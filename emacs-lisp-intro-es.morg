@title     Una introducción a la programación en Emacs Lisp
@subtitle  Revisada la tercera edición
@author    Robert J. Chassell
@traductor David Arroyo Menéndez
@define    edition-number="3.10"

Esto es una @e{Introducción a la Programación en Emacs Lisp}, para
personas que no son programadoras.

Traducido desde la edición @v{edition-number}.

Copyright © 2015 Libremanuals.

Publicado por: Libremanuals, @l{http://www.libremanuals.net/}

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; there being
no Invariant Section, with the Front-Cover Texts being “A GNU Manual”,
and with the Back-Cover Texts as in (a) below.  A copy of the license is
included in the section entitled “GNU Free Documentation License”.

(a) The FSF's Back-Cover Text is: “You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.”

* Prefacio

  La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje
  de programación llamado Emacs Lisp. El código escrito en este lenguaje
  de programación es el software –el conjunto de instrucciones– que
  cuenta al ordenador qué hacer cuando tu le das comandos. Emacs está
  diseñado de forma que se puede escribir nuevo código en Emacs Lisp y
  fácilmente instalarlo como una extensión al editor.

  (GNU Emacs es algunas veces llamado un “editor extensible”, pero hace
  mucho más que proporcionar capacidad de edición. Es mejor referirse a
  Emacs como un “entorno de computación extensible”. Sin embargo, esta
  frase es un poco pretenciosa. Es más fácil referirse a Emacs
  simplemente como un editor. De hecho, cada cosa que se hace en Emacs
  –encontrar la fecha Maya y fases de la luna, simplificar polinomios,
  depurar código, administrar ficheros, leer cartas, escribir libros–
  todas estas actividades son maneras de editar tal y como se entiende
  en el mundo.)

** ¿Por qué estudiar Emacs Lisp?

   Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un
   lenguaje de programación completo. Se puede usar Emacs Lisp como
   harías con cualquier otro lenguaje de programación.

   Quizás se quiere comprender la programación; quizás se quiere
   extender Emacs; o quizás se quiere llegar a ser un programador. Esta
   introducción a Emacs Lisp está diseñada para ayudar a empezar: para
   guiarse en el aprendizaje de los fundamentos de programación, y de
   manera más importante, para enseñar como uno mismo puede ir más allá.

** Leyendo este texto

   A través de este libro, se verá un pequeño ejemplo de programas que
   se pueden ejecutar dentro de Emacs. Si se lee este documento en Info
   dentro de GNU Emacs, se pueden ejecutar los programas como ellos
   aparecen. (Esto es fácil de hacer y se explica cuando los ejemplos se
   presentan). Alternativamente, se puede leer esta introducción como un
   libro impreso mientras se está sentando con un ordenador ejecutando
   Emacs. (Esto es lo que me gusta hacer; me gustan los libros
   impresos.) Si no se está ejecutando Emacs, todavía se puede leer este
   libro, pero en este caso, lo mejor es tratarlo como una novela, o
   como una guía para un país no visitado todavía: interesante, pero no
   es lo mismo allí.

   Mucha de esta introducción se dedica a paseos guiados de código
   usado en GNU Emacs. Estos paseos están diseñados para dos
   propósitos: primero, familiarizarse con código real que funciona
   (código que se usa cada día); y, segundo,
   familiarizarse con la manera con la que Emacs funciona. Es interesante
   ver cómo un entorno en funcionamiento se implementa. También,
   espero que se escoja el hábito de navegar a través del código
   fuente. Se puede aprender comparando código de otros con el propio
   para ganar ideas. Tener GNU Emacs es como tener una cueva del dragón
   de los tesoros.

   Además de aprender acerca de Emacs como un editor y Emacs Lisp como
   un lenguaje de programación, las guías de ejemplos guiados darán una
   oportunidad para familiarizarse con Emacs como un entorno de
   programación Lisp. GNU Emacs soporta programación y provee
   herramientas que llegarán a ser confortables usando cosas como
   @k{M-.} (la clave que invoca el comando @${find-tag}). También se
   aprenderás acerca de búffers y otros objetos que son parte del
   entorno. Aprendiendo acerca estas funcionalidades de Emacs es como
   aprender nuevas rutas alrededor de tu hogar.

   @ignore
     In addition, I have written several programs as extended examples.
     Although these are examples, the programs are real.  I use them.
     Other people use them.  You may use them.  Beyond the fragments of
     programs used for illustrations, there is very little in here that is
     `just for teaching purposes'; what you see is used.  This is a great
     advantage of Emacs Lisp: it is easy to learn to use it for work.
   @end ignore

   Finalmente, son convenientes algunas habilidades usando Emacs
   para aprender aspectos de programación que no se conocen. Con
   frecuencia se puede usar Emacs para ayudar a comprender qué puzzles
   encontrar o como hacer alguna cosa nueva. Esta auto-confianza no es
   solo un placer, también es una ventaja.

** Para quien está esto escrito

   Este texto está escrito como una introducción elemental para
   personas que no son programadoras. Quien ya programa, puede no
   estar satisfecho con este libro. La razón es que puede tener que
   llegar a ser experto leyendo manuales de referencia y ese no es el
   camino para el que este texto está organizado.

   Un programador experto que revisó este texto me dijo a mí:

   @quote
     Yo prefiero aprender desde manuales de referencia. Yo “escarbo”
     cada párrafo, y “vienen por aire” entre párrafos.

     Cuando llego al fin de un párrafo, asumo que este asunto está
     hecho, finalizado, que conozco cada cosa que necesito (con la
     posible excepción del caso en el que el siguiente párrafo empieza
     hablando acerca de eso en más detalle). Yo espero que un manual
     de referencia bien escrito no tendrá un montón de redundancia, y
     tendrá excelentes punteros a (un) lugar donde la información que
     quiero.
   @end quote

   ¡Esta introducción no está escrita para esta persona!

   Primeramente, intento decir cada cosa al menos tres veces: primero,
   introducirlo; segundo, mostrarlo en contexto; y tercero, mostrarlo
   en un contexto diferente, o revisarlo.

   Segundo, yo no siempre pongo toda la información acerca de un
   asunto en un lugar, ni mucho menos en un párrafo. Desde mi punto de
   vista, se necesita una carga bastante fuerte en el lector. En vez
   de eso intento explicar solo lo que se necesita saber en el
   momento. (Algunas veces incluyo una pequeña información extra así
   no se sorprenderá más tarde cuando la información adicional se
   presente formalmente.)

   Cuando uno lee este texto, no espera aprender todo la primera
   vez. Frecuentemente, solo necesita hacer un `reconocimiento' con
   alguno de los elementos mencionados. Mi esperanza es que haber
   estructurado el texto y dar suficientes indicios que dejarán alerta
   de lo que es importante y concentrarse en ellos.

   Es necesario “sumergirse” de algunos párrafos; no hay otro modo de
   leerlos. Pero yo he intentado guardar el número de tales párrafos.
   Este libro pretende ser como una colina que se acerca, en vez de
   una montaña.

   Esta introducción de @e{Programación en Emacs Lisp} viene
   acompañado de un documento complementario.
   @el{https://www.gnu.org/software/emacs/manual/elisp.html, El Manual
   de Referencia de GNU Emacs}. El manual de referencia tiene más
   detalles que esta introducción. En el manual de referencia, toda la
   información sobre un asunto está concentrado en un lugar. Se debe
   cambiar si se es como el programador citado arriba. Y, de acuerdo,
   después de que se ha leido esta @e{Introducción}, se encontrará el
   @e{Manual de Referencia} útil cuando se escriben propios programas.

** Historia de Lisp

   Lisp fué desarrollado primero en los 50 en el Instituto Tecnológico
   de Massachusetts para investigar en inteligencia artificial. El
   gran poder del lenguaje Lisp lo hace superior para otros propósitos
   también, tal como escribir comandos de edición y entornos
   integrados.

   GNU Emacs Lisp está fuertemente inspirado en Maclisp, que está
   escrito en el MIT en los sesenta. Está en cierto modo inspirado en
   Common Lisp, que llega a ser un estándar en los 80. Sin embargo,
   Emacs Lisp es mucho más simple que Common Lisp. (La distribución
   estándar de Emacs contiene un fichero de extensiones opctional,
   @f{cl.el}, que añade muchas funcionalidades a Emacs Lisp.)

***  Una nota para principiantes

     Aunque no se conozca GNU Emacs, se puede leer este documento de
     manera útil. Sin embargo, es mejor aprender Emacs, al menos
     aprender a moverse alrededor de la pantalla del ordenador. Uno
     puede enseñarse a sí mismo cómo usar Emacs con el tutorial
     on-line. Para usarlo, se debe escribir @k{C-h t}. (Esto significa
     que se presione la tecla @k{CTRL} y la @k{h} al mismo tiempo, y
     después se presiona @k{t}

     También, con frecuencia, me refiero a uno de los comandos de Emacs
     estándar listando las teclas que se presionan para invocar el
     comando y entonces dar el nombre del comando entre paréntesis,
     como este: @k{M-C-\} (@${indent-region}). (Si lo deseas, se pueden
     cambiar las teclas que son escritas para invocar el comando; esto
     se llama @:{rebinding}. @t{Mapas de teclado}.)  La abreviación
     @k{M-C-\} significa que se escribe la tecla @k{META}, @k{CTRL}, y
     @k{\} todo al mismo tiempo. (En muchos teclados modernos la tecla
     @k{META} es etiquetada con @k{ALT}.)  Algunas veces una
     combinación como esta es llamada keychord, puesto que es similar
     al camino de tocar un acorde en un piano. Si tu teclado no tiene
     una tecla @k{META}, la tecla con prefijo @k{ESC} es usada en lugar
     de la otra. En este caso @k{M-C-\} significa que se presiona
     @k{ESC} y entonces escribe @k{CTRL} y la tecla @k{\} al mismo
     tiempo. Pero normalmente @k{M-C-\} significa presionar la tecla
     @k{CTRL} alrededor con la tecla que está etiquetada @k{ALT} y, al
     mismo tiempo, se presiona la tecla @k{\}.

     Además de escribir una sola tecla, se puede prefijar lo que se
     escribe con @k{C-u}, que es llamado el `argumento universal'. El
     atajo @k{C-u} pasa a ser un argumento para el comando
     subsiguiente. De este modo, para indentar una región de texto
     plano a 6 espacios, se marca la región, y entonces se escribe
     @k{C-u 6 M-C-\}. (Si no se especifica un número, Emacs pasa el
     número 4 al comando o de otra manera ejecuta el comando de manera
     diferente). Vease @l{info:emacs#Argumentos Numéricos, Argumentos
     Numericos} El Manual de GNU Emacs.

     Si se está leyendo esto en Info usando GNU Emacs, se puede leer a
     través de este documento completo solo presionando la barra de
     espacio, @k{SPC}. (Para aprender acerca de Info, escribe @k{C-h
     i} y luego selecciona Info.)

     Una nota en terminología: cuando yo uso la palabra Lisp sola, con
     frecuencia me estoy refiriendo a los dialectos de Lisp en
     general, pero cuando yo hablo de Emacs Lisp, yo estoy
     refiriéndome a GNU Emacs Lisp en particular.

*** Se agradece

    Gracias a todos quienes me ayudaron con este libro. Especialmente
    agradecido a @e{Jim Blandy}, @e{Noah Friedman}, @e{Jim Kingdon},
    @e{Roland McGrath}, @e{Frank Ritter}, @e{Randy Smith}, @e{Richard
    M.  Stallman}, y @e{Melissa Weisshaus}. Gracias también a
    @e{Philip Johnson} y @e{David Stampe} por su ánimo paciente. Mis
    errores son míos.

    @right
      Robert J. Chassell @l{mailto:bob@@gnu.org}
    @end right

* Procesamiento de listas

  Para las personas nuevas, Lisp es un lenguaje de programación
  extraño. En código Lisp hay paréntesis en cada lugar. Algunas
  personas incluso reclaman que el nombre signfica 'Lots of Isolated
  Silly Parentheses' ('Montones de Paréntesis Aislados
  Estúpidos'). Pero la advertencia es sin garantías. Lisp es para
  procesamiento de listas, y el lenguaje de programación maneja
  @e{listas} (y listas de listas) poniéndolas entre paréntesis. Los
  paréntesis marcan los límites de la lista. Algunas veces una lista
  es precedida por un apóstrofe simple o una marca de cita, @'{'}@n{1}
  Las listas son las bases de Lisp.

** Listas Lisp

   En Lisp, una lista como esta: @c{'(rosa violeta margarita
   mantequilla)}. Esta lista es precedida por un apóstrofe
   simple. Podría estar bien escrita como sigue, que mira más como el
   tipo de lista con la que se está familiarizado:

   @src elips
     '(rosa
       violeta
       margarita
       mantequilla)
   @end src

   Los elementos de esta lista son los nombres de las 4 flores
   diferentes, separadas por espacios en blanco y alrededor de
   paréntesis, como flores en un campo con un muro de piedras
   alrededor de ellas.

*** Números, listas dentro de listas

    Las listas pueden también tener números dentro, como en esta
    lista: @c{(+ 2 2)}. Esta lista tiene un signo más, @'{+}, seguido
    por dos @'{2}, cada uno separado por espacios en blanco.

    En Lisp, datos y programas están representados por el mismo
    camino; que son ambas listas de palabras, números, u otras listas,
    separadas por espacios en blanco y alrededor de paréntesis. (Desde
    que un programa mira como datos, un programa puede fácilmente
    servir como datos para otros; esta es una funcionalidad muy
    poderosa de Lisp.) (Incidentalmente, estas dos marcas de
    paréntesis @e{no} son listas Lisp, porque contienen @'{;} y @'{.}
    como marcas puntuación.)

    @need 1200
    Aquí está otra lista, esta vez con una lista dentro:

    @example
      '(esta lista tiene (una lista dentro de ella))
    @end example

    Los componentes de esta lista son las palabras @'{esta},
    @'{lista}, @'{tiene}, y la lista @'{(una lista dentro de
    ella)}. La lista interior es hecha de las palabras @'{una},
    @'{lista}, @'{dentro}, @'{de}, @'{ella}.

*** Átomos Lisp

    En Lisp, hemos estado llamando a las palabras @:{átomos}. Este
    término viene desde el significado de la palabra átomo, que
    significa indivisible. Tan lejos como Lisp es concebido, las
    palabras que hemos estado usando en las listas no pueden ser
    divididas dentro de pequeñas partes y todavía significan la misma
    cosa como parte de un programa; como con números y caracteres de
    símbolos simples como @'{+}. Por otro lado, no como un antiguo
    átomo, una lista puede ser dividida en pequeñas partes. Ver @l{Car
    cdr y cons, seccion @'c{car} en @e{Funciones Fundamentales}}.

    En una lista, los átomos son separados de otros por espacios en
    blanco. Ellos pueden estar a la derecha y cerca de un paréntesis.

    Técnicamente hablando, una lista en Lisp consiste de paréntesis
    alrededor de átomos separados por espacios en blanco o alrededor
    de otras lista o alrededor de ambos átomos u otras listas. Una
    lista puede tener solo un átomo en ella o no tener nada en ella
    para todo.  Una lista con nada dentro se ve como esto: @c{()}, y
    está llamado la @:{lista vacía}. No como cualquier otra cosa, un
    lista vacía es considerad ambos un átomo y una lista al mismo
    tiempo.


    La representación impresa de ambos átomos y listas se llaman
    @:{expresiones simbólicas} o, más concisamente,
    @:{s-expresiones}. La palabra @:{expresión} por sí mismo puede
    referir o bien la representación impresa, o para el átomo o la
    lista como ella es manejada internamente en el ordenador. Con
    frecuencia, la personas usan el término @:{expresión}
    indiscriminadamente. (También, en muchos textos, la palabra
    @:{forma} se usa como un sinónimo para la expresión.)

    Incidentalmente, los átomos que hacen que nuestro universo fuese
    nombrado así cuando ellos fueron pensados para ser indivisibles;
    pero han sido encontrados átomos físicos que no son
    indivisibles. Las partes pueden dividir un átomo o puede
    fisionarse en 2 partes de igual tamaño. Los átomos físicos fueron
    nombrados prematuramente, antes de que su verdadera naturaleza
    fuese encontrada. En Lisp, ciertos tipos de átomos, como un array,
    pueden ser separados en partes; pero el mecanismo de hacer esto es
    diferente de el mecanismo para dividir una lista. Tan lejos como
    las operaciones de las listas son concebidas, los átomos de una
    lista son indivisibles.

    Como en Inglés, los significado de las letras de componentes de un
    átomo Lisp son diferentes desde el significado de las letras que
    crean una palabra. Por ejemplo, la palabra Suramericana @'{ai}, es
    completamente diferente de las dos palabras @'{a}, e @'{i}.

    Hay muchos tipos de átomos naturales, pero solo unos pocos en
    Lisp: por ejemplo, @:{números}, tales como 37, 511, o 1729, y
    @:{símbolos}, tales como @'{+}, @'{foo}, o @'{forward-line}. Las
    palabras que hemos listado en los ejemplos de debajo son todos
    símbolos. Cada día de conversación Lisp, la palabra “átomo” no se
    usa con frecuencia, porque los programadores normalmente intentan
    ser más específicos acerca de que tipo de átomo están tratando. La
    programación Lisp es sobre todo de símbolos (y algunas veces
    números) con listas. (De ese modo, tres palabras rodeadas de
    paréntesis son una apropiada lista en Lisp, desde que ello
    consiste en átomo, que en este caso son símbolos, separados por
    espacios en blanco y cerrados por paréntesis, sin cualquier
    puntuación no Lisp.)

    Texto entre comillas –incluso frases de párrafos– son también un
    átomo. Aquí hay un ejemplo:

    @example
      '(esta lista incluye "texto entre comillas.")
    @end example

    En Lisp, todo el texto citado incluyendo la marca de puntuación y
    los espacios en blanco son un átomo simple. Este tipo de átomo es
    llamado @:{string} (por 'cadena de caracteres') y es el tipo de
    cosa que es usada para mensajes que un ordenador puede imprimir
    para que un humano lea. Las cadenas son un tipo diferente de átomo
    en vez de números, o símbolo y son usados de manera diferente.

*** Espacios en blanco en listas

    La cantidad de espacios en blanco en una lista no importa. Desde
    el punto de vista del lenguaje Lisp,

    @example
      '(esta lista
         parece esto)
    @end example

    es exactamente lo mismo que esto:

    @example
      '(esta lista parece esto)
    @end example

    Ambos ejemplos muestran que Lisp es la misma lista, la lista hecha
    de los símbolos @'{esta}, @'{lista}, @'{parece}, y @'{esto} en
    este orden.

    Espacios en blanco extra y nuevas líneas son diseñadas
    para crear una lista más legible por humanos. Cuando Lisp lee la
    expresión, asimila los espacios en blanco extra (pero necesita tener
    al menos un espacio entre átomos en orden para contarlos aparte.)

    Aunque parezca raro, los ejemplos que hemos visto cubren casi todo
    lo que Lisp tiene. Cualquier otra lista en Lisp ve más o menos
    como uno de estos ejemplos, excepto que la lista puede ser más
    larga y más compleja. En resumen, una lista está entre paréntesis,
    una cadena está entre comillas, un símbolo parece como una
    palabra, y un número parece un número. (Para ciertas situaciones,
    corchetes, puntos y otros caracteres especiales pueden ser usados;
    sin embargo; iremos bastante lejos sin ellos.)

*** GNU Emacs te ayuda a escribir listas

    Cuando se escribe una expresión Lisp en GNU Emacs usando bien el
    modo de Interacción Lisp o el modo Emacs Lisp, están disponibles
    varios comandos para formatear la expresión Lisp, de modo que sea
    fácil de leer. Por ejemplo, presionando la tecla @k{TAB}
    automáticamente se indenta la línea del cursor que está en la
    cantidad correcta. Un comando para indentar apropiadamente el
    código en una región está asociado a @k{M-C-\}. La indentación
    está diseñada de manera que se pueden qué elementos de una lista
    pertenencen a qué lista – los elementos de una sublista están más
    indentados que los elementos de una lista cerrada.

    Además, cuando se escribe un paréntesis de cierre, Emacs
    momentáneamente salta el cursor atrás para hacer el matching
    (emparejamientos) con el paréntesis de apertura, para ver cuál
    es. Esto es muy útil, ya que cada lista que se escribe en Lisp
    debe tener sus parén emparejados con sus paréntesis de
    apertura. (Ver @l{info:emacs#ModosMayores, El Manual de GNU
    Emacs}, para más información acerca de modos de Emacs.)

** Ejecutar un programa

   Una lista en Lisp –cualquier lista– es un programa listo para ser
   ejecutado. Si lo ejecutas (lo que la jerga Lisp llama @:{evaluar}),
   el ordenador hará una de las tres cosas: nada excepto devolverte la
   lista misma; enviar un mensaje de error; o, tratar el primer
   símbolo en la lista como un comando para hacer alguna
   cosa. (¡Normalmente, es el último de estas tres cosas de lo que
   realmente se quiere!).

   El apóstrofe, @c{'}, que se pone enfrente de algún ejemplo de
   listas en secciones precedentes se llama @:{quote}; (comilla);
   cuando precede una lista, Lisp no tiene que hacer nada con la
   lista, otra que la toma como está escrita. Pero si no hay una cita
   precediendo la lista, el primer ítem de la lista es especial: es un
   comando para que el ordenador obedezca. (En Lisp, estos comandos
   son llamados @e{funciones}.) La lista @c{(+ 2 2)} muestra debajo
   que no tuvo un quote en frente, así Lisp comprende que @c{+} es una
   instrucción para hacer alguna cosa con el resto de la lista: añadir
   los números que siguen.

   Si está leyendo esto dentro de GNU Emacs en Info, aquí está como
   puedes evaluar una lista: posiciona tu cursor de manera inmediata
   después de la siguiente lista y escribe @k{C-x C-e}:

   @example
     (+ 2 2)
   @end example

   Verás que el número @c{4} aparece en el área echo. (La jerga que se
   usa es “evaluar la lista.” El área echo es la línea arriba de la
   pantalla que muestra o hace “echo” del texto.) Ahora intenta la
   misma cosa con una lista entre comillas: posiciona el cursor
   correcto después de la siguiente lista y escribe @k{C-x C-e}:

   @example
     '(esto es una lista comilla)
   @end example

   Tu verás @c{(esto es una lista citada)} aparece en el área echo.

   En ambos casos, lo que estás haciendo es dar un comando al programa
   dentro de GNU Emacs llamado @:{intérprete Lisp} – dando al
   intérprete un comando para evaluar la expresión. El nombre del
   intérprete Lisp viene de la palabra para la tarea hecha por un
   humano que viene con el significado de una expresión – quien lo
   “interpreta”.

   También se puede evaluar un átomo que no es parte de una lista –
   uno que no está rodeado por paréntesis; de nuevo, el intérprete
   Lisp traduce desde la expresión humanamente legible al lenguaje del
   ordenador. Pero antes de discutir esto (ver @l{Variables}),
   nosotros discutiremos lo que el intérprete de Lisp hace cuando tu
   creas el error.

** @t{Generar un mensaje de error}

   No se preocupe si genera un mensaje de error de manera accidental,
   se dará un comando para que el intérprete de Lisp lo genere. Esto
   es una actividad sin daño; y en efecto, con frecuencia se intenta
   generar mensajes de error de manera intencional. Una vez se
   comprende la jerga, los mensajes de error pueden ser
   informativos. En vez de ser llamados mensajes de “error”, deberían
   ser llamados mensajes de “ayuda”. Esto son como signos para un
   viajero en un país extraño; descifrarlos puede ser duro, pero una
   vez comprendidos, pueden encontrar el camino.

   El mensaje de error está generado por un depurador de GNU
   Emacs. Se 'introduce el depurador'. Se obtiene el depurador
   escribiendo @k{q}.

   Lo que se hace es evaluar una lista que no está citada y no tiene
   un comando con significado como su primer elemento. Aquí hay una
   lista casi exacta a la usada, pero sin la cita simple en vez de
   eso. Posicione el cursor derecho después y escribe @k{C-x C-e}:

   @example
     (esto es una lista sin cita)
   @end example

   @ignore
     What you see depends on which version of Emacs you are running.  GNU
     Emacs version 22 provides more information than version 20 and before.
     First, the more recent result of generating an error; then the
     earlier, version 20 result.

     In GNU Emacs version 22, a @f{*Backtrace*} window will open up and
     you will see the following in it:
   @end ignore

   Una ventana @f{*Backtrace*} se abrirá y se verá lo siguiente:

   @example
     –––- Buffer: *Backtrace* –––-
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     –––- Buffer: *Backtrace* –––-
   @end example

   Su cursor estará en esta ventana (puede tener que esperar unos
   pocos segundos antes de llegar a ser visible). Para salir del
   depurador y de su ventana, escribe:

   @example
     q
   @end example

   Por favor, escriba @k{q} bien ahora, así llegará a ser confidente
   de que se pueda bajar el depurador. Entonces, escribe @k{C-x C-e}
   de nuevo y se reintroduce.

   Basado en lo que ya se sabe, se puede leer este mensaje de error.

   Si se lee el búffer @f{*Backtrace*} desde arriba; cuenta lo que
   Emacs hace. Cuando se escribe @k{C-x C-e}, se hizo una llamada
   interactiva el comando @c{eval-last-sexp}. @c{eval} es una
   abreviación para 'evaluar' y @c{sexp} es una abreviación para la
   'expresión simbólica'. El comando significa 'evalúa la última
   expresión simbólica', que es la expresión ahora antes de tu cursor.

   En cada línea de abajo se cuenta lo que evaluó el siguiente
   intérprete. La acción más reciente está alta. El búffer es llamado
   @f{*Backtrace*} porque te permite habilitar la traza de Emacs hacia
   atrás.

   Arriba del búffer @f{*Backtrace*}, se verá la línea:

   @example
     El depurador introdujo el error Lisp: (void-function this)
   @end example

   El intérprete Lisp intentó evaluar el primer átomo de la lista, la
   palabra @'{this}. Esta acción que generaba el mensaje de error
   @'{void-function this}.

   El mensaje contiene las palabras @'{void-function} y @'{this}.

   La palabra @'{function} fué mencionada antes. Es una palabra muy
   importante. Para nuestros propósitos, se puede definir eso diciendo
   que una @:{función} (@e{function}) es un conjunto de instrucciones
   para el ordenador que cuenta al ordenador hacer alguna cosa.

   Ahora se puede empezar a comprender el mensaje de error:
   @'{void-function this}. La función (que es, la palabra @'{this}) no
   tiene una definición de cualquier conjunto de instrucciones del
   ordenador para llevarlo.

   La palabra ligeramente extraña, @'{void-function}, está diseñada
   para cubrir el camino en que Emacs Lisp está implementado, que es
   cuando un símbolo no tiene una definición de función adjunta a eso,
   el lugar que contendría las instrucciones es 'vacío'.

   Por otro lado, desde que fuimos capaces de añadir 2 más 2 de manera
   exitosa, evaluando @c{(+ 2 2)}, se puede inferir que el símbolo
   @c{+} debe tener un conjunto de instrucciones para que el ordenador
   obedezca y estas instrucciones deben añadir los números que siguen
   el @c{+}.

   Es posible prevenir que Emacs entre en el depurador en casos como
   este. No se explicará cómo hacer esto aquí, pero se mencionará que
   el resultado se parece, porque se puede encontrar una situación
   similar si hay un error en algún código Emacs que se está
   usando. En tales casos, se verá una línea del mensaje de error; que
   aparecerá en el área echo y parecerá así:

   @example
     La definición de la función de símbolos está
     vacío:@: this
   @end example


   @ignore
     (Also, your terminal may beep at you–some do, some don't; and others
     blink.  This is just a device to get your attention.)
   @end ignore

   El mensaje aparece tan pronto se escribe una tecla, incluso para
   mover el cursor.

   Conocemos el significado de la palabra @'{Símbolo}. Se refiere al
   primer átomo de la lista, la palabra @'{este}. La palabra
   @'{función} se refiere a las instrucciones que cuentan al ordenador
   que hacer. (Técnicamente, el símbolo cuenta al ordenador donde
   encontrar las instrucciones, pero esto es una complicación que
   podemos ignorar por el momento.)

   El mensaje de error puede ser comprendido: @'{La definición del
   símbolo está vacío: este}. El símbolo (que es, la palabra @'{este})
   le faltan instrucciones para que el ordenador funcione.

** Nombres de símbolos y definiciones de funciones

   Se puede articular otra característica de Lisp basada en lo que se
   discutió hace tiempo –una característica importante: un símbolo,
   como @c{+}, no es en sí mismo el conjunto de instrucciones que el
   ordenador transmite. En vez de eso, el símbolo está usado, quizás
   temporalmente, como un camino de localizar la definición o conjunto
   de instrucciones. Lo que se ve es el nombre a través del que las
   instrucciones se pueden encontrar. Los nombres de personas trabajan
   por el mismo camino. Puede ser llamado @'{Bob}; sin embargo, no soy
   @'{B}, @'{o}, @'{b} pero soy, o fuí, la consciencia consistente
   asociada con una forma de línea particular. El nombre no soy yo,
   pero puedo ser usado para referirme a mí.

   En Lisp, un conjunto de instrucciones puede adjuntarse a varios
   nombres. Por ejemplo, las instrucciones de ordenador para añadir
   números pueden ser enlazados al símbolo @c{más} tan bien como el
   símbolo @c{+} (y son en algunos dialectos de Lisp). Entre humanos,
   puede referirse a @'{Robert} tan bien como @'{Bob} y en otras
   palabras también.

   Por otro lado, un símbolo puede tener solo una función adjunta en
   un momento. De otro modo, el ordenador estaría confundido acerca de
   qué definición usar. Si este fuera el caso, solo una persona en el
   mundo podría llamarse @'{Bob}. Sin embargo, la definición de
   función para la que el nombre se refiere puede ser cambiada de
   manera legible. (Ver @l{Instalar, Instalar una Definición de
   Función}.)

   Puesto que Emacs Lisp es grande, es costumbre nombrar símbolos de
   un modo que identifique la parte de Emacs de la función que
   pertenece. De este modo, todos los nombres de funciones que tratan
   con Texinfo empiezan con @'{texinfo-} y estas funciones que tratan
   con la lectura de correo empiezan con @'{rmail-}.

** El intérprete Lisp

   Basado en lo que se ha visto, ahora se puede empezar a entender lo
   que el intéprete Lisp hace cuando ejecutamos un comando para
   evaluar una lista. Primero, examina si hay un símbolo quote (cita)
   antes de la lista; si el intérprete da la lista. Por otro lado, si
   no hay cita, el intéprete mira si el primer elemento en la lista
   tiene una definición de función. De otro modo, el intérprete
   imprime un mensaje de error.

   Así es como Lisp trabaja. Simple. Hay complicaciones añadidas que
   tendremos en un minuto, pero estas son fundamentales. De acuerdo,
   para escribir programas Lisp, se necesita conocer como escribir
   definiciones de función y adjuntarlas a nombres, y como hacer esto
   sin confundirnos a nosotros mismos o al ordenador.

*** Complicaciones

    Ahora, una primera complicación. Además de las listas, el
    intérprete Lisp puede evaluar un símbolo sin el símbolo cita
    (quote) y no tiene paréntesis alrededor. El intérprete Lisp
    intentará determinar el valor del símbolo como una
    @:{variable}. Esta situación está descrita en la sección acerca de
    variable. (Ver @l{Variables}.)

    La segunda complicación ocurre debido a que algunas funciones son
    inusuales y no funcionan de la manera usual. Estas que no son
    llamadas @:{formas especiales}. Son usadas para trabajos
    especiales, como definir una función, y no son muchas de ellas. En
    los siguientes próximos capítulos, se introducirán varias de las
    formas especiales más importantes.

    La tercera y final complicación es la siguiente: si la función que
    el intérprete Lisp está buscando no es una forma especial, y si
    eso es parte de una lista, el intérprete Lisp quiere ver si la
    lista tiene una lista dentro. Si hay una lista dentro, el
    intérprete Lisp primero mira qué hacer con la lista dentro, y
    entonces trabaja en la lista de fuera. Si todavía hay otra lista
    embebida dentro de la propia lista, eso funciona en esta primero,
    y así. Eso siempre funciona en la lista más interior. El
    intérprete funciona más interior primero, para evaluar el
    resultado de esta lista. El resultado puede ser usado por la
    expresión entre paréntesis.

    De otra manera, el intérprete trabaja de izquierda a derecha, desde
    una expresión a la siguiente.

*** Compilación de bytes

    Otro aspecto de interpretación: el intérprete Lisp es capaz de
    interpretar dos tipos de entidad: código humanemente legible, en
    el que focalizarse exclusivamente, y especialmente código
    procesado, llamado @:{byte compilado}, que no es humanamente
    legible. El código máquina compilado se ejecuta más rápido que el
    código humanamente legible.

    Tu puedes transformar código legible por humanos dentro de código
    compilado ejecutando un de los comandos compilados tales como
    @c{byte-compile-file}. El código compilado es normamelte
    almacenado en un fichero que finaliza con una extensión @f{.elc}
    en vez de una extensión @f{.el}. Verás ambos tipos de ficheros en
    el directorio @f{emacs/lisp}; los ficheros para leer estos son con
    extensiones @f{.el}.

    Como una cuestión práctica, para la mayoría de las cosas tu
    podrías personalizar o extender Emacs, no necesitas compilar byte;
    y no discutirás el asunto aquí. Ver @l{info:emacs#Compilación de
    Byte, seccion 'Compilación de Byte' en @e{El Manual de Referencia
    de GNU Emacs}, para una completa descripción de compilación byte.

*** Evaluación

    Cuando el intérprete Lisp funciona en una expresión, el término
    para la actividad es llamada @:{evaluación}. Decimos que el
    intérprete 'evalúa la expresión'. Yo he usado este término varias
    veces antes. La palabra viene desde su uso en el lenguaje de cada
    día, 'para cierto valor o cantidad de; para estimar' de acuerdo a
    @e{Webster's New Collegiate Dictionary}.

*** Cómo el intérprete actúa

    Después de evaluar una expresión, el intérprete Lisp normalmente
    @:{devuelve} el valor que el ordenador produce trayendo las
    instrucciones encontradas en la definición de la función, o quizás
    dará esta función y producirá un mensaje de error. (El intérprete
    puede también quedarse colgado, así hablar, a una función
    diferente o puede intentar repetir continuamente que está haciendo
    para siempre y siempre en lo que está llamado como un 'bucle
    infinito'. Estas acciones son menos comunes; y pueden
    ignorarse). Más frecuentemente, el intérprete devuelve un valor.

    Al mismo tiempo el intérprete devuelve un valor, puede hacer
    cualquier cosa más también, tal como mover un cursor o copiar un
    fichero; este otro tipo de acción es llamada @:{efecto lateral}.
    Acciones que los humanos pensamos que son importantes tales como
    imprimir resultados son, con frecuencia, “efectos laterales” al
    intérprete Lisp. La jerga puede sonar peculiar, pero cambiar que
    es fácil aprender a usar efectos laterales.

    En resumen, evaluando una expresión simbólica normalmente
    causa que el intérprete devuelva un valor y quizás trajo un efecto
    lateral; o al menos produce un error.

*** Evaluando listas propias

    Si la evaluación se aplica a una lista que está dentro de una
    lista de fuera, se puede usar el valor devuelto por la primera
    evaluación como información cuando la lista de fuera está
    evaluada. Esto explica por qué las expresiones propias son
    evaluadas primero: los valores devueltos son usados por las
    expresiones de fuera.

    Nosotros podemos investigar este proceso evaluando otro ejemplo
    adicional. Deja tu cursor después de la siguiente expresión y
    escribe @k{C-x C-e}:

    @example
      (+ 2 (+ 3 3))
    @end example

    El número 8 aparecerá en el área echo.

    Lo que ocurre es que el intérprete Lisp primero evalúa la
    expresión propia, @c{(+ 3 3)}, para que el valor 6 se devuelva;
    entonces evalúa la expresión de fuera como si fuera escrita
    @c{(+ 2 6)}, que devuelve el valor 8. Puesto que no hay más
    expresiones cerradas para evaluar el intérprete imprime este valor
    en el área echo.

    Ahora es fácil comprender el nombre de los comandos invocados por
    atajos @k{C-x C-e}: el nombre es @c{eval-last-sexp}. Las letras
    @c{sexp} son una abreviación para la 'expresión simbólica', y
    @c{eval} es una abreviación para 'evaluar'. El comando significa
    'evaluar la última expresión simbólica'.

    Como un experimento, tu puedes intentar evaluar la expresión
    poniendo el cursor al principio de la siguiente línea
    inmediatamente siguiendo la expresión, o dentro de la expresión.

    Aquí hay otra copia de la expresión:

    @example
      (+ 2 (+ 3 3))
    @end example

    Si se posiciona el cursor al principio de la línea en blanco que
    inmediatamente sigue la expresión y escribes @k{C-x C-e}, todavía
    se obtendrá el valor 8 impreso en el área echo. Ahora intenta
    poner el cursor dentro de la expresión. Si se pone bien después
    del siguiente al último paréntesis (así aparece para situarse
    arriba del último paréntesis), ¡se obtendrá un 6 impreso en el
    área echo!  Esto es porque el comando evalúa la expresión @c{(+ 3
    3)}.

    Ahora se pone el cursor inmediatamente después de un
    número. Escribe @k{C-x C-e} y se tendrá el número en sí. En Lisp,
    si evalúas un número, tu tienes el número en sí–esto es cómo los
    números difiere desde los símbolos. Si evalúas una lista empezando
    con un símbolo como @c{+}, tendrás un valor devuelto que es el
    resultado del ordenador trayendo las instrucciones en la
    definición de función adjunta a este nombre. Si un símbolo por sí
    mismo es evaluado, alguna cosa diferente ocurre, como veremos en
    la siguiente sección.

** @t{Variables}

   En Emacs Lisp, un símbolo puede tener un valor adjunto como puede
   tener una definición de función adjunta. Las dos son diferentes. La
   definición de función es un conjunto de instrucciones que un
   ordenador obedece. Un valor, por otro lado, es alguna cosa como un
   número o un nombre, que puede variar (que es porque tal símbolo es
   llamado variable). El valor de un símbolo puede ser una expresión
   en Lisp, tal como un símbolo, número, lista, o cadena. Un símbolo
   que tiene un valor es con frecuencia llamado una @:{variable}.

   Un símbolo puede tener ambos una definición de función y un valor
   adjunto al mismo tiempo. O puede tener solo uno u otro. Los dos
   están separados. Esto es algo similar al camino, el nombre
   Cambridge puede referirse a la ciudad en Massachusetts y tener
   alguna información adjunta al nombre tan bien, tal como “gran
   centro de programación”.

   @ignore
     (Incidentally, in Emacs Lisp, a symbol can have two
     other things attached to it, too: a property list and a documentation
     string; these are discussed later.)
   @end ignore

   Otro camino para pensar acerca de esto es imaginar un símbolo como
   ser una caja de cajones. La definición de función es poner en el
   cajón que maneja el valor que puede ser cambiado sin afectar los
   contenidos del cajón que maneja la definición de función, y
   viceversa.

** @c{fill-column}, un ejemplo de variable

   La variable @c{fill-column} ilustra un símbolo con un valor
   adjunto: en cada buffer de GNU Emacs, este símbolo establece algún
   valor, normalmente 72 o 70, pero algunas veces algún otro
   valor. Para encontrar el valor de este símbolo, evalúalo por sí
   mismo. Si está leyendo esto en Info dentro de GNU Emacs, tu puedes
   hacer esto poniendo el cursor después del símbolo y escribiendo
   @k{C-x C-e}:

   @example
     fill-column
   @end example

   Después de que yo escribiera @k{C-x C-e}, Emacs imprimió el número
   72 en mi área echo. Este es el valor por el que @c{fill-column} es
   escogido para mi, porque yo lo escribo. Puede ser diferente para ti
   en tu búffer Info. Sepa que el valor devuelto como una variable es
   impreso exactamente por el mismo camino que el valor devuelto por
   una función trayendo sus instrucciones. Puesto que el punto de
   vista del intérprete Lisp, es un valor devuelto. El tipo de
   expresión viene de ceder a la cuestión una vez el valor se conoce.

   Un símbolo puede tener cualquier valor adjunto a ello o, usar la
   jerga, se puede @:{bind} (asociar) la variable a un valor: a un
   número, tal como 72; a una cadena, @c{\"tal como esta\"}; a una
   lista, tal como @c{(abeto pino roble)}; podemos incluso asociar una
   variable a una definición de función.

   Un símbolo puede ser emparejado por un valor en varios caminos. Ver
   @l{Configurando el valor de una variable}, para información acerca
   de un camino para hacer esto.

*** Mensaje de error para un símbolo sin una función

    Cuando se evalúa @c{fill-column} para encontrar el valor de una
    variable, no se ponen paréntesis alrededor de la palabra. Esto es
    porque no pretendemos usarlos como un nombre de función.

    Si @c{fill-column} fuese el primer o único elemento de una lista,
    el intérprete de Lisp intentaría encontrar la definición de
    función adjunta. Pero @c{fill-column} no tiene definición de
    función. Prueba evaluando esto:

    @example
      (fill-column)
    @end example

    Se creará un buffer @f{*Backtrace*} que dice:

    @example
      –––- Buffer: *Backtrace* –––-
      Debugger entered--Lisp error: (void-function fill-column)
        (fill-column)
        eval((fill-column))
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      –––- Buffer: *Backtrace* –––-
    @end example

    (Recuerda, para salir del depurador y crear la ventana del
    depurador para ir fuera, escribe @k{q} en el buffer
    @f{*Backtrace*}.)

    @ignore
      In GNU Emacs 20 and before, you will produce an error message that says:

      @example
        La definición de símbolos de función:@: fill-column
      @end example

      (The message will go away as soon as you move the cursor or type
      another key.)
    @end ignore

*** Mensaje de error para un símbolo sin un valor

    Si se intenta evaluar un símbolo que no tiene un valor asociado,
    recibirá un mensaje de error. Se puede ver esto experimentando con
    nuestra suma 2 más 2. En la siguiente expresión, pon el cursor
    correcto después de @c{+}, antes del primer número 2, escribe
    @k{C-x C-e}:

    @example
      (+ 2 2)
    @end example

    En GNU Emacs 22, se creará un buffer @f{*Backtrace*} que dice:

    @example
      –––- Buffer: *Backtrace* –––-
      Debugger entered--Lisp error: (void-variable +)
        eval(+)
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      –––- Buffer: *Backtrace* –––-
    @end example

    (De nuevo, se puede salir del depurador escribiendo @k{q} en el
    búffer @f{*Backtrace*}.)

    Esta traza es diferente desde los muy primeros mensajes de error
    que vimos, que dijimos, @'{El depurador introdujo--errores Lisp:
    (esta función está vacía)}. En este caso, la función no tiene una
    valor como una variable; mientras en el otro mensaje de error, la
    función (la palabra 'this') no tuvo una definición.

    En este experimento con el @c{+}, lo que se hizo fué causar que el
    intérprete Lisp evalúe el @c{+} y busque el valor de la variable
    en vez de la definición de la función. Nosotros hicimos esto
    dejando el cursor correcto después del símbolo en vez de después
    de los paréntesis que cierran la lista como hicimos antes. Como
    consecuencia, el intérprete Lisp evaluó la s-expresión precedente,
    que en este caso fué el @c{+} en sí.

    Desde que @c{+} no tiene un valor asociado, solo la definición de
    función, el mensaje de error reportado que el valor del
    símbolo como una variable estaba vacío.

    @ignore
      In GNU Emacs version 20 and before, your error message will say:

      @example
        El valor de símbolo como variable está
        vacío:@: +
      @end example

      @noindent
      The meaning is the same as in GNU Emacs 22.
    @end ignore

** Argumentos

   Para ver cómo la información pasa a funciones, se permite mirar de
   nuevo a nuestro viejo standby, la adición de dos más dos. En Lisp,
   esto es escrito como sigue:

   @example
     (+ 2 2)
   @end example

   Si se evalúa esta expresión, el número 4 aparecerá en tu área
   echo. Lo que el intérprete de Lisp hace es añadir los número que
   sigue el @c{+}.

   Los números añadidos por @c{+} son llamados @:{argumentos} de la
   función @c{+}. Estos números son la información que es dada para o
   @:{pasada} a la función.

   La palabra 'argumento' viene del ámbito de las matemáticas y no se
   refiere a una disputa entre 2 personas, sino que se refiere a la
   información presentada a la función, en este caso, al @c{+}. En
   Lisp, los argumentos a una función son los átomos o listas que
   siguen la función. Los valores devueltos por la evaluación de estos
   átomos o listas son pasados a la función. Funciones diferentes
   requieren diferentes números de argumentos; algunas funciones no
   requieren ninguno más.@n{2}

*** Tipos de argumentos de datos

    Los tipos de datos que deberían ser pasados a una función dependen
    de que tipo de información usan. Los argumentos a una función
    tales como @c{+} deben tener valores que son números, puesto que
    @c{+} añade números. Otras funciones usan diferentes tipos de
    datos para sus argumentos.

    Por ejemplo, la función @c{concat} enlaza o une dos o más cadenas
    de texto para producir una cadena. Los argumentos son cadenas. La
    concatenación de los dos caracteres de cadenas @c{abc}, @c{def}
    producen la cadena simple @c{abcdef}. Esto puede ser visto
    evaluando lo siguiente:

    @example
      (concat "abc" "def")
    @end example

    El valor producido para evaluar esta expresión es @c{"abcdef"}.

    Una función tal como @c{substring} usa como argumento tanto una
    cadena como números. La función devuelve una parte de la cadena,
    una subcadena del primer argumento. Esta función toma tres
    argumentos. Su primer argumento es la cadena de caracteres, el
    segundo y tercer argumento son números que indican el principio y
    el fin de la subcadena. Los números son un contaje del número de
    caracteres (incluyendo espacios y puntuaciones) desde el principio
    de la cadena.

    Por ejemplo, si evalúa lo siguiente:

    @example
      (substring "El rápido zorro marrón saltó." 10 15)
    @end example

    se verá @c{"zorro"} en el área echo. Los argumentos son la cadena
    y los dos números.

    Nótese que la cadena pasada a @c{substring} es un átomo simple
    incluso aunque sea hecho de varias palabras separadas por
    espacios. Lisp cuenta cada cosa entre dos marcas de citas como
    parte de la cadena, incluyendo los espacios. Se puede pensar la
    función @c{substring} como una forma de 'despedazar átomos' ya que
    toma un átomo indivisible y extrae una parte. Sin embargo,
    @c{substring} es solo capaz de extraer una subcadena desde un
    argumento que es una cadena, no otro tipo de átomo tal como un
    número o símbolo.

*** Un argumento como el valor de una variable o lista

    Un argumento puede ser un símbolo que devuelva un valor cuando es
    evaluado. Por ejemplo, cuando el símbolo @c{fill-column} por sí
    mismo es evaluado, devuelve un número. Este número puede ser usado
    en una adición.

    Posicionar el cursor después la siguiente expresión y escribe
    @k{C-x C-e}:

    @example
      (+ 2 fill-column)
    @end example

    El valor será un número dos más que tu tienes evaluando
    @c{fill-column} solo. Para mí, este es 74, porque mi valor de
    @c{fill-column} es 72.

    Como se ha visto, un argumento puede ser un símbolo que devuelve
    un valor cuando se evalúa. Además, un argumento puede ser una
    lista que devuelve un valor cuando es evaluada. Por ejemplo, en la
    siguiente expresión, los argumentos para la función @c{concat} son
    las cadenas @c{"Los"} y @c{" zorros rojos."} y la lista
    @c{(number-to-string (+ 2 fill-column))}.

    @example
      (concat "Los " (number-to-string (+ 2 fill-column)) " zorros rojos.")
    @end example

    Si se evalúa esta expresión –y si, como con mi Emacs,
    @c{fill-column} se evalúa a 72– aparecerá @c{"Los 74 zorros
    rojos."} en el área echo. (Nótese que se debe poner espacio
    después de la palabra @'{Los} y antes de la palabra @'{zorros} y
    así es como aparecerá en la cadena final. La función
    @c{number-to-string} convierte los enteros que la función de
    adición devuelve en una cadena. @c{number-to-string} también se
    conoce como @c{int-to-string}.)

*** Número de variables de argumentos

    Algunas funciones, tales como @c{concat}, @c{+}, o @c{*}, toman
    cualquier número de argumentos. (El @c{*} es el símbolo para
    multiplicar.) Esto puede ser visto evaluando cada uno de las
    siguientes expresiones en el camino usual. Que verás en el área
    echo que está impresa en este texto después de @'{@result{}}, que
    puedes leer como 'evaluar a'.

    En el primer conjunto, las funciones no tienen argumentos:

    @example
      (+)       ⇒ 0

      (*)       ⇒ 1
    @end example

    En este conjunto, las funciones tienen un argumento cada una:

    @example
      (+ 3)     ⇒ 3

      (* 3)     ⇒ 3
    @end example

    En este conjunto, las funciones tienen tres argumentos cada una:

    @example
      (+ 3 4 5) ⇒ 12

      (* 3 4 5) ⇒ 60
    @end example

*** Usando el tipo incorrecto de objeto como un argumento

    Cuando a una función se le pasa un argumento del tipo incorrecto,
    el interpréte Lisp produce un mensaje de error. Por ejemplo, la
    función @c{+} espera los valores de sus argumentos para ser
    números. Como un experimento nosotros podemos pasar el símbolo
    citado @c{hola} en vez de un número. Posicionar el cursor después
    la siguiente expresión y escribir @k{C-x C-e}:

    @example
      (+ 2 'hola)
    @end example

    Cuando se hace esto se generará un mensaje de error. Lo qué ha
    ocurrido es que @c{+} ha intentado añadir el 2 para el valor
    devuelto por @c{'hola}, pero el valor devuelto por @c{'hola} es el
    símbolo @c{hola}, no un número. Solo los números pueden ser
    añadidos. Así @c{+} podría no encarrilar su adición.

    Se creará e introducirá un búffer @f{*Backtrace*} que dice:

    @example
      –––- Buffer: *Backtrace* –––-
      Debugger entered--Lisp error:
               (wrong-type-argument number-or-marker-p hello)
        +(2 hello)
        eval((+ 2 (quote hello)))
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      –––- Buffer: *Backtrace* –––-
    @end example

    Como es normal, el mensaje de error intenta ser útil y tiene
    sentido después de que se aprenda cómo leerlo.@n{3}

    La primera parte del mensaje de error es honesto; dice @'{wrong
    type argument} (mal tipo de argumento). Lo siguiente viene con la
    misteriosa palabra de jerga @'{number-or-marker-p}. Esta palabra
    está intentando contar qué tipo de argumento @c{+} se espera.

    El símbolo @c{number-or-marker-p} dice que el intérprete Lisp está
    intentando determinar si la información presentada (el valor del
    argumento) es un número o una marca (un objeto especial
    representando una posición de buffer). Lo que hace es testear para
    ver si el @c{+} está siendo números dados para añadir. También
    chequea para ver si el argumento es algo llamado un marcador, que
    es una funcionalidad específica de Emacs Lisp. (En Emacs, las
    localizaciones en un búffer son grabadas como marcadores. Cuando
    la marca está asignado con el atajo @k{C-@@} o @k{C-SPC}, su
    posición se guarda como un marcador. La marca puede ser
    considerada un número –el número de caracteres la localización
    está desde el principio del búffer.)  En Emacs Lisp, @c{+} puede
    ser usado para añadir el valor numérico de posiciones de marca
    como números.

    La @'{p} de @c{number-or-marker-p} es el cuerpo de una práctica
    iniciada en los primeros días de la programación Lisp. La @'{p} es
    para 'predicado'. En la jerga usada por los primeros
    investigadores de Lisp, un predicado se refiere a una función para
    determinar si alguna propiedad es verdadera o falsa. Así la @'{p}
    nos cuenta que @c{number-or-marker-p} es el nombre de una función
    que determina que el argumento dado es un número o una
    marca. Otros símbolos Lisp que finalizan en @'{p} incluyen
    @c{zerop}, una función que chequea si sus argumentos tienen el
    valor de cero, y @c{listp}, una función que prueba si sus
    argumentos son una lista.

    Finalmente, la última parte del mensaje de error es el símbolo
    @c{hello}. Esto es el valor del argumento que pasaba a @c{+}. Si
    la adición había sido pasada al tipo correcto de objeto, el valor
    pasado habría sido un número, tal como 37, en vez de un símbolo
    como @c{hello}. Pero entonces tu no habrías obtenido el mensaje de
    error.

    @ignore
      In GNU Emacs version 20 and before, the echo area displays an error
      message that says:

      @example
        Mal tipo de argumento:@: number-or-marker-p, hello
      @end example

      This says, in different words, the same as the top line of the
      @f{*Backtrace*} buffer.
    @end ignore

*** La función @c{message}

    Como @c{+}, la función @c{message} toma un número variable de
    argumentos. Es usado para enviar mensajes para el usuario y es así
    tan útil que nosotros lo describiremos aquí.

    Un mensaje está impreso en el área echo. Por ejemplo, se puede
    imprimir un mensaje en tu área echo evaluando la siguiente lista:

    @example
      (message "¡Este mensaje aparece en el área echo!")
    @end example

    La cadena entera entre comillas dobles es un argumento simple y
    está impreso @i{en todo}. (Nótese que en este ejemplo, el mensaje
    en sí aparecerá en el área echo con comillas comillas dobles; que
    es porque tu ves el valor devuelto por la función @c{message}. En
    la mayoría de los usos de @c{message} en programas que se escribe,
    el texto será impreso en el área echo como un efecto lateral, sin
    las comillas. Ver @l{@c{multiply-by-seven} en detalle}, para un
    ejemplo de esto.)

    Sin embargo, si hay un @'{%s} en la cadena citada de caracteres,
    la función @c{message} no imprime el @'{%s} como tal, pero mira al
    argumento que sigue la cadena. Eso evalúa el segundo argumento e
    imprime el valor en la posición en la cadena donde el @'{%s} está.

    Puede ver esto posicionando el cursor después de la siguiente
    expresión y escribiendo @k{C-x C-e}:

    @example
      (message "El nombre de este búffer es: %s." (buffer-name))
    @end example

    En Info, @c{"El nombre de este búffer es: *info*."} aparecerá en
    el área echo. La función @c{buffer-name} devuelve el nombre del
    búffer como una cadena, que la función @c{message} inserta en
    lugar de @c{%s}.

    Para imprimir un valor como un entero, usa @'{%d} en la misma
    forma que @'{%s}. Por ejemplo, para imprimir un mensaje en el área
    echo que sitúa el valor de @c{fill-column}, evalúa lo siguiente:

    @example
      (message "El valor de fill-column es %d." fill-column)
    @end example

    En mi sistema, cuando evalúo esta lista, @c{"El valor de
    fill-column es 72"} aparece en mi área echo@n{4}

    Si hay más de una @'{%s} en la cadena citada, el valor del primer
    argumento siguiente la cadena citada es impresa en la posición del
    primer @'{%s} y el valor del segundo argunmento es impreso en la
    posición del segundo @'{%s}, y así.

    Por ejemplo, si se evalúa lo siguiente,

    @example
      (message "¡Hay %d %s en la oficina!"
               (- fill-column 14) "elefantes rosas")
    @end example

    un mensaje característico aparecerá en el área echo. En mi sistema
    dice @c{"¡Hay 58 elefantes rosas en la oficina!"}

    La expresión @c{(- fill-column 14)} está evaluado y el número
    resultante está insertado en lugar del @'{%d}; y la cadena entre
    dobles comillas, @c{"elefantes rosas"}, está tratado como un
    argumento simple e insertado en lugar del @'{%s}. (Esto es decir,
    una cadena entre comillas dobles se evalúa así mismo, como un
    número.)

    Finalmente, aquí está un ejemplo algo complejo que no solo ilustra
    la computación de un número, pero también muestra como se puede
    usar una expresión que genere el texto que es sustituido por
    @'{%s}:

    @example
      (message "Se vieron %d %s"
               (- fill-column 36)
               (concat (substring
                        "Los rápidos zorros marrones saltaron." 12 19)
                        "rojos trotando."))
    @end example

    En este ejemplo, @c{message} tiene tres argumentos: la cadena,
    @c{"Él vió %d %s"}, después la expresión, que empieza con la
    función @c{concat}. El valor resultante desde la evaluación de
    @c{(- fill-column 32)} está insertado en lugar de @'{%d}; y el
    valor devuelto por la expresión empieza con @c{concat} está
    insertado en lugar del @'{%s}.

    Cuando se rellena la columna es 70 y se evalúa la expresión, el
    mensaje @c{"Se vieron 38 zorros rojos trotando."} aparece en tu
    área echo.

** @t{Configurando el valor de una variable}

   Hay varios caminos por el que una variable puede dar un valor. Uno
   de los caminos es usar la función @c{set} o la función
   @c{setq}. Otro camino es usar @c{let} (@l{let}). (La jerga para
   este proceso es @:{bind} una variable para un valor.)

   Las siguientes secciones no solo describen cómo @c{set} y @c{setq}
   funcionan pero también ilustran como los argumentos pasan.

*** Usando @c{set}

    Para asignar el valor del símbolo @c{flores} a la lista @c{'(rosa
    violeta margarita mantequilla)}, evalúa la siguiente expresión
    posicionando el cursor después de la expresión y escribiendo @k{C-x
    C-e}.

    @example
      (set 'flores '(rosa violeta margarita mantequilla))
    @end example

    La lista @c{(rosa violeta margarita mantequilla)} aparecerá en el
    área echo. Esto es lo que está @e{devuelto} por la función
    @c{set}. Como efecto lateral, el símbolo @c{flores} está asociado a
    la lista; esto es, el símbolo @c{flores}, que puede ser visto como
    una variable, que es dada por la lista como su valor. (Este
    proceso, ilustra un efecto lateral al intérprete Lisp: asignando el
    valor, que puede ser el efecto primario en el que los humanos
    estamos interesados. Esto es porque cada función Lisp debe devolver
    un valor si no se obtiene un error, pero solo tendrá un efecto
    colateral si está diseñado para tener uno.)

    Después de evaluar la expresión @c{set}, se puede evaluar el
    símbolo @c{flores} y devolverá el valor asignado. Aquí está el
    símbolo. Emplaza tu cursor después y escribe @k{C-x C-e}.

    @example
      flores
    @end example

    Cuando se evalúa @c{flores}, la lista @c{(rosa violeta margarita
    mantequilla)} aparece en el área echo.

    Incidentalmente, si se evalúa @c{'flores}, la variable con una
    comilla en frente, se ve en el área echo y es el símbolo en sí:
    @c{flores}.  Aquí está el símbolo citado, así se puede probar esto:

    @example
      'flores
    @end example

    Nótese también, que cuando se usa @c{set}, se necesitan citar ambos
    argumentos a @c{set}, a menos que se quiera evaluar. Puesto que
    nosotros no queremos argumentos evaluados, ni la variable
    @c{flores}, ni la lista @c{(rosa violeta margarita mantequilla)},
    se citan. (Cuando se usa @c{set} sin citar su primer argumento, el
    primer argumento se evalúa antes que cualquier cosa se haga. Si se
    hizo esto y @c{flores} no tenía un valor ya, se tendría un mensaje
    de error que el @'{Valor de símbolo como variable esté vacío}; por
    otro lado, si @c{flores} no devolvió un valor después de que fuera
    evaluado, el @c{set} intentaría establecer un valor después de que
    fuera devuelto. Hay situaciones donde esto es lo correcto para la
    función a hacer, pero tales situaciones son raras.)

*** Usando @c{setq}

    Como materia práctica, casi siempre se cita el primer argumento a
    @c{set}. La combinación de @c{set} y un argumento citado primero
    es común que tiene su propio nombre: la forma especial
    @c{setq}. Esta forma especial es solo como @c{set} excepto que el
    primer argumento se cita automáticamente, así no se necesita
    escribir la marca de cita por uno mismo. También, como una
    conveniencia añadida, @c{setq} permite asignar varias variables
    diferentes a diferentes valores, todo en una expresión.

    Para asignar el valor de la variable @c{carnívoros} a la lista
    @c{'(leon tigre leopardo)} usando @c{setq}, la siguiente expresión
    que se usa es:

    @example
      (setq carnivoros '(leon tigre leopardo))
    @end example

    Esto es exactamente lo mismo que usar @c{set} excepto que el
    primer argumento se cita automáticamente por @c{setq}. (El @'{q}
    en @c{setq} significa @c{quote}.)

    Con @c{set}, la expresión que se vería es:

    @example
      (set 'carnivoros '(leon tigre leopardo))
    @end example

    También, @c{setq} puede ser usado para asignar diferentes valores
    a diferentes variables. El primer argumento está asociado al valor
    del segundo argumento, el tercer argumento se asocia al valor del
    cuarto argumento, y así. Por ejemplo, se podría usar lo siguiente
    para asignar una lista de árboles al símbolo @c{arboles} y una
    lista herbívoros al símbolo @c{herbivoros}:

    @example
      (setq arboles '(pino abeto roble arce)
            herbivoros '(gacela antilope cebra))
    @end example

    (La expresión podría también haber estado en una línea, pero
    podría no haberse ajustado en una página; y los humanos encuentran
    que es fácil leer listas formateadas.)

    Aunque yo he estado usando el término 'assign', hay otro camino de
    pensar acerca de los trabajos de @c{set} y @c{setq}; y que es
    decir que @c{set} y @c{setq} creen el símbolo @e{point} a la
    lista. Este camino posterior de pensamiento es muy común y en los
    capítulos siguientes volveremos al menos a un símbolo que tiene un
    valor, específicamente una lista, adjunta; o, expresa otros
    caminos, el símbolo asigna a “apuntar” a la lista.

*** Contando

    Aquí hay un ejemplo que muestra cómo usar @c{setq} en un
    contador. Se podría usar esto para contar cuantas veces una parte
    de un programa se repite por sí mismo. Primero asigna una variable
    a cero; entonces añade uno al número cada vez que el programa se
    repite así mismo. Para hacer esto, se necesita una variable que
    sirve como un contador, y dos expresiones: una expresión @c{setq}
    que asigna la variable contador a cero; y una segunda expresión
    @c{setq} que incrementa el contador cada vez que eso es evaluado.

    @example
      (setq counter 0)                ; Se inicializa.

      (setq counter (+ counter 1))    ; Se incrementa.

      counter                         ; Contador.
    @end example

    (El siguiente texto el @'{;} son comentarios. Ver @l{Cambiar una
    definición de función}.)

    Si evalúas la primera de estas expresiones, el inicializador,
    @c{(setq counter 0)}, y entonces evalúa la tercera expresión,
    @c{counter}, el número @c{0} aparecerá en el área echo. Si
    entonces se evalúa la segunda expresión, el incrementador,
    @c{(setq counter (+ counter 1))}, el contador obtendrá el valor
    1. Así si evalúas de nuevo @c{counter}, el número
    @c{1} aparecerá en el área echo. Cada vez que se evalúa la
    segunda expresión, el valor del contador será incrementado.

    Cuando se evalúa el incrementador, @c{(setq counter (+ counter
    1))}, el intérprete Lisp primero evalúa la lista interna; esta es
    la adición. En orden para evaluar esta lista, debe evaluar la
    variable @c{counter} y el número @c{1}. Cuando evalúa la variable
    @c{counter}, recibe su valor actual. Esto pasa su valor y el
    número @c{1} para el @c{+} que los añade juntos. La suma es
    devuelta como el valor de la list propia pasada al @c{setq} que
    asigna la variable @c{counter} a este nuevo valor. De este modo,
    el valor de la variable @c{counter}, se cambia.

*** Resumen

    Aprender Lisp es como escalar una montaña en la que la primera
    parte es la empinada. Ahora has escalado la parte más difícil; y
    lo que queda es más fácil.

    En resumen,

    - Los programas Lisp son hechos de expresiones, que son listas o
      átomos simples.

    - La listas son hechas de cero o más átomos o listas internas,
      separadas por espacios en blanco y rodeados de paréntesis. Una
      lista puede estar vacía.

    - Los átomos son símbolos multi-carácter, como
      @c{forward-paragraph}, los símbolos de caracteres como @c{+},
      cadenas de caracteres entre marcas de comillas dobles, o
      números.

    - Un número se evalúa a sí mismo.

    - Una cadena entre comillas dobles también se evalúa a sí mismo.

    - Cuando se evalúa un símbolo a sí mismo, su valor se devuelve.

    - Cuando se evalúa una lista, el intérprete mira el primer símbolo
      en la lista y en la definición de la función asociada a este
      símbolo. Así se traen las instrucciones en la definición
      función.

    - Una marca de cita (quote) simple, @c{'}, cuenta al intérprete
      Lisp que devolvería la siguiente expresión como se escribe, y se
      evalúa como si la cita no estuviera.

    - Los argumentos son la información pasada a una función. Los
      argumentos a una función son computados evaluando el resto de
      los elementos de la lista de la que la función es el primer
      elemento.

    - Una función siempre devuelve un valor cuando se evalúa (a menos
      que obtenga un error); además, puede también traer alguna acción
      llamada un “efecto colateral”. En muchos casos, un propósito de
      la función primaria es crear un efecto colateral.

*** Ejercicios de mensajes de error

    Unos pocos ejercicios simples:

    - Genera un mensaje de error evaluando un símbolo apropiado que no
      está entre paréntesis.

    - Genera un mensaje de error evaluando un símbolo apropiado que
      está entre paréntesis.

    - Crea un contador que incremente por dos en vez de uno.

    - Escribe una expresión que imprima un mensaje en el área cuando
      es evaluada.

* Practicando evaluación

* Footnotes

  :: @t{fn:1} :: Los apóstrofes simples o las marcas de citas son una
     abreviación para la función @c{quote}; tu no necesitas pensar
     acerca de funciones ahora; las funciones son definidaas en
     @l{Creando errores, Generar un mensaje de error}.

  :: @t{fn:2} :: Es curioso trazar la ruta por la que la palabra
     'argumento' viene para tener dos significados diferentes, uno en
     matemáticas y el otro en el inglés de cada día. De acuerdo al
     @e{Oxford English Dictionary}, la palabra deriva del Latín para
     @'{clarificar}, de este modo significa, por un hilo de
     derivación, viene a significar 'asertir de una manera contra otro
     que puede crear un contador de aserciones', que lidera el
     significado de la palabra como una disputa. (Nótese aquí que la
     palabra Inglés tiene dos definiciones diferentes adjuntas al
     mismo tiempo. En contraste, en Emacs Lisp, un símbolo no puede
     tener dos definiciones de funciones diferentes al mismo tiempo.)

  :: @t{fn:3} :: @c{(quote hola)} es una expresión de la abreviación
     @c{'hola}.

  :: @t{fn:4} :: Actualmente, puede usar @c{%s} para imprimir un
     número. Eso es no específico. @c{%d} imprime solo la parte de un
     número a la izquierda de un punto decimal, y no cualquier cosa
     que no es un número.
