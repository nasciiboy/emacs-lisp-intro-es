@ -*- mode: org; -*-
@title     Una introducción a la programación en Emacs Lisp
@subtitle  Revisada la tercera edición
@author    Robert J. Chassell
@traductor David Arroyo Menéndez
@define    edition-number="3.10"
@define    COUNT-WORDS="count-words-example"

Una Introducción a la Programación en Emacs Lisp

Esto es una @e{Introducción a la Programación en Emacs Lisp},
para personas que no son programadoras.

Traducido desde la edición @v{edition-number}.

Copyright ® 2015 Libremanuals.

Publicado por:

Libremanuals, @l{http://www.libremanuals.net/}

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; there being no Invariant
Section, with the Front-Cover Texts being “A GNU Manual”, and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled “GNU Free Documentation License”.

(a) The FSF's Back-Cover Text is: “You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom.”

* Prefacio

  La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje de
  programación llamado Emacs Lisp. El código escrito en este lenguaje de
  programación es el software––el conjunto de instrucciones––que cuenta al
  ordenador qué hacer cuando tu le das comandos. Emacs está diseñado de forma
  que se puede escribir nuevo código en Emacs Lisp y fácilmente instalarlo
  como una extensión al editor.

  (GNU Emacs se define muchas veces como un “editor extensible”, pero hace
  mucho más que proporcionar capacidad de edición. Es mejor referirse a Emacs
  como un “entorno de computación extensible”. Sin embargo, esta frase es un
  poco pretenciosa. Es más fácil referirse a Emacs simplemente como un
  editor. De hecho, cada cosa que se hace en Emacs––encontrar la fecha Maya y
  fases de la luna, simplificar polinomios, depurar código, administrar
  ficheros, leer cartas, escribir libros––todas estas actividades son maneras
  de editar en un sentido amplio de la palabra.)

  Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un lenguaje de
  programación completo. Se puede usar Emacs Lisp del mismo modo que con
  cualquier otro lenguaje de programación.

  Quizás se quiere comprender la programación; quizás se quiere extender
  Emacs; o quizás se quiere llegar a ser un programador. Esta introducción a
  Emacs Lisp está diseñada para ayudar a empezar en todo esto: para guiarse
  en el aprendizaje de los fundamentos de programación, y de manera más
  importante, para enseñar como uno mismo puede ir más allá.

** Leyendo este texto

   A través de este libro, se verán pequeños programas de ejemplo que se
   pueden ejecutar dentro de Emacs. Si se lee este documento en Info dentro
   de GNU Emacs, se pueden ejecutar los programas como ellos aparecen. (Esto
   es fácil de hacer y se explica cuando los ejemplos se presentan).
   Alternativamente, se puede leer esta introducción como un libro impreso
   mientras se está sentando con un ordenador ejecutando Emacs. (Esto es lo
   que me gusta hacer; me gustan los libros impresos.) Si no se está
   ejecutando Emacs, todavía se puede leer este libro, pero en este caso, lo
   mejor es tratarlo como una novela, o como una guía para un país no
   visitado todavía: interesante, pero no es lo mismo que estar allí.

   Gran parte de esta introducción se dedica a paseos guiados de código usado
   en GNU Emacs. Estos paseos están diseñados para dos propósitos: primero,
   familiarizarse con código real que funciona (código que se usa cada día);
   y, segundo, familiarizarse con cómo funciona Emacs. Es interesante ver
   cómo se implementa un entorno completamente operativo. También, espero que
   se adquiera el hábito de navegar a través del código fuente. Se puede
   aprender mucho comparando código de otros con el propio, ganando nuevas
   ideas. Tener GNU Emacs es como tener la cueva del dragón de los tesoros.

   Además de aprender Emacs como un editor y Emacs Lisp como un lenguaje de
   programación, las guías de ejemplos guiados darán una oportunidad para
   familiarizarse con Emacs como un entorno de programación Lisp. GNU Emacs
   soporta programación y provee herramientas que llegarán a usarse
   cómodamente con cosas como @k{M-.} (la clave que invoca el comando
   @c{find-tag}). También se aprende acerca de búffers y otros objetos que
   son parte del entorno. Aprender estas funcionalidades de Emacs es como
   aprender nuevas rutas alrededor de tu hogar.

   @ignore
     In addition, I have written several programs as extended examples.
     Although these are examples, the programs are real.  I use them.
     Other people use them.  You may use them.  Beyond the fragments of
     programs used for illustrations, there is very little in here that is
     `just for teaching purposes'; what you see is used.  This is a great
     advantage of Emacs Lisp: it is easy to learn to use it for work.
   @end ignore

   Finalmente, espero poder transmitir algunas habilidades de Emacs para
   aprender aspectos de programación que no se conocen. Con frecuencia se
   puede usar Emacs para ayudar a comprender qué puzzles encontrar o como
   hacer alguna cosa nueva. Este auto-descubrimiento no es solo un placer,
   también es una ventaja.

** Para quien está esto escrito

   Este texto está escrito como una introducción elemental para personas que
   no son programadoras. Quien ya programa, puede no estar satisfecho con
   este libro. La razón es que un programador puede tener que convertirse en
   experto leyendo manuales de referencia y este texto no está organizado
   como un manual de referencia.

   Un programador experto que revisó este texto me dijo:

   @quote
     @i{Prefiero aprender desde manuales de referencia. Yo “me sumerjo” en
     cada párrafo y “subo a por aire” entre párrafos.}

     @i{Cuando llego al fin de un párrafo, asumo que este asunto está hecho,
     finalizado, que conozco cada cosa que necesito (con la posible excepción
     del caso en el que el siguiente párrafo empiece hablando acerca de eso
     mismo en más detalle). Yo espero que un manual de referencia bien
     escrito no tendrá un montón de redundancia, y tendrá excelentes punteros
     a (un) lugar donde está la información que quiero.}
   @end quote

   ¿Esta introducción no está escrita para esta persona!

   Primero, intento decir cada cosa al menos tres veces: primero,
   introducirlo; segundo, mostrarlo en contexto; y tercero, mostrarlo en un
   contexto diferente, o revisarlo.

   Segundo, yo no siempre pongo toda la información acerca de un asunto en un
   mismo lugar, ni mucho menos en un párrafo. Desde mi punto de vista, se
   necesita una carga bastante fuerte en el lector. En vez de eso intento
   explicar solo lo que se necesita saber en el momento. (Algunas veces
   incluyo una pequeña información extra, para que no haya sorpresas más
   tarde cuando la información adicional se presente formalmente.)

   Cuando uno lee este texto, no espera aprender todo la primera vez.
   Frecuentemente, solo necesita hacer un `reconocimiento' con alguno de los
   elementos mencionados. Mi esperanza es haber estructurado el texto y dar
   suficientes indicios que dejarán alerta de lo que es importante y
   concentrarse en ellos.

   Es necesario “sumergirse” en algunos párrafos; no hay otro modo de
   leerlos. Pero yo he intentado guardar el número de tales párrafos. Este
   libro pretende ser como una colina asequible, en vez de una montaña
   abrumadora.

   Esta introducción de @e{Programación en Emacs Lisp} viene acompañado de un
   documento complementario.  @l{El Manual de Referencia de GNU Emacs Lisp}.
   El manual de referencia tiene más detalles que esta introducción. En el
   manual de referencia, toda la información sobre un asunto está concentrada
   en un lugar. Se debe cambiar si es como el programador citado arriba. Y,
   de acuerdo, después de haber leido esta @e{Introducción}, será muy útil
   consultar el @e{Manual de Referencia} al escribir programas propios.

** Historia de Lisp

   Lisp fué originariamente desarrollado en los 50 en el Instituto
   Tecnológico de Massachusetts para investigar en inteligencia
   artificial. El gran poder del lenguaje Lisp lo hace superior para otros
   propósitos también, tal como escribir comandos de edición y entornos
   integrados.

   GNU Emacs Lisp está fuertemente inspirado en Maclisp, que está escrito en
   el MIT en los sesenta. Está en cierto modo inspirado en Common Lisp, que
   llega a ser un estándar en los 80. Sin embargo, Emacs Lisp es mucho más
   simple que Common Lisp. (La distribución estándar de Emacs contiene un
   fichero de extensiones opcional, @file{cl.el}, que añade muchas
   funcionalidades a Emacs Lisp.)

** Una nota para principiantes

   Aunque no se conozca GNU Emacs, este documento puede resultar útil. Sin
   embargo, es mejor aprender Emacs, al menos aprender a moverse alrededor de
   la pantalla del ordenador. Uno puede aprender de manera autodidacta cómo
   usar Emacs con el tutorial on-line. Para usarlo, se debe escribir @k{C-h
   t}. (Esto significa que se presione la tecla @k{CTRL} y la @k{h} al mismo
   tiempo, y después se presiona @k{t}).

   Con frecuencia, también aludo a uno de los comandos de Emacs estándar
   listando las teclas que se presionan para invocar el comando y, entonces
   dar el nombre del comando entre paréntesis, como este: @k{M-C-\}
   (@c{indent-region}). (Si lo desea, se pueden cambiar las teclas que son
   escritas para invocar el comando; esto se llama @:{rebinding}. Véase
   Sección @l{Mapas de teclado}.)  La abreviación @k{M-C-\} significa que se
   escribe la tecla @k{META}, @k{CTRL}, y @k{\} todo al mismo tiempo. (En
   muchos teclados modernos la tecla @k{META} es etiquetada con @k{ALT}.)
   Algunas veces una combinación como esta se llama @e{keychord}, puesto que
   es similar a tocar un acorde en un piano. Si el teclado no tiene una tecla
   @k{META}, se usa la tecla con prefijo @k{ESC} en su lugar. En este caso
   @k{M-C-\} significa que se presiona @k{ESC} y entonces escribe @k{CTRL} y
   la tecla @k{\} al mismo tiempo. Pero normalmente @k{M-C-\} significa
   presionar la tecla @k{CTRL} junto a la tecla que está etiquetada @k{ALT}
   y, al mismo tiempo, se presiona la tecla @k{\}.

   Además de escribir una sola combinación de teclas, se puede prefijar lo
   que se escribe con @k{C-u}, que es llamado el ‘argumento universal’. El
   atajo @k{C-u} pasa a ser un argumento para el comando subsiguiente. De
   este modo, para indentar una región de texto plano a 6 espacios, se marca
   la región, y entonces se escribe @k{C-u 6 M-C-\}. (Si no se especifica un
   número, Emacs pasa el número 4 al comando o de otra manera ejecuta el
   comando de manera diferente). Véase Sección Argumentos Numéricos en El
   Manual de GNU Emacs}.

   Si se está leyendo esto en Info usando GNU Emacs, se puede avanzar a
   través de este documento completo solo presionando la barra de espacio,
   @k{SPC}. (Para aprender acerca de Info, escribe @k{C-h i} y luego
   selecciona Info.)

   Una nota en terminología: cuando uso la palabra Lisp sola, con frecuencia
   me estoy refiriendo a los dialectos de Lisp en general, pero cuando yo
   hablo de Emacs Lisp, me estoy refiriendo a GNU Emacs Lisp en particular.

** Se agradece

   Estoy agradecido a todas las personas que me ayudaron con este libro.
   Especialmente agradecido a Jim Blandy, Noah Friedman, Jim Kingdon, Roland
   McGrath, Frank Ritter, Randy Smith, Richard M. Stallman, y Melissa
   Weisshaus. Gracias también a Philip Johnson y David Stampe por su ánimo
   paciente. Mis errores son míos.

   @right
     Robert J. Chassell
     @l{mailto:bob@gnu.org}
   @end right

* Procesamiento de listas

  Para quienes no están habituados, Lisp es un lenguaje de programación
  extraño. En código Lisp hay paréntesis por todas partes. Algunas personas
  incluso reclaman que el nombre signfica ‘Lots of Isolated Silly
  Parentheses’ (‘Montones de Paréntesis Aislados Estúpidos’). Pero la
  protesta no tiene fundamento. Lisp es para procesamiento de listas, y el
  lenguaje de programación maneja @e{listas} (y listas de listas) poniéndolas
  entre paréntesis. Los paréntesis marcan los límites de la lista. Algunas
  veces una lista va precedida por un apóstrofe simple o una marca de cita,
  @'{'}@n{1} Las listas son el fundamento de Lisp.

** Listas Lisp

   En Lisp, una lista como esta: @c{'(rosa violeta margarita botóndeoro)}.
   Esta lista es precedida por un apóstrofe simple. Podría estar bien escrita
   como sigue, que mira más como el tipo de lista con la que se está
   familiarizado:

   @smallexample
     '(rosa
       violeta
       margarita
       botóndeoro)
   @end smallexample

   Los elementos de esta lista son los nombres de 4 flores diferentes,
   separados por espacios en blanco y rodeados de paréntesis, como flores en
   un campo con un muro de piedras alrededor de ellas.

   Las listas pueden también tener números dentro, como en esta lista: @c{(+
   2 2)}. Esta lista tiene un signo más, @'{+}, seguido por dos @'{2}, cada
   uno separado por espacios en blanco.

   En Lisp, tanto datos como programas están representados de la misma
   manera; son tanto listas de palabras, como números, u otras listas,
   separadas por espacios en blanco y rodeadas de paréntesis. (Puesto que un
   programa son datos, un programa puede fácilmente servir datos a otros
   programas; esta es una funcionalidad muy poderosa de Lisp.)
   (Incidentalmente, estas dos marcas de paréntesis @e{no} son listas Lisp,
   porque contienen @'{;} y @'{.} como marcas puntuación.)

   Aquí hay otra lista, esta vez con una lista dentro:

   @smallexample
     '(esta lista tiene (una lista dentro de ella))
   @end smallexample

   Los componentes de esta lista son las palabras @'{esta}, @'{lista},
   @'{tiene}, y la lista @'{(una lista dentro de ella)}. La lista interior se
   construye con las palabras @'{una}, @'{lista}, @'{dentro}, @'{de},
   @'{ella}.

*** Átomos Lisp

    En Lisp, lo que hemos estado llamando a las palabras son en realidad
    @:{átomos}. Este término viene del significado de la palabra átomo, que
    es indivisible. Desde que Lisp es concebido, las palabras que hemos
    estado usando en las listas no pueden ser divididas en pequeñas partes,
    sin perder su significado dentro del programa; lo mismo ocurre con
    números y caracteres de símbolos simples como @'{+}. Por otro lado, a
    diferencia de un átomo, una lista puede ser dividida en pequeñas
    partes. Ver @l(@c{car}, @c{cdr}, @c{cons}: Funciones fundamentales).

    En una lista, los átomos se separan unos de otros por espacios en blanco.
    Pueden ir pegados a un paréntesis.

    Técnicamente hablando, una lista en Lisp consiste de paréntesis alrededor
    de átomos separados por espacios en blanco o alrededor de otras lista o
    alrededor de ambos átomos u otras listas. Una lista puede tener solo un
    átomo en ella o no tener absolutamente nada en ella.  Una lista con nada
    dentro se ve así: @c{()}, y se llama @:{lista vacía}. A diferencia de
    cualquier otra cosa, una lista vacía es tanto un átomo, como una lista al
    mismo tiempo.

    La representación impresa de átomos y listas se llaman @:{expresiones
    simbólicas} o, más concisamente, @:{s-expresiones}.  La palabra
    @:{expresión} por sí misma puede referir o bien a la representación
    impresa, o al átomo o a la lista como se maneja internamente en el
    ordenador. Con frecuencia, las personas usan el término @:{expresión}
    indiscriminadamente. (También, en muchos textos, la palabra @:{forma} se
    usa como un sinónimo para la expresión.)

    En realidad, los átomos que componen nuestro universo se llamaron de ese
    modo cuando se penso que serían indivisibles; pero han sido encontrados
    átomos físicos que no son indivisibles. Las partes pueden dividir un
    átomo o puede fisionarse en 2 partes de igual tamaño. Los átomos físicos
    se nombraron prematuramente, antes de que su verdadera naturaleza fuese
    encontrada. En Lisp, ciertos tipos de átomos, como un array, pueden ser
    separados en partes; pero el mecanismo de hacer esto es diferente de el
    mecanismo para dividir una lista. Tan lejos como las operaciones de las
    listas son concebidas, los átomos de una lista son indivisibles.

    Como en español, los significados de las letras que componen un átomo
    Lisp son diferentes desde el significado de las letras compuestas como
    una palabra. Por ejemplo, la expresión @'{ay}, es completamente diferente
    de las dos palabras @'{a}, e @'{y}.

    Hay muchos tipos de átomos naturales, pero solo unos pocos en Lisp: por
    ejemplo, @:{números}, tales como 37, 511, o 1729, y @:{símbolos}, tales
    como @'{+}, @'{foo}, o @'{forward-line}. Las palabras que hemos listado
    en los ejemplos de debajo son todos símbolos. Cada día de conversación
    Lisp, la palabra “átomo” no se usa con frecuencia, porque los
    programadores normalmente intentan ser más específicos acerca de que tipo
    de átomo están tratando. La programación Lisp es sobre todo de símbolos
    (y algunas veces números) con listas. (De ese modo, tres palabras
    rodeadas de paréntesis son una apropiada lista en Lisp, desde que ello
    consiste en átomo, que en este caso son símbolos, separados por espacios
    en blanco y cerrados por paréntesis, sin cualquier puntuación no Lisp.)

    Texto entre comillas––incluso frases de párrafos––son también un átomo.
    Aquí hay un ejemplo:

    @smallexample
      '(esta lista incluye "texto entre comillas.")
    @end smallexample

    En Lisp, todo el texto citado incluyendo la marca de puntuación y los
    espacios en blanco son un átomo simple. Este tipo de átomo es llamado
    @:{string} (por ‘cadena de caracteres’) y es el tipo de cosa que es usada
    para mensajes que un ordenador puede imprimir para que un humano lea. Las
    cadenas son un tipo diferente de átomo en vez de números, o símbolo y son
    usados de manera diferente.

*** Espacios en blanco en listas

    La cantidad de espacios en blanco en una lista no importa. Desde el punto
    de vista del lenguaje Lisp,

    @smallexample
      '(esta lista
         parece esto)
    @end smallexample

    es exactamente lo mismo que esto:

    @smallexample
      '(esta lista parece esto)
    @end smallexample

    Ambos ejemplos muestran que Lisp es la misma lista, la lista hecha de los
    símbolos @'{esta}, @'{lista}, @'{parece}, y @'{esto} en este orden.

    Espacios en blanco extra y nuevas líneas son diseñadas para crear una
    lista más legible por humanos. Cuando Lisp lee la expresión, asimila los
    espacios en blanco extra (pero necesita tener al menos un espacio entre
    átomos en orden para contarlos aparte.)

    Aunque parezca raro, los ejemplos que hemos visto cubren casi todo lo que
    Lisp tiene. Cualquier otra lista en Lisp ve más o menos como uno de estos
    ejemplos, excepto que la lista puede ser más larga y más compleja. En
    resumen, una lista está entre paréntesis, una cadena está entre comillas,
    un símbolo parece como una palabra, y un número parece un número. (Para
    ciertas situaciones, corchetes, puntos y otros caracteres especiales
    pueden ser usados; sin embargo; iremos bastante lejos sin ellos.)

*** GNU Emacs te ayuda a escribir listas

    Cuando se escribe una expresión Lisp en GNU Emacs usando bien el modo de
    Interacción Lisp o el modo Emacs Lisp, están disponibles varios comandos
    para formatear la expresión Lisp, de modo que sea fácil de leer. Por
    ejemplo, presionando la tecla @k{TAB} automáticamente se indenta la línea
    del cursor que está en la cantidad correcta. Un comando para indentar
    apropiadamente el código en una región está asociado a @k{M-C-\}. La
    indentación está diseñada de manera que se pueden qué elementos de una
    lista pertenencen a qué lista––los elementos de una sublista están más
    indentados que los elementos de una lista cerrada.

    Además, cuando se escribe un paréntesis de cierre, Emacs momentáneamente
    salta el cursor atrás para hacer el matching (emparejamientos) con el
    paréntesis de apertura, para ver cuál es. Esto es muy útil, ya que cada
    lista que se escribe en Lisp debe tener sus paréntesis emparejados con
    sus paréntesis de apertura. (Ver Seccion Modos Mayores en El Manual de
    GNU Emacs, para más información acerca de modos de Emacs.)

** Ejecutar un programa

   Una lista en Lisp––cualquier lista––es un programa listo para ser
   ejecutado. Si lo ejecutas (lo que la jerga Lisp llama @:{evaluar}), el
   ordenador hará una de las tres cosas: nada excepto devolverte la lista
   misma; enviar un mensaje de error; o, tratar el primer símbolo en la lista
   como un comando para hacer alguna cosa. (¿Normalmente, es el último de
   estas tres cosas de lo que realmente se quiere!).

   El apóstrofe, @c{'}, que se pone enfrente de algún ejemplo de listas en
   secciones precedentes se llama @:{quote}; (comilla); cuando precede una
   lista, Lisp no tiene que hacer nada con la lista, otra que la toma como
   está escrita. Pero si no hay una cita precediendo la lista, el primer ítem
   de la lista es especial: es un comando para que el ordenador obedezca. (En
   Lisp, estos comandos son llamados @e{funciones}.) La lista @c{(+ 2 2)}
   muestra debajo que no tuvo un quote en frente, así Lisp comprende que
   @c{+} es una instrucción para hacer alguna cosa con el resto de la lista:
   añadir los números que siguen.

   Si está leyendo esto dentro de GNU Emacs, aquí está como puedes evaluar
   una lista: posiciona tu cursor de manera inmediata después de la siguiente
   lista y escribe @k{C-x C-e}:

   @smallexample
     (+ 2 2)
   @end smallexample

   Verás que el número @c{4} aparece en el área echo. (La jerga que se usa es
   “evaluar la lista.” El área echo es la línea al fondo de la pantalla que
   muestra o hace “echo” del texto.) Ahora intenta la misma cosa con una
   lista entre comillas: posiciona el cursor justo después de la siguiente
   lista y escribe @k{C-x C-e}:

   @smallexample
     '(esto es una lista citada)
   @end smallexample

   Verás aparecer @c{(esto es una lista citada)} en el área echo.

   En ambos casos, lo que estás haciendo es dar un comando al programa dentro
   de GNU Emacs llamado @:{intérprete Lisp}––dando al intérprete un comando
   para evaluar la expresión. El nombre del intérprete Lisp viene de la
   palabra para la tarea hecha por un humano que viene con el significado de
   una expresión––quien lo “interpreta”.

   También se puede evaluar un átomo que no es parte de una lista––uno que no
   está rodeado por paréntesis; de nuevo, el intérprete Lisp traduce desde la
   expresión humanamente legible al lenguaje del ordenador. Pero antes de
   discutir esto (ver Seccion @l{Variables}), nosotros discutiremos lo que el
   intérprete de Lisp hace cuando tu creas el error.

** Generar un mensaje de error

   No se preocupe si genera un mensaje de error de manera accidental, se dará
   un comando para que el intérprete de Lisp lo genere. Esto es una actividad
   sin daño; y en efecto, con frecuencia se intenta generar mensajes de error
   de manera intencional. Una vez se comprende la jerga, los mensajes de
   error pueden ser informativos. En vez de ser llamados mensajes de “error”,
   deberían ser llamados mensajes de “ayuda”. Esto son como signos para un
   viajero en un país extraño; descifrarlos puede ser duro, pero una vez
   comprendidos, pueden encontrar el camino.

   El mensaje de error es generado por un depurador de codigo incorporado
   dentro de GNU Emacs. Así se ‘entra al depurador’. Se puede salir del
   depurador pulsando @code{q}.

   Lo que se hace es evaluar una lista que no está citada y no tiene un
   comando con significado como su primer elemento. Aquí hay una lista casi
   exacta a la usada, pero sin la cita simple en vez de eso. Posicione el
   cursor justo después y presione @k{C-x C-e}:

   @smallexample
     (esto es una lista sin cita)
   @end smallexample

   @ignore
     What you see depends on which version of Emacs you are running.  GNU
     Emacs version 22 provides more information than version 20 and before.
     First, the more recent result of generating an error; then the
     earlier, version 20 result.

     In GNU Emacs version 22, a @file{*Backtrace*} window will open up and
     you will see the following in it:
   @end ignore

   Se abrirá una ventana @f{*Backtrace*} y se verá lo siguiente:

   @smallexample
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end smallexample

   Su cursor estará en esta ventana (puede tener que esperar unos pocos
   segundos antes de llegar a ser visible). Para salir del depurador y de su
   ventana, escribe:

   @smallexample
     q
   @end smallexample

   Por favor, ahora pulsa @kbd{q}, as@'{@dotless{i}} se comprueba que se
   puede salir del depurador. A continuacion, presione "@kbd{C-x C-e} una vez
   mas para re-entrar.

   Basado en lo que ya se sabe, se puede leer este mensaje de error.

   Si se lee el búffer @f{*Backtrace*} desde arriba; cuenta lo que Emacs
   hace. Cuando se escribe @k{C-x C-e}, se hizo una llamada interactiva el
   comando @c{eval-last-sexp}. @c{eval} es una abreviación para ‘evaluar’ y
   @c{sexp} es una abreviación para la ‘expresión simbólica’. El comando
   significa ‘evalúa la última expresión simbólica’, que es la expresión
   ahora antes de tu cursor.

   En cada línea de abajo se cuenta lo que evaluó el siguiente intérprete. La
   acción más reciente está alta. El búffer es llamado @f{*Backtrace*} porque
   te permite habilitar la traza de Emacs hacia atrás.

   Arriba del búffer @f{*Backtrace*}, se verá la línea:

   @smallexample
     El depurador introdujo el error Lisp: (void-function this)
   @end smallexample

   El intérprete Lisp intentó evaluar el primer átomo de la lista, la palabra
   @'{this}. Esta acción que generaba el mensaje de error @'{void-function
   this}.

   El mensaje contiene las palabras @'{void-function} y @'{this}.

   La palabra @'{function} fué mencionada antes. Es una palabra muy
   importante. Para nuestros propósitos, se puede definir eso diciendo que
   una @:{función} (@e{function}) es un conjunto de instrucciones para el
   ordenador que cuenta al ordenador hacer alguna cosa.

   Ahora se puede empezar a comprender el mensaje de error: @'{void-function
   this}. La función (que es, la palabra @'{this}) no tiene una definición de
   cualquier conjunto de instrucciones del ordenador para llevarlo.

   La palabra ligeramente extraña, @'{void-function}, está diseñada para
   cubrir el camino en que Emacs Lisp está implementado, que es cuando un
   símbolo no tiene una definición de función adjunta a eso, el lugar que
   contendría las instrucciones es ‘vacío’.

   Por otro lado, desde que fuimos capaces de añadir 2 más 2 de manera
   exitosa, evaluando @c{(+ 2 2)}, se puede inferir que el símbolo @c{+} debe
   tener un conjunto de instrucciones para que el ordenador obedezca y estas
   instrucciones deben añadir los números que siguen el @c{+}.

   Es posible prevenir que Emacs entre en el depurador en casos como este. No
   se explicará cómo hacer esto aquí, pero se mencionará que el resultado se
   parece, porque se puede encontrar una situación similar si hay un error en
   algún código Emacs que se está usando. En tales casos, se verá una línea
   del mensaje de error; que aparecerá en el área echo y parecerá así:

   @smallexample
     La definición de la función de símbolos está
     vacío:@: this
   @end smallexample

   @ignore
     (Also, your terminal may beep at you––some do, some don't; and others
     blink.  This is just a device to get your attention.)
   @end ignore

   El mensaje aparece tan pronto se escribe una tecla, incluso para mover el
   cursor.

   Conocemos el significado de la palabra @'{Símbolo}. Se refiere al primer
   átomo de la lista, la palabra @'{este}. La palabra @'{función} se refiere
   a las instrucciones que cuentan al ordenador que hacer. (Técnicamente, el
   símbolo cuenta al ordenador donde encontrar las instrucciones, pero esto
   es una complicación que podemos ignorar por el momento.)

   El mensaje de error puede ser comprendido: @'{La definición del símbolo
   está vacío: este}. El símbolo (que es, la palabra @'{este}) le faltan
   instrucciones para que el ordenador funcione.

** Nombres de símbolos y definiciones de funciones

   Se puede articular otra característica de Lisp basada en lo que se
   discutió hace tiempo––una característica importante: un símbolo, como
   @c{+}, no es en sí mismo el conjunto de instrucciones que el ordenador
   transmite. En vez de eso, el símbolo está usado, quizás temporalmente,
   como un camino de localizar la definición o conjunto de instrucciones. Lo
   que se ve es el nombre a través del que las instrucciones se pueden
   encontrar. Los nombres de personas trabajan por el mismo camino. Puede ser
   llamado @'{Bob}; sin embargo, no soy @'{B}, @'{o}, @'{b} pero soy, o fuí,
   la consciencia consistente asociada con una forma de línea particular. El
   nombre no soy yo, pero puedo ser usado para referirme a mí.

   En Lisp, un conjunto de instrucciones puede adjuntarse a varios
   nombres. Por ejemplo, las instrucciones de ordenador para añadir números
   pueden ser enlazados al símbolo @c{más} tan bien como el símbolo @c{+} (y
   son en algunos dialectos de Lisp). Entre humanos, puede referirse a
   @'{Robert} tan bien como @'{Bob} y en otras palabras también.

   Por otro lado, un símbolo puede tener solo una función adjunta en un
   momento. De otro modo, el ordenador estaría confundido acerca de qué
   definición usar. Si este fuera el caso, solo una persona en el mundo
   podría llamarse @'{Bob}. Sin embargo, la definición de función para la que
   el nombre se refiere puede ser cambiada de manera legible. (Ver Sección
   @l{Instalar una Definición de Función}.)

   Puesto que Emacs Lisp es grande, es costumbre nombrar símbolos de un modo
   que identifique la parte de Emacs de la función que pertenece. De este
   modo, todos los nombres de funciones que tratan con Texinfo empiezan con
   @'{texinfo-} y estas funciones que tratan con la lectura de correo
   empiezan con @'{rmail-}.

** El intérprete Lisp

   Basado en lo que se ha visto, ahora se puede empezar a entender lo que el
   intéprete Lisp hace cuando ejecutamos un comando para evaluar una
   lista. Primero, examina si hay un símbolo quote (cita) antes de la lista;
   si el intérprete da la lista. Por otro lado, si no hay cita, el intéprete
   mira si el primer elemento en la lista tiene una definición de función. De
   otro modo, el intérprete imprime un mensaje de error.

   Así es como Lisp trabaja. Simple. Hay complicaciones añadidas que
   tendremos en un minuto, pero estas son fundamentales. De acuerdo, para
   escribir programas Lisp, se necesita conocer como escribir definiciones de
   función y adjuntarlas a nombres, y como hacer esto sin confundirnos a
   nosotros mismos o al ordenador.

   Ahora, una primera complicación. Además de las listas, el intérprete Lisp
   puede evaluar un símbolo sin el símbolo cita (quote) y no tiene paréntesis
   alrededor. El intérprete Lisp intentará determinar el valor del símbolo
   como una @:{variable}.  Esta situación está descrita en la sección acerca
   de variable. (Ver @l{Variables}.)

   La segunda complicación ocurre debido a que algunas funciones son
   inusuales y no funcionan de la manera usual. Estas que no son llamadas
   @:{formas especiales}. Son usadas para trabajos especiales, como definir
   una función, y no son muchas de ellas. En los siguientes próximos
   capítulos, se introducirán varias de las formas especiales más
   importantes.

   La tercera y final complicación es la siguiente: si la función que el
   intérprete Lisp está buscando no es una forma especial, y si eso es parte
   de una lista, el intérprete Lisp quiere ver si la lista tiene una lista
   dentro. Si hay una lista dentro, el intérprete Lisp primero mira qué hacer
   con la lista dentro, y entonces trabaja en la lista de fuera. Si todavía
   hay otra lista embebida dentro de la propia lista, eso funciona en esta
   primero, y así. Eso siempre funciona en la lista más interior. El
   intérprete funciona más interior primero, para evaluar el resultado de
   esta lista. El resultado puede ser usado por la expresión entre
   paréntesis.

   De otra manera, el intérprete trabaja de izquierda a derecha, desde una
   expresión a la siguiente.

*** Compilación de bytes

    Otro aspecto de interpretación: el intérprete Lisp es capaz de
    interpretar dos tipos de entidad: código humanemente legible, en el que
    focalizarse exclusivamente, y especialmente código procesado, llamado
    @:{byte compilado}, que no es humanamente legible. El código máquina
    compilado se ejecuta más rápido que el código humanamente legible.

    Tu puedes transformar código legible por humanos dentro de código
    compilado ejecutando un de los comandos compilados tales como
    @c{byte-compile-file}. El código compilado es normamelte almacenado en un
    fichero que finaliza con una extensión @f{.elc} en vez de una extensión
    @f{.el}. Verás ambos tipos de ficheros en el directorio @f{emacs/lisp};
    los ficheros para leer estos son con extensiones @f{.el}.

    Como una cuestión práctica, para la mayoría de las cosas tu podrías
    personalizar o extender Emacs, no necesitas compilar byte; y no
    discutirás el asunto aquí. Ver Seccion Compilación de Byte en El Manual
    de Referencia de GNU Emacs, para una completa descripción de compilación
    byte.

** Evaluación

   Cuando el intérprete Lisp funciona en una expresión, el término para la
   actividad es llamada @:{evaluación}. Decimos que el intérprete ‘evalúa la
   expresión’. Yo he usado este término varias veces antes. La palabra viene
   desde su uso en el lenguaje de cada día, ‘para cierto valor o cantidad de;
   para estimar’ de acuerdo a @e{Webster's New Collegiate Dictionary}.

   Después de evaluar una expresión, el intérprete Lisp normalmente
   @:{devuelve} el valor que el ordenador produce trayendo las instrucciones
   encontradas en la definición de la función, o quizás dará esta función y
   producirá un mensaje de error. (El intérprete puede también quedarse
   colgado, así hablar, a una función diferente o puede intentar repetir
   continuamente que está haciendo para siempre y siempre en lo que está
   llamado como un ‘bucle infinito’. Estas acciones son menos comunes; y
   pueden ignorarse). Más frecuentemente, el intérprete devuelve un valor.

   Al mismo tiempo el intérprete devuelve un valor, puede hacer cualquier
   cosa más también, tal como mover un cursor o copiar un fichero; este otro
   tipo de acción es llamada @:{efecto lateral}. Acciones que los humanos
   pensamos que son importantes tales como imprimir resultados son, con
   frecuencia, “efectos laterales” al intérprete Lisp. La jerga puede sonar
   peculiar, pero cambiar que es fácil aprender a usar efectos laterales.

   En resumen, evaluando una expresión simbólica normalmente causa que el
   intérprete devuelva un valor y quizás trajo un efecto lateral; o al menos
   produce un error.

*** Evaluando listas propias

    Si la evaluación se aplica a una lista que está dentro de una lista de
    fuera, se puede usar el valor devuelto por la primera evaluación como
    información cuando la lista de fuera está evaluada. Esto explica por qué
    las expresiones propias son evaluadas primero: los valores devueltos son
    usados por las expresiones de fuera.

    Nosotros podemos investigar este proceso evaluando otro ejemplo
    adicional. Deja tu cursor después de la siguiente expresión y escribe
    @k{C-x C-e}:

    @smallexample
      (+ 2 (+ 3 3))
    @end smallexample

    El número 8 aparecerá en el área echo.

    Lo que ocurre es que el intérprete Lisp primero evalúa la expresión
    propia, @c{(+ 3 3)}, para que el valor 6 se devuelva; entonces evalúa la
    expresión de fuera como si fuera escrita @c{(+ 2 6)}, que devuelve el
    valor 8. Puesto que no hay más expresiones cerradas para evaluar el
    intérprete imprime este valor en el área echo.

    Ahora es fácil comprender el nombre de los comandos invocados por atajos
    @k{C-x C-e}: el nombre es @c{eval-last-sexp}. Las letras @c{sexp} son una
    abreviación para la ‘expresión simbólica’, y @c{eval} es una abreviación
    para ‘evaluar’. El comando significa ‘evaluar la última expresión
    simbólica’.

    Como un experimento, tu puedes intentar evaluar la expresión poniendo el
    cursor al principio de la siguiente línea inmediatamente siguiendo la
    expresión, o dentro de la expresión.

    Aquí hay otra copia de la expresión:

    @smallexample
      (+ 2 (+ 3 3))
    @end smallexample

    Si se posiciona el cursor al principio de la línea en blanco que
    inmediatamente sigue la expresión y escribes @k{C-x C-e}, todavía se
    obtendrá el valor 8 impreso en el área echo. Ahora intenta poner el
    cursor dentro de la expresión. Si se pone bien después del siguiente al
    último paréntesis (así aparece para situarse arriba del último
    paréntesis), ¿se obtendrá un 6 impreso en el área echo!  Esto es porque
    el comando evalúa la expresión @c{(+ 3 3)}.

    Ahora se pone el cursor inmediatamente después de un número.  Escribe
    @k{C-x C-e} y se tendrá el número en sí. En Lisp, si evalúas un número,
    tu tienes el número en sí––esto es cómo los números difiere desde los
    símbolos. Si evalúas una lista empezando con un símbolo como @c{+},
    tendrás un valor devuelto que es el resultado del ordenador trayendo las
    instrucciones en la definición de función adjunta a este nombre. Si un
    símbolo por sí mismo es evaluado, alguna cosa diferente ocurre, como
    veremos en la siguiente sección.

** Variables

   En Emacs Lisp, un símbolo puede tener un valor adjunto como puede tener
   una definición de función adjunta. Las dos son diferentes. La definición
   de función es un conjunto de instrucciones que un ordenador obedece. Un
   valor, por otro lado, es alguna cosa como un número o un nombre, que puede
   variar (que es porque tal símbolo es llamado variable). El valor de un
   símbolo puede ser una expresión en Lisp, tal como un símbolo, número,
   lista, o cadena. Un símbolo que tiene un valor es con frecuencia llamado
   una @:{variable}.

   Un símbolo puede tener ambos una definición de función y un valor adjunto
   al mismo tiempo. O puede tener solo uno u otro. Los dos están
   separados. Esto es algo similar al camino, el nombre Cambridge puede
   referirse a la ciudad en Massachusetts y tener alguna información adjunta
   al nombre tan bien, tal como “gran centro de programación”.

   @ignore
     (Incidentally, in Emacs Lisp, a symbol can have two
     other things attached to it, too: a property list and a documentation
     string; these are discussed later.)
   @end ignore

   Otro camino para pensar acerca de esto es imaginar un símbolo como ser una
   caja de cajones. La definición de función es poner en el cajón que maneja
   el valor que puede ser cambiado sin afectar los contenidos del cajón que
   maneja la definición de función, y viceversa.

   La variable @c{fill-column} ilustra un símbolo con un valor adjunto: en
   cada buffer de GNU Emacs, este símbolo establece algún valor, normalmente
   72 o 70, pero algunas veces algún otro valor. Para encontrar el valor de
   este símbolo, evalúalo por sí mismo. Si está leyendo esto en Info dentro
   de GNU Emacs, tu puedes hacer esto poniendo el cursor después del símbolo
   y escribiendo @k{C-x C-e}:

   @smallexample
     fill-column
   @end smallexample

   Después de que yo escribiera @k{C-x C-e}, Emacs imprimió el número 72 en
   mi área echo. Este es el valor por el que @c{fill-column} es escogido para
   mi, porque yo lo escribo. Puede ser diferente para ti en tu búffer
   Info. Sepa que el valor devuelto como una variable es impreso exactamente
   por el mismo camino que el valor devuelto por una función trayendo sus
   instrucciones. Puesto que el punto de vista del intérprete Lisp, es un
   valor devuelto. El tipo de expresión viene de ceder a la cuestión una vez
   el valor se conoce.

   Un símbolo puede tener cualquier valor adjunto a ello o, usar la jerga, se
   puede @:{bind} (asociar) la variable a un valor: a un número, tal como 72;
   a una cadena, @c{\"tal como esta\"}; a una lista, tal como @c{(abeto pino
   roble)}; podemos incluso asociar una variable a una definición de función.

   Un símbolo puede ser emparejado por un valor en varios caminos. Ver @l{set
   y setq, , Configurando el valor de una variable}, para información acerca
   de un camino para hacer esto.

*** Mensaje de error para un símbolo sin una función

    Cuando se evalúa @c{fill-column} para encontrar el valor de una variable,
    no se ponen paréntesis alrededor de la palabra. Esto es porque no
    pretendemos usarlos como un nombre de función.

    Si @c{fill-column} fuese el primer o único elemento de una lista, el
    intérprete de Lisp intentaría encontrar la definición de función
    adjunta. Pero @c{fill-column} no tiene definición de función. Prueba
    evaluando esto:

    @smallexample
      (fill-column)
    @end smallexample

    Se creará un buffer @f{*Backtrace*} que dice:

    @smallexample
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (void-function fill-column)
        (fill-column)
        eval((fill-column))
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    @end smallexample

    (Recuerda, para salir del depurador y crear la ventana del depurador para
    ir fuera, escribe @k{q} en el @f{*Backtrace*} buffer.)

    @ignore
      In GNU Emacs 20 and before, you will produce an error message that says:

      @smallexample
        La definición de símbolos de función:@: fill-column
      @end smallexample

      (The message will go away as soon as you move the cursor or type
      another key.)
    @end ignore

*** Mensaje de error para un símbolo sin un valor

    Si se intenta evaluar un símbolo que no tiene un valor asociado, recibirá
    un mensaje de error. Se puede ver esto experimentando con nuestra suma 2
    más 2. En la siguiente expresión, pon el cursor correcto después de
    @c{+}, antes del primer número 2, escribe @k{C-x C-e}:

    @smallexample
      (+ 2 2)
    @end smallexample

    En GNU Emacs 22, se creará un buffer @f{*Backtrace*} que dice:

    @smallexample
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (void-variable +)
        eval(+)
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    @end smallexample

    (De nuevo, se puede salir del depurador escribiendo @k{q} en el búffer
    @f{*Backtrace*}.)

    Esta traza es diferente desde los muy primeros mensajes de error que
    vimos, que dijimos, @'{El depurador introdujo--errores Lisp: (esta
    función está vacía)}. En este caso, la función no tiene una valor como
    una variable; mientras en el otro mensaje de error, la función (la
    palabra ‘this’) no tuvo una definición.

    En este experimento con el @c{+}, lo que se hizo fué causar que el
    intérprete Lisp evalúe el @c{+} y busque el valor de la variable en vez
    de la definición de la función. Nosotros hicimos esto dejando el cursor
    correcto después del símbolo en vez de después de los paréntesis que
    cierran la lista como hicimos antes. Como consecuencia, el intérprete
    Lisp evaluó la s-expresión precedente, que en este caso fué el @c{+} en
    sí.

    Desde que @c{+} no tiene un valor asociado, solo la definición de
    función, el mensaje de error reportado que el valor del símbolo como una
    variable estaba vacío.

    @ignore
      In GNU Emacs version 20 and before, your error message will say:

      @example
        El valor de símbolo como variable está vacío:@: +
      @end example

      The meaning is the same as in GNU Emacs 22.
    @end ignore

** Argumentos

   Para ver cómo la información pasa a funciones, se permite mirar de nuevo a
   nuestro viejo standby, la adición de dos más dos. En Lisp, esto es escrito
   como sigue:

   @smallexample
     (+ 2 2)
   @end smallexample

   Si se evalúa esta expresión, el número 4 aparecerá en tu área echo. Lo que
   el intérprete de Lisp hace es añadir los número que sigue el @c{+}.

   Los números añadidos por @c{+} son llamados @:{argumentos} de la función
   @c{+}. Estos números son la información que es dada para o @:{pasada} a la
   función.

   La palabra ‘argumento’ viene del ámbito de las matemáticas y no se refiere
   a una disputa entre 2 personas, sino que se refiere a la información
   presentada a la función, en este caso, al @c{+}. En Lisp, los argumentos a
   una función son los átomos o listas que siguen la función. Los valores
   devueltos por la evaluación de estos átomos o listas son pasados a la
   función. Funciones diferentes requieren diferentes números de argumentos;
   algunas funciones no requieren ninguno más.@n{2}

*** Tipos de argumentos de datos

    Los tipos de datos que deberían ser pasados a una función dependen de que
    tipo de información usan. Los argumentos a una función tales como @c{+}
    deben tener valores que son números, puesto que @c{+} añade
    números. Otras funciones usan diferentes tipos de datos para sus
    argumentos.

    Por ejemplo, la función @c{concat} enlaza o une dos o más cadenas de
    texto para producir una cadena. Los argumentos son cadenas. La
    concatenación de los dos caracteres de cadenas @c{abc}, @c{def} producen
    la cadena simple @c{abcdef}. Esto puede ser visto evaluando lo siguiente:

    @smallexample
      (concat "abc" "def")
    @end smallexample

    El valor producido para evaluar esta expresión es @c{"abcdef"}.

    Una función tal como @c{substring} usa como argumento tanto una cadena
    como números. La función devuelve una parte de la cadena, una subcadena
    del primer argumento. Esta función toma tres argumentos. Su primer
    argumento es la cadena de caracteres, el segundo y tercer argumento son
    números que indican el principio y el fin de la subcadena. Los números
    son un contaje del número de caracteres (incluyendo espacios y
    puntuaciones) desde el principio de la cadena.

    Por ejemplo, si evalúa lo siguiente:

    @smallexample
      (substring "El rápido zorro marrón saltó." 12 17)
    @end smallexample

    se verá @c{"zorro"} en el área echo. Los argumentos son la cadena y los
    dos números.

    Nótese que la cadena pasada a @c{substring} es un átomo simple incluso
    aunque sea hecho de varias palabras separadas por espacios. Lisp cuenta
    cada cosa entre dos marcas de citas como parte de la cadena, incluyendo
    los espacios. Se puede pensar la función @c{substring} como una forma de
    ‘despedazar átomos’ ya que toma un átomo indivisible y extrae una
    parte. Sin embargo, @c{substring} es solo capaz de extraer una subcadena
    desde un argumento que es una cadena, no otro tipo de átomo tal como un
    número o símbolo.

*** Un argumento como el valor de una variable o lista

    Un argumento puede ser un símbolo que devuelva un valor cuando es
    evaluado. Por ejemplo, cuando el símbolo @c{fill-column} por sí mismo es
    evaluado, devuelve un número. Este número puede ser usado en una adición.

    Posicionar el cursor después la siguiente expresión y escribe @k{C-x
    C-e}:

    @smallexample
      (+ 2 fill-column)
    @end smallexample

    El valor será un número dos más que tu tienes evaluando @c{fill-column}
    solo. Para mí, este es 74, porque mi valor de @c{fill-column} es 72.

    Como se ha visto, un argumento puede ser un símbolo que devuelve un valor
    cuando se evalúa. Además, un argumento puede ser una lista que devuelve
    un valor cuando es evaluada. Por ejemplo, en la siguiente expresión, los
    argumentos para la función @c{concat} son las cadenas @c{"Los"} y @c{"
    zorros rojos."} y la lista @c{(number-to-string (+ 2 fill-column))}.

    @smallexample
      (concat "Los " (number-to-string (+ 2 fill-column)) " zorros rojos.")
    @end smallexample

    Si se evalúa esta expresión––y si, como con mi Emacs, @c{fill-column} se
    evalúa a 72--- aparecerá @c{"Los 74 zorros rojos."} en el área
    echo. (Nótese que se debe poner espacio después de la palabra @'{Los} y
    antes de la palabra @'{rojos} y así es como aparecerá en la cadena
    final. La función @c{number-to-string} convierte los enteros que la
    función de adición devuelve una cadena. @c{number-to-string} también se
    conoce como @c{int-to-string}.)

*** Número de variables de argumentos

    Algunas funciones, tales como @c{concat}, @c{+}, o @c{*}, toman cualquier
    número de argumentos. (El @c{*} es el símbolo para multiplicar.) Esto
    puede ser visto evaluando cada uno de las siguientes expresiones en el
    camino usual. Que verás en el área echo que está impresa en este texto
    después de @'{⇒}, que puedes leer como ‘evaluar a’.

    En el primer conjunto, las funciones no tienen argumentos:

    @smallexample
      (+)       ⇒ 0

      (*)       ⇒ 1
    @end smallexample

    En este conjunto, las funciones tienen un argumento cada una:

    @smallexample
      (+ 3)     ⇒ 3

      (* 3)     ⇒ 3
    @end smallexample

    En este conjunto, las funciones tienen tres argumentos cada una:

    @smallexample
      (+ 3 4 5) ⇒ 12

      (* 3 4 5) ⇒ 60
    @end smallexample

*** Usando el tipo incorrecto de objeto como un argumento

    Cuando a una función se le pasa un argumento del tipo incorrecto, el
    interpréte Lisp produce un mensaje de error. Por ejemplo, la función
    @c{+} espera los valores de sus argumentos para ser números. Como un
    experimento nosotros podemos pasar el símbolo citado @c{hola} en vez de
    un número. Posicionar el cursor después la siguiente expresión y escribir
    @k{C-x C-e}:

    @smallexample
      (+ 2 'hola)
    @end smallexample

    Cuando se hace esto se generará un mensaje de error. Lo qué ha ocurrido
    es que @c{+} ha intentado añadir el 2 para el valor devuelto por
    @c{'hola}, pero el valor devuelto por @c{'hola} es el símbolo @c{hola},
    no un número. Solo los números pueden ser añadidos. Así @c{+} podría no
    encarrilar su adición.

    Se creará e introducirá un búffer @f{*Backtrace*} que dice:

    @smallexample
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error:
               (wrong-type-argument number-or-marker-p hello)
        +(2 hello)
        eval((+ 2 (quote hello)))
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    @end smallexample

    Como es normal, el mensaje de error intenta ser útil y tiene sentido
    después de que se aprenda cómo leerlo.@footnote{@c{(quote hola)} es una
    expresión de la abreviación @c{'hola}.}

    La primera parte del mensaje de error es honesto; dice @'{wrong type
    argument} (mal tipo de argumento). Lo siguiente viene con la misteriosa
    palabra de jerga @'{number-or-marker-p}. Esta palabra está intentando
    contar qué tipo de argumento @c{+} se espera.

    El símbolo @c{number-or-marker-p} dice que el intérprete Lisp está
    intentando determinar si la información presentada (el valor del
    argumento) es un número o una marca (un objeto especial representando una
    posición de buffer). Lo que hace es testear para ver si el @c{+} está
    siendo números dados para añadir. También chequea para ver si el
    argumento es algo llamado un marcador, que es una funcionalidad
    específica de Emacs Lisp. (En Emacs, las localizaciones en un búffer son
    grabadas como marcadores. Cuando la marca está asignado con el atajo
    @k{C-@@} o @k{C-@k{SPC}}, su posición se guarda como un marcador. La
    marca puede ser considerada un número––el número de caracteres la
    localización está desde el principio del búffer.)  En Emacs Lisp, @c{+}
    puede ser usado para añadir el valor numérico de posiciones de marca como
    números.

    La @'{p} de @c{number-or-marker-p} es el cuerpo de una práctica iniciada
    en los primeros días de la programación Lisp. La @'{p} es para
    ‘predicado’. En la jerga usada por los primeros investigadores de Lisp,
    un predicado se refiere a una función para determinar si alguna propiedad
    es verdadera o falsa. Así la @'{p} nos cuenta que @c{number-or-marker-p}
    es el nombre de una función que determina que el argumento dado es un
    número o una marca. Otros símbolos Lisp que finalizan en @'{p} incluyen
    @c{zerop}, una función que chequea si sus argumentos tienen el valor de
    cero, y @c{listp}, una función que prueba si sus argumentos son una
    lista.

    Finalmente, la última parte del mensaje de error es el símbolo
    @c{hello}. Esto es el valor del argumento que pasaba a @c{+}. Si la
    adición había sido pasada al tipo correcto de objeto, el valor pasado
    habría sido un número, tal como 37, en vez de un símbolo como
    @c{hello}. Pero entonces tu no habrías obtenido el mensaje de error.

    @ignore
      In GNU Emacs version 20 and before, the echo area displays an error
      message that says:

      @smallexample
        Mal tipo de argumento:@: number-or-marker-p, hello
      @end smallexample

      This says, in different words, the same as the top line of the
      @f{*Backtrace*} buffer.
    @end ignore

*** La función @c{message}

    Como @c{+}, la función @c{message} toma un número variable de
    argumentos. Es usado para enviar mensajes para el usuario y es así tan
    útil que nosotros lo describiremos aquí.

    Un mensaje está impreso en el área echo. Por ejemplo, se puede imprimir
    un mensaje en tu área echo evaluando la siguiente lista:

    @smallexample
      (message "¿Este mensaje aparece en el área echo!")
    @end smallexample

    La cadena entera entre comillas dobles es un argumento simple y está
    impreso @i{en todo}. (Nótese que en este ejemplo, el mensaje en sí
    aparecerá en el área echo con comillas comillas dobles; que es porque tu
    ves el valor devuelto por la función @c{message}. En la mayoría de los
    usos de @c{message} en programas que se escribe, el texto será impreso en
    el área echo como un efecto lateral, sin las comillas. Ver
    @l{multiply-by-seven en detalle, , @c{multiply-by-seven} en detalle},
    para un ejemplo de esto.)

    Sin embargo, si hay un @'{%s} en la cadena citada de caracteres, la
    función @c{message} no imprime el @'{%s} como tal, pero mira al argumento
    que sigue la cadena. Eso evalúa el segundo argumento e imprime el valor
    en la posición en la cadena donde el @'{%s} está.

    Puede ver esto posicionando el cursor después de la siguiente expresión y
    escribiendo @k{C-x C-e}:

    @smallexample
      (message "El nombre de este búffer es: %s." (buffer-name))
    @end smallexample

    En Info, @c{"El nombre de este búffer es: *info*."} aparecerá en el área
    echo. La función @c{buffer-name} devuelve el nombre del búffer como una
    cadena, que la función @c{message} inserta en lugar de @c{%s}.

    Para imprimir un valor como un entero, usa @'{%d} en el mismo camino que
    @'{%s}. Por ejemplo, para imprimir un mensaje en el área echo que sitúa
    el valor de @c{fill-column}, evalúa lo siguiente:

    @smallexample
      (message "El valor de fill-column es %d." fill-column)
    @end smallexample

    En mi sistema, cuando evalúo esta lista, @c{"El valor de fill-column es
    72"} aparece en mi área echo@n{3}

    Si hay más de una @'{%s} en la cadena citada, el valor del primer
    argumento siguiente la cadena citada es impresa en la posición del primer
    @'{%s} y el valor del segundo argunmento es impreso en la posición del
    segundo @'{%s}, y así.

    Por ejemplo, si se evalúa lo siguiente,

    @smallexample
      (message "¿Hay %d %s en la oficina!"
               (- fill-column 14) "elefantes rosas")
    @end smallexample

    un mensaje característico aparecerá en el área echo. En mi sistema dice
    @c{"¿Hay 58 elefantes rosas en la oficina!"}

    La expresión @c{(- fill-column 14)} está evaluado y el número resultante
    está insertado en lugar del @'{%d}; y la cadena entre dobles comillas,
    @c{"elefantes rosas"}, está tratado como un argumento simple e insertado
    en lugar del @'{%s}. (Esto es decir, una cadena entre comillas dobles se
    evalúa así mismo, como un número.)

    Finalmente, aquí está un ejemplo algo complejo que no solo ilustra la
    computación de un número, pero también muestra como se puede usar una
    expresión que genere el texto que es sustituido por @'{%s}:

    @smallexample
      (message "Él vió %d %s"
               (- fill-column 36)
               (concat (substring
                        "Los rápidos zorros marrones saltaron." 12 21)
                        "rojos trotando."))
    @end smallexample

    En este ejemplo, @c{message} tiene tres argumentos: la cadena, @c{"Él vió
    %d %s"}, después la expresión, que empieza con la función @c{concat}. El
    valor resultante desde la evaluación de @c{(- fill-column 32)} está
    insertado en lugar de @'{%d}; y el valor devuelto por la expresión
    empieza con @c{concat} está insertado en lugar del @'{%s}.

    Cuando se rellena la columna es 70 y se evalúa la expresión, el mensaje
    @c{"Se vieron 38 zorros rojos trotando."} aparece en tu área echo.

** Configurando el valor de una variable

   Hay varios caminos por el que una variable puede dar un valor. Uno de los
   caminos es usar la función @c{set} o la función @c{setq}.  Otro camino es
   usar @c{let} (@l{let}). (La jerga para este proceso es @:{bind} una
   variable para un valor.)

   Las siguientes secciones no solo describen cómo @c{set} y @c{setq}
   funcionan pero también ilustran como los argumentos pasan.

*** Usando set

    Para asignar el valor del símbolo @c{flores} a la lista @c{'(rosa violeta
    margarita botóndeoro)}, evalúa la siguiente expresión posicionando el
    cursor después de la expresión y escribiendo @k{C-x C-e}.

    @smallexample
      (set 'flores '(rosa violeta margarita botóndeoro))
    @end smallexample

    La lista @c{(rosa violeta margarita botóndeoro)} aparecerá en el área
    echo. Esto es lo que está @e{devuelto} por la función @c{set}. Como
    efecto lateral, el símbolo @c{flores} está asociado a la lista; esto es,
    el símbolo @c{flores}, que puede ser visto como una variable, que es dada
    por la lista como su valor. (Este proceso, ilustra un efecto lateral al
    intérprete Lisp: asignando el valor, que puede ser el efecto primario en
    el que los humanos estamos interesados. Esto es porque cada función Lisp
    debe devolver un valor si no se obtiene un error, pero solo tendrá un
    efecto colateral si está diseñado para tener uno.)

    Después de evaluar la expresión @c{set}, se puede evaluar el símbolo
    @c{flores} y devolverá el valor asignado. Aquí está el símbolo. Emplaza
    tu cursor después y escribe @k{C-x C-e}.

    @smallexample
      flores
    @end smallexample

    Cuando se evalúa @c{flores}, la lista @c{(rosa violeta margarita
    botóndeoro)} aparece en el área echo.

    Incidentalmente, si se evalúa @c{'flores}, la variable con una comilla en
    frente, se ve en el área echo y es el símbolo en sí: @c{flores}.  Aquí
    está el símbolo citado, así se puede probar esto:

    @smallexample
      'flores
    @end smallexample

    Nótese también, que cuando se usa @c{set}, se necesitan citar ambos
    argumentos a @c{set}, a menos que se quiera evaluar. Puesto que nosotros
    no queremos argumentos evaluados, ni la variable @c{flores}, ni la lista
    @c{(rosa violeta margarita botóndeoro)}, se citan. (Cuando se usa @c{set}
    sin citar su primer argumento, el primer argumento se evalúa antes que
    cualquier cosa se haga. Si se hizo esto y @c{flores} no tenía un valor
    ya, se tendría un mensaje de error que el @'{Valor de símbolo como
    variable esté vacío}; por otro lado, si @c{flores} no devolvió un valor
    después de que fuera evaluado, el @c{set} intentaría establecer un valor
    después de que fuera devuelto. Hay situaciones donde esto es lo correcto
    para la función a hacer, pero tales situaciones son raras.)

*** Usando @c{setq}

    Como materia práctica, casi siempre se cita el primer argumento a
    @c{set}. La combinación de @c{set} y un argumento citado primero es común
    que tiene su propio nombre: la forma especial @c{setq}. Esta forma
    especial es solo como @c{set} excepto que el primer argumento se cita
    automáticamente, así no se necesita escribir la marca de cita por uno
    mismo. También, como una conveniencia añadida, @c{setq} permite asignar
    varias variables diferentes a diferentes valores, todo en una expresión.

    Para asignar el valor de la variable @c{carnívoros} a la lista @c{'(leon
    tigre leopardo)} usando @c{setq}, la siguiente expresión que se usa es:

    @smallexample
      (setq carnivoros '(leon tigre leopardo))
    @end smallexample

    Esto es exactamente lo mismo que usar @c{set} excepto que el primer
    argumento se cita automáticamente por @c{setq}. (El @'{q} en @c{setq}
    significa @c{quote}.)

    Con @c{set}, la expresión que se vería es:

    @smallexample
      (set 'carnivoros '(leon tigre leopardo))
    @end smallexample

    También, @c{setq} puede ser usado para asignar diferentes valores a
    diferentes variables. El primer argumento está asociado al valor del
    segundo argumento, el tercer argumento se asocia al valor del cuarto
    argumento, y así. Por ejemplo, se podría usar lo siguiente para asignar
    una lista de árboles al símbolo @c{arboles} y una lista herbívoros al
    símbolo @c{herbivoros}:

    @smallexample
      (setq arboles '(pino abeto roble arce)
            herbivoros '(gacela antilope cebra))
    @end smallexample

    (La expresión podría también haber estado en una línea, pero podría no
    haberse ajustado en una página; y los humanos encuentran que es fácil
    leer listas formateadas.)

    Aunque yo he estado usando el término ‘assign’, hay otro camino de pensar
    acerca de los trabajos de @c{set} y @c{setq}; y que es decir que @c{set}
    y @c{setq} creen el símbolo @e{point} a la lista. Este camino posterior
    de pensamiento es muy común y en los capítulos siguientes volveremos al
    menos a un símbolo que tiene un valor, específicamente una lista,
    adjunta; o, expresa otros caminos, el símbolo asigna a “apuntar” a la
    lista.

*** Contando

    Aquí hay un ejemplo que muestra cómo usar @c{setq} en un contador. Se
    podría usar esto para contar cuantas veces una parte de un programa se
    repite por sí mismo. Primero asigna una variable a cero; entonces añade
    uno al número cada vez que el programa se repite así mismo. Para hacer
    esto, se necesita una variable que sirve como un contador, y dos
    expresiones: una expresión @c{setq} que asigna la variable contador a
    cero; y una segunda expresión @c{setq} que incrementa el contador cada
    vez que eso es evaluado.

    @smallexample
      (setq counter 0)                ; @r{Se inicializa.}

      (setq counter (+ counter 1))    ; @r{Se incrementa.}

      counter                         ; @r{Contador.}
    @end smallexample

    (El siguiente texto el @'{;} son comentarios. Ver Véase Sección
    @l{Cambiar una definición de función}.)

    Si evalúas la primera de estas expresiones, el inicializador, @c{(setq
    counter 0)}, y entonces evalúa la tercera expresión, @c{counter}, el
    número @c{0} aparecerá en el área echo. Si entonces se evalúa la segunda
    expresión, el incrementador, @c{(setq counter (+ counter 1))}, el
    contador obtendrá el valor 1. Así si evalúas de nuevo @c{counter}, el
    número @c{1} aparecerá en el área echo. Cada vez que se evalúa la segunda
    expresión, el valor del contador será incrementado.

    Cuando se evalúa el incrementador, @c{(setq counter (+ counter 1))}, el
    intérprete Lisp primero evalúa la lista interna; esta es la adición. En
    orden para evaluar esta lista, debe evaluar la variable @c{counter} y el
    número @c{1}. Cuando evalúa la variable @c{counter}, recibe su valor
    actual. Esto pasa su valor y el número @c{1} para el @c{+} que los añade
    juntos. La suma es devuelta como el valor de la list propia pasada al
    @c{setq} que asigna la variable @c{counter} a este nuevo valor. De este
    modo, el valor de la variable @c{counter}, se cambia.

** Resumen

   Aprender Lisp es como escalar una montaña en la que la primera parte es la
   empinada. Ahora has escalado la parte más difícil; y lo que queda es más
   fácil.

   En resumen,

   - Los programas Lisp son hechos de expresiones, que son listas o átomos
     simples.

   - La listas son hechas de cero o más átomos o listas internas, separadas
     por espacios en blanco y rodeados de paréntesis. Una lista puede estar
     vacía.

   - Los átomos son símbolos multi-carácter, como @c{forward-paragraph}, los
     símbolos de caracteres como @c{+}, cadenas de caracteres entre marcas de
     comillas dobles, o números.

   - Un número se evalúa a sí mismo.

   - Una cadena entre comillas dobles también se evalúa a sí mismo.

   - Cuando se evalúa un símbolo a sí mismo, su valor se devuelve.

   - Cuando se evalúa una lista, el intérprete mira el primer símbolo en la
     lista y en la definición de la función asociada a este símbolo. Así se
     traen las instrucciones en la definición función.

   - Una marca de cita (quote) simple, @c{'}, cuenta al intérprete Lisp que
     devolvería la siguiente expresión como se escribe, y se evalúa como si
     la cita no estuviera.

   - Los argumentos son la información pasada a una función. Los argumentos a
     una función son computados evaluando el resto de los elementos de la
     lista de la que la función es el primer elemento.

   - Una función siempre devuelve un valor cuando se evalúa (a menos que
     obtenga un error); además, puede también traer alguna acción llamada un
     “efecto colateral”. En muchos casos, un propósito de la función primaria
     es crear un efecto colateral.

** Ejercicios

   Unos pocos ejercicios simples:

   - Genera un mensaje de error evaluando un símbolo apropiado que no está
     entre paréntesis.

   - Genera un mensaje de error evaluando un símbolo apropiado que está entre
     paréntesis.

   - Crea un contador que incremente por dos en vez de uno.

   - Escribe una expresión que imprima un mensaje en el área cuando es
     evaluada.

* Practicando evaluación

  Antes de aprender como escribir una definición de función en Emacs Lisp, es
  útil gastar un poco de tiempo evaluando varias expresiones que ya han sido
  escritas. Estas expresiones serán listas con las funciones como su primer
  (y con frecuencia único) elemento. Desde alguna de las funciones asociadas
  con búffers son ambas simples e interesantes, nosotros empezaremos con
  estas. En esta sección, evaluaremos unas pocas de estas. En otra sección,
  estudiaremos el código de varios otros funciones relacionadas con búffers,
  para ver cómo fueron escritas.

  @i{Siempre y cuando se de un comando de edición} a Emacs Lisp, tal como el
  comando para mover el cursor o el scroll de la pantalla, @i{se está
  evaluando una expresión,} el primer elemento del que es una función. @i{Así
  es cómo Emacs funciona}.

  Cuando se escriben teclas, se causa que el intérprete Lisp evalúe una
  expresión que devuelve resultados. Incluso escribiendo texto plano se
  evalúa la función Emacs Lisp, en este caso, uno usa
  @c{self-insert-command}, simplemente inserta el caracter que se escribió.
  Las funciones que se evalúan escribiendo atajos de teclado se llaman
  funciones @:{interactive}, o @:{comandos}; como crear una función
  interactive será ilustrada en el capítulo sobre cómo escribir definiciones
  de funciones. Ver @l{Crear una Función Interactive}.

  Además de escribir comandos de teclado, se ha visto un segundo camino para
  evaluar una expresión: posicionar el cursor después de una lista y
  escribiendo @k{C-x C-e}. Esto es lo que se hará en el resto de esta
  sección. Hay otros caminos de evaluar una expresión también; que serán
  descritos como vienen.

  Siendo usadas para evaluación práctica, las funciones mostradas en las
  siguientes pocas secciones son importantes en su propio derecho. Un estudio
  de estas funciones hace clara la distinción entre búffers y ficheros, cómo
  cambiar a un búffer, y como determinar una localización con ella.

** Nombres de búffer

   Las dos funciones, @c{buffer-name} y @c{buffer-file-name}, muestra la
   diferencia entre un fichero y un búffer. Cuando se evalúa la siguiente
   expresión, @c{(buffer-file-name)}, el nombre del fichero para el que el
   búffer se refiere aparece en el área echo. Normalmente, el nombre devuelto
   por @c{(buffer-name)} es lo mismo que el nombre del fichero para el que se
   refiere, y el nombre devuelto por @c{(buffer-file-name)} es la ruta
   completa del fichero.

   Un fichero y un búffer son dos entidades diferentes. Un fichero es
   información grabada de manera permanente en el ordenador (a menos que se
   borre). Un búffer, por otro lado, es información dentro de Emacs que
   desaparecerá al final de la sesión de la edición (o cuando se mate el
   búffer). Normalmente, un búffer contiene información que se ha copiado
   desde un fichero; nosotros decimos que el búffer está @:{visitando} este
   fichero. Esta copia es la que se trabaja y modifica. Los cambios al búffer
   no cambian el fichero, hasta ser guardados. Cuando se guarda el búffer, el
   búffer está copiado al fichero y está de este modo salvado de manera
   permanente.

   Si está leyendo esto en Info dentro de GNU Emacs, se puede evaluar cada
   una de las siguientes expresiones posicionando el cursor después de eso y
   escribiendo @k{C-x C-e}.

   @example
     (buffer-name)

     (buffer-file-name)
   @end example

   Cuando hago esto en Info, el valor devuelto para la evaluación de
   @c{(buffer-name)} es @f{"*info"}, y el valor devuelto por evaluar
   @c{(buffer-file-name)} es @f{nil}.

   Por otro lado, mientras se está escribiendo este documento, el valor
   devuelto por la evaluación de @c{(buffer-name)} es
   @f{"introduction.texinfo"}, y el valor devuelto por la evaluación
   @c{(buffer-file-name)} es @f{"/gnu/work/intro/introduction.texinfo"}.

   La forma es el nombre del búffer y lo posterior es el nombre del
   fichero. En Info, el nombre búffer es @f{"*info*"}. Info no apunta a
   cualquier fichero, así el resultado de evaluar @c{(buffer-file-name)}] es
   @f{nil}. El símbolo @c{nil} es desde la palabra latina para ‘nada’; en
   este caso, significa que el búffer no está asociado con cualquier
   fichero. (En Lisp, @c{nil} también se usa con el significado de ‘falso’ y
   es sinómino de la lista vacía, @c{()}.)

   Cuando estoy escribiendo, el nombre de mi búffer es
   @f{"introduction.texinfo"}. El nombre del fichero al que se apunta es
   @f{"/gnu/work/intro/introduction.texinfo"}.

   (En las expresiones, los paréntesis hacen que el intérprete Lisp trate a
   @c{buffer-name} y @c{buffer-file-name} como funciones; sin los paréntesis,
   el intérprete intentaría evaluar los símbolos como variables. Ver
   @l{Variables}.)

   A pesar de la distinción entre ficheros y búffers, con frecuencia se
   encuentra que hay personas que se refieren a un fichero cuando quieren un
   búffer y al revés. En realidad, la mayoría de las personas dicen, “Yo
   estoy editando un fichero,” en vez de decir, “Estoy editando un búffer que
   pronto se guardará en un fichero.”  Es casi siempre claro desde el
   contexto que las personas quieren decir. Al tratar con programas de
   ordenador, sin embargo, es importante tener la distinción en mente, ya que
   el ordenador no es una persona inteligente.

   La palabra ‘búffer’, por el camino, viene desde el significado de la
   palabra como una cuña que mata la fuerza de una colisión. En los primeros
   ordenadores, un búffer acuñaba la interacción entre ficheros y la unidad
   de procesamiento central. Los tambores o cintas que manejan un fichero y
   la unidad de procesamiento central fueron piezas de equipamiento que
   fueron muy diferentes a cualquier otra, trabajando a sus propias
   velocidades. El búffer se hizo posible para ellos a trabajar juntos de
   manera efectiva. Finalmente, el búffer creció siendo uno intermedio, un
   lugar tomado temporalmente, para ser el lugar donde el trabajo está
   hecho. Esta transformación es como un pequeño puerto de mar que crece
   dentro de una gran ciudad: una vez fué el lugar donde la carga era
   depositada temporalmente antes de ser cargada dentro de los barcos;
   entonces eso llega a ser un negocio y centro cultural en su propio
   derecho.

   No todos los búffers están asociados con ficheros. Por ejemplo, un búffer
   no visita cualquier fichero. De manera similar, un búffer @f{*Help*} no
   está asociado con cualquier fichero.

   Antaño, cuando se perdía un fichero @f{~/.emacs} y se empezaba una sesión
   Emacs escribiendo el comando @c{emacs} solo, sin nombrar ficheros Emacs
   iniciaba con el búffer @f{*scratch*} visible. En estos días, se ve una
   página de inicio. Se puede seguir uno de los comandos sugeridos en dicha
   pantalla, visitar un fichero, o presionar la barra espaciadora para lograr
   el búffer @f{*scratch*}.

   Si se cambia al búffer @f{*scratch*}, se escribe la posición del
   @c{(buffer-name)} del cursor después, y entonces escribe @k{C-x C-e} para
   evaluar la expresión. El nombre @c{*scratch*} será devuelto y aparecerá en
   el área echo. @c{*scratch*} es el nombre del búffer. Cuando se escribe
   @c{(buffer-file-name)} en el búffer @f{*scratch*} y evalúa que, @c{nil}
   aparecerá en el área echo, solo se hace cuando se evalúa
   @c{(buffer-file-name)} en Info.

   Incidentalmente, si se está en el búffer @f{*scratch*} y se quiere el
   valor devuelto por una expresión para aparecer en el búffer en sí del área
   echo, se escribe @k{C-u C-x C-e} en vez de @k{C-x C-e}. Esto causa que el
   valor devuelto aparezca después de la expresión. El búffer se verá así:

   @smallexample
     (buffer-name)"*scratch*"
   @end smallexample

   No se puede hacer esto en Info desde que Info es de solo lectura y no se
   permitirá que se cambien los contenidos en el búffer. Pero puedes hacer
   esto en cualquier búffer que se puede editar; y cuando se escribe código
   de documentación (tal como este libro), esta funcionalidad es muy útil.

** Obteniendo búffers

   La función @c{buffer-name} devuelve el @e{name} del búffer; para obtener
   el búffer @e{en sí}, una función diferente es necesaria: la función
   @c{current-buffer}. Si usa esta función en el código, que tiene en el
   búffer en sí.

   Un nombre y el objeto o entidad para el que el nombre se refiere son cosas
   diferentes. Tu no eres tu nombre, Tu eres una persona que otras personas
   se refieren por tu nombre. Si preguntas para hablar por Jorge y alguien
   escribe una carta con las letras @'{J}, @'{o}, @'{r}, @'{g}, y @'{e}
   escrito, tu podrías estar distraido, pero no estarías satisfecho. No
   quieres hablar al nombre, pero sí a la persona a la que el nombre se
   refiere. Un búffer es similar: el nombre del búffer scratch es
   @f{*scratch*}, pero el nombre no es el búffer. Para tener un búffer por sí
   mismo, se necesita usar una función tal como @c{current-buffer}.

   Sin embargo, hay una ligera complicación: si evalúas @c{current-buffer} en
   una expresión por sí mismo, como haremos aquí, lo que ves es una
   representación impresa del nombre del búffer sin los contenidos del
   búffer. Emacs funciona en este camino por dos razones: el búffer puede
   contener miles de líneas––eso es demasiado largo para ser convenientemente
   mostrado; y, otro búffer puede tener los mismos contenidos pero un nombre
   diferente, y es importante distinguirlo.

   Aquí hay una expresión conteniendo la función:

   @smallexample
     (current-buffer)
   @end smallexample

   Si se evalúa esta expresión de Info en Emacs en el camino normal,
   @f{#<buffer *info*>} aparecerá en el área echo. El formato especial indica
   que el búffer por sí mismo está siendo devuelto, en vez de solo su nombre.

   Incidentalmente, mientras se escribe un número o símbolo en un programa,
   no se puede hacer esto con la representación impresa del búffer: el único
   camino para tener un búffer por sí mismo es con una función tal como
   @c{current-buffer}.

   Un función relacionada es @c{other-buffer}. Esto devuelve los buffers
   seleccionados más recientemente que los únicos en los que tu estás
   actualmente, no una representación impresa de su nombre. Si tu
   recientemente has cambiado fuera de @f{*scratch*} búffer, @c{other-buffer}
   devolverá este búffer.

   Se puede ver esto evaluando la expresión:

   @smallexample
     (other-buffer)
   @end smallexample

   Verás que @f{#<buffer *scratch*>} aparece en el área echo, o el nombre de
   cualquier otro búffer que se cambió recientemente@n{4}

** Cambiando búffers

   La función @c{other-buffer} actualmente proporciona un búffer cuando es
   usada como un argumento a una función que uno requiere. Podemos ver esto
   usando @c{other-buffer} y @c{switch-to-buffer} para cambiar al búffer
   diferente.

   Pero primero, una breve introducción a la función @c{switch-to-buffer}.
   Cuando se cambia atrás y adelante desde Info al búffer para evaluar
   @c{(buffer-name)}, normalmente se escribe @k{C-x b} y se visualiza
   @f{*scratch*}@n{5} cuando se ve en el minibuffer el nombre del búffer al
   que se quiere cambiar. El atajo, @k{C-x b}, causa que el intérprete Lisp
   evalúe la función interactiva @c{switch-to-buffer}. Como nosotros dijimos
   antes, así es como Emacs funciona: diferentes atajos de teclado llaman o
   ejecutan diferentes funciones. Por ejemplo, @k{C-f} llama
   @c{forward-char}, @k{M-e} llama a @c{forward-sentence} y así

   Escribiendo @c{switch-to-buffer} en una expresión, y dándole un búffer
   para cambiar, se puede cambiar a búffers solo como @k{C-x b} hace.

   @smallexample
     (switch-to-buffer (other-buffer))
   @end smallexample

   El símbolo @c{switch-to-buffer} es el primer elemento de la lista, así el
   intérprete Lisp tratará eso como una función y trae las instrucciones
   adjuntas a eso. Pero antes de hacer esto, el intérprete notará este
   @c{other-buffer} está dentro de paréntesis y trabaja en este símbolo
   primero. @c{other-buffer} es el primero (y en este caso, el único)
   elemento de esta lista, así el intérprete Lisp llama o ejecuta la
   función. Eso devuelve otro búffer. Después, el intérprete ejecuta
   @c{switch-to-buffer}, pasando, como un argumento, el otro búffer, que es
   al que Emacs cambia. Si está leyendo esto en Info, prueba esto ahora.
   Evalúa la expresión. (Para volver, escribe @k{C-x b
   @k{RET}}.)@n{6}

   En los ejemplos de programación en secciones posteriores de este
   documento, se ve la función @c{set-buffer} con más con frecuencia que
   @c{switch-to-buffer}. Esto es porque a diferencia de los programas de
   ordenador: los humanos tienen ojos y esperan ver el búffer en el que ellos
   están trabajando en sus terminales de ordenador. Esto es tan obvio, que
   casi no hace falta decirlo. Sin embargo, los programas no tienen
   ojos. Cuando un programa de ordenador trabaja en un búffer, el búffer no
   necesita ser visible en la pantalla.

   @c{switch-to-buffer} está diseñado para humanos y hace dos cosas
   diferentes: cambia el búffer para el que la atención de Emacs está
   dirigida; y cambia el búffer mostrada en la ventana al nuevo
   búffer. @c{set-buffer}, por otro lado, hace solo una cosa: eso cambia la
   atención del programa del ordenador a un búffer. El búffer en la pantalla
   permanece sin cambios (de acuerdo, normalmente no ocurre nada hasta que el
   comando finaliza ejecutándose).

   También, nosotros hemos introducido otro término de jerga, la palabra
   @:{llamada}. Cuando tu evalúas una lista en el que el primer símbolo es
   una función, tu estás llamando a esta función. El uso del término viene
   desde la noción de la función como una entidad que puede hacer alguna cosa
   para tí si tu la ‘llamas’ --- es decir, es una entidad que puede arreglar
   un problema si le llamas a él o a ella.

** Tamaño de búffer y la localización del punto

   Finalmente, permítame en varias funciones simples, @c{buffer-size},
   @c{point}, @c{point-min}, y @c{point-max}. Estas dan información acerca
   del tamaño de un búffer y la localización del punto con eso.

   La función @c{buffer-size} te cuenta el tamaño del búffer actual; que es,
   la función un contaje del número de caracteres en el buffer.

   @smallexample
     (buffer-size)
   @end smallexample

   Se puede evaluar esto en el camino usual, posicionando el cursor después
   de la expresión y escribiendo @k{C-x C-e}.

   En Emacs, la posición actual del cursor es llamada @:{punto}. La expresión
   @c{(point)} devuelve un número que cuenta donde está localizado como un
   contaje del número de caracteres desde el principio del búffer al punto.

   Se puede ver el contaje de caracteres apuntar en este búffer evaluando la
   siguiente expresión en el camino normal:

   @smallexample
     (point)
   @end smallexample

   Mientras escribo esto, el valor de @c{point} es 65724. La función
   @c{point} está frecuentemente usada en alguno de los ejemplos posteriores
   en este libro.

   El valor del punto depende, de acuerdo, a la posición que tiene en el
   búffer. Si se evalúa punto en este lugar, el número será largo:

   @smallexample
     (point)
   @end smallexample

   Para mí, el valor del punto en esta posición es 66043, lo que significa
   que hay 319 caracteres (incluyendo espacios) entre las dos
   expresiones. (Sin duda, se verán diferentes números, puesto que se ha
   editado esto desde que se evaluó (point).)

   La función @c{point-min} es similar a @c{point}, pero eso devuelve del
   valor mínimo permisible del punto en el búffer actual. Este es el número 1
   a menos que @:{narrowing} esté en efecto. (Narrowing, @e{Encogiendo} es un
   mecanismo donde uno se puede encoger a uno mismo, o un programa, a
   operaciones en solo un parte de un búffer. @l{Encogiendo y extendiendo}.)
   Así, la función @c{point-max} devuelve el valor del valor máximo
   permisible del punto en el búffer actual.

** Ejercicio

   Encuentra un fichero con que tu estás trabajando y mueve hasta la
   mitad. Encuentra el nombre de búffer, el nombre del fichero, tamaño, y su
   posición en el fichero.

* Cómo escribir definiciones de funciones

  Cuando el intérprete evalúa una lista, se ve si el primer símbolo en la
  lista tiene definición adjunta; o, pone otro camino, si el símbolo apunta a
  una definición de función. Si lo hace, el ordenador trae las instrucciones
  en la definición. Un símbolo que tiene una definición de función llamada,
  simplemente, una función (aunque apropiadamente hablando, la definición es
  la función y el símbolo se refiere a eso).

  Todas las funciones están definidas en términos de otras funciones, excepto
  por unas nuevas funciones @:{primitivas} que son escritas en el lenguaje de
  programación C. Cuando se escriben definiciones de funciones, se escriben
  en Emacs Lisp y se usan otras funciones como bloques en
  construcción. Algunas de las funciones usadas en sí mismas están escritas
  en Emacs Lisp (quizás por tí) y algunas serán primitivas escritas en
  C@. Las funciones primitivas están escritas en C así podemos fácilmente
  ejecutarlas en GNU Emacs en cualquier ordenador que tiene suficiente poder
  y puede ejecutar C.

  Permíteme enfatizar esto: cuando se escribe código en Emacs Lisp, no se
  distinge entre el uso de funciones escritas en C y el uso de funciones
  escritas en Emacs Lisp. La diferencia es irrevelante. Yo menciono la
  distinción solo porque es interesante conocerla. A menos que se investigue,
  uno no se da cuenta si una función ya escrita es escrita en Emacs Lisp o C.

** La forma especial @c{defun}

   En Lisp, un símbolo tal como @c{mark-whole-buffer} tiene código adjunto
   que cuenta lo que el ordenador hace cuando la función es llamada. Este
   código es llamado la @:{definición de función} y es creado evaluando una
   expresión Lisp que empieza con el símbolo @c{defun} (que es una
   abreviación para @e{función define}). Porque @c{defun} no evalúa sus
   argumentos en el camino usual, eso se llama @:{forma especial}.

   En secciones subsiguientes, miraremos en definiciones de función desde el
   código fuente Emacs, tales como @c{mark-whole-buffer}. En esta sección,
   describiremos una definición de función simple, así puedes ver como se
   ve. Esta definición de función usa aritmética porque es un ejemplo
   simple. Algunas personas no le gustan los ejemplos usando aritmética; sin
   embargo, si usted es tal persona, no se asuste. En realidad, cualquier
   código que se puede estudiar en esta introducción va a recordar a
   aritmética o matemáticas. Los ejemplos de manera mayoritaria involucran
   texto en un camino u otro.

   Una definición de función tiene cinco partes siguiendo la palabra
   @c{defun}:

   1. El nombre del símbolo para el que la definición de función sería
      adjunta.

   2. Una lista de los argumentos que serán pasados a la función. Si no hay
      argumentos, tendremos una lista vacía, @c{()}.

   3. Documentación describiendo la función. (Técnicamente opcional, pero
      fuertemente recomendada.)

   4. Opcionalmente, una expresión para crear la función interactive así se
      puede usar escribiendo @k{M-x} y entonces el nombre de la función; o
      escribiendo una tecla apropiada o acorde.

   5. El código que instruye el ordenador qué hacer: el @:{cuerpo} de la
      definición de función.


   Es útil pensar las cinco partes de una definición de función siendo
   organizada en una plantilla, con slots para cada parte:

   @smallexample
     (defun @var{function-name} (@var{arguments}…)
       "@var{documentacion-opcional}…"
       (interactive @var{argument-passing-info})     ; @r{opcional}
       @var{body}…)
   @end smallexample

   Por ejemplo, aquí está el código para una función que multiplica sus
   argumentos por 7. (Este ejemplo no es interactivo. Ver @l{Crear una
   Función Interactive}, para esta información.)

   @smallexample
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
   @end smallexample

   Esta definición empieza con un paréntesis y el símbolo @c{defun} seguido
   por el nombre de la función.

   El nombre de la función está seguido por una lista que contiene los
   argumentos que serán pasados a la función. Esta lista es llamada por la
   @:{lista de argumentos}. En este ejemplo, la lista tiene solo un elemento,
   el símbolo @c{número}. Cuando la función es usada, el símbolo será
   asociado al valor que es usado como el argumento para la función

   En vez de elegir la palabra @c{número} por el nombre del argumento, podría
   haber escogido cualquier otro nombre. Por ejemplo, podría haber elegido la
   palabra @c{multiplicando}. Yo escojo la palabra ‘número’ porque cuenta qué
   tipo de valor se pretende para este slot; pero yo podría haber elegido
   ‘multiplicando’ para indicar el rol que el valor emplaza en este slot
   jugará en los trabajos de la función. Yo podría haber llamado @c{foogle},
   pero habría sido una mala elección porque no contaría qué significa. La
   elección del nombre es subir al programador y habría elegido crear el
   significado claro de la función.

   En realidad, se puede elegir cualquier nombre que se desee para un símbolo
   en una lista de argumentos, incluso el nombre del símbolo usado en alguna
   otra función: el nombre a usar en una lista de argumentos es privado para
   esta definición particular. En esta definición, el nombre se refiere a una
   entidad diferente que cualquiera que usa el mismo nombre fuera de la
   definición de función. Supón que tienes un apodo ‘corto’ en tu familia;
   cuando tus miembros de familia se refieren a ‘corto’, significa el
   apodo. Pero fuera de tu familia, en una película, por ejemplo, el nombre
   ‘corto’ se refiere a alguien más. Porque un nombre en una lista de
   argumentos es privado para la definición de la función, se puede cambiar
   el valor de un símbolo dentro del cuerpo de una función sin cambiar su
   valor fuera de la función. El efecto es similar a este producido por una
   expresión @c{let}. (Ver sección @l{let, @c{let}}.)

   @ignore
     Note also that we discuss the word ‘number’ in two different ways: as a
     symbol that appears in the code, and as the name of something that will
     be replaced by a something else during the evaluation of the function.
     In the first case, @c{number} is a symbol, not a number; it happens
     that within the function, it is a variable who value is the number in
     question, but our primary interest in it is as a symbol.  On the other
     hand, when we are talking about the function, our interest is that we
     will substitute a number for the word @var{number}.  To keep this
     distinction clear, we use different typography for the two
     circumstances.  When we talk about this function, or about how it works,
     we refer to this number by writing @var{number}.  In the function
     itself, we refer to it by writing @c{number}.
   @end ignore

   La lista de argumentos está seguida por la documentación que describe la
   función. Esto es lo que tu ves cuando tu escribes @k{C-h f} y el nombre de
   una función. Incidentalmente, cuando se escribe una documentación como
   esta, se haría la primera línea una frase completa desde algunos comandos,
   tal como @c{apropos}, imprime solo la primera línea de una documentación
   multi-línea. También, no indentaría la segunda línea de una documentación,
   si tu tienes una, esto se ve cuando usas @k{C-h f}
   (@c{describe-function}). La documentación es opcional, pero es también
   útil, debería ser incluido en casi cualquier función que se escribe.

   La tercera línea del ejemplo consiste en el cuerpo de la definición de
   función. (La mayoría de las definiciones de funciones, de acuerdo, son más
   largas que esto.) En esta función, el cuerpo es la lista, @c{(* 7
   number)}, que dice multiplicar el valor de @var{número} por 7. (En Emacs
   Lisp, @c{*} es la función para la multiplicación, solo como @c{+} es la
   función de suma.

   Cuando se usa la función @c{multiply-by-seven}, el argumento @c{number}
   evalúa para el número actual que quiere ser usada. Aquí hay un ejemplo que
   muestra como @c{multiply-by-seven} es usada; pero ¿no intentes evaluar
   esto primero!.

   @smallexample
     (multiply-by-seven 3)
   @end smallexample

   El símbolo @c{número}, especificado en la definición de función en la
   siguiente sección, es dada o “emparejado a” el valor 3 en el uso actual de
   la función. Note que aunque @c{número} estaba dentro de paréntesis en la
   definición de función, el argumento pasado a la función
   @c{multiply-by-seven} no está entre paréntesis. Los paréntesis son
   escritos en la definición de función así el ordenador puede figurarse
   donde la lista de argumentos finaliza y el resto de la definición de
   función empieza.

   Si se evalúa este ejemplo, se obtendrá un mensaje error. (¿Ve adelante,
   pruébalo!) Esto es porque hemos escrito la definición de función pero no
   le hemos contado todavía al ordenador la definición––no se ha instalado (o
   ‘cargado’) la definición de función en Emacs. Instalando una función es el
   proceso que cuenta al intérprete Lisp la definición de la función. La
   instalación se describe en la siguiente sección.

** Instalar una definición de función

   Si está leyendo esto dentro de Info en Emacs, se puede probar la función
   @c{multiply-by-seven} evaluando primero la definición de función y
   entonces evaluando @c{(multiply-by-seven 3)}. Una copia de la definición
   sigue. Emplaza el cursor después del último paréntesis de la definición de
   función y escribe @k{C-x C-e}. Cuando se hace esto, @c{multiply-by-seven}
   aparecerá en el área echo. (Lo que significa es que cuando una definición
   de función es evaluada, el valor devuelto es el nombre de la función
   definida.) Al mismo tiempo, esta acción instala la definición de función.

   @smallexample
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
   @end smallexample

   Evaluando esta @c{defun}, se ha instalado @c{multiply-by-seven} en
   Emacs. La función es ahora solo una parte de Emacs como @c{forward-word} o
   cualquier otra editando la función que se usa. (@c{multiply-by-seven}
   estará instalada hasta que sales de Emacs. Para recargar código
   automáticamente siempre y cuando empieces Emacs, ver @l{Instalación
   Permanente, , Instalar Código Permanentemente}.)

   Se puede ver el efecto de instalar @c{multiply-by-seven} evaluando el
   siguiente ejemplo. Localiza el cursor después de la siguiente expresión y
   escribe @k{C-x C-e}. El número 21 aparacerá en el área echo.

   @smallexample
     (multiply-by-seven 3)
   @end smallexample

   Si lo desea, se puede leer la documentación para la función escribiendo
   @k{C-h f} (@c{describe-function}) y entonces el nombre de la función,
   @c{multiply-by-seven}. Cuando haces esto, una ventana @f{*Help*} aparecerá
   en tu pantalla que dice:

   @smallexample
     multiply-by-seven es una función Lisp.
     (multiply-by-seven NUMBER)

     Multiplicar NUMERO por siete.
   @end smallexample

   (Para devolver a una ventana simple en tu pantalla, escribe @k{C-x 1}.)

*** Cambiar una definición de función

    Si se quiere cambiar al código en @c{multiply-by-seven}, solo
    reescríbelo. Para instalar la nueva versión en lugar de la vieja, evalúa
    la definición de la función de nuevo. Así, sé cómo modificar el código en
    Emacs. Es muy simple,

    Por ejemplo, se puede cambiar la función @c{multiply-by-seven} añade el
    número por sí mismo siete veces en vez de multiplicar el número por
    siete. Eso produce la misma respuesta, pero por una ruta diferente. Al
    mismo tiempo, añadiremos un comentario; un comentario es texto que el
    intérprete Lisp ignora, pero un lector humano puede encontrar útil o
    iluminante. El comentario es que esto es la “segunda versión”.

    @smallexample
      (defun multiply-by-seven (number)       ; @r{Segunda versión.}
        "Multiplicar NUMERO por siete."
        (+ number number number number number number number))
    @end smallexample

    El comentario sigue por un punto y coma, @'{;}. En Lisp cada cosa en una
    línea sigue un punto y coma que es un comentario. El final de la línea es
    el fin del comentario. Para estrechar un comentario a través de dos o más
    líneas, empieza cada línea con un punto y coma.

    Véase Sección "Empezando un Fichero @f{.emacs}}" y Seccion "Comentarios"
    en @e(El Manual de Referencia de GNU Emacs Lisp), para más comentarios.

    Se puede instalar esta versión de la función @c{multiply-by-seven} para
    evaluándolo en el mismo camino que se evaluó la primera función: deja el
    cursor después de los últimos paréntesis y escribe @k{C-x C-e}.

    En resumen, esto es cómo se escribe código en Emacs Lisp: tu escribes una
    función; se instala; se testea; y entonces crea arreglos y mejoras e
    instálalas de nuevo.

** Crear una función interactive

   Se crea una función interactive emplazando una lista que empieza con la
   forma especial @c{interactive} inmediatamente después de la
   documentación. Un usuario puede invocar una función interactive
   escribiendo @k{M-x} y entonces el nombre de la función; o escribiendo las
   teclas para el que está emparejado, por ejemplo, escribiendo @k{C-n} para
   @c{next-line} o @k{C-x h} para @c{mark-whole-buffer}.

   De manera interesante, cuando se llama a una función interactive
   interactivamente, el valor devuelto no está automáticamente mostrado en el
   área echo. Esto es porque con frecuencia se llama a una función
   interactive para sus efectos laterales, tales como mover hacia adelante
   por una palabra o línea, y no para el valor devuelto. Si el valor devuelto
   fuera mostrado en el área echo cada vez que escribiste una tecla,
   distraería mucho

   Tanto el uso de la forma especial @c{interactive} y un camino para mostrar
   un valor en el área echo puede ser ilustrada creando una versión
   interactiva de @c{multiply-by-seven}.

   Aquí está el código:

   @smallexample
     (defun multiply-by-seven (number)       ; @r{Versión Interactiva.}
       "Multiplicar NUMERO por siete."
       (interactive "p")
       (message "El resultado es %d" (* 7 number)))
   @end smallexample

   Se puede instalar este código emplazando tu cursor después y escribiendo
   @k{C-x C-e}. El nombre de la función aparecerá en tu área echo. Entonces,
   se puede usar este código escribiendo @k{C-u} y un número y entonces
   escribiendo @k{M-x multiply-by-seven} y presionando @k{RET}. La frase
   @'{El resultado es …} seguido por el producto aparecerá en el área echo

   Hablando más generalmente, se puede invocar a una función como ésta de dos
   maneras:

   1. Escribir un argumento prefijo que contiene el número a ser pasado, y
      entonces escribir @k{M-x} y el nombre de la función, como con @k{C-u 3
      M-x forward-sentence}; o,

   2. Escribe siempre de modo que la tecla/s de la función estén emparejadas,
      como con @k{C-u 3 M-e}.


   Ambos ejemplos solo trabajan mencionados idénticamente para mover puntos
   hacia adelantes tres frases. (Desde @c{multiply-by-seven} no está
   emparejado a una tecla, eso no podría ser usado como un ejemplo de
   emparejar la tecla.

   (Véase Sección @l{Atajos de teclado}, para aprender como emparejar un
   comando a una tecla.)

   Un argumento prefijo está pasado para una función interactive escribiendo
   la tecla @k{META} seguido por un número, por ejemplo, @k{M-3 M-e}, o
   escribiendo @k{C-u} y entonces un número, por ejemplo, @k{C-u 3 M-e} (si
   se escribe @k{C-u} sin un número, por defecto a 4).

*** Un @c{multiply-by-seven} interactivo

    Permite mirar el uso de la forma especial @c{interactive} y entonces en
    la función @c{message} en la versión interactiva de
    @c{multiply-by-seven}. Se volverá a llamar que la definición función se
    ve así:

    @smallexample
      (defun multiply-by-seven (number)       ; @r{Versión Interactiva.}
        "Multiplicar NUMERO por siete."
        (interactive "p")
        (message "El resultado es %d" (* 7 number)))
    @end smallexample

    En esta función, la expresión, @c{(interactive "p")}, es una lista de dos
    elementos. El @c{"p"} cuenta Emacs a pasar el argumento prefijo a la
    función y usar su valor para el argumento de la función.

    El argumento será un número. Esto significa que el símbolo @c{number}
    será asociado a un número en la línea:

    @smallexample
      (message "El resultado es %d" (* 7 number))
    @end smallexample

    Por ejemplo, si tu argumento prefijo es 5, el intérprete Lisp evaluará la
    línea como si fuera:

    @smallexample
      (message "El resultado es %d" (* 7 5))
    @end smallexample

    (Si está leyendo esto en GNU Emacs, se puede evaluar esta expresión por
    sí misma.) Primera, el intérprete evaluará la lista interna, que es @c{(*
    7 5)}. Esto devuelve un valor de 35. Lo siguiente, evaluará la lista
    externa, pasando los valores de la segunda y subsiguientes elementos de
    la lista a la función @c{message}.

    Como se ha visto, @c{message} es una función Emacs Lisp especialmente
    diseñada para enviar una línea de mensaje a un usuario. (Véase Sección
    @l{La función @c{message}}) En resumen, la función @c{message} imprime su
    primer argumento en el área echo como es, excepto para ocurrencia de
    @'{%d}, o @'{%s} (y varios otras %-secuencias que no hemos
    mencionado). Cuando se ve una secuencia de control, la función mira al
    segundo argumento o subsiguiente e imprime el valor del argumento en la
    localización en la cadena donde la secuencia de control está localizada.

    En la función interactiva @c{multiply-by-seven}, la cadena de control es
    @'{%d}, que requiere un número, y el valor devuelto evaluando @c{(* 7 5)}
    es el número 35. Por consiguiente, el número 35 es impreso en lugar de
    @'{%d} y el mensaje es @'{El resultado es 35}.

    (Nótese que cuando se llama a la función @c{multiply-by-seven}, el
    mensaje está impreso sin comillas, pero cuando se llama a @c{message}, el
    texto es impreso con dobles comillas. Esto es porque el valor devuelto
    por @c{message} aparece en el área echo cuando se evalúa una expresión
    cuyo primer elemente es @c{message}; pero cuando se embebió en una
    función, @c{message} se imprime el texto como un efecto lateral sin
    comillas.)

** Opciones diferentes para @c{interactive}

   En el ejemplo, @c{multiply-by-seven} usa @c{"p"} como el argumento a
   @c{interactive}. Este argumento cuenta a Emacs que interprete la escritura
   si @k{C-u} seguido por un número o @k{META} seguido por un número como un
   comando para pasar este número a la función como su argumento. Emacs tiene
   más de veinte caracteres predefinidos para usar con @c{interactive}. En
   casi cada caso, una de estas opciones te habilitará para pasar la
   información adecuada interactivamente a una función. (Véase Sección
   "Carácteres Código para @c{interactive}" en @e(El Manual de Referencia GNU
   Emacs Lisp)).

   Considera la función @c{zap-to-char}. Su expresión interactiva es

   @smallexample
     (interactive "p\ncZap to char: ")
   @end smallexample

   La primera parte del argumento para @c{interactive} es @'{p}, con el que
   ya se está familiarizado. Este argumento cuenta a Emacs intepretar un
   ‘prefijo’, como un número que se pase a la función. Se puede especificar
   un prefijo si escribiendo @k{C-u} seguido por un número o escribiendo
   @k{META} seguido por un número. El prefijo es el número de caracteres
   especificado. De este modo, si el prefijo es tres y el caracter específico
   es @'{x}, entonces se borrará todo el texto e incluyendo el tercer @'{x}
   siguiente. Si no se fija un prefijo, entonces borra todo el texto e
   incluye el carácter específico, pero no más.

   El @'{c} cuenta la función el nombre del carácter para que borre.

   Más formalmente, una función con dos o más argumentos puede tener
   información pasado a cada argumento añadiendo partes para la cadena que
   sigue @c{interactive}. Cuando se hace esto, la información está pasada
   para cada argumento en el mismo orden, esto está especificado en la lista
   @c{interactive}. En la cadena, cada parte está separada desde la siguiente
   parte por un @'{\n}, que es una nueva línea. Por ejemplo, tu puedes seguir
   @'{p} con un @'{\n} y un @'{cZap to char:@:}. Esto causa que Emacs pase el
   valor del argumento prefijo (si hay uno) y el carácter.

   En este caso, la definición de función mira como lo siguiente, donde
   @c{arg} y @c{char} son los símbolos para que @c{interactive} empareja el
   argumento y el caracter especificado:

   @smallexample
     (defun @var{nombre-de-funcion} (arg char)
       "@var{documentacion}…"
       (interactive "p\ncZap to char: ")
       @var{cuerpo-de-funcion}…)
   @end smallexample

   (El espacio después del punto y coma en pantalla hace que se vea
   mejor. Véase Sección @l{La Definición de @c{copy-to-buffer}}, por
   ejemplo.)

   Cuando una función no tiene argumentos, @c{interactive} no requiere
   ninguno. Tal función contiene la expresión simple @c{(interactive)}. La
   función @c{mark-whole-buffer} es como esto.

   Alternativamente, si los códigos de letras no son correctos para tu
   aplicación, se pueden pasar tus propios argumentos a @c{interactive} como
   una lista.

   Véase Sección @l{La Definición de @c{append-to-buffer}}, para un
   ejemplo. Véase Sección "Usando @c{interactive}" en @e(El Manual de GNU
   Emacs Lisp), para una explicación más completa acerca de esta técnica.

** Instalar código permanentemente

   Para instalar una definición de función, se evaluá y así estará instalada
   hasta que se salga de Emacs. La siguiente vez que se empiece una nueva
   sesión de Emacs, la función no será instalado a menos que evalúe la
   definición de nuevo.

   En algún punto, se puede querer tener código instalado automáticamente
   siempre y cuando se empiece una nueva sesión de Emacs. Hay varios caminos
   para hacer esto:

   - Si se tiene código que es solo para uno mismo, se puede poner el código
     para la definición de función en el fichero de inicialización de
     @f{.emacs}. Cuando se inicia Emacs, el fichero @f{.emacs} se evalúa
     automática y todas las definiciones de función que tenga quedan
     instaladas. Véase Sección @l{Tu Fichero @f{.emacs}}.

   - Alternativamente, se pueden poner las definiciones de función que se
     quieren instalar en uno o más ficheros y usar la función @c{load} para
     causar a Emacs evaluar y cada una de las funciones en los
     ficheros. Véase Sección @l{Cargando ficheros}.

   - Tercero, si tu tienes un código que tu sitio completo usará, es normal
     ponerlo en un fichero llamado @f{site-init.el} que es cargado cuando
     Emacs es construido. Esto hace que el código disponible a cualquiera
     quien usa tu máquina. (Mira el fichero @f{INSTALL} que es parte de la
     distribución Emacs.)


   Finalmente, si tienes código que cualquiera que use Emacs puede querer, se
   puede enviar en una red de ordenadores o enviar una copia a la Free
   Software Foundation. (Cuando se hace esto, por favor, licencia el código y
   su documentación bajo una licencia que permita a otras personas ejecutar,
   copiar, estudiar, modificar, y redistribuir el código y que te protege
   desde quien tome tu trabajo.) Si tu envias una copia de tu código a la
   Free Software Foundation y, te protege apropiadamente a tí mismo y a
   otros, eso puede ser incluido en la siguiente entrega de Emacs. Si miramos
   la historia así, es cómo Emacs ha crecido a través de los años pasados,
   por donaciones.

** @c{let}

   La expresión @c{let} es una forma especial en Lisp que se necesitará para
   usar la mayoría de las definiciones de función.

   @c{let} se usa para adjuntar o emparejar un símbolo para un valor en tal
   camino que el intérprete no confundirá la variable con otra variable del
   mismo nombre que no es parte de la función.

   Para comprender por qué la forma especial @c{let} es necesaria, considere
   la situación en el que tu propio hogar que generalmente se refiere como
   ‘la casa’, como en la frase, “La casa necesita pintura.” Si está visitando
   a un amigo y tu alojamiento se refiere a ‘la casa’, él es amistoso para
   estar refiriéndose a @e{su} casa, no la suya, que es, una casa diferente.

   Si el amigo está refiriéndose a su casa y tu piensas que él está
   refiriéndose a su casa, tu puedes estar dentro por alguna confusión. La
   misma cosa podría ocurrir en Lisp si una variable que es usada dentro de
   una función tiene el mismo que una variable que es usada dentro de otra
   función, y las dos no se pretende referirse al mismo valor. La forma
   especial @c{let} previene este tipo de confusión.

   La forma especial @c{let} evita confusiones. @c{let} crea un nombre para
   una @:{variable local} que ensombrece cualquier uso del mismo nombre fuera
   de la expresión @c{let}. Esto es como comprender que siempre y cuando tu
   host se refiera a ‘la casa’, significa su casa, no la tuya. (Símbolos
   usados en listas de argumentos trabajan en el mismo camino. Véase Sección
   @l{La Forma Especial @c{defun}}.)

   Las variable locales son creadas por una expresión @c{let} que retiene su
   valor @e{solo} con la expresión @c{let} por sí misma (y con expresiones
   llamadas con la expresión @c{let}); las variables locales no tiene efecto
   fuera de la expresión @c{let}.

   Otro camino para pensar acerca de @c{let} es que es como un @c{setq} que
   es temporal y local. Los valores asignado por @c{let} son automáticamente
   deshechos cuando el @c{let} está finalizado. La configuración solo afecta
   a expresiones que están dentro de los emparejamientos de la expresión
   @c{let}. En jerga de ciencia de computación, diríamos que “el
   emparejamiento de un símbolo es visible solo en funciones llamadas en la
   forma @c{let}; en Emacs Lisp, el alcance es dinámico, no léxico.”

   @c{let} puede crear más de una variable a la vez. También, @c{let} da cada
   variable eso crea un valor inicial, si un valor especificado por tí, o
   @c{nil}. (En la jerga, eso se llama ‘asociar la variable al valor’.)
   Después @c{let} ha creado y asociado las variables, ejecuta el código en
   el cuerpo del @c{let} y devuelve el valor de la última expresión en el
   cuerpo, como el valor de la expresión @c{let} completa. (‘Ejecuta’ es un
   término de jerga que significa evaluar una lista: viene desde el uso de la
   palabra significando ‘dar efecto práctico a’ (@e{Diccionario de Inglés de
   Oxford}). Desde que evalúas una expresión para ejecutar una acción,
   ‘ejecuta’ ha evolucionado como un sinónimo para ‘evaluar’.)

*** Las partes de una expresión @c{let}

    Una expresión @c{let} es una lista de tres partes. La primera parte es el
    símbolo @c{let}. La segunda parte es una lista, llamada una @:{varlist},
    cada elemento es un símbolo por sí mismo o una lista de dos elementos, el
    primer elemento de que es un símbolo. La tercera parte de la expresión
    @c{let} es el cuerpo del @c{let}. El cuerpo normalmente consiste de una o
    más listas.

    Una plantilla para una expresión @c{let} se parece a esto:

    @smallexample
      (let varlist body…)
    @end smallexample

    Los símbolos en la varlist son las variables que son valores iniciales
    dados por la forma especial @c{let}. Los símbolos por sí mismos son dados
    por el valor inicial de @c{nil}; y cada símbolo que es el primer elemento
    de una lista de dos elementos es emparejado al valor que el devuelto
    cuando el intérprete Lisp evalúa el segundo elemento.

    De este modo, una varlist podría verse como esto: @c{(thread (needles
    3))}. En este caso, es una expresión @c{let}, Emacs asocia el símbolo
    @c{thread} a un valor inicial de @c{nil}, y empareja el símbolo
    @c{needles} a un valor inicial de 3.

    Cuando escribes una expresión @c{let}, qué hacer es poner las expresiones
    apropiadas en las cajas de la plantilla de expresión @c{let}.

    Si la lista de variables está compuesta de listas de 2 elementos, como es
    frecuente el caso, la plantillas para la expresión @c{let} mira como
    esto:

    @smallexample
      (let ((variable valor)
            (variable valor)
            …)
        body…)
    @end smallexample

*** Expresión simple @c{let}

    La expresión siguiente crea y da valores dados iniciales para las dos
    variables @c{zebra} y @c{tiger}. El cuerpo de la expresión @c{let} es una
    lista que llama a la función @c{message}.

    @smallexample
      (let ((zebra 'rayas)
            (tiger 'fiero))
        (message "Un tipo de animal tiene %s y otro es %s."
                 zebra tiger))
    @end smallexample

    Aquí, la varlist es @c{((zebra 'rayas) (tiger 'fiero))}.

    Las dos variables son @c{cebra} y @c{tigre}. Cada variable es el primer
    elemento de una lista de dos elementos y cada valor es el segundo
    elemento de su lista de dos elementos. En la varlist, Emacs asocia la
    variable @c{cebra} al valor @c{rayas}@n{7}, y asocia la variable
    @c{tigre} al valor @c{fiero}. En este ejemplo, ambos valores son símbolos
    precedidos por una comilla. Los valores podrían ser precedidos por una
    comilla. Los valores podrían también haber sido otra lista o cadena. El
    cuerpo de @c{let} sigue después de la lista manejando las variables. En
    este ejemplo, el cuerpo es una lista que usa la función @c{message} para
    imprimir una cadena en el área echo.

    Se puede evaluar el ejemplo en el modo usual, emplazando el cursor
    después de los últimos paréntesis y escribiendo @k{C-x C-e}. Cuando se
    hace esto lo siguiente aparecerá en el área echo:

    @smallexample
      "Un tipo de animal tiene rayas y otro es fiero"
    @end smallexample

    Como se ha visto antes, la función @c{message} imprime su primer
    argumento, excepto por @'{%s}. En este ejemplo, el valor de la variable
    @c{zebra} es impreso en la posición del primer @'{%s} y el valor de la
    variable @c{tigre} es impreso en la posición del segundo @'{%s}.

*** Variables no inicializadas en un sentencia @c{let}

    Si no asocia las variables en una frase @c{let} para valores específicos
    iniciales, ellos automáticamente emparejan a un valor inicial de @c{nil},
    como en la siguiente expresión:

    @smallexample
      (let ((abedul 3)
            pino
            abeto
            (roble 'algo))
        (message
         "Aquí están %d variables con %s, %s, y el valor %s."
         abedul pino abeto roble))
    @end smallexample

    Aquí, la varlist es @c{((abeto 3) pino roble (encina 'otro))}.

    Si se evalúa esta expresión en el modo usual, aparecerá lo siguiente en
    el área echo:

    @smallexample
      "Aquí están 3 variables con nil, nil, y algún
      valor".
    @end smallexample

    En este ejemplo, Emacs empareja el símbolo @c{abedul} al número 3,
    empareja los símbolos @c{pino} y @c{abeto} a @c{nil}, y empareja el
    símbolo @c{encina} al valor @c{otro}.

    Note que en la primera parte del @c{let}, las variables @c{pine} y
    @c{fir} se aloja solo como átomos que no están rodeados por paréntesis;
    esto es porque están siendo emparejados a @c{nil}, la lista vacía. Pero
    @c{oak} es emparejado a @c{otro} y así es una parte de la lista @c{(oak
    'otro)}. De manera similar, @c{birch} se empareja al número 3 y así es
    una lista con este número. (Desde que un número se evalúa por sí mismo,
    el número no necesita ser citado. También, el número es impreso en el
    mensaje usando @'{%d} en vez de un @'{%s}.) Las cuatro variables como un
    grupo son puestas dentro de una lista para delimitarlos desde el cuerpo
    del @c{let}.

** La forma especial @c{if}

   Una tercera forma especial, además de @c{defun} y @c{let}, es el
   condicional @c{if}. Esta forma es usada para instruir el ordenador para
   crear decisiones. Se puede escribir definiciones de función usando @c{if},
   pero eso es usado con suficiente frecuencia, y es suficientemente
   importante para ser incluido aquí. Eso es usado, por ejemplo, en el código
   para la función @c{beginning-of-buffer}.

   La idea básica de un @c{if}, es que “@e{if} un test es verdad @e{then} una
   expresión es evaluado.” Si el test no es verdad, la expresión no está
   evaluada. Por ejemplo, podría crear una decisión tal y como, “¿si es
   cálido y soleado, entonces a la playa!”

   Una expresión @c{if} expresión escrita en Lisp no usa la palabra ‘then’;
   el test y la acción son el segundo y tercer elementos de la lista cuyo
   primer elemento es @c{if} (@e{si}). Ninguno menos, la parte de test de una
   expresión @c{if} (@e{si}) es con frecuencia llamada la @:{if-part}
   (@e{parte-si}) y el segundo argumento es con frecuencia llamada la
   @:{then-part} (@e{parte-entonces}).

   También, cuando una expresión @c{if} es escrita, el test-verdadero-o-falso
   es normalmente escrito en la misma línea como el símbolo @c{if}, pero la
   acción para traer si el test es verdadero, el “then-part”
   @e{parte-entonces}, es escrita en la segunda y subsiguientes líneas. Esto
   hace que la expresión @c{if} @e{si} sea fácil de leer.

   @smallexample
     (if @var{test-verdadero-o-falso}
         @var{accion-a-realizar-si-el-test-es-cierto})
   @end smallexample

   El test-verdadero-o-falso será una expresión que es evaluado por el
   intérprete Lisp.

   Aquí hay un ejemplo que se puede evaluar en la manera normal. El test es
   si el número 5 es mayor que el número 4. Desde eso, el mensaje @'{¿5 es
   más grande que 4!} será impreso.

   @smallexample
     (if (> 5 4)                             ; @r{parte-si}
         (message "¿5 es mayor que 4!"))   ; @r{parte-entonces}
   @end smallexample

   (La función @c{>} chequea si su primer argumento es mayor que su segundo
   argumento y devuelve cierto si lo es.)  @findex > (mayor que)

   De acuerdo, al uso actual, el test en una expresión @c{if} no será
   corregido todo el tiempo, ya que eso es por la expresión @c{(> 5 4)}. En
   vez, al menos una de las variables usadas en el test será asociada a un
   valor que no es conocido en frente del tiempo. (Si el valor fuera conocido
   en el tiempo, ¿no necesitaríamos ejecutar el test!)

   Por ejemplo, el valor puede ser asociado a un argumento de una definición
   de función. En la siguiente definición de función, el carácter del animal
   es un valor que es pasado a la función. Si el valor asociado a
   @c{característico} es @c{fiero}, entonces el mensaje, @'{¿Es un tigre!}
   será impreso; de otro modo, @c{nil} será devuelto.

   @smallexample
     (defun tipo-de-animal (caracteristica)
       "Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.
     Si la CARACTERISTICA es el símbolo `fiera',
     entonces avisa de un tigre."
       (if (equal caracteristica 'fiera)
           (message "¿Es un tigre!")))
   @end smallexample

   Si está leyendo esto dentro de GNU Emacs, se puede evaluar la definición
   función en el modo usual para instalarlo en Emacs, y entonces se puede
   evaluar las siguientes dos expresiones para ver los resultados:

   @smallexample
     (tipo-de-animal 'fiera)
     (tipo-de-animal 'cebra)
   @end smallexample

   Cuando se evalúa @c{(tipo-de-animal 'fiero)}, se verá el siguiente mensaje
   impreso en el área echo: @c{"¿Es un tigre!"}; y cuando se evalúa
   @c{(tipo-de-animal 'cebra)} verás @c{nil} impreso en el área echo.

*** La función @c{tipo-de-animal} en detalle

    Mira la función @c{tipo-de-animal} en detalle.

    La definición de función para @c{tipo-de-animal} fué escrito para
    rellenar los slots de dos plantillas, uno para una definición de función
    como un todo, y un segundo para una expresión @c{if} (@e{si}).

    La plantilla para cada función que no es interactiva es:

    @smallexample
      (defun @var{nombre-de-funcion} (@var{lista-de-argumentos})
        "@var{documentacion}…"
        @var{cuerpo}…)
    @end smallexample

    Las partes de la función asociada a esta plantilla es:

    @smallexample
      (defun tipo-de-animal (caracteristica)
        "Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.
      Si la CARACTERISTICA es el símbolo `fiera',
      entonces avisa de que es un tigre."
        @var{body: the} @c{if} @var{expression})
    @end smallexample

    El nombre de función es @c{tipo-de-animal}; se pasa al valor de un
    argumento. La lista de argumentos es seguida por una cadena de
    documentación multi-línea. La cadena de documentación es incluida en el
    ejemplo porque es un buen hábito para escribir documentación para cada
    definición de función. El cuerpo de la definición de función consiste de
    la expresión @c{if}.

    La plantilla para una expresión @c{if} se ve así:

    @smallexample
      (if @var{test-verdadero-o-falso}
          @var{accion-a-realizar-si-el-test-es-cierto})
    @end smallexample

    En la función @c{tipo-de-animal}, el código para el @c{if} (@e{si}) se ve
    así:

    @smallexample
      (if (equal caracteristica 'fiero)
          (message "¿Es un tigre!")))
    @end smallexample

    Aquí, está la expresión test-verdadero-o-falso

    @smallexample
      (equal caracteristica 'fiero)
    @end smallexample

    En Lisp, @c{equal} es una función que determina si su primer argumento es
    igual para su segundo argumento. El segundo argumento es el símbolo
    citado @c{'fiero} y el primer argumento es el valor del símbolo
    @c{característico}––en otras palabras, el argumento pasado a esta
    función.

    En el primer ejercicio de @c{tipo-de-animal}, el argumento @c{fiera} es
    pasado a @c{tipo-de-animal}. Desde que @c{fiera} es igual a @c{fiera}, la
    expresión, @c{(equal caracteristica 'fiera)}, devuelve un valor de
    verdad. Cuando esto ocurre, el @c{if} (@e{si}) evalúa el segundo
    argumento o parte-entonces del @c{if} (@e{si}): @c{(message "¿Es un
    tigre!")}.

    Por otro lado, en el segundo ejercicio de @c{tipo-de-animal}, el
    argumento @c{cebra} es pasado a @c{tipo-de-animal}. @c{cebra} no es igual
    a @c{fiera}, así la parte-entonces no está evaluada y se devuelve @c{nil}
    por la expresión @c{if} (@e{si}).

** Expresiones Si–entonces–resto

   Una expresión @c{if} @e{si} puede tener un tercer argumento opcional,
   llamado la @:{parte-resto}, para el caso en el que test-verdadero-o-falso
   devuelve falso. Cuando esto ocurre, el segundo argumento o la
   parte-entonces sobre todo la expresión @c{if} (@e{si}), @e{no} se evalúa,
   pero el tercero o la parte-resto @e{se} evalúa. Se podría pensar en esto
   como la alternativa del día nublado para la decisión “si eso es cálido y
   soleado, ve a la playa, sino ¿lee un libro!”

   La palabra “else” @e{resto} no está escrita en el código Lisp; la parte
   else @e{resto} de una expresión @c{if} @e{si} viene después de la parte
   then @e{entonces}. En el Lisp escrito, la parte else @e{resto} normalmente
   se escribe para empezar en la línea siguiente y está menos indentada que
   la parte then @e{entonces}:

   @smallexample
     (if @var{test-verdadero-o-falso}
         @var{accion-a-realizar-si-el-test-es-cierto}
       @var{accion-a-realizar-si-el-test-es-falso})
   @end smallexample

   Por ejemplo, la siguiente expresión @c{if} imprime el mensaje @'{¿4 no es
   mayor que 5!} cuando se evalúa eso en el camino usual:

   @smallexample
     (if (> 4 5)                               ; @r{parte-si}
         (message "¿4 no es más grande que 5!") ; @r{parte-entonces}
       (message "¿4 no es más grande que 5!"))   ; @r{parte-resto}
   @end smallexample

   Nótese que los diferentes niveles de indentación hacen fácil distinguir la
   parte then desde la parte resto. (GNU Emacs tiene varios comandos que
   automáticamente indenta expresiones correctamente @c{if} @e{si}. Véase
   Sección @l{GNU Emacs te ayuda a escribir listas}.)

   Podemos extender la función @c{tipo-de-animal} para incluir una parte else
   para simplemente incorporar una parte adicional para la expresión @c{if}
   @e{si}.

   Se puede ver las consecuencias de hacer esto si se evalúa la siguiente
   versión de la definición de función @c{type-of-animal}
   (@e{tipo-de-animal}) para instalarlo y entonces evaluar las dos
   expresiones subsiguientes para pasar diferentes argumentos para la
   función.

   @smallexample
     (defun tipo-de-animal (caracteristica)  ; @r{Segunda versión.}
       "Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.
     Si la CARACTERISTICA es el símbolo `fiera',
     entonces avisa de un tigre; sino di que no es una fiera."
       (if (equal caracteristica 'fiera)
           (message "¿Es un tigre!")
         (message "¿No es una fiera!")))

     (tipo-de-animal 'fiera)
     (tipo-de-animal 'cebra)
   @end smallexample

   Cuando se evalúa @c{(tipo-de-animal 'fiera)}, se verá el siguiente mensaje
   impreso en el área echo: @c{"¿Eso es un tigre!"}; pero cuando se evalúa
   @c{(tipo-de-animal 'cebra)}, se verá @c{"¿No es una fiera!"}.

   (De acuerdo, si la @var{característica} fuera @c{feroz}, el mensaje
   @c{"¿No es una fiera!"}  sería impreso; ¿y sería erróneo!  Cuando se
   escribe código, se necesita tener en cuenta la posibilidad que algunos
   argumentos será probado por @c{if} @e{si} y escribir tu programa de
   acuerdo.

** Verdad y falsedad en Emacs Lisp

   Hay un aspecto importante para el test de verdad en una expresión @c{if}
   (@e{si}). Así, hemos hablado de ‘verdad’ y ‘mentira’ como valores de
   predicados como si fueran nuevos tipos de objetos Emacs Lisp. En efecto,
   ‘falso’ es solo nuestro viejo amigo @c{nil}. Cualquier otra es
   ‘verdadero’.

   La expresión chequea si verdad se interpreta como (@:{true}) @e{verdadero}
   si el resultado de evaluarlo es un valor que no es @c{nil}. En otras
   palabras, el resultado del test se considera cierto si el valor devuelto
   es un número como 47, una cadena tal como @c{"hola"}, o un símbolo (otro
   como @c{nil}) tal como @c{flores}, o una lista (tan larga como eso no está
   vacía) ¿o incluso un búffer!

   Antes de ilustrar un test para verdad, se necesita una explicación de
   @c{nil}.

   En Emacs Lisp, el símbolo @c{nil} tiene dos significados. Primero, está el
   significado de la lista vacía. Segundo, está el valor de falso y es el
   valor devuelto cuando el test test-verdadero-o-falso salga
   falso. @c{nil}. Tan lejos como el intérprete Lisp es concebido, @c{()} y
   @c{nil} son el mismo. Los humanos, sin embargo, tienden a usar @c{nil}
   para falso y @c{()} para la lista vacía.

   En Emacs Lisp, cualquier valor que no es @c{nil} --- no es una lista
   vacía––es considerado verdad. Esto significa que si una evaluación
   devuelve alguna cosa que no es una lista vacía, una expresión @c{if}
   devuelve verdad. Por ejemplo, si un número es puesto en el slot para el
   test, será evaluado y devolverá por sí mismo, desde lo que hacen los
   números cuando se evalúan. En este condicional, la expresión @c{if}
   devuelve verdad. La expresión se chequea como falso solo cuando @c{nil},
   una lista vacía, es devuelta evaluando la expresión.

   Se puede ver esto evaluando las dos expresiones en los siguientes
   ejemplos.

   En el primer ejemplo, número 4 es evaluado como el test en la expresión
   @c{if} y se devuelve por sí mismo; por consiguiente, la then-part de la
   expresión es evaluada y devuelta: @'{true} aparece en el área echo. En el
   segundo ejemplo, @c{nil} indica falso; por consiguiente, el else-part de
   la expresión es evaluada y devuelta: @'{false} aparece en el área echo.

   @smallexample
     (if 4
         'true
       'false)

     (if nil
         'true
       'false)
   @end smallexample

   Incidentalmente, si algún otro valor útil no está disponible para un test
   que devuelve cierto, entonces el intérprete Lisp retornará el símbolo
   @c{t} para cierto. Por ejemplo, la expresión @c{(> 5 4)} devuelve @c{t}
   cuando se evalúa, como puedes ver evaluándolo en el camino usual:

   @smallexample
     (> 5 4)
   @end smallexample

   Por otro lado, esta función devuelve @c{nil} si el test es falso.

   @smallexample
     (> 4 5)
   @end smallexample

** @c{save-excursion}

   La función @c{save-excursion} es la cuarta y última forma especial que se
   discutirá en este capítulo.

   En Emacs Lisp hay programas usados para edición, la función
   @c{save-excursion} es muy común. Eso guarda la posición de punto y marca,
   ejecuta el cuerpo de la función, y entonces restaura el punto y marca a
   sus posiciones previas si sus posiciones fueran cambiadas. Su propósito
   primario es guardar que el usuario sea sorprendido y molesto por
   movimientos inesperados de punto y marca.

   Antes de discutir @c{save-excursion}, sin embargo, puede ser útil primero
   revisar que punto y marca están en GNU Emacs. @:{Punto} es la posición
   actual del cursor. En cualquier lugar que el cursor se posicione hay un
   punto. De manera más precisa, en terminales donde el cursor parece estar
   en lo alto de un carácter, el punto está inmediatamente antes del
   carácter. En Emacs Lisp, punto es un entero. El primer carácter en un
   búffer es el número uno, el segundo es el número dos, y así. La función
   @c{punto} devuelve la posición actual del cursor como un número. Cada
   búffer tiene su propio valor para el punto.

   La @:{marca} es otra posición en el búffer; su valor puede ser asignado
   con un comando tal como @k{C-@k{SPC}} (@c{set-mark-command}). Si una marca
   ha sido asignada, se puede usar el comando @k{C-x C-x}
   (@c{exchange-point-and-mark}) para hacer que el cursor salte a la marca y
   asignar la marca para la posición previa del punto. Además, si tu asignas
   otra marca, la posición puede ser guardada por este camino. Se puede
   saltar al cursor para una marca guardada escribiendo @k{C-u C-@k{SPC}} una
   o más veces.

   La parte del búffer entre el punto y la marca es llamada @:{la
   región}. Numerosos comandos trabajan en la región, incluyendo
   @c{center-region}, @c{count-lines-region}, @c{kill-region} y
   @c{print-region}.

   La forma especial @c{save-excursion} salva las posiciones del punto y la
   marca y restaura estas posiciones después del código con el cuerpo de la
   forma especial es evaluada por el intérprete Lisp. De este modo, si el
   punto fuera en el principio de una pieza de texto y algún código movido
   apunta al fin del búffer, el @c{save-excursion} no apuntaría a donde fué
   antes, después las expresiones en el cuerpo de las que fueron evaluadas.

   En Emacs, una función frecuentemente mueve el punto como parte de sus
   trabajos internos incluso aunque un usuario no espere esto. Por ejemplo,
   @c{count-lines-region} se mueve al punto. Para prevenir al usuario que se
   preocupe por el salto que es inesperado y (desde el punto de vista del
   usuario) innecesario, @c{save-excursion} es con frecuencia usado para
   punto y marca en la posición esperada por el usuario. El uso de
   @c{save-excursion} es un buen guarda casas.

   Para estar seguro que la casa está limpia, @c{save-excursion} restaura los
   valores de punto y marca incluso si alguna cosa va mal en el código dentro
   de eso (o, para ser más preciso y usar la jerga apropiada, “en caso de
   salida anormal”). Esta funcionalidad es muy útil.

   Además grabando los valores de punto y marca, @c{save-excursion} guarda la
   traza del actual buffer, y lo restaura, también. Esto significa que puedes
   escribir código que cambiará el buffer y tener que @c{save-excursion}
   vuelva al buffer original. Esto es como @c{save-excursion} es usado en
   @c{append-to-buffer}. (Véase Sección @l{La Definición de @c{append-to-buffer}}.)

*** Plantilla para una expresión @c{save-excursion}

    La plantilla para código usando @c{save-excursion} es simple:

    @smallexample
      (save-excursion
        @var{body}…)
    @end smallexample

    El cuerpo de la función es una o más expresiones que serán evaluadas en
    secuencia por el intérprete Lisp. Si hay más de una expresión en el
    cuerpo, el valor de la última será devuelto como el valor de la función
    @c{save-excursion}. Las otras expresiones en el cuerpo son evaluadas solo
    por sus efectos laterales; y @c{save-excursion} en sí es usado solo por
    su efecto lateral (que está restaurando las posiciones de punto y marca).

    Para más detalles, la siguiente plantilla explica @c{save-excursion}

    @smallexample
      (save-excursion
        @var{primera-expresion-en-el-cuerpo}
        @var{segunda-expresion-en-el-cuerpo}
        @var{tercera-expresion-en-el-cuerpo}
         …
        @var{ultima-expresion-en-el-cuerpo})
    @end smallexample

    Una expresión, de acuerdo, puede ser un símbolo por sí mismo o una lista.

    En código Emacs Lisp, una expresión @c{save-excursion} con frecuencia
    ocurre el cuerpo de una expresión @c{let}. Eso se ve como esto:

    @smallexample
      (let @var{varlist}
        (save-excursion
          @var{body}…))
    @end smallexample

** Revisar

   En los últimos pocos capítulos se han introducido un número limpio de
   funciones y formas especiales. Aquí se han descrito brevemente, con unas
   pocas funciones similares que no han sido mencionadas todavía.

   - eval-last-sexp -:

     Evalúa la última expresión simbólica antes de la posición actual del
     punto. El valor es impreso en el área echo a menos que la función sea
     invocada con un argumento; en este caso, la salida es impresa en el
     actual búffer. Este comando está normalmente asociado a @k{C-x C-e}.

   - defun -:

     Definir función. Esta forma especial ha subido a cinco partes: el nombre
     una plantilla para los argumentos que serán pasados a la documentación
     de la función, una declaración interactiva opcional, y el cuerpo de la
     definición.

     Por ejemplo, en las primeras versiones de Emacs, la definición de
     función era como sigue. (Eso es ligeramente más complejo ahora que si
     busca el primer caracter de espacio no en blanco en vez del primer
     caracter visible.)

     @smallexample
       (defun volver-a-indentacion ()
         "Mover el punto al primer caracter visible en linea."
         (interactive)
         (beginning-of-line 1)
         (skip-chars-forward " \t"))
     @end smallexample

     @ignore
       In GNU Emacs 22,

       (defun backward-to-indentation (&optional arg)
         "Move backward ARG lines and position at first nonblank character."
         (interactive "p")
         (forward-line (- (or arg 1)))
         (skip-chars-forward " \t"))

       (defun back-to-indentation ()
         "Move point to the first non-whitespace character on this line."
         (interactive)
         (beginning-of-line 1)
         (skip-syntax-forward " " (line-end-position))
         ;; Move back over chars that have whitespace syntax but have the p flag.
         (backward-prefix-chars))
     @end ignore

   - interactive -:

     Declara al intérprete que la función puede ser usada
     interactivamente. Esta forma especial puede ser seguida por una cadena
     con una o más partes que pasan la información a los argumentos de la
     función, en secuencia. Estas partes pueden también contar al intérprete
     para mostrar la información. Parte de las cadenas son separadas por
     nuevas líneas, @'{\n}.

     Caracteres de código común son:

     - b -: El nombre de un búffer existente.

     - f -: El nombre de un fichero existente

     - p -: El argumento prefijo numérico. (Nótese que esta ‘p’ es
       minúscula.)

     - r -: El Punto y la marca, como dos argumentos numéricos, el más
       pequeño primero. Esta es la única letra que especifica dos argumentos
       sucesivos en vez de uno.


     Véase Sección "Caracteres de Código para @'{interactive}" en @e(El
     Manual de Referencia de GNU Emacs Lisp), para una lista de caracteres de
     código.

   - let -:

     Declara que una lista de variables es para usarla con el cuerpo del
     @c{let} y darles un valor inicial, bien @c{nil} o un valor específico;
     entonces se evaluarán el resto de las expresiones en el cuerpo del
     @c{let} y devolver el valor de la última. Dentro del cuerpo del @c{let},
     el intérprete Lisp no ve los valores de las variables de los mismos
     nombres que son asociados fuera del @c{let}.

     Por ejemplo,

     @smallexample
       (let ((foo (nombre-de-buffer))
             (bar (tamagno-de-buffer)))
         (message
          "Este buffer es %s y tiene %d caracteres."
          foo bar))
     @end smallexample

   - save-excursion -:

     Graba los valores de punto y marca y el actual búffer antes de evaluar
     el cuerpo de esta forma especial. Restaura los valores de punto y marca
     y el búffer después de esto.

     Por ejemplo,

     @smallexample
       (message "Hay %d caracteres dentro de este buffer."
                (- (point)
                   (save-excursion
                     (goto-char (point-min)) (point))))
     @end smallexample

   - if -:

     Evalúa el primer argumento a la función; si es verdad, evalúa el segundo
     argumento; lo demás evalúa el tercer argumento, si hay uno.

     La forma especial @c{if} es llamada @:{condicional}. Hay otros
     condicionales en Emacs Lisp, pero @c{if} es quizás lo más comúnmente
     usado.

     Por ejemplo,

     @smallexample
       (if (= 22 version-de-emacs-mayor)
           (message "Esta es la versión 22 de Emacs")
         (message "Esta no es la versión 22 Emacs"))
     @end smallexample

   - <  -:
     >  -:
     <= -:
     >= -:

     La función @c{<} chequea si su primer argumento es más pequeño que su
     segundo argumento. Una función correspondiente, @c{>}, chequea si el
     primer argumento es mayor que el segundo. De otro modo, @c{<=} chequea
     si el primer argumento es menor o igual al segundo y @c{>=} chequea si
     el primer argumento es mayor o igual al segundo. En todos los casos,
     ambos argumentos deben ser números o marcas (las marcas indican
     posiciones en búffers).

   - = -:

     La función @c{=} chequea si dos argumentos, ambos números o marcadores,
     son iguales.

   - equal -:
     eq    -:

     Chequea si dos objetos son el mismo. @c{equal} usa un signicado de la
     palabra ‘mismo’ y @c{eq} usa otro: @c{equal} devuelve cierto si los dos
     objetos tienen una estructura y contenidos similares, tal como dos
     copias del mismo libro. En una mano, @c{eq}, devuelve cierto si ambos
     argumentos son actualmente el mismo objeto.  @findex equal @findex eq

   - string<      -:
     string-lessp -:
     string=      -:
     string-equal -:

     La función @c{string-lessp} chequea si su primer argumento es más
     pequeño que el segundo. En resumen, el nombre alternativo para la misma
     función (un @c{defalias}) es @c{string}.

     Los argumentos para @c{string-lessp} deben ser cadenas o símbolos; la
     ordenación es lexicográfica, así el caso es significativo. Los nombres
     impresos de símbolos son usado en vez de símbolos por sí mismos.

     Una cadena vacía, @'{"\"}, es una cadena sin caracteres dentro, es más
     pequeña que cualquier cadena de caracteres.

     @c{string-equal} provee el test correpondiente para igualdad. Su corto
     nombre alternativo es @c{string=}. No hay funciones test que correponden
     a @var{>}, @c{>=}.

   - message -:

     Imprime un mensaje en el área echo. El primer argumento es una cadena
     que puede contener, @'{%s}, @'{%d}, o @'{%c} para imprimir el valor de
     argumentos que siguen la cadena. El argumento usado por @'{%d} debe ser
     un número. El argumento usado por @'{%c} debe ser un número de código
     @Cc{ascii}; eso será impreso como el caracter con este código
     @Cc{ascii}. (Otras varias %-secuencias no han sido mencionadas.)

   - setq -:
     set  -:

     La función @c{setq} asigna el valor de su primer argumento al valor del
     segundo argumento. El primer argumento está automáticamente citado por
     @c{setq}. Eso hace lo mismo para los pares de argumentos. Otra función,
     @c{set}, toma solo dos argumentos y evalúa ambos de ellos antes de
     configurar el valor devuelto por su primer argumento al valor devuelto
     por su segundo argumento.

   - buffer-name -:

     Sin un argumento, devuelve el nombre del búffer, como una cadena.

   - buffer-file-name -:

     Sin un argumento, devuelve el nombre del fichero si el búffer lo está
     visitando.

   - current-buffer -:

     Devuelve el búffer en el que Emacs es activo; eso puede no ser el búffer
     que es visible en la pantalla.

   - other-buffer -:

     Devuelve el búffer seleccionado más recientemente (otro que el búffer
     pasado a @c{other-buffer} como un argumento y otro en vez de el búffer
     actual).

   - switch-to-buffer -:

     Selecciona un búffer para que Emacs esté activo y lo muestre en la
     ventana actual y así los usuarios puedan mirarlo. Normalmente se
     empareja a @k{C-x b}.

   - set-buffer -:

     Cambia la atención de Emacs a un búffer en el que los programas se
     ejecutarán. No altera lo que la ventana está mostrando.

   - buffer-size -:

     Devuelve el número de caracteres en el búffer actual.

   - punto -:

     Devuelve el valor de la actual posición del cursor, como un entero
     contando el número de caracteres desde el principio del búffer.

   - point-min -:

     Devuelve el valor mínimo permisible del punto en el búffer actual. Esto
     es 1, a menos que la contracción esté en efecto

   - point-max -:

     Devuelve el valor del máximo valor permisible del punto en el
     búffer actual. Esto es el fin del búffer, a menos que la
     contracción esté en efecto

** Ejercicios

   - Escribe una función no interactiva que doble el valor de su argumento,
     un número. Luego haz la función interactiva.

   - Escribe una función que chequee si el valor actual de @c{fill-column} es
     más grande que el argumento pasado a la función, y si es así, imprime un
     mensaje apropiado.

* Unas pocas funciones de buffer relacionadas

  En este capítulo estudiamos en detalle varias de las funciones usadas en
  GNU Emacs. Esto se llama un “paseo a través”. Estas funciones son usadas
  como ejemplos de código Lisp, pero no son ejemplos imaginarios; con la
  excepción del primero, la definición de función simplificada, esta
  funciones muestran el actual código usado en GNU Emacs. Se puede aprender
  mucho desde estas definiciones. Las funciones descritas aquí están todas
  relacionadas a búffers. Después, estudiaremos otras funciones.

** Encontrando más información

   En este paseo, se describe cada nueva función como viene, algunas veces en
   detalle y algunas veces brevemente. Si está interesado, se puede obtener
   la documentación completa de cualquier función Emacs Lisp en cualquier
   momento escribiendo @k{C-h f} y entonces el nombre de la función (y
   entonces @k{RET}. De manera similar, se puede obtener la documentación
   completa para una variable escribiendo @k{C-h v}, después el nombre de la
   variable (y entonces @k{RET}).

   También, en @c{describe-function}, se encontrará la localización de la
   definición de la función.

   Poner el punto dentro del nombre del fichero que contiene la función y
   presiona la tecla @k{RET}. En este caso, @k{RET} significa @c{push-button}
   en vez de ‘return’ o ‘enter’. Emacs tomará directamente a la definición de
   la función.

   @ignore
     Not In version 22

     If you move point over the file name and press
     the @k{RET} key, which in this case means @c{help-follow} rather
     than ‘return’ or ‘enter’, Emacs will take you directly to the function
     definition.
   @end ignore

   De manera más general, si quieres ver una función en su fichero fuente
   original, se puede usar la función @c{find-tag} para saltar dentro.
   @c{find-tag} funciona con una amplia variedad de lenguajes, no solo Lisp,
   y C, y funciona con texto de no programación también. Por ejemplo,
   @c{find-tag} saltará a los varios nodos en el fichero fuente Texinfo de
   este documento. La función @c{find-tag} depende de ‘tablas de etiquetas’
   que graba las localizaciones de las funciones, variables, y otros ítems
   para los que @c{find-tag} salta.

   Para usar el comando @c{find-tag}, escribe @k{M-.} (por ej., presionando
   la tecla @k{META}, o al menos escribe la tecla @k{ESC} y entonces escribe
   la tecla punto), entonces, en la pantalla, se escribe el nombre de la
   función cuyo código fuente se quiere ver, tal como @c{mark-whole-buffer},
   y luego escribe @k{RET}. Emacs cambiará el búffer y mostrará el código
   fuente para la función en la pantalla. Para volver al búffer actual,
   escribe @k{C-x b @k{RET}}. (En algunos teclados, la tecla @k{META} es
   etiquetada con @k{ALT}.)

   Dependiendo de cómo los valores iniciales por defecto de tu copia de Emacs
   son asignados se puede también necesitar especificar la posición de tu
   ‘tabla de tags’, que es un fichero llamado @f{TAGS}. Por ejemplo, si se
   está interesado en fuentes de Emacs, la tabla de tags que se desea, si ya
   ha sido creada para tí, estará en un subdirectorio del directorio
   @f{/usr/local/share/emacs}; de este modo se usaría el comando @c{M-x
   visit-tags-table} y especifica una ruta tal como
   @f{/usr/local/share/emacs/22.1.1/lisp/TAGS}. Si la tabla tags no ha sido
   creada, tendrás que crearla por tí mismo. Será un fichero tal como
   @f{/usr/local/src/emacs/src/TAGS}.

   Para crear un fichero @f{TAGS} en un directorio específico, cambia a este
   directorio en Emacs usando un comando @k{M-x cd}, o lista el directorio
   como @c{etags *.el} como el comando para ejecutar:

   @smallexample
     M-x compile RET etags *.el RET
   @end smallexample

   Para más información, ver @l{etags, , Crea tu propio fichero @f{TAGS}}.

   Después de llegar a estar más familiarizado con Emacs Lisp, se encontrará
   frecuentemente usar @c{find-tag} para navegar tu camino alrededor del
   código fuente; y se crearán tus propias tablas @f{TAGS}.

   Incidentalmente, los ficheros que contienen código Lisp son
   convencionalmente llamadas @:{librerías}. La metáfora se deriva que una
   librería, tal como la librería de leyes o una librería de ingeniería, en
   vez de una librería general. Cada librería, o fichero, contiene funciones
   que se relacionan a un asunto particular o actividad, tal como
   @f{abbrev.el} para manejar abreviaciones y otros atajos, y @f{help.el}
   para la ayuda on-line. (Algunas veces varias librerías proporcionan código
   para una actividad simple, como varios @f{rmail…} ficheros proveen código
   para leer correos electrónicos.) En @e{El Manual de GNU Emacs}, tu verás
   varias frases tales como “El comando @k{C-h p} te permite buscar el
   estándar de las librerías Emacs Lisp por las palabras claves.

** Una definición simplificada de @c{beginning-of-buffer}

   El comando @c{beginning-of-buffer} es una buena función para empezar ya
   puedes tener cierta familiaridad con eso y es fácil de comprender. Usado
   como un comando interactivo, @c{beginning-of-buffer} mueve el cursor al
   principio del búffer, dejando la marca en la posición previa. Eso es
   generalmente asignados a @k{M-<}.

   En esta sección, se discutirá una versión ordenada de la función que
   muestra como eso es lo usado más frecuentemente. Esta función ordenada
   trabaja como se escribe, pero no contiene el código para una función
   compleja. En otra sección, describiremos la función entera. (Véase Sección
   @l{beginning-of-buffer, Definición Completa de @c{beginnning-of-buffer}}.)

   Antes de mirar en el código, permítenos considerar que la definición de
   función tiene que contener: eso debe incluir una expresión que crea la
   función interactiva así puede ser llamado escribiendo @k{M-x
   beginning-of-buffer} o escribiendo unos atajos tales como @k{M-<}; debe
   incluir código para dejar una marca en la posición original en el búffer;
   y debe incluir código el cursor al principio del búffer.

   Aquí está el texto completo la versión ordenada de la función:

   @smallexample
     (defun simplified-beginning-of-buffer ()
       "Mover punto al principio del bufer; dejar marca en la posición previa."
       (interactive)
       (push-mark)
       (goto-char (point-min)))
   @end smallexample

   Como todas las definiciones de función, esta definición tiene cinco partes
   siguiendo la forma especial @c{defun}:

   1. El nombre: en este ejemplo, @c{simplified-beginning-of-buffer}.

   2. Una lista de los argumentos: en este ejemplo, una lista vacía, @c{()},

   3. La cadena de documentación.

   4. La expresión interactive.

   5. El cuerpo.


   En esta definición de función, la lista de argumentos está vacía; esto
   significa que esta función no requiere argumentos. (Cuando se busca la
   definición para la función completa, se verá que puede pasarse un
   argumento opcional.)

   La expresión interactiva cuenta a Emacs que la función se pretende ser
   usada interactivamente. En este ejemplo, @c{interactive} no tiene un
   argumento porque @c{simplified-beginning-of-buffer} no se requiere.

   El cuerpo de la función consiste de dos líneas:

   @smallexample
     (push-mark)
     (goto-char (point-min))
   @end smallexample

   La primera de estas líneas es la expresión, @c{(push-mark)}. Cuando esta
   expresión es evaluado por el intérprete Lisp, eso asigna una marca en la
   posición actual del cursor, siempre y cuando esto pueda ser. La posición
   de esta marca está guardada en el anillo de marcas.

   La siguiente línea es @c{(goto-char (point-min))}. Esta expresión salta el
   cursor al punto mínimo en el búffer, esto es, para el comienzo del búffer
   (o al principio de la porción accesible del búffer si eso está
   encogido. Véase Sección @l{Encogiendo y extendiendo}.)

   El comando @c{push-mark} estable una marca en el lugar donde el cursor fué
   localizado antes que fuera movido al principio del búffer por la expresión
   @c{(goto-char (point-min))}. Consiguientemente, puedes, si lo deseas,
   volver donde estabas originalmente escribiendo @k{C-x C-x}.

   ¿Esto es todo lo que hay para la definición de función!

   Cuando se lee código como este y vuelve a una función no familiar, tal
   como @c{goto-char}, se puede encontrar que se hace usando el comando
   @c{describe-function}. Para usar este comando, escribe @k{C-h f} y
   entonces escribe en el nombre de la función y presiona @k{RET}. El comando
   @c{describe-function} imprimirá la documentaci@'n de la cadena de la
   función en una ventana @f{*Help*}. Por ejemplo, la documentación para
   @c{goto-char} es:

   @smallexample
     Asignar punto a POSITION, un número o marca
     Empezando el buffer es la posición (point-min), y el final es
     (point-max).
   @end smallexample

   La función es un argumento es la posición deseada.

   (La consola para @c{describe-function} te ofrecerá el símbolo abajo o
   precediendo al cursor, así se puede guardar escribiendo al posicionar el
   cursor a la derecha o después de la función y entonces escribir @k{C-h f
   @k{RET}}.)

   La definición de función @c{end-of-buffer} está escrito en el mismo modo
   que la definición @c{beginnig-of-buffer} excepto que el cuerpo de la
   función contenga la expresión @c{(goto-char (point-max))} en lugar de
   @c{(goto-char (point-min))}

** La definición de @c{mark-whole-buffer}

   La función @c{mark-whole-buffer} no es tan difícil de comprender que la
   función @c{simplified-beginning-of-buffer}. En este caso, sin embargo, se
   verá la función completa, no una versión ordenada.

   La función @c{mark-whole-buffer} no está comúnmente usada como la función
   @c{beginning-of-buffer}, pero eso no es útil: eso marca un búffer completo
   como una región poniendo el punto al principio y una marca al fin del
   búffer. Eso está generalmente asociado a @k{C-x h}.

   En GNU Emacs 22, el código para la función completa se parece a:

   @smallexample
     (defun mark-whole-buffer ()
       "Pon el punto al principio y marca el fin del búffer.
     Probablemante no deberías usar esta función en
       programas Lisp; normalmente un error para una función Lisp usa
       cualquier subrrutina que usa o asigna la marca."
       (interactive)
       (push-mark (point))
       (push-mark (point-max) nil t)
       (goto-char (point-min)))
   @end smallexample

   Como todas las otras funciones, la función @c{mark-whole-buffer} se ajusta
   dentro de la plantilla para una definición. La plantilla se parece a esta:

   @smallexample
     (defun @var{name-of-function} (@var{argument-list})
       "@var{documentation}…"
       (@var{interactive-expression}…)
       @var{body}…)
   @end smallexample

   Aquí está cómo la función trabaja: el nombre de la función es
   @c{mark-whole-buffer}; eso es seguida por un argumento de lista vacía,
   @'{()}, que significa que la función no requiere argumentos. La
   documentación viene la siguiente.

   La siguiente línea es una expresión @c{(interactive)} que cuenta a Emacs
   que la función será usada interactivamente. Estos detalles son similares a
   la función @c{simplified-beginning-of-buffer} descrita en la sección
   previa

*** Cuerpo de @c{mark-whole-buffer}

    El cuerpo de la función @c{mark-whole-buffer} consiste en tres líneas de
    código:

    @smallexample
      (push-mark (point))
      (push-mark (point-max) nil t)
      (goto-char (point-min))
    @end smallexample

    El primero de estas líneas es la expresión, @c{(push-mark (point))}.

    Esta línea hace exactamente el mismo trabajo que la primera línea del
    cuerpo de la función @c{simplified-beginning-of-buffer}, que está escrita
    @c{(push-mark)}. En ambos casos, el intérprete Lisp asigna una marca en
    la posición actual del cursor.

    No sé por qué en la expresión @c{mark-whole-buffer} está escrito
    @c{(push-mark (point))} y en la expresión @c{beginning-of-buffer} está
    escrito @c{(push-mark)}. Quizás quien escribió el código no sabía que los
    argumentos para @c{push-mark} son opcionales y que si @c{push-mark} no se
    pasa como argumento, la función automáticamente asigna la marca en la
    localización del punto por defecto. O quizás la expresión fué escrita así
    como para parelizar la estructura de la siguiente línea. En cualquier
    caso, la línea causa que Emacs determine la posición del punto y asigne
    una marca allí.

    En las primeras versiones de GNU Emacs, la siguiente línea de
    @c{mark-whole-buffer} fué @c{(push-mark (point-max))}. Esta expresión
    asigna una marca en el punto en el búffer que tiene el número más
    alto. Esto será el fin del búffer (o, si el búffer es encogida, el fin de
    la porción accesible del búffer. Véase Sección @l{Encogiendo y
    extendiendo, , Encogiendo y extendiendo}, para más acerca de
    encoger). Después esta marca ha sido asignada, la marca previa, uno
    asigna un punto, pero no se asigna largo, pero Emacs recuerda su
    posición, solo como todas las otras marcas recientes son siempre
    recordadas. Esto significa que se puede, si lo deseas, vuelve a esta
    posición escribiendo @k{C-u C-@k{SPC}} dos veces.

    En GNU Emacs 22, el @c{(point-max)} es ligeramente más complicado. La
    línea lee

    @smallexample
      (push-mark (point-max) nil t)
    @end smallexample

    La expresión funciona cerca de lo mismo que antes. Eso asigna una marca
    en el lugar numerado más alto que se puede en el búffer. Sin embargo, en
    esta versión, @c{push-mark} tiene dos argumentos adicionales. El segundo
    argumento para @c{push-mark} es @c{nil}. Esto cuenta la función que
    @e{mostraría} un mensaje que dice ‘Marca asignada’ cuando eso empuja la
    marca. El tercer argumento es @c{t}. Esto cuenta @c{push-mark} para
    activar la marca cuando el modo Transient Mark está activado. Transient
    Mark mode ilumina la región de marca activa. Con frecuencia desactivada

    Finalmente, la última línea de la función es @c{(goto-char
    (point-min))}. Esto es escrito exactamente el mismo camino camino como
    está escrito @c{beginning-of-buffer}. La expresión mueve el cursor al
    mínimo punto en el búffer, que es, al principio del búfferr (o para el
    principio de la porción accesible del búffer). Como un resultado de esto,
    punto está emplazado al principio del búffer y la marca está asignada al
    fin del búffer. El búffer completo es, más allá, la región.

** La definición de @c{append-to-buffer}

   El comando @c{append-to-buffer} es más complejo que el comando
   @c{mark-whole-buffer}. Lo que hace es copiar la región (que es, la parte
   del búffer entre punto y marca) desde el buffer actual a un búffer
   específico.

   El comando @c{append-to-buffer} usa la función @c{insert-buffer-substring}
   para copiar la región. @c{insert-buffer-substring} es descrita por su
   nombre: eso toma una cadena de caracteres desde parte de un búffer, una
   “subcadena”, y las inserta dentro de otro búffer.

   La mayoría de @c{append-to-buffer} se refiere con la configuración de las
   condiciones para @c{insert-buffer-substring} para trabajar: el código debe
   especificar ambos el búffer para el que el texto irá, la ventana viene y
   va, y la región que será copiada.

   Aquí está el texto completo de la función:

   @smallexample
     (defun append-to-buffer (buffer start end)
       "Introduce al búffer específico el texto de la
       región. Esto es insertado de este búffer antes de su punto.

     Cuando se llama desde un programa, se dan tres argumentos:
     BUFFER (o nombre del búffer), START y END.
     START y END especifica la porción del búffer actual para ser copiado."
       (interactive
        (list (read-buffer "Append to buffer: " (other-buffer
                                                 (current-buffer) t))
              (region-beginning) (region-end)))
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (let* ((append-to (get-buffer-create buffer))
                  (windows (get-buffer-window-list append-to t t))
                  point)
             (set-buffer append-to)
             (setq point (point))
             (barf-if-buffer-read-only)
             (insert-buffer-substring oldbuf start end)
             (dolist (window windows)
               (when (= (window-point window) point)
                 (set-window-point window (point))))))))
   @end smallexample

   La función puede ser comprendida buscando como series de plantillas
   rellenas

   La plantilla de fuera es para la definición de la función. En esta
   función, se ve como esto (con varios slots rellenos):

   @smallexample
     (defun append-to-buffer (buffer start end)
       "@var{documentacion}…"
       (interactive …)
       @var{cuerpo}…)
   @end smallexample

   La primera línea de la función incluye su nombre y los tres
   argumentos. Los argumentos son el @c{búffer} que el texto será copiado, y
   el @c{start} y @c{end} de la región en el buffer actual que será copiado.

   La siguiente parte de la función es la documentación, que es claro y
   completo. Como es convencional, los tres argumentos son escritos en
   mayúsculas así se notificarán fácilmente. Incluso mejor, son descritas en
   el mismo orden como en la lista de argumentos.

   Nótese que la documentación distingue entre un búffer y su nombre. (La
   función puede manejar otro.)

*** La expresión interactiva @c{append-to-buffer}

    Desde que la función @c{append-to-buffer} será usada interactivamente, la
    función debe tener una expresión @c{interactive}. (Para una revisión de
    @c{interactive}, ver @l{Crear una Función Interactive}.) La expresión se
    lee de la siguiente manera:

    @smallexample
      (interactive
       (list (read-buffer
              "Agrega al buffer: "
              (other-buffer (current-buffer) t))
             (region-beginning)
             (region-end)))
    @end smallexample

    Esta expresión no es una con letras separadas por partes, como se
    describe antes. En vez de eso, empieza una lista con estas partes:

    La primera parte de la lista es una expresión para leer el nombre de un
    búffer y lo devuelve como una cadena. Esto es @c{read-buffer}. La función
    requiere una consola como su primer argumento, @'{"Asocia al buffer:
    "}. Su segundo argumento cuenta el comando que valora para proporciona si
    no especifica cualquier cosa.

    En este caso este segundo argumento es una expresión conteniendo la
    función @c{other-buffer}, una excepción, y una @'{t}, para verdad.

    El primer argumento para @c{other-buffer}, la excepción, es todavía otra
    función, @c{other-buffer}. Esto es no yendo a ser devuelto. El segundo
    argumento es el símbolo para verdad, @c{t}. Esto cuenta @c{other-buffer}
    que puede mostrar búffers visibles (excepto en este caso, eso no mostrará
    el búffer actual, que tiene sentido).

    La expresión se ve como:

    @smallexample
      (other-buffer (current-buffer) t)
    @end smallexample

    El segundo y tercer argumento de la expresión @c{list} son
    @c{(region-beginning)} y @c{(region-end)}. Estas dos funciones
    especifican el principio el y el final del texto que se adjunta.

    Originalmente, el comando usaba las letras @'{B} y @'{r}. La expresión
    completa @c{interactive} es así:

    @smallexample
      (interactive "BAsociar al buffer:@: \nr")
    @end smallexample

    Pero cuando esto fué hecho, el valor por defecto del búffer cambió a ser
    invisible. Esto no se quería.

    (La consola estaba separada del segundo argumento con una nueva línea,
    @'{\n}. Estaba seguido por un @'{r} que contaba a Emacs emparejar los dos
    argumentos que siguen el símbolo @c{buffer} en la lista de argumentos de
    la función (que es, @c{start} y @c{end}) para los valores de punto y
    marca. Este argumento trabajó bien.)

*** El cuerpo de @c{append-to-buffer}

    @ignore
      in GNU Emacs 22   in    /usr/local/src/emacs/lisp/simple.el

      (defun append-to-buffer (buffer start end)
        "Append to specified buffer the text of the region.
      It is inserted into that buffer before its point.

      When calling from a program, give three arguments:
      BUFFER (or buffer name), START and END.
      START and END specify the portion of the current buffer to be copied."
        (interactive
         (list (read-buffer "Append to buffer: " (other-buffer (current-buffer) t))
               (region-beginning) (region-end)))
        (let ((oldbuf (current-buffer)))
          (save-excursion
            (let* ((append-to (get-buffer-create buffer))
                   (windows (get-buffer-window-list append-to t t))
                   point)
              (set-buffer append-to)
              (setq point (point))
              (barf-if-buffer-read-only)
              (insert-buffer-substring oldbuf start end)
              (dolist (window windows)
                (when (= (window-point window) point)
                  (set-window-point window (point))))))))
    @end ignore

    El cuerpo de la función @c{append-to-buffer} empieza con @c{let}.

    Como se ha visto antes (@pxref{let, , @c{let}}), el propósito de una
    expresión @c{let} es crear y dar valores iniciales a una o más variable
    que solo serán usada con el cuerpo del @c{let}. Esto significa que tal
    variable no será confuso con cualquier variable del mismo nombre fuera de
    la expresión @c{let}.

    Podemos ver como la expresión @c{let} se ajusta dentro de la función como
    un todo mostrando una plantilla para @c{append-to-buffer} con la
    expresión @c{let} en línea:

    @smallexample
      (defun append-to-buffer (buffer start end)
        "@var{documentacion}…"
        (interactive …)
        (let ((@var{variable} @var{valor}))
              @var{cuerpo}…)
    @end smallexample

    La expresión @c{let} tiene tres elementos:

    1. El símbolo @c{let};

    2. Una varlist conteniendo, en este caso, una lista simple de dos
       elementos, @c{(@var{variable} @var{value})};

    3. El cuerpo de la expresión @c{let}.


    En la función @c{append-to-buffer}, la varlist se parece a esto:

    @smallexample
      (oldbuf (current-buffer))
    @end smallexample

    En esta parte de la expresión @c{let}, una variable, @c{oldbuf} es
    emparejada al valor devuelto por la expresión @c{(current-buffer)}. La
    variable, @c{oldbuf}, es usada para guardar la traza del búffer en el que
    tu estás trabajando y desde el que se copiará.

    El elemento o elementos de una varlist son rodeados por un conjunto de
    paréntesis así el intérprete Lisp puede distinguir la varlist desde el
    cuerpo del @c{let}. Como consecuencia, la lista de dos elementos con la
    varlist está rodeados por un circunscrito conjunto de paréntesis. Las
    líneas se ven así:

    @smallexample
      (let ((oldbuf (current-buffer)))
        … )
    @end smallexample

    Los dos paréntesis antes de @c{oldbuf} podrían sorprenderte si no fuera
    porque los primeros paréntesis antes de @c{oldbuf} marcan el límite de la
    varlist y el segundo paréntesis marca el principio de la lista de dos
    elementos, @c{(oldbuf (current-buffer))}.

*** @c{save-excursion} en @c{append-to-buffer}

    El cuerpo de la expresión @c{let} en @c{append-to-buffer} consiste de una
    expresión @c{save-excursion}.

    La función @c{save-excursion} guarda las localizaciones de punto y la
    marca, y las restaura a estas posiciones después de las expresiones en el
    cuerpo de la ejecución completa @c{save-excursion}. Además,
    @c{save-excursion} completa la ejecución. Además, @c{save-excursion}
    guarda la traza del búffer original, y lo restaura. Esto es cómo
    @c{save-excursion} que se usa en @c{append-to-buffer}.

    Incidentalmente, no se valora nada aquí que una función Lisp es
    normalmente formateada así que cada cosa que es encerrada en conjunto
    multilínea que es indentada más a la derecha que el primer símbolo. En
    esta definición de función, el @c{let} es indentado más que @c{defun}, y
    el @c{save-excursion} es indentado más que el @c{let}, como esto:

    @smallexample
      (defun …
        …
        …
        (let…
          (save-excursion
            …
    @end smallexample

    Esta convención formatea que sea fácil de ver que las líneas en el cuerpo
    de @c{save-excursion}, solo como @c{save-excurion} por sí mismo están
    encerradas por los paréntesis asociados con el @c{let}:

    @smallexample
      (let ((oldbuf (current-buffer)))
        (save-excursion
          …
          (set-buffer …)
          (insert-buffer-substring oldbuf start end)
          …))
    @end smallexample

    El uso de la función @c{save-excursion} puede ser vista como un proceso
    de rellenar slots de una plantilla:

    @smallexample
      (save-excursion
        @var{primera-expresion-en-cuerpo}
        @var{segunda-expresion-en-cuerpo}
         …
        @var{ultima-expresion-en-cuerpo})
    @end smallexample

    En esta función, el cuerpo de @c{save-excursion} contiene solo una
    expresión, la expresión @c{let*}. Se conoce una función @c{let}. La
    función @c{let*} es diferente. Eso tiene un @'{*} en su nombre. Eso
    permite a Emacs asignar cada variable de su varlist en secuencia, una
    después de otra.

    Su funcionalidad crítica es que las variable después en la varlist puedan
    hacer uso de los valores para los que Emacs asigna variables pronto en la
    varlist. Véase Sección @l{La expresión @c{let*}}.

    Se obviarán funciones como @c{let*} y se focalizará en dos: la función
    @c{set-buffer} y la función @c{insert-buffer-substring}.

    En antaño, la expresión @c{set-buffer} era simple:

    @smallexample
      (set-buffer (get-buffer-create buffer))
    @end smallexample

    pero ahora eso es

    @smallexample
      (set-buffer append-to)
    @end smallexample

    @c{append-to} se asigna a @c{(get-buffer-create-buffer)} pronto en la
    expresión @c{let*}. Esta asociación extra no sería necesaria excepto para
    este @c{append-to} es usado después en la varlist como un argumento para
    @c{get-buffer-window-list}.

    @ignore
      in GNU Emacs 22

        (let ((oldbuf (current-buffer)))
          (save-excursion
            (let* ((append-to (get-buffer-create buffer))
                   (windows (get-buffer-window-list append-to t t))
                   point)
              (set-buffer append-to)
              (setq point (point))
              (barf-if-buffer-read-only)
              (insert-buffer-substring oldbuf start end)
              (dolist (window windows)
                (when (= (window-point window) point)
                  (set-window-point window (point))))))))
    @end ignore

    La definición de la función @c{append-to-buffer} inserta texto desde el
    búffer en el que estás actualmente a un buffer nombrado. Eso sucede que
    @c{insert-buffer-substring} copia texto desde otro búffer al búffer
    actual, solo el inverso––que es porque la definición @c{append-to-buffer}
    empieza con un @c{let} que asocia el símbolo local @c{oldbuf} al valor
    devuelto por @c{current-buffer}.

    La expresión @c{insert-buffer-substring} se ve como esto:

    @smallexample
      (insert-buffer-substring oldbuf start end)
    @end smallexample

    La función @c{insert-buffer-substring} copia una cadena @e{from} al
    búffer especificado como su primer argumento e inserta la cadena dentro
    del búffer presente. En este caso, el argumento para
    @c{insert-buffer-substring} es el valor de la variable creada y asociada
    por el @c{let}, llama al valor de @c{oldbuf}, que fué el búffer actual
    cuando tu diste el comando @c{append-to-buffer}.

    Después de que @c{insert-buffer-substring} ha hecho su trabajo,
    @c{save-excursion} restaurará la acción al búffer original y
    @c{append-to-buffer} habrá hecho su trabajo.

    Escrito en forma esquelética, los trabajos del cuerpo se ven como esto:

    @smallexample
      (let (@var{bind-}@c{oldbuf}@var{-to-value-of-}@c{current-buffer})
        (save-excursion                       ; @r{Guarda la traza del búffer.}
          @var{change-buffer}
          @var{insert-substring-from-}@c{oldbuf}@var{-into-buffer})

        @var{change-back-to-original-buffer-when-finished}
      @var{let-the-local-meaning-of-}@c{oldbuf}@var{-disappear-when-finished}
    @end smallexample

    En resumen, @c{append-to-buffer} funciona como sigue: se guarda el valor
    del búffer actual en la variable llamada @c{oldbuf}. Se obtiene el nuevo
    búffer (creando uno si necesita ser) y cambia la atención de Emacs a
    eso. Usando el valor de @c{oldbuf}, inserta la región del texto desde el
    viejo búffer dentro del nuevo búffer; y entonces usando
    @c{save-excursion}, trae atrás a tu búffer original.

    Buscando @c{append-to-buffer}, se ha explorado una función limpia
    compleja. Eso muestra como usar @c{let} y @c{save-excursion}, y como
    cambiar y volver desde otro buffer. Muchas definiciones de función usan
    @c{let}, @c{save-excursion}, y @c{set-buffer} de este modo.

** Revisar

   Aquí está un breve resumen de varias funciones discutidas en este
   capítulo.

   - describe-function -:
   - describe-variable -:

     Imprime la documentación para una función o variable. Convencionalmente
     asociada a @k{C-h f} y @k{C-h v}.

   - find-tag -:

     Encuentra el fichero que contiene la fuente para una función o variable
     y cambia buffer a él, posicionando el punto al principio del
     ítem. Convencionalmente emparejado a @k{M-.} (esto es un período
     seguiendo la tecla @k{META}).

   - save-excursion -:

     Guarda la localización de punto y marca y restaura sus valores después
     de los argumentos para @c{save-excursion} y han sido evaluados. También,
     recuerda el buffer actual y devuélvelo.

   - push-mark -:

     Asigna la marca en una localización y graba el valor de la marca previa
     en el anillo de la marca. La marca es una localización en el búffer que
     guarda su posición relativa incluso si el texto es añadido o borrado
     desde el búffer.

   - goto-char -:

     Asigna punto a la localización especificada por el valor del argumento,
     que puede ser un número, una marca, o una expresión que devuelve el
     número de una posición, tal como @c{(point-min)}.

   - insert-buffer-substring -:

     Copia una región de texto desde un búffer que es pasado a la función
     como un argumento e inserta la región dentro del búffer actual.

   - mark-whole-buffer -:

     Marca el búffer completo como una región. Normalmente asignado a @k{C-x
     h}.

   - set-buffer -:

     Cambia la atención de Emacs a otro búffer, pero no cambies la ventana
     siendo mostrada. Usado cuando el programa en vez de un humano trabaja en
     un búffer diferente.

   - get-buffer-create -:
     get-buffer        -:

     Encuentra un búffer nombrado o crea uno si un búffer de este nombre no
     existe. La función @c{get-buffer} devuelve @c{nil} si el nombre del
     búffer no existe.

** Ejercicios

   - Escribe tu propia definición de función @c{simplified-end-of-buffer};
     entonces testea para ver si funciona.

   - Usa @c{if} y @c{get-buffer} para escribir una función que imprime un
     mensaje contando si un buffer existe.

   - Usando @c{find-tag}, encuentra la fuente para la función
     @c{copy-to-buffer}

* Unas pocas funciones más complejas

  En este capítulo, se construye lo que se aprendió en los capítulos previos
  mirando en funciones más complejas. La función @c{copy-to-buffer} ilustra
  el uso de expresiones @c{save-excursion} en una definición, mientras la
  función @c{insert-buffer} ilustra el uso de un asterisco en una expresión
  @c{interactive}, uso de @c{o}, y la importante distinción entre un nombre y
  el objeto para el que el nombre se refiere.

** La definición de @c{copy-to-buffer}

   Después de comprender cómo se trabaja @c{append-to-buffer}, es fácil para
   comprender @c{copy-to-buffer}. Esta función copia texto dentro de un
   búffer, pero en vez de añadir al segundo búffer, se reemplaza a todo el
   texto previo en el segundo búffer.

   El cuerpo de @c{copy-to-buffer} se ve como esto,

   @smallexample
     …
     (interactive "BCopy to buffer: \nr")
     (let ((oldbuf (current-buffer)))
       (with-current-buffer (get-buffer-create buffer)
         (barf-if-buffer-read-only)
         (erase-buffer)
         (save-excursion
           (insert-buffer-substring oldbuf start end)))))
   @end smallexample

   La función @c{copy-to-buffer} tiene una expresión simple @c{interactive}
   en vez de @c{append-to-buffer}.

   La definición entonces dice:

   @smallexample
     (with-current-buffer (get-buffer-create buffer) …
   @end smallexample

   Primero, mira en la expresión interna más temprana; que es evaluada
   primero. Esta expresión empieza con @c{get-buffer-create buffer}. La
   función cuenta al ordenador para usar el búffer con el nombre específicado
   como uno para el que estás copiando, o si tal búffer no existe,
   créalo. Entonces, la función @c{with-current-buffer} evalúa su cuerpo con
   este búffer temporalmente al actual.

   (Esto demuestra otro camino para cambiar la atención del ordenador pero no
   los usuarios. La función @c{append-to-buffer} muestra como hacer lo mismo
   con @c{save-excursion} y @c{set-buffer}. @c{with-current-buffer} es uno
   nuevo, y argumentablemente fácil, mecanismo.)

   La función @c{barf-if-buffer-read-only} envía un mensaje de error diciendo
   al búffer es de solo lectura si no se puede modificar.

   La siguiente línea tiene la función @c{erase-buffer} como sus únicos
   contenidos. Este función borra el búffer.

   Finalmente, las últimas dos líneas contienen la expresión
   @c{save-excursion} con @c{insert-buffer-substring} como su cuerpo. La
   expresión @c{insert-buffer-substring} copia el texto desde el búffer en el
   que se está (y no se ha visto el ordenador puesta su atención, así no se
   sabe que este búffer es ahora llamado @c{oldbuf}).

   De manera incidental, esto es lo que significa por ‘reemplazo’. Para
   reemplazar texto Emacs se borra el texto previo y entonces se inserta el
   nuevo texto.

   El código fuente, del cuerpo de @c{copy-to-buffer} se parece a esto:

   @smallexample
     (let (@var{bind-}@c{oldbuf}@var{-to-value-of-}@c{current-buffer})
         (@var{with-the-buffer-you-are-copying-to}
           (@var{but-do-not-erase-or-copy-to-a-read-only-buffer})
           (erase-buffer)
           (save-excursion
             @var{insert-substring-from-}@c{oldbuf}@var{-into-buffer})))
   @end smallexample

** La definición de @c{insert-buffer}

   @c{insert-buffer} es todavía una función relacionada con el búffer. Este
   comando copia otro búffer @e{dentro} del búffer actual. Es lo inverso de
   @c{append-to-buffer} o @c{copy-to-buffer}, desde que se copia una región
   de texto @e{desde} el búffer actual a otro búffer.

   Aquí hay una discusión basada en el código original. El código era
   simplificado en 2003 y es duro de comprender.

   (Véase Sección @l{Nuevo Cuerpo para @c{insert-buffer}}, para ver una
   discusión del nuevo cuerpo.)

   Además, este código ilustra el uso de @c{interactive} con un
   búffer que podría ser @:{read-only} y la
   distinción entre el nombre de un objeto y el objeto actualmente referido.

   Aquí está el primer código

   @smallexample
     (defun insert-buffer (buffer)
       "Inserta después del punto los contenidos del BUFFER.
     Pon la marca después del texto insertado.
     El BUFFER puede ser un buffer un nombre de buffer."
       (interactive "*bInsert buffer:@: ")
       (or (bufferp buffer)
           (setq buffer (get-buffer buffer)))
       (let (start end newmark)
         (save-excursion
           (save-excursion
             (set-buffer buffer)
             (setq start (point-min) end (point-max)))
           (insert-buffer-substring buffer start end)
           (setq newmark (point)))
         (push-mark newmark)))
   @end smallexample

   Como con otras definiciones de función, se puede usar una plantilla para
   visión de la función:

   @smallexample
     (defun insert-buffer (buffer)
       "@var{documentation}…"
       (interactive "*bInsert buffer:@: ")
       @var{body}…)
   @end smallexample

*** La expresión interactiva en @c{insert-buffer}

    En @c{insert-buffer}, el argumetno para la declaración @c{interactive}
    tiene dos partes, un asterisco, @'{*}, y @'{bInserta un buffer:@: }.

**** Un búffer de solo lectura

     El asterisco se utliza en la situación cuando el búffer actual es un
     búffer de solo lectura––un búffer que no puede ser modificado. Si
     @c{insert-buffer} es llamado cuando el búffer actual es de solo lectura,
     un mensaje a este efecto está impreso en el área echo y el terminal
     puede avisar; no se permite insertar cualquier cosa dentro del
     búffer. El asterisco no necesita ser seguido por una nueva línea para
     separarse desde el siguiente argumento.

**** @'{b} en una expresión interactiva

     El siguiente argumento en la expresión interactiva empieza con una tecla
     minúscula @'{b}. (Esto es diferente desde el código para
     @c{append-to-buffer}, que usa una mayúscula @'{B}. Véase Sección @l{La
     Definición de @c{append-to-buffer}}.) La tecla minúscula cuenta al
     intérprete Lisp que el argumento para @c{insert-buffer} sería un buffer
     existente o sino su nombre. (La mayúscula @'{B} provee para la
     posibilidad que el búffer no existe.)  Emacs te mostrará en pantalla el
     nombre del búffer, ofreciendo un búffer por defecto, con la compleción
     de nombre habilitado. Si el búffer no existe, se recibe un mensaje que
     dice “No concuerda”; tu terminal te avisa también.

     El nuevo y simplificado código genera una lista @c{interactive}. Eso usa
     las funciones @c{barf-if-buffer-read-only} y @c{read-buffer} con las que
     estamos ya familiarizados y la forma especial @c{progn} con los que
     no. (Eso será descrito después).

*** El cuerpo de la función @c{insert-buffer}

    El cuerpo de la función @c{insert-buffer} tiene dos partes principales:
    una expresión @c{or} y una expresión @c{let}. El propósito de la
    expresión @c{or} es asegurar que el argumento @c{buffer} es emparejado a
    un búffer y no solo el nombre de un búffer. El cuerpo de la expresión
    @c{let} contiene el código que copia los otros búffers dentro del búffer.

    En el "outline" (esquema), las dos expresiones se ajustan dentro de la
    función @c{insert-buffer} como esto:

    @smallexample
      (defun insert-buffer (buffer)
        "@var{documentation}…"
        (interactive "*bInsertar buffer:@: ")
        (or …
            …
        (let (@var{varlist})
            @var{body-of-}@c{let}… )
    @end smallexample

    Para comprender como la expresión @c{or} asegura que el argumento
    @c{buffer} es emparejado a un buffer y no al nombre de un búffer, es
    primero necesario comprender la función @c{or}.

    Antes de hacer esto, permíteme reescribir esta parte de la función usando
    @c{if} así puedes ver que es hecho en una manera que será familiar.

*** @c{insert-buffer} con un @c{if} en vez de un @c{or}

    El trabajo que debe ser hecho y asegura el valor de @c{buffer} es un
    búffer en sí mismo y no el nombre de un búffer. Si el valor es el nombre,
    entonces el búffer en sí debe ser obtenido.

    Te puedes imaginar a tí mismo en una conferencia donde un acomodador está
    observando una lista con tu nombre dentro y mirándote: el acomodador sabe
    “asociar” tu nombre, pero no a tí; pero cuando el acomodador te encuentra
    y te toma el brazo, el acomodador llega a “asociarte” a tí.

    En Lisp, se podría describir esta situación así:

    @smallexample
      (if (not (holding-on-to-guest))
          (find-and-take-arm-of-guest))
    @end smallexample

    Se quiere hacer la misma cosa con un búffer––si no tenemos el búffer en
    sí, queremos tenerlo.

    Usando un predicado llamado @c{bufferp} que nos cuenta si tenemos un
    búffer (en vez de su nombre), se puede escribir el código como este:

    @smallexample
      (if (not (bufferp buffer))              ; @r{if-part}
          (setq buffer (get-buffer buffer)))  ; @r{then-part}
    @end smallexample

    Aquí, el true-or-false-test de la expresión @c{if} es @c{(not (bufferp
    buffer))}; y la then-part es la expresión @c{(setq buffer (get-buffer
    buffer))}.

    En el test, la función @c{bufferp} devuelve cierto si su argumento es un
    búffer––pero falso si su argumento es el nombre del búffer. (El último
    carácter del nombre de la función @c{bufferp} es el carácter @'{p}; como
    se vió antes, tal uso de @'{p} es una convención que indica que la
    función es un predicado, que es un término que significa que la función
    determinará si alguna propiedad es verdadera o falsa. Véase Sección
    @l{Tipo incorrecto de argumento, , Usando el objeto de tipo incorrecto
    como un argumento}.)

    La función @c{not} precede la expresión @c{(bufferp buffer)}, así el
    true-or-false-test se ve como esto:

    @smallexample
      (not (bufferp buffer))
    @end smallexample

    @c{no} es una función que devuelve cierto si su argumento es falso y
    falso si su argumento es verdadero. Así si @c{(bufferp buffer)} devuelve
    cierto, la expresión @c{no} devuelve falso y vice-versa: que es “no
    cierto” es falso que es “no falso” es verdadero.

    Usando este test, la expresión @c{if} trabaja como sigue: cuando el valor
    de la variable @c{buffer} está actualmente en un búffer en vez de su
    nombre, el test true-or-false-test devuelve false y la expresión @c{if}
    no evalúa la parte then-part. Esto está bien, desde que no necesita para
    hacer cualquier cosa para la variable @c{buffer} si es realmente un
    búffer.

    Por otro lado, cuando el valor de @c{buffer} no es un buffer en sí, pero
    el nombre de un buffer, el true-or-false-test devuelve cierto y la
    then-part de la expresión es evaluada. En este caso, la then-part es
    @c{(setq buffer (get-buffer buffer))}. Esta expresión usa la función
    @c{get-buffer} para devolver un buffer actual en sí, dado su nombre. El
    @c{setq} entonces asigna la variable @c{buffer} al valor del buffer en
    sí, reemplazando su valor previo (que era el nombre del buffer).

*** El @c{or} en el cuerpo

    El propósito de la expresión @c{or} en la función @c{insert-buffer} es
    asegurar que el argumento @c{buffer} está asociado a un búffer y no solo
    al nombre de un búffer. La sección previa muestra como el trabajo podría
    haber sido hecho usando una expresión @c{if}. Sin embargo, la función
    @c{insert-buffer} actualmente usa @c{or}. Para comprender esto, es
    necesario comprender como @c{or} trabaja.

    Una función @c{or} puede tener cualquier número de argumentos. Eso evalúa
    cada argumento en turno y devuelve el valor del primero de sus argumentos
    que no es @c{nil}. También, y esto es una funcionalidad crucial de
    @c{or}, eso no evalúa cualquier argumentos subsiguientes después
    devolviendo el primer valor no-@c{nil}.

    La expresión @c{or} se ve como esto:

    @smallexample
      (or (bufferp buffer)
          (setq buffer (get-buffer buffer)))
    @end smallexample

    El primer argumento a @c{or} es la expresión @c{(bufferp buffer)}. Esta
    expresión devuelve cierto (un valor no-@c{nil}) si el búffer es
    actualmente un búffer, y no solo el nombre de un búffer. En la expresión
    @c{or}, si este es el caso, la expresión @c{or} devuelve esto el valor
    cierto y no evalúa la siguiente expresión––y esto es bueno para nosotros,
    desde que nosotros no queremos hacer cualquier cosa al valor de
    @c{buffer} si eso es realmente un búffer.

    Por otro lado, si el valor de @c{(bufferp buffer)} es @c{nil}, que será
    si el valor de @c{buffer} es el nombre de un buffer, el intérprete Lisp
    evalúa el siguiente elemento de la expresión. Esta es la expresión
    @c{(setq buffer (get-buffer buffer))}. Esta expresión devuelve un valor
    no-@c{nil}, que es el valor para el que asigna la variable @c{buffer} ---
    y este valor es un búffer en sí, no el nombre de un búffer.

    El resultado de todo esto es que el símbolo @c{buffer} es siempre
    asociado a un búffer en sí en vez del nombre de un búffer. Toda es
    necesario porque la función @c{set-buffer} en una línea siguiente trabaja
    con un buffer en sí, no con el nombre de un búffer.

    Incidentalmente, usando @c{or}, la situación con el acomodador se vería
    así:

    @smallexample
      (or (holding-on-to-guest) (find-and-take-arm-of-guest))
    @end smallexample

*** La expresión @c{let} en @c{insert-buffer}

    Después asegurando que la variable @c{buffer} se refiere a un buffer en
    sí y no solo al nombre de un buffer, la función @c{insert-buffer}
    continúa con una expresión @c{let}. Esto especifica tres variables
    locales, @c{start}, @c{end} y @c{newmark} y los asocia al valor inicial
    @c{nil}. Estas variables son usadas dentro del resto de @c{let} y
    temporalmente se oculta con cualquier otra ocurrencia de variables del
    mismo nombre en Emacs hasta el fin del @c{let}.

    El cuerpo del @c{let} contiene dos expresiones
    @c{save-excursion}. Primero, miraremos la expresión @c{save-excursion} en
    detalle. La expresión se parece a esto:

    @smallexample
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
    @end smallexample

    La expresión @c{(set-buffer buffer)} cambia la atención de Emacs desde el
    búffer actual a uno desde el que el texto será copiado. En este búffer
    las variables @c{start} y @c{end} se asignadan al principio y al fin del
    búffer, usando los comandos @c{point-min} y @c{point-max}. Note que
    tenemos aquí una ilustración de cómo @c{setq} es capaz de asignar dos
    variables en la misma expresión. El primer argumento de @c{setq} es
    asignar al valor del segundo, y su tercer argumento está asignado al
    valor del cuarto.

    Después el cuerpo del @c{save-excursion} propio es evaluado, el
    @c{save-excursion} restaura el búffer original, pero @c{start} y @c{end}
    permanece asignado a los valores del principio y fin del búffer en el que
    el texto será copiado.

    La expresión por fuera @c{save-excursion} se ve como:

    @smallexample
      (save-excursion
        (@var{inner-}@c{save-excursion}@var{-expression}
           (@var{go-to-new-buffer-and-set-}@c{start}@var{-and-}@c{end})
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
    @end smallexample

    La función @c{insert-buffer-substring} copia el texto @e{dento} del
    búffer @e{desde} la región indicada por @c{start} y @c{end} en el
    @c{búffer}. Desde el total del segundo búffer cae entre @c{start} y
    @c{end}, el todo del segundo búffer es copiado dentro del búffer que
    estás editando. Lo siguiente, el valor del punto, que será al fin del
    texto insertado, es grabado en la variable @c{newmark}.

    Después el cuerpo de @c{save-excursion} es evaluado, punto y marca son
    recolocados a sus lugares originales.

    Sin embargo, es conveniente localizar una marca al fin del texto
    nuevamente insertado y localizar el punto al principio. La variable
    @c{newmark} graba el fin del texto insertado. En la última línea de la
    expresión @c{let}, la expresión de la función @c{(push-mark newmark)}
    asigna una marca a esta posición. (La posición previa de la marca está
    todavía accesible; está grabado en la marca del anillo y se puede
    regresar a eso con @k{C-u C-@k{SPC}}.) Mientras tanto, el punto está
    localizado al principio del texto insertado, que está donde estaba antes
    de ser llamado la función que inserta, la posición de lo que estaba
    guardado por la primera @c{save-excursion}.

    La expresión @c{let} se parece a esto:

    @smallexample
      (let (start end newmark)
        (save-excursion
          (save-excursion
            (set-buffer buffer)
            (setq start (point-min) end (point-max)))
          (insert-buffer-substring buffer start end)
          (setq newmark (point)))
        (push-mark newmark))
    @end smallexample

    Como la función @c{append-to-buffer}, la función @c{insert-buffer} usa
    @c{let}, @c{save-excursion} y @c{set-buffer}. Además, la función ilustra
    un camino para usar @c{o}. Toda estas funciones están construyendo el
    bloque que se encontrarán y usarán una y otra vez.

*** Nuevo cuerpo para @c{insert-buffer}

    El cuerpo en la versión de GNU Emacs 22 es más confuso que en el
    original.

    Consiste de dos expresiones

    @smallexample
        (push-mark
         (save-excursion
           (insert-buffer-substring (get-buffer buffer))
           (point)))

         nil
    @end smallexample

    excepto, y esto es lo que los novicios confunden, un trabajo muy
    importante es hecho dentro de la expresión @c{push-mark}.

    La función @c{get-buffer} devuelve un búffer con el nombre
    proporcionado. Se tomará nota de que la función @e{no} se llama
    @c{get-buffer-create}; eso no crea un búffer si uno no existe ya. El
    búffer devuelto por @c{get-buffer}, un búffer existente, es pasado a
    @c{insert-buffer-substring}, que inserta el total del búffer (desde que
    no se especificón ninguna cosa más).

    La posición dentro del buffer es insertado es grabado por
    @c{push-mark}. Entonces la función devuelve @c{nil}, el valor de su
    último comando. Pon otro camino, la función @c{insert-buffer} existe solo
    para producir un efecto lateral, insertando otro buffer, no para devolver
    cualquier valor.

** Definición completa de @c{beginning-of-buffer}

   La estructura básica de la función @c{beginning-of-buffer} ya ha sido
   discutida. (Véase Sección @l{Una definición simplificada de
   @c{beginning-of-buffer}}). Esta sección describe la parte compleja de la
   definición.

   Como se describe previamente, cuando se invoca sin un argumento,
   @c{beginning-of-buffer} mueve el cursor al principio del búffer (en
   realidad, al principio de la porción accesible del búffer), dejando la
   marca en la posición previa. Sin embargo, cuando el comando es invocado
   con un número entre uno y diez, la función considera que número será una
   fracción del tamaño del búffer, medido en decenas, y Emacs mueve el cursor
   en esta fracción del camino desde el principio del búffer. De este modo,
   se puede o bien llamar a esta función con la tecla comando @k{M-<}, que
   moverá el cursor al principio del búffer, o con una tecla tal como @k{C-u
   7 M-<} que moverá el cursor a un punto 70% del camino a través del
   búffer. Si un número más grande de diez es usado para el argumento que se
   mueve al final del búffer.

   La función @c{beginning-of-buffer} puede ser llamada con o sin
   argumentos. El uso del argumento es opcional.

*** Argumentos opcionales

    A menos que se cuente de otro modo, Lisp espera que una función con un
    argumento en su definición de función se llame con un valor para este
    argumento. Si esto no ocurre, se obtiene un error y un mensaje que dice
    @'{Número de argumentos erróneo}.

    Sin embargo, los argumentos opcionales son una funcionalidad de Lisp: una
    @:{palabra clave} particular es usada para contar al intérprete Lisp que
    un argumento es opcional. La palabra clave es @c{&optional}. (El @'{&} en
    frente de @'{opcional} es parte de la palabra clave.) En una definición
    de función, si un argumento sigue a la palabra clave @c{&optional},
    ningún valor necesita ser pasado a este argumento cuando la función se
    llama.

    La primera línea de la definición de función de @c{beginning-of-buffer}
    tiene lo siguiente:

    @smallexample
      (defun beginning-of-buffer (&optional arg)
    @end smallexample

    En el "outline" (esquema), la función completa se parece a esto:

    @smallexample
      (defun beginning-of-buffer (&optional arg)
        "@var{documentation}…"
        (interactive "P")
        (or (@var{is-the-argument-a-cons-cell} arg)
            (and @var{are-both-transient-mark-mode-and-mark-active-true})
            (push-mark))
        (let (@var{determine-size-and-set-it})
        (goto-char
          (@var{if-there-is-an-argument}
              @var{figure-out-where-to-go}
            @var{else-go-to}
            (point-min))))
         @var{do-nicety}
    @end smallexample

    La función es similar a la función @c{simplified-beginning-of-buffer}
    excepto que la expresión @c{interactive} tiene @c{"P"} como un argumento
    y la función @c{goto-char} es seguida por una expresión if-then-else que
    figura donde poner el cursor si hay un argumento que no es un cons cell.

    (Puesto que no se explica un cons cell en muchos capítulos, por favor,
    considere ignorar la función @c{consp}. @l{Cómo las listas se
    implementan}, y Seccion "Cons Cell y Tipos de Listas" en @e(El Manual de
    Referencia GNU Emacs Lisp)).

    El @c{"P"} en la expresión @c{interactive} cuenta a Emacs cómo pasar un
    argumento prefijo, si hay uno, a la función en forma plana. Un argumento
    prefijo se crea escribiendo la tecla @k{META} seguida por un número, o
    escribiendo @k{C-u} y entonces un número. (Si no escribes un número,
    @k{C-u} por defecto a un cons cell con un 4. Una minúscula @c{"p"} en la
    expresión @c{interactive} causa a la función convertir un argumento
    prefijo a un número.)

    El true-or-false-test de la expresión @c{if} se ve compleja, pero no lo
    es: se chequea si @c{arg} tiene un valor que no es @c{nil} y si es un
    cons cell. (Esto es lo que @c{consp} hace; chequea si su argumento es un
    cons cell.) Si @c{arg} tiene un valor que no es @c{nil} (y no es un cons
    cell.), que será el caso si @c{beginning-of-buffer} se llama con un
    argumento, entonces este true-or-false-test devolverá cierto y la
    then-part de la expresión @c{if} falsa. Por otro lado, si
    @c{beginning-of-bufer} no se llama con un argumento, el valor de @c{arg}
    será @c{nil} y la else-part de la expresión @c{if} se evaluará. La
    else-part es simple @c{point-min}, y esto es lo de fuera, la expresión
    @c{goto-char} es @c{(goto-char (point-min))}, que es cómo se vió la
    función @c{beginning-of-buffer} en su forma simplificada.

*** @c{beginning-of-buffer} con un argumento

    Cuando @c{beginning-of-buffer} se llama con un argumento, una expresión
    es evaluada que calcula que valor pasa a @c{goto-char}. Esto es incluso
    complicado a primera vista. Eso incluye una expresión @c{if} propia y
    mucha aritmética. Se ve así:

    @smallexample
      (if (> (buffer-size) 10000)
          ;; @r{¿Evitar sobrecarga para grandes tamaños de búffer!}
                                (* (prefix-numeric-value arg)
                                   (/ size 10))
        (/
         (+ 10
            (*
             size (prefix-numeric-value arg))) 10)))
    @end smallexample

    Como otras expresiones que se ven complejas, la expresión condicional con
    @c{beginning-of-buffer} puede ser desenredada mirándola por partes de una
    plantilla, en este caso, la plantilla par una expresión if-then-else. En
    forma esquelética, la expresión se ve así:

    @smallexample
      (if (@var{buffer-is-large}
          @var{divide-buffer-size-by-10-and-multiply-by-arg}
        @var{else-use-alternate-calculation}
    @end smallexample

    El true-or-fase-test de esta expresión @c{if} propia chequea el tamaño
    del buffer. La razón para esto es que la versión vieja de Emacs 18 usaba
    números que no son más grandes que 8 millones o así y en la computación
    que seguía, el programador temía que Emacs podría intentar usar a través
    de largos números si el búffer fuera largo. El término ‘sobrecarga’, que
    se mencionó en el comentario, significa que los números son grandes. Las
    versiones más recientes de Emacs usan números largos, pero este código no
    ha sido tocado, solo porque la gente ahora mira en búffers que están
    lejos, tan lejos como antes.

    Hay dos casos: si el búffer es largo, o si no.

**** Qué ocurre en un búffer largo

     En @c{beginning-of-buffer}, la expresión propia @c{if} chequea si el
     tamaño del búffer es mayor que 10000 caracteres. Para hacer esto, se usa
     la función @c{>} y la computación de @c{size} que viene desde la
     expresión let.

     Hace tiempo, se usaba la función @c{buffer-size}. No solo esta función
     era llamada varias veces, eso daba el tamaño del búffer completo, no la
     parte accesible. La computación tiene mucho más sentido cuando se maneja
     solo la parte accesible. (Véase Sección @l{Encogiendo y extendiendo},
     para más información en focalizar la atención para una parte
     ‘accesible’.)

     La línea se parece a esto:

     @smallexample
       (if (> size 10000)
     @end smallexample

     Cuando el búffer es largo, el then-part de la expresión @c{if} se
     evalúa. Eso se lee así (después de ser formateado para una fácil
     lectura):

     @smallexample
       (*
         (prefix-numeric-value arg)
         (/ size 10))
     @end smallexample

     Esta expresión es una multiplicación, con dos argumentos para la función
     @c{*}.

     El primer argumento es @c{(prefix-numeric-value arg)}. Cuando @c{"P"} se
     usa como argumento para @c{interactive}, el valor pasado para la función
     como argumento es un “argumento prefijo crudo”, y no un número. (Es un
     número en una lista). Para desarrollar la aritmética, una conversión es
     necesaria, y @c{prefix-numeric-value} hace el trabajo.

     El segundo argumento es @c{(/ size 10)}. Esta expresión divide el valor
     numérico por diez––el valor numérico del tamaño de la porción accesible
     del búffer. Esto produce un número que cuenta cuántos caracteres crean
     una decena del tamaño del búffer. (En Lisp, @c{/} es usado para
     división, solo como @c{*} es usado para multiplicación.)

     En la expresión de la multiplicación como un todo, esta cantidad se
     multiplica por el valor del argumento prefijo––la multiplicación se
     parece a:

     @smallexample
       (* @var{numeric-value-of-prefix-arg}
          @var{number-of-characters-in-one-tenth-of-the-accessible-buffer})
     @end smallexample

     Si, por ejemplo, el argumento prefijo es @'{7}, el valor one-tenth será
     multiplicado por 7 para dar una posición del 70% del camino.

     El resultado de todo esto es que si la porción accesible del búffer es
     largo, la expresión @c{goto-char} se lee esto:

     @smallexample
       (goto-char (* (prefix-numeric-value arg)
                     (/ size 10)))
     @end smallexample

     Esto pone el cursor donde se quiere.

**** Qué ocurre en un búffer pequeño

     Si el búffer contiene poco más de 10000 caracteres, una computación
     ligeramente diferente es medida. Se podría pensar que esto no es
     necesario, desde que la primera computación podría hacer el trabajo. Sin
     embargo, en un búffer pequeño, el primer método puede no poner el cursor
     en la línea exactamente deseada; el segundo método hace un trabajo
     mejor.

     El código se parece a esto:

     @smallexample
       (/ (+ 10 (* size (prefix-numeric-value arg))) 10))
     @end smallexample

     Este es el código en el que se ve qué ocurre descubriendo como las
     funciones se embeben entre paréntesis. Eso es fácil de leer si se
     reformatea con cada expresión indentada más profundamente que la
     expresión que encierra:

     @smallexample
         (/
          (+ 10
             (*
              size
              (prefix-numeric-value arg)))
          10))
     @end smallexample

     Mirando los paréntesis, se ve que la operación propia es
     @c{(prefix-numeric-value arg)}, que convierte el argumento plano para un
     número. En la siguiente expresión, este número es multiplicado por el
     tamaño de la porción accesible del búffer:

     @smallexample
       (* size (prefix-numeric-value arg))
     @end smallexample

     Esta multiplicación crea un número que puede ser más largo que el tamaño
     del buffer––siete veces más larga si el argumento es 7, por
     ejemplo. Diez se a@~anade a éste n@~umero y finalmente el número es
     dividido por 10 para proporcionar un valor que es un carácter más largo
     que la posición de porcentaje en el búffer.

     El número que resulta de todo esto se pasa a @c{goto-char} y el cursor
     se mueve a este punto.

*** El @c{beginning-of-buffer} completo

    Aquí está el texto completo de la función @c{beginning-of-buffer}:

    @smallexample
      (defun beginning-of-buffer (&optional arg)
        "Mueve el punto al principio del buffer;
      deja marca en la posición previa.
      Con prefijo \\[universal-argument],
      no se asigna una marca en la posición previa.
      Con el argumento numérico N, pon el
      punto N/10 del camino desde el principio.
      Si el búffer está encogido
      este comando usa el principio y tamaño
      de la parte accesible del búffer.

      ¿No use este comando en programas Lisp!
      \(goto-char (point-min)) es rápido
      y evita poseer la marca."
        (interactive "P")
        (or (consp arg)
            (and transient-mark-mode mark-active)
            (push-mark))
        (let ((size (- (point-max) (point-min))))
          (goto-char (if (and arg (not (consp arg)))
                         (+ (point-min)
                            (if (> size 10000)
                                ;; ¿Evita sobrecarga para grandes tamaños de búffer!
                                (* (prefix-numeric-value arg)
                                   (/ size 10))
                              (/ (+ 10 (* size (prefix-numeric-value arg)))
                                 10)))
                       (point-min))))
        (if arg (forward-line 1)))
    @end smallexample

    @ignore
      From before GNU Emacs 22
      @smallexample
        (defun beginning-of-buffer (&optional arg)
          "Mueve el punto al principio del buffer;
        deja la marca a la posición previa.
        Con el arg N, pon el punto N/10 del camino
        desde el comienzo real.@end group
        ¿No usar esto en programas Lisp!
        \(goto-char (point-min)) es rápido
        y no asigna la marca."
          (interactive "P")
          (push-mark)
          (goto-char
           (if arg
               (if (> (buffer-size) 10000)
                   ;; @r{¿Evita overflow para tamaños de búffer grandes!}
                   (* (prefix-numeric-value arg)
                      (/ (buffer-size) 10))
                 (/ (+ 10 (* (buffer-size)
                             (prefix-numeric-value arg)))
                    10))
             (point-min)))
          (if arg (forward-line 1)))
      @end smallexample
    @end ignore

    Excepto por dos pequeños puntos, la discusión previa muestra cómo esta
    función trabaja. El primer punto trata un detalle en la cadena de
    documentación, y el segundo concierne la última línea de la función.

    En la cadena de documentación, hay referencia a una expresión:

    @smallexample
      \\[universal-argument]
    @end smallexample

    Un @'{\\} es usado antes de la primera llave de esta expresión. Este
    @'{\\} le cuenta al intérprete Lisp sustituir qué clave está actualmente
    emparejada a los @'{[…]}. En el caso de @c{universal-argument}, que es
    normalmente @k{C-u}, pero eso podría ser diferente. (Véase Sección
    @l{Consejos de Documentación, , Consejos para Cadenas de Documentación,
    elisp, El Manual de Referencia de GNU Emacs Lisp}, para más información.)

    Finalmente, la última línea del comando @c{beginning-of-buffer} dice
    mover el punto al principio de la siguiente línea si el comando es
    invocado con un argumento:

    @smallexample
      (if arg (forward-line 1)))
    @end smallexample

    Esto pone el cursor al principio de la primera línea después de las
    apropiadas decenas de posiciones en el búffer. Esto significa que el
    cursor está siempre localizado @e{al menos} las decenas solicitadas del
    camino a través del búffer, que es un bien que es, quizás, no necesario,
    pero que, si no ocurrió, estaría seguro de dibujar rumores.

    Por otro lado, eso significa que si se especifica el comando con un
    @k{C-u}, sin un número, que es decir, si el ‘prefijo de argumento plano’
    es simplemente un cons cell, entonces el comando te pone al principio de
    la segunda línea … no sé si este se pretende ningún trato con el código
    para evitar que esto ocurre.

** @t(Revisar el segundo búffer relacionado, Revisar)

   Aquí hay un breve resumen de los asuntos cubierto en este capítulo.

   - or -:

     Evalúa cada argumento en secuencia, y devuelve el valor del primer
     argumento que no es @c{nil}, si ninguno devuelve un valor que no es
     @c{nil}, devuelve @c{nil}. En breve, devuelve el primer valor de verdad
     de los argumento; devuelve un valor cierto si un @e{or} cualquier de los
     otros son verdad.

   - and -:

     Evalúa cada argumento en secuencia, y si cualquiera es @c{nil}, devuelve
     @c{nil}; si ninguno es @c{nil}, devuelve el valor del último
     argumento. En breve, devuelve un valor cierto solo si todos los
     argumentos cierto; devuelve un valor cierto si un @e{and} cada uno de
     los otros son ciertos.

   - &optional -:

     Una palabra clave usaba para indicar que un argumento a una definición
     de función es opcional; esto significa que la función puede ser evaluado
     sin el argumento, si se desea.

   - prefix-numeric-value -:

     Convierte el ‘argumento prefijo plano’ producido por @c{(interactive
     "P")} a un valor numérico.

   - forward-line -:

     Mueve el punto hacia delante al principio de la siguiente línea, o si el
     argumento es más de uno, hacia delante varias líneas. Si eso no se puede
     mover tan lejos hacia delante como se puede, @c{forward-line} va hacia
     delante tan lejos como se puede y entonces devuelve un contaje del
     número de líneas adicionales que no pudo moverse.

   - erase-buffer -:

     Borra todos los contenidos del búffer actual.

   - bufferp -:

     Devuelve @c{t} si su argumento es un búffer; de otro modo devuelve
     @c{nil}.

** Ejercicio de argumento @c{opcional}

   Escribe una función interactiva con un argumento opcional que chequee si
   su argumento, un número, es mayor o igual, o al menos, menos que el valor
   de @c{fill-column}, y lo escribe, en un mensaje. Sin embargo, si no se
   pasa un argumento a la función, usa 56 como un valor por defecto.

* Encogiendo y extendiendo

  Encoger es una funcionalidad de Emacs que hace posible focalizar en una
  parte específica de un búffer, y funcionar sin cambiar accidentalmente
  otras partes. Encoger normalmente se deshabilita puesto que puede confundir
  a novatos.

  Con encoger, el resto del búffer se hace invisible, como si no
  estuviera. Esto es una ventaja si, por ejemplo, se quiere reemplazar una
  palabra en una parte del búffer pero no otro: se encoge la parte que se
  quiere y el reemplazo se trae solo en esta sección, no en el resto del
  búffer. Las búsquedas solo funcionarán con una región encogida, no fuera de
  una, así si tu estás arreglando una parte de un documento, se puede guardar
  en sí desde encontrar partes accidentalmente que no necesitas arreglar
  encongiendo solo la región que quieres. (La tecla asociada a
  @c{narrow-to-region} es @k{C-x n n}.)

  Sin embargo, encoger hace que el resto del búffer sea invisible, esto puede
  asustar a gente quien inadvertidamente invoca a encoger y pensar que se ha
  borrado una parte de su fichero. Más allá, el comando @c{undo} (que es
  normalmente emparejado a @k{C-x u}) no se deja encoger, así las personas
  pueden llegar a estar bastante desesperadas si no conocen que ellas pueden
  volver al resto de un búffer para visibilizarlo con el comando
  @c{widen}. (El emparejamiento de la tecla para @c{widen} es @k{C-x n w}.)

  Encoger es tan útil al intérprete Lisp como para las personas. Con
  frecuencia, una función Emacs Lisp está diseñada para trabajar en solo
  parte de un búffer; o de manera conversa, una función Emacs Lisp necesita
  trabajar en todo un búffer que ha sido encogido. La función @c{what-line},
  por ejemplo, borra el encogimiento desde un búffer, si eso tiene cualquier
  encogimiento y cuando eso ha finalizado su trabajo, restaura el
  encogimiento que haya. Por otro lado, la función @c{count-lines}, que es
  llamada por @c{what-line}, usa el encogimiento para restringirse a sí misma
  solo a la porción del búffer en el que se está interesado y entonces
  restaura la situación previa.

** La forma especial @c{save-restriction}

   En Emacs Lisp, se puede usar la forma especial @c{save-restriction} para
   guardar la traza siempre que el encogimiento esté en efecto. Cuando el
   intérprete Lisp se encuentra con @c{save-restriction}, eso ejecuta el
   código en el cuerpo de la expresión @c{save-restriction}, y entonces
   deshace cualquier cambio para encoger lo que el código causó. Si, por
   ejemplo, el búffer está encogido y el código que sigue al comando
   @c{save-restriction} devuelve el búffer para su región encogida. En el
   comando @c{what-line}, cualquier encogimiento del búffer que se puede
   tener se deshace por el comando @c{widen} que inmediatamente sigue el
   comando @c{save-restriction}. Cualquier encogimiento original es
   restaurado solo antes de la compleción de la función.

   La plantilla para una expresión @c{save-restriction} es simple:

   @smallexample
     (save-restriction
       @var{body}… )
   @end smallexample

   El cuerpo del @c{save-restriction} es una o más expresiones que serán
   evaluadas en secuencia por el intérprete Lisp.

   Finalmente, un punto a anotar: cuando se usa tanto @c{save-excursion} y
   @c{save-restriction}, uno correcto después del otro, deberías usar
   @c{save-excursion} fuera. Si se escribe en el orden inverso, se podría
   fallar para grabar el encogimiento en el búffer para el que Emacs cambia
   después de llamar a @c{save-excursion}. De este modo, cuando se escribe
   junto a @c{save-excursion} y @c{save-restriction} sería escrito así:

   @smallexample
     (save-excursion
       (save-restriction
         @var{body}…))
   @end smallexample

   En otras circunstancias, cuando no se escribe junto, las formas especiales
   @c{save-excursion} y @c{save-restriction} deben ser escritas en el orden
   apropiado para la función.

   Por ejemplo,

   @smallexample
     (save-restriction
       (widen)
       (save-excursion
       @var{body}…))
   @end smallexample

   @ignore
     Emacs 22
     /usr/local/src/emacs/lisp/simple.el

     (defun what-line ()
       "Print the current buffer line number and narrowed line number of point."
       (interactive)
       (let ((start (point-min))
             (n (line-number-at-pos)))
         (if (= start 1)
             (message "Line %d" n)
           (save-excursion
             (save-restriction
               (widen)
               (message "line %d (narrowed line %d)"
                        (+ n (line-number-at-pos start) -1) n))))))

     (defun line-number-at-pos (&optional pos)
       "Return (narrowed) buffer line number at position POS.
     If POS is nil, use current buffer location.
     Counting starts at (point-min), so the value refers
     to the contents of the accessible portion of the buffer."
       (let ((opoint (or pos (point))) start)
         (save-excursion
           (goto-char (point-min))
           (setq start (point))
           (goto-char opoint)
           (forward-line 0)
           (1+ (count-lines start (point))))))

     (defun count-lines (start end)
       "Return number of lines between START and END.
     This is usually the number of newlines between them,
     but can be one more if START is not equal to END
     and the greater of them is not at the start of a line."
       (save-excursion
         (save-restriction
           (narrow-to-region start end)
           (goto-char (point-min))
           (if (eq selective-display t)
               (save-match-data
                 (let ((done 0))
                   (while (re-search-forward "[\n\C-m]" nil t 40)
                     (setq done (+ 40 done)))
                   (while (re-search-forward "[\n\C-m]" nil t 1)
                     (setq done (+ 1 done)))
                   (goto-char (point-max))
                   (if (and (/= start end)
                            (not (bolp)))
                       (1+ done)
                     done)))
             (- (buffer-size) (forward-line (buffer-size)))))))
   @end ignore

** @c{what-line}

   El comando @c{what-line} cuenta el número de la línea en la que el cursor
   se ha localizado. La función ilustra el uso de los comandos
   @c{save-restriction} y @c{save-excursion}. Aquí está el texto original de
   la función:

   @smallexample
     (defun what-line ()
       "Imprime el número de línea actual (en el búffer)
       del punto."
       (interactive)
       (save-restriction
         (widen)
         (save-excursion
           (beginning-of-line)
           (message "Línea %d"
                    (1+ (count-lines 1 (point)))))))
   @end smallexample

   (En versiones recientes de GNU Emacs, la función @c{what-line} se ha
   expandido para contar el número de líneas en un búffer encogido tan bien
   como el número de líneas en un búffer ampliado. La versión reciente es más
   compleja que la versión que se muestra. Alguien sintiéndose venturoso,
   podría querer mirarla después de entender como esta versión
   funciona. Probablemente se necesitará usar @k{C-h f}
   (@c{describe-function}). La versión nueva usa un condicional para
   determinar si el búffer se ha encogido.

   (También, eso usa @c{line-number-at-pos}, que otras expresiones simples,
   tales como @c{(goto-char (point-min))}, mueve el punto al principio de la
   línea actual con @c{(forward-line 0)} en vez de @c{beginning-of-line}.)

   La función @c{what-line} como se muestra aquí tiene una línea de
   documentación y es interactiva, como se esperaría. Las dos líneas
   siguientes usan las funciones @c{save-restriction} y @c{widen}.

   La forma especial @c{save-restriction} nota que encogiendo es en efecto,
   si cualquiera, en el buffer actual y restaura que encogiendo después del
   código en el cuerpo del @c{save-restriction} ha sido evaluada.

   La forma especial @c{save-restriction} es seguida por @c{widen}. Esta
   función deshace cualquier distancia del actual búffer que puede haber
   tenido cuando @c{what-line} se llame. (La distancia que había es la
   distancia que @c{save-restriction} recuerda.) Esta ampliación se hace
   posible para la línea contando comandos a contar desde el principio del
   búffer. De otro modo, se habría limitado para contar con la región
   accesible. Cualquier distancia original se restaura solo antes de la
   compleción de la función por la forma especial @c{save-restriction}.

   La llamada a @c{widen} es seguida por @c{save-excursion}, que guarda la
   posición del cursor (por ej., el punto) y de la marca, y la restaura
   después el código en el cuerpo del @c{save-excursion} usa la función
   @c{beginning-of-line} para mover el punto.

   (Nótese que la expresión @c{(widen)} viene entre las formas especiales
   @c{save-restriction} y @c{save-excursion}. Cuando se escribe las dos
   expresiones @c{save- …} en secuencia, escribe @c{save-excursion}
   finalmente.)

   Las últimas dos líneas de la función @c{what-line} son funciones para
   contar el número de líneas en el búffer y entonces imprimir el número en
   el área echo.

   @smallexample
     (message "Line %d"
              (1+ (count-lines 1 (point)))))))
   @end smallexample

   La función @c{message} imprime un mensaje de una línea abajo de la
   pantalla Emacs. El primer argumento está dentro de marcas de cita y está
   impreso como una cadena de caracteres. Sin embargo, se puede contener una
   expresión @'{%d} para imprimir un argumento siguiente. @'{%d} imprime el
   argumento como un decimal, así el mensaje dirá alguna cosa tal como
   @'{Línea 243}.

   El número que está impreso en lugar de @'{%d} está computada por la última
   línea de la función:

   @smallexample
     (1+ (count-lines 1 (point)))
   @end smallexample

   @ignore
     GNU Emacs 22

     (defun count-lines (start end)
       "Return number of lines between START and END.
     This is usually the number of newlines between them,
     but can be one more if START is not equal to END
     and the greater of them is not at the start of a line."
       (save-excursion
         (save-restriction
           (narrow-to-region start end)
           (goto-char (point-min))
           (if (eq selective-display t)
               (save-match-data
                 (let ((done 0))
                   (while (re-search-forward "[\n\C-m]" nil t 40)
                     (setq done (+ 40 done)))
                   (while (re-search-forward "[\n\C-m]" nil t 1)
                     (setq done (+ 1 done)))
                   (goto-char (point-max))
                   (if (and (/= start end)
                            (not (bolp)))
                       (1+ done)
                     done)))
             (- (buffer-size) (forward-line (buffer-size)))))))
   @end ignore

   Lo que esto hace es contar las líneas entre la primera posición del búffer
   indicada por el @c{1}, y el @c{(point)}, y entonces se añade uno a este
   número. (La función @c{1+} añade uno a su argumento.) Se añade a eso
   porque la línea 2 tiene solo una línea antes, y @c{count-lines} cuenta
   solo las líneas @e{antes} de la línea actual.

   Después de que @c{count-lines} ha hecho su trabajo, y el mensaje ha sido
   impreso en el área echo, la función @c{save-excursion} restaura punto y
   marca a sus posiciones originales; y @c{save-restriction} restaura la
   contracción original, si la hay.

** Ejercicio de encoger

   Escribe una función que mostrará los primeros 60 caracteres del búffer
   actual, incluso si se ha encogido el búffer a su mitad así que la primera
   línea es inaccesible. Restaura punto, marca y encogimiento. Para este
   ejercicio, se necesita usa un popurri entero de funciones, incluyendo
   @c{save-restriction}, @c{widen}, @c{goto-char}, @c{point-min},
   @c{message}, y @c{buffer-substring}.

   (@c{buffer-substring} es una función previamente no mencionada que tendrá
   que investigarla cada cual por uno mismo; o quizás tendrá que usarse
   @c{buffer-substring-no-properties} o @c{filter-buffer-substring} …, o
   todavía otras funciones. Las propiedades de texto son una funcionalidad
   que de otro modo no serían discutidas aquí.  Véase Sección "Propiedades de
   Texto" en @e(El Manual de Referencia de Emacs Lisp).)

   Además, ¿realmente se necesita @c{goto-char} o @c{point-min}?  ¿O se puede
   escribir la función sin ellos?

* @c{car}, @c{cdr}, @c{cons}: Funciones fundamentales

  En Lisp, @c{car}, @c{cdr}, y @c{cons} son funciones fundamentales. La
  función @c{cons} es usada para construir listas, y las funciones @c{car} y
  @c{cdr} son usadas para tomarlas aparte.

  En el paseo guiado a través de la función @c{copy-region-as-kill}, se verá
  @c{cons} tan bien como dos variantes de @c{cdr}, llamadas @c{setcdr} y
  @c{nthcdr}. (Véase Sección @l{copy-region-as-kill}.)

  El nombre de la función @c{cons} es razonable: es una abreviación de la
  palabra ‘constructo’. Los orígenes de los nombres @c{car} y @c{cdr}, por
  otro lado, son esotéricos: @c{car} es un acrónimo de la frase ‘Contenidos
  de la parte de la Dirección del Registro’; y @c{cdr} (pronunciado
  ‘could-er’) es un acrónimo de la frase ‘Contenidos del Decremento del
  Registro’. Estas frases se refieren a piezas específicas de hardware en el
  ordenador en el que el Lisp original fué desarrollado. El resto de frases
  han sido completamente irrelevantes por más de 25 años a cualquiera
  pensando acerca de Lisp. Ninguno, excepto unos pocos académicos valientes
  han empezado a usar nombres más razonables para estas funciones, los viejos
  términos están todavía en uso. En particular, los términos usados en el
  código fuente Emacs Lisp, que usaremos en esta introducción.

** @c{car} y @c{cdr}

   El @Cc{car} de una lista es, bastante simple, el primer ítem en la
   lista. De este modo, el @Cc{car} de la lista @c{(rosa violeta margarita
   botóndeoro)} es @c{rosa}.

   Si está leyendo en Info y en GNU Emacs, se puede ver esto evaluando lo
   siguiente:

   @smallexample
     (car '(rosa violeta margarita botóndeoro))
   @end smallexample

   Después de evaluar la expresión, @c{rosa} aparecerá en el área echo.

   Claramente, un nombre más razonable para la función @c{car} sería
   @c{first} y esto es con frecuencia lo que se sugiere.

   @c{car} no elimina el primer ítem de la lista; solo se informa de lo que
   hay. Después de que @c{car} se haya aplicado a una lista, la lista es
   todavía la misma que era. En la jerga, @c{car} es ‘no-destructiva’. Esta
   funcionalidad deja de ser importante.

   El @Cc{cdr} de una lista es el resto de la lista, que es, la función
   @c{cdr} que devuelve la parte de la lista que sigue el primer ítem. De
   este modo, mientras el @Cc{car} de la lista @c{'(rosa violeta margarita
   botóndeoro)} es @c{rosa}, el resto de la lista, el valor devuelto por la
   función @c{cdr}, es @c{(violeta margarita botóndeoro)}.

   Se puede ver esto evaluando lo siguiente del modo usual:

   @smallexample
     (cdr '(rosa violeta margarita botóndeoro))
   @end smallexample

   Cuando se evalúa esto, @c{(violeta margarita botóndeoro)} aparecerá en el
   área echo.

   Al igual que @c{car}, @c{cdr} no elimina los elementos desde la
   lista––solo devuelve un informe de lo que el segundo y subsiguientes
   elementos son.

   En el ejemplo, la lista de flores se cita. Si no, el intérprete Lisp
   intentaría evaluar la lista llamando a @c{rosa} como una función. En este
   ejemplo, no queremos hacer esto.

   Claramente, un nombre más razonable para @c{cdr} sería @c{rest}.

   (Hay una lección aquí: cuando se nombran nuevas funciones, considere muy
   cuidadosamente lo que se está haciendo, ya que puede estar pegadas con los
   nombres largos que se esperan. La razón es que este documento perpetúa
   estos nombres que el código fuente de Emacs Lisp usa, y si no los usaba,
   se estaría un duro rato leyendo el código; pero, por favor, se debe
   intentar evitar usar estos términos por uno mismo. Las personas que vengan
   después se lo agradecerán.

   Cuando @c{car} y @c{cdr} se aplica a una lista hecha de símbolos, tal como
   la lista @c{(pino roble abeto arce)}, el elemento de la lista devuelta por
   la función @c{car} es el símbolo @c{pino} sin cualquier paréntesis
   alrededor. @c{pino} es el primer elemento en la lista. Sin embargo, el
   @Cc{cdr} de la lista es una lista por sí misma, @c{(roble abeto arce)},
   como se puede ver evaluando las siguientes expresiones en el modo usual:

   @smallexample
     (car '(pino roble abeto arce))

     (cdr '(pino roble abeto arce))
   @end smallexample

   Por otro lado, en una lista de listas, el primer elemento es en sí mismo
   una lista. @c{char} devuelve este primer elemento como una lista. Por
   ejemplo, la siguiente lista contiene tres sublistas, una lista de
   carnívoros, una lista de herbívoros y una lista de mamíferos:

   @smallexample
     (car '((leon tigre leopardo)
            (gacela antilope cebra)
            (ballena delfin foca)))
   @end smallexample

   En este ejemplo, el primer elemento de @Cc{car} de la lista es la lista de
   carnívoros, @c{(leon tigre leopardo)}, y el resto de la lista es
   @c{((gacela antilope cebra) (ballena delfin foca))}.

   @smallexample
     (cdr '((leon tigre leopardo)
            (gacela antilope cebra)
            (ballena delfin)))
   @end smallexample

   Es un valor decir de nuevo que @c{car} y @c{cdr} son no destructivos––esto
   es, no se modifican o cambian listas para las que ser aplicados. Esto es
   muy importante por cómo son usados.

   También, en el primer capítulo, en la discusión acerca de átomos, yo dije
   que en Lisp, “ciertos tipos de átomos, tales como un array, pueden
   separarse en partes; pero el mecanismo de hacer esto es diferente del
   mecanismo de separar una lista. Desde que Lisp se conoce, los átomos de
   una lista son indivisibles.”  (Véase Sección @l{Átomos Lisp}.) El @c{car}
   y el @c{cdr} son funciones que son usadas para dividir listas y son
   consideradas fundamentales para Lisp. Puesto que no pueden dividir o ganar
   acceso a las partes de un array, un array es considerado un átomo. De otro
   modo, la otra función fundamental, @c{cons}, se puede poner cerca o
   construir una lista, pero no un array. (Los arrays son manejados por
   funciones de array específicas. Véase Sección @l{Arrays, , Arrays, elisp,
   El Manual de Referencia de GNU Emacs Lisp}.)

** @c{cons}

   La función @c{cons} construye listas; eso es lo inverso de @c{car} y
   @c{cdr}. Por ejemplo, @c{cons} puede usarse para crear una lista de cuatro
   elementos desde los tres elementos de la lista, @c{(abeto roble arce)}:

   @smallexample
     (cons 'pino '(abeto roble arce))
   @end smallexample

   Después de evaluar esto, se verá lo siguiente:

   @smallexample
     (pino abeto roble arce)
   @end smallexample

   aparece en el área echo. @c{cons} causa la creación de una nueva lista en
   el que el elemento es seguido por los elementos de la lista original.

   Con frecuencia decimos que ‘@c{cons} pone un nuevo elemento al principio
   de una lista; adjunta o empuja el elemento dentro de la lista’, pero esta
   frase puede ser incorrecta, puesto que @c{cons} no cambia a una lista
   existente, pero crea una nueva.

   Como @c{car} y @c{cdr}, @c{cons} es no destructivo.

   @c{cons} debe tener una lista para adjuntar a@n{8} No se puede empezar
   desde absolutamente nada. Si se está construyendo una lista, se necesita
   proveer al menos una lista vacía al principio. Aquí hay una serie de
   expresiones @c{cons} que construyen una lista de flores. Si está leyendo
   esto en Info en GNU Emacs, se puede evaluar cada una de las expresiones en
   el camino usual; el valor es impreso en este texto después de @'{⇒}, que
   puede leer como ‘evalúas para’.

   @smallexample
     (cons 'botóndeoro ())
          ⇒ (botóndeoro)

     (cons 'margarita '(botóndeoro))
          ⇒ (margarita botóndeoro)

     (cons 'violeta '(margarita botóndeoro))
          ⇒ (violeta margarita botóndeoro)

     (cons 'rosa '(violeta margarita botóndeoro))
          ⇒ (rosa violeta margarita botóndeoro)
   @end smallexample

   En el primer ejemplo, la lista vacía se muestra como @c{()} y después se
   construye una lista de @c{botóndeoro} seguida por la lista vacía. Como se
   puede ver, la lista vacía no se muestra en la lista que fué
   construida. Todo lo que se ve es @c{(botóndeoro)}. La lista vacía no
   cuenta como un elemento de una lista porque no hay nada en una lista
   vacía. Generalmente hablando, una lista vacía es invisible.

   El segundo ejemplo, @c{(cons 'margarita '(botóndeoro))} construye una
   nueva lista de dos elemento poniendo @c{margarita} en frente de
   @c{botóndeoro}; y el tercer ejemplo construye una lista de tres elementos
   poniendo @c{violeta} en frente de @c{margarita} y @c{botóndeoro}.

*** Encuentra el tamaño de una lista: @c{length}

    Se pueden encontrar cuántos elementos hay en una lista usando la función
    Lisp @c{length}, como en los siguientes ejemplos:

    @smallexample
      (length '(botóndeoro))
           ⇒ 1

      (length '(margarita botóndeoro))
           ⇒ 2

      (length (cons 'violeta '(margarita botóndeoro)))
           ⇒ 3
    @end smallexample

    En el tercer ejemplo, la función @c{cons} es usada para construir una
    lista de tres elementos que entonces se pasa a la función @c{length} como
    su argumento.

    Se puede también usar @c{length} para contar el número de elementos en
    una lista vacía:

    @smallexample
      (length ())
           ⇒ 0
    @end smallexample

    Como se esperaría, el número de elementos en una lista vacía es cero.

    Un experimento interesante es encontrar qué ocurre si se intenta
    encontrar el tamaño de una no lista en todo; que es, si se intenta llamar
    a @c{length} sin darle un argumento, incluso una lista no vacía:

    @smallexample
      (length )
    @end smallexample

    Lo que se ve, si se evalúa esto, es el mensaje de error

    @smallexample
      Lisp error: (wrong-number-of-arguments length 0)
    @end smallexample

    Esto significa que la función recibe el número incorrecto de argumentos,
    cero, cuando se espera algún otro número de argumentos. En este caso, se
    espera un argumento, el argumento de una lista cuyo tamaño de la función
    se está midiendo. (Nótese que @e{una} lista es @e{un} argumento, incluso
    si la lista tiene muchos elementos dentro.)

    La parte del mensaje de error que dice @'{length} es el nombre de la
    función.

    @ignore
      @c{length} is still a subroutine, but you need C-h f to discover that.

      In an earlier version:
          This is written with a special notation, @'{#<subr},
          that indicates that the function @c{length} is one of the primitive
          functions written in C rather than in Emacs Lisp.  (@'{subr} is an
          abbreviation for ‘subroutine’.)  Véase Sección @l{What Is a Function, , What Is a
          Function?, elisp , The GNU Emacs Lisp Reference Manual}, for more
          about subroutines.
    @end ignore

** @c{nthcdr}

   La función @c{nthcdr} está asociada con la función @c{cdr}. Que lo que
   hace es tomar la @Cc{cdr} de una lista repetidamente.

   Si se toma el @Cc{cdr} de la lista @c{(pino roble abeto arce)}, será
   devuelta la lista @c{(roble abeto arce)}. Si se repite esto en lo que se
   devolvió, se devolverá lista lista @c{(abeto arce)}. (De acuerdo, se
   repite @Cc{cdr} en la lista original solo se dará @Cc{cdr} desde la
   función que no cambia la lista. Se necesita evaluar el @Cc{cdr} del
   @Cc{cdr} y así.) Si se contiúa esto, finalmente será devuelta una lista
   vacía, que en este caso, en vez de ser mostrada como @c{()} es mostrado
   como @c{nil}.

   Para revisar, aquí hay una serie de @Cc{cdr}s repetidos, el siguiente
   @'{⇒} muestra lo que se devuelve.

   @smallexample
     (cdr '(pino roble abeto arce))
          ⇒(roble abeto arce)

     (cdr '(roble abeto arce))
          ⇒ (abeto arce)

     (cdr '(abeto arce))
          ⇒(arce)

     (cdr '(arce))
          ⇒ nil

     (cdr 'nil)
          ⇒ nil

     (cdr ())
          ⇒ nil
   @end smallexample

   También se pueden hacer varios @Cc{cdr}s sin imprimir los valores así:

   @smallexample
     (cdr (cdr '(pino roble abeto arce)))
          ⇒ (abeto arce)
   @end smallexample

   En este ejemplo, el intérprete Lisp evalúa la lista propia dentro. La
   lista de dentro está entre comillas, así solo pasa la lista del @c{cdr}
   más interno. Este @c{cdr} pasa una lista hecho del segundo y subsiguientes
   elementos de la lista al @c{cdr} más externo, que produce una lista
   compuesta del tercer y subsiguientes elementos de la lista original. En
   este ejemplo, la función @c{cdr} se repite y devuelve una lista que
   consiste de la lista original sin sus primeros dos elementos.

   La función @c{nthcdr} hace lo mismo que repitiendo la llamada a
   @c{cdr}. En el siguiente ejemplo, el segundo argumento se pasa a la
   función @c{nthcdr}, a través con la lista, y el valor devuelto es la lista
   sin sus primeros dos ítems, que son exactamente los mismos dos @c{cdr} en
   la lista:

   @smallexample
     (nthcdr 2 '(pino roble abeto arce))
          ⇒ (abeto arce)
   @end smallexample

   Usando la lista original de cuatro elementos, se puede ver qué ocurre
   cuando varios argumentos numéricos son pasados a @c{nthcdr}, incluyendo 0,
   1, y 5:

   @smallexample
     ;; @r{Deja la lista como estaba.}
     (nthcdr 0 '(pine fir oak maple))
          ⇒ (pino roble abeto arce)

     ;; @r{Devuelve una copia sin el primer elemento.}
     (nthcdr 1 '(pine fir oak maple))
          ⇒ (fir oak maple)

     ;; @r{Devuelve una copia de la lista sin tres elementos.}
     (nthcdr 3 '(pine fir oak maple))
          ⇒ (maple)

     ;; @r{Devuelve la lista faltando los cuatro elementos.}
     (nthcdr 4 '(pine fir oak maple))
          ⇒ nil

     ;; @r{Devuelve una copia sin los elementos.}
     (nthcdr 5 '(pine fir oak maple))
          ⇒ nil
   @end smallexample

** @c{nth}

   La función @c{nthcdr} toma el @Cc{cdr} de una lista repetidamente. La
   función @c{nth} toma el @Cc{car} del resultado devuelto por
   @c{nthcdr}. Devuelve el elemento Nth de la lista.

   De este modo, si no fuera definido en C para velocidad, la definición de
   @c{nth} sería:

   @smallexample
     (defun nth (n list)
       "Devuelve el elemento Nth de Lista.
     N cuenta desde cero. Si Lista no es larga, nil es devuelto".
       (car (nthcdr n list)))
   @end smallexample

   (Originalmente, @c{nth} fué definido en Emacs Lisp en @f{subr.el}, pero su
   definición fué rehecha en C en los 1980s.)

   La función @c{nth} devuelve un elemento simple de una lista. Esto puede
   ser muy conveniente.

   Nótese que los elementos son numerados desde cero, no desde uno. Es decir,
   el primer elemento de una lista, su @Cc{car} es el elemento cero. Esto se
   llama contar en ‘base cero’ y con frecuencia las personas tienen la
   costumbre del que el primer elemento en una lista sea el número uno, eso
   es ‘basado en uno’.

   Por ejemplo:

   @smallexample
     (nth 0 '("uno" "dos" "tres"))
         ⇒ "uno"

     (nth 1 '("uno" "dos" "tres"))
         ⇒ "dos"
   @end smallexample

   Es valorable mencionar que @c{nth}, como @c{nthcdr} y @c{cdr}, no cambia
   la lista original––la función no es destructiva. En contraste con las
   funciones @c{setcar} y @c{setcdr}.

** @c{setcar}

   Como se podría adivinar desde sus nombres, las funciones @c{setcar} y
   @c{setcdr} asignan el @Cc{car} o la @Cc{cdr} de una lista a un nuevo
   valor. Ellos actualmente cambia la lista original, no como @c{car} y
   @c{cdr} que deja la lista original como estaba. Un camino para encontrar
   cómo esto funciona es experimentar. Se comenzará con la función
   @c{setcar}.

   Primero, podemos crear una lista y entonces asignar el valor de una
   variable a la lista usando la función @c{setq}. Aquí hay una lista de
   animales:

   @smallexample
     (setq animales '(antilope jirafa leon tigre))
   @end smallexample

   Si está leyendo esto en Info dentro de GNU Emacs, se puede evaluar esta
   expresión del modo usual, posicionando el cursor después de la expresión y
   escribiendo @k{C-x C-e}. Esto es una de las ventajas de tener el
   intérprete construido dentro del entorno de computación. Incidentalmente,
   cuando no hay nada en la línea después del paréntesis final, tal como un
   comentario, el punto puede estar en la siguiente línea. De este modo, si
   tu cursor está en la primera columna de la siguiente línea, no se necesita
   mover. En realidad, Emacs permite cualquier cantidad de espacio en blanco
   después del paréntesis final.)

   Cuando se evalúa la variable @c{animal}, vemos que está asociada a la
   lista @c{(antelope giraffer lion tiger)}:

   @smallexample
     animales
          ⇒ (antilope jirafa leon tigre)
   @end smallexample

   Por otro lado, la variable @c{animales} apunta a la lista @c{(antilope
   jirafa leon tigre)}.

   Lo siguiente, es evaluar la función @c{setcar} mientras le pasa dos
   argumentos, la variable @c{animales} y el símbolo citado @c{hipopotamo};
   esto se hace escribiendo la lista de tres elementos @c{(setcar animales
   'hipopotamo)} y entonces evaluando en el modo usual:

   @smallexample
     (setcar animales 'hipopotamo)
   @end smallexample

   Después de evaluar esta expresión, evalúa la variable @c{animales} de
   nuevo. Se puede ver que la lista de animales ha cambiado:

   @smallexample
     animales
          ⇒ (hipopótamo jirafa leon tigre)
   @end smallexample

   El primer elemento en la lista, @c{antilope} se reemplaza por
   @c{hipopotamo}.

   Así se puede ver que @c{setcar} no añadió un nuevo elemento a la lista
   como @c{cons} tendría; eso reemplazó @c{antílope} con @c{hipopótamo}; eso
   @e{cambió} la lista.

** @c{setcdr}

   La función @c{setcdr} es similar a la función @c{setcar}, excepto que la
   función reemplaza el segundo y subsiguientes elementos de una lista en vez
   del primer elemento.

   (Para ver cómo se cambia el último elemento de una lista, mira hacia
   delante a la @l{La función @c{kill-new}}, que usa las funciones @c{nthcdr}
   y @c{setcdr}.)

   Para ver cómo esto funciona, asigna el valor de la variable a una lista de
   animales domesticados evaluando la siguiente expresión:

   @smallexample
     (setq animales-domesticos '(caballo vaca oveja cabra))
   @end smallexample

   Si ahora se evalúa la lista, lo que se devuelve es @c{(caballo vaca oveja
   cabra)}:

   @smallexample
     animales-domesticos
          ⇒ (caballo vaca oveja cabra)
   @end smallexample

   Lo siguiente, evalúa @c{setcdr} con dos argumentos, el nombre de la
   variable que tiene una lista como su valor, y la lista para la que el
   @Cc{cdr} de la primera lista sea asignada;

   @smallexample
     (setcdr animales-domesticos '(gato perro))
   @end smallexample

   Si se evalúa esta expresión, la lista @c{(gato perro)} aparecerá en el
   área echo. Este es el valor devuelto por la función. El resultado en el
   que estamos interesados es el “efecto lateral”, que se puede ver evaluando
   la variable @c{domesticated-animals}:

   @smallexample
     animales-domesticos
          ⇒ (caballo gato perro)
   @end smallexample

   En realidad, la lista es cambiada desde @c{(caballo vaca oveja cabra)} a
   @c{(caballo gato perro)}. El @Cc{cdr} de la lista es cambiada desde
   @c{(vaca oveja cabra)} a @c{(gato perro)}.

** Ejercicio

   Construye una lista de cuatro pájaros evaluando varias expresiones con
   @c{cons}. Encuentra que ocurre cuando @c{cons} una lista dentro de
   sí. Reemplaza el primer elemento de la lista de cuatro pájaros con un
   pez. Reemplaza el resto de esta lista con una lista de otro pez.

* Cortando y almacenando texto

  Siempre y cuando se corte o pegue texto de un búffer con un comando ‘kill’
  en GNU Emacs, se almacenará dentro de una lista que se puede traer con un
  comando ‘yank’.

  (El uso de la palabra ‘kill’ @e{matar, cortar} en Emacs para procesos que
  específicamente @e{no} destruyen los valores de las entidades es un
  accidente histórico desafortunado. Una palabra mucho más apropiada debería
  ser ‘clip’ @e{cortar} puesto que es lo que los comandos de corte hacen;
  ellos cortan texto fuera de un búffer y lo ponen dentro del almacenamiento
  desde el que puede traerse. Con frecuencia ha sido tentada de reemplazar
  globalmente todas las ocurrencia de ‘kill’ @e{matar, cortar} en las fuentes
  de Emacs con ‘clip’ @e{cortar} y todas las ocurrencias de ‘killed’
  @e{cortado, muerto} con ‘clipped’ @e{cortado}.)

  Cuando el texto se corta de un búffer, es almacenado en una lista. Piezas
  sucesivas de texto se almacenan en la lista sucesivamente, así la lista
  podría verse así:

  @smallexample
    ("una pieza de texto" "pieza previa")
  @end smallexample

  La función @c{cons} puede usarse para crear una nueva lista desde una pieza
  de texto (un ‘átomo’, para usar la jerga) y una lista existente, como esta:

  @smallexample
    (cons "otra pieza"
          '("una pieza de texto" "pieza previa"))
  @end smallexample

  Si se evalúa esta expresión, una lista de tres elementos aparecerá en el
  área echo:

  @smallexample
    ("otra pieza" "una pieza de texto" "pieza previa")
  @end smallexample

  Con las funciones @c{car} y @c{nthcdr}, se puede recuperar siempre la pieza
  de texto que se quiere. Por ejemplo, en el siguiente código, @c{nthcdr 1 …}
  devuelve la lista con el primer ítem eliminado; y el @c{car} devuelve el
  primer elemento de este resto––el segundo elemento de la lista original:

  @smallexample
    (car (nthcdr 1 '("otra pieza"
                     "una pieza de texto"
                     "pieza previa")))
         ⇒ "una pieza de texto"
  @end smallexample

  Las funciones actuales en Emacs son más complejas que esto, de acuerdo. El
  código para cortar y recuperar texto tiene que ser escrito de modo que
  Emacs pueda ver qué elemento en la lista se quiere––el primer, segundo,
  tercer o cualquier otro. Además, cuando tiene el fin de la lista, Emacs
  daría el primer elemento de la lista, en lugar de nada.

  La lista que maneja las piezas de texto se llama @:{kill ring} (anillo de
  la muerte). Este capítulo lidera una descripción del anillo de la muerte y
  como eso se usa por la primera traza de cómo la función @c{zap-to-char}
  funciona. Esta función usa (o ‘llama’) a una función que invoca a otra
  función que manipula el anillo de la muerte. De este modo, antes de lograr
  las montañas, se escalan las colinas.

  Un capítulo subsiguiente describe cómo el texto que se corta desde el
  búffer se recupera. Véase Sección @l{Pegando, , Pegando Texto}.

** @c{zap-to-char}

   La función @c{zap-to-char} cambió poco entre GNU Emacs versión 19 y GNU
   Emacs versión 22. Sin embargo, @c{zap-to-char} llama a otra función,
   @c{kill-region}, que se reescribió más.

   La función @c{kill-region} en Emacs 19 es compleja, pero no usa código que
   es importante en este momento. Se obviará.

   La función @c{kill-region} en Emacs 22 es más de fácil leer que la misma
   función en Emacs 19 e introduce un concepto muy importante, que el error
   maneja. Nosotros pasearemos a través de la función.

   Pero primero, déjanos ver en la función interactive @c{zap-to-char}.

   La función @c{zap-to-char} elimina el texto en la región entre la
   localización del curso (por ej. punto) para incluir la siguiente
   ocurrencia de un caracter específico. El texto que @c{zap-to-char} borra
   es puesto en el kill ring @e{anillo de la muerte}; y puede ser recuperado
   desde el kill ring @e{anillo de la muerte} escribiendo @k{C-y}
   (@c{yank}). Si el comando dado es un argumento, eso borra texto a través
   de este número de ocurrencias. De este modo, si el cursor estuviera al
   principio de esta frase y el carácter fuera @'{s}, @'{De este modo} sería
   borrado. Si el argumento fueran dos, @'{De este modo, si el cursor} se
   borrase, y incluiría la @'{s} en el @'{cursor}.

   Si el carácter específico no encuentra @c{zap-to-char} dirá “Búsqueda
   fallida”, eso cuenta el carácter que se escribió, y no eliminó cualquier
   texto.

   En orden para determinar cuánto texto eliminar @c{zap-to-char} usa una
   función de búsqueda. Las búsquedas son usadas extensivamente en el código
   que manipula texto, y focalizará la atención en ellos tan bien como el
   comando de borrado.

   @ignore
     @c GNU Emacs version 19
     (defun zap-to-char (arg char)  ; version 19 implementation
       "Kill up to and including ARG'th occurrence of CHAR.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "*p\ncZap to char: ")
       (kill-region (point)
                    (progn
                      (search-forward
                       (char-to-string char) nil nil arg)
                      (point))))
   @end ignore

   Aquí está el texto completo de la versión 22 de la función:

   @smallexample
     (defun zap-to-char (arg char)
       "Corta e incluye ARG'th ocurrencia de CHAR
     En caso de ser ignorada si `case-fold-search' es no nulo en el
       búffer actual.
     Para ir atrás si ARG es negativo; error si CHAR no se encuentra."
       (interactive "p\ncZap to char: ")
       (if (char-table-p translation-table-for-input)
           (setq char (or (aref translation-table-for-input char) char)))
       (kill-region (point) (progn
                              (search-forward (char-to-string char)
                                              nil nil arg)
                              (point))))
   @end smallexample

   La documentación es en línea. Se necesita conocer el significado de la
   jerga de la palabra ‘kill’.

*** La expresión @c{interactive}

    La expresión interactiva en el comando @c{zap-to-char} se ve así:

    @smallexample
      (interactive "p\ncZap to char: ")
    @end smallexample

    La parte con comillas, @c{"p\ncZap to char:@: "} @e{Cortar a caracter},
    especifica dos cosas diferentes. Primero, y más simple es el @'{p}. Este
    parte se separa desde la siguiente parte por una nueva línea, @'{\n}. El
    @'{p} significa que la parte del primero argumento a la función será
    pasando el valor de un ‘prefijo procesado’. El argumento prefijo es
    pasado escribiendo @k{C-u} y un número, o @k{M-} y un número. Si la
    función es llamada interactivamente sin un prefijo, el número que se pasa
    es 1.

    La segunda parte de @c{"p\ncZap a caracter:@: "} es @'{cZap a
    carácter:@:}. En esta parte, la tecla baja @'{c} indica que
    @c{interactive} espera una consola que el argumento será un caracter. La
    consola sigue el @'{c} y es la cadena @'{Zap a caracter:@: } (con un
    espacio después del punto y coma para hacerlo bien).

    Todo lo que se hace es preparar los argumentos para @c{zap-to-char} así
    están en el tipo correcto, y dan al usuario un prompt.

    En un búffer de solo lectura, la función @c{zap-to-char} copia el texto
    al anillo de la muerte, no se elimina. El área echo muestra un mensaje
    diciendo que el búffer es de solo lectura. También, la terminal avisa con
    un pitido.

*** El cuerpo de @c{zap-to-char}

    El cuerpo de la función @c{zap-to-char} contiene el código que mata (que
    se borra/corta) el texto en la región desde la posición actual del cursor
    e incluyendo el carácter especificado.

    La primera parte del código se ve como:

    @smallexample
      (if (char-table-p translation-table-for-input)
          (setq char (or (aref translation-table-for-input char) char)))
      (kill-region (point) (progn
                             (search-forward (char-to-string char) nil nil arg)
                             (point)))
    @end smallexample

    @c{char-table-p} es una función prescrita no vista. Eso determina si sus
    argumentos son una tabla de caracteres. Así, se asigna el carácter pasado
    a @c{zap-to-char} a uno de ellos, si este carácter existe, o al carácter
    en sí. (Esto llega a ser importante para ciertos caracteres en lenguajes
    no Europeos. La función @c{aref} extrae un elemento desde un array. Eso
    es una función específica de array que no está descrita en este
    documento. Véase Sección @l{Array, , Arrays, elisp, El Manual de
    Referencia de GNU Emacs Lisp}.)

    Lo que devuelve @c{(point)} es la posición actual del cursor.

    La siguiente parte del código es una expresión usando @c{progn}. El
    cuerpo del @c{progn} se basa en llamadas a @c{search-forward} y
    @c{point}.

    Es fácil comprender cómo @c{progn} funciona después de aprender acerca de
    @c{search-forward}, así se verá en @c{search-forward} y entonces en
    @c{progn}.

*** La función @c{search-forward}

    La función @c{search-forward} se usa para localizar el
    zapped-for-character en @c{zap-to-char}. Si la búsqueda es exitosa,
    @c{search-forward} deja el punto inmediatamente después del último
    carácter en la cadena objetivo. (En @c{zap-to-char}, la cadena objetivo
    es solo un carácter largo. @c{zap-to-char} usa la función
    @c{char-to-string} para asegurar que el ordenador trata este carácter
    como una cadena). Si la búsqueda es hacia atrás, @c{search-forward} deja
    el punto solo antes del primer carácter en el objetivo. También,
    @c{search-forward} devuelve @c{t} para verdad. (Moviendo el punto allí es
    un ‘efecto lateral’.)

    En @c{zap-to-char}, la función @c{search-forward} se ve así:

    @smallexample
      (search-forward (char-to-string char) nil nil arg)
    @end smallexample

    La función @c{search-forward} toma cuatro argumentos:

    1. El primer argumento es el objetivo, para el que es buscado. Esto debe
       ser una cadena, tal como @'{"z"}.

       Cuando eso ocurre, el argumento pasado a @c{zap-to-char} es un
       caracter simple. Debido a la forma en la que los ordenadores son
       construidos, el intérprete Lisp puede tratar un caracter simple siendo
       diferente desde una cadena de caracteres. Dentro del ordenador, un
       caracter simple tiene un formato electrónico en vez de una cadena de
       un caracter. (Un caracter simple puede con frecuencia ser grabado en
       el ordenador usando exactamente un byte; pero una cadena puede ser
       larga, y el ordenador necesita estar listo para esto.) Desde que la
       función @c{search-forward} busca una cadena, el caracter que la
       función @c{zap-to-char} recibe como argumento debe ser convertida
       dentro del ordenador de un formato a otro; de otro modo, la función
       @c{search-forward} fallará. La función @c{char-to-string} es usada
       para hacer esta conversión.

    2. El segundo argumento asocia la búsqueda; eso se especifica como una
       posición en el búffer. En este caso, la búsqueda puede ir al final del
       búffer, así no se asigna y el segundo argumento es @c{nil}.

    3. El tercer argumento cuenta la función que haría si la búsqueda
       cae––eso puede señalar un error (e imprimir un mensaje) o puede
       devolver @c{nil}. Un @c{nil} como tercer argumento hace que la función
       señale un error cuando la búsqueda falla.

    4. El cuarto argumento @c{search-forward} es el contaje repetido ---
       cuántas ocurrencias de la cadena para buscar. Este argumento es
       opcional y si la función es llamada sin un contaje repetido, este
       argumento pasa el valor 1. Si este argumento es negativo, la búsqueda
       va hacia atrás.


    En la forma de plantilla, una expresión @c{search-forward} se ve así:

    @smallexample
      (search-forward "@var{cadena-a-buscar}"
                      @var{limite-de-busqueda}
                      @var{que-hacer-si-la-busqueda-falla}
                      @var{repetir-contaje})
    @end smallexample

    Lo siguiente es echar un vistazo a @c{progn}.

*** La forma especial @c{progn}

    @c{progn} es una forma especial que causa que cada uno de sus argumentos
    puedan ser evaluados en secuencia y entonces devuelve el valor del
    último. Las expresiones precedentes son evaluadas solo por los efectos
    laterales que ellos desarrollan. Los valores producidos por ellos son
    descartados.

    La plantilla para una expresión @c{progn} es muy simple:

    @smallexample
      (progn
        @var{body}…)
    @end smallexample

    En @c{zap-to-char}, la expresión @c{progn} tiene que hacer dos cosas:
    poner el punto en la posición exacta; y devolver la posición del punto de
    modo que @c{kill-region} conoce cómo de lejos se copia.

    El primer argumento de @c{progn} es @c{search-forward}. Cuando
    @c{search-forward} encuentra la cadena, la función deja el punto
    inmediatamente después del último caracter en la cadena objetivo. (En
    este caso la cadena objetivo es solo un carácter largo.) Si la búsqueda
    es hacia atrás, @c{search-forward} deja el punto justo antes del primer
    carácter en el objetivo. El movimiento del punto es un efecto lateral.

    El segundo y último argumento de @c{progn} es la expresión
    @c{(point)}. Esta expresión devuelve el valor del punto, que en este caso
    será la localización para la que se ha movido por @c{search-forward}. (En
    la fuente, una línea que cuenta la función para ir al carácter previo, si
    se está yendo hacia delante, se comentó en 1999; yo no recuerdo si esta
    funcionalidad o no funcionalidad era siempre parte de las fuentes
    distribuidas.) El valor de @c{point} se devuelve por la expresión
    @c{progn} y se pasa a @c{kill-region} como el segundo argumento de
    @c{kill-region} .

*** Resumiendo @c{zap-to-char}

    Ahora que se ha visto cómo @c{search-forward} y @c{progn} trabajan, se
    puede ver cómo la función @c{zap-to-char} funciona como un todo.

    El primer argumento de @c{kill-region} es la posición del cursor cuando
    el comando @c{zap-to-char} da––el valor del punto en este momento. Con el
    @c{progn}, la búsqueda de la función mueve el punto a solo después del
    zapped-to-character y @c{point} devuelve el valor de localización. La
    función @c{kill-region} pone junto a estos dos valores de punto, el
    primero como el principio de la región y el segundo como el fin de la
    región, y borra la región.

    La forma especial @c{progn} se necesita porque el comando @c{kill-region}
    toma dos argumentos; y fallaría si @c{search-forward} y expresiones
    @c{point} fueran escritas en secuencia como dos argumentos
    adicionales. La expresión @c{progn} es un argumento simple para
    @c{kill-region} y devuelve un valor para que @c{kill-region} se necesite
    por su segundo argumento.

** @c{kill-region}

   La función @c{zap-to-char} usa la función @c{kill-region}. Esta función
   corta texto desde una región y copia este texto al kill ring @e{anillo de
   la muerte}, desde el que puede ser recuperado.

   @ignore
     GNU Emacs 22:

     (defun kill-region (beg end &optional yank-handler)
       "Kill (\"cut\") text between point and mark.
     This deletes the text from the buffer and saves it in the kill ring.
     The command \\[yank] can retrieve it from there.
     \(If you want to kill and then yank immediately, use \\[kill-ring-save].)

     If you want to append the killed region to the last killed text,
     use \\[append-next-kill] before \\[kill-region].

     If the buffer is read-only, Emacs will beep and refrain from deleting
     the text, but put the text in the kill ring anyway.  This means that
     you can use the killing commands to copy text from a read-only buffer.

     This is the primitive for programs to kill text (as opposed to deleting it).
     Supply two arguments, character positions indicating the stretch of text
      to be killed.
     Any command that calls this function is a \"kill command\".
     If the previous command was also a kill command,
     the text killed this time appends to the text killed last time
     to make one entry in the kill ring.

     In Lisp code, optional third arg YANK-HANDLER, if non-nil,
     specifies the yank-handler text property to be set on the killed
     text.  See ‘insert-for-yank’."
       ;; Pass point first, then mark, because the order matters
       ;; when calling kill-append.
       (interactive (list (point) (mark)))
       (unless (and beg end)
         (error "The mark is not set now, so there is no region"))
       (condition-case nil
           (let ((string (filter-buffer-substring beg end t)))
             (when string                        ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)
         ((buffer-read-only text-read-only)
          ;; The code above failed because the buffer, or some of the characters
          ;; in the region, are read-only.
          ;; We should beep, in case the user just isn't aware of this.
          ;; However, there's no harm in putting
          ;; the region's text in the kill ring, anyway.
          (copy-region-as-kill beg end)
          ;; Set this-command now, so it will be set even if we get an error.
          (setq this-command 'kill-region)
          ;; This should barf, if appropriate, and give us the correct error.
          (if kill-read-only-ok
              (progn (message "Read only text copied to kill ring") nil)
            ;; Signal an error if the buffer is read-only.
            (barf-if-buffer-read-only)
            ;; If the buffer isn't read-only, the text is.
            (signal 'text-read-only (list (current-buffer)))))))
   @end ignore

   Tanto la versión de Emacs 22 de esta función usa @c{condition-case} y
   @c{copy-region-as-kill}, ambas se explicarán. @c{condition-case} es una
   forma especial importante.

   En esencia, la función @c{kill-region} llama a @c{condition-case}, que
   toma tres argumentos. En esta función, el primer argumento no hace
   nada. El segundo argumento contiene el código hace el trabajo cuando todo
   va bien. El tercer argumento contiene el código que se llama en el evento
   de un error.

   Ahora se puede volver a través del código @c{condition-case} en un
   momento. Primero, se echa un vistazo a la definición de @c{kill-region},
   con comentarios añadidos:

   @smallexample
     (defun kill-region (beg end)
       "Kill (\"corta\") texto entre punto y marca.
     Esto borra el texto desde el búffer y lo guarda en anillo de la
       muerte @e{kill ring}.
     El comando \\[yank] puede recuperarse desde allí. …
      "

       ;; • Desde materias de orden, pasa el punto primero.
       (interactive (list (point) (mark)))
       ;; • Y cuéntanos si no podemos cortar el texto.
       ;; `a menos que' sea un `if' sin una then-part.
       (unless (and beg end)
         (error "La marca no está asignada ahora, así que
       no hay región"))

       ;; • `condition-case' toma tres argumentos
       ;;    Si el primer argumento es nulo, como aquí
       ;;    la información acerca del error no está
       ;;    almacenada para ser usada por otra función
       (condition-case nil

           ;; • El segundo argumento a `condition-case' cuenta lo que el
           ;;    intérprete que hace cuando todo va bien.

           ;;    Empieza con una función ‘let’ que extrae la cadena
           ;;    y chequea si existe. Si es así (esto es lo
           ;;    que ‘when’ chequea), eso llama a una función ‘if’ que
           ;;    determina si el comando previo que era otra llamada
           ;;    si el comando previo fué otra llamada a ‘kill-region’;
           ;;    si lo era, entonces el siguiente texto se añade
           ;;    cuando se chequea), eso llama a una función ‘if’ que
           ;;    determina si el comando previo era otra llamada a
           ;;    ‘kill-region’; si era eso, entonces el nuevo texto es
           ;;    añadido al texto previo; si no, entonces una función
           ;;    diferente, ‘kill-new’ se llama.

           ;;    La función ‘kill-append’ concatena la nueva cadena y
           ;;    la vieja.  La función ‘kill-new’ inserta texto dentro de
           ;;    ítem en el kill ring @e{anillo de la muerte}.

           ;;    ‘when’ es un ‘if’ sin una parte else.  El segundo ‘when’
           ;;    de nuevo chequea si la cadena actual existe;
           ;;    por añadidura, eso chequea si el comando previo fuese
           ;;    otra llamada a ‘kill-region’. Si una u otra condición
           ;;    es verdadero, entonces eso configura el actual comando a
           ;;    ser ‘kill-region’.
           (let ((string (filter-buffer-substring beg end t)))
             (when string                    ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
                   ;;    @minus{} ‘yank-handler’ es un argumento opcional para
                   ;;    ‘kill-region’ que cuenta el ‘kill-append’ y funciones
                   ;;    ‘kill-new’ como tratan con propiedades añadidas
                   ;;    al texto, tal como ‘negrilla’ o ‘itálica’
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)

         ;;  • El tercer argumento a ‘condition-case’ cuenta el intérprete
         ;;  qué hacer con un error.
         ;;    El tercer argumento tiene una parte de condiciones y una
         ;;    parte del cuerpo.
         ;;    Si las condiciones se encuentra (en este caso,
         ;;             si el texto o búffer son de solo lectura)
         ;;    entonces el cuerpo es ejecutado.
         ;;    La primera parte del tercer es el siguiente:
         ((buffer-read-only text-read-only) ;; parte if
          ;; …  parte then-part
          (copy-region-as-kill beg end)
          ;;    Lo siguiente, también como parte de la then-part, asigna this-command, así
          ;;    será asignado en un error
          (setq this-command 'kill-region)
          ;;    Finalmente, en la then-part, envía un mensaje
          ;;    si se puede copiar el texto al anillo de la muerte
          ;;    @e{kill ring} sin señalar un error, pero no si no se puede.

          (if kill-read-only-ok
              (progn (message "Lee solo texto copiado para el kill ring") nil)
            (barf-if-buffer-read-only)
            ;; If the buffer isn't read-only, the text is.
            (signal 'text-read-only (list (current-buffer)))))
   @end smallexample

   @ignore
     @c v 21
     @smallexample
       (defun kill-region (beg end)
         "Corta entre punto y marca.
       El texto es borrado, pero guardado en el kill ring."
         (interactive "r")

         ;; 1. ‘condition-case’ tiene tres argumentos.
         ;;    Si el primer argumento es nil, como está aquí
         ;;    la información acerca de la señal de error no es
         ;;    almacenada para usarse por otra función.
         (condition-case nil

             ;; 2. El segundo argumento a ‘condition-case’
             ;;    cuenta al intéprete Lisp que hacer cuando todo va bien.

             ;;    La función ‘delete-and-extract-region’ normalmente hace
             ;;    el trabajo. Si el principio y final de la región son lo
             ;;    mismo, entonces la varible ‘string’ estará
             ;;    vacía, o nula
             (let ((string (delete-and-extract-region beg end)))

               ;; ‘cuando’ es una cláusula ‘if’ que no puede tomar ‘else-part’.
               ;; Emacs normalmente asigna el valor del ‘last-command’ al
               ;; comando previo.
               ;; ‘kill-append’ concatena la nueva cadena y la vieja.
               ;; ‘kill-new’ inserta texto dentro de un nuevo
               ;; ítem dentro de un nuevo í en
               ;; kill ring.
               (when string
                 (if (eq last-command 'kill-region)
                     ;; si verdadero, concatena la cadena
                     (kill-append string (< end beg))
                   (kill-new string)))
               (setq this-command 'kill-region))

           ;; 3. El tercer argumento para ‘condition-case’ cuenta el intérprete
           ;;    que hacer con un error.
           ;;    El tercer argumento tiene una parte de condiciones y una
           ;;    parte del cuerpo.
           ;;    Si las condiciones se encuentra (en este caso,
           ;;             si el texto o búffer son de solo lectura)
           ;;    entonces el cuerpo es ejecutado.
           ((buffer-read-only text-read-only) ;; esta el la parte if
            ;; entonces...
            (copy-region-as-kill beg end)
            (if kill-read-only-ok            ;; normalmente esta variable es nula
                (message "Lee el texto copiado al kill ring")
              ;; o sino, señala un error si el búffer es de solo lectura;
              (barf-if-buffer-read-only)
              ;; y, en cualquier caso, señala el texto de solo lectura.
              (signal 'text-read-only (list (current-buffer)))))))
     @end smallexample
   @end ignore

*** @c{condition-case}

    Como se ha visto antes (@pxref{Creando errores, , Genera un Mensaje de
    Error}), cuando el intérprete Emacs Lisp tiene problemas evaluando una
    expresión, se provee de una ayuda; en jerga, se dice “signaling an error”
    @e{señalando un error}. Normalmente, el ordenador para el programa y te
    muestra un mensaje.

    Sin embargo, algunos programas garantizan acciones complicadas. Eso no
    pararía en un error. En la función @c{kill-region}, la mayoría parece un
    error que intentará cortar texto que es de solo lectura y no puede ser
    eliminado. Así la función @c{kill-region} contiene código para manejar
    esta circunstancia. Este código, hace que el cuerpo de la función
    @c{kill-region}, esté dentro de una forma especial @c{condition-case}.

    La plantilla para @c{condition-case} se parece a esto:

    @smallexample
      (condition-case
        @var{var}
        @var{bodyform}
        @var{error-handler}…)
    @end smallexample

    El segundo argumento, @var{bodyform} es sencillo. La forma especial
    @c{condition-case} causa que el intérprete Lisp evalúe el código en
    @var{bodyform}. Si ningún error ocurre, la forma especial devuelve el
    valor del código y produce efectos laterales, si hay.

    En resumen, la parte @var{bodyform} de una expresión @c{condition-case}
    determina qué ocurre cuando cualquier cosa funciona correctamente.

    Sin embargo, si un error ocurre, entre sus otras acciones, la función
    genera la señal de error que definirá uno o más errores de nombres de
    condición.

    Un manejador de errores es el tercer argumento para
    @c{condition-case}. Un manejador de errores tiene dos partes, un
    @var{condition-name} y un @var{body}. Si la parte @var{condition-name}
    tiene un manejador de errores encuentra un nombre de condición generado
    por un error, entonces la parte del @var{body} del manejador de errores
    se ejecuta.

    Como se esperaría, la parte @var{condition-name} de un manejador de
    errores puede ser así, un nombre de condición simple o una lista de
    nombres de condición.

    También, una expresión completa @c{condition-case} puede contener más de
    un manejador de errores. Cuando un error ocurre, el primer manejador
    aplicable se ejecuta.

    Finalmente, el primer argumento a la expresión @c{condition-case}, es el
    argumento @var{var}, que es algunas veces asignado a una variable que
    contiene información acerca del error. Sin embargo, si este argumento es
    nulo, como es el caso en @c{kill-region}, esta información se descarta.

    En breve, en la función @c{kill-region}, el código @c{condition-case}
    funciona así:

    @smallexample
      @var{Si no hay errores}, @var{ejecuta solo este código}
          @var{pero}, @var{si hay errores}, @var{ejecuta este otro código}.
    @end smallexample

    @ignore
      2006 Oct 24
      In Emacs 22,
      copy-region-as-kill is short, 12 lines, and uses
      filter-buffer-substring, which is longer, 39 lines
      and has delete-and-extract-region in it.
      delete-and-extract-region is written in C.

      see Initializing a Variable with @c{defvar}
      this is line 8054
      Initializing a Variable with @c{defvar} includes line 8350
    @end ignore

*** Macro Lisp

    La parte de la expresión @c{condition-case} que se evalúa en la
    expectativa de que todo va bien si tiene un @c{when}. El código usa
    @c{when} para determinar si la variable @c{string} (@e{cadena}) apunta al
    texto que existe.

    Una expresión @c{when} es simplemente una conveniencia de
    programadores. Eso es un @c{if} sin la posibilidad de una cláusula
    else. En tu mente, se puede reemplazar @c{when} con @c{if} y comprender
    de que va. Esto es lo que el intérprete Lisp hace.

    Técnicamente hablando, @c{when} es una macro Lisp. Una @:{macro} Lisp
    permite definir una nueva construcción de control y otras funcionalidades
    del lenguaje. Eso cuenta al intérprete cómo computar otra expresión Lisp
    que dejará de computar el valor. En este caso, la ‘otra expresión’ es una
    expresión @c{if}.

    La definición de función también tiene una macro @c{unless}; que acompaña
    a @c{when}. La macro @c{unless} es un @c{if} sin una cláusula then.

    Para más acerca de macros Lisp, ver Seccion "Macros" en @e(El Manual de
    Referencia de Emacs Lisp). El lenguaje de programación C también provee
    macros. Estos son diferentes, pero también útiles.

    @ignore
      We will briefly look at C macros in
      @l{Digression into C}.
    @end ignore

    Guardando la macro @c{when}, en la expresión @c{condition-case}, cuando
    la cadena tiene contenido, entonces otra expresión condicional se
    ejecuta. Esto es un @c{if} tanto con una then-part y como con una
    else-part.

    @smallexample
      (if (eq last-command 'kill-region)
          (kill-append string (< end beg) yank-handler)
        (kill-new string nil yank-handler))
    @end smallexample

    La parte then (then-part) se evalúa si el comando previo fué otra llamada
    para @c{kill-region}; si no, se evalúa la parte else (else-part)

    @c{yank-handler} es un argumento opcional para @c{kill-region} que cuenta
    cómo las funciones @c{kill-append} y @c{kill-new} se tratan con
    propiedades añadidas al texto, tal como ‘negrilla’ o ‘itálica’.

    @c{last-command} es una variable que viene con Emacs y que no se ha visto
    antes. Normalmente, siempre y cuando una función se ejecute, Emacs asigna
    el valor de @c{last-command} al comando previo.

    En este segmento de la definición, la expresión @c{if} chequea si el
    comando previo era @c{kill-region}. Si era eso,

    @smallexample
      (kill-append string (< end beg) yank-handler)
    @end smallexample

    Se concatena una copia del nuevo texto cortado al texto cortado
    previamente en el kill ring @e{anillo de la muerte}.

** @c{copy-region-as-kill}

   La función @c{copy-region-as-kill} copia una región de texto desde un
   búffer y (via @c{kill-append} o @c{kill-new}) lo guarda en el
   @c{kill-ring}.

   Si se llama a @c{copy-region-as-kill} inmediatamente después de un comando
   @c{kill-region}, Emacs inserta el texto nuevamente copiado al texto
   copiado previamente. Esto significa que si se pega el texto, se obtiene
   todo, tanto esto, como la operación previa. Por otro lado, si algún otro
   comando precede la @c{copy-region-as-kill}, la función copia el texto
   dentro de una entrada separada el kill ring @e{anillo de la muerte}.

   Aquí está el texto completo de la versión 22 de la función
   @c{copy-region-as-kill}:

   @smallexample
     (defun copy-region-as-kill (beg end)
       "Guarda la región como si estuviera cortada, pero no la cortes.
     En el modo Marca de Tránsito @e{Transient Mark}, se desactiva la
       marca.
     Si ‘interprogram-cut-function’ es no nulo, también se guarda el
       texto para una sistema de ventanas de cortar y pegar."
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (filter-buffer-substring beg end) (< end beg))
         (kill-new (filter-buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)
   @end smallexample

   De normal, esta función puede ser dividida dentro sus componentes:

   @smallexample
     (defun copy-region-as-kill (@var{argument-list})
       "@var{documentation}…"
       (interactive "r")
       @var{body}…)
   @end smallexample

   Los argumentos son @c{beg} y @c{end} y la función es interactiva con
   @c{"r"}, así los dos argumentos deben referirse al principio y al final de
   la región. Si ha estado leyendo a través de este documento desde el
   principio, comprendiendo estas partes de una función casi llegaría a ser
   rutina.

   La documentación es algo confusa a menos que se recuerde que la palabra
   ‘kill’ @e{matar, cortar} tiene un significado diferente de la usual. La
   ‘Marca Transitoria’ y @c{interprogram-cut-function} comenta explicar
   ciertos efectos laterales.

   Después de que se ha asignado una marca, un búffer siempre contiene una
   región. Si se desea se puede usar el modo Marca Transitoria para iluminar
   la región temporalmente. (Nadie quiere iluminar la región todo el rato,
   así el modo Marca Transitoria subrraya solo en el momento
   apropiado. Muchas personas desactivan el modo Marca Transitoria, así la
   región nunca se ilumina.)

   También, un sistema de ventanas permite copiar, cortar y pegar entre
   programas diferentes. En el sistema de X windows, por ejemplo, la función
   @c{interprogram-cut-function} es @c{x-select-text}, que funciona con el
   sistema de ventanas equivalente del kill ring de Emacs.

   El cuerpo de la función @c{copy-region-as-kill} empieza con una cláusula
   @c{if}. Lo que esta cláusula hace es distinguir entre dos situaciones
   diferentes: si este comando se ejecuta o no inmediatamente después de un
   comando previo @c{kill-region}. En el primer caso, la nueva región se
   concatena al texto copiado previamente. De otro modo, eso se inserta al
   principio del anillo de la muerte @e{kill ring} como una pieza separada de
   texto desde la pieza previa.

   Las dos líneas de la función previene la región desde la iluminación si el
   modo Transient Mark @e{Marca Transitoria} está activado.

   El cuerpo de @c{copy-region-as-kill} merece discusión en detalle.

*** El cuerpo de @c{copy-region-as-kill}

    La función @c{copy-region-as-kil} funciona de un modo parecido a la
    función @c{kill-region}. Ambas están escritas de un modo que dos o más
    textos cortados en una fila combinan su texto en una entrada simple. Si
    se pega el texto desde el anillo de la muerte @e{kill ring}, se tiene
    todo en una pieza. Más allá, los cortes de textos que se cortan hacia
    adelante desde la posición actual del cursor se añaden al fin del texto
    copiado previamente y comanda este texto copiado vaya hacia atrás al
    principio del texto copiado previamente. De este modo, las palabras en el
    texto están en el orden apropiado.

    Como @c{kill-region}, la función @c{copy-region-as-kill} hace uso de la
    variable @c{last-command} que deja traza del comando de Emacs previo.

    Normalmente, siempre y cuando una función se ejecuta, Emacs asigna el
    valor de @c{this-command} a la función que se ejecuta (que en este caso
    sería @c{copy-region-as-kill}). Al mismo tiempo, Emacs asigna el valor de
    @c{last-command} al valor previo de @c{this-command}.

    En la primera parte del cuerpo de la función @c{copy-region-as-kill}, una
    expresión @c{if} determina si el valor de @c{last-command} es
    @c{kill-region}. Si es así, la then-part de la expresión @c{if} se
    evalúa; eso usa la función @c{kill-append} para concatenar el texto
    copiado en esta llamada a la función con el texto ya en el primer
    elemento (el @Cc{car} del anillo de la muerte. Por otro lado, si el valor
    de @c{last-command} no es @c{kill-region}, entonces la función
    @c{copy-region-as-kill} adjunta un nuevo elemento al anillo de la muerte
    @e{kill ring} usando la función @c{kill-new}.

    La expresión @c{or} se ve así; usa @c{eq}:

    @smallexample
        (if (eq last-command 'kill-region)
            ;; @r{parte then}
            (kill-append  (filter-buffer-substring beg end) (< end beg))
          ;; @r{parte else}
          (kill-new  (filter-buffer-substring beg end)))
    @end smallexample

    (La función @c{filter-buffer-substring} devuelve una subcadena filtrada
    del búffer, cualquiera. Opcionalmente––los argumentos no están aquí, así
    nunca está hecho --- la función puede borrar el texto inicial o devolver
    el texto sin sus propiedades; esta función es un reemplazo para la vieja
    función @c{buffer-substring}, que viene antes que las propiedades del
    texto fuesen implementadas.)

    La función @c{eq} chequea si su primer argumento es el mismo objeto Lisp
    que su segundo argumento. La función @c{eq} es similar a la función
    @c{equal} en esto que es usado para chequear para igualdad, pero difiere
    en esto que determina si dos representaciones son actualmente el mismo
    objeto dentro del ordenador, pero con diferentes nombres. @c{equal}
    determina si la estructura y contenidos de dos expresiones son la misma.

    Si el comando previo era @c{kill-region}, entonces el intérprete Emacs
    Lisp llama a la función @c{kill-append}

**** La función @c{kill-append}

     La función @c{kill-new} se ve como así:

     @smallexample
       (defun kill-append (string before-p &optional yank-handler)
         "Inserta STRING al fin del último corte en el anillo de la muerte @e{kill ring}.
       Si BEFORE-P es no nulo, inserta STRING.
       … "
         (let* ((cur (car kill-ring)))
           (kill-new (if before-p (concat string cur) (concat cur string))
                     (or (= (length cur) 0)
                         (equal yank-handler
                                (get-text-property 0 'yank-handler cur)))
                     yank-handler)))
     @end smallexample

     @ignore
       was:
       (defun kill-append (string before-p)
         "Append STRING to the end of the latest kill in the kill ring.
       If BEFORE-P is non-nil, prepend STRING to the kill.
       If ‘interprogram-cut-function’ is set, pass the resulting kill to
       it."
         (kill-new (if before-p
                       (concat string (car kill-ring))
                     (concat (car kill-ring) string))
                   t))
     @end ignore

     La función @c{kill-append} es limpia. Usa la función @c{kill-new}, que
     discutiremos en más detalle en un momento.

     (También, la función provee un argumento opcional llamado
     @c{yank-handler}; cuando se invoque, este argumento cuenta a la función
     cómo tratar con la propiedades añadidas al texto, tales como ‘negrilla’
     o ‘itálicas’.)

     Eso tiene una función @c{let*} para asignar el valor del primer elemento
     del kill ring a @c{cur}. (No se sabe por qué la función no usa @c{let};
     solo un valor es asignado en la expresión. ¿Quizás esto es un error que
     no produce problemas?

     Considera el condicional que es uno de los dos argumentos para
     @c{kill-new}. Eso usa @c{concat} para concatenar el nuevo texto al
     @Cc{car} del anillo de la muerte @e{kill ring}. Si eso se concatena
     atrás o delante depende de los resultados de una expresión @c{if}:

     @smallexample
       (if before-p                            ; @r{if-part}
           (concat string cur)                 ; @r{then-part}
         (concat cur string))                  ; @r{else-part}
     @end smallexample

     Si la región cortada está antes que la región que se cortó en el último
     comando, entonces debería ser puesto antes que el material salvador en
     el anterior corte @e{kill}; y de manera contraria, si el texto cortado
     sigue lo que fué cortado, eso sería añadido después del texto previo. La
     expresión @c{if} depende del predicado @c{before-p} para decidir si el
     texto nuevamente salvado es puesto antes o después.

     El símbolo @c{before-p} es el nombre de uno de los argumentos a
     @c{kill-append}. Cuando la función @c{kill-append} se evalúa, se asocia
     al valor devuelto evaluando el argumento actual. En este caso, esta es
     la expresión @c{(< end beg)}. Esta expresión no determina directamente
     si el texto cortado en este comando se localiza antes o después del
     texto cortado del último comando; lo que hace es determinar si el valor
     de la variable @c{end} es menor que el valor de la variable @c{beg}. Si
     es así, significa que el usuario se encara al principio del
     búffer. También, el resultado de evaluar la expresión del
     predicado. @c{(< end beg)}, será verdadero y el texto se concatena antes
     del texto previo. Por otro lado, si el valor de la variable @c{end} es
     mayor que el valor del la variable @c{beg}, el texto será concatenado
     después del texto previo.

     Cuando el texto nuevamente guardado se concatena, entonces la cadena con
     el nuevo texto será concatenado antes del viejo texto:

     @smallexample
       (concat string cur)
     @end smallexample

     Pero si el texto será añadido, eso será concatenado después del viejo
     texto:

     @smallexample
       (concat cur string))
     @end smallexample

     Para comprender cómo funciona esto, primero se necesita revisar la
     función @c{concat}. La función @c{concat} enlaza junto o une dos cadenas
     de texto. El resultado es una cadena. Por ejemplo:

     @smallexample
       (concat "abc" "def")
            ⇒ "abcdef"

       (concat "nuevo "
               (car '("primer elemento" "segundo elemento")))
            ⇒ "nuevo primer elemento"

       (concat (car
               '("primer elemento" "segundo elemento")) " modificado")
            ⇒ "primer elemento modificado"
     @end smallexample

     Ahora puede tener sentido @c{kill-append}: eso modifica los contenidos
     del anillo de la muerte @e{kill ring}. El anillo de la muerte @e{kill
     ring} es una lista, en la que cada elemento es texto guardado. La
     función @c{kill-append} usa la función @c{kill-new} que usa la función
     @c{setcar}.

**** La función @c{kill-new}

     @ignore
       Optional third arguments YANK-HANDLER controls how the STRING is later
       inserted into a buffer; see ‘insert-for-yank’ for details.
       When a yank handler is specified, STRING must be non-empty (the yank
       handler, if non-nil, is stored as a ‘yank-handler’ text property on STRING).

       When the yank handler has a non-nil PARAM element, the original STRING
       argument is not used by ‘insert-for-yank’.  However, since Lisp code
       may access and use elements from the kill ring directly, the STRING
       argument should still be a \"useful\" string for such uses."
     @end ignore

     La función @c{kill-new} se ve de esta manera:

     @smallexample
       (defun kill-new (string &optional replace yank-handler)
         "Crea STRING el último corte en el anillo de la muerte @e{kill
         ring}.
       Asigna ‘kill-ring-yank-pointer’ para apuntarlo.

       Si ‘interprogram-cut-function’ es no nulo, aplícalo a su
        STRING.
       Segundo argumento opcional REPLACE no-nulo significa que STRING
        reemplazará el frente del kill ring, en vez de ser a@~andido a la lista.
       …"
         (if (> (length string) 0)
             (if yank-handler
                 (put-text-property 0 (length string)
                                    'yank-handler yank-handler string))
           (if yank-handler
               (signal 'args-out-of-range
                       (list string "yank-handler specified for empty string"))))
         (if (fboundp 'menu-bar-update-yank-menu)
             (menu-bar-update-yank-menu string (and replace (car kill-ring))))
         (if (and replace kill-ring)
             (setcar kill-ring string)
           (push string kill-ring)
           (if (> (length kill-ring) kill-ring-max)
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end smallexample
     @ignore
       was:
       (defun kill-new (string &optional replace)
         "Make STRING the latest kill in the kill ring.
       Set the kill-ring-yank pointer to point to it.
       If ‘interprogram-cut-function’ is non-nil, apply it to STRING.
       Optional second argument REPLACE non-nil means that STRING will replace
       the front of the kill ring, rather than being added to the list."
         (and (fboundp 'menu-bar-update-yank-menu)
              (menu-bar-update-yank-menu string (and replace (car kill-ring))))
         (if (and replace kill-ring)
             (setcar kill-ring string)
           (setq kill-ring (cons string kill-ring))
           (if (> (length kill-ring) kill-ring-max)
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end ignore

     (Vea que la función no es interactiva.)

     Normalmente, se mira a esta función en partes.

     La definición de la función tiene un argumento opcional
     @c{yank-handler}, que cuando se invoca cuenta la función de cómo tratar
     con propiedades añadidas al texto, tal como ‘negrilla’ o
     ‘itálica’. Nosotros evitaremos esto.

     La primer línea de la documentación tiene sentido:

     @smallexample
       Crea la CADENA la última copia en el anillo de la muerte @e{kill
       ring}.
     @end smallexample

     Permite saltarse el resto de la documentación por el momento.

     También, permite salir de la expresión inicial @c{if} y estas líneas de
     código involucrando @c{menu-bar-update-yank-menu}. Nosotros explicaremos
     debajo.

     Las líneas críticas son estas:

     @smallexample
         (if (and replace kill-ring)
             ;; @r{entonces}
             (setcar kill-ring string)
           ;; @r{resto}
         (push string kill-ring)
           (setq kill-ring (cons string kill-ring))
           (if (> (length kill-ring) kill-ring-max)
               ;; @r{avoid overly long kill ring}
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end smallexample

     El test condicional es @c{(and replace kill-ring)}. Esto será verdad
     cuando dos condiciones se encuentran: el anillo de la muerte @e{kill
     ring} tiene alguna cosa dentro, y la variable @c{replace} es verdad.

     Cuando la función @c{kill-append} asigna @c{replace} para ser cierto y
     cuando el anillo de la muerte @e{kill ring} tiene al menos un ítem en
     eso, la expresión @c{setcar} es ejecutada.

     @smallexample
       (setcar kill-ring string)
     @end smallexample

     La función @c{setcar} actualemten cambia el primer elemento del anillo
     de la muerte (@c{kill-ring} lista al valor de @c{string}. Eso reemplaza
     el primer elemento.

     Por otro lado, si el kill ring está vacío, o reemplazar es falso, la
     else-part de la condición está ejecutado:

     @smallexample
       (push string kill-ring)
     @end smallexample

     @c{push} pone su primer argumento dentro del segundo. Es similar al
     viejo.

     @smallexample
       (setq kill-ring (cons string kill-ring))
     @end smallexample

     o el nuevo

     @smallexample
       (add-to-list kill-ring string)
     @end smallexample

     Cuando eso es falso, la expresión primero construye una nueva versión
     del anillo de la muerte @e{kill ring} añadiendo @c{string} al anillo de
     la muerte @e{kill ring} como un nuevo elemento (que es lo que @c{push}
     hace). Entonces ejecuta un segundo @c{if} cláusula. Este segundo @c{if}
     cláusula guarada el anillo de la muerte @e{kill ring} desde el creciente
     demasiado largo.

     Déjanos mirar estas dos expresiones en orden.

     La línea @c{push} de la parte else asigna el nuevo valor del kill ring
     @e{anillo de la muerte} a que resultados añaden la cadena siendo cortada
     al viejo anillo de la muerte @e{kill ring}

     Nosotros podemos ver cómo esto funciona con un ejemplo.

     Primero,

     @smallexample
       (setq example-list '("aqui una clausula" "otra clausula"))
     @end smallexample

     Después de evaluar esta expresión con @k{C-x C-e}, se puede evaluar
     @c{example-list} y mira lo que devuelve:

     @smallexample
       example-list
            ⇒ ("aquí hay una claúsula" "otra claúsula")
     @end smallexample

     Ahora, se puede añadir un nuevo elemento en esta lista evaluando la
     siguiente expresión: @findex push, @r{ejemplo}

     @smallexample
       (push "una tercera cláusula" lista-de-ejemplo)
     @end smallexample

     Cuando se evalúa @c{example-list}, se encuentra su valor es:

     @smallexample
       example-list
            ⇒ ("una tercera claúsula" "aquí hay una
            claúsula" "otra claúsula")
     @end smallexample

     De este modo, la tercera claúsula se añade a la lista con @c{push}.

     Ahora para la segunda parte de la claúsula @c{if}. Esta expresión deja
     el kill ring desde lo creciente demasiado largo. Eso se ve de la
     siguiente manera:

     @smallexample
       (if (> (length kill-ring) kill-ring-max)
           (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
     @end smallexample

     El código chequea si el tamaño del anillo de la muerte @e{kill ring} es
     más grande que el máximo tamaño permitido. Este es el valor de
     @c{kill-ring-max} (que es 60, por defecto). Si el tamaño del anillo de
     la muerte @e{kill ring} es demasiado largo, entonces este código asigna
     el último elemento del anillo de la muerte @e{kill ring} a @c{nil}. Eso
     hace esto usando dos funciones, @c{nthcdr} y @c{setcdr}.

     Nosotros vemos que @c{setcdr} temprano (@pxref{setcdr, ,
     @c{setcdr}}). Eso asigna el @Cc{cdr} de una lista, solo como @c{setcar}
     asigna el @Cc{car} de una lista. En este caso, sin embargo, @c{setcdr}
     no estará configurando el @Cc{cdr} del kill ring completo; la función
     @c{nthcdr} es usada para causarlo para asignar el @Cc{cdr} del siguiente
     al último elemento del kill ring --- esto significa que desde el
     @Cc{cdr} del siguiente al último elemnto del kill ring @e{anillo de la
     muerte}, eso asignará el último elemento del kill ring @e{anillo de la
     muerte}.

     La función @c{nthcdr} funciona repetidamente tomando el @Cc{cdr} de una
     lista––eso toma el @Cc{cdr} del @Cc{cdr} del @Cc{cdr} …. Eso hace esto
     @var{N} veces y devuelve los resultados. (Véase Sección @l{nthcdr, ,
     @c{nthcdr}}.)

     De este modo, si teniamos una lista de cuatro elemento que era
     supuestamente de tres elementos, se podría asignar el @Cc{cdr} del
     siguiente al último elemento a @c{nil}, y por eso se ordena la
     lista. (Si se asigna el último elemento a algún otro valor a @c{nil},
     que se podría hacer, entonces no se habría ordenado la lista. Véase
     Sección @l{setcdr, , @c{setcdr}}.)

     Se puede ver ordenando la evaluación de las siguientes tres expresiones
     en turno. Primero asigna el valor de @c{arboles} a @c{(arce encina pino
     abedul)} entonces asigna el @Cc{cdr} de su segundo @Cc{cdr} y entonces
     encuentra el valor de @c{arboles}.

     @smallexample
       (setq arboles '(arce encina pino abedul))
            ⇒ (arce encina pino abedul)

       (setcdr (nthcdr 2 arboles) nil)
            ⇒ nil

       árboles
            ⇒ (arce encina pino)
     @end smallexample

     (El valor devuelto por la expresión @c{setcdr} es @c{nil} desde que es
     que el @Cc{cdr} es asignado.)

     Para repetir, en @c{kill-new}, la función @c{nthcdr} toma el @Cc{cdr} un
     número de veces que es uno menos que el tamaño máximo permitido del
     anillo de la muerte @e{kill ring} y @c{setcdr} asigna el @Cc{cdr} de
     este elemento (que será el resto de los elementos en el anillo muerte)
     para @c{nil}. Esto previene el anillo de la muerte @e{kill ring} desde
     lo que crece demasiado largo.

     De la siguiente a la última expresión en la función @c{kill-new} es

     @smallexample
       (setq kill-ring-yank-pointer kill-ring)
     @end smallexample

     El @c{kill-ring-yank-pointer} es una variable global que es asignado
     para ser el @c{kill-ring}.

     Incluso aunque el @c{kill-ring-yank-pointer} es llamado un @'{puntero},
     eso es una variable solo como el anillo de la muerte @e{kill ring}. Sin
     embargo, el nombre que ha sido elegido para ayudar a humanos a
     comprender cómo la variable se usa.

     Ahora, para devolver rápido una expresión en el cuerpo de la función:

     @smallexample
         (if (fboundp 'menu-bar-update-yank-menu)
              (menu-bar-update-yank-menu string (and replace (car kill-ring))))
     @end smallexample

     Empieza con una expresión @c{if}

     En este caso, la expresión chequea primero si
     @c{menu-bar-update-yank-menu} existe como una función, y si así, se
     llama. La función @c{fboundp} devuelve cierto si el símbolo que se
     chequea tiene una definición de función que ‘no es vacía’. Si el símbolo
     de la definición de función fuera vacío, recibiría un mensaje de error,
     como se hizo cuando se crearon errores intencionalmente (@pxref{Creando
     errores, , Genera un Mensaje de Error}).

     La then-part contiene una expresión cuyo primer elemento es la función
     @c{and}.

     La forma especial @c{and} evalúa cada uno de sus argumentos hasta que
     uno de los argumentos devuelva un valor de @c{nil}, en cuyo caso la
     expresión @c{and} devuelve @c{nil}; sin embargo, si ninguno de los
     argumentos devuelve una valor de @c{nil}, el valor resultante desde la
     evaluación el último argumento es devuelto. (Desde que tal valor no es
     @c{nil}, eso es considerado cierto en Emacs Lisp.) En otras palabras,
     una expresión @c{and} devuelve un valor cierto solo si todos sus
     argumentos son verdaderos. (Véase Sección @l{Revisar el segundo búffer
     relacionado}.)

     La expresión determina si el segundo argumento
     @c{menu-bar-update-yank-menu} es verdadero o no.

     @ignore
       ;; If we're supposed to be extending an existing string, and that
       ;; string really is at the front of the menu, then update it in place.
     @end ignore

     @c{menu-bar-update-yank-menu} es una de la funciones que lo hace posible
     para usar el menu ‘Seleccionar y Pegar’ en el ítem Editar de una barra
     de menu; usando un ratón, se pueden mirar varias piezas de texto que se
     han guardado y se selecciona una pieza para pegar.

     La última expresión en la función @c{kill-new} añade las cadenas
     nuevamente copiadas a aquella facilidad que existe copiando y pegando
     entre diferentes programas ejecutando un sistema de ventanas. En el
     Sistema de Ventanas de X, por ejemplo, la función @c{x-select-text} toma
     la cadena y la almacena en memoria operada por X@. Se puede pegar la
     cadena en otro programa, tal como un Xterm.

     La expresión se ve como:

     @smallexample
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end smallexample

     Si @c{interprogram-cut-function} existe, entonces Emacs ejecuta
     @c{funcall}, que en vez de llamar a su primer argumento como una
     función, pasa los argumentos que permanecen en eso. (Incidentalmente,
     tan lejos como se puede ver, esta expresión @c{if} podría ser
     reemplazado por una expresión @c{and} similar a uno en la primera parte
     de la función.)

     Estamos yendo a discutir sistemas de ventanas y otros programas más allá
     pero meramente nota que este es un mecanismo que habilita GNU Emacs a
     trabajar fácilmente y bien con otros programas.

     Este código para emplazar texot en el anillo de la muerte @e{kill ring},
     concatenado con un elemento existente o como un nuevo elemento, nos
     lidera al código para traer texto que ha sido cortado del búffer––los
     comandos de corte. Sin embargo, antes de discutir los comandos de corte,
     es mejor aprender cómo las listas son implementadas en un
     ordenador. Esto dejará claro tales misterios como el uso del término
     ‘puntero’. Pero antes de esto, nos desviaremos a C.

     @ignore
       @c is this true in Emacs 22?   Does not seems to be

         (If the @c{(< end beg))} expression is true, @c{kill-append}
       prepends the string to the just previously clipped text.  For a
       detailed discussion, see @l{kill-append function, , The
       @c{kill-append} function}.)

       If you then yank back the text, i.e., ‘paste’ it, you get both pieces
       of text at once.  That way, if you delete two words in a row, and then
       yank them back, you get both words, in their proper order, with one
       yank.  (The @c{(< end beg))} expression makes sure the order is
       correct.)

       On the other hand, if the previous command is not @c{kill-region},
       then the @c{kill-new} function is called, which adds the text to
       the kill ring as the latest item, and sets the
       @c{kill-ring-yank-pointer} variable to point to it.
     @end ignore

     @ignore

       @c Evidently, changed for Emacs 22. The zap-to-char command does not
       @c use the delete-and-extract-region function

       2006 Oct 26, the Digression into C is now OK but should come after
       copy-region-as-kill and filter-buffer-substring

       2006 Oct 24
       In Emacs 22,
       copy-region-as-kill is short, 12 lines, and uses
       filter-buffer-substring, which is longer, 39 lines
       and has delete-and-extract-region in it.
       delete-and-extract-region is written in C.

       see Initializing a Variable with @c{defvar}
     @end ignore

** Disgresión dentro de C

   La función @c{copy-region-as-kill} (@pxref{copy-region-as-kill, ,
   @c{copy-region-as-kill}}) usa la función @c{filter-buffer-substring}, que
   en vez de eso usa la función @c{delete-and-extract-region}. Eso elimina
   los contenidos de una región y no se puede volverlos a tener.

   Al contrario que el otro código discutido aquí, la función
   @c{delete-and-extract-region} no está escrita en Emacs Lisp; eso está
   escrito en C y es una de las primitivas del sistema GNU Emacs. Puesto que
   es muy simple, se hará la disgresión brevemente desde el Lisp y se
   describe aquí.

   Como muchas de las otras primitivas Emacs, @c{delete-and-extract-region}
   se escribe como una instancia de una macro C, una macro es una plantilla
   para codificar. La macro completa se parece a esto:

   @smallexample
     DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
            Sdelete_and_extract_region, 2, 2, 0,
            doc: /* Borra el texto entre START y END y lo devuelve.  */)
            (Lisp_Object start, Lisp_Object end)
     {
       validate_region (&start, &end);
       if (XINT (start) == XINT (end))
         return empty_unibyte_string;
       return del_range_1 (XINT (start), XINT (end), 1, 1);
     }
   @end smallexample

   Sin ir dentro de los detalles de la macro que escribe el proceso, se hará
   un apunte de esta macro que empieza con la palabra @c{DEFUN}. La palabra
   @c{DEFUN} fué elegida puesto que el código sirve para el mismo propósito
   que @c{defun} hace en Lisp. (La macro C @c{DEFUN} definida en
   @f{emacs/src/lisp.h}.)

   El palabra @c{DEFUN} tiene siete partes dentro de los paréntesis:

   - La primera parte es el nombre dado a la función en Lisp,
     @c{delete-and-extract-region}.

   - La segunda parte es el nombre de la función en C,
     @c{Fdelete_and_extract_region}. Por convención, eso empieza con
     @'{F}. Puesto que C no usa guiones en nombres, los guiones bajos son
     usados a su vez.

   - La tercera parte es el nombre para la estructura constante C que
     registra información en esta función para uso interno. Es el nombre de
     la función en C pero empieza con una @'{S} en vez de una @'{F}.

   - Las partes cuarta y quinta especifican el número mínimo y máximo de
     argumentos que la función puede tener. Esta función demanda exactamente
     2 argumentos.

   - La sexta parte está cerca del argumento que sigue la declaración
     @c{interactive} en una función escrita en Lisp: una carta seguida,
     quizás, por una consola. La única diferencia con Lisp es que si la macro
     se llama sin argumentos. Entonces se escribe un @c{0} (que es una
     ‘cadena nula’), como en esta macro.

     Si se fueran a especificar argumentos, se emplazarían entre marcas de
     comillas. La macro C para @c{goto-char} incluye @c{\"NGoto char \"} en
     esta posición se indica que la función espera un prefijo plano, en este
     caso, una localización numérica en un búffer, y provee una consola.

   - La séptima parte es una cadena de documentación, solo como la única para
     una función escrita en Emacs Lisp. Esto es escrito como un comentario
     C. (Cuando se escribe Emacs, el programa @command{lib-src/make-docfile}
     extrae estos comentarios y los usa para crear la documentación “real”.)


   En una macro C, los parámetros son los siguientes, con una frase de este
   tipo de objeto se siguen por lo que podría ser llamado el ‘cuerpo’ de la
   macro. Para @c{delete-and-extract-region} el ‘cuerpo’ consiste de las
   siguientes cuatro líneas:

   @smallexample
     validate_region (&start, &end);
     if (XINT (start) == XINT (end))
       return build_string ("");
     return del_range_1 (XINT (start), XINT (end), 1, 1);
   @end smallexample

   La función @c{validate_region} chequea si los valores pasados como el
   principio y fin de la región son el tipo apropiado y son del mismo
   rango. Si las posiciones del principio y fin son las mismas, entonces se
   devuelve una cadena vacía.

   La función @c{del_range_1} actualmente borra el texto. Eso es una función
   compleja que no miraremos. Eso actualiza el búffer y hace otras cosas. Sin
   embargo, es el valorable mirar los dos argumentos pasados para
   @c{del_range}. Estos son @c{XINT (start)} y @c{XINT (end)}.

   Tan lejos como el lenguaje C es concebido, @c{start} y @c{end} son dos
   enteros que marcan el principio y el fin de la región para ser
   borrada@n{9}.

   En las primeras versiones de Emacs, estos dos números fueron 32 bits de
   longitud, pero el código está lentamente siendo generalizado para manejar
   otras longitudes. Tres de los bits disponibles son usados para especificar
   el tipo de información; los bits permanecen ser usados como ‘contenido’.

   @'{XINT} es una macro C que extrae los números relevantes desde la
   colección larga de bits; los otros tres bits se descartan.

   El comando en @c{delete-and-extract-region} se parece a esto:

   @smallexample
     del_range_1 (XINT (start), XINT (end), 1, 1);
   @end smallexample

   Esto borra la región entre la posición del principio, @c{start}, y la
   posición final, @c{end}.

   Desde el punto de vista de la persona que escribe Lisp, Emacs es muy
   simple; pero oculta en el fondo un gran trato de complejidad para hacer
   todo el trabajo.

** Inicializando una variable con @c{defvar}

   @ignore
     2006 Oct 24
     In Emacs 22,
     copy-region-as-kill is short, 12 lines, and uses
     filter-buffer-substring, which is longer, 39 lines
     and has delete-and-extract-region in it.
     delete-and-extract-region is written in C.

     see Initializing a Variable with @c{defvar}
   @end ignore

   La función @c{copy-region-as-kill} es escrita en Emacs Lisp. Dos funciones
   con eso, @c{kill-append} y @c{kill-new}, copiar una región en un búffer y
   guardarlo en una variable llamada el @c{kill-ring}. Esta sección describe
   cómo la variable @c{kill-ring} es creada e inicializada usando la forma
   especial @c{defvar}.

   (De nuevo se nota que el término @c{kill-ring} es un sin nombre. El texto
   que es cortado fuera del búffer puede ser traido; eso no es un corpus de
   anillo, pero un anillo de texto resucitable.)

   En Emacs Lisp, una variable tal como @c{kill-ring} es creada y dada por un
   valor inicial usando la forma especial @c{defvar}. El nombre viene de
   “definir variable”.

   La forma especial @c{defvar} es similar a @c{setq} en este se configura el
   valor de una variable. Eso no es @c{setq} en dos modos; primero solo
   configura el valor de la variable si la variable no tiene ya un valor. Si
   la variable ya tiene un valor, @c{defvar} no sobreescribe el valor
   existente. Segundo, @c{defvar} tiene una cadena de documentación.

   (Otra forma especial, @c{defcustom}, está diseñado para variables que la
   gente personaliza. Eso tiene más funcionalidades que @c{defvar}. (Véase
   Sección @l{Especificar variables usando @c{defcustom}}.)

   Se puede ver el actual valor de una variable, cualquier variable, usando
   la función @c{describe-variable}, que es normalmente invocado escribiendo
   @k{C-h v}. Si se escribe @k{C-h v} y @c{kill-ring} (seguido por @k{RET}),
   se verá que hay en tu anillo de la muerte actual @e{kill ring} al ser
   pulsado --- ¿esto puede ser bastante tranquilo! A la inversa, si no has
   estado haciendo nada esta sesión en Emacs, excepto leer este documento, se
   puede no tener nada dentro. También, se verá la documentación para
   @c{kill-ring}:

   @smallexample
     Documentación:
     Lista de secuencias de texto muerto (guardado).
     Desde que el (kill ring) se supone que interactua bien con
     cut-and-paste facilita ofrecer por sistemas de ventanas,
     debería usar esta variable
     interactúa bin con ‘interprogram-cut-function’ y
     ‘interprogram-paste-function’. Las funciones ‘kill-new’,
     ‘kill-append’, y ‘current-kill’ se suponen para implementar esta
     interacción; se puede querer usarlo en vez de manipular en anillo de
     la muerte @e{kill ring} directamente.
   @end smallexample

   El kill ring @e{anillo de la muerte} está definido por un @c{defvar} del
   siguiente modo:

   @smallexample
     (defvar kill-ring nil
       "Lista de secuencia de textos cortados.
     …")
   @end smallexample

   En esta definición de variable, la variable es dada un valor inicial de
   @c{nil}, que tiene sentido, desde que si no se ha guardado nada, no se
   quiere nada si se da un comando @c{yank}. La cadena de documentación es
   escrito solo como la cadena de documentación de un @c{defun}. Como con la
   cadena de documentación sería una frase completa, desde que algunos
   comandos, como @c{apropos}, imprime solo la primera línea de
   documentación. Las líneas de exito no serían indentadas; de otro modo se
   mira cuando se usa @k{C-h v} (@c{describe-variable}).

*** @c{defvar} y un asterisco

    En el pasado, Emacs usaba la forma especial @c{defvar} tanto para
    variables interna que no esperaría que un usuario cambie y para variables
    que espera un usuario cambie. Aunque se puede todavía usar @c{defvar}
    para variables personalizadas, por favor, usa @c{defcustom} en vez, desde
    que la forma especial provee una ruta dentro de los comando de
    Personalización. (Véase Sección @l{Especificar variables usando
    @c{defcustom}}.)

    Cuando se especifica una variable usando la forma especial @c{defvar}, se
    podría distinguir una variable que un usuario podría querer cambiar desde
    otros escribiendo, @'{*}, en la primera columna de su cadena de
    documentación. Por ejemplo:

    @smallexample
      (defvar shell-command-default-error-buffer nil
        "*Nombre de buffer para ‘shell-command’ … salir del error.
      … ")
    @end smallexample

    Tu podrías (y todavía puedes) usar el comando @c{set-variable} para
    cambiar el valor de @c{shell-command-default-error-buffer}
    temporalmente. Sin embargo, las opciones configuradas usando
    @c{set-variable} no están asignadas solo por la duración de tu sesión de
    edición. Los nuevos valores no están guardados entre sesiones. Cada vez
    que Emacs empieza, lee el valor original, a menos que tu cambia el valor
    con tu fichero @f{.emacs}, si configurándolo manualmente o usando
    @c{customize}. Véase Sección @l{Tu Fichero @f{.emacs}}.

    Para mí, el mayor uso del comando @c{set-variable} es sugerir variables
    que se podrían querer asignar en mi fichero @f{.emacs}. Ahora hay más de
    700 variables, demasiadas para recordarlas fácilmente. Afortunadamente,
    se puede presionar @k{TAB} después de llamar al comando @c{M-x
    set-variable} para ver la lista de variables. (Véase Sección "Examinando
    y Configurando Variables" en @e(El Manual de GNU Emacs).)

** Revisar

   Aquí hay un breve resumen de algunas funciones introducidas recientemente.

   - car -:
     cdr -:

     @c{car} devuelve el primer elemento de una lista; @c{cdr} devuelve el
     segundo y subsiguientes elementos de una lista.

     Por ejemplo:

     @smallexample
       (car '(1 2 3 4 5 6 7))
            ⇒ 1
       (cdr '(1 2 3 4 5 6 7))
            ⇒ (2 3 4 5 6 7)
     @end smallexample

   - cons -:

     @c{cons} construye una lista enlazando su primer argumento a su segundo
     argumento.

     Por ejemplo:

     @smallexample
       (cons 1 '(2 3 4))
            ⇒ (1 2 3 4)
     @end smallexample

   - funcall -:

     @c{funcall} evalúa su primer argumento como una función. Así pasa los
     argumentos que permanecen a su primer argumento.

   - nthcdr -:

     Devuelve el resultado de tomar @Cc{cdr} ‘n’ veces en una lista.  The
     @m(n^{th}) @c{cdr}. El ‘resto del resto’, como estaba

     Por ejemplo:

     @smallexample
       (nthcdr 3 '(1 2 3 4 5 6 7))
            ⇒ (4 5 6 7)
     @end smallexample

   - setcar -:
     setcdr -:

     @c{setcar} cambia el primer elemento de una lista; @c{setcdr} cambia el
     segundo y subsiguiente elementos de una lista.

     Por ejemplo:

     @smallexample
       (setq triple '(1 2 3))

       (setcar triple '37)

       triple
            ⇒ (37 2 3)

       (setcdr triple '("foo" "bar"))

       triple
            ⇒ (37 "foo" "bar")
     @end smallexample

   - progn -:

     Evalúa cada argumento en secuencia y entonces devuelve el valor del
     último.

     Por ejemplo:

     @smallexample
       (progn 1 2 3 4)
            ⇒ 4
     @end smallexample

   - save-restriction -:

     Graba siempre que encoger esté en efecto en el búffer, si cualquiera,
     restaura este encogimiento después de evaluar los argumentos.

   - search-forward -:

     Buscar una cadena, y si la cadena es encontrada, mueve el punto. Con una
     expresión regular, usa algo similar a @c{re-search-forward}. (Véase
     Sección @l{Búsquedas de Expresiones Regulares}, para una explicación de
     expresiones regulares patrones y búsquedas.)

     @c{search-forward} y @c{re-search-forward} tiene cuatro argumentos:

     1. La cadena o la expresión regular para buscar.

     2. Opcionalmente, el límite de la búsqueda.

     3. Opcionalmente, que haces si la búsqueda falla, devuelve @c{nil} o un
        mensaje de error.

     4. Opcionalmente, cuántas veces se puede repetir la búsqueda; si es
        negativa, la búsqueda va hacia atrás.


   - kill-region               -:
     delete-and-extract-region -:
     copy-region-as-kill       -:

     @c{kill-region} corta el texto entre punto y marca desde el búffer y
     almacena ese texto en el anillo de la muerte @e{kill ring}, así se puede
     obtener pegándolo.

     @c{copy-region-as-kill} copia el texto entre punto y marca dentro del
     anillo de la muerte @e{kill ring}, que se puede obtener pegándolo. La
     función no corta o borra el texto desde el búffer.


   @c{delete-and-extract-region} elimina el texto entre el punto y marca
   desde el búffer y a través. No se puede volver. Esto no es un comando
   interactivo.)

** Buscando ejercicios

   - Escribe una función interactiva que busca una cadena. Si la búsqueda
     encuentra la cadena, deja el punto después y muestra un mensaje que dice
     “¿Encontrado!”. (No use @c{search-forward} como nombre de esta función;
     si se hace, se sobreescribirá la versión existente @c{search-forward}
     que viene con Emacs. Use un nombre tal como @c{test-search} en vez de
     eso.

   - Escribe una función que imprime el tercer elemento del kill ring
     @e{anillo de la muerte} en el área echo, si cualquiera; si el kill ring
     @e{anillo de la muerte} no contiene un tercer elemento, imprime un
     mensaje apropiado.

* Cómo las listas se implementan

  En Lisp, los átomos se graban de manera simple, si la implementación no es
  sencilla en la práctica, no es, nada sencilla en la teoría. El átomo
  @'{rosa}, por ejemplo, se graba como las cuatro letras contiguas @'{r},
  @'{o}, @'{s}, @'{a}. Una lista, por otro lado, se guarda de manera
  diferente. El mecanismo es igualmente simple, pero toma un momento para
  tener usada la idea. Una lista se guarda usando una serie de pares de
  punteros. En las series, el primer puntero en cada par de puntos a un átomo
  o a otra lista, y el segundo puntero en cada par al siguiente par, o al
  símbolo @c{nil}, que marca el fin de la lista.

  Un puntero por sí mismo es poco simple a la dirección electrónica de la que
  está apuntada. Aquí, una lista se guarda como una serie de direcciones
  electrónicas.

  Por ejemplo, la lista @c{(rosa violeta botóndeoro)} tiene tres elementos,
  @'{rosa}, @'{violeta}, y @'{botóndeoro}. En el ordenador, la dirección
  electrónica de @'{rosa} se graba en un segmento de memoria del ordenador a
  través de la dirección que da la dirección electrónica de donde el átomo
  @'{violeta} está localizado; y esta dirección (la que cuenta donde
  @'{violeta} está se localiza) se guarda con una dirección que cuenta donde
  la dirección para el átomo @'{botóndeoro} se localiza.

  Esto parece más complicado de lo que es y es más fácil visto en un
  diagrama:

  @diagram
        ___ ___      ___ ___      ___ ___
       |___|___|--> |___|___|--> |___|___|--> nil
         |            |            |
         |            |            |
         ---> rosa    ---> violeta ---> botóndeoro
  @end diagram

  En el diagrama, cada caja representa una palabra de memoria del ordenador
  que maneja un objeto Lisp, normalmente en la forma de una dirección de
  memoria. Las cajas, por ej. las direcciones, están en pares. Cada flecha
  apunta a lo que la dirección es la dirección de, si un átomo u otro par de
  direcciones. La primera caja es la dirección electrónica de @'{rosa} y la
  flecha apunta a @'{rosa}; la segunda caja es la dirección del siguiente par
  de cajas, la primera parte de la que es la dirección de @'{violeta} y la
  segunda parte es la dirección del siguiente par. La última caja apunta al
  símbolo @c{nil}, que marca el fin de la lista.

  Cuando una variable es configurado a una lista con una función tal como
  @c{setq}, almacena la dirección de la primera caja en la variable. De este
  modo, la evaluación de la expresión es:

  @smallexample
    (setq ramo '(rosa violeta botóndeoro))
  @end smallexample

  crea una situación como esta:

  @diagram
    ramo
         |
         |     ___ ___      ___ ___      ___ ___
          --> |___|___|--> |___|___|--> |___|___|--> nil
                |            |            |
                |            |            |
                 --> rosa     --> violeta   --> botóndeoro
  @end diagram

  En este ejemplo, el símbolo @c{ramo} maneja la dirección del primer par de
  cajas.

  Esta misma lista puede ser ilustrada en un modo diferente de anotación de
  cajas como esta:

  @diagram
    ramo
     |
     |    --------------       ----------------       --------------------
     |   | car   | cdr  |     | car     | cdr  |     | car         | cdr  |
      -->| rosa  |   o------->| violeta |   o------->| botóndeoro  | nil  |
         |       |      |     |         |      |     |             |      |
          --------------       ----------------       --------------------
  @end diagram

  (Los símbolos consisten de más pares de direcciones, pero la estructura de
  un símbolo es hecha de direcciones. De manera profunda, el símbolo @c{ramo}
  consiste de un grupo de cajas-de-direcciones, una que es la dirección de la
  palabra impresa @'{ramo}, una segunda de la que es la dirección de una
  definición de función adjunta al símbolo, si cualquiera, un tercero del que
  es la dirección del primer par de cajas-de-direccion para la lista @c{(rosa
  violeta botóndeoro)}, y así. Aquí se está mostrando que la tercera caja de
  dirección del símbolo apunta al primer par de cajas-de-direccion para la
  lista.)

  Si un símbolo se asigna al @Cc{cdr} de una lista, la lista en sí no cambia;
  el símbolo simplemente tiene una dirección abajo de la lista. (En la jerga,
  @Cc{car} y @Cc{cdr} son ‘no destructivos’.) De este modo, se evalúa la
  siguiente expresión

  @smallexample
    (setq flores (cdr ramo))
  @end smallexample

  produce esto:

  @diagram
    ramo        flores
      |              |
      |     ___ ___  |     ___ ___      ___ ___
       --> |   |   |  --> |   |   |    |   |   |
           |___|___|----> |___|___|--> |___|___|--> nil
             |              |            |
             |              |            |
              --> rosa       --> violeta  --> botóndeoro
  @end diagram

  El valor de @c{flores} es @c{(violeta botóndeoro)}, esto es decir que el
  símbolo @c{flores} maneja la dirección del par address-boxes el primero que
  maneja la dirección de @c{violeta}, y el segundo que maneja la dirección de
  @c{botóndeoro}.

  Un par de cajas-de-direcciones se llama una @:{cons cell} o @:{par de
  puntos}. Véase Sección "la Célula Cons y los Tipos Lista" en @e(El Manual
  de Referencia de Emacs Lisp), y @"(Notación de Pares de Puntos) en @e(El
  Manual de Referencia de GNU Emacs Lisp), para más información acerca de
  células cons y pares de puntos.

  La función @c{cons} añade un nuevo par de direcciones al frente de una
  serie de direcciones como son mostradas debajo. Por ejemplo, evaluando la
  expresión

  @smallexample
    (setq ramo (cons 'lila ramo))
  @end smallexample

  produce:

  @diagram
    ramo                       flores
      |                             |
      |     ___ ___        ___ ___  |     ___ ___       ___ ___
       --> |   |   |      |   |   |  --> |   |   |     |   |   |
           |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
             |              |              |             |
             |              |              |             |
              --> lila      --> rosa       --> violeta    --> botóndeoro
  @end diagram

  Sin embargo, esto no cambia el valor del símbolo @c{flores}, así puedes ver
  evaluando lo siguiente,

  @smallexample
    (eq (cdr (cdr ramo)) flores)
  @end smallexample

  que devuelve @c{t} para verdad.

  Hasta que se resetea, @c{flores} todavía tiene el valor de @c{(violeta
  botóndeoro)}; que es, eso tiene la dirección de la celula cons cuya primera
  dirección es @c{violeta}. También, esto no altera cualquier célula
  prexistente cons; ellas está todavía allí.

  De este modo, en Lisp, tiene el @Cc{cdr} de una lista, se obtiene la
  dirección del siguiente cons en las serie; para tener el @Cc{car} de una
  lista, se obtiene la dirección del primer elemento de la lista; para
  @c{cons} un nuevo elemento en una lista, se añade una nueva célula cons al
  frente de la lista. ¿Esto es todo lo que hay así! ¿La estructura subyacente
  de Lisp es brillantemente simple!

  ¿Y qué hace la última dirección en una serie de células cons se refieren?
  Eso es la dirección de la lista vacía, de @c{nil}.

  En resumen, cuando una variable Lisp es asignada a un valor, eso provee con
  la dirección de la lista a la que la variable se refiere.

** Símbolos como una caja con cajones

   En una sección temprana, se sugería que se podría imaginar un símbolo
   siendo una caja con cajones. La definición de función se pone en un cajón,
   el valor en otro, y así. Lo que se pone en el cajón maneja el valor que
   puede cambiarse sin afectar a los contenidos del cajón manejando la
   definición de función, y viceversa.

   Actualmente, lo que está puesto en cada cajón es la dirección del valor o
   definición de función. Eso es como si se encontrara un viejo cajón en el
   ático, y en uno de sus cajones se encontrara un mapa dándote direcciones a
   donde está el tesoro escondido.

   (Además de su nombre, la definición del símbolo, y un valor de la
   variable, un símbolo tiene un ‘cajón’ para una @:{lista de propiedades}
   que puede ser usada para grabar otra información. Las listas de
   propiedades no se discuten aquí; ver @l{Listas de Propiedades, , Listas de
   Propiedades, elisp, El Manual de Referencia de Emacs Lisp}.)

   Aquí hay una representación visionaria:

   @diagram
                 Caja de Cajones            Contenidos de Cajones

                 __   o0O0o   __
               /                 \
              ---------------------
             |    direcciones al   |            [mapeo a]
             | nombre del simbolo  |            ramo
             |                     |
             +---------------------+
             |  direcciones a la   |
             |   definición del    |            [nunca]
             |    simbolo          |
             +---------------------+
             |    direcciones al   |            [mapeo a]
             |   valor de variable |            (rosa violeta botóndeoro)
             |                     |
             +---------------------+
             |    direcciones a la |
             |lista de propiedades |            [no descrito aquí]
             |                     |
             +---------------------+
             |/                   \|
   @end diagram

** Ejercicio

   Asignar @c{flores} a @c{violeta} y @c{botóndeoro}. Asigna dos flores más
   en esta lista y asigna esta nueva lista a @c{mas-flores}. Asigna el
   @Cc{car} de @c{flores} a un pez. ¿Qué lista contiene ahora @c{mas-flores}?

* Pegando texto

  Siempre y cuando se corta texto fuera de un búffer con un comando `kill’ en
  GNU Emacs, se puede traer con un comando ‘pegar’. El texto cortado del
  búffer es puesto en el anillo de la muerte y en los comandos pegar, se
  insertan los contenidos apropiados del kill ring detrás de un búffer (no
  necesariamente el búffer original).

  Un simple comando @k{C-y} (@c{yank}) inserta el primer ítem desde el anillo
  de la muerte @e{kill ring} dentro del actual búffer. Si el comando @k{C-y}
  es seguido inmediatamente para @k{M-y}, el primer elemento se reemplaza por
  el segundo elemento. Los sucesivos comandos @k{M-y} reemplazan el segundo
  elemento con el tercer, cuarto, o quinto elemento, y así. Cuando se llega
  al último elemento en el anillo de la muerte @e{kill ring}, se reemplaza
  por el primer elemento y el ciclo se repite. (De este modo, el kill ring se
  llama un ‘anillo’ en vez de solo una ‘lista’. Sin embargo, la estructura de
  de datos actual que maneja el texto es una lista. Véase Sección @l{Qué hace
  el anillo de la muerte, , Manejando el anillo de la muerte @e{kill ring}},
  para los detalles de cómo la lista es manejada como un anillo.)

** Resumen del anillo de la muerte

   El anillo de la muerte @e{kill ring} es una lista de cadenas
   textuales. Esto es lo que se ve:

   @smallexample
     ("algún texto" "una pieza diferente pieza de texto"
     "todavía más texto")
   @end smallexample

   Si estos fueran los contenidos de mi anillo de la muerte @e{kill ring} y
   yo presionara @k{C-y}, la cadena de caracteres diciendo @'{algún texto}
   sería insertado en este búffer donde mi cursor está localizado.

   El comando @c{yank} @e{pegar} es también usado para duplicar texto
   copiándolo. El texto copiado no es cortado desde el búffer, pero una copia
   de eso se pone en el anillo de la muerte @e{kill ring} y se inserta
   pegándolo.

   Tres funciones se usan para atraer texto desde el anillo de la muerte
   @e{kill ring}: @c{yank} (@e{pegar}), que normalmente se asocian a @k{C-y};
   @c{yank-pop}, que normalmente se asocia a @k{M-y}; y
   @c{rotate-yank-pointer}, que se usa por las otras dos funciones.

   Estas funciones se refieren al kill ring @e{anillo de la muerte} a través
   de una variable llamada el @c{kill-ring-yank-pointer}. En vez de eso, la
   inserción del código para ambos son las funciones @c{yank} y @c{yank-pop}:

   @smallexample
     (insert (car kill-ring-yank-pointer))
   @end smallexample

   (Bien, no más. En GNU Emacs 22, la función se ha reemplazado por
   @c{insert-for-yank} que llama a @c{insert-for-yank-1} repetitivamente para
   cada segmento @c{yank-handler}. En vez de eso, @c{insert-for-yank-1}
   destituye las propiedades de texto desde el texto insertado de acuerdo a
   @c{yank-excluded-properties}. De otro modo, eso es como
   @c{insert}. Nosotros lo pegamos con un @c{insert} plano puesto que sea
   fácil de comprender.)

   Para empezar a comprender cómo @c{yank} y @c{yank-pop} funcionan, primero
   es necesario mirar en la variable @c{kill-ring-yank-pointer}.

** La variable @c{kill-ring-yank-pointer}

   @c{kill-ring-yank-pointer} es una variable, solo como @c{kill-ring} es una
   variable. Eso apunta a alguna cosa siendo asignada al valor de lo que
   apunta, como cualquier otra variable Lisp.

   De este modo, si el valor del kill ring es:

   @smallexample
     ("algún texto" "una pieza diferente pieza de texto"
     "todavía más texto")
   @end smallexample

   y el @c{kill-ring-yank-pointer} apunta a la segunda cláusula, el valor de
   @c{kill-ring-yank-pointer} es:

   @smallexample
     ("una pieza diferente de texto" "todavía más texto")
   @end smallexample

   Como se explica en el capítulo previo (Véase Sección @l{Cómo las listas se
   implementan}), el ordenador no guarda dos copias diferentes del texto
   siendo apuntado por ambos el @c{kill-ring} (el @e{anillo de la muerte}) y
   el @c{kill-ring-yank-pointer} (el @e{puntero de pegar el anillo de la
   muerte}). Las palabras “una pieza diferente de texto” y “todavía más
   texto” no están duplicadas. En vez de eso, las dos variables Lisp apuntan
   a las mismas piezas de texto. Aquí hay un diagrama:

   @diagram
     kill-ring     kill-ring-yank-pointer
         |               |
         |      ___ ___  |     ___ ___      ___ ___
          ---> |   |   |  --> |   |   |    |   |   |
               |___|___|----> |___|___|--> |___|___|--> nil
                 |              |            |
                 |              |            |
                 |              |             --> "todavía más texto"
                 |              |
                 |               --> "una pieza diferente de texto"
                 |
                  --> "algo de texto"
   @end diagram

   Tanto la variable @c{kill-ring} y la variable @c{kill-ring-yank-pointer}
   son punteros. Pero el kill ring @e{anillo de la muerte} en sí es
   normalmente descrito como si fuera actualmente de lo que está
   compuesto. El @c{kill-ring} se refiere a lo que es la lista en vez de lo
   que apunta a la lista. Conversando, el @c{kill-ring-yank-pointer} se
   refiere a como se apunta a una lista.

   Estas dos maneras hablar acerca de la misma cosa suena confuso al
   principio pero tiene sentido para reflexionar. El kill ring @e{anillo de
   la muerte} es generalmente pensado como la estructura completa de datos
   que manejan la información de lo que se ha cortado reciéntemente de los
   búffers de Emacs. El @c{kill-ring-yank-pointer} en la otra mano, sirve
   para indicar --- que es, para ‘apuntar a’ --- esta parte del anillo de la
   muerte del que el primer elemento (el @Cc{car}) será insertado.

   @ignore
     In GNU Emacs 22, the @c{kill-new} function calls

     @c{(setq kill-ring-yank-pointer kill-ring)}

     (defun rotate-yank-pointer (arg)
       "Rotate the yanking point in the kill ring.
     With argument, rotate that many kills forward (or backward, if negative)."
       (interactive "p")
       (current-kill arg))

     (defun current-kill (n &optional do-not-move)
       "Rotate the yanking point by N places, and then return that kill.
     If N is zero, ‘interprogram-paste-function’ is set, and calling it
     returns a string, then that string is added to the front of the
     kill ring and returned as the latest kill.
     If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
     yanking point; just return the Nth kill forward."
       (let ((interprogram-paste (and (= n 0)
                                      interprogram-paste-function
                                      (funcall interprogram-paste-function))))
         (if interprogram-paste
             (progn
               ;; Disable the interprogram cut function when we add the new
               ;; text to the kill ring, so Emacs doesn't try to own the
               ;; selection, with identical text.
               (let ((interprogram-cut-function nil))
                 (kill-new interprogram-paste))
               interprogram-paste)
           (or kill-ring (error "Kill ring is empty"))
           (let ((ARGth-kill-element
                  (nthcdr (mod (- n (length kill-ring-yank-pointer))
                               (length kill-ring))
                          kill-ring)))
             (or do-not-move
                 (setq kill-ring-yank-pointer ARGth-kill-element))
             (car ARGth-kill-element)))))

   @end ignore

** Ejercicios con @c{yank} y @c{nthcdr}

   - Usando @k{C-h v} (@c{describe-variable}), mira en el valor de tu kill
     ring @e{anillo de la muerte}. Añade varios ítems a tu anillo de la
     muerte @e{kill ring}; mira en su valor de nuevo. Usando @k{M-y}
     (@c{yank-pop}, mueve todo el camino alrededor del kill ring @e{anillo de
     la muerte}. ¿Cuántos ítems estaban en tu kill ring @e{anillo de la
     muerte}? Encuentra el valor de @c{kill-ring-max}. ¿Estaba tu anillo de
     la muerte @e{kill ring} completo, o podrías haber guardado más bloques
     de texto dentro?

   - Usando @c{nthcrd} y @c{car}, construye una serie de expresiones para
     devolver, el primer, segundo, tercer y cuarto elemento de una lista.

* Bucles y recursión

  Emacs Lisp tiene dos caminos primarios para causar una expresión, o una
  serie de expresiones, para ser evaluado repetidamente: uno usa un bucle
  @c{while}, y el otro usa @:{recursión}.

  La repetición puede ser valorable. Por ejemplo, para mover hacia delante
  cuatro frases, tu solo necesitas escribir un programa que moverá hacia
  delante una frase y entonces repite el proceso cuatro veces. Ya que un
  ordenador no está aburrido o cansado, tal acción repetitiva no tiene los
  efectos de borrado por equivocación o exceso que pueden tener los humanos.

  La gente mayoritariamente escribe funciones de Emacs Lisp usando bucles
  @c{while}; pero se puede usar recursión, que provee un poderoso camino
  mental para resolver problemas@n{10}.

** @c{while}

   La forma especial @c{while} chequea si el valor devuelto para evaluar el
   primer argumento es verdadero o falso. Esto es parecido a lo que el
   intérprete Lisp hace con un @c{if}; el intérprete hace lo siguiente, sin
   embargo, es diferente.

   En una expresión @c{while}, si el valor devuelto por evaluar el primer
   argumento es falso, el intérprete Lisp descarta el resto de la expresión
   (el @:{cuerpo} de la expresión) y no la evalúa. Sin embargo, si el valor
   es cierto, el intérprete Lisp evalúa el cuerpo de la expresión y entonces
   de nuevo chequea si el primer argumento para @c{while} es cierto o
   falso. Si el valor devuelto de evaluar el primer argumento es cierto de
   nuevo, el intérprete Lisp evalúa el cuerpo de la expresión.

   La plantilla para una expresión @c{while} se ve así:

   @smallexample
     (while @var{test-verdadero-o-falso}
       @var{cuerpo}…)
   @end smallexample

   En el momento en el que el true-or-false-test de la expresión @c{while}
   devuelve un valor cierto cuando eso se evalúa, el cuerpo es repetidamente
   evaluado. Este proceso se llama bucle puesto que el intérprete Lisp repite
   la misma cosa una y otra vez, como un avión haciendo un loop. Cuando el
   resultado de evaluar el true-or-false-test es falso, el intérprete Lisp no
   evalúa el resto de la expresión @c{while} y ‘existe el bucle’.

   Claramente, si el valor devuelto evaluando el primer argumento para
   @c{while} es siempre cierto, el cuerpo siguiente será evaluado una y otra
   vez … y … para siempre. Recíprocamente, si el valor devuelto nunca es
   cierto, las expresiones en el cuerpo nunca serán evaluadas. La fortaleza
   de escribir un bucle @c{while} consiste de elegir un mecanismo tal que el
   true-or-false-test devuelva cierto solo el número de veces que requieren
   las subsiguientes expresiones para ser evaluadas, y entonces tener el test
   devuelto a falso.

   El valor devuelto evaluando @c{while} es el valor del
   true-or-false-test. Una consecuencia interesante de esto es que un bucle
   @c{while} que evalúa sin errores devolverá @c{nil} o falso sin dignidad de
   si eso ha girado 1 o 100 veces o ninguna. ¿Una expresión @c{while} que se
   evalúa de manera exitosa nunca devuelve un valor cierto! Lo que esto
   significa es que @c{while} es siempre evaluado por sus efectos laterales,
   que es decir, las consecuencias de evaluar las expresiones con el cuerpo
   del bucle @c{while}. Esto tiene sentido. Eso no es el mero acto del bucle
   que es deseado, pero las consecuencias de lo que ocurre cuando las
   expresiones en el bucle son repetidamente evaluadas.

*** Un bucle @c{while} y una lista

    Un camino común para controlar un bucle @c{while} es chequear si una
    lista tiene cualquier elemento. Si eso se hace, el bucle se repite; pero
    si no, la repetición se finaliza. Puesto que esto es una técnica
    importante, se creará un breve ejemplo para ilustrarlo.

    Un camino simple para chequear si una lista tiene elementos es evaluar la
    lista: si eso no tiene elementos, si es una lista vacía y devuelve la
    lista vacía, @c{()}, que es un sinónimo para @c{nil} o falso. Por otro
    lado, una lista con elementos devolverá estos elementos cuando eso se
    evalúa. Puesto que Emacs Lisp considera como cierto cualquier valor que
    no es @c{nil}, una lista que devuelve elementos chequeará cierto en un
    bucle @c{while}.

    Por ejemplo, se puede asignar la variable @c{empty-list} a @c{nil} para
    evaluar la siguiente expresión @c{setq}:

    @smallexample
      (setq lista-vacia ())
    @end smallexample

    Después de evaluar la expresión @c{setq}, se puede evaluar la variable
    @c{lista-vacia} es el camino normal, posicionando el cursor después del
    símbolo y escribiendo @k{C-x C-e}; @c{nil} aparecerá en tu área echo:

    @smallexample
      lista-vacia
    @end smallexample

    Por otro lado, si se asigna una variable para ser una lista con
    elementos, la lista aparecerá cuando se evalúe la variable, como se puede
    ver evaluando las siguientes dos expresiones:

    @smallexample
      (setq animales '(gacela jirafa leon tigre))

      animales
    @end smallexample

    De este modo, para un bucle @c{while} que chequea si hay cualquier ítem
    en la lista @c{animales}, la primera parte del bucle será escrito así:

    @smallexample
      (while animales
             …
    @end smallexample

    Cuando el @c{while} chequea su primer argumento, la variable @c{animales}
    se evalúa. Eso devuelve una lista. Mientras la lista tiene elementos, el
    @c{while} considera los resultados del test para ser verdadero; pero
    cuando la lista es vacía, eso considera los resultados del test para ser
    falso.

    Para prevenir que el bucle @c{while} se ejecute siempre, se necesita
    proporcionar algún mecanismo. Una técnica usada con frecuencia es tener
    una de las subsiguientes formas en la expresión @c{while} que asigna el
    valor de la lista para ser el @Cc{cdr} de la lista. Cada vez que la
    función @c{cdr} se evalúa, se va reduciendo, hasta que finalmente solo
    queda la lista vacía. En este punto, el test del bucle @c{while}
    devolverá falso, y los argumentos para el @c{while} no se evaluarán.

    Por ejemplo, la lista de animales asociada a la variable @c{animals} se
    puede asignar a ser el @Cc{cdr} de la lista original con la siguiente
    expresión:

    @smallexample
      (setq animals (cdr animals))
    @end smallexample

    Si se han evaluado las expresiones previas y entonces se evalúa esta
    expresión, se verá @c{(jirafa leon tigre)} que aparecerá en el área
    echo. Si se evalúa la expresi@'n de nuevo, @c{(leon tigre)} aparecerá en
    el área echo. Si se evalúa de nuevo, @c{(tigre)} y todavía de nuevo
    aparecerá la lista vacía y se mostrará como @c{nil}.

    Una plantilla para un bucle @c{while} usa la función @c{cdr}
    repetidamente para causar el true-or-false-test finalmente para chequear
    la veracidad y se parece a esto:

    @smallexample
      (while @var{test-whether-list-is-empty}
        @var{body}…
        @var{set-list-to-cdr-of-list})
    @end smallexample

    Este chequeo y uso de @c{cdr} puede ser puesto junto a una función que va
    a través de una lista e imprime cada elemento de la lista en una línea de
    sí misma.

*** Un ejemplo: @c{imprimir-elementos-de-la-lista}

    La función @c{imprimir-elementos-de-la-lista} ilustra un bucle @c{while}
    con una lista.

    La función requiere varias líneas por su salida. Si estás leyendo esto en
    una instancia reciente de GNU Emacs, se puede evaluar la siguiente
    expresión dentro de Info, de normal.

    Si se está usando una versión antigua de Emacs, es necesario copiar las
    expresiones necesarias para el búffer @f{*scratch*} y evaluarlas
    allí. Esto es porque el área echo tenía solo una línea en las versiones
    antiguas.

    Se pueden copiar las expresiones marcando el principio de la región con
    @k{C-@k{SPC}} (@c{set-mark-command}), moviendo el cursor al fin de la
    región y entonces copiando la región usando @k{M-w} (@c{kill-ring-save},
    que llama a @c{copy-region-as-kill} y entonces provee realimentación
    visual). En el búffer @f{*scratch*}, se pueden copiar las expresiones
    escribiendo @k{C-y} (@c{yank}).

    Después de haber copiado las expresiones al búffer @f{*scratch*}, se
    evalúa cada expresión en orden. Asegúrese de evaluar la última expresión,
    @c{(imprimir-elementos-de-la-lista animales)}, escribiendo @k{C-u C-x
    C-e}, que es, dando un argumento para @c{eval-last-sexp}. Esto causará el
    resultado de la evaluación para ser impreso en el búffer @f{*scratch*} en
    vez de siendo impreso en el área echo. (De otro modo se verá alguna cosa
    como esto en tu área echo: @c{^Jgacela^J^Jjirafa^J^Jleon^J^Jtigre^Jnulo},
    en cada @'{^J} se estructura una ‘nueva línea’.)

    En una instancia de GNU Emacs reciente, se pueden evaluar estas
    expresiones directamente en el búffer Info, y el área echo crecerá para
    mostrar los resultados.

    @smallexample
      (setq animales '(gacela jirafa leon tigre))

      (defun imprimir-elementos-de-la-lista (list)
        "Imprime cada elemento de LIST en una línea."
        (while list
          (print (car list))
          (setq list (cdr list))))

      (imprimir-elementos-de-la-lista animales)
    @end smallexample

    Cuando se evalúan las tres expresiones en secuencia, se verá esto:

    @smallexample
      gacela

      jirafa

      leon

      tigre
      nil
    @end smallexample

    Cada elemento de la lista se imprime en una línea en sí (que es lo que la
    función @c{print} hace) y entonces el valor devuelto por la función se
    imprime. Desde que la última expresión en la función es el bucle
    @c{while}, y desde que el bucle @c{while} siempre devuelve @c{nil}, un
    @c{nil} se imprime después del último elemento de la lista.

*** Un bucle con un contaje incremental

    Un bucle no es útil a menos que pare cuando debe. Bajo el control de un
    bucle con una lista, un camino común de parar un bucle es escribir el
    primer argumento como un test que devuelve falso cuando el número
    correcto de repeticiones es completo. Esto significa que el bucle debe
    tener un contador––una expresión que cuenta cuántas veces el bucle se
    repite a sí mismo.

    El test para un bucle con un contador de incremento puede ser una
    expresión tal como @c{(< contador numero-deseado)} que devuelve @c{t}
    para verdad si el valor de @c{contador} es menor que el
    @c{numero-deseado} de repeticiones y @c{nil} para falso si el valor de
    @c{contador} es igual a o es mayor que el @c{numero-deseado}. La
    expresión que incrementa el contador puede ser un simple @c{setq} tal
    como @c{(setq contador (1+ contador))}, donde @c{1+} es una función
    construida en Emacs Lisp que añade 1 a su argumento. (La expresión @c{(1+
    contador)} tiene el mismo resultado que @c{(+ contador 1)}, que es fácil
    de leer para un humano.)

    La plantilla para un bucle @c{while} controlado por un contador que se
    incrementa se parece a esto:

    @smallexample
      @var{asignar-contador-al-valor-inicial}
      (while (< contador numero-deseado)         ; @r{true-or-false-test}
        @var{body}…
        (setq contador (1+ contador)))              ; @r{incremento}
    @end smallexample

    Note que se necesita asignar el valor inicial de @c{contador};
    normalmente asignado a 1.

**** Ejemplo con contador incremental

     Supón que estás jugando en la playa y decides crear un triángulo de
     asteriscos, poniendo un asterisco en la primera fila, dos en la segunda
     fila, tres en la tercera fila y así:

     @smallexample
                      *
                     * *
                    * * *
                   * * * *
     @end smallexample

     (Hace 2500 años, Pitágoras y otras desarrollaron los principios de la
     teoría de números considerando preguntas como esta.)

     Supón que quieres saber cuántos asteriscos necesitarás crear para un
     triángulo con 7 filas

     Claramente, lo que necesitas hacer es añadir los números de 1 a
     7. Hay dos caminos para hacer esto; se puede comenzar con los
     números más pequeños, uno, y añadir la lista en secuencia, 1,
     2, 3, 4 y así; o empieza con el número más largo y
     añade la lista bajando: 7, 6, 5, 4 y así. Porque ambos
     mecanismos ilustran caminos comunes de escribir el bucle @c{while},
     crearemos dos ejemplos, uno contando hacia arriba y el otro contando
     hacia abajo. En este primer ejemplo, empezaremos con 1 y añadimos 2,
     3, 4 y así.

     Si se quiere sumar toda una lista de números, el camino más fácil para
     hacer eso es sumar todos los números a la vez. Sin embargo, si no se
     sabe cuántos números tendrá la lista, o si se requiere estar preparado
     para una lista muy larga, entonces se necesita diseñar la adición, esto
     es, repetir un proceso simple muchas veces en vez de hacer un proceso
     más complejo.

     Por ejemplo, en vez de añadir todos los asteriscos a la vez, lo que se
     puede hacer es añadir el número de asteriscos en la primera fila, 1,
     para el número en la segunda fila, 2, y entonces añadir el total de
     estas dos filas a la tercera fila, 3. Entonces se puede añadir el número
     en la cuarta fila, 4, al total de las primeras tres filas; y así.

     La característica crítica del proceso es que cada acción repetitiva sea
     simple. En este caso, en cada paso nosotros añadimos solo dos números,
     el número de asteriscos en la fila y el total ya encontrado. Este
     proceso de añadir dos números es repetido de nuevo y de nuevo hasta la
     última fila que ha sido añadida al total de todas las filas
     precedentes. En un bucle más complejo la acción repetitiva podría no ser
     tan simple, pero será tan simple como hacer todo a la vez.

**** Las partes de la definición de función

     El análisis precedente nos da los bonos de nuestra definición de
     función: primero, necesitaremos una variable que podemos llamar
     @c{total} que será el número total de asteriscos. Esto será el valor
     devuelto por la función.

     Segundo, sabemos que la función requerirá un argumento: este argumento
     será el número de filas en el triángulo. Eso puede llamarse
     @c{number-of-rows}.

     Finalmente, se necesita una variable para usarse como contador. Se
     podría llamar a esta variable @c{counter}, pero un nombre mejor es
     @c{row-number}. Debido a que lo que el contador hace en esta función es
     contar filas, y un programa debería escribirse para ser comprendido en
     la medida de lo posible.

     Cuando el intérprete Lisp primero empieza evaluando las expresiones de
     la función, el valor de @c{total} estaría asignado a cero, ya que no
     hemos añadido cualquier cosa a eso. Entonces la función añadiría el
     número de asteriscos en la primera fila al total, y entonces añade el
     número de asteriscos en la segunda al total, y entonces añade el número
     de asteriscos a la tercera fila al total, y así, hasta que no hay más
     filas a la izquierda para añadir.

     Ambos @c{total} y @c{row-number} se usan solo dentro de la función, así
     ellos pueden ser declarados como variables locales con @c{let} y valores
     iniciales dados. Claramente, el valor inicial para total sería
     0. El valor inicial de @c{row-number} sería 1, desde
     que se comienza con la primera fila. Esto significa que la frase
     @c{let} se parece a esto:

     @smallexample
         (let ((total 0)
               (row-number 1))
           @var{body}…)
     @end smallexample

     Después de que las variables internas se declaran y se asignan a sus
     valores iniciales se podría empezar el bucle @c{while}. La expresión que
     sirve como el test devolvería un valor de @c{t} para la verdad tan
     grande como el @c{row-number} que es menor o igual al
     @c{number-of-rows}. (La expresión devuelve cierto solo si el número de
     fila es menor que el número de filas en el triángulo, la última fila
     nunca será añadida al total; aquí el número de fila tiene que ser menor
     o igual el número de filas.))

     Lisp provee la función @c{<=} que devuelve cierto si el valor de su
     primer argumento es menor o igual al valor de su segundo argumento y
     falso de otro modo. Así la expresión que el @c{while} evaluará como si
     su test se vería como esto:

     @smallexample
       (<= row-number number-of-rows)
     @end smallexample

     El número de asteriscos puede encontrarse repetidamente añadiendo el
     número de asteriscos en una fila al total ya encontrado. Puesto que el
     número de asteriscos en la fila es igual al número de la fila, el total
     puede encontrarse añadiendo el número de filas al total. (Claramente, en
     una situación más compleja, el número de asteriscos en la fila podría
     ser relacionada al número de la fila en un camino más complicado; si
     este fuera el caso, el número de fila sería reemplazado por la expresión
     apropiada.)

     @smallexample
       (setq total (+ total row-number))
     @end smallexample

     Lo que esto hace es asignar el nuevo valor de @c{total} a ser igual a la
     suma de añadiendo el número de asteriscos en la fila al total previo.

     Después de configurar el valor de @c{total}, las condiciones deben ser
     establecidas para la siguiente repetición del bucle, si hay alguna. Esto
     se hace incrementando el valor de la variable @c{row-number}, que sirve
     como un contador. Después que la variable @c{row-number} ha sido
     incrementada, el true-or-false-test al principio del bucle @c{while}
     chequea si su valor es todavía menor o igual al valor del
     @c{number-of-rows} y si eso es, añade el nuevo valor de la variable
     @c{row-number} al @c{total} de la repetición del bucle.

     La función construida en Emacs Lisp @c{1+} añade 1 a un número, así la
     variable @c{row-number} puede ser incrementado con esta expresión:

     @smallexample
       (setq row-number (1+ row-number))
     @end smallexample

**** Poniendo la definición de la función junta

     Nosotros hemos creado las partes para la definición de la función; ahora
     necesitamos ponerlas juntas.

     Primero, los contenidos de la expresión @c{while}:

     @smallexample
       (while (<= row-number number-of-rows)   ; @r{true-or-false-test}
         (setq total (+ total row-number))
         (setq row-number (1+ row-number)))    ; @r{incremento}
     @end smallexample

     Tener la expresión @c{let} de varlist, se acerca a completar el cuerpo
     de la definición de función. Sin embargo, eso requiere un elemento
     final, la necesidad para la que es alguna cosa pequeña.

     El toque final es emplazar la variable @c{total} en una línea por sí
     misma después de la expresión @c{while}. De otro modo, el valor devuelto
     por la función completa es el valor de la última expresión que es
     evaluada en el cuerpo del @c{let}, y este es el valor devuelto por el
     @c{while} que es siempre @c{nil}.

     Esto puede no ser evidente a primera vista. Eso casi se ve como si la
     expresión de incremento es la última expresión de la función
     completa. Pero esta expresión es parte del cuerpo del @c{while}; eso es
     el último elemento de la lista que empieza con el símbolo @c{while}. Más
     allá, el bucle @c{while} completo es una lista con el cuerpo del
     @c{let}.

     En línea (@e{outline}), la función se parece a esto:

     @smallexample
       (defun @var{name-of-function} (@var{argument-list})
         "@var{documentation}…"
         (let (@var{varlist})
           (while (@var{true-or-false-test})
             @var{body-of-while}… )
           … ))                    ; @r{Necesita la expresión final aquí.}
     @end smallexample

     El resultado de evaluar el @c{let} es que lo que está yendo para
     devolver el @c{defun} desde el @c{let} que no está embebido con
     cualquier lista que contiene, excepto para la @c{defun} como un
     todo. Sin embargo, si el @c{while} es el último elemento de la expresión
     @c{let}, la función siempre devolverá @c{nil}. ¿Esto no es lo que
     quiero! En vez de eso, lo que queremos es el valor de la variable
     @c{total}. Eso devuelve simplemente emplazando el símbolo como el último
     elemento de la lista empezando con @c{let}. Eso se evalúa después de los
     elementos precedentes de la lista evaluada, que significa que eso se
     evaluó después de haber sido asignado el valor correcto para el total.

     Eso puede ser fácil de ver imprimiendo la lista empezando con @c{let}
     todo en una línea. Este formato hace evidente que las expresiones
     @var{varlist} y @c{while} son el segundo el tercer elementos de la lista
     empezando con @c{let}, y el @c{total} es el último elemento:

     @smallexample
       (let (@var{varlist}) (while (@var{true-or-false-test})
       @var{body-of-while}… ) total)
     @end smallexample

     Poniendo cualquier cosa junta, la definición de función @c{triangle} se
     parece a esto:

     @smallexample
       (defun triangle (number-of-rows)    ; @r{Versión con}
                                           ; @r{ contador de incremento.}
         "Añade el número de asteriscos en un triángulo.
       La primera fila tiene un asterisco, la segunda fila dos asteriscos,
       la tercera fila tres asteriscos, y así.
       El argumento es NUMBER-OF-ROWS."
         (let ((total 0)
               (row-number 1))
           (while (<= row-number number-of-rows)
             (setq total (+ total row-number))
             (setq row-number (1+ row-number)))
           total))
     @end smallexample

     Después de haber instalado @c{triangle} para evaluar la función, se
     puede probar. Aquí hay dos ejemplos:

     @smallexample
       (triangle 4)

       (triangle 7)
     @end smallexample

     La suma del primero de cuatro números es 10 y la suma de los primeros
     siete números es 28.

*** Bucle que se decrementa

    Otro camino común para escribir un bucle @c{while} es escribir el test
    así que determina si un contador es mayor que cero. Así tan largo es el
    contador mayor que cero, el bucle se repite. Pero cuando el contador es
    igual o menor que cero, el bucle se para. Para este trabajo, el contador
    tiene que empezar mayor que cero y entonces se hace más pequeño y pequeño
    por una forma que es evaluada repetidamente.

    El test será una expresión tal como @c{(> counter 0)} que devuelve @c{t}
    @e{cierto} si el valor de @c{counter} es mayor que cero, y @c{nil}
    @e{falso} si el valor de @c{counter} es igual a o menor que cero. La
    expresión hace que el número menor y menor puede ser un simple @c{setq}
    tal como @c{(setq counter (1- counter)}, donde @c{1-} es una función
    construida en Emacs Lisp que sustrae 1 de su argumento.

    La plantilla para decrementar el bucle @c{while} se ve así:

    @smallexample
      (while (> counter 0)                    ; @r{test-verdadero-o-falso}
        @var{body}…
        (setq counter (1- counter)))          ; @r{decremento}
    @end smallexample

**** Ejemplo con el contador que se decrementa

     Para ilustrar un bucle con un contador de decremento, reescribirá la
     función @c{triangle} así como el contador se decrementa a cero.

     Esto es lo inverso de la versión temprana de la función. En este caso,
     para encontrar cuántos asteriscos son necesarios para crear un triángulo
     con 3 filas, añade el número de asteriscos en la tercera fila, 3, para
     el número en la fila precedente, 2, y entonces añade el total de estas
     dos filas a la fila que lo precede, 1.

     Más allá, para encontrar el número de asteriscos en un triángulo con 7
     filas, añade el número de asteriscos en la fila siete, 7, al número en
     la fila precedente, que es 6, y entonces añade el total de estas dos
     filas a la fila esta que lo precede, que es 5, y así. Como en el ejemplo
     previo, cada adición solo involucra la adición de dos números, el total
     de las filas ya se añadió y el número de asteriscos en la fila que está
     siendo añadida al total. Este proceso de añadir dos números se repite de
     nuevo y de nuevo hasta que no haya más asteriscos que añadir.

     Sabemos con cuántos asteriscos empezar: el número de asteriscos en la
     última fila es igual al número de filas. Si el triángulo tiene siete
     filas, el número de asteriscos en la última fila es 7. Más allá, sabemos
     cuántos asteriscos están en la fila precedente: eso es uno menos que el
     número en la fila.

**** Las partes de la definición de función

     Empezamos con tres variables: el número total de filas en el triángulo;
     el número de asteriscos en una fila; y el número total de asteriscos,
     que es lo que queremos calcular. Estas variables pueden llamarse
     @c{number-of-rows}, @c{number-of-pebbles-in-row}, y @c{total},
     respectivamente.

     Ambos @c{total} y @c{number-of-pebbles-in-row} se usan solo dentro de la
     función y se declaran con @c{let}. El valor inicial de @c{total} sería
     cero. Sin embargo, el valor inicial de @c{number-of-pebbles-in-row}
     sería igual al número de filas en el triángulo, desde la adición
     empezará con la fila más larga.

     Esto significa que el principio de la expresión @c{let} se verá así:

     @smallexample
       (let ((total 0)
             (number-of-pebbles-in-row number-of-rows))
         @var{body}…)
     @end smallexample

     El número total de asteriscos puede encontrarse repetidamente añadiendo
     el número de asteriscos en una fila para el total ya encontrado, que, se
     evalúa repetidamente en la siguiente expresión:

     @smallexample
       (setq total (+ total number-of-pebbles-in-row))
     @end smallexample

     Después el @c{number-of-pebbles-in-row} se añade al @c{total}, el
     @c{number-of-pebbles-in-row} sería decrementado por uno, desde que la
     siguiente vez el bucle repite, la fila precedente será añadida al total.

     El número de asteriscos en una fila precedente es uno menos que el
     número de asteriscos en una fila, así la función Emacs Lisp construida
     @c{1-} puede usarse para computar el número de asteriscos de la fila
     precedente. Esto puede ser hecho con la siguiente expresión:

     @smallexample
       (setq number-of-pebbles-in-row
             (1- number-of-pebbles-in-row))
     @end smallexample

     Finalmente, sabemos que el bucle @c{while} pararía creando repetidas
     adiciones cuando no hay asteriscos en una fila. Así el test para el
     bucle @c{while} es simple:

     @smallexample
       (while (> number-of-pebbles-in-row 0)
     @end smallexample

**** Poniendo la definición de la función junta

     Se pueden poner estas expresiones juntas para crear una definición de
     función que funcione. Sin embargo, al examinarlas, encontraremos que una
     de la variables locales ¿es innecesaria!

     La definición de función se ve como esto:

     @smallexample
       ;;; @r{Primero la versión substractiva.}
       (defun triangle (number-of-rows)
         "Añade el número de asteriscos en un triángulo."
         (let ((total 0)
               (number-of-pebbles-in-row number-of-rows))
           (while (> number-of-pebbles-in-row 0)
             (setq total (+ total number-of-pebbles-in-row))
             (setq number-of-pebbles-in-row
                   (1- number-of-pebbles-in-row)))
           total))
     @end smallexample

     Como se dijo, esta función funciona.

     Sin embargo, no se necesita @c{number-of-pebbles-in-row}.

     Cuando la función @c{triangle} se evalúa, el símbolo @c{number-of-rows}
     será asociado al número, dando un valor inicial. Este número puede ser
     cambiado en el cuerpo de la función si hubiera una variable local, sin
     miedo de que tal cambio se efectuará el valor de la variable fuera de la
     función. Esto es una característica muy útil de Lisp; eso significa que
     la variable @c{number-of-rows} puede ser usada en cualquier lugar en la
     función donde @c{number-of-pebbles-in-row} se usa.

     Aquí hay una segunda versión de la función escrita un poco más
     limpiamente:

     @smallexample
       (defun triangle (number)                ; @r{Segunda versión.}
         "Devuelve la suma de números 1 a través de NUMBER inclusive."
         (let ((total 0))
           (while (> number 0)
             (setq total (+ total number))
             (setq number (1- number)))
           total))
     @end smallexample

     En breve, un bucle @c{while} apropiadamente escrito consistirá de tres
     partes:

     1. Un test que devuelva falso después de que el bucle ha repetido por sí
        mismo el número de veces correcto.

     2. Una expresión de la evaluación de que devolverá el valor deseado
        después de ser repetidamente evaluado.

     3. Una expresión para cambiar el valor pasado al true-or-false-test así
        el test devuelve falso después de que el bucle se ha repetido por sí
        mismo el número de veces correcto.

** Ahorra tiempo: @c{dolist} y @c{dotimes}

   Además de @c{while}, tanto @c{dolist} como @c{dotimes} proveen un
   bucle. Algunas veces estos son rápidos para escribir el bucle equivalente
   @c{while}. Ambos son macros Lisp. (Véase Sección @"(Macros) en @e(El
   Manual de Referencia GNU Emacs Lisp).)

   @c{dolist} funciona como un bucle @c{while} con ‘@Cc{cdr}s que bajan la
   lista’: @c{dolist} automáticamente ordena la lista cada vez que la lista
   hace bucles––toma la @Cc{cdr} de la lista––y asocia el @Cc{car} de cada
   versión ordenada de la lista al primero de sus argumentos.

   @c{dotimes} repite el bucle un número específico de veces: tu especificas
   el número.

*** La macro @c{dolist}

    Supón, por ejemplo, que quieres invertir una lista, así que “primero”,
    “segundo”, “tercero” llega a ser “tercero”, “segundo”, “primero”.

    En la práctica, usarías la función @c{reverse}, como esta:

    @smallexample
      (setq animales '(gacela jirafa leon tigre))

      (reverse animales)
    @end smallexample

    Aquí se ve cómo se podría invertir la lista usando un bucle @c{while}:

    @smallexample
      (setq animales '(gacela jirafa leon tigre))

      (defun reverse-list-with-while (list)
        "Usando while, invierte el orden de LIST."
        (let (value)  ; asegura que la lista comienza vacía
          (while list
            (setq value (cons (car list) value))
            (setq list (cdr list)))
          value))

      (reverse-list-with-while animales)
    @end smallexample

    Y aquí se ve cómo podría usarse la macro @c{dolist}:

    @smallexample
      (setq animales '(gacela jirafa leon tigre))

      (defun reverse-list-with-dolist (list)
        "Usando dolist, reverse, la orden de la LISTA."
        (let (value)  ; asegura que la lista empieza vacía
          (dolist (element list value)
            (setq value (cons element value)))))

      (reverse-list-with-dolist animals)
    @end smallexample

    En Info, se puede localizar su cursor después de cerrar paréntesis de
    cada expresión y escribir @k{C-x C-e}; en cada caso, se vería

    @smallexample
      (tigre leon jirafa gacela)
    @end smallexample

    en el área echo.

    Para este ejemplo, la función @c{reverse} existente es obviamente la
    mejor. El bucle @c{while} es solo como nuestro primer ejemplo (vease
    Seccion @l{Un bucle @c{while} y una lista}). El @c{while} primero chequea
    si la lista tiene elementos; si es así, eso construye una nueva lista
    añadiendo el primer elemento de la lista a la lista existente (que en la
    primera iteración del bucle es @c{nil}). Puesto que el segundo elemento
    está asignado en frente del segundo elemento, la lista es inversa.

    En la expresión que usa el bucle @c{while}, la expresión @c{(setq list
    (cdr list))} ordena la lista, así el bucle @c{while} finalmente
    para. Además, se proporciona la expresión @c{cons} con un nuevo primer
    elemento creando una nueva lista y se ordena en cada repetición del
    bucle.

    La expresión @c{dolist} hace lo mismo que la expresión @c{while}, excepto
    que la macro @c{dolist} hace algo del trabajo que se tiene que hacer
    cuando se escribe una expresión @c{while}.

    Al igual que el bucle @c{while}, tenemos el bucle @c{dolist}. Lo que es
    diferente es que automáticamente ordena la lista cada vez que se
    repite––eso es ‘recorrer los @Cc{cdr}s de la lista’ en sí––y eso
    automáticamente asocia el @Cc{car} de cada versión ordenada de la lista
    al primero de sus argumentos.

    En el ejemplo, el @Cc{car} de cada versión ordenada de la lista se
    refiere a usar el símbolo @'{element}, la lista en sí se llama @'{list},
    y el valor devuelto se llama @'{value}. El resto de la expresión
    @c{dolist} es el cuerpo.

    La expresión @c{dolist} asocia el @Cc{car} de cada versión ordenada de la
    lista al @c{element} y entonces evalúa el cuerpo de la expresión y repite
    el bucle. El resultado es devuelto en @c{value}.

*** La macro @c{dotimes}

    La macro @c{dotimes} es similar a @c{dolist}, excepto que el bucle se
    repite un número específico de veces.

    El primer argumento @c{dotimes} se asigna a los números 0, 1, 2 y así
    vuelve al bucle, y el valor del tercer argumento se devuelve. Se necesita
    proveer el valor del segundo argumento, que es cuántas veces la macro
    hace el bucle.

    Por ejemplo, lo siguiente asocia los números de 0 en adelante, pero no
    incluyendo, el número 3 al primer argumento, @var{número}, y entonces
    construye una lista de los tres números. (El primer número es 0, el
    segundo número es 1, y el tercer número es 2; esto crea un total de tres
    números en todo, empezando con cero como el primer número.)

    @smallexample
      (let (value)      ; de otro modo un valor es una variable vacía
        (dotimes (number 3 value)
          (setq value (cons number value))))

      ⇒ (2 1 0)
    @end smallexample

    @c{dotimes} devuelve @c{value}, así el camino para usar @c{dotimes} es
    para operar en alguna expresión el número de veces @var{number} y
    entonces devolver el resultado, como una lista o un átomo.

    Aquí hay un ejemplo de una @c{defun} que usa @c{dotimes} para añadir el
    número de asteriscos en un triángulo.

    @smallexample
      (defun triangle-using-dotimes (number-of-rows)
        "Usando dotimes, añade el número de asteriscos en un triángulo."
      (let ((total 0))  ; de otro modo un total es una variable vacía
        (dotimes (number number-of-rows total)
          (setq total (+ total (1+ number))))))

      (triangle-using-dotimes 4)
    @end smallexample

** Recursión

   Una función recursiva contiene código que hace que el intérprete Lisp
   llame a un programa que ejecute el código en sí, pero con argumentos
   ligeramente diferentes. El código ejecuta exactamente lo mismo porque eso
   tiene el mismo nombre. Sin embargo, incluso aunque el programa tenga el
   mismo nombre, no es la misma entidad. Eso es diferente. En la jerga, se
   dice es una ‘instancia’ diferente.

   Finalmente, si el programa se escribe correctamente, los ‘argumentos
   ligeramente diferentes’ llegan a ser suficientemente diferentes puesto que
   los primeros argumentos de la instancia final se pararán.

*** Construyendo robots: Extendiendo la metáfora

    Algunas veces es útil pensar en un programa en ejecución como un robot
    que hace un trabajo. Haciendo su trabajo, una función recursiva llama a
    un segundo robot para que le ayude. El segundo robot es idéntico al
    primero en cada paso, excepto que el segundo robot ayuda al primero y se
    han pasado diferentes argumentos en vez del primero.

    En una función recursiva, el segundo robot puede llamar a un tercero; y
    el tercero puede llamar a un cuarto, y así. Cada una de estos es una
    entidad diferente; pero todos son clones.

    Desde que cada robot tiene instrucciones ligeramente diferentes --- los
    argumentos diferirán desde un robot al siguiente––el último robot
    conocería cuando pare.

    Permite expandir la metáfora en el que un programa de ordenador es un
    robot.

    Una definición de función provee impresiones para un robot. Cuando se
    instala una definición de función, que es, cuando se evalúa una forma
    especial @c{defun}, se instala el equipamiento para construir robots. Eso
    es como si tu estuvieras en una fábrica, configurando una línea de
    ensamblaje. Los robots con el mismo nombre son construidos de acuerdo a
    las mismas impresiones. Así ellos tienen, como estaban, el mismo ‘número
    de modelo’, pero un diferente ‘número de serie’.

    Nosotros con frecuencia decimos que una función recursiva ‘se llama así
    misma’. Esto significa que las instrucciones en una función recursiva
    causa que el intérprete de Lisp ejecute una función diferente que tiene
    el mismo nombre y hace el mismo trabajo que el primero, pero con
    diferentes argumentos.

    Es importante que los argumentos difieran desde una instancia a la
    siguiente; de otro modo, el proceso nunca parará.

*** Las partes de una definición recursiva

    Una función recursiva típicamente contiene una expresión condicional que
    tiene tres partes:

    1. Un true-or-false-test que determina si la función se llama de nuevo,
       aquí se llama el @:{do-again-test}.

    2. El nombre de la función. Cuando este nombre se llama, es una nueva
       instancia de la función––un nuevo robot, así––se crea y se dice qué
       hacer.

    3. Una expresión que devuelve un valor diferente cada vez que la función
       se llama, aquí llamada la @:{next-step-expression}. Consecuentemente,
       el argumento (o argumentos) pasados a la nueva instancia de la función
       serán diferentes puesto que se pasa a la instancia previa. Esto causa
       la expresión condicional, que el @:{do-again-test}, devuelva falso
       después del número correcto de repeticiones.


    Las funciones recursivas pueden ser más simples que cualquier otro tipo
    de funciones. De manera profunda, cuando la gente empieza a usarlas, con
    frecuencia se miran así misteriosamente de manera tan simple como
    incompresible. Como montar en bicicleta, leer una función recursiva es
    duro al principio, pero después es simple.

    Hay varios patrones recursivos diferentes. Un patrón muy simple se parece
    a:

    @smallexample
      (defun @var{name-of-recursive-function} (@var{argument-list})
        "@var{documentation}…"
        (if @var{do-again-test}
          @var{body}…
          (@var{name-of-recursive-function}
               @var{next-step-expression})))
    @end smallexample

    Cada vez que una función recursiva es evaluada, una nueva instancia se
    crea y se dice qué hacer. Los argumentos le dicen a la instancia qué
    hacer.

    Un argumento se empareja al valor de la next-step-expresion. Cada
    instancia se ejecuta con un valor diferente de la next-step-expression.

    El valor en la next-step-expression es usado en la do-again-test.

    El valor devuelto por la next-step-expression es pasada a las nuevas
    instancias de la función, que lo evalúa (o alguna transformación de eso)
    para determinar si continuar o parar. El next-step-expression está
    diseñado así que el do-again-test devuelve falso cuando la función no se
    repetiría mucho.

    El do-again-test es algunas veces llamado la @:{condición de parar},
    puesto que sirve para parar las repeticiones cuando se devuelve falso.

*** Recursión con una lista

    El ejemplo de un bucle @c{while} que imprimió los elementos de una lista
    de números puede ser escrito recursivamente. Aquí está el código,
    incluyendo una expresión para asignar el valor de la variable
    @c{animales} a una lista.

    Si está leyendo esto en el Info de Emacs, se puede evaluar esta expresión
    directamente en Info. De otro modo, se debe copiar el ejemplo al búffer
    @f{*scratch*} y evalúa cada expresión aquí. Usa @k{C-u C-x C-e} para
    evaluar la expresión @c{(print-elements-recursively animals)} así que los
    resultado se imprimen en el búffer; de otro modo el intérprete Lisp
    intentará presionar los resultados dentro de una línea del área echo.

    También, posiciona tu cursor inmediatamente después del último paréntesis
    que cierra la función @c{print-elements-recursively}, antes del
    comentario. De otro modo, el intérprete Lisp intentará evaluar el
    comentario.

    @smallexample
      (setq animales '(gacela jirafa leon tigre))

      (defun print-elements-recursively (list)
        "Imprime cada elemento de la LISTA de la línea en
        sí. Usa recursión."
        (when list                            ; @r{do-again-test}
              (print (car list))              ; @r{body}
              (print-elements-recursively     ; @r{recursive call}
               (cdr list))))                  ; @r{next-step-expression}

      (print-elements-recursively animales)
    @end smallexample

    La función @c{print-elements-recursively} primero chequea si hay
    cualquier contenido en la lista; si lo hay, la función imprime el primer
    elemento de la lista, el @Cc{car} de la lista. Entonces la función se
    ‘invoca en sí’, pero da a sí mismo como su argumento, no la lista
    completa, pero el segundo y subsiguientes elementos de la lista, el
    @Cc{cdr} de la lista.

    Pon otro camino, si la lista no está vacía, la función invoca otra
    instancia de código que es similar al código inicial, pero es un hilo
    diferente de ejecución, con diferentes argumentos a la primera instancia.

    Veamos una manera más, si la lista no está vacía, el primer robot
    ensambla un segundo robot que cuenta qué hacer; el segundo robot es un
    individuo diferente desde el principio, pero es el mismo modelo.

    Cuando la segunda evaluación ocurre, la expresión @c{when} se evalúa y si
    es verdad, se imprime el primer elemento de la lista que recibe como su
    argumento (que es el segundo elemento de la lista original). Entonces la
    función ‘llamarse a sí mismo’ con la @Cc{cdr} del @Cc{cdr} de la lista
    original.

    Note que aunque nosotros decimos que la función ‘se llama a sí misma’, lo
    que significa es que el intérprete Lisp ensambla e instruye una nueva
    instancia del programa. La nueva instancia es un clon del primero, pero
    es un individuo separado.

    Cada vez que la función ‘se invoca a sí misma’, se invoca a sí misma en
    una versión de la lista original. Eso crea una nueva instancia que
    funciona como una lista ordenada.

    Finalmente, la función se invoca a sí misma en una lista vacía. Eso crea
    una nueva instancia cuyo argumento es @c{nil}. La expresión condicional
    chequea el valor de @c{lista}. Desde el valor de @c{lista} a @c{nil}, la
    expresión @c{when} devuelve falso así la then-part no está evaluada. La
    función es como un todo que entonces devuelve @c{nil}.

    Cuando se evalúa la expresión @c{(print-elements-recursively animals)} en
    el búffer @f{*scratch*}, se verá este resultado:

    @smallexample
      gacela

      jirafa

      leon

      tigre
      nil
    @end smallexample

*** Recursión en lugar de un contador

    La función @c{triangle} describe en una sección previa si puede ser
    escrita recursivamente. Se ve así:

    @smallexample
      (defun triangle-recursively (number)
        "Return the sum of the numbers 1 through NUMBER inclusive.
      Uses recursion."
        (if (= number 1)                    ; @r{do-again-test}
            1                               ; @r{then-part}
          (+ number                         ; @r{else-part}
             (triangle-recursively          ; @r{recursive call}
              (1- number)))))               ; @r{next-step-expression}

      (triangle-recursively 7)
    @end smallexample

    Se puede instalar esta función evaluando y entonces se intenta evaluar
    @c{(triangle-recursively 7)}. (Recuerda poner tu cursor inmediatamente
    después de los últimos paréntesis de la definición de la función, antes
    del comentario.) La función se evalúa a 28.

    Para comprender cómo funciona la función, hay que considerar qué ocurre
    en varios casos cuando la función se le pasa 1, 2, 3, o 4 como el valor a
    su argumento.

    Primero, veamos qué ocurre si el valor del argumento es 1.

    La función tiene una expresión @c{if} después de la cadena de
    documentación. Esto chequea si el valor de @c{number} es igual a 1; si es
    así, Emacs evalúa la then-part de la expresión @c{if}, que devuelve el
    número 1 como el valor de la función. (Un triángulo con una fila tiene un
    asterisco dentro.)

    Supón, sin embargo, que el valor del argumento es 2. En este caso, Emacs
    evalúa la parte else de la expresión @c{if}.

    La parte else consiste de una adición, la llamada recursiva para
    @c{triangle-recursively} y una acción de decremento; y se ve así:

    @smallexample
      (+ number (triangle-recursively (1- number)))
    @end smallexample

    Cuando Emacs evalúa esta expresión, la expresión interna es evaluada
    primero; entonces las otras partes en secuencia. Aquí están los pasos en
    detalle:

    - Paso 1 Evalúa la expresión interna. -:

      La expresión interna es @c{(1- number)} así Emacs decrementa el valor
      de @c{number} desde 2 a 1.

    - Paso 2 Evalúa la función @c{triangle-recursively}.

      El intérprete Lisp crea una instancia individual de
      @c{triangle-recursively}. Eso no importa que esta función está
      contenida con sí misma. Emacs pasa el resultado Paso 1 como el
      argumento usado por esta instancia de la función
      @c{triangle-recursively}

      En este caso, Emacs evalúa @c{triangle-recursively} con un argumento
      de 1. Esto significa que esta evaluación de @c{triangle-recursively}
      devuelve 1.

    - Paso 3 Evalúa el valor de @c{number}. -:

      La variable @c{number} es el segundo elemento de la lista que empieza
      con @c{+}; su valor es 2.

    - Paso 4 Evalúa la expresión @c{+}. -:

      La expresión @c{+} recibe dos argumentos, el primero desde la
      evaluación de @c{number} (Paso 3) y el segundo desde la evaluación de
      @c{triangle-recursively} (Paso 2).

      El resultado de la adición es la suma de 2 + 1, y el número 3 es
      devuelto, que es correcto. Un triángulo con dos filas tiene tres
      asteriscos ahí.  @end table

**** Un argumento de 3 o 4

     Supón que @c{triangle-recursively} es llamado con un argumento de
     3.

     - Paso 1 Evalúa la do-again-test. -:

       La expresión @c{if} se evalúa primero. Esto es el test do-again
       y devuelve falso, así la parte else de la expresión
       @c{if} es evaluada. (Note que en este ejemplo, el do-again-test
       causa la función para llamarse a sí misma cuando eso
       se chequea como falso, no cuando eso se chequea como verdadero.)

     - Paso 2 Evalúa la expresión propia de la parte else. -:

       La expresión propia de la parte que es evaluada, decrementa 3 a
       2. Esta la next-step-expression.

     - Paso 3 Evalúa la función @c{triangle-recursively}. -:

       El número 2 es pasado a la función @c{triangle-recursively}.

       Nosotros ya sabemos qué ocurre cuando Emacs evalúa
       @c{triangle-recursively} con un argumento de 2. Después de ir a
       través de la secuencia de acciones descritas temprano, eso devuelve
       un valor de 3. Así que es lo que ocurrirá
       aquí.

     - Paso 4 Evalúa la adición. -:

       3 será pasado como un argumento para la adición y será añadido
       al número con el que la función se llamó, que es 3.
       @end table


     El valor devuelto por la función como un todo será 6.

     Ahora que sabemos qué ocurrirá cuando @c{triangle-recursively} llama con
     un argumento 3, es evidente lo que ocurrirá si se llama con el argumento
     4:

     @blood
       En la llamada recursiva, la evaluación de

       @smallexample
         (triangle-recursively (1- 4))
       @end smallexample

       devuelve el valor de evaluar

       @smallexample
         (triangle-recursively 3)
       @end smallexample

       que es 6 este valor será añadido a 4 por la adición en la tercera
       línea.
     @end blood


     El valor devuelto por la función como un todo será 10.

     Cada vez que @c{triangle-recursively} se evalúa, se interpreta una
     versión de sí misma––una instancia diferente en sí––con un pequeño
     argumento, hasta que el argumento es suficientemente pequeño así que no
     se evalúa en sí.

     Note que este particular diseño para una función recursiva requiere que
     las operaciones sean diferidas.

     Antes de que @c{(triangle-recursively 7)} pueda calcular su respuesta,
     debe llamarse a @c{(triangle-recursively 6)}; y antes a
     @c{(triangle-recursively 5)}; y así. Esto es decir, que el cálculo de
     @c{(triangle-recursively 7)} a crear debe ser diferido hasta que
     @c{(triangle-recursively 6)} haga su cálculo; y @c{(triangle-recursively
     5)} lo complete; y así.

     Si cada una de estas instancias de @c{triangle-recursively} son pensadas
     como diferentes robots, el primer robot debe esperar por el segundo para
     completar su trabajo, que debe esperar hasta los terceros completos, y
     así.

     Hay un camino alrededor de este tipo de espera, que se discutirá en
     @l{Recursión sin diferir}.

*** Ejemplo de recursión usando @c{cond}

    La versión de @c{triangle-recursively} antes descrita se escribió con la
    forma especial @c{if}. Eso puede también ser escrita usando otra forma
    especial llamada @c{cond}. El nombre de la forma especial @c{cond} es una
    abreviación de la palabra @'{conditional}.

    Aunque la forma especial @c{cond} no se usa con frecuencia en las fuentes
    de Emacs como @c{if}, se usa con suficiente frecuencia para justificarse
    explicando.

    La plantilla para una expresión @c{cond} se parece a:

    @smallexample
      (cond
       @var{body}…)
    @end smallexample

    donde el @var{body} es una serie de listas.

    Escrito de manera más completa, la plantilla se parece a esto:

    @smallexample
      (cond
       (@var{first-true-or-false-test} @var{first-consequent})
       (@var{second-true-or-false-test} @var{second-consequent})
       (@var{third-true-or-false-test} @var{third-consequent})
        …)
    @end smallexample

    Cuando el intérprete Lisp evalúa la expresión @c{cond}, evalúa el primer
    elemento (el @Cc{car} o true-or-false-test) de la primera expresión en
    una serie de expresiones con el cuerpo del @c{cond}.

    Si el true-or-false-test devuelve @c{nil} el resto de esta expresión, el
    consecuente, se descarta y el true-or-false-test de la siguiente
    expresión se evalúa. Cuando una expresión encuentra un true-or-false-test
    cuyo valor no es @c{nil}, el consecuente de esta expresión se evalúa. El
    consecuente puede ser una o más expresiones. Si el consecuente consiste
    de más de una expresión, las expresiones son evaluadas en secuencia y el
    valor del último se devuelve. Si la expresión no tiene un consecuente, se
    devuelve el valor del true-or-false-test.

    Si ninguno del test true-or-false-tests es cierto, la expresión @c{cond}
    devuelve @c{nil}.

    Escrito usando @c{cond}, la función @c{triangle} se parece a esto:

    @smallexample
      (defun triangle-using-cond (number)
        (cond ((<= number 0) 0)
              ((= number 1) 1)
              ((> number 1)
               (+ number (triangle-using-cond (1- number))))))
    @end smallexample

    En este ejemplo, el @c{cond} devuelve 0 si el número es menor o igual a
    0, eso devuelve 1 si el número es 1 y eso evalúa @c{(+ number
    (triangle-using-cond (1- number)))} si el número es más grandes que 1.

*** Patrones recursivos

    Aquí hay tres patrones recursivos. Cada uno involucra una lista. La
    recursión no se necesita para involucrar listas, pero Lisp se diseña para
    listas y esto provee un sentido de sus capacidades primarias.

**** Patrón recursivo: @e{every}

     En el patrón recursivo @c{every}, se desarrolla una acción por cada
     elemento de una lista.

     El patrón básico es:

     - Si una lista es vacía, devuelve @c{nil}.

     - Si no, se va al principio de la lista (el @Cc{car} de la lista)
       actuando

       - a través de una llamada recursiva por la función en el resto (el
         @Cc{cdr}) de la lista,

       - y, opcionalmente, se combina el elemento sobre el que actúa, usando
         @c{cons}, con los resultados de actuar en el resto.


     Aquí está el ejemplo:

     @smallexample
       (defun square-each (numbers-list)
         "El cuadrado de cada LISTA DE NUMEROS, recursivamente."
         (if (not numbers-list)                ; test-hazlo-de-nuevo
             nil
           (cons
            (* (car numbers-list) (car numbers-list))
            (square-each (cdr numbers-list))))) ; expresion-siguiente-paso

       (square-each '(1 2 3))
           ⇒ (1 4 9)
     @end smallexample

     Si @c{numbers-list} está vacío, no hay que hacer nada. Pero si tiene
     contenido, se construye una lista combinando el cuadrado del primer
     número en la lista con el resultado de la llamada recursiva.

     (El ejemplo sigue el patrón exactamente: se devuelve @c{nil} si la lista
     de números es vacía. En la práctica, se escribiría el condicional, así
     se ejecuta la acción cuando la lista de números no es vacía.)

     La función @c{print-elements-recursively} (Vease Sección @l{Recursión
     con una Lista}) es otro ejemplo de un patrón @c{every}, excepto en este
     caso, en vez de traer los resultados juntos usando @c{cons}, se imprime
     cada elemento de salida.

     La función @c{print-elements-recursively} se parece a esto:

     @smallexample
       (setq animales '(gacela jirafa leon tigre))

       (defun print-elements-recursively (list)
         "Imprime cada elemento de la LISTA de la línea en
         sí. Usa recursión."
         (when list                            ; @r{do-again-test}
               (print (car list))              ; @r{body}
               (print-elements-recursively     ; @r{recursive call}
                (cdr list))))                  ; @r{next-step-expression}

       (print-elements-recursively animales)
     @end smallexample

     El patrón para @c{print-elements-recursively} es:

     - Cuando la lista está vacía, no hacer nada.

     - Pero cuando la lista tiene al menos un elemento,

       - actúa al principio de la lista (el @Cc{car} de la lista),

       - y crea una llamada recursiva en el resto (el @Cc{cdr} de la lista).

**** Patrón recursivo: @e{accumulate}

     Otro patrón recursivo es llamado el patrón @c{accumulate}. En el patrón
     recursivo @c{accumulate}, se realiza una acción en cada elemento de una
     lista y el resultado de esta acción se acumula con los resultados de
     desarrollar la acción en otros elementos.

     Esto es como ‘cada’ patrón usando @c{cons}, excepto que este @c{cons} no
     se esté usando, pero que algún otro combine.

     El patrón es:

     - Si una lista está vacía, devuelve cero o alguna otra constante.

     - Lo demás, actúa al principio de la lista (el @Cc{car} de la lista),

       - y combinar este elemento que actúa, usando @c{+} o alguna otra
         función de combinación, con

       - una llamada recursiva por la función en el resto (el @Cc{cdr}) de la
         lista.


     Aquí hay un ejemplo:

     @smallexample
       (defun add-elements (numbers-list)
         "Añade los elementos de NUMBERS-LIST juntos."
         (if (not numbers-list)
             0
           (+ (car numbers-list) (add-elements (cdr numbers-list)))))

       (add-elements '(1 2 3 4))
           ⇒ 10
     @end smallexample

     Véase Sección @l{Creando una lista de ficheros}, para un ejemplo del
     patrón acumulado.

**** Patrón recursivo: @e{keep}

     Un tercer patrón es llamado el patrón @c{keep}. En el patrón recursivo
     @c{keep}, se chequea cada elemento de una lista; se actúa en el elemento
     y los resultados se guardan solo si el elemento encuentra un criterio.

     De nuevo, esto se parece al patrón ‘every’, excepto que el elemento se
     descarta a menos que se encuentre un criterio.

     El patrón tiene tres partes:

     - Si una lista es vacía, devuelve @c{nil}.

     - Lo demás, si el principio de la lista (el @Cc{car} de la lista) pasa
       un test

       - actua en este elemento y lo combina, usando @c{cons} con

       - una llamada recursiva por la función en el resto (el @Cc{cdr} de la
         lista.

     - De otro modo, si el principio de la lista (el @Cc{car} de la lista)
       falla el test @itemize @item para en este elemento, @item y,
       recursivamente llama la función al resto (el @Cc{cdr}) de la lista.

     Aquí hay un ejemplo que usa @c{cond}:

     @smallexample
       (defun manten-tres-letras (lista-palabras)
         "Guarda 3 palabras en WORD-LIST."
         (cond
          ;; Primero do-again-test: stop-condition
          ((not lista-palabras) nil)

          ;; Segundo do-again-test: cuando actuar
          ((eq 3 (length (symbol-name (car lista-palabras))))
           ;; combina el elemento que actúa con la llamada recursiva en la
           ;; lista ordenada
           (cons (car lista-palabras) (manten-tres-letras (cdr lista-palabras))))

          ;; Tercero do-again-test: cuando se descarte el elemento;
          ;; llama recursivamente a la lista ordenada con la next-step expression
          (t (manten-tres-letras (cdr lista-palabras)))))

       (manten-tres-letras '(uno dos tres cuatro cinco seis))
           ⇒ (uno dos)
     @end smallexample

     Eso va sin decir que no se necesita usar @c{nil} como si el test para
     cuando para; y se puede, de acuerdo, combinar estos patrones.

*** Recursión sin diferir

    Permita considerar de nuevo qué ocurre con la función
    @c{triangle-recursively}. Nosotros encontraremos que los cálculos
    difieran hasta que todo pueda ser hecho.

    Aquí está la definición de función:

    @smallexample
      (defun triangle-recursively (number)
        "Devuelve la suma de los números 1 a través de NUMBER inclusive
      Usa recursión."
        (if (= number 1)                    ; @r{do-again-test}
            1                               ; @r{then-part}
          (+ number                         ; @r{else-part}
             (triangle-recursively          ; @r{recursive call}
              (1- number)))))               ; @r{next-step-expression}
    @end smallexample

    ¿Qué ocurre cuando se llama a esta función con un argumento de 7?

    La primera instancia de la función @c{triangle-recursively} añade el
    número 7 al valor devuelto por una segunda instancia de
    @c{triangle-recursively}, una instancia que ha pasado un argumento
    de 6. Así, el primer cálculo es:

    @smallexample
      (+ 7 (triangle-recursively 6))
    @end smallexample

    La primera instancia de @c{triangle-recursively} --- se puede querer
    pensar como un pequeño robot––no puede completar su trabajo. Eso debe
    manejar el cálculo para @c{(triangle-recursively 6)} a una segunda
    instancia del programa, a un segundo robot. Este segundo individuo es
    completamente diferente desde el primero; eso es, en la jerga, una
    ‘diferente instanciación’. O, poner otro camino, eso es un diferente
    robot. Eso es el mismo modelo como el primero; eso calcula números de
    triángulo recursivamente; pero eso tiene un número de serie diferente.

    ¿Y qué hace @c{(triangle-recursively 6)} devuelve? Eso devuelve el número
    6 añadido al valor devuelto para evaluar @c{triangle-recursively} con un
    argumento de 5. Usando la metáfora del robot, eso cuestiona todavía otro
    robot para ayudarle.

    Ahora el total es:

    @smallexample
      (+ 7 6 (triangle-recursively 5))
    @end smallexample

    ¿Y qué ocurre después?

    @smallexample
      (+ 7 6 5 (triangle-recursively 4))
    @end smallexample

    Cada vez que @c{triangle-recursively} es llamado, excepto por la última
    vez, eso crea otra instancia del programa––otro robot --- y pregunta para
    crear un cálculo.

    Finalmente, la adición completa es de la siguiente manera:

    @smallexample
      (+ 7 6 5 4 3 2 1)
    @end smallexample

    Este diseño para la función difiere el cálculo del primer paso hasta el
    segundo puede ser hecho, y difiere esto hasta que el tercero puede ser
    hecho, y así. Cada defermento significa el ordenador debe recordar que
    está siendo esperado dentro. Esto no es un problema cuando hay solo unos
    pocos pasos, como en este ejemplo. Pero eso puede ser un problema cuando
    hay más pasos.

*** No hay solución pospuesta

    La solución al problema de operaciones pospuestas es para escribir en una
    manera que no posponga operaciones@n{11}. Esto requiere escribir a un
    patrón diferente, con frecuencia uno que involucra escribiendo dos
    definiciones de función, una función de ‘inicialización’ y una función
    ‘ayuda’.

    La función ‘inicializacion’ configura el trabajo; la función ‘ayudante’
    hace el trabajo.

    Aquí hay dos definiciones para añadir números. Son así de simple, aunque
    se encuentre duro de comprender.

    @smallexample
      (defun triangle-initialization (number)
        "Devuelve la suma de los números 1 a través de NUMBER inclusive.
      Este es el componente de ‘inicialización’ de una función dúo que
      usa recursión"
        (triangle-recursive-helper 0 0 number))
    @end smallexample

    @smallexample
      (defun triangle-recursive-helper (sum counter number)
        "Devuelve SUM, usando COUNTER, a través de NUMBER inclusive.
      Este es el componente ‘helper’ de unas dos funciones
      que usan recursión."
        (if (> counter number)
            sum
          (triangle-recursive-helper (+ sum counter)  ; @r{suma}
                                     (1+ counter)     ; @r{contador}
                                     number)))        ; @r{número}
    @end smallexample

    Instalar ambas definiciones de función por evaluarlo, entonces llama a
    @c{triangle-initialization} con 2 filas:

    @smallexample
      (triangle-initialization 2)
          ⇒ 3
    @end smallexample

    La función ‘inicialización’ llama la primera instancia de la función
    ‘ayudante’ con tres argumentos: cero, cero, y un número que es el número
    de filas en el triángulo.

    Los primeros dos argumentos pasaron a la función ‘ayuda’ son valores de
    inicialización. Estos valores son cambiados cuando
    @c{triangle-recursive-helper} invocan nuevas instancias.@n{12}

    Permítase ver que ocurre cuando tenemos un triángulo que tiene una
    fila. (¿Este triángulo tendrá un asterisco dentro!)

    @c{triangle-initialization} llamará su ayudante con los argumentos @c{0 0
    1}. Esta función ejecutará el test condicional si @c{(> counter number)}:

    @smallexample
      (> 0 1)
    @end smallexample

    y encuentra que el resultado es falso, así invocará la else-part de la
    claúsula @c{if}:

    @smallexample
          (triangle-recursive-helper
           (+ sum counter)  ; @r{sum más counter} ⇒ @r{sum}
           (1+ counter)     ; @r{incrementa counter} ⇒ @r{counter}
           number)          ; @r{number parece lo mismo}
    @end smallexample

    que computará primero:

    @smallexample
      (triangle-recursive-helper (+ 0 0)  ; @r{sum}
                                 (1+ 0)   ; @r{counter}
                                 1)       ; @r{number}
      que es:

      (triangle-recursive-helper 0 1 1)
    @end smallexample

    De nuevo, @c{(> counter number)} será falso, así de nuevo, el intérprete
    Lisp evaluará @c{triangle-recursive-helper}, creando una nueva instancia
    con nuevos argumentos.

    Esta nueva instancia será;

    @smallexample
          (triangle-recursive-helper
           (+ sum counter)  ; @r{suma más contador} ⇒ @r{sum}
           (1+ counter)     ; @r{incrementar contador} ⇒ @r{contador}
           number)          ; @r{número empieza lo mismo}

      que es:

      (triangle-recursive-helper 1 2 1)
    @end smallexample

    En este caso, el test @c{(> counter number)} ¿será cierto!  Así la
    instancia devolverá el valor de la suma, que será 1, como se espera.

    Ahora, permite pasar @c{triangle-initialization} un argumento de 2, para
    encontrar cuántos asterisco hay en un triángulo con dos filas.

    Esta función llama @c{(triangle-recursive-helper 0 0 2)}.

    En fases, las instancias llamadas serán:

    @smallexample
                                @r{suma contador número}
      (triangle-recursive-helper 0    1       2)

      (triangle-recursive-helper 1    2       2)

      (triangle-recursive-helper 3    3       2)
    @end smallexample

    Cuando la última instancia se llama, el @c{(> counter number)} se chequea
    si será cierto, así la instancia devolverá el valor de @c{sum}, que
    será 3.

    Este tipo de patrón ayuda cuando estás escribiendo funciones que puede
    usar recursos en un ordenador.

** Ejercicio de bucles

   - Escribe una función similar a @c{triangle} en el que cada fila tiene un
     valor que es la raíz del número de la fila. Usa un bucle @c{while}.

   - Escribe una función similar para @c{triangle} que multiplique en vez de
     añadir los valores.

   - Reescribe estas dos funciones recursivamente. Reescribe estas funciones
     usando @c{cond}.

   - Escribe una función para el modo Texinfo que crea una entrada índice al
     principio de un párrafo para cada @'{@@dfn} con el párrafo. (En un
     fichero Texinfo, @'{@@dfn} marca una definición. El libro es escrito en
     Texinfo.)

     Muchas de las funciones necesitarán ser descritas en dos de los
     capítulos, @l{Cortando y almacenando texto} y @l{Pegando texto}. Si usas
     @c{forward-paragraph} para poner la entrada índice al principio del
     párrafo, tendrá que usar @k{C-h f} (@c{describe-function}) para
     encontrar cómo conseguir que el comando vaya hacia atrás.


   Para más información, ver “Indicando Definiciones, Comandos, etc.” en
   @e{Texinfo} el @e{Formato de Documentación de GNU}.

* Búsquedas de expresiones regulares

  Las búsquedas expresiones regulares son usadas extensivamente en GNU
  Emacs. Las dos funciones @c{forward-sentence} y @c{forward-paragraph},
  ilustran estas búsquedas bien. Usan expresiones regulares para encontrar
  donde mover el punto. La frase ‘expresión regular’ es con frecuencia
  escrita como ‘regexp’.

  Las búsquedas de expresiones regulares son descritas en Seccion @"{Búsqueda
  de Expresión Regular} en @e{El Manual de GNU Emacs}, tan bien como en
  Seccion @"{Expresiones Regulares} @e{El Manual de Referencia de GNU Emacs
  Lisp}. Escribiendo este capítulo, estoy presuponiendo que tiene al menos
  una familiaridad con esto. El mayor punto para recordar es que las
  expresiones regulares te permiten buscar patrones tan bien como para
  cadenas literales de caracteres. Por ejemplo, el código en
  @c{forward-sentence} busca para el patrón de posibles caracteres que
  podrían marcar el fin de una frase, y mueve el punto al otro lado.

  Antes de mirar en el código la función @c{forward-sentence}, es valorable
  considerar que el patrón que marca el fin de una frase debe estar. El
  patrón se discute en la siguiente sección; siguiendo que es una descripción
  de la expresión regular de búsqueda, @c{re-search-forward}. La función
  @c{forward-sentence} es descrito en la sección siguiente. Finalmente, la
  función @c{forward-paragraph} es descrito en la última sección de este
  capítulo. @c{forward-paragraph} es una función compleja que introduce
  varias funcionalidades.

** La expresión regular para @c{sentence-end}

   El símbolo @c{sentence-end} se asocia al patrón que marca el fin de una
   frase. ¿Cuál sería esta expresión regular?

   Claramente, una frase puede ser finalizada por un periodo, una marca de
   inicio de interrogación, o una marca de exclamación. Puesto que viene del
   inglés, solo las claúsulas que finalizan con uno de estos tres caracteres
   deberían ser consideradas al fin de una frase. Esto significa que el
   patrón incluiría el conjunto de caracteres:

   @smallexample
     [.?!]
   @end smallexample

   Sin embargo, no queremos que @c{forward-sentence} salte a un periodo, una
   marca de pregunta, o una marca de exclamación, porque tal carácter podría
   ser usado en el medio de una frase. Un periodo, por ejemplo, se usa
   después de abreviaciones. Así, otra información es necesaria.

   De acuerdo a la convención, escribe dos espacios después de cada frase,
   pero solo un espacio después de un periodo, una marca de pregunta, o una
   marca de exclamación seguida por dos espacios es un buen indicador de un
   fin de frase. Sin embargo, en un fichero, los dos espacios pueden ser un
   tabulador o el fin de una línea. Esto significa que la expresión regular
   incluiría estos tres ítems como alternativas.

   Este grupo de alternativas se parece a esto:

   @smallexample
     \\($\\| \\|  \\)
            ^   ^^
           TAB  SPC
   @end smallexample

   Aquí, @'{$} indica el fin de la línea, y yo he apuntado donde el tab y dos
   espacios están insertados en la expresión. Ambos están insertados poniendo
   los caracteres actuales dentro de la expresión.

   Dos barras invertidas, @'{\\}, se requiere antes de los paréntesis y
   barras verticales: la primera barra invertida cita la siguiente barra
   invertida en Emacs; y el segundo indica que el siguiente caracter, el
   paréntesis o la barra vertical, es especial.

   También, una frase puede ser seguida por uno o más retornos de carro, como
   este:

   @smallexample
     [
     ]*
   @end smallexample

   Como en los tabuladores y espacios, un retorno de carro se inserta dentro
   de una expresión regular insertándolo literalmente. El asterisco indica
   que el @k{RET} se repite cero o más veces.

   Pero una frase no consiste solo en un periodo, una marca de pregunta o una
   marca de exclamación seguida por espacios apropiados: una marca de cerrar
   comillas o cerrar un paréntesis de algún tipo puede preceder el
   espacio. En realidad más de una marca o paréntesis pueden preceder el
   espacio. Estas requieren una expresión que se parezca a:

   @smallexample
     []\"')@}]*
   @end smallexample

   En esta expresión, el primer @'{]} es el primer caracter en la expresión;
   el segundo caracter es @'{"}, que está precedido por un @'{\} para contar
   Emacs el @'{"} @e{no} es especial. Los últimos tres caracteres son @'{'},
   @'{)}, y @'{@}}.

   Todo esto sugiere que el patrón de la expresión regular para asociar el
   fin de una frase sería; y, profundamente, si se evalúa @c{sentence-end} y
   encuentra que se devuelve el valor siguiente:

   @smallexample
     sentence-end
          ⇒ "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
     ]*"
   @end smallexample

   (Bien, no en GNU Emacs 22; porque es un esfuerzo crear el proceso simple y
   manejar más símbolos y lenguajes. Cuando el valor de @c{sentence-end} es
   @c{nil}, entonces usa el valor definido por la función @c{sentence-end} es
   @c{nil}, entonces usa el valor definido por la función
   @c{sentence-end}. (Aquí se usa la diferencia entre un valor y una función
   en Emacs Lisp.) La función devuelve un valor construido desde las
   variables @c{sentence-end-base}, @c{sentence-end-double-space},
   @c{sentence-end-without-period}, y @c{sentence-end-without-space}. La
   variable crítica es @c{sentence-end-base}; su valor global es similar a
   uno descrito debajo pero también contiene marcas de cita
   adicionales. Estas tienen diferentes grados de curvas. La variable
   @c{sentence-end-without-period}, cuando es verdad, dice a Emacs que una
   frase puede finalizar sin un periodo tal como texto en Thai.)

   @ignore
     (Note that here the @k{TAB}, two spaces, and @k{RET} are shown literally
     in the pattern.)

     This regular expression can be deciphered as follows:

     - [.?!] -:

       La primera parte del patrón son los tres caracteres, un periodo, una
       pregunta marca y un marca de exclamación, con paréntesis cuadrados. El
       patrón empieza con uno un otro de estos caracteres.

     - []\"')@}]* -:

       La segunda parte del patrón es el grupo de cerrar paréntesis y marcas
       de cita, que pueden aparecer cero o más veces. Estos pueden seguir el
       periodo, marca de pregunta o marca de exclamación. En una expresión
       regular la barra, @'{\}, seguido por las dobes comillas, @'{"}, indica
       los casos de caracteres string-quote. Normalmente, las dobles comillas
       es el único caracter en esta clase. El asterisco, @'{*}, indica que
       los ítems en el grupo previo (el grupo alrededor por comillas
       cuadradas, @'{[]} puede ser repetido cero o más veces.@item \\($\\|
       \\| \\) La tercera parte del patrón es uno u otro de: si el fin de una
       línea, o dos espacios en blanco, o un tabulador. Las barras invertidas
       dobles son usadas para prevenir a Emacs desde leer los paréntesis y
       barras verticales como parte del patrón de búsqueda; los paréntesis
       son usados para marcar el grupo y las barras verticales usadas para
       indicarse que los patrones de un lado de ellos son alternativas. El
       signo del dólar es usados para indicar el fin de una línea y ambos
       espacios y el tabulador son cada uno insertados como están para
       indicar lo que ellos son.@item [@k{RET}]* Finalmente, la última parte
       del patrón indica que el fin de la línea o el espacio en blanco
       siguiendo el periodo, marca de pregunta o marca de exclamación, pero
       no necesita, el retorno de carro es insertado como un retorno de carro
       devuelve paréntesis cuadrados pero aquí eso muestra @k{RET}.
   @end ignore

** La función @c{re-search-forward}

   La función @c{re-search-forward} es similar a la función
   @c{search-forward}. (Véase Sección @l{La Función @c{search-forward}}.)

   @c{re-search-forward} busca una expresión regular. Si la búsqueda es
   exitosa, deja el punto inmediatamente después del último caracter en el
   objetivo. Si la búsqueda es hacia atrás, deja el punto antes del primer
   caracter en el objetivo. Se puede contar @c{re-search-forward} para
   devolver @c{t} a cierto. (Moviendo el punto es por ello un ‘efecto
   lateral’.)

   Como @c{search-forward}, la función @c{re-search-forward} toma cuatro
   argumentos:

   1. El primer argumento es la expresión regular que la función busca. La
      expresión regular será una cadena entre comillas.

   2. El segundo argumento opcional limita cómo la función busca; es un
      emparejamiento, que se especifica como una posición en el búffer.

   3. El tercer argumento opcional especifica cómo la función responde al
      fallo: @c{nil} como tercer argumento que causa la función para señalar
      un error (e imprime un mensaje) cuando la búsqueda falla; cualquier
      otro valor causa devolver @c{nil} si la búsqueda falla y @c{t} si la
      búsqueda tiene éxito.

   4. El cuarto argumento opcional es el contaje repetido. Un contaje
      negativo repetido causa @c{re-search-forward} para buscar hacia atrás.


   La plantilla para @c{re-search-forward} se parece a esto:

   @smallexample
     (re-search-forward "@var{regular-expression}"
                     @var{limit-of-search}
                     @var{what-to-do-if-search-fails}
                     @var{repeat-count})
   @end smallexample

   El segundo, tercer, y cuarto argumentos son opcionales. Sin embargo, si se
   quiere pasar un valor a uno o ambos de los últimos dos argumentos, se debe
   también pasar un valor a todos los argumentos precedentes. De otro modo,
   el intérprete Lisp errará a qué argumento estás pasando el valor.

   En la función @c{forward-sentence}, la expresión regular será el valor de
   la variable @c{sentence-end}. En forma simple, esto es:

   @smallexample
     "[.?!][]\"')@}]*\\($\\|  \\|  \\)[
     ]*"
   @end smallexample

   El límite de la búsqueda será el fin del párrafo (desde una frase no puede
   ir bajo un párrafo). Si la búsqueda falla, la función devuelve @c{nil}, y
   el contaje repite será provisto por el argumento para la función
   @c{forward-sentence}.

** La función @c{forward-sentence}

   El comando mueve el cursor hacia adelante una frase es una ilustración
   honesta de cómo usar búsquedas de expresiones regulares en Emacs Lisp. En
   realidad, la función parece más larga y más complicada de lo que es; esto
   es porque la función está diseñada para ir hacia atrás tan bien como hacia
   adelante; y, opcionalmente, a través de una frase. La función está
   normalmente asociada al comando @k{M-e}.

   Aquí está la código para @c{forward-sentence}:

   @smallexample
     (defun forward-sentence (&optional arg)
       "Ve al siguiente ‘sentence-end’. Con el argumento, repite.
     Con el argumento negativo, mueve atrás repetidamente a ‘sentence-beginning’.
     La variable ‘sentence-end’ es una expresión regular que empareja el
     fin de frases. También, cada párrafo asociado termina las frases
     bien.
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point))
             (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            (if (and (re-search-backward sentence-end par-beg t)
                     (or (< (match-end 0) pos)
                         (re-search-backward sentence-end par-beg t)))
                (goto-char (match-end 0))
              (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            (if (re-search-forward sentence-end par-end t)
                (skip-chars-backward " \t\n")
              (goto-char par-end)))
           (setq arg (1- arg)))
         (constrain-to-field nil opoint t)))
   @end smallexample

   @ignore
     GNU Emacs 21
     @smallexample
       (defun forward-sentence (&optional arg)

        "Mueve hacia adelante a la siguiente sentence-end. Con el argumento,
         repetir.  Con el argumento negativo, mueve hacia atrás
         repetidamente a sentence-beginning. La frase que finalizan son
         identificadas por el valor de sentence-end tratada como expresión
         regular. También, cada párrafo límite termina las
         frases bien"
         (interactive "p")
         (or arg (setq arg 1))
         (while (< arg 0)
           (let ((par-beg
                  (save-excursion (start-of-paragraph-text) (point))))
             (if (re-search-backward
                  (concat sentence-end "[^ \t\n]") par-beg t)
                 (goto-char (1- (match-end 0)))
               (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end
                  (save-excursion (end-of-paragraph-text) (point))))
             (if (re-search-forward sentence-end par-end t)
                 (skip-chars-backward " \t\n")
               (goto-char par-end)))
           (setq arg (1- arg))))
     @end smallexample
   @end ignore

   La función se ve larga a primera vista y es mejor mirar primero el
   esqueleto, y entonces su músculo. El camino para ver el esqueleto es mirar
   en las expresiones que empiezan las columnas más a la izquierda:

   @smallexample
     (defun forward-sentence (&optional arg)
       "@var{documentation}…"
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point)) (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            @var{rest-of-body-of-while-loop-when-going-backwards}
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            @var{rest-of-body-of-while-loop-when-going-forwards}
         @var{handle-forms-and-equivalent}
   @end smallexample

   ¿Esto parece bastante simple! La definición de la función consiste de
   documentación una expresión @c{interactive}, una expresión @c{or}, una
   expresión @c{let}, y bucles @c{while}.

   Permite mirar cada una de estas partes.

   Notamos que la documentación es profunda y comprensible.

   La función tiene una declaración @c{interactive "p"}. Esto signifca que el
   argumento prefijo, si cualquiera es pasado a la función como su
   argumento. (Esto será un número.) Si la función no pasa un argumento (eso
   es opcional) entonces el argumento @c{arg} será asociado a 1.

   Cuando @c{forward-sentence} se llama no interactivamente sin un argumento,
   @c{arg} está asignado @c{nil}. La expresión @c{or} maneja esto. Lo que
   hace es dejar el valor de @c{arg} como eso es, pero solo si @c{arg} está
   asignado a un valor; o eso asigna el valor de @c{arg} a 1, en el caso de
   @c{arg} está asignado a @c{nil}.

   Lo siguiente es un @c{let}. Que especifica los valores de dos variables
   locales @c{point} y @c{sentence-end}. El valor local de punto, desde antes
   de la búsqueda, es usada en la función @c{constrain-to-field} que maneja
   formularios y equivalentes. La variable @c{sentence-end} está asignada por
   la función @c{sentence-end}.

*** Los bucles @c{while}

    Sigue dos bucles @c{while}. El primer @c{while} tiene un
    true-or-false-test que chequea cierto si el argumento prefijo para
    @c{forward-sentence} es un número negativo. Esto es para volver hacia
    atrás. El cuerpo de este bucle es similar al cuerpo de la segunda
    cláusula @c{while}, pero eso no es exactamente el mismo. Se obviará este
    bucle @c{while} y concentra en el segundo bucle @c{while}.

    El segundo bucle @c{while} está moviendo el punto hacia adelante. Su
    esqueleto se parece a esto:

    @smallexample
      (while (> arg 0)            ; @r{true-or-false-test}
        (let @var{varlist}
          (if (@var{true-or-false-test})
              @var{then-part}
            @var{else-part}
        (setq arg (1- arg))))     ; @c{while} @r{loop decrementer}
    @end smallexample

    El bucle @c{while} es el tipo de decremento. (Véase Sección @l{Los bucles
    @c{while}}.) Eso tiene un true-or-false-test que chequea cierto tan largo
    con el contador (en este caso, la variable @c{arg}) es mayor que cero; y
    eso tiene un decremento que elimina 1 desde el valor del contador cada
    vez que el bucle se repite.

    Si ningún argumento prefijo es dado para @c{forward-sentece}, que es el
    camino más común es usado, este bucle @c{while} ejecutará una vez, desde
    que el valor de @c{arg} será 1.

    El cuerpo del cuerpo @c{while} consite de una expresión @c{let}, que crea
    y asocia una variable local, y tiene, su cuerpo, una expresión @c{if}.

    El cuerpo del bucle @c{while} se parece a esto:

    @smallexample
      (let ((par-end
             (save-excursion (end-of-paragraph-text) (point))))
        (if (re-search-forward sentence-end par-end t)
            (skip-chars-backward " \t\n")
          (goto-char par-end)))
    @end smallexample

    La expresión @c{let} crea y asocia la variable local @c{par-end}. Como se
    ve, esta variable local está diseñada para proporcionar una asociación o
    límite para la búsqueda de la expresión regular. Si la búsqueda falla
    para encontrar una frase apropiada finalizando en el párrafo, eso se
    parará logrando el fin del párrafo.

    Pero primero, permítenos examinar cómo @c{par-end} se asocia a la
    variable del fin del párrafo. Lo que ocurre es que el @c{let} asigna el
    valor de @c{par-end} al valor devuelto cuando el intérprete evalúa la
    expresión.

    @smallexample
      (save-excursion (end-of-paragraph-text) (point))
    @end smallexample

    En esta expresión, @c{(end-of-paragraph-text)} mueve el punto al fin del
    párrafo, @c{(point)} devuelve el valor del punto, y entonces
    @c{save-excursion} restaura el punto a su posición original. De este
    modo, el @c{let} asocia @c{par-end} al valor devuelto por la expresión
    @c{save-excursion}, que es la posición del fin del párrafo.  (La función
    @c{end-of-paragraph-text} usa @c{forward-paragraph}, que se discutirá
    pronto.)

    Emacs evalúa el cuerpo del @c{let}, que es una expresión @c{if} que se
    parece a esto:

    @smallexample
      (if (re-search-forward sentence-end par-end t) ; @r{if-part}
          (skip-chars-backward " \t\n")              ; @r{then-part}
        (goto-char par-end)))                        ; @r{else-part}
    @end smallexample

    El test @c{if} si su primer argumento es cierto y si así, evalúa su parte
    then; de otro modo, el intérprete Emacs Lisp evalúa la parte else. El
    true-or-false-test de la expresión @c{if} es la búsqueda de la expresión
    regular.

    Puede estar mal tener que mirar como el ‘trabajo real’ de la función
    @c{forward-sentence} es vista aquí, pero esto es un camino común de este
    tipo de operación traida en Lisp.

*** La búsqueda de expresiones regulares

    La función @c{re-search-forward} busca el fin de la frase, que es, para
    el patrón definido por la expresión regular @c{sentence-end}. Si el
    patrón es encontrado––si el fin de la frase se encuentra––entonces la
    función @c{re-search-forward} hace dos cosas:

    1. La función @c{re-search-forward} trae un efecto lateral, que es mover
       el punto al final de la ocurrencia encontrada.

    2. La función @c{re-search-forward} devuelve un valor de verdad. Esto es
       el valor recibido por el @c{if}, y significa que la búsqueda fué
       exitosa.


    El efecto lateral, el movimiento del punto se completa antes de la
    función @c{if} y es manejado por el valor devuelto por la exitosa
    conclusión de la búsqueda.

    Cuando la función @c{if} recibe el valor de verdad desde una llamada
    exitosa a @c{re-search-forward}, el @c{if} evalúa la parte then que es la
    expresión @c{(skip-chars-backward "\t\n")}. Esta expresión se mueve atrás
    a través de espacios en blanco, los tabuladores o retornos de carro hasta
    un caracter impreso es encontrado y entonces deja el punto correcto
    después del caracter impreso cerrado de la frase, que es normalmente un
    periodo.

    Por otro lado, si la función @c{re-search-forward} falla para encontrar
    un patrón marcando el fin de la frase, la función devuelve falso. Lo
    falso causa el @c{if} para evaluar su tercer argumento, que es
    @c{(goto-char par-end)}: eso mueve el punto al final del párrafo.

    (Y si el texto está en una forma o equivalente, y apunta a que no puede
    moverse completamente entonces la función @c{constrain-to-field} empieza
    a funcionar.)

    Las búsquedas de expresiones regulares son excepcionalmente útiles y el
    patrón ilustrado por @c{re-search-forward}, en el que la búsqueda es el
    test de una expresión @c{if}, es manejable. Se verá o escribirá código
    incorporando este patrón con frecuencia.

** @c{forward-paragraph}: una mina de oro de funciones

   @ignore
     @c in GNU Emacs 22
     (defun forward-paragraph (&optional arg)
       "Move forward to end of paragraph.
     With argument ARG, do it ARG times;
     a negative argument ARG = -N means move backward N paragraphs.

     A line which ‘paragraph-start’ matches either separates paragraphs
     \(if ‘paragraph-separate’ matches it also) or is the first line of a paragraph.
     A paragraph end is the beginning of a line which is not part of the paragraph
     to which the end of the previous line belongs, or the end of the buffer.
     Returns the count of paragraphs left to move."
       (interactive "p")
       (or arg (setq arg 1))
       (let* ((opoint (point))
              (fill-prefix-regexp
               (and fill-prefix (not (equal fill-prefix ""))
                    (not paragraph-ignore-fill-prefix)
                    (regexp-quote fill-prefix)))
              ;; Remove ^ from paragraph-start and paragraph-sep if they are there.
              ;; These regexps shouldn't be anchored, because we look for them
              ;; starting at the left-margin.  This allows paragraph commands to
              ;; work normally with indented text.
              ;; This hack will not find problem cases like "whatever\\|^something".
              (parstart (if (and (not (equal "" paragraph-start))
                                 (equal ?^ (aref paragraph-start 0)))
                            (substring paragraph-start 1)
                          paragraph-start))
              (parsep (if (and (not (equal "" paragraph-separate))
                               (equal ?^ (aref paragraph-separate 0)))
                          (substring paragraph-separate 1)
                        paragraph-separate))
              (parsep
               (if fill-prefix-regexp
                   (concat parsep "\\|"
                           fill-prefix-regexp "[ \t]*$")
                 parsep))
              ;; This is used for searching.
              (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
              start found-start)
         (while (and (< arg 0) (not (bobp)))
           (if (and (not (looking-at parsep))
                    (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
                    (looking-at parsep))
               (setq arg (1+ arg))
             (setq start (point))
             ;; Move back over paragraph-separating lines.
             (forward-char -1) (beginning-of-line)
             (while (and (not (bobp))
                         (progn (move-to-left-margin)
                                (looking-at parsep)))
               (forward-line -1))
             (if (bobp)
                 nil
               (setq arg (1+ arg))
               ;; Go to end of the previous (non-separating) line.
               (end-of-line)
               ;; Search back for line that starts or separates paragraphs.
               (if (if fill-prefix-regexp
                       ;; There is a fill prefix; it overrides parstart.
                       (let (multiple-lines)
                         (while (and (progn (beginning-of-line) (not (bobp)))
                                     (progn (move-to-left-margin)
                                            (not (looking-at parsep)))
                                     (looking-at fill-prefix-regexp))
                           (unless (= (point) start)
                             (setq multiple-lines t))
                           (forward-line -1))
                         (move-to-left-margin)
                         ;; This deleted code caused a long hanging-indent line
                         ;; not to be filled together with the following lines.
                         ;; ;; Don't move back over a line before the paragraph
                         ;; ;; which doesn't start with fill-prefix
                         ;; ;; unless that is the only line we've moved over.
                         ;; (and (not (looking-at fill-prefix-regexp))
                         ;;      multiple-lines
                         ;;      (forward-line 1))
                         (not (bobp)))
                     (while (and (re-search-backward sp-parstart nil 1)
                                 (setq found-start t)
                                 ;; Found a candidate, but need to check if it is a
                                 ;; REAL parstart.
                                 (progn (setq start (point))
                                        (move-to-left-margin)
                                        (not (looking-at parsep)))
                                 (not (and (looking-at parstart)
                                           (or (not use-hard-newlines)
                                               (bobp)
                                               (get-text-property
                                                (1- start) 'hard)))))
                       (setq found-start nil)
                       (goto-char start))
                     found-start)
                   ;; Found one.
                   (progn
                     ;; Move forward over paragraph separators.
                     ;; We know this cannot reach the place we started
                     ;; because we know we moved back over a non-separator.
                     (while (and (not (eobp))
                                 (progn (move-to-left-margin)
                                        (looking-at parsep)))
                       (forward-line 1))
                     ;; If line before paragraph is just margin, back up to there.
                     (end-of-line 0)
                     (if (> (current-column) (current-left-margin))
                         (forward-char 1)
                       (skip-chars-backward " \t")
                       (if (not (bolp))
                           (forward-line 1))))
                 ;; No starter or separator line => use buffer beg.
                 (goto-char (point-min))))))

         (while (and (> arg 0) (not (eobp)))
           ;; Move forward over separator lines...
           (while (and (not (eobp))
                       (progn (move-to-left-margin) (not (eobp)))
                       (looking-at parsep))
             (forward-line 1))
           (unless (eobp) (setq arg (1- arg)))
           ;; ... and one more line.
           (forward-line 1)
           (if fill-prefix-regexp
               ;; There is a fill prefix; it overrides parstart.
               (while (and (not (eobp))
                           (progn (move-to-left-margin) (not (eobp)))
                           (not (looking-at parsep))
                           (looking-at fill-prefix-regexp))
                 (forward-line 1))
             (while (and (re-search-forward sp-parstart nil 1)
                         (progn (setq start (match-beginning 0))
                                (goto-char start)
                                (not (eobp)))
                         (progn (move-to-left-margin)
                                (not (looking-at parsep)))
                         (or (not (looking-at parstart))
                             (and use-hard-newlines
                                  (not (get-text-property (1- start) 'hard)))))
               (forward-char 1))
             (if (< (point) (point-max))
                 (goto-char start))))
         (constrain-to-field nil opoint t)
         ;; Return the number of steps that could not be done.
         arg))
   @end ignore

   La función @c{forward-paragraph} mueve el punto al fin del párrafo. Eso
   está normalmente asociado a @k{M-@}} y hace uso de un número de funciones
   que son importantes en sí, incluyendo @c{let*}, @c{match-beginning}, y
   @c{looking-at}.

   La definición de función para @c{forward-paragraph} es considerablemente
   mayor que la definición de función para @c{forward-sentence} porque eso
   funciona como un párrafo, cada línea puede empezar con un prefijo de
   relleno @e{fill prefix}.

   Un prefijo de relleno @e{fill prefix} consiste en una cadena de caracteres
   que se repite al principio de cada línea. Por ejemplo, en código Lisp, es
   una convención para empezar cada línea de un comentario de párrafo largo
   con @'{;;; }. En modo Texto, cuatro espacios en blanco crean otro prefijo
   de relleno @e{fill prefix} común, creando un párrafo indentado. (Véase
   Sección @"{Fill Prefix} en @e(The GNU Emacs Manual) para más información
   acerca de prefijos de relleno @e{fill prefix}.)

   La existencia de un prefijo de relleno significa que además de ser capaz
   de encontrar el fin de un párrafo cuyas líneas empiezan más a la
   izquierda, la función @c{forward-paragraph} debe ser capaz de encontrar el
   fin de un párrafo cuando todas o muchas de las líneas en el búffer
   empiezan con el prefijo de relleno @e{fill prefix}.

   Más allá, es algunas veces práctico ignorar un prefijo de relleno @e{fill
   prefix} que existe, especialmente cuando las líneas en blanco separen
   párrafos. Esto es una complicación añadida.

   En vez de imprimir toda la función @c{forward-paragraph}, nosotros solo
   imprimiremos partes de la misma. ¿Lee sin preparación, la función puede
   estar para desanimar!

   En esquema, la función se parece a esto:

   @smallexample
     (defun forward-paragraph (&optional arg)
       "@var{documentation}…"
       (interactive "p")
       (or arg (setq arg 1))
       (let*
           @var{varlist}
         (while (and (< arg 0) (not (bobp)))     ; @r{backward-moving-code}
           …
         (while (and (> arg 0) (not (eobp)))     ; @r{forward-moving-code}
           …
   @end smallexample

   Las primeras partes de la función son rutinas: la función lista argumentos
   que consisten de un argumento opcional. La documentación sigue.

   La letra minúscula @'{p} en la declaración @c{interactive} significa que
   el argumento prefijo se procesa, si se pasa a la función. Eso será un
   número, y es el contaje repetido de cuántos párrafos se moverá.  La
   expresión @c{or} en la siguiente línea maneja el caso común cuando no hay
   argumentos que se pasan a la función, esto ocurre si la función se llama
   desde otro código en vez de interactivamente. Este caso se describe
   pronto. (Véase Sección @l{La función @c{forward-sentence}, La función
   @c{forward-sentence}}.) Ahora se logra el fin de la parte familiar de esta
   función.

*** La expresión @c{let*}

    La siguiente línea de la función @c{forward-paragraph} empieza una
    expresión @c{let*}. Esto es tan diferente como @c{let}. El símbolo es
    @c{let*} no @c{let}.

    La forma especial @c{let*} es como @c{let} excepto que Emacs asigna cada
    variable en secuencia, una después de otra, y las variables en la última
    parte de la varlist hacen uso de los valores para los que Emacs asignó
    variable al principio la varlist.

    @ignore
      ( refappend save-excursion, , code save-excursion in code append-to-buffer .)
    @end ignore

    (Seccion @l{La definición de @c{append-to-buffer}}.)

    En la expresión @c{let*} en esta función, Emacs asigna un total de siete
    variables: @c{opoint}, @c{fill-prefix-regexp}, @c{parstart}, @c{parsep},
    @c{sp-parstart}, @c{start}, y @c{found-start}.

    La variable @c{parsep} aparece dos veces, primero, para borrar instancias
    de @'{^}, y segundo, para manejar prefijos rellenos.

    La variable @c{opoint} es solo el valor de @c{point}. Como se puede
    adivinar, eso se usa en una expresión @c{constrain-to-field}, solo como
    en @c{forward-sentence}.

    La variable @c{fill-prefix-regexp} se asigna al valor devuelto para
    evaluar la siguiente lista:

    @smallexample
      (and fill-prefix
           (not (equal fill-prefix ""))
           (not paragraph-ignore-fill-prefix)
           (regexp-quote fill-prefix))
    @end smallexample

    Esta es una expresión cuyo primer elemento es la forma especial @c{and}.

    Como se aprendió antes la (Vease Sección @l{Función kill-new, , La
    función @c{kill-new}}), la forma especial @c{and} evalúa cada uno de sus
    argumentos hasta uno de los argumentos y devuelve un valor de @c{nil} en
    el que el caso de la expresión @c{and} devuelve @c{nil}; sin embargo, si
    ninguno de los argumentos devuelve un valor de @c{nil}, el valor
    resultante de evaluar el último argumento es devuelto. (Puesto que tal
    valor no es @c{nil}, eso es considerado verdad en Lisp.) En otras
    palabras, una expresión @c{and} devuelve un valor de verdad solo si todos
    sus argumentos son verdad.  @findex and

    En este caso, la variable @c{fill-prefix-regexp} está asociado a un valor
    no @c{nil} solo si el las siguientes cuatro expresiones producen un valor
    true (por ej., un no @c{nil}) cuando son evaluados; de otro modo,
    @c{fill-prefix-regexp} está asociado a @c{nil}.

    - fill-prefix -:

      Cuando esta variable se evalúa, el valor del prefijo de relleno @e{fill
      prefix}, si cualquiera, está devuelto. Si no hay prefijo relleno, la
      variable devuelve @c{nil}.

    - (not (equal fill-prefix "") -:

      Esta expresión chequea si un prefijo lleno es una cadena vacía, que es,
      una cadena sin caracteres en eso. Una cadena vacía no es útil un
      prefijo relleno @e{fill prefix}.

    - (not paragraph-ignore-fill-prefix) -:

      Esta expresión devuelve @c{nil} si la variable
      @c{paragraph-ignore-fill-prefix} ha sido cambiado siendo asignado un
      valor de verdad tal como @c{t}.

    - (regexp-quote fill-prefix) -:

      Este es el último argumento para la forma especial @c{and}. Si todos
      los argumentos de @c{and} son verdaderos, el valor resultante de
      evaluar esta expresión será devuelto por la expresión @c{and} y
      asociado a la variable @c{fill-prefix-regexp},


    El resultado de evaluar esta expresión @c{and} con éxito es que
    @c{fill-prefix-regexp} se asociará al valor de @c{fill-prefix} como fué
    modificado por la función @c{regexp-quote}. Lo que @c{regexp-quote} hace
    es leer una cadena y devolver la expresión regular que asociará
    exactamente la cadena y nada más. Esto significa que
    @c{fill-prefix-regexp} será asignada a un valor que asociará el prefijo
    si el prefijo existe. De otro modo, la variable será asignada a @c{nil}.

    Las dos variables locales siguientes en la expresión @c{let*} están
    diseñadas para eliminar instancias de @'{^} desde @c{parstart} y
    @c{parsep}, las variables locales indican que el párrafo empieza como
    separador de párrafo. La siguiente expresión asigna @c{parsep} de
    nuevo. Esto es manejar prefijos rellenos.

    Esta es la configuración que requiere la llamada de la definición
    @c{let*} en vez de @c{let}. El true-or-false-test para el @c{if} depende
    de si la variable @c{fill-prefix-regexp} evalúa a @c{nil} o algún otro
    valor.

    Si @c{fill-prefix-regexp} no tiene un valor, Emacs evalúa la parte else
    de la expresión @c{if} y asocia @c{parsep} a su valor local. (@c{parsep}
    es una expresión regular que asocia lo que los párrafos separan.)

    Pero si @c{fill-prefix-regexp} tiene un valor, Emacs evalúa la parte then
    de la expresión @c{if} y asocia @c{parsep} a una expresión regular que
    incluye el @c{fill-prefix-regexp} como parte del patrón.

    Específicamente, @c{parsep} está asignado al valor original del párrafo
    que separa la expresión regular concatenada con una expresión alternativa
    que consiste del @c{fill-prefix-regexp} seguido por espacios en blanco
    opcionales para el fin de la línea. El espacio en blanco está definido
    por @c{"[ \t]*$"}.) El @'{\\|} define esta porción del regexp como una
    alternativa a @c{parsep}.

    De acuerdo a un comentario en el código, la siguiente variable local,
    @c{sp-parstart}, se usa para buscar, y entonces los dos finales,
    @c{start} y @c{found-start}, se asignan a @c{nil}.

    Ahora tenemos dentro el cuerpo del @c{let*}. La primera parte del cuerpo
    del @c{let*} trata con el caso cuando la función es dada a un argumento
    negativo y consiguientemente moviéndose hacia atrás. Nosotros saldremos
    de esta sección yendo hacia atrás.

*** El bucle @c{while} hacia adelante

    La segunda parte del cuerpo del @c{let*} trata con el proceso hacia
    adelante. Eso es un bucle @c{while} que se repite si el valor de @c{arg}
    es mayor que cero. En el uso más común de la función el valor del
    argumento es 1, así el cuerpo del bucle @c{while} se evalúa exactamente
    una vez, y el cursor se mueve hacia adelante un párrafo.

    @ignore
      (while (and (> arg 0) (not (eobp)))

        ;; Move forward over separator lines...
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (looking-at parsep))
          (forward-line 1))
        (unless (eobp) (setq arg (1- arg)))
        ;; ... and one more line.
        (forward-line 1)

        (if fill-prefix-regexp
            ;; There is a fill prefix; it overrides parstart.
            (while (and (not (eobp))
                        (progn (move-to-left-margin) (not (eobp)))
                        (not (looking-at parsep))
                        (looking-at fill-prefix-regexp))
              (forward-line 1))

          (while (and (re-search-forward sp-parstart nil 1)
                      (progn (setq start (match-beginning 0))
                             (goto-char start)
                             (not (eobp)))
                      (progn (move-to-left-margin)
                             (not (looking-at parsep)))
                      (or (not (looking-at parstart))
                          (and use-hard-newlines
                               (not (get-text-property (1- start) 'hard)))))
            (forward-char 1))

          (if (< (point) (point-max))
              (goto-char start))))
    @end ignore

    Esta parte maneja tres situaciones: cuando el punto está entre párrafos,
    cuando hay un prefijo de relleno y cuando no hay prefijo de relleno
    @e{fill prefix}.

    El bucle @c{while} se parece a esto:

    @smallexample
      ;; @r{yendo hacia adelante y no al fin del búffer}
      (while (and (> arg 0) (not (eobp)))

        ;; @r{entre párrafos}
        ;; Mueve hacia adelante a través de líneas de
        ;; separación...
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (looking-at parsep))
          (forward-line 1))
        ;;  @r{Esto decremento el bucle}
        (unless (eobp) (setq arg (1- arg)))
        ;; ... y una línea más
        (forward-line 1)

        (if fill-prefix-regexp
            ;; Hay un prefijo lleno; que sobreescribe parstart;
            ;; vamos adelante línea por línea
            (while (and (not (eobp))
                        (progn (move-to-left-margin) (not (eobp)))
                        (not (looking-at parsep))
                        (looking-at fill-prefix-regexp))
              (forward-line 1))

          ;; No hay prefijo;
          ;; vamos hacia adelante caracter por caracter
          (while (and (re-search-forward sp-parstart nil 1)
                      (progn (setq start (match-beginning 0))
                             (goto-char start)
                             (not (eobp)))
                      (progn (move-to-left-margin)
                             (not (looking-at parsep)))
                      (or (not (looking-at parstart))
                          (and use-hard-newlines
                               (not (get-text-property (1- start) 'hard)))))
            (forward-char 1))

          ;; y si no hay prefijo y si no estamos al final
          ;; ir a lo que fué encontrado en la búsqueda de expresiones regulares
          ;; para sp-parstart
          (if (< (point) (point-max))
              (goto-char start))))
    @end smallexample

    Se puede ver que esto es un contador de decremento @c{while}, usando la
    expresión @c{(setq arg (1- arg))} como lo que se decrementa. Esta
    expresión no está lejos desde el @c{while}, pero está oculta en otra
    macro Lisp, una macro @c{unless}. A menos que estemos al final del
    búffer––esto es lo que la función @c{eobp} determina; eso es una
    abreviación de @'{Fin del Buffer P} --- nosotros decrementamos el valor
    de @c{arg} por uno.

    (Si estamos al fin del búffer, no podemos ir más hacia adelante y el
    siguiente bucle de la expresión @c{while} chequeará falso desde que el
    test es un @c{and} con @c{(not (eobp))}. La función @c{not} significa
    exactamente como se esperaba; eso es otro nombre de @c{null}, una función
    que devuelve cierto cuando su argumento es falso.)

    De manera interesante, el bucle cuenta que no se decrementa hasta que
    deje el espacio entre párrafos, a menos que vuelva al fin del búffer o
    pare viendo el valor local del separador del párrafo.

    El segundo @c{while} también tiene una expresión
    @c{(move-to-left-margin)}. La función es autoexplicativa. Eso está dentro
    de una expresión @c{progn} y no el último elemento de su cuerpo, así es
    solo invocado para su efecto lateral, que es mover el punto al margen
    izquierdo de la línea actual.

    La función @c{looking-at} es también auto-explicativa; eso devuelve
    cierto si el texto después del punto asocia la expresión regular dada
    como su argumento.

    El resto del cuerpo del bucle se ve compleja al principio, pero tiene
    sentido cuando se comprende.

    Primero considera que ocurre si hay un prefijo de relleno @e{fill
    prefix}:

    @smallexample
      (if fill-prefix-regexp
          ;; Hay un prefijo lleno; que sobreescribe parstart;
          ;; vamos adelante línea por línea
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
    @end smallexample

    Esta expresión mueve el punto hacia adelante línea por línea tan lejos
    como que las cuatro condiciones son ciertas:

    1. Punto no está al final del búffer.

    2. Podemos mover al margen izquierdo del texto y no estar al fin del
       búffer.

    3. El siguiente punto no separa párrafos.

    4. El patrón que sigue el punto es la expresión regular prefija rellena.


    La última condición puede ser un puzzle, hasta que se recuerde qué punto
    fué movido al principio de la línea temprana en la función
    @c{forward-paragraph}. Esto significa que si el texto tiene el prefijo
    relleno, la función @c{looking-at} se verá.

    Considera qué ocurre cuando no hay un prefijo lleno.

    @smallexample
      (while (and (re-search-forward sp-parstart nil 1)
                  (progn (setq start (match-beginning 0))
                         (goto-char start)
                         (not (eobp)))
                  (progn (move-to-left-margin)
                         (not (looking-at parsep)))
                  (or (not (looking-at parstart))
                      (and use-hard-newlines
                           (not (get-text-property (1- start) 'hard)))))
        (forward-char 1))
    @end smallexample

    El bucle @c{while} nos tiene buscando hacia adelante para
    @c{sp-parstart}, que es la combinación de posibles espacios en blanco con
    un valor local del comienzo de un párrafo o de un párrafo separador. (Las
    últimas dos son con una expresión empezando con @c{(?:)} así que no están
    referenciadas por la función @c{match-beginning}.)

    Las dos expresiones,

    @smallexample
      (setq start (match-beginning 0))
      (goto-char start)
    @end smallexample

    significa ir al comienzo del siguiente texto localizado por la expresión
    regular.

    La expresión @c{(match-beginning 0)} es nueva. Eso devuelve un número
    especificando la posición del comienzo del texto fuese asociado a la
    última búsqueda.

    La función @c{match-beginning} es usado aquí porque una característica de
    una búsqueda hacia adelante: una búsqueda hacia adelante, sin dignidad si
    eso es una búsqueda plana o una expresión regular, mueve el punto al fin
    del texto que es encontrado. En este caso, una búsqueda exitosa mueve el
    punto al fin del patrón para @c{sp-parstart}.

    Sin embargo, se quiere poner el punto al fin del actual párrafo, no en
    algún lugar más. En vez de eso, desde que la búsqueda posiblemente
    incluye el separador del párrafo, el punto puede finalizar al principio
    de lo siguiente a menos que se use una expresión que incluya
    @c{match-beginning}.

    @findex match-beginning Cuando un argumento de 0, @c{match-beginning}
    devuelve la posición que es el comienzo del texto asociado por la
    búsqueda más reciente. En este caso, la búsqueda más reciente parece
    @c{sp-parstart}. La expresión @c{(match-beginning 0)} devuelve la
    posición del comienzo de este patrón, en vez de la posición final de este
    patrón.

    (Incidentalmente, cuando se pasa un número positivo como un argumento, la
    función @c{match-beginning} devuelve la localización de punto en el que
    la expresión con paréntesis en la última búsqueda a menos que la
    expresión con paréntesis empiece con @c{\(?:}. No sé porque @c{\(?:}
    aparece aquí desde que el argumento es 0.)

    La última expresión cuando no hay prefijos es

    @smallexample
      (if (< (point) (point-max))
          (goto-char start))))
    @end smallexample

    Esto dice que si no hay prefijo lleno y no estamos al punto final que se
    movería al principio de lo que fué encontrado por la búsqueda de la
    expresión regular para @c{sp-parstart}.

    La definición completa para la función @c{forward-paragraph} no solo
    incluye código para avanzar, también código para retroceder.

    Si está leyendo esto dentro de GNU Emacs y quieres ver la función
    completa, se puede escribir @k{C-h f} (@c{describe-function}) y el nombre
    de la función. Esto da la documentación de función y el nombre de la
    librería conteniendo las fuentes de la función. Posiciona el punto a
    través del nombre de la librería y presionar la tecla RET; será tomado
    directamente a las fuentes. (¿Asegúrate de instalar las fuentes! ¿Sin
    eso, estarás como una persona que intenta conducir un coche con los ojos
    cerrados!)

** Crea tu propio fichero @f{TAGS}

   Bajo @k{C-h f} (@c{describe-function}), otro camino para ver la fuente de
   una función es escribir @k{M-.} (@c{find-tag}) y el nombre de la función
   se asigna para eso. Esto es un buen hábito para obtenerlo. El comando
   @k{M-.} (@c{find-tag}) toma directamente a las fuentes de una función,
   variable, o nodo. La función depende de tablas de etiquetas para saber
   donde ir.

   Si la función @c{find-tag} pregunta primero por el nombre de una tabla
   @f{TAGS}, dado el nombre de un fichero @f{TAGS} tal como
   @f{/usr/local/src/emacs/src/TAGS}. (La ruta exacta a tu fichero @f{TAGS}
   depende de cómo tu copia de Emacs fué instalada. Yo te cuento la
   localización que provee tanto mi C y mis fuentes de Emacs Lisp.)

   Se puede también crear tu propio fichero @f{TAGS} para los directorios que
   faltan.

   Con frecuencia se necesita construir e instalar etiquetas de tablas por
   uno mismo. Esas no son construidas automáticamente. Una tabla de etiquetas
   llama a un fichero @f{TAGS}; el nombre es letras mayúsculas.

   Se puede crear un fichero @f{TAGS} llamando el programa @c{etags} que
   viene como parte de la distribución Emacs. Normalmente, @c{etags} está
   compilado e instalado cuando Emacs se construye. (@c{etags} no es una
   función Lisp o una parte de Emacs; eso es un programa C.)

   Para crear el fichero @f{TAGS}, primero cambia el directorio en el que se
   quiere crear el fichero. En Emacs se puede hacer esto con el comando
   @k{M-x cd}, o visitando un fichero en el directorio, o listando el
   directorio @c{etags *.el} como el comando a ejecutar

   @smallexample
     M-x compile RET etags *.el RET
   @end smallexample

   crear un fichero de @f{TAGS} para Emacs Lisp.

   Por ejemplo, si se tiene un gran número de ficheros en el directorio
   @f{~/emacs}, como se hace––Yo tengo 137 @f{.el} dentro, de que se carguen
   12––se puede crear un fichero @f{TAGS} para los ficheros Emacs Lisp en
   este directorio.

   El programa @c{etags} toma en toda la consola usual ‘comodines’. Por
   ejemplo, si tienes dos directorios para el que quieres un fichero @f{TAGS}
   simple, escribe @c{etags *.el ../elisp/*.el}, donde @f{../elisp/} es el
   segundo directorio:

   @smallexample
     M-x compile RET etags *.el ../elisp/*.el RET
   @end smallexample

   Tipo

   @smallexample
     M-x compile RET etags --help RET
   @end smallexample

   para ver una lista de las opciones aceptadas por @c{etags} tan bien como
   una lista de lenguajes soportados.

   El programa @c{etags} maneja más de 20 lenguajes, incluyendo Emacs Lisp,
   Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java, LaTeX, Pascal,
   Perl, Postscript, Python, TeX, Texinfo, makefiles, y la mayoría de
   ensambladores. El programa no cambia para especificar el lenguaje; eso
   reconoce el lenguaje como una entrada de fichero de acuerdo a su nombre de
   fichero y contenidos.

   @f{etags} es muy útil cuando se escribe código por tí mismo y quiere
   referirse a funciones que ya se han escrito. Ahora ejecuta @c{etags} de
   nuevo en intervalos como se escriben nuevas funciones, así llegan a ser
   parte del fichero @f{TAGS}.

   Si piensa que un fichero @f{TAGS} apropiado que ya existe para lo que
   quieres, pero no conoces donde está, se puede usar el programa @c{locate}
   para intentar encontrarlo.

   Escribe @k{M-x locate @k{RET} TAGS @k{RET}} y Emacs listará para ti las
   rutas nombres completas de todos tus ficheros @f{TAGS}. En mi sistema,
   este comando lista 34 fichero @f{TAGS}.  Por otro lado, un sistema
   ‘vanilla plano’ que recientemente no contenía fichero @f{TAGS}.

   Si la tabla de etiquetas que se quiere ha sido creada, se puede usar el
   comando @c{M-x visit-tags-table} para especificarlo. De otro modo, se
   necesitará la tabla de etiquetas por tí mismo y entonces usar @c{M-x
   visit-tags-table}.

*** Construyendo Etiquetas en las fuentes Emacs

    Las fuentes GNU Emacs vienen con un @f{Makefile} que contiene un comando
    sofisticado @c{etags} que crea, recoge, y asocia tablas de etiquetas de
    todas las fuentes de Emacs y pone la información dentro de un fichero
    @f{TAGS} en el directorio @f{src/}. (El directorio @f{src/} está debajo
    del alto nivel de tu directorio Emacs.)

    Para construir este fichero @f{TAGS}, se puede ir al alto nivel de
    directorio de fuentes Emacs y ejecutar el comando de compilar @c{make
    tags}:

    @smallexample
      M-x compile RET make tags RET
    @end smallexample

    (El comando @c{make tags} trabaja bien con las fuentes de GNU Emacs, tan
    bien como con otros paquetes fuentes.)

    Para más información, mira @"{Tablas de Etiquetas} en @e(El Manual GNU
    Emacs).

** Revisar

   Aquí hay un breve resumen de algunas funciones introducidas recientemente.

   - while -:

     Repetidamente evalúa el cuerpo de la expresión tan larga como el primer
     elemento del cuerpo chequea cierto. Entonces devuelve @c{nil}. (La
     expresión es evaluado solo por sus efectos laterales.)

     Por ejemplo:

     @smallexample
       (let ((foo 2))
         (while (> foo 0)
           (insert (format "foo is %d.\n" foo))
           (setq foo (1- foo))))

            ⇒      foo is 2.
                    foo is 1.
                    nil
     @end smallexample

     (La función @c{insert} inserta sus argumentos en el punto; la función
     @c{format} devuelve una cadena formateada desde sus argumentos el camino
     @c{message} formatea sus argumentos; @c{\n} produce una nueva línea.)

   - re-search-forward -:

     Busca un patrón, y si el patrón se encuentra, mueve el punto al resto
     solo después de eso.

     Toma cuatro argumentos, como @c{search-forward}:

     1. Una expresión regular que especifica el patrón para
        buscarlo. (¿Recuerda por marcas de comillas alrededor de este
        argumento!)

     2. Opcionalmente, el límite de la búsqueda.

     3. Opcionalmente, que haces si la búsqueda falla, devuelve @c{nil} o un
        mensaje de error.

     4. Opcionalmente, cuántas veces se puede repetir la búsqueda; si es
        negativa, la búsqueda va hacia atrás.


   - let* -:

     Asocia algunas variables localmente a valores particulares, y entonces
     evalúa los argumentos que permanencen, devolviendo el valor del
     último. Mientras se asocian las variables locales, se usan los valores
     locales de variables asociadas pronto, si acaso.

     Por ejemplo:

     @smallexample
       (let* ((foo 7)
             (bar (* 3 foo)))
         (message "`bar' is %d." bar))
            ⇒ `bar' is 21.
     @end smallexample

   - match-beginning -:

     Devuelve la posición del principio del texto encontrado por la última
     búsqueda de la expresión regular.

   - looking-at -:

     Devuelve @c{t} para verdadero si el texto después del punto se asocia al
     argumento, que debería ser una expresión.

   - eobp -:

     Devuelve @c{t} para cierto si el punto está en el fin de la parte
     accesible de un búffer. El fin de la parte accesible es el fin del
     búffer no está encogido; eso es el fin de la parte encogida si el búffer
     está encogido.

** Ejercicios con @c{re-search-forward}

   - Escribe una función para buscar para una expresión que detecte dos o más
     líneas blancas en secuencia.

   - Escribe una función para buscar palabras duplicadas, tales como ‘el
     el’. Véase Sección @"{Sintaxis para Expresiones Regulares} en @e(El
     Manual de GNU Emacs), para información de cómo escribir un regexp (una
     expresión regular) para asociar una cadena que se compone de dos mitades
     idénticas. Se puede disponer de varios regexps; algunos son mejores que
     otros. La función que se usa es descrito en un apéndice, a lo largo de
     varios regexps. Véase Sección @l{the-the, , Función de Palabras
     Duplicadas @c{the-the}}.

* Contando: repetición y regexps

  La repetición y búsqueda de expresiones regulares son herramientas
  poderosas que con frecuencia se usan cuando se escribe código en Emacs
  Lisp. Este capítulo ilustra el uso de búsqueda de expresiones regulares a
  través de la construcción de comandos de contaje de palabras usando bucles
  @c{while} y recursión.

  La distribución de Emacs estándar contiene una función para contar el
  número de líneas en una región.

  Hay cierto tipo de pregunta escrita para contar palabras. De este modo, si
  se escribe un ensayo, puede limitarse a 800 palabras; si se escribe una
  novela, te puedes disciplinar a ti mismo a escribir 1000 palabras al
  día. Parece raro, pero durante mucho tiempo, a Emacs le faltó un comando
  para contar palabras. Quizás la gente usaba Emacs mayoritariamente para
  codificar o documentar cosas que no requieren contar palabras, o quizás se
  restringían al sistema operativo el comando de contar palabras, @c{wc}. De
  manera alternativa, la gente puede seguir la convención de las editoriales
  y computaban un contaje de palabras dividiendo el número de caracteres en
  un documento por cinco.

  Hay mucho caminos para implementar un comando para contar palabras. Aquí
  hay algunos ejemplos, que pueden desear compararse con el comando de Emacs
  estándar, @c{count-words-region}.

** La función @c{@v{COUNT-WORDS}}

   Un comando de contar palabras podría contar palabras en una línea,
   párrafo, región, o búffer. ¿Qué comando funcionaría? Se podría diseñar el
   comando para contar el número de palabras en un búffer completo. Sin
   embargo, la tradición Emacs anima a la flexibilidad––se puede querer
   contar palabras solo en una sección, en vez de en todo un búffer. Así,
   tiene más sentido diseñar el comando para contar el número de palabras en
   una región. Una vez tienes un comando @c{count-words-region}, se puede, si
   desea, contar palabras en un búffer completo marcándolo con @k{C-x h}
   (@c{mark-whole-buffer}).

   Claramente, contar palabras es un acto repetitivo: empezando desde el
   principio de la región, se cuenta la primera palabra, entonces la segunda
   palabra, entonces la tercera palabra, y así, hasta que logres el fin de la
   región. Esto significa que contar palabras se ajusta idealmente a
   recursión o a un bucle @c{while}.

   Primero, implementaremos el comando de contar palabras con un bucle
   @c{while}, entonces con la recursión. El comando, de acuerdo, será
   interactivo.

   La plantilla para una definición de función interactiva es, como siempre:

   @smallexample
     (defun @var{name-of-function} (@var{argument-list})
       "@var{documentation}…"
       (@var{interactive-expression}…)
       @var{body}…)
   @end smallexample

   Lo que necesitamos hacer es rellenar los slots.

   El nombre de la función sería auto-explicativo y similar al nombre del
   @c{count-lines-region} existente. Esto hace que el nombre sea fácil de
   recordar. @c{count-words-region} es una buena elección. Puesto que el
   nombre se usa ahora para el comando de Emacs estándar para contar
   palabras, nosotros nombraremos nuestra implementación como
   @c{@v{COUNT-WORDS}}.

   La función cuenta palabras con una región. Esto significa que el argumento
   lista debe contener símbolos que son asociados a las dos posiciones, el
   principio y fin de la región. Estas dos posiciones puede ser llamadas
   @'{beginning} y @'{end} respectivamente. La primera línea de la
   documentación sería una frase simple, desde que esto es todo lo que está
   impreso como documentación por un comando tal como @c{apropos}. La
   expresión interactiva será de la forma @'{(interactive "r")}, puesto que
   causará que Emacs pase al principio y fin de la región a la lista de
   argumentos de función. Todo esto es rutina.

   El cuerpo de la función necesita ser escrita para hacer tres tareas:
   primero, configurar condiciones bajo las que el bucle @c{while} pueda
   contar palabras, segundo, ejecutar el bucle @c{while}, y tercero, enviar
   un mensaje al usuario.

   Cuando un usuario llama a @c{@v{COUNT-WORDS}}, apunta a que puede estar al
   principio o fin de la región. Sin embargo, el proceso de conteo debe
   empezar al principio de la región. Esto significa que querremos poner el
   punto que hay si eso no está allí. Ejecutando @c{(goto-char beginning)}
   asegura esto. De acuerdo, querremos devolver el punto a su posición
   esperada cuando la función finalice su trabajo. Por esta razón, el cuerpo
   debe ser encerrado en una expresión @c{save-excursion}.

   La parte central del cuerpo de la función consiste en un bucle @c{while}
   en el que una expresión salta el punto hacia delante palabra por palabra,
   y otra expresión cuenta estos saltos. Si el test-verdadero-o-falso del
   bucle @c{while} es verdadero, el punto saltaría hacia adelante, y si es
   falso el punto estaría al fin de la región.

   Nosotros podríamos usar @c{(forward-word 1)} como la expresión para mover
   el punto hacia adelante palabra por palabra, pero eso es fácil de ver que
   Emacs identifica como una ‘palabra’ si se usa una búsqueda de expresión
   regular.

   Una expresión regular busca lo que encuentra el patrón que se está
   buscando deja el punto después del último carácter emparejado. Esto
   significa que una sucesión de palabras exitosas busquen que moverá el
   punto adelante palabra por palabra.

   Como materia práctica, se quiere que la expresión regular se busque para
   saltar a través de un espacio en blanco y puntúe entre palabras tan bien a
   través de las palabras en sí. Una expresión regexp que rechaza para saltar
   a través de espacios en blanco entre palabras ¿nunca saltaría más de una
   palabra!. Esto significa que el regexp incluiría el espacio en blanco y la
   puntuación sigue a una palabra cualquiera, como la palabra en sí. (Una
   palabra puede finalizar un búffer y no tiene cualquier espacio en blanco o
   puntuación, así esta parte del regexp debe ser opcional.)

   De este modo, queremos para el regexp es un patrón definiendo una o más
   palabras de caracteres que constituyen caracteres seguidos, opcionalmente,
   por uno o más caracteres que no son palabras constituyentes. La expresión
   regular para esto es:

   @smallexample
     \w+\W*
   @end smallexample

   La tabla de sintaxis del búffer determina qué caracteres son y no son
   palabras constituyentes. Para más información acerca de sintaxis, Vease
   Sección @"{Tablas de Sintaxis} @e(El Manual de Referencia de GNU Emacs
   Lisp).

   La expresión se parece a esto:

   @smallexample
     (re-search-forward "\\w+\\W*")
   @end smallexample

   (Note que las barras invertidas que preceden el @'{w} y @'{W}. Una barra
   invertida tiene significado especial al intérprete Emacs Lisp. Eso indica
   que el caracter siguiente es interpretado de manera diferente que la
   normal. Por ejemplo, los dos caracteres, @'{\n}, son una @'{nueva línea},
   en vez de una barra invertida seguida por @'{\n}. Dos barras invertidas en
   una fila para una ‘barra invertida no especial’, así Emacs Lisp interpreta
   el fin de mirar una barra invertida simple seguida por una letra. Así
   descubre la letra que es especial.)

   Se necesita un contador para contar cuántas palabras hay; esta variables
   debe primero ser asignado a 0 y entonces incrementados cada vez que Emacs
   va alrededor del bucle @c{while}. La expresión de incremento es simple:

   @smallexample
     (setq count (1+ count))
   @end smallexample

   Finalmente, se quiere contar al usuario cuántas palabras hay en la
   región. La función @c{message} presenta este tipo de información al
   usuario. El mensaje tiene que ser fraseado de manera que se lea
   apropiadamente sin cuidado de cuantas palabras hay en la región: no se
   quiere decir que “hay una palabra en la región”. El conflicto entre
   singular y plural no es gramatical. Se puede resolver este problema usando
   una expresión condicional que evalúa diferentes mensajes dependiendo en el
   número de palabras en la región. Hay tres posibilidades: no palabras en la
   región, una palabra en la región, y más de una palabra. Esto significa que
   la forma especial @c{cond} es apropiada.

   Todo esto lidera a la siguiente definición de función:

   @smallexample
     ;;; @r{¿La Primera versión; tiene errores!}
     (defun count-words-region (beginning end)
       "Imprime el número de palabras en la región.
     Las palabras están definidas al menos una palabra
     constituida de caracteres seguido por al menos un
     caracter que no constituye palabra. La tabla de
     sintaxis del búffer determina qué caracteres hay."
       (interactive "r")
       (message "Contando palaras en la región ... ")

     ;;; @r{1. Configurar condiciones apropiadas.}
       (save-excursion
         (goto-char beginning)
         (let ((count 0))

     ;;; @r{2. Ejecutar el} @r{bucle} while.
           (while (< (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))

     ;;; @r{3. Enviar un mensaje al usuario.}
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message
                   "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   @end smallexample

   Como se escribe, la función funciona, pero no en todas las circunstancias.

*** El error de espacio en blanco en @c{@v{COUNT-WORDS}}

    El comando @c{@v{COUNT-WORDS}} descrito en la sección precedente tiene
    dos errores, o incluso, un error con dos manifestaciones. Primero, si se
    marca una región conteniendo solo espacio en blanco en el medio de algún
    texto el comando ¿@c{@v{COUNT-WORDS}} cuenta que la región contiene una
    palabra!. Segundo, si se marca una región conteniendo solo espacios en
    blanco al final del búffer o la porción accesible de un búffer encogido,
    el comando muestra un mensaje de error que se parece a esto:

    @smallexample
      Búsqueda fallida: "\\w+\\W*"
    @end smallexample

    Si está leyendo esto en Info en GNU Emacs, se puede testear para estos
    errores por sí mismo.

    Primero, evalúa la función de la manera usual para instalarlo.

    @ignore
      Aquí hay una copia de la definición. Emplaza tu cursor
      después de cerrar los paréntesis y escribir @k{C-x C-e} para
      instalarlo.

      @smallexample
        ;; @r{¿La Primera versión; tiene errores!}  (defun
        @v{COUNT-WORDS} (beginning end)
        "Imprime el número de palabras en la región.  Las palabras son
        definidas como al menos un caracter de palabra constituida seguida por
        al menos un caracter que no es una palabra constituyente. La tabla de
        sintaxis del búffer determina qué caracteres hay."

          (interactive "r")
          (message "Contando palabras en la región ... ")

        ;;; @r{1. Configurar condiciones apropiadas.}
          (save-excursion
            (goto-char beginning)
            (let ((count 0))

        ;;; @r{2. Ejecutar el} @r{bucle} while.
              (while (< (point) end)
                (re-search-forward "\\w+\\W*")
                (setq count (1+ count)))

        ;;; @r{3. Envía un mensaje al usuario.}
              (cond ((zerop count)
                     (message "La región no tiene palabras."))
                    ((= 1 count) (message "The región tiene 1 palabra."))
                    (t (message "La región tiene %d palabras." count))))))
      @end smallexample
    @end ignore

    Si se desea, se puede también instalar este atajo para ser evaluado:

    @smallexample
      (global-set-key "\C-c=" '@v{COUNT-WORDS})
    @end smallexample

    Para conducir el primer test, asigna marca y punto al principio y fin de
    la siguiente línea y entonces escribe @k{C-c =} (o @k{M-x
    @v{COUNT-WORDS}} si no se ha asignado @k{C-c =}):

    @smallexample
          uno   dos  tres
    @end smallexample

    Emacs te contará, correctamente, que la región tiene tres palabras.

    Repite el test, pero marca el lugar al principio de la línea y emplaza el
    punto justo @e{antes} de la palabra @'{uno}. De nuevo escribe el comando
    @k{C-c =} (o @k{M-x @v{COUNT-WORDS}}). Emacs cuenta que la región no
    tiene palabras, puesto que eso está compuesto solo por espacios en blanco
    al principio de la línea. ¿Pero en vez de que Emacs cuente que la región
    tiene una palabra!

    Para el tercer test, copia la línea de ejemplo al fin del búffer
    @f{*scratch*} y entonces escribe varios espacios al fin de la
    línea. Posiciona la marca correcta después de la palabra @'{tres} y
    apunta al fin de la línea. (El fin de la línea será el fin del búffer.)
    Escribe @k{C-c =} (o @k{M-x @v{COUNT-WORDS}}) como se hizo antes. De
    nuevo, Emacs te contaría que la región no tiene palabras, puesto que eso
    está compuesto solo de los espacios en blanco al fin de la línea. En vez
    de eso, Emacs muestra un mensaje de error diciendo @'{Búsqueda fallida}.

    Los dos errores queman el mismo problema.

    Considere la primera manifestación del error, en el que el comando te
    cuenta que el espacio en blanco al principio de la línea contiene una
    palabra. Lo que ocurre es esto: El comando @c{M-x @v{COUNT-WORDS}} mueve
    el punto al principio de la región. El test @c{while} si el valor del
    punto es más pequeño de lo que el valor de @c{end}, que es. Por
    consiguiente, en la expresión regular se busca y encuentra la primera
    palabra. Eso deja el punto después de la palabra. @c{count} que se
    establece a uno. El bucle @c{while} repite; pero esta vez el valor del
    punto es más largo que el valor de @c{end}, el bucle sale; y la función
    muestra un mensaje diciendo el número de palabras en la región es uno. En
    breve, la expresión regular busca y encuentra la palabra incluso aunque
    eso esté fuera de la región marcada.

    En la segunda manifestación del error, la región es un espacio en blanco
    al fin del búffer. Emacs dice @'{Búsqueda fallida}. Lo que ocurre es que
    true-or-false-test en el bucle @c{while} chequea verdad, así la expresión
    de búsqueda es ejecutada. Pero desde que no hay más palabras en el
    buffer, la búsqueda falla.

    En ambas manifestaciones del error, la búsqueda extiende o intenta
    extenderse fuera de la región.

    La solución es limitar la búsqueda a la región––esto es una acción simple
    y limpia, pero como tu puedes tener que llegar a esperar, eso no es tan
    simple como se podría pensar.

    Como se ha visto, la función @c{re-search-forward} toma un patrón de
    búsqueda como su primer argumento. Pero además de este primer, argumento
    obligatorio, se aceptan tres argumentos opcionales. El segundo argumento
    opcional asocia la búsqueda. El tercer argumento opcional, si @c{t},
    causa la función a devolver @c{nil} en vez de la señal un error si la
    búsqueda falla. El cuarto argumento opcional es un contador repetido. (En
    Emacs, se puede ver una documentación de la función escribiendo @k{C-h
    f}, el nombre de la función, y entonces @k{RET}.)

    En la definición @c{@v{COUNT-WORDS}}, el valor del fin de la región es
    tomada por la variable @c{end} que es pasada como un argumento para la
    función. De este modo, se puede añadir @c{end} como un argumento para la
    búsqueda de la expresión de búsqueda:

    @smallexample
      (re-search-forward "\\w+\\W*" fin)
    @end smallexample

    Sin embargo, si se crea solo este cambio a la definición
    @c{@v{COUNT-WORDS}} y entonces se chequea la nueva versión de la
    definición en una extensión de espacio en blanco, se recibirá un mensaje
    de error diciendo @'{Búsqueda fallida}.

    Lo que ocurre es esto: la búsqueda se limita a la región, y falla como se
    espera porque no hay caracteres de palabras constituyentes en la
    región. Puesto que eso falla, se recibe un mensaje de error. Pero no
    queremos recibir un mensaje de error en este caso; se quiere recibir el
    mensaje que "La región no tiene palabras".

    La solución a este problema es proveer @c{re-search-forward} con un
    tercer argumento de @c{t}, que causa la función para devolver @c{nil} en
    vez la señalar un error si la búsqueda falla.

    Sin embargo, si se crea este cambio y se intenta, se verá el mensaje
    “Contando palabras en la región ...” y … se guardará viendo qué mensaje
    …, hasta que se escribe @k{C-g} (@c{keyboard-quit}).

    Aquí está lo que ocurre: la búsqueda está limitada a la región, como
    antes, y eso falla porque no hay caracteres no constituyentes de palabras
    en la región, como se espera. Por tanto, la expresión
    @c{re-search-forward} devuelve @c{nil}. Eso no hace nada más. En
    particular, no mueve el punto, que hace como un efecto lateral si se
    encuentra la búsqueda objetiva. Después la expresión
    @c{re-search-forward} devuelve @c{nil}, la siguiente expresión en el
    bucle @c{while} está evaluado. Esta expresión incrementa el
    contador. Entonces el bucle repite. El test true-or-false-test chequea
    cierto porque el valor del punto es todavía menor que el valor final,
    desde que la expresión @c{re-search-forward} no movería el punto. … y el
    ciclo repite …

    La definición @c{@v{COUNT-WORDS}} requiere todavía de otra modificación
    para causar el true-or-false-test del bucle @c{while} para chequear falso
    si la búsqueda falla. Pon otro camino, hay dos condiciones que deben ser
    satisfechas en el true-or-false-test antes que el contador de palabras
    variable se incremente: el punto debe todavía estar con la región y la
    expresi@'n de búsqueda debe haber encontrado una palabra para contar.

    Por ambas la primera condición y la segunda condición deben ser ciertas
    juntas, las dos expresiones, la región chequea y la expresión de
    búsqueda, puede estar unido con una forma especial @c{and} y embebido en
    el bucle @c{while} como el true-or-false-test, como esto:

    @smallexample
      (and (< (point) end) (re-search-forward "\\w+\\W*" end t))
    @end smallexample

    @iftex
    (Para información acerca de @c{and}, ver @"{La función @c{kill-new}}.)

    La expresión @c{re-search-forward} devuelve @c{t} si la búsqueda es
    exitosa y como efecto lateral se mueve el punto. Consiguientemente, como
    las palabras se encuentran, el punto es movido a través de la
    región. Cuando la búsqueda de la expresión falla para encontrar otra
    palabra, o cuando el punto logra el fin de la región, el test
    true-or-false-test es falso, el bucle @c{while} existe, y la función
    @c{@v{COUNT-WORDS}} muestra uno u otro de sus mensajes.

    Después de incorporar estos cambios finales, el @c{@v{COUNT-WORDS}}
    funciona sin errores (¿o al menos, sin los errores que yo haya
    encontrado!. Aquí está lo que parece:

    @smallexample
      ;;; @r{Versión final:} @c{while}
      (defun @v{COUNT-WORDS} (beginning end)
        "Imprime número de palabras en la región."
        (interactive "r")
        (message "Contando palabras en la región ... ")

      ;;; @r{1. Configura condiciones apropiadas.}
        (save-excursion
          (let ((count 0))
            (goto-char beginning)

      ;;; @r{2. Ejecuta el} @r{bucle} while
            (while (and (< (point) end)
                        (re-search-forward "\\w+\\W*" end t))
              (setq count (1+ count)))

      ;;; @r{3. Enviar un mensaje al usuario.}
            (cond ((zerop count)
                   (message
                    "La región no tiene palabras."))
                  ((= 1 count)
                   (message
                    "La región tiene 1 palabra."))
                  (t
                   (message
                    "La región tiene %d palabras." count))))))
    @end smallexample

** Cuenta palabras recursivamente

   Se puede escribir la función para contar palabras tanto de manera
   recursiva como con un bucle @c{while}. Permita ver cómo se hace.

   Primero, se necesita reconocer que la función @c{@v{COUNT-WORDS}} tiene
   tres trabajos: eso configura las condiciones apropiadas para contar lo que
   ocurre; eso cuenta las palabras en la región; y envía un mensaje al
   usuario contando cuántas palabras hay.

   Si se escribe una función recursiva simple para hacer cualquier cosa se
   recibirá un mensaje para cada llamada recursiva. Si la región contiene 13
   palabras, se recibirán trece mensajes, uno correcto después del otro. ¿No
   queremos esto!. En vez de eso, se deben escribir dos funciones para hacer
   el trabajo, una (la función recursiva) será usada dentro de la otra. Una
   función configurará las condiciones y muestra el mensaje; la otra
   devolverá el contador de palabras.

   Permítase comenzar con la función que causa el mensaje que se muestra. Se
   puede continuar por llamarse @c{@v{COUNT-WORDS}}.

   Esta es la función que el usuario llama. Será interactiva. En realidad,
   será similar a nuestras versiones previas de esta función, excepto que
   llamará @c{recursive-count-words} para determinar cuántas palabras hay en
   la región.

   Se puede construir una plantilla legible para esta función, basada en
   versiones previas:

   @smallexample
     ;; @r{Versión Recursiva; usa la búsqueda de la expresión regular}
     (defun @v{COUNT-WORDS} (beginning end)
       "@var{documentation}…"
       (@var{interactive-expression}…)

     ;;; @r{1. Configura condiciones apropiadas.}
       (@var{explanatory message})
       (@var{set-up functions}…

     ;;; @r{2. Contar las palabras.}
         @var{recursive call}

     ;;; @r{3. Envía un mensaje al usuario.}
         @var{message providing word count}))
   @end smallexample

   La definición parece sencilla, excepto que como el contador devuelve la
   llamada recursiva que debe ser pasada al mensaje mostrando el contaje de
   palabras. Un pequeño pensamiento sugiere que esto puede ser hecho haciendo
   uso de una expresión @c{let} al número de palabras en la región, como se
   devuelve por la llamada recursiva; y entonces la expresión @c{cond}, que
   usa la asociación, puede mostrar el valor al usuario.

   Con frecuencia, uno piensa que se puede asociar una expresión @c{let} como
   algo secundario al trabajo ‘primario’ de una función. Pero en este caso,
   se podría considerar el trabajo ‘primario’ de la función, contando
   palabras, esto es hecho con la expresión @c{let}.

   Usando @c{let}, la definición de función se parece a:

   @smallexample
     (defun @v{COUNT-WORDS} (beginning end)
       "Imprime el número de palabras en la región."
       (interactive "r")

     ;;; @r{1. Configura condiciones apropiadas.}
       (message "Contando palabras en la región ... ")
       (save-excursion
         (goto-char beginning)

     ;;; @r{2. Contar las palabras.}
         (let ((count (recursive-count-words end)))

     ;;; @r{3. Enviar un mensaje al usuario.}
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message
                   "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   @end smallexample

   Lo siguiente, que se necesita es escribir la función de contaje recursivo.

   Una función recursiva tiene al menos tres partes: el ‘do-again-test’, la
   ‘next-step-expression’, y la llamada recursiva.

   El do-again-test determina si la función será o no llamada de
   nuevo. Puesto que estamos contando palabras en una región y puede causar
   que una función se mueva el punto hacia delante por cada palabra, el
   do-again-test puede chequear si el punto está todavía con la región. El
   do-again-test encontraría el valor del punto y determina si el punto está
   antes, en, o después del valor del fin de la región. Se puede usar la
   función @c{point} para localizar el punto. Claramente, se debe pasar el
   valor del fin de la región a la función de contaje recursivo como un
   argumento.

   Además, el do-again-test también chequea si la búsqueda encuentra una
   palabra. Si no, la función no se llamaría de nuevo.

   La next-step-expression cambia un valor así que cuando la función
   recursiva se supone que debe parar de llamarse así misma, se para. Más
   precisamente, los cambios de next-step-expression cambia un valor así en
   el momento adecuado, el do-again-test para la función recursiva de la
   llamada en sí de nuevo. En este caso, la next-step-expression puede ser la
   expresión que mueve el punto hacia adelante, palabra por palabra.

   La tercera parte de una función recursiva es la llamada recursiva.

   En algún lugar, también, se necesita una parte que hace el ‘trabajo’ de la
   función, una parte que es el contaje. ¿Una parte vital!

   Pero ya, tenemos un guión de la función recursiva de contaje:

   @smallexample
     (defun recursive-count-words (region-end)
       "@var{documentation}…"
        @var{do-again-test}
        @var{next-step-expression}
        @var{recursive call})
   @end smallexample

   Ahora se necesita rellenar los slots. Permite comenzar con el caso más
   simple primero: si se apunta debajo del fin de la región, no puede haber
   palabras en la región, así la función devuelve cero. De otro modo, si la
   búsqueda falla no hay palabras para contar, así la función devolvería
   cero.

   Por otro lado, si se apunta con la región y la búsqueda tiene éxito, la
   función se llamaría de nuevo.

   De este modo, do-again-test se vería así:

   @smallexample
     (and (< (point) region-end)
          (re-search-forward "\\w+\\W*" region-end t))
   @end smallexample

   Note que la expresión de búsqueda es parte del do-again-test --- la
   función devuelve @c{t} si su búsqueda tiene éxito y @c{nil} si
   falla. (Véase Sección @l{Error de espacio en blanco, , El Error de Espacio
   en Blanco en @c{@v{COUNT-WORDS}}}), para una explicación de cómo
   @c{re-search-forward} funciona.)

   El do-again-test es el test true-or-false de una cláusula
   @c{if}. Claramente si el do-again-test tiene éxito, la then-part de la
   cláusula @c{if} llamaría a la función; pero si eso falla, la else-part
   devolvería cero desde que el punto está fuera de la región o la búsqueda
   falló porque no había palabras a encontrar.

   Pero antes de considerar la llamada recursiva, se necesita considerar la
   next-step-expression. ¿Qué es eso? De manera interesante, eso es la parte
   de la búsqueda del do-again-test.

   Además para devolver @c{t} o @c{nil} para el do-again-test,
   @c{re-search-forward} mueve el punto hacia adelante como un efecto lateral
   de una búsqueda exitosa. Esta es la acción que cambia el valor de punto
   así que la función recursiva para de llamarse a sí misma cuando el punto
   complete su movimiento a través de la región. Por consiguiente, la
   expresión @c{re-search-forward} es la next-step-expression.

   En esquema, entonces, el cuerpo de la función @c{recursive-count-words} se
   parece a esto:

   @smallexample
     (if @var{do-again-test-and-next-step-combined}
         ;; @r{then}
         @var{recursive-call-returning-count}
       ;; @r{else}
       @var{return-zero})
   @end smallexample

   ¿Cómo incorporar el mecanismo que cuenta?

   Si no estás acostumbrado a escribir funciones recursivas, una pregunta
   como esta puede ser un problema. Pero eso puede y sería enfocado
   sistemáticamente.

   Se sabe que el mecanismo de contaje sería asociado en algún lugar con la
   llamada recursiva. En vez de eso, desde que la next-step-expression mueve
   el punto hacia adelante por una palabra, y desde que una llamada recursiva
   es hecha para cada palabra, el mecanismo de contaje debe ser una expresión
   que añade uno al valor devuelto por una llamada para
   @c{recursive-count-words}

   Considera varias casos:

   - Si hay dos palabras en la región, la función devolverá un valor
     resultante de añadir uno al valor devuelto al contar la primera palabra,
     más el número devuelto al contar las palabras que permanecen en la
     región, que en este caso es una.

   - Si hay una palabra en la región, la función devolvería un valor
     resultante de añadir uno al valor devuelto cuando eso cuenta esta
     palabra más el número devuelto cuando eso cuenta las palabras que
     permanecen en la región, que en este caso es cero.

   - Si no hay palabras en la región, la función devolvería cero.


   Desde el esquema se puede ver que la parte else del @c{if} devuelve cero
   para el caso en el que no hay palabras. Esto significa que la parte then
   del @c{if} debe devolver un valor resultante de añadir uno al valor
   devuelto desde el contaje de las palabras que permanecen.

   La expresión se parece a esto, donde @c{1+} es una función que añade uno a
   su argumento.

   @smallexample
     (1+ (recursive-count-words region-end))
   @end smallexample

   La función completa @c{recursive-count-words} entonces se parecerá e esto:

   @smallexample
     (defun recursive-count-words (region-end)
       "@var{documentation}…"

     ;;; @r{1. do-again-test}
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; @r{2. then-part: la llamada recursiva}
           (1+ (recursive-count-words region-end))

     ;;; @r{3. else-part}
         0))
   @end smallexample

   Permíteme examinar cómo esto funciona:

   Si no hay palabras en la región, la parte else de la expresión @c{if} es
   evaluada y, por tanto, la función devuelve cero.

   Si hay una palabra en la región, el valor del punto es menor que el valor
   de @c{region-end} y la búsqueda tiene éxito. En este caso, el
   true-or-false-test de la expresión @c{if} chequea cierto, y la then-part
   de la expresión @c{if} es evaluada. La expresión de contaje se
   evalúa. Esta expresión devuelve un valor (que será el valor devuelto por
   la función completa) que es la suma de uno añadida al valor devuelto por
   una llamada recursiva.

   Mientras tanto, la next-step-expression ha causado el punto para saltar a
   través de la primera (y en este caso única) palabra en la región. Esto
   significa que cuando @c{(recursive-count-words region-end)} está evaluada
   una segunda vez, como un resultado de la llamada recursiva, el valor del
   punto será igual o mayor que el valor de la región final. Así esta vez,
   @c{recursive-count-words} devolverá cero. El cero será añadido a uno, y la
   evaluación original de @c{recursive-count-words} devolverá uno más cero
   (uno) que es la cantidad correcta.

   Claramente, si hay dos palabras en la región, la primera llamada a
   @c{recursive-count-words} devuelve uno que se añade al valor devuelto por
   el siguiente @c{recursive-count-words} en una región donde está la palabra
   que permanece––que es, eso añadir uno a uno, produciendo dos, que es la
   cantidad correcta.

   Similarmente, si hay tres palabras en la región, la primera llamada
   @c{recursive-count-words} devuelve uno añadido al valor devuelto llamado
   @c{recursive-count-words} en una región conteniendo las dos palabras que
   faltan––y así.

   Con documentación completa las dos funciones se parecen a esto:

   La función recursiva:

   @smallexample
     (defun recursive-count-words (region-end)
       "Número de palabras entre punto y REGION-END."

     ;;; @r{1. do-again-test}
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; @r{2. then-part: la llamada recursiva}
           (1+ (recursive-count-words region-end))

     ;;; @r{3. else-part}
         0))
   @end smallexample

   El envoltorio:

   @smallexample
     ;;; @r{Versión Recursiva}
     (defun @v{COUNT-WORDS} (beginning end)
       "Imprime el número de palabras en la región.

     Las palabras son definidas como al menos una palabra constituyente
     seguida por al menos un caracter que es una palabra constituyente. La
     tabla de sintaxis del buffer determina qué caracter hay.
       (interactive "r")
       (message "Contando palabras en la región ... ")
       (save-excursion
         (goto-char beginning)
         (let ((count (recursive-count-words end)))
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   @end smallexample

** Ejercicio: contando puntuación

   Usando un bucle @c{while}, escriba una función para contar el número de
   marcas de puntuación en una región––periodo, coma, punto y coma, dos
   puntos, exclamación, marca y marca de pregunta. Haga lo mismo usando
   recursión.

* Contando palabras en una @c{defun}

  El siguiente proyecto es contar el número de palabras en una definición de
  función. Claramente, esto se puede hacer usando alguna variante de
  @c{@v{COUNT-WORDS}}. Véase Sección @l{Contando palabras, , Contando
  palabras: repetición y regexps}. Si se está ahora yendo a contar las
  palabras en una definición, es suficientemente fácil marcar la definición
  con el comando @k{C-M-h} (@c{mark-defun}), y entonces se llama a
  @c{@v{COUNT-WORDS}}.

  Sin embargo, soy más ambicioso: Yo quiero contar las palabras y símbolos en
  cada definición en las fuentes de Emacs y entonces imprimir un grafo que
  muestre cuántas funciones hay de cada tamaño: cuántas contienen de 40 a 49
  palabras o símbolos, cuántas contienen de 50 a 59 palabras o símbolos, y
  así. Yo he sido con frecuencia curioso de cómo es una función típica, y
  esto se contará.

  Descrito en una frase, el proyecto desanima; pero dividido dentro de
  numerosos pequeños pasos, cada uno de los que podemos tomar en un momento,
  el proyecto llegar ser menos atemorizante. Permítenos considerar qué pasos
  deben ser:

  - Primero, escribe una función para contar las palabras en una
    definición. Esto incluye el problema de manejar símbolos tan bien como
    palabras.

  - Segundo, escribe una función para listar los números de palabras en cada
    función en un fichero. Esta función puede usar la función
    @c{count-words-in-defun}.

  - Tercero, escribe una función para listar los números de palabras en cada
    función en cada uno de varios ficheros. Esto encola automáticamente
    encontrando varios ficheros, cambiándolos, y contando las palabras en las
    definiciones con ellos.

  - Cuarto, escribe una función para convertir la lista de números que
    nosotros creamos en tres pasos para un formulario que se ajustará para
    imprimir un grafo.

  - Quinto, escribe una función para imprimir los resultados como un grafo.


  ¿Esto es un proyecto! Pero si tomamos cada paso lentamente, eso no será
  difícil.

** ¿Qué contar?

   Cuando nosotros primero empezamos pensando acerca del contaje de palabras
   en una definición de función, la primera pregunta es (o podría ser) ¿qué
   se va a contar?  Cuando se habla de ‘palabras’ con repecto a una
   definición de función Lisp, estamos actualmente hablando, en parte, de
   ‘símbolos’. Por ejemplo, la siguiente función @c{multiply-by-seven}
   contiene los cinco símbolos @c{defun}, @c{multipy-by-seven}, @c{number},
   @c{*}, y @c{7}. Además, en la cadena de documentación, contiene cuatro
   palabras @'{Multiplicar}, @'{NUMBER}, @'{por}, y @'{siete}. El símbolo
   @'{número} es repetido, así la definición contiene un total de diez
   palabras y símbolos.

   @smallexample
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
   @end smallexample

   Sin embargo, si se marca la definición @c{multiply-by-seven} con @k{C-M-h}
   (@c{mark-defun}), y entonces se llama a @c{@v{COUNT-WORDS}} dentro, se
   encontrará que @c{@v{COUNT-WORDS}} ¿reclama la definición tiene once
   palabras, no diez! ¿Alguna cosa está mal!

   El problema es doble: @c{@v{COUNT-WORDS}} no cuenta el @'{*} como una
   palabra, y eso cuenta el símbolo simple, @c{multiply-by-seven},
   conteniendo tres palabras. Las conexiones son tratadas como si fueran
   espacios entre palabras en vez de conectores entre palabras
   @'{multiply-by-seven} se cuenta como si fuese escrito
   @'{multiply-by-seven}.

   La causa de esta confusión es la expresión regular que busca la definición
   @c{@v{COUNT-WORDS}} que mueve el punto hacia delante palabra por
   palabra. En la versión canónica de @c{@v{COUNT-WORDS}}, el regexp es:

   @smallexample
     "\\w+\\W*"
   @end smallexample

   Esta expresión regular es un patrón definiendo una o más palabras
   constituyendo caracteres posiblemente seguidos por uno o más caracteres
   que no son palabras constituyentes. Esto significa que los ‘caracteres que
   constituyen palabras’ nos traen la cuestión de la sintaxis, que es el
   valor de una sección en sí.

** ¿Qué constituye una palabra o símbolo?

   Emacs trata diferentes caracteres perteneciendo a diferentes @:{categorías
   de sintaxis}. Por ejemplo, la expresión regular, @'{\\w+}, es un patrón
   especificando uno o más caracteres de @e{palabras constituyentes}. Los
   caracteres de palabras constituyentes son miembros de una categoría de
   sintaxis. Otras categoría de sintaxis incluye la clase de caracteres de
   puntuación, tales como el espacio en blanco o el caracter de
   tabulación. (Para más información, ver Seccion @"{La Tabla de Sintaxis} en
   @e(El Manual GNU Emacs), y Seccion @"{Tablas de Sintaxis) en @e(El Manual
   de Referencia GNU Emacs Lisp).)

   Las tablas de sintaxis especifican qué caracteres pertenecen a qué
   categorías. Normalmente un guión no está especificado como un ‘caracter
   constituido por una palabra’. En vez de eso, se especificó como estando en
   la ‘clase de caracteres que son parte de los nombres de símbolos, pero no
   las palabras.’  Esto significa que la función @c{@v{COUNT-WORDS}} se trata
   del mismo modo que trata un espacio en blanco entre palabras, que es el
   por qué @c{@v{COUNT-WORDS}} cuenta @'{multiply-by-seven} como tres
   palabras.

   Hay dos caminos para causar que Emacs cuente @'{multiply-by-seven} como un
   símbolo: modificar la tabla de sintaxis o modificar la expresión regular.

   Se podría redefinir un guión (@e{hyphen}) como un caracter que constituye
   una palabra modificando la tabla de sintaxis que Emacs guarda por cada
   modo. Esta acción serviría nuestro propósito, excepto que una conexión es
   meramente el caracter más común con símbolos que no son típicamente un
   caracter de palabra constituyente; hay otros, también.

   Alternativamente, se puede redefinir la expresión regular @e{regexp} usada
   en la definición @c{count-words} así como incluir símbolos. Este
   procedimiento tiene el mérito de la claridad, pero la tarea es un pequeño
   truco.

   La primera parte es suficientemente simple: el patrón debe asignarse “al
   menos un carácter que es una palabra o símbolo constituyente”. De este
   modo:

   @smallexample
     "\\(\\w\\|\\s_\\)+"
   @end smallexample

   El @'{\\(} es la primera parte del constructo que agrupa esto que incluye
   el @'{\\w} y el @'{\\s_} como alternativas, separadas por los @'{\\|}.  El
   @'{\\w} asocia cualquier caracter de palabra constituyente y el @'{\\s_}
   asocia cualquier caracter que es parte de un nombre de símbolo pero no una
   palabra de caracteres constituyente. El @'{+} sigue al grupo que indica
   que la palabra o símbolo constituyan caracteres que deben ser asociados al
   menos por uno.

   Sin embargo, la segunda parte de regexp es más difícil de diseñar. Lo que
   queremos es seguir la primera parte con “opcionalmente uno o más
   caracteres que no constituyen una palabra o símbolo”. Primero, se pensaba
   que se podría definir esto con lo siguiente:

   @smallexample
     "\\(\\W\\|\\S_\\)*"
   @end smallexample

   Las mayúsculas @'{W} y @'{S} asocian caracteres que @e{no} son
   constituyente de palabra o símbolo. Desafortunadamente, esta expresión
   asocia cualquier caracter que sea o no una palabra constituyente no un
   símbolo constituyente. ¿Esto asocia cualquier caracter!

   Entonces se notificó que cada palabra o símbolo en mi región test fué
   seguida por algún espacio (espacio en blanco, tabulador, o nueva
   línea). Así yo intenté emplazar un patrón para asociar uno o más espacios
   en blanco después del patrón para una o más palabras o símbolos
   constituyentes. Esto falló, también. Palabras y símbolos son con
   frecuencia separados por espacios en blanco, pero en el código actual los
   paréntesis pueden seguir símbolos y puntuación puede seguir las
   palabras. Así finalmente, se diseño un patrón en el que la palabra o
   símbolo constituyente es seguido opcionalmente por caracteres que no son
   espacios en blanco y entonces son seguidos opcionalmente por espacios en
   blanco.

   Aquí está la expresión regular completa:

   @smallexample
     "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
   @end smallexample

** La función @c{count-words-in-defun}

   Se ha visto que hay varios caminos para escribir una función
   @c{count-word-region}. Para escribir un @c{count-words-in-defun}, se
   necesita solamente adaptar una de estas versiones.

   La versión que usa un bucle @c{while} es fácil de comprender, así estoy
   yendo a adaptar esto. Porque @c{count-words-in-defun} será parte de un
   programa más complejo, eso no necesita ser interactivo y no necesita
   mostrar un mensaje pero solo devuelve el contaje. Estas consideraciones
   simplifican la definición un poco.

   Por otro lado, @c{count-words-in-defun} será usado con un buffer que
   contiene definiciones de función. Consiguientemente, es razonable
   preguntar que la función determina si se llamó cuando el punto está con
   una definición de función, y eso es, para devolver el contaje para esta
   definición. Esto añade complejidad a la definición, pero nos guarda desde
   la necesidad de pasar argumentos a la función.

   Estas consideraciones nos llevan a preparar la siguiente plantilla:

   @smallexample
     (defun count-words-in-defun ()
       "@var{documentation}…"
       (@var{set up}…
          (@var{while loop}…)
        @var{return count})
   @end smallexample

   Así, el trabajo es rellenar los slots.

   Primero, la configuración.

   Estamos presuponiendo que esta función será llamada con un búffer
   conteniendo definiciones de función. Apunta si será con una definición de
   función o no. Para que @c{count-words-in-defun} funcione, el punto debe
   moverse al principio de la definición, un contador debe empezar a cero, y
   el bucle contando debe parar cuando el punto logre el fin de la
   definición.

   La función @c{beginning-of-defun} busca atrás para un delimitador de
   apertura tal como @'{(} al principio de una línea, y mueve el punto a esta
   posición, o sino al límite de la búsqueda. En la práctica, esto significa
   que @c{beginning-of-defun} mueve el punto al principio de un cierre o
   definición de función precedente, o sino al principio del buffer.

   El bucle @c{while} requiere un contador para guardar la traza de las
   palabras o símbolos siendo contados. Una expresión @c{let} puede ser usado
   para crear una variable local para este propósito, y lo asocia a un valor
   inicial de cero.

   La función @c{end-of-defun} funciona como @c{beginning-of-defun} excepto
   que mueve el punto al fin de la definición. @c{end-of-defun} puede ser
   usado como parte de una expresión que determina la posición del fin de la
   definición.

   La configuración para @c{count-words-in-defun} toma forma rápidamente:
   primero movemos el punto al principio de la definición, entonces se crea
   una variable local para manejar el conteo, y finalmente, se graba la
   posición del fin de la definición así el bucle @c{while} conocerá cuando
   parar el bucle.

   El código se parece a esto:

   @smallexample
     (beginning-of-defun)
     (let ((count 0)
           (end (save-excursion (end-of-defun) (point))))
   @end smallexample

   El código es simple. La única ligera complicación es probablemente ir al
   @c{end}: eso está asociado a la posición del fin de la definición por una
   expresión @c{save-excursion} que devuelve el valor del punto después de
   @c{end-of-defun} temporalmente se mueve al fin de la definición.

   La segunda parte del @c{count-words-in-defun}, después de la
   configuración, es el bucle @c{while}.

   El bucle debe contener una expresión que mueva el punto hacia adelante
   palabra por palabra y símbolo por símbolo, y otra expresión que cuente los
   saltos. El test-verdadero-o-falso para el bucle @c{while} chequearía
   verdadero tan largo como el punto debería saltar hacia adelante, y falso
   si apunta al fin de la definición. Ya se ha redefinido la expresión
   regular para esto, así el bucle es sencillo:

   @smallexample
     (while (and (< (point) end)
                 (re-search-forward
                  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t)
       (setq count (1+ count)))
   @end smallexample

   La tercera parte de la definición devuelve el contaje de palabras y
   símbolos. Esta parte es la última expresión con el cuerpo de la expresión
   @c{let}, y puede ser, muy la variable local @c{count}, que cuando se
   evalúa devuelve el contaje.

   Puesto junto, la definición @c{count-words-in-defun} se ve así:

   @smallexample
     (defun count-words-in-defun ()
       "Devuelve el número de palabras y símbolos en una defun."
       (beginning-of-defun)
       (let ((count 0)
             (end (save-excursion (end-of-defun) (point))))
         (while
             (and (< (point) end)
                  (re-search-forward
                   "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
                   end t))
           (setq count (1+ count)))
         count))
   @end smallexample

   ¿Cómo se chequea esto? La función no es interactiva, pero es fácil poner
   un envoltorio alrededor de la función para hacerla interactiva; se puede
   usar casi el mismo código como la versión recursiva de
   @c{@v{COUNT-WORDS}}:

   @smallexample
     ;;; @r{Versión Interactiva.}
     (defun count-words-defun ()
       "Número de palabras y símbolos en una definición
       de función."
       (interactive)
       (message
        "Contando palabras y símbolos en la definición de función ... ")
       (let ((count (count-words-in-defun)))
         (cond
          ((zerop count)
           (message
            "La definición NO tiene palabras o símbolos."))
          ((= 1 count)
           (message
            "La definición tiene 1 palabra o símbolo."))
          (t
           (message
            "La definición tiene %d palabras o símbolos." count)))))
   @end smallexample

   Permite reutilizar @k{C-c =} como un atajo conveniente:

   @smallexample
     (global-set-key "\C-c=" 'count-words-defun)
   @end smallexample

   Ahora se puede intentar @c{count-words-defun}: instala ambas funciones
   @c{count-words-in-defun} y @c{count-words-defun}, y asigna el atajo, y
   entonces emplaza el cursor con la siguiente definición:

   @smallexample
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
          ⇒ 10
   @end smallexample

   ¿Éxito! La definición tiene 10 palabras y símbolos.

   El siguiente problema es contar los números de palabras y símbolos en
   varias definiciones con un fichero simple.

** Contar varias @c{defuns} en un fichero

   Un fichero tal como @f{simple.el} puede tener un centenar o más
   definiciones de función dentro. Nuestro objetivo es recoger estadísticas
   en muchos ficheros, pero en un primer paso, nuestro objetivo inmediato es
   recoger estadísticas en un fichero.

   La información será una serie de números, cada número siendo el tamaño de
   una definición de función. Se pueden almacenar los números en una lista.

   Se sabe que se querrá incorporar la información considerando un fichero
   con información acerca de muchos otros ficheros; esto significa que la
   función para contar el tamaño de contaje con un fichero solo necesita
   devolver la lista de tamaños. Eso no necesita y no mostraría mensajes.

   Los comando de contar palabras contienen una expresión para saltar el
   punto hacia adelante palabra por palabra y otra expresión para contar los
   saltos. La función devuelve los tamaños de definiciones que pueden ser
   diseñadas para trabajar del mismo modo, con una expresión para saltar el
   punto hacia la definición por definición y otra expresión para construir
   el tamaño de la lista.

   Esta frase del problema hace elemental escribir la definición de
   función. Claramente, empezaremos el conteo al principio del fichero, así
   el primer comando será @c{(goto-char (point-min))}. Lo siguiente, es
   empezar el bucle @c{while}; y este true-or-false del bucle puede ser una
   búsqueda de expresión regular para la siguiente definición de función ---
   así en el momento que la búsqueda tiene éxito, el punto se mueve hacia
   adelante y entonces el cuerpo del bucle es evaluado. El cuerpo necesita
   una expresión que construye la lista de tamaños. @c{cons}, la lista de
   construcción del comando, puede ser usado para crear la lista. Esto es
   casi todo lo que hay.

   Aquí está este fragmento de código que se ve así:

   @smallexample
     (goto-char (point-min))
     (while (re-search-forward "^(defun" nil t)
       (setq lengths-list
             (cons (count-words-in-defun) lengths-list)))
   @end smallexample

   Dejamos fuera el mecanismo para encontrar el fichero que contiene las
   definiciones de función.

   En ejemplos previos, nosotros habíamos usado esto, el fichero Info, o
   cambiamos atrás y adelante a algún otro búffer, tal como el búffer
   @f{*scratch*}.

   Encontrar un fichero es un nuevo proceso que no tenemos todavía discutido.

** Encontrar un fichero

   Para encontrar un fichero en Emacs, se usa el comando @k{C-x C-f}
   (@c{find-file}). Este comando es casi, pero no bastante correcto para el
   problema de tamaños.

   Permita mirar el fuente para @c{find-file}:

   @smallexample
     (defun find-file (filename)
       "Edita el fichero FILENAME.
     Cambia a un búffer visitando el fichero FILENAME,
     creando uno si no existe ya."
       (interactive "FFind file: ")
       (switch-to-buffer (find-file-noselect filename)))
   @end smallexample

   (La versión más reciente de la definición de función @c{find-file} permite
   comodines especiales para visitar múltiples ficheros; que hacen la
   definición más compleja y no se discutirá aquí, ya que no es relevante. Se
   pueden ver sus fuentes usando @k{M-.} (@c{find-tag}) o @k{C-h f}
   (@c{describe-function}).)

   @ignore
     In Emacs 22
     (defun find-file (filename &optional wildcards)
       "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     Interactively, the default if you just type RET is the current directory,
     but the visited file name is available through the minibuffer history:
     type M-n to pull it into the minibuffer.

     Interactively, or if WILDCARDS is non-nil in a call from Lisp,
     expand wildcards (if any) and visit multiple files.  You can
     suppress wildcard expansion by setting ‘find-file-wildcards’ to nil.

     To visit a file without any kind of conversion and without
     automatically choosing a major mode, use \\[find-file-literally]."
       (interactive (find-file-read-args "Find file: " nil))
       (let ((value (find-file-noselect filename nil nil wildcards)))
         (if (listp value)
             (mapcar 'switch-to-buffer (nreverse value))
           (switch-to-buffer value))))
   @end ignore

   La definición que se está mostrando posee una documentación corta, pero
   completa y una especificación interactiva que muestra un nombre de fichero
   cuando se usa el comando interactivamente. El cuerpo de la definición
   contiene dos funciones, @c{find-file-noselect} y @c{switch-to-buffer}.

   De acuerdo a su documentación como muestra por @k{C-h f} (el comando
   @c{describe-function}), la función @c{find-file-noselect} lee el fichero
   nombrado dentro de un búffer y devuelve el búffer. (Su versión más
   reciente incluye un argumento comodín, también, así como otro para leer un
   fichero literalmente y otro que suprime mensajes de aviso. Estos
   argumentos opcionales son irrelevantes.)

   Sin embargo, la función @c{find-file-noselect} no selecciona el búffer en
   el que se pone el fichero. Emacs no cambia su atención (o la tuya si estás
   usando @c{find-file-noselect}) al búffer seleccionado. Esto es lo que
   @c{switch-to-buffer} hace: eso cambia el búffer al que se dirige la
   atención de Emacs; y eso cambia el búffer mostrado en la ventana al nuevo
   búffer. Se ha discutido el búffer cambiando a otro lugar. (Véase Sección
   @l{Cambiando búffers}.)

   En este proyecto de histograma, no se necesita mostrar cada fichero en la
   pantalla como el programa determina el tamaño de cada definición con
   eso. En vez de emplear @c{switch-to-buffer}, se puede trabajar con
   @c{set-buffer}, que redirige la atención del programa de ordenador para un
   búffer diferente pero no lo muestra en pantalla. Así en vez llamar a
   @c{find-file} para hacer el trabajo, debe escribir nuestra expresión.

   La tarea es fácil: usar @c{find-file-noselect} y @c{set-buffer}.

** @c{lengths-list-file} en detalle

   El núcleo de la función @c{lengths-list-file} es un bucle @c{while}
   conteniendo una función para mover el punto hacia delante ‘función a
   función’ y una función para contar el número de palabras y símbolos en
   cada función. Este núcleo debe ser rodeado por funciones que hacen otras
   tareas varias, incluyendo encontrar el fichero, y asegurando que el punto
   empieza al principio del fichero. La definición de la función se parece a:
   @findex lengths-list-file

   @smallexample
     (defun lengths-list-file (filename)
       "Devuelve la lista de tamaños de definiciones con FILE.
     La lista devuelta es una lista de números.
     Cada número es el número de palabras o
     símbolos en una definición."
       (message "Trabajando en `%s' ... " filename)
       (save-excursion
         (let ((buffer (find-file-noselect filename))
               (lengths-list))
           (set-buffer buffer)
           (setq buffer-read-only t)
           (widen)
           (goto-char (point-min))
           (while (re-search-forward "^(defun" nil t)
             (setq lengths-list
                   (cons (count-words-in-defun) lengths-list)))
           (kill-buffer buffer)
           lengths-list)))
   @end smallexample

   La función pasa un argumento, el nombre del fichero en el que se
   trabajará. Eso tiene cuatro líneas de documentación, pero sin
   especificación interactiva. Para evitar la preocupación de si se ha
   estropeado el programa o no, la primera línea del cuerpo es un mensaje de
   aviso.

   La siguiente línea contiene un @c{save-excursion} que devuelve a Emacs la
   atención al actual búffer cuando la función se completa. Esto es útil en
   caso de embeber esta función en otra función que presume que el punto
   restaura el búffer original.

   En la varlist de la expresión @c{let}, Emacs encuentra el fichero y ajusta
   la variable local @c{buffer} al búffer conteniendo el fichero. Al mismo
   tiempo, Emacs crea @c{lengths-list} como una variable local.

   Lo siguiente, Emacs cambia su atención al búffer.

   En la siguiente línea, Emacs crea el búffer de solo lectura. Idealmente,
   esta línea no es necesaria. Ninguna de las funciones para contar palabras
   y símbolos en una definición de función cambiaría el búffer. Debajo, el
   búffer no está yendo para ser guardado, incluso si eso fuese
   cambiado. Esta línea es enteramente la consecuencia grata, quizás excesiva
   precaución. La razón para la precaución es que esta función y esta se
   llama a trabajar en las fuentes para Emacs y eso es un inconveniente si
   están inadvertidamente modificadas. Eso va sin decir que no se realizó una
   necesidad para esta línea hasta que un experimento fué cambiado hacia un
   lado y empezó a modificar mis ficheros de fuentes Emacs …

   Lo siguiente llama a alargar el búffer si eso está encogido. Esta función
   es normalmente innecesaria––Emacs crea un búffer fresco si ninguno ya
   existe; pero si un búffer está visitando el fichero que ya existe que
   Emacs devuelve uno. En este caso, el búffer puede ser encogido y debe ser
   amplio. Si se quiere ser completamente ‘amigo del usuario’, se pondría en
   orden para guardar la restricción y la localización del punto, pero no.

   La expresión @c{(goto-char (point-min))} mueve el punto al principio del
   búffer.

   Entonces llega un bucle @c{while} en el que se devuelve el ‘trabajo’ de la
   función. En el bucle, Emacs determina el tamaño de cada definición y
   construye una lista de tamaños conteniendo la información.

   Emacs corta el búffer después de trabajar a través de eso. Esto es guardar
   espacio dentro de Emacs. Mi versión de GNU Emacs 19 contenía 300 ficheros
   fuente de interés; GNU Emacs 22 contiene a través de un millar de ficheros
   fuente. Otra función aplicará @c{lengths-list-file} a cada uno de los
   ficheros.

   Finalmente, la última expresión con la expresión @c{let} es la variable
   @c{lengths-list}; su valor es devuelto como el valor de la función
   completa.

   Se puede probar esta función instalándolo en el modo usual. Entonces
   posiciona tu cursor después de la siguiente expresión y escribe @k{C-x
   C-e} (@c{eval-last-sexp}).

   @smallexample
     (lengths-list-file
      "/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el")
   @end smallexample

   (Se puede necesitar cambiar la ruta del fichero; el único aquí es para GNU
   Emacs versión 22.1.1. Para cambiar la expresión, cópialo al búffer
   @f{*scratch*} y edítalo.

   (También, para ver el tamaño completo de la lista, en vez de una versión
   truncada se puede tener que evaluar lo siguiente:

   @smallexample
     (custom-set-variables '(eval-expression-print-length nil))
   @end smallexample

   (Véase Sección @l{Especificar Variables usando @c{defcustom}}. Entonces
   evalúa la expresión @c{lengths-list-file}.)

   La lista de tamaños para @f{debug.el} toma menos de un segundo para
   producirse esto en GNU Emacs 22:

   @smallexample
     (83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
   @end smallexample

   (Usando mi vieja máquina, la versión 19 lista tamaños para @f{debug.el}
   que en siete segundos para producen esto:

   @smallexample
     (75 41 80 62 20 45 44 68 45 12 34 235)
   @end smallexample

   (La versión nueva de @f{debug.el} contiene más defuns que la temprana; y
   mi nueva máquina es más rápida que la vieja.

   Nótese que el tamaño de la última definición en el fichero es el primero
   en la lista.

** Contar palabras en @c{defuns} en diferentes ficheros

   En la sección previa, se creaba una función que devuelve una lista de los
   tamaños de cada definición en un fichero. Ahora, se quiere definir una
   función para devolver una lista maestra de los tamaños de las definiciones
   en una lista de ficheros.

   Trabajar en cada elemento de una lista de ficheros es un acto repetitivo,
   así se puede usar un bucle @c{while} o recursión.

   El diseño usando un bucle @c{while} es rutina. El argumento que se pasaba
   a la función es una lista de ficheros. Como se vió pronto (Vease Sección
   @l{Ejemplo de bucle}), se puede escribir un bucle @c{while} de un modo que
   el cuerpo del bucle es evaluado si tal lista contiene elementos, pero sale
   del bucle si la lista está vacía. Para que este diseño funcione, el cuerpo
   del bucle debe contener una expresión que ordene la lista cada vez que el
   cuerpo es evaluado, de modo que finalmente la lista esté vacía. La técnica
   normal es asignar el valor de la lista para el valor del @Cc{cdr} de la
   lista cada vez que el cuerpo es evaluado.

   La plantilla se ve así:

   @smallexample
     (while @var{test-whether-list-is-empty}
       @var{body}…
       @var{set-list-to-cdr-of-list})
   @end smallexample

   También, recuérdanos que un bucle @c{while} devuelve @c{nil} (el resultado
   de evaluar el true-or-false-test), no el resultado de cualquier evaluación
   con su cuerpo. (Las evaluaciones con el cuerpo del bucle son hechas para
   sus efectos laterales.) Sin embargo, la expresión que asigna la lista de
   tamaños es parte del cuerpo––y que es el valor que queremos devuelto por
   la función como un todo. Para hacer esto cerramos el bucle @c{while} con
   una expresión @c{let}, y pone en orden que el último elemento de la
   expresión @c{let} contiene el valor de lista de tamaños. (Véase Sección
   @l{Ejemplo de Incremento, , El Ejemplo del Bucle con un Contador de
   Incremento}.)

   Estas consideraciones lideran directamente a la función en sí:

   @smallexample
     ;;; @r{Usar bucle @c{while}.}
     (defun lengths-list-many-files (list-of-files)
       "Devuelve la lista de tamaños de funciones en LIST-OF-FILES."
       (let (lengths-list)

     ;;; @r{true-or-false-test}
         (while list-of-files
           (setq lengths-list
                 (append
                  lengths-list

     ;;; @r{Genera una lista de tamaños.}
                  (lengths-list-file
                   (expand-file-name (car list-of-files)))))

     ;;; @r{Crea una lista ordenada de ficheros.}
           (setq list-of-files (cdr list-of-files)))

     ;;; @r{Devuelve la lista final de valores de tamaños.}
         lengths-list))
   @end smallexample

   @c{expand-file-name} es una función construida que convierte un nombre de
   fichero al absoluto, forma de nombre de ruta. La función emplea el nombre
   del directorio en el que la función se llama.

   De este modo, si @c{expand-file-name} es llamado en @c{debug.el} cuando
   Emacs está visitando el directorio
   @f{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/}

   @smallexample
     debug.el
   @end smallexample

   llega a ser

   @smallexample
     /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
   @end smallexample

   El único nuevo elemento de esta definición de función es la todavía no
   estudiada función @c{append}, que merece una corta sección en sí.

*** La función @c{append}

    La función @c{append} adjunta una lista a otra. De este modo,

    @smallexample
      (append '(1 2 3 4) '(5 6 7 8))
    @end smallexample

    produce la lista

    @smallexample
      (1 2 3 4 5 6 7 8)
    @end smallexample

    Esto es exactamente cómo queremos adjuntar dos listas de tamaños
    producidas por @c{lengths-list-file} a cualquier otra. Los resultados
    contrastan con @c{cons},

    @smallexample
      (cons '(1 2 3 4) '(5 6 7 8))
    @end smallexample

    que construye una nueva lista en el que el primer argumento para @c{cons}
    llega a ser el primer elemento de la nueva lista:

    @smallexample
      ((1 2 3 4) 5 6 7 8)
    @end smallexample

** Recursivamente cuenta palabras en diferentes ficheros

   Bajo un bucle @c{while}, se puede trabajar cada lista de ficheros con
   recursión. Una versión recursiva de @c{lengths-list-many-files} es corta y
   simple.

   La función recursiva tiene las partes normales: el ‘do-again-test’, la
   ‘next-step-expression’, y la llamada recursiva. El ‘do-again-test’
   determina si la función se llamaría, que hará si la @c{list-of-files}
   contiene los elementos que permanecen; la ‘next-step-expression’ resetea
   el @c{list-of-files} al @Cc{cdr} en sí, así finalmente la lista será
   vacía; y la llamada recursiva llama en sí a la lista ordenada. ¿La función
   completa está ordenada por esta descripción!

   @smallexample
     (defun recursive-lengths-list-many-files (list-of-files)
       "Devuelve la lista de tamaños de cada defun en LIST-OF-FILES."
       (if list-of-files                     ; @r{do-again-test}
           (append
            (lengths-list-file
             (expand-file-name (car list-of-files)))
            (recursive-lengths-list-many-files
             (cdr list-of-files)))))
   @end smallexample

   En una frase, la función devuelve de tamaños de la lista para la el
   primero de la @c{list-of-files} al resultado de llamarse así mismo al
   resto de @c{list-of-files}.

   Aquí hay un test @c{recursive-lengths-list-many-files}, a lo largo de los
   resultados de ejecutar @c{lengths-list-file} en cada uno de los ficheros
   individualmente.

   Instala @c{recursive-lengths-list-many-files} y @c{lengths-list-file}, si
   es necesario, y entonces evalúa las siguientes expresiones. Se puede
   necesitar cambiar las rutas de ficheros; aquí se trabaja cuando este
   fichero Info y las fuentes de Emacs están localizadas en sus lugares
   personales. Para cambiar las expresiones, cópialas al búffer
   @f{*scratch*}, edítalos y entonces evalúalos.

   Los resultados son mostrados después del @'{⇒}. (Estos resultados son para
   ficheros de Emacs versión 22.1.1; ficheros desde otras versiones de Emacs
   puede producir diferentes resultados.)

   @smallexample
     (cd "/usr/local/share/emacs/22.1.1/")

     (lengths-list-file "./lisp/macros.el")
          ⇒ (283 263 480 90)

     (lengths-list-file "./lisp/mail/mailalias.el")
          ⇒ (38 32 29 95 178 180 321 218 324)

     (lengths-list-file "./lisp/makesum.el")
          ⇒ (85 181)

       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mail/mailalias.el"
          "./lisp/makesum.el"))
            ⇒ (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)
   @end smallexample

   La función @c{recursive-lengths-list-many-files} produce la salida que
   queremos.

   El siguiente paso es preparar el dato en la lista para mostrarlo en un
   grafo.

** Preparar los datos para mostrarlos en un grafo

   La función @c{recursive-lengths-list-many-files} devuelve una lista de
   números. Cada número graba el tamaño de una definición de función. Lo que
   se necesita hacer ahora es transformar estos datos dentro de una lista de
   números ajustado para generar un grafo. La nueva lista contará cuántas
   definiciones de funciones contienen menos de 10 palabras y símbolos,
   cuantas contienen entre 10 y 19 palabras y símbolos, cuántas contienen
   entre 20 y 29 palabras y símbolos, y así.

   En breve, se necesita ir a través el tamaño de la lista producida por la
   función @c{recursive-lengths-list-many-files} y contar el número de defuns
   con cada rango de tamaños, y produce una lista de esto de números.

   Basado en lo que hemos hecho antes, se prevee que no sería difícil
   escribir una función que ‘@Cc{cdr}s’ bajo la lista de tamaños, parece que
   cada elemento, determina que rango de tamaños está dentro, e incrementa un
   contador para este rango.

   Sin embargo, antes de empezar a escribir tal función, nosotros
   consideraríamos las ventajas de ordenar los tamaños de la lista primero,
   así los números son ordenados desde el más pequeño al más largo. Primero,
   ordenando se hará fácil contar los números en cada rango, desde dos
   números adyacentes será el mismo rango del tamaño en rangos
   adyacentes. Segundo, inspeccionando una lista ordenada, se puede descubrir
   el número mayor y menor, y esto significa determinar el rango de tamaño
   mayor y menor que necesitará.

*** Ordenando listas

    Emacs contiene una función para listas ordenadas, llamadas (como se
    podría adivinar) @c{sort}. La función @c{sort} toma dos argumentos, la
    lista es ordenada, y un predicado que determina si la primera de dos
    elementos de lista es “menor” que la segunda.

    Como se vió antes (Vease Sección @"{Usando el Tipo Incorrecto de Objeto
    como un Argumento}), un predicado es una función que determina si alguna
    propiedad es verdadera o falsa. La función @c{sort} reordenará una lista
    de acuerdo a lo que la propiedad del predicado usa; esto significa que
    @c{sort} puede ser usado para ordenar listas no numéricas por un criterio
    no numérico --- eso puede, por ejemplo, alfabetizar una lista.

    La función @c{<} se usa cuando se ordena una lista numérica. Por ejemplo,

    @smallexample
      (sort '(4 8 21 17 33 7 21 7) '<)
    @end smallexample

    produce esto:

    @smallexample
      (4 7 7 8 17 21 21 33)
    @end smallexample

    (Note que en este ejemplo, ambos argumentos se citan así que los símbolos
    no se evalúan antes de ser pasados por @c{sort} como argumentos.)

    Ordenando la lista devuelta por la función
    @c{recursive-lengths-list-many-files} es honesta; eso usa la funci@'n
    @c{<}:

    @ignore
      2006 Oct 29
      In GNU Emacs 22,  eval
      (progn
        (cd "/usr/local/share/emacs/22.0.50/")
        (sort
         (recursive-lengths-list-many-files
          '("./lisp/macros.el"
            "./lisp/mail/mailalias.el"
            "./lisp/makesum.el"))
         '<))

    @end ignore

    @smallexample
      (sort
       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mailalias.el"
          "./lisp/makesum.el"))
       '<)
    @end smallexample

    que produce:

    @smallexample
      (29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)
    @end smallexample

    (Note que en este ejemplo, el primer argumento para @c{sort} no está
    citado, desde que la expresión debe ser evaluado así como producir la
    lista que es pasada para @c{sort}.)

*** Creando una lista de ficheros

    La función @c{recursive-lengths-list-many-files} requiere una lista de
    fichero como argumento. Para nuestros ejemplos de test, se construyeron
    tal como una lista a mano; pero el directorio fuente de Emacs Lisp es
    demasiado grande para hacer esto. Así, se escribirá una función para
    hacer el trabajo. En esta función, se usa tanto un bucle @c{while} como
    una llamada recursiva.

    En viejas versiones de GNU Emacs no hizo falta tener que escribir esta
    función, puesto que todos los ficheros @'{.el} en un directorio. En vez
    de eso, se puede ser capaz de usar la función @c{directory-files}, que
    lista los nombres de fichero que hay en un directorio simple.

    Sin embargo, las versiones reciente Emacs emplazan ficheros de Emacs Lisp
    en subdirectorios del directorio de alto nivel @f{lisp}. Esto facilita la
    navegación. Por ejemplo, todos los ficheros de correo relacionados que
    están en el subdirectorio llamado @f{mail}. Pero al mismo tiempo, esta
    facilidad fuerza a crear un fichero listando la función que desciende
    dentro de los subdirectorios.

    Se puede crear esta función, llamada @c{files-en-below-directory}, usando
    funciones familiares tales como @c{car}, @c{nthcdr}, y @c{substring} en
    conjunción con una función existente llamada
    @c{directory-files-and-attributes}. Esta última función no solo listas de
    ficheros en un directorio, incluyendo los nombres de subdirectorios, pero
    también sus atributos.

    Para empezar nuestro objetivo: crear una función que nos permita
    alimentas ficheros a @c{recursive-lengths-list-many-files} como una lista
    que se parece a esto (pero con más elementos):

    @smallexample
      ("./lisp/macros.el"
       "./lisp/mail/rmail.el"
       "./lisp/makesum.el")
    @end smallexample

    La función @c{directory-files-and-attributes} devuelve una lista de
    listas. Cada una de las listas con la lista principal consiste de 13
    elementos. El primer elemento es una cadena que contiene el nombre del
    fichero -- que, en GNU/Linux, puede ser un ‘directorio fichero’, que
    dice, un fichero con los atributos especiales de un directorio. El
    segundo elemento de la lista es @c{t} para un directorio, es una cadena
    para el enlace simbólico (la cadena es el nombre enlazado), o @c{nil}.

    Por ejemplo, el primer fichero @'{.el} en el directorio es
    @f{abbrev.el}. Su nombre es
    @f{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} y no es un directorio o
    un enlace simbólico.

    Esto es cómo @c{directory-files-and-attributes} lista este fichero y sus
    atributos:

    @smallexample
      ("abbrev.el"
      nil
      1
      1000
      100
      (20615 27034 579989 697000)
      (17905 55681 0 0)
      (20615 26327 734791 805000)
      13188
      "-rw-r--r--"
      nil
      2971624
      773)
    @end smallexample

    Por otro lado, @f{mail/} es un directorio con el directorio @f{lisp/}. El
    principio del listado se parece a esto:

    @smallexample
      ("mail"
      t
      …
      )
    @end smallexample

    (Para aprender acerca de los diferentes atributos, mira en la
    documentación de @c{file-attributes}. Tenga en mente que la función
    @c{file-attributes} no lista el nombre del fichero, así su primer
    elemento es @c{directory-files-and-attributes} que es el segundo
    elemento.)

    Se querrán nuestras nuevas funciones, @c{files-in-below-directory}, para
    listar los fichero @'{.el} en el directorio eso es contado para chequear,
    y en los directorios bajo este directorio.

    Esto nos da una sugestión de como construir @c{files-in-below-directory}:
    con un directorio, la función añadir los nombres de ficheros @'{.el} a
    una lista; y si, con un directorio, la función viene con un
    subdirectorio, iría dentro de este subdirectorio y repite sus acciones.

    Sin embargo, nosotros notaríamos que cada directorio contiene un nombre
    que se refiere a sí mismo, llamado @f{.}, (“dot”) y un nombre que se
    refiere a su directorio padre, llamado @f{..} (“doble punto”). (En @f{/},
    el directorio raíz, @f{..} se refiere así mismo, desde que @f{/} no tiene
    padre.) Claramente, no que se quiere nuestra función
    @c{files-in-below-directory} para introducir estos directorio, desde que
    ellos siempre nos lideran, directamente o indirectamente, al directorio
    actual.

    Consecuentemente, nuestra función @c{files-in-below-directory} debe hacer
    varias tareas:

    - Chequee para ver si se está mirando en un nombre de fichero que
      finaliza en @'{.el} y si es así, se añade el nombre a una lista.

    - Chequee para ver si está mirando en un nombre de fichero que es el
      nombre de un directorio; y si es así,

      - Chequee para ver si está mirando en @f{.} o @f{..}; y si es así sal.

      - O además, ve dentro de este directorio y repite el proceso.


    Se permite escribir una definición de función para hacer estas tareas. Se
    usará un bucle @c{while} para mover de un nombre de fichero a otro con un
    directorio chequeando lo que necesita ser hecho; y se usa una llamada
    recursiva para repetir las acciones en cada subdirectorio. El patrón
    recursivo es ‘acumular’ (Vease Sección @l{Patrón recursivo:
    @e{accumulate}}) usando @c{append} para combinar.

    @ignore
      (directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
      (shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

      (directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
      (shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
    @end ignore

    Aquí está la función:

    @smallexample
      (defun files-in-below-directory (directory)
        "Lista los ficheros .el en DIRECTORIO y en sus subdirectorios."
        ;; Aunque la función será usada no interactivamente,
        ;; será fácil chequear si lo hacemos interactivo.
        ;; El directorio tendrá un nombre tal como
        ;;  "/usr/local/share/emacs/22.1.1/lisp/"
        (interactive "DNombre del Directorio: ")
        (let (el-files-list
              (current-directory-list
               (directory-files-and-attributes directory t)))
          ;; mientras estamos en el directorio actual
          (while current-directory-list
            (cond
             ;; chequee para ver si el nombre del fichero finaliza en ‘.el’
             ;; y si es así, añade su nombre a una lista.
             ((equal ".el" (substring (car (car current-directory-list)) -3))
              (setq el-files-list
                    (cons (car (car current-directory-list)) el-files-list)))
             ;; chequee si el nombre del fichero es un directorio
             ((eq t (car (cdr (car current-directory-list))))
              ;; decide si salir o hacer recursión
              (if
                  (equal "."
                         (substring (car (car current-directory-list)) -1))
                  ;; entonces no hagas nada puesto que el nombre del fichero es
                  ;; el actual directorio o padre, "." o ".."
                  ()
                ;; else desciende dentro del directorio y repite el proceso
                (setq el-files-list
                      (append
                       (files-in-below-directory
                        (car (car current-directory-list)))
                       el-files-list)))))
            ;; mueve al siguiente fichero en la lista; esto también
            ;; ordena la lista así mientras el bucle
            ;; eventualmente llega a un fin
            (setq current-directory-list (cdr current-directory-list)))
          ;; devuelve los ficheros
          el-files-list))
    @end smallexample

    Las funciones @c{files-in-below-directory} @c{directory-files} toma un
    argumento, el nombre de un directorio.

    De este modo, en mi sistema,

    @smallexample
      (length
       (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
    @end smallexample

    se cuenta que dentro y debajo de mi directorio de fuentes Lisp hay 1031
    ficheros @'{.el}

    @c{files-in-below-directory} devuelve una lista en orden alfabético
    inverso. Una expresión para ordenar la lista en orden que parece como
    este:

    @smallexample
      (sort
       (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
       'string-lessp)
    @end smallexample

    @ignore
      (defun test ()
        "Test how long it takes to find lengths of all sorted elisp defuns."
        (insert "\n" (current-time-string) "\n")
        (sit-for 0)
        (sort
         (recursive-lengths-list-many-files
          (files-in-below-directory "/usr/local/src/emacs/lisp/"))
         '<)
        (insert (format "%s" (current-time-string))))
    @end ignore

*** Contando definiciones de función

    Nuestro objetivo inmediato es generar una lista que cuenta, cuantas
    definiciones de funciones contienen menos de 10 palabras y símbolos,
    cuantas contienen entre 10 y 19 palabras y símbolos, cuantas contienen
    entre 20 y 29 palabras y símbolos, y así.

    Con una lista ordenada de números, es fácil: se cuentan cuantos elementos
    de la lista son más pequeños de 10, entonces, se devuelven los números
    contados, se cuenta cuantos son más pequeños de 20, entonces se devuelven
    los números contados, después se cuentan los que son más pequeños de 30,
    y así. Cada uno de los números, 10, 20, 30, 40, y como, es más grande que
    el tope de este rango. Se puede llamar a la lista de tales números, la
    lista @c{top-of-ranges}.

    Si se desea, se podría generar esta lista automáticamente, pero es más
    simple escribir una lista manualmente. Aquí está: @vindex top-of-ranges

    @smallexample
      (defvar top-of-ranges
       '(10  20  30  40  50
         60  70  80  90 100
        110 120 130 140 150
        160 170 180 190 200
        210 220 230 240 250
        260 270 280 290 300)
       "Listar especificando rangos para ‘defuns-per-range’.")
    @end smallexample

    Para cambiar los rangos, se edita esta lista.

    Lo siguiente, que se necesita es escribir la función que crea la lista
    del número de definiciones con cada rango. Claramente, esta función debe
    tomar el @c{sorted-lengths} y las listas @c{top-of-ranges} listas como
    argumentos.

    La función @c{defuns-per-range} debe hacer dos cosas una y otra vez: eso
    debe contar el número de definiciones con un rango específico por el
    actual valor top-of-range; y eso debe dividir al siguiente gran valor en
    la lista @c{top-of-ranges} después de contar el número de definiciones en
    el rango actual. Desde que cada una de estas acciones es repetitiva, se
    puede usar los bucles @c{while} para el trabajo. Un bucle cuenta el
    número de definiciones en el rango definido por el valor actual
    top-of-range, y el otro bucle selecciona cada uno de los valores
    top-of-range en turno.

    Varias entradas de la lista @c{sorted-lengths} se cuentan para cada
    rango; esto significa que el bucle para la lista @c{sorted-lengths} será
    dentro del bucle para la lista @c{top-of-ranges}, como un pequeño adorno
    dentro de un gran adorno.

    El bucle interno cuenta el número de definiciones con el rango. Eso es un
    simple contaje del tipo en el que se ha visto antes. (Véase Sección @l{Un
    bucle con un contaje incremental}). El test true-or-false del bucle
    chequea si el valor desde la lista @c{sorted-lengths} es más pequeña que
    el actual valor de lo alto del rango. Si es así, la función incrementa el
    contador y se chequea el siguiente valor desde la lista
    @c{sorted-lengths}.

    El bucle interno se parece a esto:

    @smallexample
      (while @var{length-element-smaller-than-top-of-range}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
    @end smallexample

    El bucle de fuera debe empezar con el valor más bajo de la lista
    @c{top-of-ranges}, y entonces se asigna a cada uno de los valores
    superiores exitosos a su vez. Esto puede ser hecho con un bucle como
    este:

    @smallexample
      (while top-of-ranges
        @var{body-of-loop}…
        (setq top-of-ranges (cdr top-of-ranges)))
    @end smallexample

    Se ponen juntos, los dos bucles como este:

    @smallexample
      (while top-of-ranges

        ;; @r{Contar el número de elementos con el actual rango.}
        (while @var{length-element-smaller-than-top-of-range}
          (setq number-within-range (1+ number-within-range))
          (setq sorted-lengths (cdr sorted-lengths)))

        ;; @r{Mover al siguiente rango.}
        (setq top-of-ranges (cdr top-of-ranges)))
    @end smallexample

    Además, en cada circuito del bucle exterior, Emacs grabaría el número de
    definiciones con este rango (el valor de @c{number-within-range}) en una
    lista. Se puede usar @c{cons} para este propósito. (Véase Sección
    @l{@c{cons}}.)

    La función @c{cons} trabaja bien, excepto que la lista que se construye
    contendrá el número de definiciones para el alto rango y su principio el
    número de definiciones para el más bajo rango a su fin. Esto es porque
    @c{cons} adjunta nuevos elementos de la lista al principio de la lista, y
    desde los dos bucles que hacen cálculos a través de la lista de tamaños
    desde lo bajo finaliza primero, el @c{defuns-per-range-list} finalizará
    el primer número más largo. Pero lo que se quiere es imprimir nuestro
    grafo con pequeños valores primero y el más grande después. La solución
    es invertir el orden del @c{defuns-per-range-list}. Nosotros podemos
    hacer esto usando la función @c{nreverse}, que invierte el orden de una
    lista.  @findex nreverse

    Por ejemplo,

    @smallexample
      (nreverse '(1 2 3 4))
    @end smallexample

    produce:

    @smallexample
      (4 3 2 1)
    @end smallexample

    Note que la función @c{nreverse} es “destructiva” --- que es, cambiar la
    lista a la que se aplica; esto contrasta con las funciones @c{car} y
    @c{cdr}, que no son destructivas. En este caso, no se quiere que el
    original @c{defuns-per-range-list}, de manera que no hay materia que se
    destruya. (La función @c{reverse} provee un copia inversa de una lista,
    dejando la lista original como es.)  @findex reverse

    Pon todo junto, el @c{defuns-per-range} se parece a esto:

    @smallexample
      (defun defuns-per-range (sorted-lengths top-of-ranges)
        "funciones de SORTED-LENGTHS en cada rango TOP-OF-RANGES."
        (let ((top-of-range (car top-of-ranges))
              (number-within-range 0)
              defuns-per-range-list)

          ;; @r{Bucle Exterior.}
          (while top-of-ranges

            ;; @r{Bucle Interno.}
            (while (and
                    ;; @r{Necesita el número para el test numérico.}
                    (car sorted-lengths)
                    (< (car sorted-lengths) top-of-range))

              ;; @r{Contar número de definiciones con el rango actual.}
              (setq number-within-range (1+ number-within-range))
              (setq sorted-lengths (cdr sorted-lengths)))

            ;; @r{Sal del bucle interno pero permanece con el bucle externo.}

            (setq defuns-per-range-list
                  (cons number-within-range defuns-per-range-list))
            (setq number-within-range 0)      ; @r{Resetear el contaje a cero.}

            ;; @r{Mover al siguiente rango.}
            (setq top-of-ranges (cdr top-of-ranges))
            ;; @r{Especifica el siguiente mejor rango de valores.}
            (setq top-of-range (car top-of-ranges)))

          ;; @r{Salir del bucle externo y contar el número de defuns más
          ;; largas que}
          ;; @r{el valor más largo del valor top-of-range.}
          (setq defuns-per-range-list
                (cons
                 (length sorted-lengths)
                 defuns-per-range-list))

          ;; @r{Devuelve una lista del número de definiciones con cada rango,}
          ;; @r{ del más pequeño al más largo.}
          (nreverse defuns-per-range-list)))
    @end smallexample

    La función es simple excepto para una pequeña funcionalidad. El test
    verdadero-o-falso para el bucle interno se parece a esto:

    @smallexample
      (and (car sorted-lengths)
           (< (car sorted-lengths) top-of-range))
    @end smallexample

    en vez de algo como esto:

    @smallexample
      (< (car sorted-lengths) top-of-range)
    @end smallexample

    El propósito del test es determinar si el primer ítem en la lista
    @c{sorted-lengths} es menor que el valor de lo mejor del rango.

    La versión simple del test trabaja bien a menos que la lista
    @c{sorted-lengths} tiene un valor @c{nil}. En este caso, la expresión
    @c{(car sorted-lengths)} devuelve @c{nil}. La función @c{<} no se puede
    compara un número a @c{nil}, que es una lista vacía, así Emacs señala un
    error y para la función desde el intento de continuar la ejecución.

    La lista @c{sorted-lengths} siempre llega a ser @c{nil} cuando el
    contador logra el fin de la lista. Esto significa que cualquier intento
    de usar la función @c{defuns-per-range} con la versión simple del test
    fallará.

    Se resuelve el problema usando @c{(car sorted-lengths)} en conjunción con
    la expresión @c{and}. La expresión @c{(car sorted-lengths)} devuelve un
    valor no @c{nil} tan largo como la lista que tiene al menos un número con
    eso, pero devuelve @c{nil} si la lista está vacía. La expresión @c{and}
    primero evalúa el @c{(car sorted-lengths)}, y si eso es @c{nil}, devuelve
    falso @e{sin} evaluar la expresión @c{<} y devuelve este valor como el
    valor de la expresión @c{and}.

    Este camino, evita un error.  (Para información acerca de @c{and}, ver
    @l{La función @c{kill-new}}

    Aquí hay un pequeño test de la función @c{defuns-per-range}. Primero,
    evalúa la expresión que ajusta (una resumida) lista @c{top-of-ranges} a
    la lista de valores, entonces evalúa la expresión para ajustar la lista
    @c{sorted-lengths}, y entonces evalúa la función @c{defuns-per-range}.

    @smallexample
      ;; @r{(La lista ordenada que usará después.)}
      (setq top-of-ranges
       '(110 120 130 140 150
         160 170 180 190 200))

      (setq sorted-lengths
            '(85 86 110 116 122 129 154 176 179 200 265 300 300))

      (defuns-per-range sorted-lengths top-of-ranges)
    @end smallexample

    La lista devuelta se parece a esto:

    @smallexample
      (2 2 2 0 0 1 0 2 0 0 4)
    @end smallexample

    Dentro, hay dos elementos de la lista @c{sorted-lengths} menores de 110,
    dos elementos entre 110 y 119, dos elementos entre 120 y 129 y así. Hay
    cuatro elementos con un valor de 200 o superior.

* Leyendo un grafo

  Nuestro objetivo es construir un grafo mostrando los números de
  definiciones de función de varios tamaños en las fuentes de Emacs lisp.

  Como una materia práctica, si se estuviese creando un grafo, probablemente
  usarías un programa tal como @c{gnuplot} para hacer el
  trabajo. (@c{gnuplot} está bien integrado dentro de GNU Emacs.) En este
  caso, sin embargo, creamos uno desde cero, y en el proceso lo reconstruimos
  nosotros mismos con algo de lo que se aprende antes y así poder aprender
  más.

  En este capítulo, primero se escribe un grafo simple imprimiendo la
  función. Esta primera definición será un @:{prototipo}, una función escrita
  rápidamente nos permite reconocer este territorio de crear un grafo. Se
  descubren dragones, o resulta que son mitos. Después de olisquear el
  terreno, nos sentiremos más confidentes y mejoraremos la función para
  etiquetar las coordenadas automáticamente.

  Puesto que Emacs está diseñado para ser flexible y trabajar con todo tipo
  de terminales, incluyendo los terminales de caracteres, el grafo necesitará
  ser hecho desde símbolos de ‘escritura’. Un asterisco hará; como nosotros
  mejoramos la función de impresión del grafo, se puede crear la elección del
  símbolo como una opción de usuario.

  Se puede llamar a esta función @c{graph-body-print}; se tomará un
  @c{numbers-list} como su único argumento. En esta fase, no se etiquetará el
  grafo, pero se imprime su cuerpo.

  La función @c{graph-body-print} inserta una columna vertical de asteriscos
  para cada elemento en la lista @c{numbers-list}. La altura de cada línea
  está determinada por el valor de este elemento de la @c{numbers-list}.

  Insertar columnas es un acto repetitivo; que significa que esta función
  debe ser escrita con un bucle @c{while} o recursivamente.

  Nuestro primer reto es descubrir como imprimir una columna de
  asteriscos. Normalmente, en Emacs, se imprimen caracteres dentro de una
  pantalla horizontalmente, línea a línea, escribiendo. Se tienen dos rutas
  que se pueden seguir: escribir nuestra función column-insertion o descubrir
  si una que exista en Emacs.

  Para ver si hay uno en Emacs, se puede usar el comando @k{M-x
  apropos}. Este comando es como el comando @k{C-h a} (@c{command-apropos}),
  excepto que último encuentra solo estas funciones que son comandos. El
  comando @k{M-x apropos} lista todos los símbolos que se asocian a una
  expresión regular, incluyendo funciones que no son interactivas.  @findex
  apropos

  Lo que se quiere buscar es algún comando que imprima o inserte
  columnas. Muy probablemente, el nombre de la función contendrá la palabra
  ‘print’ o la palabra ‘insert’ o la palabra ‘column’. Por esta razón,
  podemos simplemente escribir @k{M-x apropos RET print \|insert\|column RET}
  y se ve el resultado. En mi sistema, este comando toma todavía algún
  tiempo, y entonces se produce una lista de 79 funciones y variables. Ahora
  no se tarda mucho y se produce una lista de 211 funciones y
  variables. Escaneando la lista, la única función que se ve como si se
  pudiera hacer el trabajo que es @c{insert-rectangle}.

  En realidad, esta es la función que queremos; su documentación dice:

  @smallexample
    insert-rectangle:
    Insertar texto de RECTANGLE con la esquina izquierda a punto
    La primera línea de RECTANGLE es insertada al punto
    su segunda línea es insertada a un punto verticalmente
    bajo el punto, etc.
    El RECTANGLE debería ser una lista de cadenas.
    Después de este comando, la marca está en la esquina izquierda
    superior y el punto en la esquina derecha inferior.
  @end smallexample

  Se puede ejecutar un test rápido, para asegurar que hace lo que se espera
  de eso.

  Aquí está el resultado de emplazar el cursor después de la expresión
  @c{insert-rectangle} y escribiendo @k{C-u C-x C-e} (@c{eval-last-sexp}). La
  función inserta las cadenas @'{"primero"}, @'{"segundo"}, y @'{"tercero"}
  en el punto. También la función devuelve @c{nil}.

  @smallexample
    (insert-rectangle '("primero" "segundo" "tercer"))primero
                                                  segundo
                                                  terceronil
  @end smallexample

  De acuerdo, no se inserta el texto de la expresión @c{insert-rectangle} en
  sí dentro del búffer en el que se marca el grafo, pero se llamará la
  función de nuestro programa. Nosotros, sin embargo, tenemos que asegurar
  que el punto está en el búffer en el lugar donde la función
  @c{insert-rectangle} insertará la columna de cadenas.

  Si se está leyendo esto en Info, se puede ver como este trabajo cambia a
  otro búffer, tal como el búffer @f{*scratch*}, emplazando el punto a algún
  lugar en el búffer, se escribe @k{M-:}, después se escribe la expresión
  @c{insert-rectangle} dentro del minibúffer en la consola, y entonces se
  escribe @k{RET}. Esto causa que Emacs evalúe la expresión en el minibúffer,
  pero usa como el valor del punto la posición del punto en el búffer
  @f{*scratch*}. (@k{M-:} es el atajo para @c{eval-expression}. @c{nil}
  tampoco aparece en el búffer @f{*scratch*} desde que la expresión se evalúa
  en el minibúffer.)

  Se encuentra cuando hacer esto hasta el punto que finaliza al fin de la
  última línea insertada––es decir, esta función mueve el punto como un
  efecto lateral. Si se iba a repetir el comando, con el punto en esta
  posición, la siguiente inserción sería debajo y a la derecha de la
  inserción previa. ¿Nosotros no queremos esto!. Si se está yendo a crear un
  gráfico de barras, las columnas necesitan estar debajo unas de otras.

  Así se descubre que cada ciclo del bucle @c{while} de column-inserting debe
  reposicionar el punto al lugar que queremos, y este lugar estará arriba, no
  abajo, de la columna. Más allá, se recuerda que cuando se imprime un grafo,
  no esperan todas las columnas para estar a la misma altura. Esto significa
  que el alto de cada columna puede estar a una altura diferente desde una
  previa. Nosotros simplemente reposicionamos el punto a la misma línea cada
  vez, pero movido cubriendo a la derecha––o quizás se puede …

  Estamos planeando crear las columnas de la barra gráfica sin asteriscos. El
  número de asteriscos en la columna es el número específico por el elemento
  actual del @c{numbers-list}. Necesitamos construir una lista de asteriscos
  del tamaño derecho para cada llamada a @c{insert-rectangle}. Si esta lista
  consiste únicamente del número requerido de asteriscos, entonces tendremos
  la posición de punto el número correcto de líneas bajo la base del gráfico
  para imprimirse correctamente. Esto podría ser difícil.

  Alternativamente, si podemos figurarnos algún camino para pasar
  @c{insert-rectangle} del mismo tamaño cada vez, entonces podemos posicionar
  el punto en la misma línea cada vez, pero se mueve a través de una columna
  a la derecha por cada nueva columna. Si hacemos esto, sin embargo, alguna
  de las entradas en la lista pasaba a @c{insert-rectangle} y deben ser
  espacios en blanco en vez de asteriscos. Por ejemplo, si la altura máxima
  del grafo es 5, pero la altura de la columna es 3, entonces
  @c{insert-rectangle} requiere un argumento que se parezca a esto:

  @smallexample
    (" " " " "*" "*" "*")
  @end smallexample

  Esta última propuesta no es tan difícil, de hecho se puede determinar la
  altura de la columna. Hay dos caminos para nosotros especificar la altura
  de la columna: se puede arbitrariamente situar lo que será, lo que
  funcionaría bien para gráficas de esta altura; o podemos buscar a través de
  la lista de números y usar la altura máxima de la lista como la altura
  máxima del grafo. Si la última operación fuera difícil, entonces el
  procedimiento formal sería fácil, pero hay una función construida en Emacs
  para determinar el máximo de sus argumentos. Se puede usar esta función. La
  función se llamaba @c{max} y eso devuelve el mayor de sus argumentos, que
  deben ser números. De este modo, por ejemplo,

  @smallexample
    (max  3 4 6 5 7 3)
  @end smallexample

  devuelve 7. (Una función correspondiente llamada @c{min} devuelve lo más
  pequeño de todos sus argumentos.)  @findex max @findex min

  Sin embargo, no podemos simplemente llama a @c{max} en el @c{numbers-list};
  la función @c{max} espera números como sus argumentos, no una lista de
  números. De este modo, la siguiente expresión,

  @smallexample
    (max  '(3 4 6 5 7 3))
  @end smallexample

  produce el siguiente mensaje error;

  @smallexample
    Mal tipo de argumento: number-or-marker-p, (3 4 6 5 7 3)
  @end smallexample

  Se necesita una función que pasa una lista de argumentos a una
  función. Esta función es @c{apply}. Esta función ‘aplica’ su primer
  argumento (una función) para los argumentos que permanecen, el último puede
  ser una lista.

  Por ejemplo,

  @smallexample
    (apply 'max 3 4 7 3 '(4 8 5))
  @end smallexample

  devuelve 8

  (Incidentalmente, yo no sabría cómo aprender acerca de esta función sin un
  libro tal como este. Eso es posible descubrir otras funciones, como
  @c{search-forward} o @c{insert-rectangle}, adivinando una parte de sus
  nombres y entonces usando @c{apropos}. Incluso aunque su base metafórica es
  clara --- ‘apply’ su primer argumento al resto––dudo que un novicio vendría
  con esta palabra particular usando @c{apropos} u otra ayuda. De acuerdo,
  podría ser incorrecto; después de todo, la función fué primero llamada por
  alguien quien lo había inventado.

  El segundo y subsiguientes argumentos para @c{apply} son opcionales, así se
  puede usar @c{apply} para llamar a una función y pasan los elementos de una
  lista, como este, que también devuelve 8:

  @smallexample
    (apply 'max '(4 8 5))
  @end smallexample

  Este camino tardío usará @c{apply}. La función
  @c{recursive-lengths-list-many-files} devuelve una lista de números que se
  puede aplicar a @c{max} (se podría también aplicar @e{(hacer apply)} a la
  lista de números ordenados; eso no importa si la lista está o no).

  Aquí, la operación para encontrar el tamaño máximo del grafo es este:

  @smallexample
    (setq max-graph-height (apply 'max numbers-list))
  @end smallexample

  Ahora se puede devolver la pregunta de como crear una lista de cadenas para
  una columna del grafo. Cuenta la máxima altura del grafo y el número de
  asteriscos que aparecerían en la columna, la función devolverá una lista de
  cadenas para el comando a insertar @c{insert-rectangle}.

  Cada columna se realiza con asteriscos o espacios en blanco. Puesto que la
  función pasa el valor del alto de la columna y el número de asteriscos en
  el columna, el número de espacios en blanco puede ser encontrado
  sustrayendo el número de asteriscos desde lo alto de la columna. Dado el
  número de espacios en blanco y el número de asteriscos, dos bucles
  @c{while} puede ser usado para construir la lista:

  @smallexample
    ;;; @r{Primera versión.}
    (defun column-of-graph (max-graph-height actual-height)
      "Devuelve la lista de cadenas que una columna de un grafo."
      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))

        ;; @r{Llenar asteriscos.}
        (while (> actual-height 0)
          (setq insert-list (cons "*" insert-list))
          (setq actual-height (1- actual-height)))

        ;; @r{Rellena espacios en blanco.}
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons " " insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))

        ;; @r{Devuelve la lista completa.}
        insert-list))
  @end smallexample

  Si se instala esta función y entonces evalúa la siguiente expresión se verá
  que devuelve la lista como se desea:

  @smallexample
    (column-of-graph 5 3)
  @end smallexample

  devuelve

  @smallexample
    (" " " " "*" "*" "*")
  @end smallexample

  Como está escrito, @c{column-of-graph} contiene una grieta mayor: los
  símbolos usados para el espacio en blanco para las entradas marcadas en la
  columna son ‘codificadas duras’ como un espacio y un asterisco. Esto está
  bien para un prototipo, pero tu, u otro usuario, puede desear usar otros
  símbolos. Por ejemplo, chequeando la función grafo, tu quieres usar un
  periodo en vez del espacio, asegura el punto que está siendo reposicionando
  apropiadamente cada vez que la función @c{insert-rectangle} se llama; o se
  podría querer sustituir un signo @'{+} u otro símbolo para el asterisco. Se
  podría incluso querer hacer un graph-column que es más que un ancho de
  columna. El programa debería ser más flexible. El camino para hacer esto es
  reemplazar el espacio en blanco y el asterisco con dos variables que se
  puede llamar @c{graph-blank} y @c{graph-symbol} y define estas variables
  separadamente.

  También la documentación no está escrita. Estas consideraciones nos llevan
  también a la segunda versión de la función:

  @smallexample
    (defvar graph-symbol "*"
      "Cadena usada como símbolo en grafo, normalmente un asterisco.")

    (defvar graph-blank " "
      "La cadena como un espacio en blanco en grafo, normalmente un
      espacio en blanco.
    graph-blank debe ser el mismo número de columnas amplio como graph-symbol.")
  @end smallexample

  (Para una explicación de @c{defvar}, ver @l{Inicializando una Variable con
  @c{defvar}}.)

  @smallexample
    ;;; @r{Segunda versión.}
    (defun column-of-graph (max-graph-height actual-height)
      "Devuelve cadenas MAX-GRAPH-HEIGHT; ACTUAL-HEIGHT son
      símbolos de grafos.

    Los graph-symbols son entradas contiguo al fin de la lista.
    La lista será insertado como una columna de un grafo.
    Las cadenas son tanto graph-blank o graph-symbol.

      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))

        ;; @r{Rellenar en @c{graph-symbols}.}
        (while (> actual-height 0)
          (setq insert-list (cons graph-symbol insert-list))
          (setq actual-height (1- actual-height)))

        ;; @r{Rellenar en @c{graph-blanks}.}
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons graph-blank insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))

        ;; @r{Devuelve la lista completa.}
        insert-list))
  @end smallexample

  Si se desea, podríamos reescribir @c{column-of-graph} una tercera vez para
  proporcionar opcionalmente un gráfico de líneas, como gráfico de
  barras. Esto no sería duro de hacer. Un camino para pensar en un grafo de
  líneas es que no es más que un grafo de barras en el que la parte de cada
  barra que está debajo del alto es blanco. Para construir una columna para
  gráfico de líneas, la función primero construyen una lista de espacios en
  blanco que es una más ordenada que el valor, entonces usa @c{cons} para
  adjuntar un símbolo gráfico a la lista; entonces eso usa @c{cons} de nuevo
  para adjuntar el ‘alto de espacios en blanco’ a la lista.

  Es fácil ver como escribir tal función, pero puesto que no se necesita eso,
  no se hará. Pero el trabajo podría ser hecho, y si eso se hiciera, se haría
  con @c{column-of-graph}. Incluso más importante, no se valora nada más que
  pocos cambios que tendrían que ser hechos de cualquier otra manera. La
  mejora, que se desea hacer, es simple.

  Ahora, finalmente, volvemos a nuestra primera función de grafo
  impresa. Esto imprime el cuerpo de un grafo, no las etiquetas para los ejes
  horizontal y vertical, así se puede llamar este @c{graph-body-print}.

** La función @c{graph-body-print}

   Después de nuestra preparación en la sección precedente, la función
   @c{graph-body-print} es simple. La función imprimirá la columna después de
   la columna de asteriscos y espacios en blanco, usando los elementos de la
   lista de números para especificar el número de asteriscos en cada
   columna. Esto es un acto repetitivo, que significa que se puede usar un
   bucle @c{while} que decrementa o una función recursiva para el trabajo. En
   esta sección, se escribirá la definición usando un bucle @c{while}.

   La función @c{column-of-graph} requiere el alto del grafo como un
   argumento, así se asigna y guarda esto como una variable local.

   Esto lidera a la siguiente plantilla para el bucle @c{while} versión de
   esta función:

   @smallexample
     (defun graph-body-print (numbers-list)
       "@var{documentation}…"
       (let ((height  …
              …))

         (while numbers-list
           @var{insert-columns-and-reposition-point}
           (setq numbers-list (cdr numbers-list)))))
   @end smallexample

   Necesitamos rellenar los slots de la plantilla.

   Claramente, se puede usar la expresión @c{(apply 'max numbers-list)} para
   determinar el alto del grafo.

   El bucle @c{while} iterará a través de @c{numbers-list} un elemento a la
   vez. Como eso está ordenado por la expresión @c{(setq numbers-list (cdr
   numbers-list))}, el @Cc{car} de cada instancia de la lista es el valor del
   argumento para @c{column-of-graph}.

   En cada ciclo del bucle @c{while}, la función @c{insert-rectangle} inserta
   la lista devuelta por @c{column-of-graph}. Desde que la función
   @c{insert-rectangle}, se necesita guardar la localización de punto al
   tiempo que el rectángulo se inserta, mueve atrás a esta posición después
   de que el rectángulo es insertado, y entonces se mueve horizontalmente al
   siguiente lugar desde el que @c{insert-rectangle} se llama.

   Si las columnas se insertan en un carácter amplio, será si los espacios en
   blanco y asteriscos se usan, el comando de reposición es simple
   @c{(forward-char 1)}; sin embargo, el ancho de una columna puede ser más
   grande que uno. Esto significa que el comando de reposicionamiento sería
   escrito @c{(forward-char symbol-width)}. El mejor lugar para asociar la
   variable @c{symbol-width} al valor del width de la columna grafo está en
   la varlist de la expresión @c{let}.

   Estas consideraciones lideran a la siguiente definición de función:

   @smallexample
     (defun graph-body-print (numbers-list)
       "Imprime un gráfico de barras de la NUMBERS-LIST.
     La numbers-list consiste en los valores del eje Y."

       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)

         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; @r{Dibuja la columna del grafo por columna.}
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; @r{Emplaza el punto para etiquetas de ejes X.}
         (forward-line height)
         (insert "\n")
     ))
   @end smallexample

   La expresión inesperada en esta función es la expresión @c{(sit-for 0)} en
   el bucle @c{while}. Esta expresión hace que el grafo imprima la operación
   más interesante para vigilar lo que sería de otro modo. La expresión causa
   que Emacs pare (sit-for 0) para un momento cero y entonces redibuje la
   pantalla. Puesto aquí, eso causa que Emacs redibuje la pantalla columna
   por columna. Sin eso, Emacs no redibujaría la pantalla hasta que la
   función exista.

   Se puede chequear @c{graph-body-print} con una pequeña lista de números.

   1. Instala @c{graph-symbol}, @c{graph-blank}, @c{column-of-graph}, que
      están en @l{Leyendo un grafo}, and @c{graph-body-print}.

   2. Copia la siguiente expresión:

      @smallexample
        (graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
      @end smallexample

   3. Cambia al búffer @f{*scratch*} y emplaza el cursor donde quiere que el
      grafo empiece.

   4. Escribe @k{M-:} (@c{eval-expression}).

   5. Pega la expresión @c{graph-body-print} dentro del minibúffer con
      @k{C-y} (@c{yank}).

   6. Presiona @k{RET} para evaluar la expresión @c{graph-body-print} @end
      enumerate


   Emacs imprimirá un grafo como este:

   @smallexample
             *
         *   **
         *  ****
        *** ****
       ********* *
      ************
     *************
   @end smallexample

** La función @c{recursive-graph-body-print}

   La función @c{graph-body-print} puede también ser escrito
   recursivamente. La solución recursiva es dividida dentro de dos partes:
   una fuera ‘wrapper’ @e{envoltorio} que usa una expresión @c{let} para
   determinar los valores varias variables que solo necesitan ser encontradas
   una vez, tal como la máxima altura del grafo, y una función dentro que es
   llamada recursivamente para imprimir el grafo.

   El ‘envoltorio’ no es complicado:

   @smallexample
     (defun recursive-graph-body-print (numbers-list)
       "Imprime un gráfico de barras del NUMBERS-LIST.
     El numbers-list consiste en los valores del eje Y."
       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)
         (recursive-graph-body-print-internal
          numbers-list
          height
          symbol-width)))
   @end smallexample

   La función recursiva es un poco más difícil. Eso tiene cuatro partes: el
   ‘do-again-test’, el código impreso, la llamada recursiva, y la
   ‘next-step-expression’. El ‘do-again-test’ es una expresión @c{when}
   determina si la @c{numbers-list} contiene cualquier elemento que
   permanece; si hace eso, la función imprime una columna del grafo usando el
   código impreso y se llama así mismo de nuevo. La función se llama así
   misma de nuevo de acuerdo al valor producido por la ‘next-step-expression’
   que causa para llamar a actuar en una versión ordenada de la
   @c{numbers-list}.

   @smallexample
     (defun recursive-graph-body-print-internal
       (numbers-list height symbol-width)
       "Imprime un gráfico de barras.
     Usado con la función recursive-graph-body-print."

       (when numbers-list
             (setq from-position (point))
             (insert-rectangle
              (column-of-graph height (car numbers-list)))
             (goto-char from-position)
             (forward-char symbol-width)
             (sit-for 0)     ; @r{Dibuja un gráfico columna por columna.}
             (recursive-graph-body-print-internal
              (cdr numbers-list) height symbol-width)))
   @end smallexample

   Después de la siguiente instalación, esta expresión puede ser chequeada;
   aquí hay un ejemplo:

   @smallexample
     (recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
   @end smallexample

   Aquí está lo que @c{recursive-graph-body-print} produce:

   @smallexample
         *
        **   *
       ****  *
       **** ***
     * *********
     ************
     *************
   @end smallexample

   Cada una de estas dos funciones, @c{graph-body-print} o
   @c{recursive-graph-body-print}, crea el cuerpo de un grafo.

** Necesidad para ejes impresos

   Un grafo necesita ejes impresos, así se puede orientar a tí mismo. Para un
   proyecto do-once, eso puede ser razonable dibujar los ejes a mano usando
   el modo de emacs Picture, pero un grafo dibuja la función que puede ser
   usada más de una vez.

   Por esta razón, se han escrito mejoras a la función básica
   @c{print-graph-body} que automáticamente imprime etiquetas para los ejes
   horizontal y vertical. Puesto que la etiqueta de imprimir funciones no
   contiene mucho material nuevo, se ha emplazado su descripción en un
   apéndice Véase Sección @l{Un Grafo con Ejes Etiquetados}.

** Ejercicio

   Escribe una versión de línea de grafo de la funciones de impresión del
   grafo.

* Tu fichero @f{.emacs}

  “No te tiene que gustar Emacs para lo que te gusta” --- esto que parece una
  frase paradójica es el secreto de GNU Emacs. En realidad, Emacs es una
  herramienta genérica. La mayoría de la gente que usa Emacs, lo personaliza
  para ajustarlo a sus necesidades.

  GNU Emacs está mayoritariamente escrito en Emacs Lisp; esto significa que
  escribiendo expresiones en Emacs Lisp se puede modificar o extender Emacs.

  Hay quien aprecia la configuración por defecto de Emacs. Después de todo,
  Emacs empieza en modo C cuando se edita un fichero C, empieza en modo
  Fortran cuando se edita un fichero Fortran, y empieza en modo Fundamental
  cuando se edita un fichero no adornado. Esto tiene sentido, si no sabes
  quien está yendo a usar Emacs. ¿Quién sabe lo que una persona espera hacer
  con un fichero no adornado? El modo fundamental es el modo correcto por
  defecto para tal fichero, tal como el modo C es lo correcto para editar
  código C. (Suficientes lenguajes de programación tienen sintaxis que
  permiten compartir funcionalidades, tal como el modo C es ahora
  proporcionado por el modo CC, la ‘Colección C’.)

  Pero cuando se conoce quien está yendo a usar Emacs––tu, tu mismo ---
  entonces eso tiene sentido para personalizar Emacs.

  Por ejemplo, yo raramente quiero el modo Fundamental cuando edito un
  fichero de otro modo no distinguido; yo quiero el modo Texto. Esto es por
  lo que yo personalizo Emacs: así eso se ajusta a mí.

  Se puede personalizar y extender Emacs escribiendo o adaptando un fichero
  @f{~/.emacs}. Esto es un fichero de inicialización personal; sus
  contenidos, escritos en Emacs Lisp, cuentan a Emacs qué hacer.@n{13}

  Un fichero @f{~/.emacs} contiene código Emacs Lisp. Se puede escribir este
  código por uno mismo; o se puede usar la funcionalidad @c{customize} para
  escribir el código para ti. Se puede combinar tus propias expresiones y
  expresiones auto-escritas personalizadas en tu fichero @f{.emacs}.

  (Yo prefiero por mí mismo escribir mis propias expresiones, excepto para
  estas, fuentes particularmente, que se encuentran fáciles de manipular
  usando el comando @c{customize}. Yo combino los dos métodos.)

  La mayoría de este capítulo es acerca de escribir expresiones por uno
  mismo. Eso describe un fichero @f{.emacs} simple; para más información,
  mira @"{El Fichero de Inicio} en @e(El Manual GNU Emacs), y la Seccion
  @"{El Fichero de Inicio} en @e(El Manual de Referencia GNU Emacs Lisp).

** Fichero de inicialización site-wide

   Además de tu fichero de inicialización personal, Emacs automáticamente
   carga varios ficheros de inicialización amplios, si existen. Tienen la
   misma forma que tu fichero @f{.emacs}, pero se cargan por cualquiera.

   Dos ficheros de incialización, @f{site-load.el} y @f{site-init.el}, están
   cargados dentro de Emacs y volcados @e{dumped} sin una versión dumped de
   Emacs se creó, como es más común. (Las copias dumped de Emacs cargan más
   rápidamente. Sin embargo, puesto que un fichero se carga y compila, un
   cambio no llega a ser un cambio en Emacs a menos que se cargue por uno
   mismo o se recompile Emacs. Véase Sección @"(Construyendo Emacs) en @e(El
   Manual de Referencia de GNU Emacs Lisp), y el fichero @f{INSTALL})

   Los otros tres ficheros de inicialización se cargan automáticamente cada
   vez que se inicia Emacs, si existen. Son @f{site-start.el}, que se carga
   @e{antes} que tu fichero @f{.emacs}, y @f{default.el}, y el tipo de
   fichero terminal, que se cargan @e{después} de tu fichero @f{.emacs}.

   Las configuraciones y definiciones en tu fichero @f{.emacs}
   sobreescribirán las configuraciones en conflicto y definiciones en un
   fichero @f{site-start.el}, si eso existe; pero las configuraciones y
   definiciones en un @f{default.el} o el tipo de fichero terminal
   sobreescribirá estos en tu fichero @f{.emacs}. (Se pueden prevenir
   interferencias desde un tipo de fichero terminal configurando
   @c{term-file-prefix} para @c{nil}. Véase Sección @l{Una extensión simple:
   @c{line-to-top-of-window}}.)

   El fichero @f{INSTALL} que viene en la distribución contiene descripciones
   de los fichero @f{site-init.el} y @f{site-load.el}.

   Los ficheros @f{loadup.el}, @f{startup.el}, y @f{loaddefs.el} controlan la
   carga. Estos ficheros están en el directorio @f{lisp} de la distribución
   Emacs y tiene valor de uso.

   El fichero @f{loaddefs.el} contiene buenas sugerencias como las que poner
   dentro de tu propio fichero @f{.emacs}, o dentro de un fichero de
   inicialización amplio.

** Especificar variables usando @c{defcustom}

   Se pueden especificar variables usando @c{defcustom} así que la gente
   pueda usar la funcionalidad de Emacs @c{customize} para asignar sus
   valores. (No se puede usar @c{customize} para escribir definiciones de
   función; pero se pueden escribir @c{defuns} en tu fichero @f{.emacs}. En
   vez de eso, se puede escribir cualquier expresión Lisp en tu fichero
   @f{.emacs}).

   La funcionalidad @c{customize} depende de la forma especial
   @c{defcustom}. Aunque se puede usar @c{defvar} o @c{setq} para las
   variables que los usuarios asignan, la forma especial @c{defcustom} está
   diseñada para el trabajo.

   Se puede usar tu conocimiento de @c{defvar} para escribir los primeros
   tres argumentos para @c{defcustom}. El primer argumento para @c{defcustom}
   es el nombre de la variable. El segundo argumento es el valor inicial de
   la variable, cualquiera; y este valor es asignado solo si el valor no ha
   sido ya asignado. El tercer argumento es la documentación.

   El cuarto y subsiguientes argumentos para @c{defcustom} especifican los
   tipos y opciones; estos no son funcionales en @c{defvar}. (Estos
   argumentos son opcionales.)

   Cada uno de estos argumentos consiste de una palabra seguido de una
   palabra por un valor. Cada palabra clave empieza con los dos puntos @'{:}.

   Por ejemplo, la variable de opciones personalizable @c{text-mode-hook} se
   parece a esto:

   @smallexample
     (defcustom text-mode-hook nil
       "El hook normal se ejecuta cuando se introduce en modo texto y
       muchos modos relacionados."
       :type 'hook
       :options '(turn-on-auto-fill flyspell-mode)
       :group 'data)
   @end smallexample

   El nombre de la variable es @c{text-mode-hook}; no tiene valor por
   defecto; y su cadena de documentación cuenta lo que hace.

   La palabra clave @c{:type} le cuenta a Emacs el tipo de datos para los que
   @c{text-mode-hook} sería asignado y como muestra el valor en un búffer de
   Personalización.

   La palabra clave @c{:options} especifica una lista sugerida de valores
   para la variable. Normalmente, @c{:options} se asocia a un gancho
   (@e{hook}. La lista es solo una sugerencia; esa no es exclusiva; una
   persona quien asigna la variable puede asignarse a otros valores; la lista
   mostrada siguiendo la palabra clave @c{:options} se pretende ofrecer
   elecciones convenientes a un usuario.

   Finalmente, la palabra clave @c{:group} cuenta el comando de
   Personalización de Emacs en el que el grupo de la variable está
   localizado. Esto cuenta dónde encontralo.

   La función @c{defcustom} reconoce más de una docena de palabras
   clave. Para más información, mire @"{Escribiendo las Definiciones de
   Personalización} en @e(El Manual de Referencia GNU Emacs Lisp).

   Considere @c{text-mode-hook} como un ejemplo.

   Hay dos caminos para personalizar esta variable. Se puede usar el comando
   de personalización o escribir las expresiones apropiadas por uno mismo.

   Usando el comando de personalización, se puede escribir:

   @smallexample
     M-x customize
   @end smallexample

   y encuentre que el grupo para editar ficheros de datos se llama
   ‘datos’. Introduzca este grupo. El Hook @e{Disparador} es el primer
   miembro. Se puede hacer click en sus opciones varias, tal como
   @c{turn-on-auto-fill}, para asignar los valores. Después de hacer click en
   el botón.

   @smallexample
     Guárdalo para Futuras Sesiones
   @end smallexample

   Emacs escribirá una expresión en tu fichero @f{.emacs}. Se parecerá a
   esto:

   @smallexample
     (custom-set-variables
       ;; custom-set-variables fué añadido por Custom.
       ;; Si se edita a mano, tu podrías liarte,
       ;; así que ten cuidado.
       ;; Tu fichero init contendría solo esta instancia.
       ;; Si hay más de uno, ellos no quieren trabajar.
      '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
   @end smallexample

   (La función @c{text-mode-hook-identify} cuenta
   @c{toggle-text-mode-auto-fill} que buffers hay en modo Texto.  Eso viene
   automáticamente)

   La función @c{custom-set-variables} funciona de alguna manera diferente
   más de un @c{setq}. Mientras yo nunca he aprendido las diferencias, yo
   modifico las expresiones @c{custom-set-variable} en mi fichero @f{.emacs}
   a mano: yo creo los cambios en los que aparecen a mi para ser una manera
   razonable y no tener problemas. Otros prefieren usar el comando de
   Personalización y permitir a Emacs hacer el trabajo para ellos.

   Otra función @c{custom-set-…} es @c{custom-set-faces}. Esta función asigna
   varios tipos de fuentes. A través del tiempo, yo he asignado un
   considerable número de tipos. Algo de tiempo, yo las reseteo usando
   @c{customize}; otras veces, simplemente edito la expresión
   @c{custom-set-faces} en mi fichero @f{.emacs} en sí.

   El segundo modo de personalizar tu @c{text-mode-hook} es asignarte a tí
   mismo en tu fichero @f{.emacs} usando código que no tiene nada que hacer
   con las funciones @c{custom-set-…}.

   Cuando se hace esto, y después usa @c{customize}, se verá un mensaje que
   dice:

   @smallexample
     CHANGED fuera de Personalizar; operando dentro aquí
     puede ser no confiable.
   @end smallexample

   Este mensaje es solo un aviso. Si se puede cliquear en el botón a

   @smallexample
     Guárdalo para Futuras Sesiones
   @end smallexample

   Emacs escribirá una expresión @c{custom-set-…} cerca del fin de tu fichero
   @f{.emacs} que será evaluado después de que tu expresión sea escrita a
   mano. Por esta razón, se sobreescribirá tu expresión escrita a
   mano. Ningún daño será hecho. Cuando se haga esto, sin embargo, ten
   cuidado para recordar que expresión está activa; si olvidas, puedes
   confundirte por tí mismo.

   Tan largo como se recuerda donde los valores son configurados, no habrá
   problemas. En cualquier eventos, los valores son siempre configurados en
   tu fichero de inicialización, que es normalmente llamado @f{.emacs}.

   Yo mismo hago un @c{customize} para cualquier cosa. Mayoritariamente,
   escribo expresiones por mí mismo.

   Incidentalmente, para ser una definición concerniente más completa:
   @c{defsubst} define una función inline. La sintaxis es solo como esta de
   @c{defun}. @c{defconst} define un símbolo como una constante. El intento
   es que ningún programa o usuario cambiarían un valor asignado por
   @c{defconst}. (Se puede cambiar; el valor asignado es una variable; pero
   por favor no lo haga.)

** Empieza por un fichero @f{.emacs}

   Cuando se abre Emacs, se carga tu fichero @f{.emacs} a menos que se cuente
   que no se especifique @'{-q} en la línea de comandos. (El comando @c{emacs
   -q} tu da un Emacs plano, fuera.)

   Un fichero @f{.emacs} contiene expresiones Lisp. Con frecuencia, no hay
   más expresiones para configura valores; algunas veces esas son
   definiciones de funciones.

   Véase Sección @l{El Fichero de Inicio @f{~/.emacs} en @e(El Manual GNU
   Emacs), para una corta descripción de fichero de inicialización.

   Este capítulo cubre algo del mismo suelo, pero es un paseo entre extractos
   desde un completo, largamente usado fichero @f{.emacs} --- por mí.

   La primera parte del fichero consiste en comentario: me recuerdo a mí
   mismo. Por ahora, yo recuerdo estas cosas, pero cuando empecé, no.

   @smallexample
     ;;;; fichero .emacs de Bob
     ; Robert J. Chassell
     ; 26 de Septiembre de 1985
   @end smallexample

   ¿Mira en esta fecha! Yo empecé este fichero hace mucho tiempo. Yo he
   estado añadiendo cosas desde siempre.

   @smallexample
     ; Cada sección en este fichero es introducido por una
     ; línea empezando con cuatro puntos y comas y cada
     ; entrada es introducida por una línea empezando con
     ; tres puntos y comas.
   @end smallexample

   Esto describe las convenciones usuales para comentarios en Emacs
   Lisp. Cada cosa en una línea que sigue un punto y coma es un
   comentario. Dos, tres, y cuatro puntos y coma son usados como subsección y
   marcas de sección. (Véase Sección @"{Comentarios} en @e(El Manual de
   Referencia GNU Emacs Lisp), para más comentarios.)

   @smallexample
     ;;;; La Tecla de Ayuda
     ; Control-h es la tecla de ayuda;
     ; después escribiendo control-h, escribe una letra a
     ; indica el asunto acerca del que quieres ayuda.
     ; Para una explicación de la facilidad de ayuda,
     ; escribe control-h dos veces en una fila.
   @end smallexample

   Solo recuerda: escribe @k{C-h} dos veces para ayudar.

   @smallexample
     ; Para informarse acerca de cualquier modo, escribe control-h m
     ; mientras esté en este modo. Por ejemplo, para encontrar
     ; acerca del modo correo, introduce el modo correo y entonces
     ; escribe control-h m.
   @end smallexample

   ‘Modo ayuda’, como yo llamo a esto, es muy útil. Usualmente, se cuenta
   todo lo que se necesita saber.

   De acuerdo, no se necesitan incluir comentarios y ficheros como estos
   @f{.emacs}. Yo los incluí en el mío porque se olvida el Modo ayuda o las
   convenciones para comentarios --- pero era capaz de recordar ver aquí
   recordármelo a mí mismo.

** Modo texto y auto relleno

   Ahora regresa a la parte que ‘vuelve’ al modo Texto y modo Auto Relleno.

   @smallexample
     ;;; Modo texto modo Auto Fill
     ;; Las siguiente dos líneas puestas en Emacs dentro de
     ;; modo Texto y en el modo Auto Fill, son para escritores que
     ;; quieren empezar a escribir prosa en vez de código.
     (setq-default major-mode 'text-mode)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   @end smallexample

   ¿Aquí está la primera parte de este fichero @f{.emacs} que hace alguna
   cosa bajo recuerdo de un humano olvidado!

   La primera de las dos líneas entre paréntesis cuentan a Emacs a cambiar al
   modo Texto que se encuentra un fichero, @e{a menos que} el fichero iría
   dentro de algún otro modo, tal como el modo C.

   Cuando Emacs lee un fichero, eso parece la extensión al nombre del
   fichero. (La extensión es la parte que viene después de un @'{.}.) Si el
   fichero finaliza con una extensión @'{.c} o @'{.h} entonces Emacs cambia
   al modo C. También, Emacs parece al principio una línea no blanca del
   fichero; si la línea dice @'{-*- C -*-}, Emacs cambia al modo C. Emacs
   posee una lista de extensiones y especificaciones que usa
   automáticamente. Además, Emacs se ve cerca de la última página por buffer,
   “lista variables locales”.

   Mira las secciones “Cómo los Modos Mayores son Elegidos” y “Variables
   Locales en Fichero” en @e{El Manual GNU Emacs}.

   Ahora, regresa al fichero @f{.emacs}.

   Aquí está la línea de nuevo; ¿cómo funciona?

   @smallexample
     (setq major-mode 'text-mode)
   @end smallexample

   Esta línea es un resumen, pero completa la expresión Emacs Lisp.

   Ya estamos familiarizados con @c{setq}. Eso asigna la siguiente variable,
   @c{major-mode}, al subsiguiente valor, que es @c{text-mode}. La marca de
   cita simple antes de @c{text-mode} cuenta a Emacs como tratar directamente
   con el símbolo, no con cualquier cosa que pudiera existir. Véase Sección
   @l{Configurando el Valor de una Variable}, por un recuerdo de como
   @c{setq} funciona. El principal punto es que no hay diferencia entre el
   procedimiento que se usa para asignar un valor en su fichero @f{.emacs} y
   el procedimiento que se usa en cualquier lugar más en Emacs.

   Aquí está la siguiente línea:

   @smallexample
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   @end smallexample

   En esta línea, el comando @c{add-hook} añade @c{turn-on-auto-fill} para la
   variable.

   ¿@c{turn-on-auto-fill} es el nombre de un programa, que se adivina!,
   cambia al modo Auto Fill.

   Cada vez que Emacs cambia al modo texto, Emacs ejecuta el comando ‘hooked’
   dentro de modo Texto. Así que cada vez que Emacs cambia al modo Texto,
   Emacs también cambia al modo de autoajuste.

   En breve, la primera línea causa a Emacs a entrar en modo Texto cuando se
   edite un fichero, a menos que la extensión del nombre del fichero, una
   línea no en blanco, variables locales para contar a Emacs de otro modo.

   El modo texto entre otras acciones, asigna la tabla de sintaxis para
   trabajar adecuadamente a escritores. En modo texto, Emacs considera un
   apóstrofe como parte de una palabra como una letra; pero Emacs no
   considera un período o un espacio como parte de una palabra. De este modo,
   @k{M-f} se mueve hacia tí a través de @'{eso}. Por otro lado, en modo C,
   @k{M-f} para solo después del @'{t} de @'{eso}.

   La segunda línea causa que Emacs active el modo Auto Fill cuando cambia al
   modo Texto. En modo Auto Fill, Emacs automáticamente rompe una línea que
   es demasiado amplio y trae la parte excesivamente amplia de la línea de
   debajo a la siguiente línea. Emacs rompe líneas entre palabras con ellas.

   Cuando el modo Auto Fill está desactivado, las líneas continúan a la
   derecha como se escriben. Dependiendo de como configuras el valor de
   @c{truncate-lines}, las palabras que se escribe si desaparecen al lado
   derecho de la pantalla, o lo demás son mostradas, en un modo feo e
   ilegible, como una línea de continuación en la pantalla.

   Además, en esta parte de mi fichero @f{.emacs}, yo cuento a Emacs el
   ajuste de comandos para insertar dos espacios después de dos puntos:

   @smallexample
     (setq colon-double-space t)
   @end smallexample

** Alias de correo

   Aquí hay un @c{setq} que ‘activa’ el alias de correo, para más ocasiones.

   @smallexample
     ;;; Modo Correo
     ; Para entrar en el modo correo, escribe ‘C-x m’
     ; Para introducir RMAIL (para leer el correo),
     ; escribe ‘M-x rmail’
     (setq mail-aliases t)
   @end smallexample

   Este comando @c{setq} asigna el valor de la variable @c{mail-aliases} al
   @c{t}. Desde que @c{t} significa cierto, la línea dice, en efecto, “Sí uso
   alias de correo.”

   Los alias de correo son nombres cortos convenientes para largas
   direcciones de correo o para listas de direcciones de correo. El fichero
   donde guardar tus ‘aliases’ es @f{~/.mailrc}. Se escribe un alias como
   este:

   @smallexample
     alias geo george@@foobar.wiz.edu
   @end smallexample

   Cuando se escribe un mensaje a Jorge, la dirección a @'{geo}; el correo
   automáticamente expandirá @'{geo} a la dirección completa.

** Indentar modo de tabulaciones

   Por defecto, Emacs inserta tabulaciones en lugar en múltiples espacios
   cuando se formatea una región. (Por ejemplo, se podrían indentar muchas
   líneas de texto todo a la vez con el comando @c{indent-region}.) Los
   tabuladores se ven bien en un terminal o con impresión ordinaria, pero
   ellos producen mala salida de indentación cuando se usa T@_(E)X o Texinfo
   puesto que T@_(E)X ignora tabuladores.

   Lo siguiente desactiva el modo de Indentar Tabulaciones:

   @smallexample
     ;;; Prevenir Tabulaciones Extrañas
     (setq-default indent-tabs-mode nil)
   @end smallexample

   Note que esta línea usa @c{setq-default} en vez de el comando @c{setq} que
   hemos visto antes. El comando @c{setq-default} asigna valores solo en
   búffers que no tienen sus propios valores locales para la variable.

   Ver secciones “Tabuladores versus Espacios” y “Variables Locales en
   Ficheros” en @e{El Manual de GNU Emacs}.

** Atajos de teclado

   Ahora para algunos atajos personales:

   @smallexample
     ;;; Compara ventanas
     (global-set-key "\C-cw" 'compare-windows)
   @end smallexample

   @c{compare-windows} es un comando excelente que compara el texto en tu
   ventana actual con texto de la siguiente ventana. Eso hace la comparación
   empezando al punto en cada ventana, moviendo a través del texto en cada
   ventana tan lejos como ellos asocian. Yo uso este comando todo el tiempo.

   Esto también muestra como configurar una tecla globalmente, para todo los
   modos

   El comando es @c{global-set-key}. Es seguido por el atajo. En un fichero
   @f{.emacs}, el atajo es escrito como se ve: @c{\C-c} que se asocia a
   ‘control-c’, que significa ‘presionar la tecla de control y la tecla @k{c}
   al mismo tiempo’. La @c{w} significa ‘presionar la tecla @k{w}’. El atajo
   es rodeado por dobles comillas. En la documentación, se escribiría esto
   como @k{C-c w}. (Si estuviera asociando una tecla @k{META}, tal como
   @k{M-c}, en vez de una tecla de @k{CTRL}, se escribiría @c{\M-c} en su
   fichero @f{.emacs}. Véase Sección @"{Reasociando Teclas en Su Fichero
   Init} en @e(El Manual de GNU Emacs), para más detalles.)

   El comando invocado por las teclas es @c{compare-windows}. Note que
   @c{compare-windows} es precedido por una comilla simple; de otro modo,
   Emacs primero intentaría evaluar el símbolo para determinar su valor.

   Estas tres cosas, las marcas de dobles comillas, la barra invertida antes
   de la @'{C}, y la marca de comilla simple son partes necesarias de atajos
   de teclado que tiendo a olvidar. Afortunadamente, he llegado a recordar
   que miraría mi fichero @f{.emacs} existente, y lo adaptaría a lo que hay.

   Como para el atajo en sí: @k{C-c w}, combina la tecla prefija, @k{C-c},
   con un caracter simple, en este caso, @k{w}. Este conjunto de teclas,
   @k{C-c} seguido por un caracter simple, es estrictamente reservado para un
   uso propio individual. (Esto se llama teclas ‘propias’, puesto que estas
   son para su propio uso). Siempre sería capaz de crear tal atajo para el
   uso propio sin pisar fuerte en algún atajo más. Si siempre se escribe una
   extensión a Emacs, por favor, evite tomar cualquiera de estas teclas para
   uso público. Se cree que una tecla como @k{C-c C-w} en vez de eso. De otra
   manera, ejecutará sin sus ‘propias’ teclas.

   Aquí hay otro atajo, con un comentario:

   @smallexample
     ;;; Atajo para ‘occur’
     ; Yo uso mucho occur, así permite asignarlo a una tecla:
     (global-set-key "\C-co" 'occur)
   @end smallexample

   El comando @c{occur} muestra todas las líneas en el buffer actual que
   contiene un emparejamiento para una expresión regular. Asociar las líneas
   que se muestran en un búffer llamado @f{*Occur*}. Este buffer sirve como
   un menu para saltar a ocurrencias.

   Aquí se muestra como desasignar una tecla, así no funciona:

   @smallexample
     ;;; Desasociar ‘C-x f’
     (global-unset-key "\C-xf")
   @end smallexample

   Hay una razón para esta no asociación: Yo encontré inadvertidamente
   escrito @k{C-x f} cuando significó escribir @k{C-x C-f}. En vez de
   encontrar un fichero, como se pretende, accidentalmente asigna el ancho
   para el fichero lleno, casi siempre a un tamaño que no quería. Puesto que
   duramente se reseteó mi ancho por defecto, yo simplemente disocié la
   tecla.

   Lo siguiente reasocia una tecla existente:

   @smallexample
     ;;; Reasocia ‘C-x C-b’ al ‘buffer-menu’
     (global-set-key "\C-x\C-b" 'buffer-menu)
   @end smallexample

   Por defecto, @k{C-x C-b} ejecute el comando @c{list-buffers}. Este comando
   lista sus buffers en @e{otra} ventana. Desde que casi siempre se quiere
   hacer alguna cosa en esta ventana, se prefiere el comando @c{buffer-menu},
   que no solo lista los buffers, pero mueve el punto dentro de esta ventana.

** Mapas de teclado

   Emacs usa @:{keymaps} para grabar qué teclas llaman a qué comandos. Cuando
   se use @c{global-set-key} para asignar los atajos de teclados a un simple
   comando en todo @c{current-global-map}.

   Modos específicos, tales como modo C o modo Texto, tiene sus propios mapas
   de teclado; mapas de teclado de modo específico sobreescribe el mapa
   global que es compartido por todos los buffers.

   La función @c{global-set-key} asocia, o reasocia, el mapa de teclado
   global. Por ejemplo, las siguientes asociaciones la tecla @k{C-x C-b} a la
   función @c{buffer-menu}:

   @smallexample
     (global-set-key "\C-x\C-b" 'buffer-menu)
   @end smallexample

   Mapas de teclado específico de modo son asociados usando la función
   @c{define-key}, que toma un mapa de teclado específico como un argumento,
   tan bien como la tecla y el comando. Por ejemplo, mi fichero @f{.emacs}
   contiene la siguiente expresión asociada al comando
   @c{texinfo-insert-@@group} comando a @k{C-c C-c g}:

   @smallexample
     (define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
   @end smallexample

   La función @c{texinfo-insert-@@group} en sí es una pequeña extensión del
   modo Texinfo que inserta @'{@@group} dentro de un fichero Texinfo. Se usa
   este comando todo el tiempo y se prefieren escribir los tres atajos @k{C-c
   C-c g} en vez de los seis atajos @k{@@ g r o u p}. (@'{@@group} y su
   asociación @'{@@end group} son comandos que guarda todo el texto cerrado
   junto a una página; muchos ejemplos multi-línea en este libro están
   rodeados por @'{@@group … @@end group}.)

   Aquí está la definición de función @c{texinfo-insert-@@group}:

   @smallexample
     (defun texinfo-insert-@@group ()
       "Inserta la cadena @@group en un búffer Texinfo."
       (interactive)
       (beginning-of-line)
       (insert "@@group\n"))
   @end smallexample

   (De acuerdo, podría haber usado el modo Abbrev para dejar de escribir, en
   vez de escribir una función para insertar una palabra; pero prefiero
   atajos de teclado consitentes con otro modo Texinfo para atajos de
   teclado.)

   Verá numerosas expresiones @c{define-key} en @f{loaddefs.el} tan bien como
   en varios modos de librerías, tal como @f{cc-mode.el} y @f{lisp-mode.el}.

   Véase Sección @"{Personalizando Atajos de Teclado} en @e(El Manual GNU
   Emacs), y @"{Mapas de Teclado} en @e(El Manual de Referencia GNU Emacs
   Lisp), para más información acerca de mapas de teclado.

** Cargando ficheros

   Muchas personas en la comunidad de GNU Emacs han escrito extensiones a
   Emacs. Hace tiempo, que estas extensiones son con frecuencia incluidas en
   las nuevas entregas @e{releases}. Por ejemplo, los paquetes Calendario y
   Diario son ahora parte del estándar GNU Emacs, como es Calc.

   Se puede usar un comando @c{load} para evaluar un fichero completo que
   significa instalar todas las funciones y variables en el fichero
   Emacs. Por ejemplo:

   @smallexample
     (load "~/emacs/slowsplit")
   @end smallexample

   Esto evalúa, por ej.@: carga, el fichero @f{slowsplit.el} o si eso existe,
   lo más rápido, el fichero compilado @f{slowsplit.elc} desde el
   subdirectorio @f{emacs} del directorio home. El fichero contiene la
   función @c{split-window-quietly}, que John Robinson escribió en 1989.

   La función @c{split-window-quietly} divide una ventana con el mínimo de
   redisplay. Yo lo instalé en 1989 porque trabajó bien con los terminales de
   1200 baudios que entonces estaba usando. Ahora, ocasionalmente vengo a
   través de una conexión lenta, pero continúa usando la función porque me
   gusta el camino que deja arriba del búffer en el bajo de las nuevas
   ventanas y arriba en la ventana superior.

   Para reemplazar el atajo de teclado por defecto
   @c{split-window-vertically}, se debe también desasignar esta tecla y
   asociar las teclas a @c{split-window-quietly}, como este:

   @smallexample
     (global-unset-key "\C-x2")
     (global-set-key "\C-x2" 'split-window-quietly)
   @end smallexample

   Si se cargan muchas extensiones, como yo hago, entonces en vez de
   especificar la posición exacta del fichero, como se muestra arriba, se
   puede especificar que directorio como parte del @c{load-path} de
   Emacs. Entonces, cuando Emacs carga un fichero, buscará que directorio tan
   bien como su lista por defecto de directorios. (La lista por defecto es
   especificada en @f{paths.h} cuando Emacs se construye.)

   El comando siguiente añade tu directorio @f{~/emacs} a la ruta existente:

   @smallexample
     ;;; Ruta Emacs
     (setq load-path (cons "~/emacs" load-path))
   @end smallexample

   Incidentalmente, @c{load-library} es un interfaz interactivo a la función
   @c{load}. La función se parece a esto:

   @smallexample
     (defun load-library (library)
       "Carga la librería llamada LIBRARY.
     Esto es una interfaz a la función ‘load’."
       (interactive
        (list (completing-read "Carga la librería: "
                               (apply-partially 'locate-file-completion-table
                                                load-path
                                                (get-load-suffixes)))))
       (load library))
   @end smallexample

   El nombre de la función, @c{load-libray}, viene desde el uso de ‘library’
   como un sinónimo para ‘file’. La fuente para el comando @c{load-library}
   está en la librería @f{files.el}.

   Otro comando interactivo que hace un trabajo ligeramente diferente es
   @c{load-file}. Véase Sección @"{Librerías de Código Lisp para Emacs} en
   @e(El Manual GNU Emacs), para información en la distinción entre
   @c{load-library} y este comando.

** Autoloading

   En vez de instalar una función cargando el fichero que lo contiene, o
   evaluando la definición de función, se puede hacer la función disponible
   pero actualmente no se instala hasta la primera vez llamada. Este proceso
   se llama @:{autocarga} (@e{autoloading}).

   Cuando se ejecuta una función de autocarga, Emacs automáticamente evalúa
   el fichero que contiene la definición, y entonces llama a la función.

   Emacs empieza rápido con funciones de autocarga, puesto que sus librerías
   no se cargan bien; pero si necesita esperar un momento cuando su primer
   uso tal como una función, mientras que el fichero que lo contiene se
   evalúa.

   Raramente las funciones usadas son frecuentemente autocargadas. La
   librería @f{loaddefs.el} coniene cientos de funciones autocargadas, desde
   @c{bookmark-set} a @c{wordstar-mode}. Si se usa una función ‘rara’
   frecuentemente, se debería cargar este fichero de función con una
   expresión de @c{load} en tu fichero @f{.emacs}.

   En mi fichero @f{.emacs}, se cargan 14 librerías que contienen funciones
   que de otro modo serían autocargadas. (Actualmente, eso habría sido mejor
   para incluir estos ficheros en mi Emacs ‘volcado’, pero se olvida. Véase
   Sección @"{Construyendo Emacs} en @e(El Manual de Referencia GNU Emacs
   Lisp), y el fichero @f{INSTALL} para más acerca de volcados.)

   Se puede también querer incluir expresiones autocargadas en tu fichero
   @f{.emacs}. @c{autoload} es una función construida que toma cinco
   argumento, los tres finales de los que son opcionales. El primer argumento
   es el nombre de la función para ser autocargada. El segundo es el nombre
   del fichero para ser cargado. El tercer argumento es documentación para la
   función, y el cuarto cuenta si la función puede ser llamada
   interactivmente. El quinto argumento cuenta que tipo de
   objeto––@c{autoload} puede manejar un mapa de teclado o macro tan bien
   como una función (por defecto es una función).

   Aquí hay un ejemplo típico:

   @smallexample
     (autoload 'html-helper-mode
       "html-helper-mode" "Editar documentos HTML" t)
   @end smallexample

   (@c{html-helper-mode} es una vieja alternativa a @c{html-mode}, que es una
   parte estándar de la distribución.)

   Esta expresión autocarga la función @c{html-helper-mode}. Esto se toma
   desde el fichero @f{html-helper-mode-el} (o desde la versión compilada
   @f{html-helper-mode.elc}, si eso existe). El fichero debe ser localizado
   en un directorio específico por @c{load-path}. La documentación dice que
   esto es un modo para ayudar a editar documentos escritos en Lenguaje de
   Marcas de Hiper Texto. Se puede llamar este modo interactivamente
   escribiendo @k{M-x html-helper-mode}. (Se necesitan duplicar las funciones
   regulares de documentación en la expresión de autocarga porque la función
   regular no está todavía cargada, así su documentación no está disponible.)

   Véase Sección @"{Autocarga} en @e(El Manual de Referencia de GNU Emacs
   Lisp), para más información.

** Una extensión simple: @c{line-to-top-of-window}

   Aquí hay una simple extensión a Emacs que mueve el punto de línea arriba
   de la ventana. Yo uso esto todo el tiempo, para hacer fácil de leer el
   texto.

   Se puede poner el siguiente código dentro de un fichero separado y entonce
   cargarlo desde tu fichero @f{.emacs}, o se puede incluir con tu fichero
   @f{.emacs}.

   Aquí está la definición

   @smallexample
     ;;; Línea a lo alto de la ventana;
     ;;; reemplaza tres secuencias de atajos de teclado  C-u 0 C-l
     (defun line-to-top-of-window ()
       "Mueve la línea que apunta a lo alto de la ventana."
       (interactive)
       (recenter 0))
   @end smallexample

   Ahora el atajo.

   En estos días, las teclas de función así como los eventos del ratón y
   caracteres no @Cc{ascii} son escritos con corchetes, sin marcas de
   citas. (En Emacs versión 18 y anteriores, se tenía que escribir diferentes
   teclas de función asignadas por cada diferente creación del terminal.)

   Se puede asociar @c{line-to-top-of-window} a la tecla de función @k{F6}
   así:

   @smallexample
     (global-set-key [f6] 'line-to-top-of-window)
   @end smallexample

   Para más información, mira @"{Reasociando Teclas en tu fichero init} en
   @e{El Manual GNU Emacs}.

   Si ejecutas dos versiones de GNU Emacs, tal como las versiones 22 y 23, y
   usas un fichero @f{.emacs}, se puede seleccionar qué código evalúa el
   siguiente condicional:

   @smallexample
     (cond
      ((= 22 emacs-major-version)
       ;; evalúa la version 22
       ( … ))
      ((= 23 emacs-major-version)
       ;; evalúa la version 23
       ( … )))
   @end smallexample

   Por ejemplo, en versiones más recientes se ocultan los cursores por
   defecto. Si se odia tal ocultación se escribe lo siguiente en mi fichero
   @f{.emacs}@n{14}:

   @smallexample
     (when (>= emacs-major-version 21)
       (blink-cursor-mode 0)
       ;; Inserta la nueva línea cuando se presiona ‘C-n’ (next-line)
       ;; al fin del búffer
       (setq next-line-add-newlines t)
       ;; Cambia la imagen viendo
       (auto-image-file-mode t)
       ;; Activa la barra de menu (esta barra tiene texto)
       ;; (Usa un argumento numérico para activarlo)
       (menu-bar-mode 1)
        ;; Desactiva la barra de herramientas (esta barra tiene iconos)
        ;; (Usa argumentos numéricos para activarlo)
        (tool-bar-mode nil)
       ;; Desactiva el modo tooltip para la tool bar
       ;; (Este modo causa explicaciones de iconos al pop up)
       ;; (Usa el argumento numérico para activarlo)
       (tooltip-mode nil)
       ;; Si los tooltips activados, crea consejos aparecen en el prompt
       (setq tooltip-delay 0.1)  ; por defecto es de 0.7 segundos
        )
   @end smallexample

** Colores X11

   Se pueden especificar colores cuando se usa Emacs con el Sistema de
   Ventanas X del MIT.

   Si disgustan los colores por defecto y especifica unos propios.

   Aquí están las expresiones en un fichero @f{.emacs} que establecen los
   valores:

   @smallexample
     ;; Asigna el color del cursor
     (set-cursor-color "white")

     ;; Asigna el color del ratón
     (set-mouse-color "white")

     ;; Asigna foreground y background
     (set-foreground-color "white")
     (set-background-color "darkblue")

     ;;; Asigna colores para isearch y drag
     (set-face-foreground 'highlight "white")
     (set-face-background 'highlight "blue")

     (set-face-foreground 'region "cyan")
     (set-face-background 'region "blue")

     (set-face-foreground 'secondary-selection "skyblue")
     (set-face-background 'secondary-selection "darkblue")

     ;; Asigna colores al calendario
     (setq calendar-load-hook
           '(lambda ()
              (set-face-foreground 'diary-face   "skyblue")
              (set-face-background 'holiday-face "slate blue")
              (set-face-foreground 'holiday-face "white")))
   @end smallexample

   Las varias sombras de azul disparan mi ojo y me preveen de ver la ventana
   desplegada.

   Alternativamente, se podrían haber configurado mis especificaciones en
   varios ficheros inicialización de X. Por ejemplo, se podría asignar el
   foreground, background, cursor y puntero (por ej., ratón) colores en mi
   fichero @f{~/.Xresources} como esto:

   @smallexample
     Emacs*foreground:   white
     Emacs*background:   darkblue
     Emacs*cursorColor:  white
     Emacs*pointerColor: white
   @end smallexample

   En cualquier evento que no es parte de Emacs, se asigna el color raíz de
   mi ventana X en mi fichero @f{~/.xinitrc}, como este@n{15}

   @smallexample
     xsetroot -solid Navy -fg white &
   @end smallexample

** Configuraciones misceláneas para un fichero @f{.emacs}

   Aquí hay unas pocas configuraciones misceláneas:


   - Asigna la forma y color del ratón del cursor:

     @smallexample
       ; Formas de Cursor están definidas en
       ; ‘/usr/include/X11/cursorfont.h’;
       ; por ejemplo, el cursor ‘objetivo’ es número 128;
       ; el cursor ‘top_left_arrow’ es el número 132.

       (let ((mpointer (x-get-resource "*mpointer"
                                       "*emacs*mpointer")))
         ;; Si no se ha asignado tu puntero de ratón
         ;; entonces asignalo, de otro modo, déjalo así:
         (if (eq mpointer nil)
             (setq mpointer "132")) ; top_left_arrow
         (setq x-pointer-shape (string-to-int mpointer))
         (set-mouse-color "white"))
     @end smallexample

   - O se pueden asignar los valores de una variedad de funcionalidades en
     una alist, como esta:

     @smallexample
       (setq-default
        default-frame-alist
        '((cursor-color . "white")
          (mouse-color . "white")
          (foreground-color . "white")
          (background-color . "DodgerBlue4")
          ;; (cursor-type . bar)
          (cursor-type . box)
          (tool-bar-lines . 0)
          (menu-bar-lines . 1)
          (width . 80)
          (height . 58)
          (font .
                "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
          ))
     @end smallexample

   - Convierte @k{@k{CTRL}-h} dentro @k{DEL} y @k{DEL} dentro de
     @k{@k{CTRL}-h}.@* (Algunos viejos teclados lo necesitan, aunque yo no he
     visto el problema recientemente.)

     @smallexample
       ;; Traducir ‘C-h’ a <DEL>.
       ; (keyboard-translate ?\C-h ?\C-?)

       ;; Traducir <DEL> a ‘C-h’.
       (keyboard-translate ?\C-? ?\C-h)
     @end smallexample

     @item ¿Desactiva un cursor oculto!

     @smallexample
       (if (fboundp 'blink-cursor-mode)
           (blink-cursor-mode -1))
     @end smallexample

     o empieza GNU Emacs con el comando @c{emacs -nbc}.

   - Cuando se usa ‘grep’

     - @'{-i} -: Ignore distinciones de letras@*

     - @'{-n} -: El prefijo de cada línea de la salida con el número de
       líneas@*

     - @'{-H} -: Imprime el nombre de fichero para cada cadena encontrada.@*

     - @'{-e} -: Protege patrones empezando con un caracter de guión, @'{-}

       @smallexample
         (setq grep-command "grep -i -nH -e ")
       @end smallexample

     @ignore
     @c Evidently, no longer needed in GNU Emacs 22

     item Automatically uncompress compressed files when visiting them

     smallexample
     (load "uncompress")
     end smallexample

     @end ignore

   - Encuentra un búffer existente, incluso si eso tiene un nombre diferente
     Esto evita problemas con enlaces simbólicos.

     @smallexample
       (setq find-file-existing-other-name t)
     @end smallexample

   - Configura tu entorno de lenguaje y el método de entrada por defecto

     @smallexample
       (set-language-environment "latin-1")
       ;; Recuerda que se puede habilitar o deshabilitar el texto de lenguaje
       ;; multilingüe con el comando @c{toggle-input-method'} (@k{C-\})
       (setq default-input-method "latin-1-prefix")
     @end smallexample

     Si se quiere escribir con el caracter Chino ‘GB’, asigna esto:

     @smallexample
       (set-language-environment "Chinese-GB")
       (setq default-input-method "chinese-tonepy")
     @end smallexample



*** Arreglando Atajos de Teclados

    Algunos sistemas asocian teclas de maneras no agradables. Algunas veces,
    por ejemplo, la tecla @k{CTRL} en un modo perverso en vez de la lejanía a
    la izquierda de la fila.

    Normalmente, cuando las personas arreglan estos atajos de teclado, no se
    cambia su fichero @f{~/.emacs}. En vez de eso, se asocian las teclas
    apropiadas en sus consolas con los comandos @c{loadkeys} o
    @c{install-keymap} en su script de inicio y entonces incluyen comandos
    @c{xmodmap} en su fichero @f{.xinitrc} o @f{.Xsession} para X Windows.

    Para un script de inicio:

    @smallexample
      loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

      or

      install-keymap emacs2
    @end smallexample

    Para un fichero @f{.xinitrc} o un fichero @f{.Xsession} cuando la tecla
    @k{Caps Lock} es que tan lejos de la fila del home:

    @smallexample
      # Asocia la tecla etiquetada ‘Caps Lock’ a ‘Control’
      # (Tal como un interfaz de usuario roto sugiere que el teclado hecho
      # piensa que los ordenadores son máquinas de escribir desde 1885.)

      xmodmap -e "clear Lock"
      xmodmap -e "add Control = Caps_Lock"
    @end smallexample

    En un @f{.xinitrc} o @f{.Xsession}, para convertir una tecla @k{ALT} a
    una tecla @k{META}:

    @smallexample
      # Algunos teclados mal diseñados tienen una tecla etiquetada ALT y no Meta
      xmodmap -e "keysym Alt_L = Meta_L Alt_L"
    @end smallexample

** Una línea modificada

   Finalmente, una funcionalidad que realmente me gusta: un mode line
   modificado.

   Cuando se trabaja a través de una red, se olvida que máquina se está
   usando. También, se tiende a perder la traza de donde se está, y a qué
   línea se apunta.

   Así se resetea mi mode line para que se parezca a esto:

   @smallexample
     -:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
   @end smallexample

   Estoy visitando un fichero llamado @f{foo.texi}, en mi máquina
   @f{rattlesnake} en mi búffer @f{/home/bob}. Yo estoy en la línea 1, en
   modo Texinfo, y estoy arriba del búffer.

   Mi fichero @f{.emacs} tiene una sección que se parece a esto:

   @smallexample
     ;; Asigna un Mode Line que nos cuente que máquina, que directorio,
     ;; y que línea estoy on, más la información de client.
     (setq-default mode-line-format
      (quote
       (#("-" 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        "    "
        mode-line-buffer-identification
        "    "
        (:eval (substring
                (system-name) 0 (string-match "\\..+" (system-name))))
        ":"
        default-directory
        #(" " 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (line-number-mode " Line %l ")
        global-mode-string
        #("   %[(" 0 6
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (:eval (mode-line-mode-name))
        mode-line-process
        minor-mode-alist
        #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
        ")%] "
        (-3 . "%P")
        ;;   "-%-"
        )))
   @end smallexample

   Aquí, se redefine el mode line por defecto. La mayoría de las partes son
   desde el original; pero yo creo unos pocos cambios. Yo asigno el formato
   de mode line @e{default} así como permitir varios modos, tales como Info,
   para sobreescribirlo.

   Muchos elementos en la lista son auto-explicativos: @c{mode-line-modified}
   es una variable que cuenta si el búffer ha sido modificado, @c{mode-name}
   cuenta el nombre del modo, y así. Sin embargo, el formato parece
   complicado porque las dos funcionalidades no han sido discutidas.

   La nueva cadena de formato tiene una sintaxis especial:

   @smallexample
     #("-" 0 1 (help-echo "mouse-1: select window, ..."))
   @end smallexample

   El @c{#(} empieza una lista. El primer elemento de la lista es la cadena
   en sí, solo un @'{-}. El segundo y tercer elemento especifica el rango a
   través del cuarto elemento aplicado. Un rango empieza @e{después} un
   carácter, así un cero significa el rango que empieza solo después del
   primer caracter; un 1 significa que el rango finaliza solo después del
   primer caracter. El tercer elemento es la propiedad para el rango. Eso
   consiste en una lista de propiedades, un nombre de propiedad, en este
   caso, @'{help-echo}, seguido por un valor, en este caso, una cadena. El
   segundo, tercer y cuarto elemento de este nuevo formato de cadena puede
   ser repetido.

   Véase Sección @"{Propiedades de Texto} en @e{El Manual de Referencia de
   GNU Emacs Lisp}, y ver @"{Formato Mode Line} en @e{El Manual de Referencia
   de GNU Emacs Lisp}, para más información.

   @c{mode-line-buffer-identification} muestra el nombre del buffer. Eso es
   una lista empezando por @c{(#("%12b" 0 4 …}. El @c{#(} empieza la lista.

   El @'{"%12b"} muestra el nombre del actual búffer, usando la función
   @c{buffer-name} con la que estamos familiarizados; el ‘12’ especifica el
   número máximo de caracteres que serán mostrados. Cuando un nombre tiene
   pocos caracteres, el espacio en blanco se añade para rellenar este
   número. (Los nombres del búffer puede y con frecuencia serán más largos de
   12 caracteres; esta longitud funciona bien en la típica ventana de 80
   columnas de ancho.)

   @c{:eval} dice evaluar la siguiente forma y usa el resultado como una
   cadena para mostrarse. En este caso, la expresión muestra el primer
   componente del sistema completo. El fin del primer componente es un @'{.}
   (‘periodo’), así se usa la función @c{string-match} para contar el tamaño
   del primer componente. La subcadena desde el caracter cero a este tamaño
   del primer componente. La subcadena desde el caracter cero a este tamaño
   es el nombre de la máquina.

   Esta es la expresión:

   @smallexample
     (:eval (substring
             (system-name) 0 (string-match "\\..+" (system-name))))
   @end smallexample

   @'{%[} y @'{%]} causa un par de corchetes que aparezcan por cada edición
   nivel de edición recursiva editando el nivel. @'{%n} dice ‘Encoger’ cuando
   esto puede hacerse. @'{%P} te cuenta el porcentaje del búffer que está
   debajo de la ventana, o ‘arriba’, ‘abajo’, o ‘todo’. (Una minúscula @'{p}
   cuenta el porcentaje bajo el alto de la ventana.) @'{%-} inserta
   suficientes guiones para rellenar la línea.

   Recuerda, “No tiene que gustarte Emacs para que le gustes” --- Emacs puede
   tener diferentes colores, diferentes comandos, y diferentes teclas que un
   Emacs por defecto.

   Por otro lado, si se quiere traer un plano ‘fuera de la caja’ Emacs, sin
   personalización, escribe:

   @smallexample
     emacs -q
   @end smallexample

   Esto inicializará un Emacs que @e{no} cargue tu @f{~/.emacs} fichero de
   inicialización. Uno plano, el que trae Emacs por defecto. Nada más.

* Depurando

  GNU Emacs tiene dos depuradores, @c{debug} y @c{edebug}. El primero es
  construido dentro de las tripas de Emacs y está siempre contigo; el segundo
  requiere que exista una función antes de que se pueda usar.

  Ambos depuradores son descritos extensivamente en Seccion @"{Depurando} en
  @e{El Manual de Referencia GNU Emacs Lisp}. En este capítulo, se explicará
  un breve ejemplo de esto.

** @c{depurar}

   Supón que se ha escrito una definición de función que se pretende devolver
   la suma de los números 1 a través de un número dado. (Esta es la función
   @c{triangle} discutida pronto. Véase Sección @l{Ejemplo de Decremento, ,
   Ejemplo con Contador de Decremento}, para una discusión.)

   Sin embargo, tu definición de función tiene un error. Se ha malescrito
   @'{1=} por @'{1-}. Aquí está la definición rota:

   @smallexample
     (defun triangle-bugged (number)
       "Devuelve suma de números 1 a través de NUMBER inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (setq number (1= number)))      ; @r{Error aquí.}
         total))
   @end smallexample

   Si se está leyendo esto en Info, se puede evaluar esta definición en el
   modo normal. Se verá que @c{triangle-bugged} aparece en el área echo.

   Ahora evalúa la función @c{triangle-bugged} con un argumento de 4:

   @smallexample
     (triangle-bugged 4)
   @end smallexample

   En un GNU Emacs reciente, se creará e introducirá un búffer
   @f{*Backtrace*} que dice:

   @smallexample
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
       (1= number)
       (setq number (1= number))
       (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
       (let ((total 0)) (while (> number 0) (setq total ...)
         (setq number ...)) total)
       triangle-bugged(4)
       eval((triangle-bugged 4))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end smallexample

   (Se ha reformateado este ejemplo ligeramente; el depurador no contiene
   muchas líneas. Así, se puede salir del depurador escribiendo @k{q} en el
   buffer @f{*Backtrace*}.)

   En la práctica, debido a un error tan simple como este, la línea de ‘error
   Lisp’ explica lo que se necesita saber para corregir la definición. La
   función @c{1=} está ‘vacía’.

   @ignore
     In GNU Emacs 20 and before, you will see:

     @smallexample
       La definición de la función está vacío:@: 1=
     @end smallexample

     which has the same meaning as the @f{*Backtrace*} buffer line in
     version 21.
   @end ignore

   Sin embargo, si no se conoce con bastante certeza lo que está pasando, se
   puede leer la traza completa.

   En este caso, se necesita ejecutar una versión reciente de GNU Emacs, que
   automáticamente empieza el depurador que pone en el búffer
   @f{*Backtrace*}; o además, se necesita para empezar el depurador
   manualmente como se describe debajo.

   Lee el búffer @f{*Backtrace*} de abajo a arriba; eso cuenta lo que le hizo
   a Emacs tener un error. Emacs hace una llamada interactiva a @k{C-x C-e}
   (@c{eval-last-sexp}), que lleva a la evaluación de la expresión
   @c{triangle-bugged}. Cada línea de debajo cuenta lo que el intérprete Lisp
   evaluó.

   La tercera línea desde lo alto del búffer es

   @smallexample
     (setq number (1= number))
   @end smallexample

   Emacs intentó evaluar esta expresión; para hacerlo así, se intentó evaluar
   la expresión interna para ser mostrada en la segunda línea desde arriba:

   @smallexample
     (1= number)
   @end smallexample

   Aquí es donde el error ocurre; como se dice en la línea de arriba:

   @smallexample
     Debugger entered--Lisp error: (void-function 1=)
   @end smallexample

   Se puede corregir el error, reevalúa la definición de función, y entonces
   se puede testear de nuevo.

** @c{debug-on-entry}

   Un GNU Emacs actual abre el depurador automáticamente cuando la función
   tiene un error.

   @ignore
     GNU Emacs version 20 and before did not; it simply
     presented you with an error message.  You had to start the debugger
     manually.
   @end ignore

   Incidentalmente, se puede empezar el depurador manualmente para todas las
   versiones de Emacs; la ventaja es que el depurador se ejecuta incluso si
   no se tiene un error en su código. Algunas veces, ¿su código estará libre
   de errores!

   Se puede introducir el depurador cuando se llama a la función llamando
   @c{debug-on-entry}.

   Tipo:

   @smallexample
     M-x debug-on-entry RET triangle-bugged RET
   @end smallexample

   Ahora, evalúa lo siguiente:

   @smallexample
     (triangle-bugged 5)
   @end smallexample

   Todas las versiones de Emacs crearán un búffer @f{*Backtrace*} y cuenta tu
   que eso es el principio para evaluar la función @c{triangle-bugged}:

   @smallexample
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--entering a function:
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end smallexample

   En el búffer @f{*Backtrace*}, escribe @k{d}. Emacs evaluará la primera
   expresión en @c{triangle-bugged}; el búffer se parece a esto:

   @smallexample
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end smallexample

   Ahora, escribe @k{d} de nuevo, ocho veces, lentamente. Cada vez que se
   escribe @k{d} Emacs evaluará otra expresión en la definición de función.

   Eventualmente, el búffer se parece a esto:

   @smallexample
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (setq number (1= number))
     * (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end smallexample

   Finalmente, después se escribe @k{d} dos veces más, Emacs logrará el error
   y las dos líneas superiores del buffer @f{*Backtrace*} se ve así:

   @smallexample
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
     * (1= number)
     …
     ---------- Buffer: *Backtrace* ----------
   @end smallexample

   Escribiendo @k{d}, sería capaz de pasear a través de la función.

   Se puede salir de un buffer @f{*Backtrace*} escribiendo @k{q}; esto se
   sale de la traza, pero no cancela @c{debug-on-entry}.

   Para cancelar el efecto de @c{debug-on-entry}, llama a
   @c{cancel-debug-on-entry} y el nombre de la función, como esto:

   @smallexample
     M-x cancel-debug-on-entry RET triangle-bugged RET
   @end smallexample

   (Si está leyendo esto en Info, cancela @c{debug-on-entry} ahora.)

** @c{debug-on-quit} y @c{(debug)}

   Adición a la configuración @c{debug-on-error} o llamando
   @c{debug-on-entry}, hay otros dos caminos para empezar @c{debug}.

   Se puede empezar @c{debug} siempre y cuando se escribe @k{C-g}
   (@c{keyboard-quit}) se configura la variable @c{debug-on-quit} para
   @c{t}. Esto es útil para depurar bucles infinitos.

   O, se puede insertar un línea que dice @c{(debug)} dentro de tu código
   donde se quiere que el depurador empiece, así:

   @smallexample
     (defun triangle-bugged (number)
       "Devuelve suma de números 1 a través de NUMERO inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (debug)                         ; @r{Empieza el depurador.}
           (setq number (1= number)))      ; @r{Error aquí.}
         total))
   @end smallexample

   La función @c{debug} se describe en detalle en @"{El Depurador Lisp} en
   @e{El Manual de Referencia GNU Emacs Lisp}.

** El depurador de nivel de fuentes @c{edebug}

   Edebug es un depurador a nivel de fuentes Edebug que normalmente muestra
   las fuentes del código que se está depurando, con una flecha a la
   izquierda que muestra que línea se está actualmente ejecutando.

   Se puede pasear a través de la ejecución de una función, línea a línea, o
   ejecutarse rápidamente hasta lograr un @:{punto de ruptura} donde la
   ejecución pare.

   Edebug se describe en Seccion @"{edebug} en @e{El Manual de Referencia de
   GNU Emacs Lisp}.

   Aquí hay una función con errores para @c{triangle-recursively}. Véase
   Sección @l{Recursión en lugar de un contador}, para una revisión de eso.

   @smallexample
     (defun triangle-recursively-bugged (number)
       "Devuelve la suma of números 1 a través de NUMBER inclusive.
     Usa recursión."
       (if (= number 1)
           1
         (+ number
            (triangle-recursively-bugged
             (1= number)))))               ; @r{Error aquí.}
   @end smallexample

   Normalmente, se instalaría esta definición posicionando su cursor después
   de la función cerrando paréntesis y escribiendo @k{C-x C-e}
   (@c{eval-last-sexp}) o lo demás posicionando tu cursor con la definición y
   escribiendo @k{C-M-x} (@c{eval-defun}). (Por defecto, el comando
   @c{eval-defun} funciona solo en modo Emacs Lisp o en el modo de
   interacción de Lisp.)

   Sin embargo, para preparar esta definición de función para Edebug, se debe
   primero @:{instrumentar} el código usando un comando diferente. Se puede
   hacer esto posicionando el cursor dentro o después de la definición y
   escribiendo

   @smallexample
     M-x edebug-defun RET
   @end smallexample

   Esto causará que Emacs cargue Edebug automáticamente si eso no está ya
   cargado y, apropiadamente prepara la función.

   Después de preparar la función, emplaza tu cursor después de la siguiente
   expresión y escribe @k{C-x C-e} (@c{eval-last-sexp}):

   @smallexample
     (triangle-recursively-bugged 3)
   @end smallexample

   Se vuelve a las fuentes de @c{triangle-recursively-bugged} y el cursor se
   posiciona al principio del @c{if} de la línea de la función. También, se
   verá una flecha en la mano izquierda al lado de esta línea donde la
   función se está ejecutando. (En los siguientes ejemplos, se muestra la
   flecha con @'{=>}; en un sistema de ventanas, se puede ver la flecha como
   un triángulo sólido en el ‘borde’ de la ventana.)

   @smallexample
     =>@point{}(if (= number 1)
   @end smallexample

   En el ejemplo, la posición del punto es mostrado con una estrella,
   @'{@point{}} (en Info, eso es mostrado como @'{-!-}).

   Si ahora se presiona @k{SPC}, el punto se moverá a la siguiente expresión
   para ejecutarse; la línea se parece a esto:

   @smallexample
     =>(if @point{}(= number 1)
   @end smallexample

   Como se continua presionando @k{SPC}, el puntero se moverá desde la
   expresión a la expresión. Al mismo tiempo, siempre y cuando una expresión
   devuelva un valor, este valor será mostrado en el área echo. Por ejemplo,
   después de mover el punto pasado @c{number}, se verá lo siguiente:

   @smallexample
     Resultado: 3 (#o3, #x3, ?\C-c)
   @end smallexample

   Esto significa el valor de @c{number} es 3, que son tres octales, tres
   hexadecimales, y @Cc{ascii} ‘control-c’ (la tercera letra del alfabeto, en
   caso de que se necesite conocer esta información).

   Uno puede continuar moviéndose a través del código hasta que logre la
   línea con el error. Antes de la evaluación, esta línea se parece a esto:

   @smallexample
     =>        @point{}(1= number)))))               ; @r{Error aquí.}
   @end smallexample

   Cuando se presiona @k{SPC} una vez de nuevo, se producirá un mensaje de
   error que dice:

   @smallexample
     La definición de la función está vacío:@: 1=
   @end smallexample

   Este es el error.

   Presiona @k{q} para salir de Edebug.

   Para eliminar la instrumentación desde una definición de función,
   simplemente se reevalúa con un comando que no lo instrumente. Por ejemplo,
   se podría posicionar su cursor después de la definición cerrando
   paréntesis y escribiendo @k{C-x C-e}.

   Edebug hace un gran trato antes de entrar en una función. Se puede dirigir
   así mismo, parando solo en un error o en puntos específicos, se puede
   causar para mostrar los valores cambiantes de varias expresiones; se puede
   encontrar cuantas veces una función se llama, y más.

   Edebug se describe en @"{edebug} en @e{El Manual de Referencia de GNU
   Emacs Lisp}.

** Ejercicios de depuración

   - Instale la función @c{@v{COUNT-WORDS}} y provoque que se introduzca el
     depurador construido cuando se llame. Ejecute el comando en una región
     conteniendo dos palabras. Se necesitará presionar @k{d} un número
     remarcable de veces. En el sistema, es un ‘hook’ llamado después que el
     comando se finaliza. (Para información sobre hooks, mira Seccion
     @"{Resumen del Comando Bucle} en @e{El Manual de Referencia GNU Emacs
     Lisp}.)

   - Copie @c{@v{COUNT-WORDS}} dentro del búffer @f{*scratch*}, instrumente
     la función para Edebug, y navegue a través de su ejecución. La función
     no necesita tener un error, aunque se puede introducir uno si se
     desea. Si a la función le falta un error, el paseo se completa sin
     problemas.

   - Mientras se ejecuta Edebug, escriba @k{?} para ver una lista de todos
     los comandos Edebug. (El @c{global-edebug-prefix} normalmente es @k{C-x
     X}, por ej@: @k{@k{CTRL}-x} seguido por una tecla mayúscula @k{X}; use
     este prefijo para comandos hechos fuera del búffer de depuración
     Edebug.)

   - En el búffer de depuración Edebug, usa el comando @k{p}
     (@c{edebug-bounce-point}) para ver si @c{@v{COUNT-WORDS}} está
     funcionando.

   - Mueve el punto a algún sitio debajo de la función y entonces escribe el
     comando @k{h} (@c{edebug-goto-here}) para saltar a esta localización.

   - Usa el comando @k{t} (@c{edebug-trace-mode}) para causar que Edebug
     pasee a través de la función en sí; usa una letra mayúscula @k{T} para
     @c{edebug-Trace-fast-mode}.

   - Asigna un punto de ruptura, entonces ejecuta Edebug en modo Traza hasta
     que se logre el punto de parada.

* Conclusión

  Ahora se ha llegado al fin de esta Introducción. Se ha aprendido lo
  suficiente acerca de programación en Emacs Lisp para asignar valores, para
  escribir ficheros @f{.emacs} para tí mismo y tus amigos, y escribir
  personalizaciones simples y extensiones a Emacs.

  Este es un lugar para parar. O, si se desea, se puede ir adelante, y
  aprender más por uno mismo.

  Se han aprendido algunas bases de programación. Pero solo algunas. Todavía
  hay muchas cosas que son fáciles de usar que no se han tocado.

  Otra idea para seguir es leer las fuentes de Emacs o @ifnotinfo @e{El
  Manual de Referencia de GNU Emacs}.  @end ifnotinfo @ifinfo @l{Arriba, , El
  Manual de Referencia de GNU Emacs Lisp, El Manual de Referencia de GNU
  Emacs Lisp}.  @end ifinfo

  Las fuentes de Emacs Lisp son una aventura. Cuando se leen las fuentes
  vienen a través de una función o expresión que nos es familiar, se necesita
  imaginar o encontrar qué se hace.

  Ir al Manual de Referencia. Eso está a través del completo, limpio y fácil
  de leer descripción de Emacs Lisp. Está escrito no solo para expertos, pero
  sí para gente que conoce lo que usted conoce. (El @e{Manual de Referencia}
  viene con la distribución de GNU Emacs. Como esta introducción, viene como
  un fichero fuente Texinfo, así se puede leer on-line como un libro
  impreso.)

  Ir a otra ayuda on-line que sea parte de GNU Emacs: la documentación
  on-line para todas las funciones y variables, y @c{find-tag}, el programa
  que va a las fuentes.

  Aquí hay un ejemplo de cómo explorar las fuentes. Porque su nombre,
  @f{simple.el} es el fichero que se vió primero, hace tiempo. Como eso
  ocurre alguna de las funciones en @f{simple.el} son complicadas, o al menos
  parece complicado a primera vista. La función @c{open-line}, por ejemplo,
  parece complicada.

  Se puede querer pasear a través de esta función lentamente, como nosotros
  hicimos la función @c{forward-sentence}. (Véase Sección @l{La función
  @c{forward-sentence}}.) O se puede querer salir de esta función y mirar en
  otra, tal como @c{split-line}. No se necesita leer todas las funciones. De
  acuerdo a @c{count-words-in-defun}, la función @c{split-line} contiene 102
  palabras y símbolos.

  Incluso aunque sean pocas, @c{split-line} contiene expresiones que no se
  han estudiado: @c{skip-chars-forward}, @c{indent-to}, @c{current-column} y
  @c{insert-and-inherit}.

  Considera la función @c{skip-chars-forward}. (Eso es parte de la definición
  de función para @c{back-to-indentation}, que muestra la @l{Revisar}.)

  En GNU Emacs, se puede encontrar más acerca de @c{skip-chars-forward}
  escribiendo @k{C-h f} (@c{describe-function}) y el nombre de la
  función. Esto te da la documentación de función.

  Se puede ser capaz de adivinar que se hace por una función bien llamada tal
  como @c{indent-to}; o se puede buscar, también. Incidentalmente, la función
  @c{describe-function} en sí está en @f{help.el}; esta es una de estas
  largas, pero descifrables funciones. ¿Se puede buscar @c{describe-function}
  usando el comando @k{C-h f}!

  En esta instancia, desde el código es Lisp, el búffer @f{*Help*} contiene
  el nombre de la librería conteniendo las fuentes de la función. Se puede
  poner el punto a través del nombre de la librería y presiona la tecla RET,
  que está en esta situación está asociado a @c{help-follow}, y se toma
  directamente de las fuentes, en el mismo camino que @k{M-.} (@c{find-tag}).

  La definición para @c{describe-function} ilustra como personalizar las
  expresiones @c{interactive} sin usar los códigos de caracter estándar y eso
  muestra como crear un búffer temporal.

  (La función @c{indent-to} es escrita en C en vez de Emacs Lisp; eso es una
  función ‘construida’. @c{help-follow} toma su fuente como @c{find-tag},
  cuando se configura apropiadamente.)

  Se puede mirar en las fuentes de la función usando @c{find-tag}, que está
  asociado a @k{M-.}. Finalmente, se puede encontrar que el Manual de
  Referencia tiene que decir visitando el manual en Info, y escribiendo @k{i}
  (@c{Info-index}) y el nombre de la función, o buscando la función en el
  índice a una copia impresa del manual.

  Similarmente, se puede encontrar que significa por @c{insert-and-inherit}.

  Otros ficheros fuente interesantes incluyen @f{paragraphs.el},
  @f{loaddefs.el} y @f{loadup.el}. El fichero @f{paragraphs.el} incluye
  ordenar, funciones fácilmente comprendidas tan bien como las largas. El
  fichero @f{loaddefs.el} contiene muchos autoloads estándar y muchos mapas
  de teclado. Nunca se ha buscado en todo; solo en las partes. @f{loadup.el}
  es el fichero que carga las partes estándar de Emacs; eso cuenta un gran
  trato acerca de cómo Emacs está construido. (Véase Sección @"{Construyendo
  Emacs} en @e{El Manual de Referencia GNU Emacs Lisp}, para más acerca de
  construcción.)

  Como dije, se han aprendido algunas cosas; sin embargo, y de manera muy
  importante, se han tocado fuertes aspectos de la programación; no se ha
  dicho nada acerca de como ordenar la información, excepto para usar la
  función predefinida @c{sort}; no se ha dicho nada acerca de cómo almacenar
  la información, excepto para usar variables y listas; no se ha dicho nada
  acerca de como escribir programas que escriben programas. Esto son asuntos
  para otro tipo diferente de libro, un diferente tipo de aprendizaje.

  Lo que se ha hecho es aprender lo suficiente para hacer mucho trabajo
  práctico con GNU Emacs. Lo que se ha hecho es comenzar. Este es el fin del
  principio de una gran amistad.

** Apéndice A La función @c{the-the}

   Algunas veces cuando se se escribe texto, se duplican palabras––como con
   “se se” cerca del principio de esta frase. Se encuentra que lo más
   frecuente, es duplicar “el”; aquí, se llama a la función para detectar las
   palabras duplicadas, @c{the-the}.

   Como primer paso, se podrían usar las siguientes expresiones regulares
   para buscar duplicados:

   @smallexample
     \\(\\w+[ \t\n]+\\)\\1
   @end smallexample

   Este regexp asocia uno o más caracteres que constituyen palabras seguidas
   por uno o más espacios, tabuladores, o nuevas líneas. Sin embargo, eso no
   detecta palabras duplicadas en diferentes líneas, desde la finalización de
   la primera palabra, el fin de la línea, es diferente desde el fin de la
   segunda palabra, un espacio. (Para más información acerca de expresiones
   regulares, mira el Capitulo 12 @l{Búsquedas de Expresiones Regulares}, tan
   bien como la Seccion @"{Sintaxis de Expresiones Regulares} en @e{El Manual
   de GNU Emacs}, y la Seccion @"{Expresiones Regulares} en @e{El Manual de
   Referencia GNU Emacs Lisp}.)

   Se podrían intentar buscar caracteres duplicados pero no si el patrón
   detecta dobles tales como las dos ocurrencias de ‘th’ en ‘with the’.

   Otro posible regexp busca caracteres constituyentes de palabras seguidos
   por caracteres de no palabras constituyentes, reduplicadas. Aquí, @'{\\w+}
   asocia a una o más caracteres de palabras constituyente y @'{\\W*} asocia
   cero o más caracteres que no constituyen palabras.

   @smallexample
     \\(\\(\\w+\\)\\W*\\)\\1
   @end smallexample

   De nuevo, no útil.

   Aquí está el patrón que uso. No es perfecto, pero suficientemente
   bueno. @'{\\b} asocia la cadena vacía provista al principio o fin de una
   palabra; @'{[^@@ \n\t]+} asocia una o más ocurrencias de qué caracteres
   que @e{no} son un @@-signo, espacio, nueva línea, o tabulador.

   @smallexample
     \\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
   @end smallexample

   Uno puede escribir expresiones más complicadas, pero esta expresión es
   suficientemente buena así.

   Aquí está la función @c{the-the}, como se incluye en mi fichero
   @f{.emacs}, a lo largo de un atajo global manejable:

   @smallexample
     (defun the-the ()
       "Busca hacia adelante para una palabra duplicada."
       (interactive)
       (message "Buscando palabras duplicadas ...")
       (push-mark)
       ;; Este regexp no es perfecto
       ;; pero es limpiamente bueno a pesar de todo:
       (if (re-search-forward
            "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
           (message "Palabra encontrada duplicada.")
         (message "Fin de búffer")))

     ;; Asocia ‘the-the’ a  C-c \
     (global-set-key "\C-c\\" 'the-the)
   @end smallexample

   Aquí está el test del texto:

   @smallexample
     uno dos tres cuatro cinco
     cinco seis siete
   @end smallexample

   Se pueden sustituir las otras expresiones regulares mostradas debajo en la
   definición de función y se prueba cada una de ellas en esta lista.

** Apéndice B Manejando el anillo de la muerte

   El anillo de la muerte es una lista que es transformada dentro de un
   anillo que trabaja con la función @c{current-kill}. Los comandos @c{yank}
   y @c{yank-pop} usan la función @c{current-kill}.

   Este apéndice describe la función @c{current-kill} y los comandos @c{yank}
   y @c{yank-pop}, pero primero, considere los trabajo del kill ring.

   El anillo de la muerte @e{kill ring} tiene el tamaño máximo de sesenta
   elementos; hacer una explicación con este número máximo quedaría demasiado
   larga. En vez de eso, pensemos qué ocurre si se asígna a cuatro. Por
   favor, evalúe lo siguiente:

   @smallexample
     (setq old-kill-ring-max kill-ring-max)
     (setq kill-ring-max 4)
   @end smallexample

   Entonces, por favor, copie cada línea del siguiente ejemplo indentado
   dentro del anillo de la muerte @e{kill ring}. Se puede cortar cada línea
   con @k{C-k} o marcarla y copiarla con @k{M-w}.

   (En un búffer de solo lectura, tal como el búffer @f{*info*}, el comando
   kill, @k{C-k} (@c{kill-line}), no eliminará el texto, solamente lo mueve
   al anillo de la muerte @e{kill ring}. Sin embargo, el ordenador puede
   avisar con un beep. Alternativamente, para silenciar, se puede copiar la
   región de cada línea con el comando @k{M-w} (@c{kill-ring-save}). Se debe
   marcar cada línea de este comando para tener éxito, pero no importa si al
   final se posiciona en el punto o la marca).

   Por favor, invoque las llamadas en orden, de modo que los cinco elementos
   rellenen el anillo de la muerte @e{kill ring}.

   @smallexample
     primero algo de texto
     segunda pieza de texto
     tercera línea
     cuarta línea de texto
     quinto bit de texto
   @end smallexample

   Entonces encuentra el valor de @c{kill-ring} evaluando

   @smallexample
     kill-ring
   @end smallexample

   Eso es:

   @smallexample
     ("quinto bit de texto" "cuarta línea de texto"
     "tercera línea" "segunda pieza de texto")
   @end smallexample

   El primer elemento, @'{primero algo de texto}, fué borrado.

   Para devolver el viejo valor para el tamaño del kill ring, evalúe:

   @smallexample
     (setq kill-ring-max old-kill-ring-max)
   @end smallexample

*** La función @c{current-kill}

    La función @c{current-kill} cambia el elemento en el anillo de la muerte
    @e{kill ring} para el que el @c{kill-ring-yank-pointer} apunta. (También,
    la función @c{kill-new} asigna @c{kill-ring-yank-pointer} para apuntar al
    último elemento del anillo de la muerte @e{kill ring}. La función
    @c{kill-new} se usa directamente o indirectamente por @c{kill-append},
    @c{copy-region-as-kill}, @c{kill-ring-save}, @c{kill-line}, y
    @c{kill-region}.)

    La función @c{current-kill} es usada por @c{yank} y por
    @c{yank-pop}. Aquí está el código para @c{current-kill}:

    @smallexample
      (defun current-kill (n &optional do-not-move)
      "Rota el punto de pegue por N lugares, y entonces devuelve lo cortado.
      Si N es cero, ‘interprogram-paste-function’ se asigna, y si se llama
      devuelve una cadena, entonces esta cadena se añade al frente del
      anillo de la muerte @e{kill ring} y devuelve el último corte.
      Si el argumento opcional DO-NOT-MOVE es no nulo, entonces no muevas el
      punto de pegue; solo devuelve el Nth corte hacia adelante.
         (let ((interprogram-paste (and (= n 0)
                                        interprogram-paste-function
                                        (funcall interprogram-paste-function)))))
          (if interprogram-paste
              (progn
                ;; Deshabilita el programa de la función de corte cuando se
                ;; añade el nuevo texto al anillo de la muerte @e{kill ring},
                ;; así Emacs no intenta poseer la selección
                ;; con idéntico texto.
                (let ((interprogram-cut-function nil))
                  (kill-new interprogram-paste))
                interprogram-paste)
            (or kill-ring (error "Kill ring is empty"))
            (let ((ARGth-kill-element
                   (nthcdr (mod (- n (length kill-ring-yank-pointer))
                                (length kill-ring))
                           kill-ring)))
              (or do-not-move
                  (setq kill-ring-yank-pointer ARGth-kill-element))
              (car ARGth-kill-element)))))
    @end smallexample

    Recuerde también que la función @c{kill-new} asigna
    @c{kill-ring-yank-pointer} al último elemento del anillo de la muerte
    @e{kill ring}, que significa que todas las funciones lo llaman y asigna
    el valor de manera indirecta: @c{kill-append}, @c{copy-region-as-kill},
    @c{kill-ring-save}, @c{kill-line} y @c{kill-region}.

    Aquí está la línea en @c{kill-new}, que se explica en la @l{La función
    @c{kill-new}}.

    @smallexample
      (setq kill-ring-yank-pointer kill-ring)
    @end smallexample

    La función @c{current-kill} parece compleja, pero usual, eso puede ser
    comprendido tomándolo aparte pieza por pieza. Primero míralo en la forma
    esquelética:

    @smallexample
      (defun current-kill (n &optional do-not-move)
        "Rota el punto a pegar por N lugares, y entonces devuelve el texto cortado."
        (let @var{varlist}
          @var{body}…)
    @end smallexample

    Esta función tiene dos argumentos, uno es opcional. Hay una cadena de
    documentación. @e{No} es una función interactiva.

    El cuerpo de la definición de función es una expresión @c{let}, que por
    sí misma tiene tanto un cuerpo como una @var{varlist}.

    La expresión @c{let} declara una variable que será solo usable con las
    asociaciones de esta función. Esta variable se llama
    @c{interprogram-paste} y se copia a otro programa. No se copia con esta
    instancia de GNU Emacs. La mayoría de los sistemas de ventanas proveen
    una facilidad para pegar el interprograma. Tristemente, esta facilidad
    normalmente provee solo el último elemento. La mayoría de los sistemas de
    ventanas no han adoptado un anillo de muchas posibilidades, incluso
    aunque Emacs haya provisto esto durante décadas.

    La expresión @c{if} tiene dos partes, una si existe
    @c{interprogram-paste} y otra si no.

    Permítenos considerar el ‘si no’ o la parte else de la función
    @c{current-kill}. (La parte then usa la función @c{kill-new}, que ya
    hemos descrito. Véase Sección @l{La función @c{kill-new}.})

    @smallexample
      (or kill-ring (error "El Kill ring está vacío"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element))
    @end smallexample

    El código primero chequea si el kill ring @e{anillo de la muerte} tiene
    contenido; de otro modo señala un error.

    Note que la expresión @c{or} es muy similar para testear el tamaño con un
    @c{if}:

    @smallexample
      (if (zerop (length kill-ring))          ; @r{parte-si}
          (error "Anillo de la muerte vacío"))       ; @r{parte-entonces}
        ;; No hay parte-resto
    @end smallexample

    Si no hay nada en el kill ring @e{anillo de la muerte}, su tamaño debe
    ser cero y un mensaje de error se envía al usuario: @'{El kill ring está
    vacío}. La función @c{current-kill} usa una expresión @c{or} que es
    simple. Pero una expresión @c{if} recuerda lo que lleva.

    Esta expresión @c{if} usa la función @c{zerop} que devuelve cierto si el
    valor que se chequea es cero. Cuando @c{zerop} chequea cierto, la parte
    then del @c{if} se evalúa. La parte then es una lista empezando con la
    función @c{error}, que es una función que es similar a la función
    @c{message} (Vease Sección @l{message, , La Función @c{message}}) que
    imprime un mensaje de una línea en el área echo. Sin embargo, además de
    imprimir un mensaje, @c{error} también evalúa la función que está
    embebida. Esto significa que el resto de la función no será evaluada si
    el tamaño del anillo de la muerte @e{kill ring} es cero.

    Entonces la función @c{current-kill} selecciona el elemento a
    devolver. La selección depende del número de lugares que @c{current-kill}
    rota y donde @c{kill-ring-yank-pointer} apunta.

    Lo siguiente, si el argumento @c{do-not-move} opcional es verdadero o el
    actual valor de @c{kill-ring-yank-pointer} se establece al punto de la
    lista. Finalmente, otra expresión devuelve el primer elemento de la lista
    incluso si el argumento @c{do-not-move} es verdadero.

    En mi opinión, es ligeramente erróneo, al menos para humanos, usar el
    término ‘error’ como el nombre de la función @c{error}. Un término mejor
    sería ‘cancelar’. Estrictamente hablando, de acuerdo, no se puede
    apuntar, mucho menos rotar un puntero a una lista que no tiene tamaño,
    así desde el punto de vista del ordenador, la palabra ‘error’ es
    correcta. Pero un humano espera intentar algo, si solo si se encuentra el
    anillo de la muerte @e{kill ring} esté lleno o vacío. Esto es un acto de
    exploración.

    Desde el punto de vista humano, el acto de exploración y descubrimiento
    no es necesariamente un error, y por esta razón no sería etiquetado como
    tal, incluso las vocales de un ordenador. Como tal, el código en Emacs
    implica que un humano que está actuando virtuosamente, explorando su
    entorno, está teniendo un error. Esto está mal. Incluso aunque el
    ordenador tome los mismos pasos como cuando hay ‘error’, un término tal
    como ‘cancelar’ tendría una clara connotación.

    Entre otras acciones, la else-part de la expresión @c{if} asigna el valor
    de @c{kill-ring-yank-pointer} a @c{ARGth-kill-element} cuando el kill
    ring @e{anillo de la muerte} tiene alguna cosa dentro y el valor de
    @c{do-not-move} es @c{nil}.

    El código se parece a esto:

    @smallexample
      (nthcdr (mod (- n (length kill-ring-yank-pointer))
                   (length kill-ring))
              kill-ring)))
    @end smallexample

    Esto necesita algún examen. A menos que no se suponga mover el puntero, la
    función @c{current-kill} cambia donde @c{kill-ring-yank-pointer}
    apunta. Esto es lo que la expresión @c{(setq kill-ring-yank-pointer
    ARGth-kill-element)} hace. También, claramente, @c{ARGth-kill-element}
    está siendo asignado para ser igual a algún @Cc{cdr} del anillo de la
    muerte @e{kill ring}, usando la función @c{nthcdr} que está descrita en
    una sección temprana. (Véase Sección @l{copy-region-as-kill}.)  ¿Cómo se
    hace?

    Como se ha visto antes (Vease Sección @l{nthcdr}), la función @c{nthcdr}
    funciona repetidamente tomando el @Cc{cdr} de una lista––eso toma el
    @Cc{cdr}, del @Cc{cdr}, del @Cc{cdr}, …

    Las siguientes dos expresiones producen el mismo resultado:

    @smallexample
      (setq kill-ring-yank-pointer (cdr kill-ring))

      (setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
    @end smallexample

    Sin embargo, la expresión @c{nthcdr} es más complicada. Usa la función
    @c{mod} para determinar que @Cc{cdr} para seleccionar.

    (Se recordará buscar funciones propias primero, en vez de esto, tendremos
    que ir dentro del @c{mod}.)

    La función @c{mod} devuelve el valor de su primer argumento módulo el
    segundo; que es decir, eso devuelve el resto después de dividir el primer
    argumento por el segundo. El valor devuelto tiene el mismo signo que el
    segundo argumento.

    De este modo,

    @smallexample
      (mod 12 4)
        ⇒ 0  ;; @r{porque no hay resto}
      (mod 13 4)
        ⇒ 1
    @end smallexample

    En este caso, el primer argumento es con frecuencia pequeño que el
    segundo. Que está bien.

    @smallexample
      (mod 0 4)
        ⇒ 0
      (mod 1 4)
        ⇒ 1
    @end smallexample

    Se puede adivinar lo que la función @c{-} hace. Eso es como @c{+} pero
    sustrae en vez de añadir; la función @c{-} sustrae su segundo argumento
    desde el primero. También, ya se sabe que la función @c{length} hace
    (Vease Sección @l{Encuentra el tamaño de una lista: @c{length}}). Eso
    devuelve el tamaño de una lista.

    Y @c{n} es el nombre del argumento requerido a la función
    @c{current-kill}.

    Así cuando el primer argumento a @c{nthcdr} es cero, la expresión
    @c{nthcdr} devuelve la lista entera, como se puede ver evaluando lo
    siguiente:

    @smallexample
      ;; kill-ring-yank-pointer @r{and} kill-ring @r{tener un tamaño de cuatro}
      ;; @r{and} (mod (- 0 4) 4) ⇒ 0
      (nthcdr (mod (- 0 4) 4)
              '("cuarta línea de texto"
                "tercera línea"
                "segunda pieza de texto"
                "primero algo de texto"))
    @end smallexample

    Cuando el primer argumento a la función @c{current-kill} es uno, la
    expresión @c{nthcdr} devuelve la lista sin su primer elemento.

    @smallexample
      (nthcdr (mod (- 1 4) 4)
              '("cuarta línea de texto"
                "tercera línea"
                "segunda pieza de texto"
                "primero algo de texto"))
    @end smallexample

    Incidentalmente, tanto @c{kill-ring} y @c{kill-ring-yank-pointer} son
    @:{variables globales}. Esto significa que cualquier expresión en Emacs
    Lisp puede acceder a ellas. Ellas no son como las variables locales
    asignadas por @c{let} o como los símbolos en una lista de argumentos. Las
    variables locales pueden solo ser accedidas con el @c{let} que los define
    o la función que los especifica en una lista de argumentos (y con
    expresiones llamadas por ellos).

    @ignore
      @c texi2dvi fails when the name of the section is within ifnottex ...
      (Véase Sección @l{Prevent confusion, , @c{let} Prevents Confusion}, and
      @l{defun, , The @c{defun} Special Form}.)
    @end ignore

*** @c{pegar}

    Después de aprender acerca de @c{current-kill}, el código para la función
    @c{yank} es casi fácil.

    La función @c{yank} no usa la variable @c{kill-ring-yank-pointer}
    directamente. Eso llama a @c{insert-for-yank} que llama a @c{current-kill}
    que asigna la variable @c{kill-ring-yank-pointer}.

    El código se parece a esto:

    @smallexample
      (defun yank (&optional arg)
        "Reinserta (\"pega\") el último logro del texto cortado.
      Más precisamente, reinserta el texto cortado más recientemente.
      Pon el punto al final, y asigna la marca al principio.
      Solo con \\[universal-argument] como argumento, lo mismo pero pon el
      punto al principio (y la marca al final). Con el argumento N, reinserta
      el N más recientemente cortado.
      Cuando este comando inserta texto cortado dentro del búffer, eso
      honra a ‘yank-excluded-properties’ y ‘yank-handler’ como se describe
      la cadena de documentación para ‘insert-for-yank-1’, que se ve.
      Ver también el comando \\[yank-pop]."
        (interactive "*P")
        (setq yank-window-start (window-start))
        ;; Si no tenemos todo el camino a través, crea last-command que
        ;; indique esto para el siguiente comando.
        (setq this-command t)
        (push-mark (point))
        (insert-for-yank (current-kill (cond
                                        ((listp arg) 0)
                                        ((eq arg '-) -2)
                                        (t (1- arg)))))
        (if (consp arg)
            ;; Esto es como like exchange-point-and-mark,
            ;;     pero no activa la marca.
            ;; Es limpio evitar la activación, incluso aunque el comando
            ;; loop would desactivaría la marca porque se
            ;; insertara el texto.
            (goto-char (prog1 (mark t)
                         (set-marker (mark-marker) (point) (current-buffer)))))
        ;; Si tenemos todo el camino, haz que this-command lo indique.
        (if (eq this-command t)
            (setq this-command 'yank))
        nil)
    @end smallexample

    La expresión clave es @c{insert-for-yank}, que inserta la cadena devuelta
    por @c{current-kill}, pero elimina algo de propiedades de texto desde eso.

    Sin embargo, antes de tener esta expresión, la función asigna el valor de
    @c{yank-window-start} a la posición devuelta por la expresión
    @c{(window-start)}, la posición que muestra lo que actualmente empieza. La
    función @c{yank} también asigna @c{this-command} y empuja la marca.

    Después de pegar el elemento apropiado, si el argumento opcional es un
    @Cc{cons} en vez de un número o nada, se pone el punto al principio del
    texto pegado y se marca al final.

    (La función @c{prog1} es como @c{progn} pero devuelve el valor de su
    primer argumento en vez del valor de su último argumento. Su primer
    argumento fuerza devolver la marca del búffer como un entero. Se puede ver
    la documentación para estas funciones emplazando el punto a través de
    ellas en este búffer y entonces escribiendo @k{C-h f}
    (@c{describe-function}) seguido por un @k{RET}; por defecto es la
    función.)

    La última parte de la función cuenta que hacer cuando eso sucede.

*** @c{yank-pop}

    Después de comprender @c{yank} y @c{current-kill}, se conoce como enfocar
    la función @c{yank-pop}. Dejando fuera la documentación para guardar el
    espacio, se parece a esto:

    @smallexample
      (defun yank-pop (&optional arg)
        "…"
        (interactive "*p")
        (if (not (eq last-command 'yank))
            (error "El comando previo no fué un corte"))
        (setq this-command 'yank)
        (unless arg (setq arg 1))
        (let ((inhibit-read-only t)
              (before (< (point) (mark t))))
          (if before
              (funcall (or yank-undo-function 'delete-region) (point) (mark t))
            (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
          (setq yank-undo-function nil)
          (set-marker (mark-marker) (point) (current-buffer))
          (insert-for-yank (current-kill arg))
          ;; Asigna la ventana a volver donde estaba el comando yank,
          ;; si es posible
          (set-window-start (selected-window) yank-window-start t)
          (if before
              ;; Esto es como exchange-point-and-mark,
              ;; pero no activa la marca.
              ;; Es limpio evitar la activación, incluso aunque el comando
              ;; desactivase la marca porque se insertara el texto.
              (goto-char (prog1 (mark t)
                           (set-marker (mark-marker)
                                       (point)
                                       (current-buffer))))))
        nil)
    @end smallexample

    La función es interactive con una pequeña @'{p} así el argumento prefijo
    es procesado y pasado a la función. El comando puede solo ser usado
    después del yank previo; de otro modo un mensaje de error se envía. Este
    chequeo usa la variable @c{last-command} que se asigna por @c{yank} y
    discutida de algún modo. (Véase Sección @l{copy-region-as-kill}.)

    La cláusula @c{let} asigna la variable @c{before} a cierto o falso
    dependiendo de si el punto está antes o después de la marca y entonce la
    región entre punto y marca se borra. Esta es la región que fué insertada
    por el yank previo y eso es este texto que será reemplazado.

    @c{funcall} llama a su primer argumento como una función, pasando los
    argumentos que permanecen. El primer argumento es el que la expresión
    @c{or} devuelve. Los dos argumentos que permanecen son las posiciones de
    punto y marca asignadas por el comando @c{yank} precedente.

    Hay más, pero esta es la parte más dura.

*** El fichero @f{ring.el}

    De manera interesante, GNU Emacs posee un fichero llamado @f{ring.el} que
    provee muchas de las funcionalidades que ahora se discuten. Pero las
    funciones tales como @c{kill-ring-yank-pointer} no usan esta librería,
    posiblemente porque fueron escritas pronto.

** Apéndice C @t(Un grafo con ejes etiquetados)

   Los ejes impresos ayudan a comprender un grafo. Para crear escalas. En un
   capítulo anterior (Vease Sección @l{Leyendo un grafo, , Leyendo un
   grafo}), se escribió el código para imprimir el cuerpo de un grafo. Aquí
   se escribe el código para imprimir y etiquetar ejes horizontales y
   verticales, a lo largo del cuerpo en sí.

   Puesto que las inserciones rellenan un búffer a la derecha y debajo del
   punto, el nuevo grafo imprime la función que primero imprimiría el eje
   vertical Y, después el cuerpo del grafo, y finalmente el eje horizontal
   X. Esta secuencia nos da los contenidos de la función:

   1. Configura código.

   2. Imprime el eje Y.

   3. Imprime el cuerpo del grafo.

   4. Imprime el eje X.


   Aquí hay un ejemplo de como se ve un grafo finalizado:

   @smallexample
     0 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
   @end smallexample

   En este grafo, en ambos ejes vertical y horizontal se etiquetan con
   números. Sin embargo, en algunos grafos, el eje horizontal es tiempo y
   estaría mejor etiquetarlo con meses, así:

   @smallexample
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
       Enero Junio Enero
   @end smallexample

   Dentro, con un pequeño pensamiento, se puede fácilmente venir con una
   variedad de esquemas de etiquetado verticales y horizontales. Nuestra
   tarea podría llegar a ser complicada. Pero las complicaciones generan
   confusión. En vez de permitir esto, es mejor elegir un simple esquema de
   etiquetado para nuestro primer esfuerzo, y modificarlo o reemplazarlo
   después.

   Estas consideraciones sugieren el siguiente outline para la función
   @c{print-graph}:

   @smallexample
     (defun print-graph (numbers-list)
       "@var{documentation}…"
       (let ((height  …
             …))
         (print-Y-axis height … )
         (graph-body-print numbers-list)
         (print-X-axis … )))
   @end smallexample

   Nosotros podemos trabajar en cada parte de la definición de función
   @c{print-graph}.

*** La varlist @c{print-graph}

    Para escribir la función @c{print-graph}, la primera tarea es escribir la
    varlist en la expresión @c{let}. (Nosotros dejaremos por ahora cualquier
    pensamiento acerca de hacer la función interactive o acerca de los
    contenidos de su cadena de documentación.)

    La varlist asignaría varios valores. Claramente, la etiqueta superior del
    eje vertical debe ser al menos la altura del grafo, que significa que
    debe obtener esta información aquí. Note que la función
    @c{print-graph-body} también requiere esta información. No hay razón para
    calcular la altura del grafo en dos lugares diferentes, así cambiaría
    @c{print-graph-body} desde el camino que definimos pronto para tomar
    ventaja del cálculo.

    De manera similar, tanto la función para imprimir la etiqueta del eje X y
    la función @c{print-graph-body} se necesita aprender el valor del ancho
    de cada símbolo. Se puede desarrollar el cálculo aquí y cambiar la
    definición para @c{print-graph-body} desde el camino que se definió en el
    capítulo previo.

    El tamaño de la etiqueta para el eje horizontal debe ser al menos tan
    largo como el grafo. Sin embargo, esta información es usada solo en la
    función que imprime el eje horizontal, así no necesita calcularse aquí.

    Estos pensamientos nos llevan directamente a la siguiente forma para la
    varlist en el @c{let} para @c{print-graph}:

    @smallexample
      (let ((height (apply 'max numbers-list)) ; @r{Primera versión.}
            (symbol-width (length graph-blank)))
    @end smallexample

    Como se verá, esta expresión no es bastante correcta.

*** La función @c{print-Y-axis}

    El trabajo de la función @c{print-Y-axis} es imprimir una etiqueta para el
    eje vertical que se parece a esto:

    @smallexample
          10 -




           5 -



           1 -
    @end smallexample

    La función se pasaría a lo alto del grafo, y así construyen e insertan los
    números y marcas apropiados.

    Es suficientemente fácil ver en la figura que la etiqueta del eje Y pero
    se puede decir en palabras, y entonces escribir una definición de función
    para hacer el trabajo es otra materia. No es bastante verdad decir que se
    quiere un número y un tic cada cinco líneas: solo hay tres líneas entre el
    @'{1} y el @'{5} (líneas 2, 3 y 4), pero cuatro líneas entre el @'{5} y el
    @'{10} (líneas 6, 7, 8 y 9). Es mejor decir que se quiere un número y un
    tic en la quinta línea desde abajo a cada línea que es un múltiplo de
    cinco.

    La siguiente cuestión es a que altura se etiquetaría. Supón que la máxima
    altura de la columna mayor del grafo es siete. La etiqueta superior en el
    eje Y sería @'{5 -}, ¿y el grafo se pegaría debajo de la etiqueta?, ¿o la
    etiqueta superior sería @'{7 -}, y marcar la vertical del grafo? ¿o sería
    la etiqueta superior @c{10 -}, que es múltiplo de cinco, y es superior al
    valor más alto del grafo?

    La última forma es preferida. La mayoría de los grafos son rectángulos
    cuyos lados son un número integral de pasos a lo largo––5, 10, 15, y así
    para un paso a distancia de cinco. Pero tan pronto se decide usar un paso
    alto para el eje vertical, se descubre que la expresión simple en la
    varlist para la altura de la computación es errónea. La expresión es
    @c{(apply 'max numbers-list)}. Esto devuelve la altura precisa, no la
    altura máxima más de lo que es necesario para redondear el múltiplo de
    cinco. Una expresión más compleja es requerida.

    Como es normal en casos como este, un problema complejo llega a ser simple
    si está dividido en varios problemas pequeños.

    Primero, considere el caso cuando el valor superior del grafo es un
    múltiplo integral de cinco––cuando eso es 5, 10, 15, o algún múltiplo de
    cinco. Se puede usar este valor como la altura del eje Y.

    Un camino simple y limpio para determinar si un número es múltiplo de
    cinco se divide por cinco y mira si la división devuelve resto. Si no hay
    resto, el número es un múltiplo de cinco. De este modo, siete dividido
    tiene un resto de dos, y siete no es un entero múltiplo de cinco. Dicho de
    otra manera, recordando la escuela, cinco entre siete es uno y me llevo
    dos. Sin embargo, diez entre dos, no tiene resto: diez es un múltiplo
    entero de cinco.

**** Viaje lateral: Calcula un resto

     En Lisp, la función para calcular un resto es @c{%}. La función devuelve
     el resto de su primer argumento dividido por su segundo argumento. Como
     ocurre, @c{%} es una función en Emacs Lisp que no se puede implementar
     usando @c{apropos}: no se puede encontrar nada si se escribe @k{M-x
     apropos @k{RET} resto @k{RET}}. El único camino para aprender la
     existencia de @c{%} es leer acerca de eso en un libro tal como este o en
     las fuentes de Emacs Lisp.

     Se puede probar la función @c{%} evaluando las siguientes dos
     expresiones:

     @smallexample
       (% 7 5)

       (% 10 5)
     @end smallexample

     La primera expresión devuelve 2 y la segunda expresión devuelve 0.

     Para chequear si el valor devuelto es cero o algún otro número, se puede
     usar la función @c{zerop}. Esta función devuelve @c{t} si su argumento
     debe ser un número, es cero.

     @smallexample
       (zerop (% 7 5))
            ⇒ nil

       (zerop (% 10 5))
            ⇒ t
     @end smallexample

     De este modo, la siguiente expresión devolverá @c{t} si la altura del
     grafo es divisible por cinco:

     @smallexample
       (zerop (% height 5))
     @end smallexample

     (El valor de @c{height}, de acuerdo, puede ser encontrado desde
     @c{(apply 'max numbers-list)}.)

     Por otro lado, si el valor de @c{height} no es un múltiplo de cinco,
     nosotros queremos resetear el valor al siguiente múltiplo de cinco. Esta
     es la aritmética sencilla usando funciones con las que ya se está
     familiarizado. Primero, se divide el valor de @c{height} por cinco para
     determinar cuantas veces cinco va dentro del número. De este modo, cinco
     va dentro doce veces. Si se añade uno a este cociente y se multiplica
     por cinco, obtendremos el valor del siguiente múltiplo de cinco que es
     más largo que el mayor. Cinco va dentro de doce dos veces. Añade uno a
     dos, y multiplica por cinco; el resultado es quince, que es el siguiente
     múltiplo de cinco que es mayor de doce. La expresión Lisp para esto es:

     @smallexample
       (* (1+ (/ height 5)) 5)
     @end smallexample

     Por ejemplo, si se evalúa lo siguiente, el resultado es 15:

     @smallexample
       (* (1+ (/ 12 5)) 5)
     @end smallexample

     Todo a través de esta discusión, se ha estado usando ‘cinco’ como el
     valor para las etiquetas espaciadas en el eje Y; pero se puede querer
     usar algún otro valor. Generalmente, reemplazaría ‘cinco’ con una
     variable a la que poder asignar un valor. El mejor nombre que puedo
     pensar para esta variable es @c{Y-axis-label-spacing}.

     Usando este término, y una expresión @c{if}, se produce lo siguiente:

     @smallexample
       (if (zerop (% height Y-axis-label-spacing))
           height
         ;; @r{else}
         (* (1+ (/ height Y-axis-label-spacing))
            Y-axis-label-spacing))
     @end smallexample

     Esta expresión devuelve el valor de @c{height} en sí si la altura es
     incluso un múltiplo del valor del @c{Y-axis-label-spacing} o lo demás
     computa y devuelve un valor de @c{height} que es igual al siguiente
     múltiplo mayor del valor del @c{Y-axis-label-spacing}.

     Se puede ahora incluir esta expresión en la expresión @c{let} de la
     función @c{print-graph} (después de la primera configuración del valor
     de @c{Y-axis-label-spacing}): @vindex Y-axis-label-spacing

     @smallexample
       (defvar Y-axis-label-spacing 5
         "Número de líneas desde una etiqueta del eje Y al siguiente.")

       …
       (let* ((height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; @r{else}
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (symbol-width (length graph-blank))))
       …
     @end smallexample

     (Note que el uso de la función @c{let*}: el valor inicial de la altura
     es calculada una vez por la expresión @c{(apply 'max numbers-list)} y
     entonces el valor resultado de @c{height} es usado para computar su
     valor final. Véase Sección @l{La expresión @c{let*}}, para más acerca de
     @c{let*}.)

**** Construye un elemento del eje Y

     Cuando se imprime el eje vertical, se quieren insertar cadenas tales
     como @'{5 -} y @'{10 - } cada cinco líneas. Más allá, se quieren los
     números agitados para alinear, así pocos números deben ser acuñados con
     espacios de guía. Si alguna de las cadenas usan dos dígitos, las cadenas
     con un simple dígito deben incluir una guía en blanco antes del número.

     Para figurarse el tamaño del número, se usa la función @c{length}. Pero
     la función @c{length} funciona solo con una cadena, no con un
     número. Así el número tiene que ser convertido desde un número a una
     cadena. Esto se hace con la función @c{number-to-string}. Por ejemplo,

     @smallexample
       (length (number-to-string 35))
            ⇒ 2

       (length (number-to-string 100))
            ⇒ 3
     @end smallexample

     (@c{number-to-string} se llama @c{int-to-string}; se verá este nombre
     alternativo en varias fuentes.)

     Además, en cada etiqueta, cada número es seguido por una cadena tal como
     @'{ - }, que llamará al marcador @c{Y-axis-tic}. Esta variable está
     definida con @c{defvar}:

     @smallexample
       (defvar Y-axis-tic " - "
          "La Cadena que sigue el número en una etiqueta del eje Y.")
     @end smallexample

     El tamaño de la etiqueta Y es la suma del tamaño del eje Y y el tamaño
     del número del alto del grafo.

     @smallexample
       (length (concat (number-to-string height) Y-axis-tic)))
     @end smallexample

     Este valor será calculado por la función @c{print-graph} en su varlist
     como @c{full-Y-label-width} y se pasa dentro. (Note que no se pensaba en
     incluir esto en el varlist cuando se propuso.)

     Para crear un eje vertical completo, una marca de tic es concatenada con
     un número; y los dos juntos pueden ser precedidos por uno o más espacios
     dependiendo de cómo de largo es el número. La etiqueta consiste de tres
     partes: los espacios que se lideran (opcional), el número, y la marca
     tic. La función se pasa al valor del número para la fila específica, y
     el valor del ancho de la línea de arriba, que es calculada (solo una
     vez) por @c{print-graph}.

     @smallexample
       (defun Y-axis-element (number full-Y-label-width)
         "Construye una etiqueta NUMERADA
       Un elemento numerado se parece a esto ‘ 5 - ’,
       y está tan acuñado como se necesita así todo se
       alinea con el elemento para el número mayor."
         (let* ((leading-spaces
                (- full-Y-label-width
                   (length
                    (concat (number-to-string number)
                            Y-axis-tic)))))
           (concat
            (make-string leading-spaces ? )
            (number-to-string number)
            Y-axis-tic)))
     @end smallexample

     La función @c{Y-axis-element} concatena junto los espacios que se
     lideran si cualquiera; el número, como una cadena; y la marca tic.

     Para imaginarnos cuantos espacios guía la etiqueta necesita, la función
     sustrae el tamaño de la etiqueta––el tamaño del número más el tamaño de
     la marca tic––desde el ancho de la etiqueta deseada.

     Los espacios en blanco se insertan usando la función
     @c{make-string}. Esta función tiene dos argumentos: lo primero cuenta
     como de larga será a cadena y el segundo es un símbolo para el caracter
     a insertar, en un formato espcial. El formato es una marca de pregunta
     seguida por un espacio en blanco, como este, @'{?}. Véase Sección
     @"{Tipo de Caracter} en @e{El Manual de Referencia Emacs Lisp}, para una
     descripción de la sintaxis para caracteres. (De acuerdo, se podría
     querer reemplazar el espacio en blanco por algún otro caracter …. Tu
     sabes qué hacer.)

     La función @c{number-to-string} es usada en la expresión de
     concatenación, para convertir el número a una cadena que es concatenada
     con los espacios que se lideran y la marca de tic.

**** Crea un eje de la columna Y

     Las funciones precedentes proporcionan todas las herramientas necesarias
     para construir una función que genera una lista de cadenas enumeradas y
     en blanco para inserta como la etiqueta para el eje vertical:

     @smallexample
       (defun Y-axis-column (height width-of-label)
         "Construye la lista de ejes Y etiquetadas y cadenas en blanco.
       Para height @e{la altura} de la línea de debajo y width-of-label."
         (let (Y-axis)
           (while (> height 1)
             (if (zerop (% height Y-axis-label-spacing))
                 ;; @r{Insertar etiqueta.}
                 (setq Y-axis
                       (cons
                        (Y-axis-element height width-of-label)
                        Y-axis))
               ;; @r{Else, insertar blancos.}
               (setq Y-axis
                     (cons
                      (make-string width-of-label ? )
                      Y-axis)))
             (setq height (1- height)))
           ;; @r{Insertar la línea base.}
           (setq Y-axis
                 (cons (Y-axis-element 1 width-of-label) Y-axis))
           (nreverse Y-axis)))
     @end smallexample

     En esta función, nosotros empezamos con el valor de @c{height} y
     repetitivamente sustrae uno desde su valor. Después de cada sustración,
     se chequea para ver si el valor es una integral múltiple del
     @c{Y-axis-label-spacing}. Si eso es, se construye una etiqueta numerada
     usando la función @c{Y-axis-element}; si no, se construye una etiqueta
     blanca usando la función @c{make-string}. La línea base consiste del
     número uno seguido por una marca tic.

**** La versión no demasiado final de @c{print-Y-axis}

     La lista construida por la función @c{Y-axis-column} está pasada a la
     función @c{print-Y-axis}, que inserta la lista como una columna.

     @smallexample
       (defun print-Y-axis (height full-Y-label-width)
         "Inserta el eje Y usando HEIGHT y FULL-Y-LABEL-WIDTH.
       La altura debe ser la máxima altura del grafo.
       El ancho completo es el ancho del mayor elemento de la
       etiqueta"
       ;; El valor del alto y full-Y-label-width
       ;; son pasadas por ‘print-graph’.
         (let ((start (point)))
           (insert-rectangle
            (Y-axis-column height full-Y-label-width))
           ;; @r{Posiciona el punto listo para inserta el grafo.}
           (goto-char start)
           ;; @r{Mueve el punto hacia adelante por valor de} full-Y-label-width
           (forward-char full-Y-label-width)))
     @end smallexample

     El @c{print-Y-axis} usa la función @c{insert-rectangle} para inserta el
     eje Y creado por la función @c{Y-axis-column}. Además, eso emplaza el
     punto en la posición correcta para imprimir el cuerpo del grafo.

     Se puede chequear @c{print-Y-axis}:

     - Instalar

       @smallexample
         Y-axis-label-spacing
         Y-axis-tic
         Y-axis-element
         Y-axis-column
         print-Y-axis
       @end smallexample

     - Copia la siguiente expresión:

       @smallexample
         (print-Y-axis 12 5)
       @end smallexample

     - Cambia al búffer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M-:} (@c{eval-expression}).

     - Pega la expresión @c{graph-body-print} dentro del minibúffer con
       @k{C-y} (@c{yank}).

     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá etiquetas verticalmente, el primero siendo @'{10 -
     }. (La función @c{print-graph} pasará el valor de
     @c{height-of-top-line}, que en este caso finalizará en 15, por esto lo
     que se obtiene podría aparecer como un error.)

*** La función @c{print-X-axis}

    Las etiquetas del eje X son como las etiquetas del eje Y, excepto que los
    ticks son un línea debajo de los números. Las etiquetas se parece como
    esto:

    @smallexample
      |   |    |    |
      1   5   10   15
    @end smallexample

    El primer tic está bajo la primera columna del grafo y está precedido por
    varios espacios en blanco. Estos espacios proporcionan la habitación en
    filas de debajo para las etiquetas del eje Y. El segundo, tercer, cuarto,
    y subsiguientes ticks son todos espaciados igualmente, de acuerdo al valor
    de @c{X-axis-label-spacing}.

    La segunda fila del eje X consiste de números, precedidos por varios
    espacios en blanco y también separado de acuerdo al valor de la variable
    @c{X-axis-label-spacing}.

    El valor de la variable @c{X-axis-label-spacing} sería medido en unidades
    de @c{symbol-width}, puesto que se puede querer cambiar el ancho de los
    símbolos que estás usando para imprimir el cuerpo del grafo sin cambiar
    los caminos del grafo que está etiquetado.

    La función @c{print-X-axis} está construida más o menos del mismo modo
    como que la función @c{print-Y-axis} excepto que tiene dos líneas: la
    línea de marcas tic y los números. Nosotros escribiremos una función
    separado a imprimir cada línea y entonces combinarlo con la función
    @c{print-X-axis}.

    Esto es un proceso de tres pasos:

    1. Escribe una función para imprimir el eje X marca tic,
       @c{print-X-axis-tic-line}.

    2. Escribe una función imprime los números X,
       @c{print-X-axis-numbered-line}.

    3. Escribe una función para imprimir ambas líneas, la función
       @c{print-X-axis}, usando @c{print-X-axis-tic-line} y
       @c{print-X-axis-numbered-line}.

**** Eje X marca tic

     La primera función imprimiría las marcas de tic del eje X. Se deben
     especificar las marcas en sí y su espacio:

     @smallexample
       (defvar X-axis-label-spacing
         (if (boundp 'graph-blank)
             (* 5 (length graph-blank)) 5)
         "Números de unidades desde un eje X al siguiente.")
     @end smallexample

     (Note que el valor de @c{graph-blank} est'a asignado por otro
     @c{defvar}. El predicado @c{boundp} chequea si ya ha sido asignado;
     @c{boundp} devuelve @c{nil} si no lo tiene. Si @c{graph-blank} fuera
     disociado y no usara esta construcción condicional, en un GNU Emacs
     reciente, se introduciría el depurador y mirará un mensaje de error
     diciendo @'{Debugger entered--Lisp error: (void-variable graph-blank)}

     Aquí está el @c{defvar} para @c{X-axis-tic-symbol}:

     @smallexample
       (defvar X-axis-tic-symbol "|"
         "Cadena para insertar para apuntar a una columna en el eje X.")
     @end smallexample

     El objetivo es crear una línea que se parece a esto:

     @smallexample
       |   |    |    |
     @end smallexample

     El primer tic es indentado así que está bajo la primera columna, que es
     indentado para proveer espacio para las etiquetas del eje Y.

     Un elemento tic consiste en espacios en blanco que se extienden desde un
     tic al siguiente más un símbolo tic. El número de espacios en blanco se
     determinan por el ancho del símbolo tic y el @c{X-axis-label-spacing}.

     El código se parece a esto:

     @smallexample
       ;;; X-axis-tic-element
       …
       (concat
        (make-string
         ;; @r{Crea una cadena de blancos.}
         (-  (* symbol-width X-axis-label-spacing)
             (length X-axis-tic-symbol))
         ? )
        ;; @r{Concatena blancos con símbolos.}
        X-axis-tic-symbol)
       …
     @end smallexample

     Lo siguiente, determina cuantos espacios en blanco son necesarios para
     indentar la primera marca tic a la primera del grafo. Esto usa el valor
     de @c{full-Y-label-width} pasaba por la función @c{print-graph}.

     El código para crear @c{X-axis-leading-spaces} se parece a esto:

     @smallexample
       ;; X-axis-leading-spaces
       …
       (make-string full-Y-label-width ? )
       …
     @end smallexample

     También necesita determinar el tamaño del eje horizontal, que es el
     tamaño de la lista de números, y el número de ticks en el eje
     horizontal:

     @smallexample
       ;; X-length
       …
       (length numbers-list)

       ;; tic-width
       …
       (* symbol-width X-axis-label-spacing)

       ;; number-of-X-ticks
       (if (zerop (% (X-length tic-width)))
           (/ (X-length tic-width))
         (1+ (/ (X-length tic-width))))
     @end smallexample

     Todo esto lidera directamente a la función para imprimir el eje X:

     @findex print-X-axis-tic-line
     @smallexample
       (defun print-X-axis-tic-line
         (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
         "Imprime ticks para el eje X."
           (insert X-axis-leading-spaces)
           (insert X-axis-tic-symbol)  ; @r{En la primera columna.}
           ;; @r{Inserta el segundo tic en el lugar adecuado.}
           (insert (concat
                    (make-string
                     (-  (* symbol-width X-axis-label-spacing)
                         ;; @r{Inserta el espacio en blanco al segundo símbolo tic.}
                         (* 2 (length X-axis-tic-symbol)))
                     ? )
                    X-axis-tic-symbol))
           ;; @r{Inserta los ticks que permanecen.}
           (while (> number-of-X-tics 1)
             (insert X-axis-tic-element)
             (setq number-of-X-tics (1- number-of-X-tics))))
     @end smallexample

     La línea de números es igualmente simple:

     Primero, creamos un elemento numerado con espacios en blanco antes de
     cada número:

     @smallexample
       (defun X-axis-element (number)
         "Construye un elemento del eje X numerado."
         (let ((leading-spaces
                (-  (* symbol-width X-axis-label-spacing)
                    (length (number-to-string number)))))
           (concat (make-string leading-spaces ? )
                   (number-to-string number))))
     @end smallexample

     Lo siguiente, se crea la función para imprimir la línea numerada,
     empezando con el número “1” para la primera columna:

     @smallexample
       (defun print-X-axis-numbered-line
         (number-of-X-tics X-axis-leading-spaces)
         "Imprime la líneas de números del eje X"
         (let ((number X-axis-label-spacing))
           (insert X-axis-leading-spaces)
           (insert "1")
           (insert (concat
                    (make-string
                     ;; @r{Inserta espacios en blanco al siguiente número.}
                     (-  (* symbol-width X-axis-label-spacing) 2)
                     ? )
                    (number-to-string number)))
           ;; @r{Insertar números.}
           (setq number (+ number X-axis-label-spacing))
           (while (> number-of-X-tics 1)
             (insert (X-axis-element number))
             (setq number (+ number X-axis-label-spacing))
             (setq number-of-X-tics (1- number-of-X-tics)))))
     @end smallexample

     Finalmente, se necesita escribir lo que @c{print-X-axis} que usa
     @c{print-X-axis-tic-line} y @c{print-X-axis-numbered-line}.

     La función debe determinar los valores locales de las variables usadas
     por @c{print-X-axis-tic-line} y @c{print-X-axis-numbered-line}, y
     entonces eso debe llamarlas. También, debe imprimir el retorno de carro
     que separe las dos líneas.

     La función consiste de una varlist que especifica cinco variables
     locales, y llama cada una de las dos líneas imprimiendo funciones:

     @smallexample
       (defun print-X-axis (numbers-list)
         "Imprime el eje X etique al tamaño de NUMBERS-LIST."
         (let* ((leading-spaces
                 (make-string full-Y-label-width ? ))
              ;; symbol-width @r{se provee por} graph-body-print
              (tic-width (* symbol-width X-axis-label-spacing))
              (X-length (length numbers-list))
              (X-tic
               (concat
                (make-string
                 ;; @r{Crea una cadena de espacios en blanco.}
                 (-  (* symbol-width X-axis-label-spacing)
                     (length X-axis-tic-symbol))
                 ? )
                ;; @r{Concatena espacio en blanco con símbolos
                tic.}
                X-axis-tic-symbol))
              (tic-number
               (if (zerop (% X-length tic-width))
                   (/ X-length tic-width)
                 (1+ (/ X-length tic-width)))))
           (print-X-axis-tic-line tic-number leading-spaces X-tic)
           (insert "\n")
           (print-X-axis-numbered-line tic-number leading-spaces)))
     @end smallexample

     Se puede testear @c{print-X-axis}:

     - Instale @c{X-axis-tic-symbol}, @c{X-axis-label-spacing},
       @c{print-X-axis-tic-line}, tanto como @c{X-axis-element},
       @c{print-X-axis-numbered-line}, y @c{print-X-axis}.

     - Copia la siguiente expresión:

       @smallexample
         (progn
          (let ((full-Y-label-width 5)
                (symbol-width 1))
            (print-X-axis
             '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
       @end smallexample

     - Cambia al búffer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M-:} (@c{eval-expression}).

     - Pegue la expresión de test dentro del minibuffer con @k{C-y}
       (@c{yank}).

     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá el eje horizontal así

     @smallexample
       |   |    |    |    |
       1   5   10   15   20
     @end smallexample

** Imprimiendo el grafo completo

   Ahora estamos listos para imprimir el grafo completo.

   La función para imprimir el grafo con las etiquetas apropiadas sigue el
   esquema que creamos antes (Vease Sección @l{Un Grafo con Ejes
   Etiquetados}), pero con adiciones.

   Aquí está el esquema:

   @smallexample
     (defun print-graph (numbers-list)
       "@var{documentation}…"
       (let ((height  …
             …))
         (print-Y-axis height … )
         (graph-body-print numbers-list)
         (print-X-axis … )))
   @end smallexample

   La versión final es diferente desde que se planea en dos caminos: primero,
   contiene los valores adicionales calculadas una vez que en la varlist;
   segundo, eso trae una opción para específicar las etiquetas se incrementa
   la fila. Esta última funcionalidad cambia a ser esencial; de otro modo, un
   grafo puede tener más filas que ajustarse en una muestra o en una hoja de
   papel.

   Esta nueva funcionalidad requiere un cambio a la función
   @c{Y-axis-column}, para añadir @c{vertical-step} para eso. Esta función es
   parece a esto:

   @smallexample
     ;;; @r{Versión Final.}
     (defun Y-axis-column
       (height width-of-label &optional vertical-step)
       "Construye una lista de etiquetas para el eje Y.
     HEIGHT es la máxima altura del grafo.
     WIDTH-OF-LABEL es el máximo ancho de la etiqueta.
     VERTICAL-STEP, una opción, es un entero positivo
     que especifica cuanto una etiqueta de eje Y incrementa
     cada línea. Por ejemplo, un paso de 5
     significa que cada línea es cinco unidades
     del grafo."
       (let (Y-axis
             (number-per-line (or vertical-step 1)))
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; @r{Inserta etiqueta.}
               (setq Y-axis
                     (cons
                      (Y-axis-element
                       (* height number-per-line)
                       width-of-label)
                      Y-axis))
             ;; @r{Else, inserta espacios en blanco.}
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; @r{Inserta línea base.}
         (setq Y-axis (cons (Y-axis-element
                             (or vertical-step 1)
                             width-of-label)
                            Y-axis))
         (nreverse Y-axis)))
   @end smallexample

   Los valores para la máxima altura del grafo y el ancho de un símbolo se
   computan por @c{print-graph} es su expresión @c{let}; así
   @c{graph-body-print} debe ser cambiado para aceptarlos.

   @smallexample
     ;;; @r{Versión Final.}
     (defun graph-body-print (numbers-list height symbol-width)
       "Imprime una gráfica de barras del NUMBERS-LIST.
     El numbers-list consiste en los valores del eje Y.
     HEIGHT es la máxisma altura del grafo.
     SYMBOL-WIDTH es el número de cada columna."
       (let (from-position)
         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; @r{Dibuja el grafo columna por columna.}
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; @r{Posiciona el punto para las etiquetas del eje X.}
         (forward-line height)
         (insert "\n")))
   @end smallexample

   Finalmente, el código para la función @c{print-graph}:

   @smallexample
     ;;; @r{Versión Final.}
     (defun print-graph
       (numbers-list &optional vertical-step)
       "El gráfico de barras etiquetadas del NUMBERS-LIST.
     El numbers-list consiste en los valores de eje Y.

     Opcionalmente, VERTICAL-STEP, un entero positivo, especifica cuanto el
     eje Y incrementa cada línea. Por ejemplo, un paso de 5
     significa que cada fila es de cinco unidades.
       (let* ((symbol-width (length graph-blank))
              ;; @c{height} @r{en ambos es el número más largo}
              ;; @r{y el número con la mayoría de los digitos.}
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; @r{else}
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))

         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
          numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list)))
   @end smallexample

**** Testeando @c{print-graph}

     Se puede chequear la función @c{print-graph} con una lista ordenada de
     números:

     - Instala las versiones finales de @c{Y-axis-column},
       @c{graph-body-print}, y @c{print-graph} (además del resto del código.)

     - Copia la siguiente expresión:

       @smallexample
         (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
       @end smallexample

     - Cambia al búffer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M-:} (@c{eval-expression}).

     - Pegue la expresión de test dentro del minibuffer con @k{C-y}
       (@c{yank}).

     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá un grafo que se parece a:

     @smallexample
       10 -


                *
               **   *
        5 -   ****  *
              **** ***
            * *********
            ************
        1 - *************

            |   |    |    |
            1   5   10   15
     @end smallexample

     Por otro lado, si se pasa a @c{print-graph} un @c{vertical-step} valor
     de 2, evaluando esta expresión:

     @smallexample
       (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
     @end smallexample

     El grafo se parece a esto:

     @smallexample
       20 -


                *
               **   *
       10 -   ****  *
              **** ***
            * *********
            ************
        2 - *************

            |   |    |    |
            1   5   10   15
     @end smallexample

     (Una pregunta: ¿es el ‘2’ debajo del eje vertical un error o una
     funcionalidad? Si se piensa que es un error, y sería un ‘1’, (o incluso
     un ‘0’), se pueden modificar las fuentes.)

**** Creando gráficas de números de palabras y símbolos

     Ahora para el gráfico para el que todo este código fué escrito: un
     gráfico que muestra cuantas definiciones de función contienen unas pocas
     10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y
     símbolos, cuantos contienen entre 20 y 29 palabras y símbolos, y así.

     Esto es un proceso de múltiples pasos. Primero asegúrate que has cargado
     todo el requisito del código.

     Eso es una buena idea para eliminar el valor de @c{top-of-ranges} en
     caso de que has asignado a algún valor diferente. Se puede evaluar lo
     siguiente:

     @smallexample
       (setq top-of-ranges
        '(10  20  30  40  50
          60  70  80  90 100
         110 120 130 140 150
         160 170 180 190 200
         210 220 230 240 250
         260 270 280 290 300)
     @end smallexample

     Lo siguiente crea una lista del número de palabras y símbolos en cada
     rango.

     Evalúa lo siguiente:

     @smallexample
       (setq list-for-graph
              (defuns-per-range
                (sort
                 (recursive-lengths-list-many-files
                  (directory-files "/usr/local/emacs/lisp"
                                   t ".+el$"))
                 '<)
                top-of-ranges))
     @end smallexample

     En mi vieja máquina, esto lleva como una hora. Se parece a 303 ficheros
     Lisp en mi copia de Emacs version 19.23. Después de toda esta
     computación, el @c{list-for-graph} tenía este valor:

     @smallexample
       (537 1027 955 785 594 483 349 292 224 199 166 120 116 99
       90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
     @end smallexample

     Esto significa que mi copia de Emacs tiene 537 definiciones de funciones
     con poco menos de 10 palabras o símbolos en sí, 1027 definiciones de
     función con 10 a 19 palabras o símbolos dentro, 955 definiciones de
     función con 20 a 29 palabras o símbolos dentro, y así.

     Claramente, solo buscando esta lista se puede ver que la mayoría de
     definiciones de función contienen de diez a treinta palabras y símbolos.

     Ahora para imprimir. Nosotros @e{no} queremos imprimir un grafo que es
     de 1030 líneas de alto …. En vez de eso, imprimiría un grafo que es
     mejor que venticinco líneas de alto. Un grafo cuya altura puede ser
     mostrada en casi cualquier monitor, y fácilmente impreso en una hoja de
     papel.

     Esto significa que cada valor en @c{list-for-graph} debe ser reducido a
     un quinceavo de su valor presente.

     Aquí hay una corta función para hacer esto, usando dos funciones que no
     se han visto todavía, @c{mapcar} y @c{lambda}.

     @smallexample
       (defun one-fiftieth (full-range)
         "Devuelve la lista, con el cincuenteavo de cada elemento."
        (mapcar '(lambda (arg) (/ arg 50)) full-range))
     @end smallexample

**** Una expresión @c{lambda}: Anonimicidad útil

     @c{lambda} es el símbolo para una función anónima, una función sin un
     nombre. Cada vez que se use una función anónima, se necesita incluir su
     cuerpo completo.

     De este modo,

     @smallexample
       (lambda (arg) (/ arg 50))
     @end smallexample

     es una definición de función que dice ‘devuelve el valor resultante de
     dividir cualquier cosa que es pasada como @c{arg} por 50’.

     Pronto, por ejemplo, se tenía una función @c{multiply-by-seven}; se
     multiplica su argumento por 7. Esta función es similar, excepto que
     divide su argumento por 50; y, no tiene nombre. El equivalente anónimo
     de @c{multiply-by-seven} es:

     @smallexample
       (lambda (number) (* 7 number))
     @end smallexample

     (Véase Sección @l{La forma especial @c{defun}}.)

     Si queremos multiplicar 3 por 7, podemos escribir:

     @diagram
       (multiply-by-seven 3)
        \_______________/ ^
                |         |
             función  argumento
     @end diagram

     Esta expresión devuelve 21.

     De manera similar, se puede escribir:

     @diagram
       ((lambda (number) (* 7 number)) 3)
        \____________________________/ ^
                      |                |
             función anónima     argumento
     @end diagram

     Si queremos dividir 100 por 50, se puede escribir:

     @diagram
       ((lambda (arg) (/ arg 50)) 100)
        \______________________/  \_/
                    |              |
            función anónima   argumento
     @end diagram

     Esta expresión devuelve 2. El 100 es pasado para la función, que divide
     este número por 50.

     Véase Sección @"{Expresiones Lambda} en @e{El Manual de Referencia GNU
     Emacs Lisp}, para más acerca de @c{lambda}. Lisp y expresiones Lambda se
     derivan del Cálculo Lambda.

*** La función @c{mapcar}

    @c{mapcar} es una función que llama a su primer argumento con cada
    elemento de su segundo argumento. El segundo argumento debe ser una
    secuencia.

    La parte @'{map} del nombre viene de la frase matemática, ‘mapeando a
    través de un dominio’, significa hace apply a una función a cada uno de
    los elementos en un dominio. La frase matemática está basada en la
    metáfora de un superviviente paseando, un paso en un momento, a través de
    un área él está mapeando. Y @'{car}, de acuerdo, viene desde la noción
    Lisp del primero de una lista.

    Por ejemplo,

    @smallexample
      (mapcar '1+ '(2 4 6))
           ⇒ (3 5 7)
    @end smallexample

    La función @c{1+} añade uno a su argumento, es ejecutada en @e{each} de
    la lista, y una nueva lista es devuelta.

    En contraste con esto @c{apply}, se aplica su primer argumento a todo lo
    que permanece. (Véase Sección @l{Leyendo un grafo}, para una explicación
    de @c{apply}.)

    En la definición de @c{one-fiftieth}, el primer argumento es la función
    anónima:

    @smallexample
      (lambda (arg) (/ arg 50))
    @end smallexample

    y el segundo argumento es @c{full-range}, que será asociado para
    @c{list-for-graph}.

    La expresión completa se parece a esto:

    @smallexample
      (mapcar (lambda (arg) (/ arg 50)) full-range))
    @end smallexample

    Véase Sección @"{Mapeando Funciones} en @e{El Manual de Referencia de GNU
    Emacs Lisp}, para más acerca de @c{mapcar}.

    Usando la función @c{one-fiftieth}, se puede generar una lista en el que
    cada elemento es un cincuenteavo del tamaño del correspondiente elemento
    en @c{list-for-graph}.

    @smallexample
      (setq fiftieth-list-for-graph
            (one-fiftieth list-for-graph))
    @end smallexample

    La lista resultante se parece a esto:

    @smallexample
      (10 20 19 15 11 9 6 5 4 3 3 2 2
      1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
    @end smallexample

    Así, ¿ya estamos casi listos para imprimir!  (También se notifica la
    pérdida de información: muchos de los rangos superiores son 0, esto
    significa que menos de 50 funciones tenían muchas palabras o
    símbolos––pero no necesariamente significando que niguna tenía muchas
    palabras o símbolos.)

**** Otro error … más insidioso

     ¿Se dijo ‘casi listo para imprimir’! De acuerdo, hay un error en la
     función @c{print-graph} …. Esta tiene una opción @c{vertical-step}, pero
     no una opción @c{horizontal-step}. La escala @c{top-of-range} va desde
     10 a 300 por decenas. Pero la función @c{print-graph} imprimirá solo uno
     por uno.

     Esto es un ejemplo clásico de lo que algunos consideramos el tipo más
     insidioso de error, el error de omisión. Este no es el tipo de error que
     se puede encontrar estudiando el código, para eso no es el código; es
     una funcionalidad omitida. Tus mejores acciones son probar tu programa
     pronto y con frecuencia; e intentar poner en orden, tanto como se pueda,
     escribir código que sea fácil de comprender y fácil de cambiar. Intenta
     ser consciente, siempre y cuando se pueda, esto es siempre que tengas
     que escribir, @e{será} reescrito, si no pronto, eventualmente. Un máximo
     duro de seguir.

     Esta es la función @c{print-X-axis-numbered-line} que necesita el
     trabajo; y entonces el @c{print-X-axis} y la función @c{print-graph}
     necesita ser adaptada. No se necesita mucho para ser hecho; hay uno
     simpático: los números podrían alinearse con marcas de tic. Esto toma un
     pequeño pensamiento.

     Aquí está el @c{print-X-axis-numbered-line} corregido:

     @smallexample
       (defun print-X-axis-numbered-line
         (number-of-X-tics X-axis-leading-spaces
          &optional horizontal-step)
         "Imprime la líneas de números X-axis"
         (let ((number X-axis-label-spacing)
               (horizontal-step (or horizontal-step 1)))
           (insert X-axis-leading-spaces)
           ;; @r{Elimina espacios extra de guía.}
           (delete-char
            (- (1-
                (length (number-to-string horizontal-step)))))
           (insert (concat
                    (make-string
                     ;; @r{Inserta espacio en blanco.}
                     (-  (* symbol-width
                            X-axis-label-spacing)
                         (1-
                          (length
                           (number-to-string horizontal-step)))
                         2)
                     ? )
                    (number-to-string
                     (* number horizontal-step))))
           ;; @r{Insertar los números que permanecen.}
           (setq number (+ number X-axis-label-spacing))
           (while (> number-of-X-tics 1)
             (insert (X-axis-element
                      (* number horizontal-step)))
             (setq number (+ number X-axis-label-spacing))
             (setq number-of-X-tics (1- number-of-X-tics)))))
     @end smallexample

     Si se está leyendo esto en Info, se pueden ver las nuevas versiones
     @c{print-X-axis} y @c{print-graph} y los evaluarlas. Si se está leyendo
     esto en un libro impreso, se pueden ver las líneas cambiadas aquí (el
     texto completo es mucho para imprimir).

     @smallexample
       (defun print-X-axis (numbers-list horizontal-step)
         …
           (print-X-axis-numbered-line
            tic-number leading-spaces horizontal-step))
       (defun print-graph
         (numbers-list
          &optional vertical-step horizontal-step)
         …
           (print-X-axis numbers-list horizontal-step))
     @end smallexample

**** El gráfico impreso

     Cuando esté hecho e instalado, se puede llamar al comando
     @c{print-graph} como esto:

     @smallexample
       (print-graph fiftieth-list-for-graph 50 10)
     @end smallexample

     Aquí está el gráfico:

     @smallexample
       1000 -  *
               **
               **
               **
               **
        750 -  ***
               ***
               ***
               ***
               ****
        500 - *****
              ******
              ******
              ******
              *******
        250 - ********
              *********                     *
              ***********                   *
              *************                 *
         50 - ***************** *           *
              |   |    |    |    |    |    |    |
             10  50  100  150  200  250  300  350
     @end smallexample


     El grupo largo de funciones contienen de 10 a 19 palabras y símbolos.

** Apéndice D Software Libre y Manuales Libres
   @ @b{por Richard M. Stallman}

   La mayor deficiencia en sistemas operativos libres no está en el
   software––es la falta de buenos manuales libres que se puedan incluir en
   estos sistemas. Muchos de nuestros programas más importantes no vienen con
   manuales completos. La documentación es una parte esencial de cualquier
   paquete de software; cuando un paquete de software libre no viene con un
   manual libre, es una brecha mayor. Nosotros tenemos muchas brechas hoy.

   Érase una vez, hace muchos años, se piensa que aprendería Perl. Se tiene
   una copia de un manual libre, pero se encontró difícil de leer. Cuando
   pregunto a los usuarios de Perl acerca de alternativas, me contaron que
   serían mejor los manuales introductorios––pero estos no eran libres.

   ¿Por qué era esto? Los autores de los buenos manuales los habían escrito
   para O'Reilly Associates, que los publicaron con términos restrictivos––no
   copiando, no modificando, los ficheros fuentes están disponibles––que los
   excluyen desde la comunidad de software libre.

   No era la primera vez que esto ocurría, y (para nuestra comunidad es una
   gran pérdida) eso está lejos desde el último. Las editoriales de manuales
   privativos han logrado que muchos autores restrinjan sus manuales desde
   entonces. Muchas veces se ha oido que un usuario de GNU hábil me cuente
   que un manual que está escribiendo, con el que él espera ayudar al
   proyecto GNU --- y entonces tenía mis esperanzas frustradas, como se ha
   procedió a explicar que él tenía que haber firmado un contrato con una
   editorial que restringiría eso, así que no puede usarlo.

   Debido a que escribir buen inglés es una habilidad rara entre
   programadores, se pueden perder manuales por este motivo.

   La documentación, como el software, es una cuestión de libertad, no de
   precio. El problema con estos manuales no eran que O'Reilly Associates
   impusiera un precio por las copias impresas––que en sí estaban bien. La
   Free Software Foundation @e{Fundación por el Software Libre}
   @l{http://shop.fsf.org, vende copias impresas} de
   @l{http://www.gnu.org/doc/doc.html, manuales libres de GNU}, también. Pero
   los manuales de GNU están disponibles en forma de código fuente, mientras
   que estos manuales están disponibles solo en papel. Los manuales de GNU
   vienen con permiso para copiar y modificar; los manuales de Perl no. Estas
   restricciones son un problema.

   El criterio para un manual libre es parecido al del software libre: es una
   cuestión de dar a todos los usuarios ciertas libertades. La redistribución
   (incluyendo redistribución comercial) debe ser permitida, así el manual
   puede acompañar cada copia del programa, en líne o en papel. El permiso
   para modificar es crucial también.

   Como regla general, no se cree que sea esencial para la gente tener
   permisos para modificar todas las partes de artículos y libro. Las
   cuestiones para escritos no son necesariamente las mismas como estas para
   el software. Por ejemplo, no se sabe si se está obligado a dar permisos
   para modificar artículos como este, que describen nuestras acciones y
   nuestras vistas.

   Pero hay una razón particular de por qué la libertad de modificar es
   crucial para la documentación de software libre. Cuando las personas
   ejercita su derecho a modificar el software, y añadir o cambiar sus
   funcionalidades, si son consciente ellos cambiarán el manual también––así
   se puede proveer documentación usable y cuidada con el programa
   modificado. Un manual que prohibe a los programadores ser consciente y
   finalizar el trabajo, o más precisamente requiere escribir un nuevo manual
   desde cero si ellos cambian el programa, no se ajusta a las necesidades de
   nuestra comunidad.

   Mientras una serie de prohibiciones en la modificación es inaceptable,
   algunos tipos de límites en el método de modificar no tiene tanto
   problema. Por ejemplo, los requisitos para preservar la noticia de autores
   del copyright, los términos de distribución, o la lista de autores, estén
   ok. Eso es también no da problemas para requerir versiones modificadas
   para incluir notificar que fueron modificadas, incluso tienen secciones
   enteras que puede no ser eliminadas o cambiadas, tan largo como estas
   secciones tratan con asuntos no técnicos. (Algunos manuales de GNU los
   tienen).

   Estos tipos de restricciones no son un problema porque, como materia
   práctica, no para al programador consciente desde la adaptación del manual
   para ajustar el programa modificado. En otras palabras, no se bloquea la
   comunidad del software libre haciendo el uso completo del manual.

   Sin embargo, debe ser posible modificar todo el contenido técnico del
   manual, y entonces se distribuye el resultado en todos los medios usuales,
   a través de todos los canales usuales; de otro modo, las restricciones
   bloquean la comunidad, el manual no es libre, y así no se necesita otro
   manual.

   Desafortunadamente, con frecuencia es duro encontrar a alguien a escribir
   otro manual cuando un manual privativo. El obstáculo es que muchos usuario
   piensan que un manual privativo es suficientemente bueno––así ellos no ven
   la necesidad de escribir un manual libre. Ellos no ven que el sistema
   operativo tiene un gazapo que necesita se rellenado.

   ¿Por qué los usuarios piensan que los manuales privativos son
   suficientemente buenos? Algunos no han considerado la cuestión. Espero que
   este artículo hará alguna cosa para cambiar esto.

   Otros usuarios considera manuales privativos aceptables para la misma
   razón así muchas personas software privativo aceptable: ellos judgan en
   términos puramente prácticos, no usando la liberta como un criterio. Estas
   personas son tituladas a sus opiniones, pero desde que estas opciones
   crezcan desde valores que no incluyen libertad, ellas no están guiadas por
   esto quienes valoran la libertad.

   Por favor, populariza esta cuestión. Se continúa a perder manuales para
   publicación privativa. Si se populariza que los manuales privativos no son
   suficientes, quizás la siguiente persona que quiere ayudar a GNU
   escribiendo documentación realizará, antes de que sea demasiado tarde, lo
   que él debe que todo sea libre.

   Se puede también animar editoriales comerciales a vender manuales libres o
   con copyleft en vez de uno privativo. Un camino que se puede ayudar esto
   chequea los términos de la distribución de un manual antes de que se
   compre, y preferimos manuales copyleft a los no copyleft.

   Note: La Fundación para el Software Libre mantiene una página en su sitio
   Web que liste libros libres disponibles desde otras editoriales:@*
   @l{http://www.gnu.org/doc/other-free-books.html}

** Apéndice E GNU Free Documentation License

   @center
     Version 1.3, 3 November 2008
   @end center

   Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
   <http://fsf.org/>

   Everyone is permitted to copy and distribute verbatim copies of this
   license document, but changing it is not allowed.

*** 0. PREAMBLE

    The purpose of this License is to make a manual, textbook, or other
    functional and useful document "free" in the sense of freedom: to assure
    everyone the effective freedom to copy and redistribute it, with or
    without modifying it, either commercially or noncommercially.
    Secondarily, this License preserves for the author and publisher a way to
    get credit for their work, while not being considered responsible for
    modifications made by others.

    This License is a kind of "copyleft", which means that derivative works
    of the document must themselves be free in the same sense.  It
    complements the GNU General Public License, which is a copyleft license
    designed for free software.

    We have designed this License in order to use it for manuals for free
    software, because free software needs free documentation: a free program
    should come with manuals providing the same freedoms that the software
    does.  But this License is not limited to software manuals; it can be
    used for any textual work, regardless of subject matter or whether it is
    published as a printed book.  We recommend this License principally for
    works whose purpose is instruction or reference.

*** 1. APPLICABILITY AND DEFINITIONS

    This License applies to any manual or other work, in any medium, that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  Such a notice grants a
    world-wide, royalty-free license, unlimited in duration, to use that work
    under the conditions stated herein.  The "Document", below, refers to any
    such manual or work.  Any member of the public is a licensee, and is
    addressed as "you".  You accept the license if you copy, modify or
    distribute the work in a way requiring permission under copyright law.

    A "Modified Version" of the Document means any work containing the
    Document or a portion of it, either copied verbatim, or with
    modifications and/or translated into another language.

    A "Secondary Section" is a named appendix or a front-matter section of
    the Document that deals exclusively with the relationship of the
    publishers or authors of the Document to the Document's overall subject
    (or to related matters) and contains nothing that could fall directly
    within that overall subject.  (Thus, if the Document is in part a
    textbook of mathematics, a Secondary Section may not explain any
    mathematics.)  The relationship could be a matter of historical
    connection with the subject or with related matters, or of legal,
    commercial, philosophical, ethical or political position regarding them.

    The "Invariant Sections" are certain Secondary Sections whose titles are
    designated, as being those of Invariant Sections, in the notice that says
    that the Document is released under this License.  If a section does not
    fit the above definition of Secondary then it is not allowed to be
    designated as Invariant.  The Document may contain zero Invariant
    Sections.  If the Document does not identify any Invariant Sections then
    there are none.

    The "Cover Texts" are certain short passages of text that are listed, as
    Front-Cover Texts or Back-Cover Texts, in the notice that says that the
    Document is released under this License.  A Front-Cover Text may be at
    most 5 words, and a Back-Cover Text may be at most 25 words.

    A "Transparent" copy of the Document means a machine-readable copy,
    represented in a format whose specification is available to the general
    public, that is suitable for revising the document straightforwardly with
    generic text editors or (for images composed of pixels) generic paint
    programs or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic translation to
    a variety of formats suitable for input to text formatters.  A copy made
    in an otherwise Transparent file format whose markup, or absence of
    markup, has been arranged to thwart or discourage subsequent modification
    by readers is not Transparent.  An image format is not Transparent if
    used for any substantial amount of text.  A copy that is not
    "Transparent" is called "Opaque".

    Examples of suitable formats for Transparent copies include plain ASCII
    without markup, Texinfo input format, LaTeX input format, SGML or XML
    using a publicly available DTD, and standard-conforming simple HTML,
    PostScript or PDF designed for human modification.  Examples of
    transparent image formats include PNG, XCF and JPG.  Opaque formats
    include proprietary formats that can be read and edited only by
    proprietary word processors, SGML or XML for which the DTD and/or
    processing tools are not generally available, and the machine-generated
    HTML, PostScript or PDF produced by some word processors for output
    purposes only.

    The "Title Page" means, for a printed book, the title page itself, plus
    such following pages as are needed to hold, legibly, the material this
    License requires to appear in the title page.  For works in formats which
    do not have any title page as such, "Title Page" means the text near the
    most prominent appearance of the work's title, preceding the beginning of
    the body of the text.

    The "publisher" means any person or entity that distributes copies of the
    Document to the public.

    A section "Entitled XYZ" means a named subunit of the Document whose
    title either is precisely XYZ or contains XYZ in parentheses following
    text that translates XYZ in another language.  (Here XYZ stands for a
    specific section name mentioned below, such as "Acknowledgements",
    "Dedications", "Endorsements", or "History".)  To "Preserve the Title" of
    such a section when you modify the Document means that it remains a
    section "Entitled XYZ" according to this definition.

    The Document may include Warranty Disclaimers next to the notice which
    states that this License applies to the Document.  These Warranty
    Disclaimers are considered to be included by reference in this License,
    but only as regards disclaiming warranties: any other implication that
    these Warranty Disclaimers may have is void and has no effect on the
    meaning of this License.

*** 2. VERBATIM COPYING

    You may copy and distribute the Document in any medium, either
    commercially or noncommercially, provided that this License, the
    copyright notices, and the license notice saying this License applies to
    the Document are reproduced in all copies, and that you add no other
    conditions whatsoever to those of this License.  You may not use
    technical measures to obstruct or control the reading or further copying
    of the copies you make or distribute.  However, you may accept
    compensation in exchange for copies.  If you distribute a large enough
    number of copies you must also follow the conditions in section 3.

    You may also lend copies, under the same conditions stated above, and you
    may publicly display copies.

*** 3. COPYING IN QUANTITY

    If you publish printed copies (or copies in media that commonly have
    printed covers) of the Document, numbering more than 100, and the
    Document's license notice requires Cover Texts, you must enclose the
    copies in covers that carry, clearly and legibly, all these Cover Texts:
    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
    cover.  Both covers must also clearly and legibly identify you as the
    publisher of these copies.  The front cover must present the full title
    with all words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes limited
    to the covers, as long as they preserve the title of the Document and
    satisfy these conditions, can be treated as verbatim copying in other
    respects.

    If the required texts for either cover are too voluminous to fit legibly,
    you should put the first ones listed (as many as fit reasonably) on the
    actual cover, and continue the rest onto adjacent pages.

    If you publish or distribute Opaque copies of the Document numbering more
    than 100, you must either include a machine-readable Transparent copy
    along with each Opaque copy, or state in or with each Opaque copy a
    computer-network location from which the general network-using public has
    access to download using public-standard network protocols a complete
    Transparent copy of the Document, free of added material.  If you use the
    latter option, you must take reasonably prudent steps, when you begin
    distribution of Opaque copies in quantity, to ensure that this
    Transparent copy will remain thus accessible at the stated location until
    at least one year after the last time you distribute an Opaque copy
    (directly or through your agents or retailers) of that edition to the
    public.

    It is requested, but not required, that you contact the authors of the
    Document well before redistributing any large number of copies, to give
    them a chance to provide you with an updated version of the Document.

*** 4. MODIFICATIONS

    You may copy and distribute a Modified Version of the Document under the
    conditions of sections 2 and 3 above, provided that you release the
    Modified Version under precisely this License, with the Modified Version
    filling the role of the Document, thus licensing distribution and
    modification of the Modified Version to whoever possesses a copy of it.
    In addition, you must do these things in the Modified Version:

    A. Use in the Title Page (and on the covers, if any) a title distinct
       from that of the Document, and from those of previous versions
       (which should, if there were any, be listed in the History section
       of the Document).  You may use the same title as a previous version
       if the original publisher of that version gives permission.

    B. List on the Title Page, as authors, one or more persons or entities
       responsible for authorship of the modifications in the Modified
       Version, together with at least five of the principal authors of the
       Document (all of its principal authors, if it has fewer than five),
       unless they release you from this requirement.

    C. State on the Title page the name of the publisher of the
       Modified Version, as the publisher.

    D. Preserve all the copyright notices of the Document.

    E. Add an appropriate copyright notice for your modifications
       adjacent to the other copyright notices.

    F. Include, immediately after the copyright notices, a license notice
       giving the public permission to use the Modified Version under the
       terms of this License, in the form shown in the Addendum below.

    G. Preserve in that license notice the full lists of Invariant Sections
       and required Cover Texts given in the Document's license notice.

    H. Include an unaltered copy of this License.

    I. Preserve the section Entitled "History", Preserve its Title, and add
       to it an item stating at least the title, year, new authors, and
       publisher of the Modified Version as given on the Title Page.  If
       there is no section Entitled "History" in the Document, create one
       stating the title, year, authors, and publisher of the Document as
       given on its Title Page, then add an item describing the Modified
       Version as stated in the previous sentence.

    J. Preserve the network location, if any, given in the Document for
       public access to a Transparent copy of the Document, and likewise
       the network locations given in the Document for previous versions
       it was based on.  These may be placed in the "History" section.
       You may omit a network location for a work that was published at
       least four years before the Document itself, or if the original
       publisher of the version it refers to gives permission.

    K. For any section Entitled "Acknowledgements" or "Dedications",
       Preserve the Title of the section, and preserve in the section all
       the substance and tone of each of the contributor acknowledgements
       and/or dedications given therein.

    L. Preserve all the Invariant Sections of the Document,
       unaltered in their text and in their titles.  Section numbers
       or the equivalent are not considered part of the section titles.

    M. Delete any section Entitled "Endorsements".  Such a section
       may not be included in the Modified Version.

    N. Do not retitle any existing section to be Entitled "Endorsements"
       or to conflict in title with any Invariant Section.

    O. Preserve any Warranty Disclaimers.


    If the Modified Version includes new front-matter sections or appendices
    that qualify as Secondary Sections and contain no material copied from
    the Document, you may at your option designate some or all of these
    sections as invariant.  To do this, add their titles to the list of
    Invariant Sections in the Modified Version's license notice.  These
    titles must be distinct from any other section titles.

    You may add a section Entitled "Endorsements", provided it contains
    nothing but endorsements of your Modified Version by various parties--for
    example, statements of peer review or that the text has been approved by
    an organization as the authoritative definition of a standard.

    You may add a passage of up to five words as a Front-Cover Text, and a
    passage of up to 25 words as a Back-Cover Text, to the end of the list of
    Cover Texts in the Modified Version.  Only one passage of Front-Cover
    Text and one of Back-Cover Text may be added by (or through arrangements
    made by) any one entity.  If the Document already includes a cover text
    for the same cover, previously added by you or by arrangement made by the
    same entity you are acting on behalf of, you may not add another; but you
    may replace the old one, on explicit permission from the previous
    publisher that added the old one.

    The author(s) and publisher(s) of the Document do not by this License
    give permission to use their names for publicity for or to assert or
    imply endorsement of any Modified Version.

*** 5. COMBINING DOCUMENTS

    You may combine the Document with other documents released under this
    License, under the terms defined in section 4 above for modified
    versions, provided that you include in the combination all of the
    Invariant Sections of all of the original documents, unmodified, and list
    them all as Invariant Sections of your combined work in its license
    notice, and that you preserve all their Warranty Disclaimers.

    The combined work need only contain one copy of this License, and
    multiple identical Invariant Sections may be replaced with a single copy.
    If there are multiple Invariant Sections with the same name but different
    contents, make the title of each such section unique by adding at the end
    of it, in parentheses, the name of the original author or publisher of
    that section if known, or else a unique number.  Make the same adjustment
    to the section titles in the list of Invariant Sections in the license
    notice of the combined work.

    In the combination, you must combine any sections Entitled "History" in
    the various original documents, forming one section Entitled "History";
    likewise combine any sections Entitled "Acknowledgements", and any
    sections Entitled "Dedications".  You must delete all sections Entitled
    "Endorsements".

*** 6. COLLECTIONS OF DOCUMENTS

    You may make a collection consisting of the Document and other documents
    released under this License, and replace the individual copies of this
    License in the various documents with a single copy that is included in
    the collection, provided that you follow the rules of this License for
    verbatim copying of each of the documents in all other respects.

    You may extract a single document from such a collection, and distribute
    it individually under this License, provided you insert a copy of this
    License into the extracted document, and follow this License in all other
    respects regarding verbatim copying of that document.

*** 7. AGGREGATION WITH INDEPENDENT WORKS

    A compilation of the Document or its derivatives with other separate and
    independent documents or works, in or on a volume of a storage or
    distribution medium, is called an "aggregate" if the copyright resulting
    from the compilation is not used to limit the legal rights of the
    compilation's users beyond what the individual works permit.  When the
    Document is included in an aggregate, this License does not apply to the
    other works in the aggregate which are not themselves derivative works of
    the Document.

    If the Cover Text requirement of section 3 is applicable to these copies
    of the Document, then if the Document is less than one half of the entire
    aggregate, the Document's Cover Texts may be placed on covers that
    bracket the Document within the aggregate, or the electronic equivalent
    of covers if the Document is in electronic form.  Otherwise they must
    appear on printed covers that bracket the whole aggregate.

*** 8. TRANSLATION

    Translation is considered a kind of modification, so you may distribute
    translations of the Document under the terms of section 4.  Replacing
    Invariant Sections with translations requires special permission from
    their copyright holders, but you may include translations of some or all
    Invariant Sections in addition to the original versions of these
    Invariant Sections.  You may include a translation of this License, and
    all the license notices in the Document, and any Warranty Disclaimers,
    provided that you also include the original English version of this
    License and the original versions of those notices and disclaimers.  In
    case of a disagreement between the translation and the original version
    of this License or a notice or disclaimer, the original version will
    prevail.

    If a section in the Document is Entitled "Acknowledgements",
    "Dedications", or "History", the requirement (section 4) to Preserve its
    Title (section 1) will typically require changing the actual title.

*** 9. TERMINATION

    You may not copy, modify, sublicense, or distribute the Document except
    as expressly provided under this License.  Any attempt otherwise to copy,
    modify, sublicense, or distribute it is void, and will automatically
    terminate your rights under this License.

    However, if you cease all violation of this License, then your license
    from a particular copyright holder is reinstated (a) provisionally,
    unless and until the copyright holder explicitly and finally terminates
    your license, and (b) permanently, if the copyright holder fails to
    notify you of the violation by some reasonable means prior to 60 days
    after the cessation.

    Moreover, your license from a particular copyright holder is reinstated
    permanently if the copyright holder notifies you of the violation by some
    reasonable means, this is the first time you have received notice of
    violation of this License (for any work) from that copyright holder, and
    you cure the violation prior to 30 days after your receipt of the notice.

    Termination of your rights under this section does not terminate the
    licenses of parties who have received copies or rights from you under
    this License.  If your rights have been terminated and not permanently
    reinstated, receipt of a copy of some or all of the same material does
    not give you any rights to use it.

*** 10. FUTURE REVISIONS OF THIS LICENSE

    The Free Software Foundation may publish new, revised versions of the GNU
    Free Documentation License from time to time.  Such new versions will be
    similar in spirit to the present version, but may differ in detail to
    address new problems or concerns.  See http://www.gnu.org/copyleft/.

    Each version of the License is given a distinguishing version number.  If
    the Document specifies that a particular numbered version of this License
    "or any later version" applies to it, you have the option of following
    the terms and conditions either of that specified version or of any later
    version that has been published (not as a draft) by the Free Software
    Foundation.  If the Document does not specify a version number of this
    License, you may choose any version ever published (not as a draft) by
    the Free Software Foundation.  If the Document specifies that a proxy can
    decide which future versions of this License can be used, that proxy's
    public statement of acceptance of a version permanently authorizes you to
    choose that version for the Document.

*** 11. RELICENSING

    "Massive Multiauthor Collaboration Site" (or "MMC Site") means any World
    Wide Web server that publishes copyrightable works and also provides
    prominent facilities for anybody to edit those works.  A public wiki that
    anybody can edit is an example of such a server.  A "Massive Multiauthor
    Collaboration" (or "MMC") contained in the site means any set of
    copyrightable works thus published on the MMC site.

    "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license
    published by Creative Commons Corporation, a not-for-profit corporation
    with a principal place of business in San Francisco, California, as well
    as future copyleft versions of that license published by that same
    organization.

    "Incorporate" means to publish or republish a Document, in whole or in
    part, as part of another Document.

    An MMC is "eligible for relicensing" if it is licensed under this
    License, and if all works that were first published under this License
    somewhere other than this MMC, and subsequently incorporated in whole or
    in part into the MMC, (1) had no cover texts or invariant sections, and
    (2) were thus incorporated prior to November 1, 2008.

    The operator of an MMC Site may republish an MMC contained in the site
    under CC-BY-SA on the same site at any time before August 1, 2009,
    provided the MMC is eligible for relicensing.


** ADDENDUM: How to use this License for your documents

   To use this License in a document you have written, include a copy of the
   License in the document and put the following copyright and license
   notices just after the title page:

   @pre
       Copyright (c)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
       A copy of the license is included in the section entitled "GNU
       Free Documentation License".
   @end pre

   If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
   replace the "with...Texts." line with this:

   @pre
       with the Invariant Sections being LIST THEIR TITLES, with the
       Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
   @end pre

   If you have Invariant Sections without Cover Texts, or some other
   combination of the three, merge those two alternatives to suit the
   situation.

   If your document contains nontrivial examples of program code, we
   recommend releasing these examples in parallel under your choice of
   free software license, such as the GNU General Public License,
   to permit their use in free software.

** Acerca del Autor

   Robert J. Chassell ha trabajado con GNU Emacs desde 1985. Él
   escribe, edita y enseña Emacs y Emacs Lisp, y habla alrededor del
   mundo acerca de la libertad del software. Chassell es Director
   fundador y Tesorero de la Fundación por el Software Libre (FSF). Él
   se graduó la Universidad de Cambridge, en Inglaterra. Él tiene un
   interés contínuo en historia económica y social y vuela su
   propio aeroplano

* footnotes

  - @N{1} -: Los apóstrofes simples o las marcas de citas son una
    abreviación para la función @c{quote}; no se necesita pensar
    acerca de funciones ahora; las funciones se definen en @l{Generar
    un mensaje de error}.

  - @N{2} -: Es curioso trazar la ruta por la que la palabra
    ‘argumento’ viene para tener dos significados diferentes, uno en
    matemáticas y el otro en el inglés de cada día. De acuerdo al
    @e{Oxford English Dictionary}, la palabra deriva del Latín para
    @'{clarificar}, de este modo significa, por un hilo de derivación,
    viene a significar ‘asertir de una manera contra otro que puede
    crear un contador de aserciones’, que lidera el significado de la
    palabra como una disputa. (Nótese aquí que la palabra Inglés tiene
    dos definiciones diferentes adjuntas al mismo tiempo. En
    contraste, en Emacs Lisp, un símbolo no puede tener dos
    definiciones de funciones diferentes al mismo tiempo.)

  - @N{3} -: Actualmente, puede usar @c{%s} para imprimir un
    número. Eso es no específico. @c{%d} imprime solo la parte de un
    número a la izquierda de un punto decimal, y no cualquier cosa que
    no es un número.

  - @N{4} -: Actualmente, por defecto, si el búffer desde el que tu has
    cambiado es visible para tí en otra ventana, @c{other-buffer} elegirá el
    búffer más reciente que no puedes ver; esto es algo pequeño que he
    olvidado.

  - @N{5} -: O incluso, para cambiar, solo se necesita pulsar @k{RET} si el
    buffer por defecto era @f{*scratch*}, o si era diferente, entonces se
    puede escribir solo parte del nombre, tal como @c{*sc}, luego presiona la
    tecla @k{TAB} para causar expandir al nombre completo, y entonces escribe
    la tecla @k{RET}

  - @N{6} -: Recuerda, esta expresión te permite cambiar a tus búffers más
    recientes y otros buffers que no puedes ver. Si realmente quieres ir a
    tus búffers seleccionados más recientemente, se necesita evaluar la
    siguiente expresión más compleja:

    @smallexample
      (switch-to-buffer (other-buffer (current-buffer)))
    @end smallexample

    En este caso, el primer argumento a @c{other-buffer} cuenta de que búffer
    salir––el actual––y el segundo argumento cuenta al @c{other-buffer} es OK
    para cambiar a un búffer visible. En uso regular, @c{switch-to-buffer}
    toma a una ventana invisible desde usarías @k{C-x o} (@c{other-window})
    para ir a otro búffer visible}.

  - @N{7} -: De acuerdo a Jared Diamond en @e{Guns, Germs, y Steel}, “… las
    cebras llegan a ser muy peligrosas a medida que crecen” pero el clamor
    aquí son que ellos no llegan a ser fieros como un tigre. (1997,
    W. W. Norton and Co., ISBN 0-393-03894-2, page 171)

  - @N{8} -: Actualmente, se puede @c{cons} un elemento para un átomo para
    producir a para punteado. Los pares punteados no se discuten aquí; ver
    Seccion "Notación de Para Punteado" en @e(El Manual de Referencia de GNU
    Emacs Lisp).

  - @N{9} -: Más precisamente, y requiriendo conocimiento más experto para
    comprender, los dos enteros son del tipo ‘Lisp_Object’, que puede también
    ser una unión C en vez de un tipo de entero.

  - @N{10} -: Se pueden escribir funciones recursivas para ser frugal o
    basura mental o recursos de ordenador; como eso ocurre, los métodos que
    la gente encuentra fáciles––son frugales de ‘recursos mentales’ ---
    algunas veces usan recursos de ordenador considerables. Emacs fué
    diseñado para ejecutarse en máquinas que ahora se consideran limitadas y
    sus configuraciones por defecto son conservadoras. Se puede querer
    incrementar los valores de @c{max-specdl-size} y
    @c{max-lisp-eval-depth}. En mi fichero @f{.emacs}, yo los asigno a 15 o
    30 veces su valor por defecto.

  - @N{11} -: La frase @:{cola recursiva} es usado para describir tal
    proceso, uno que usa ‘espacio constante’.

  - @N{12} -: La jerga es medianamente confusa: @c{triangle-recursive-helper}
    usa un proceso que es iterativo en un procedimiento que es recursivo. El
    proceso se llama iterativo porque el ordenador necesita solo grabar los
    tres valores, @c{suma}, @c{contador}, y @c{número}: el procedimiento es
    recursivo porque la función ‘llama a sí mismo’. Por otro lado, ambos el
    proceso y el procedimiento usado por @c{triangle-recursively} son
    llamados recursivos. La palabra ‘recursivo’ tiene diferentes significados
    en los dos contextos.

  - @N{13} -: Tu puedes también añadir @f{.el} para @f{~/.emacs} y llama a un
    fichero @f{~/.emacs}. En el pasado, fué prohibido escribir los atajos de
    teclado extra que el nombre @f{~/.emacs.el} requiere, pero ahora
    puedes. El nuevo formato es consistente con las conveniciones de nombre
    del fichero Emacs Lisp; el viejo formato guarda la escritura.

  - @N{14} -: Cuando se empiezan las instancias de Emacs que no cargan mi
    fichero @f{.emacs} o cualquier fichero, también se puede deshabilitar la
    ocultación: @smallexample emacs -q --no-site-file -eval
    '(blink-cursor-mode nil)' @exdent O ahora, usando un conjunto más
    sofisticado de opciones, emacs -Q - D @end smallexample

  - @N{15} -: también se ejecutan gestores de ventanas más modernos, tales
    como Enlightenment, Gnome, o KDE; en estos casos, con frecuencia se
    especifica una imagen en vez de un color plano.
