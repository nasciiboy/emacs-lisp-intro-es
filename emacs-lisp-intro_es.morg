..title      > Una introducción a la programación en Emacs Lisp
..subtitle   > Revisada la tercera edición
..author     > Robert J. Chassell
..translator > David Arroyo Menéndez
..translator > nasciiboy
..lang       > es
..style      > worg-data/worg.css
..options    > fancyCode toc

@ ‘’ ^[^#^j].+^j @[^[<({]+[[<({][^]>})]+[]>})]

Esto es una @e{Introducción a la Programación en Emacs Lisp}, para personas que
no son programadoras.

Traducido desde la edición 3.10

Copyright ® 1990–1995, 1997, 2001–2013 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; there being no Invariant
Section, with the Front-Cover Texts being “A GNU Manual”, and with the
Back-Cover Texts as in (a) below. A copy of the license is included in the
section entitled “GNU Free Documentation License”.

(a) The FSF's Back-Cover Text is: “You have the freedom to copy and modify
this GNU manual. Buying copies from the FSF supports it in developing GNU
and promoting software freedom.”

* Prefacio

  La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje de
  programación llamado Emacs Lisp. El código escrito en este lenguaje de
  programación es el software––el conjunto de instrucciones––que le indican al
  ordenador qué hacer cuando se le dan comandos. Emacs está diseñado de forma
  que se puede escribir nuevo código en Emacs Lisp e instalarlo fácilmente como
  una extensión al editor.

  (GNU Emacs se define muchas veces como un “editor extensible”, pero hace
  mucho más que proporcionar capacidad de edición. Es mejor referirse a Emacs
  como un “entorno de computación extensible”. Sin embargo, esta frase es un
  poco pretenciosa. Es más fácil referirse a Emacs simplemente como un
  editor. De hecho, cada cosa que se hace en Emacs––encontrar la fecha Maya y
  fases de la luna, simplificar polinomios, depurar código, administrar
  ficheros, leer cartas, escribir libros––todas estas actividades son maneras
  de editar en un sentido amplio de la palabra.)

  Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un lenguaje de
  programación completo. Se puede usar Emacs Lisp del mismo modo que con
  cualquier otro lenguaje de programación.

  Quizás quiera comprender la programación; quizás quiera extender Emacs; o
  quizás quiera llegar a ser un programador. Esta introducción a Emacs Lisp está
  diseñada para que empieces: para guiarte en el aprendizaje de los fundamentos
  de la programación y, lo que es más importante, para mostrarte como puedes
  aprender a ir mas más allá.

** Sobre la lectura de este texto

   A lo largo de este documento, verá pequeños programas de ejemplo que se
   pueden ejecutar dentro de Emacs. Si se lee este documento dentro de GNU
   Emacs, puede ejecutar los programas tal y como aparecen. (Esto es fácil de
   hacer y se explica cuando se presentan los ejemplos). Alternativamente, puede
   leer esta introducción como un libro impreso mientras se está sentando con un
   ordenador ejecutando Emacs. (Esto es lo que me gusta hacer; me gustan los
   libros impresos.) Si usted no se está ejecutando Emacs, todavía se puede leer
   este libro, pero en este caso, lo mejor es tratarlo como una novela, o como
   una guía de viaje a un país que aún no visitado: interesante, pero no es lo
   mismo que estar allí.

   Gran parte de esta introducción se dedica a paseos guiados de código usado en
   GNU Emacs. Estos paseos están diseñados para dos propósitos: primero,
   familiarizarse con código real que funciona (código que se usa cada día); y,
   segundo, familiarizarse con cómo funciona Emacs. Es interesante ver cómo se
   implementa un entorno completamente operativo. También, espero que aprenda el
   hábito de navegar a través del código fuente. Puedes aprender mucho
   comparando código de otros con el propio y extraer nuevas ideas. Tener GNU
   Emacs es como tener la cueva del dragón de los tesoros.

   Además de aprender sobre Emacs como editor y Emacs Lisp como lenguaje de
   programación, los ejemplos y visitas guiadas le darán una oportunidad para
   familiarizarse con Emacs como un entorno de programación Lisp. GNU Emacs
   soporta programación y provee herramientas que llegara a sentirse comodo
   usando, como @k{M-.} (el atajo que invoca el comando @c{find-tag}). También
   aprendera sobre búfers y otros objetos que forman parte del entorno.
   Aprender estas funcionalidades de Emacs es como aprender nuevas rutas
   alrededor de tu ciudad natal.

   Finalmente, espero poder transmitir algunas habilidades para utilizar
   Emacs para aprender aspectos de programación que no conoces. Con
   frecuencia se puede usar Emacs para ayudarte a entender un rompecabezas o
   para encontrar la manera de hacer algo nuevo. Este auto-descubrimiento no
   es solo un placer, también es una ventaja.

** Para quien está escrito esto

   Este texto está escrito como una introducción elemental para personas que no
   son programadoras. Si usted es un programador, es posible que no este
   satisfecho con este manual. La razón es que un programador puede tener que
   convertirse en experto leyendo manuales de referencia y este texto no está
   organizado como un manual de referencia.

   Un programador experto que revisó este texto me dijo:

   ..quote >
     Prefiero aprender desde manuales de referencia. Me “zambullo” en cada
     párrafo y “subo a tomar aire” entre párrafos.

     Cuando llego al fin de un párrafo, asumo que este asunto está hecho,
     terminado, que sé todo lo que necesito (con la posible excepción del caso
     cuando el siguiente párrafo empiece a hablar de el con más detalle). Espero
     que un manual de referencia bien escrito no tenga mucha redundancia, y que
     tenga excelentes indicadores del (unico) lugar donde está la información
     que quiero.
   < quote..

   ¡Esta introducción no está escrita para esta persona!

   En primer lugar, intento decir cada cosa al menos tres veces: primero, para
   introducirlo; segundo, para mostrarlo en contexto; y tercero, para mostrarlo
   en un contexto diferente, o para revisarlo.

   En segundo lugar, casi nunca pongo toda la información sobre un tema en un
   solo lugar, y mucho menos en un párrafo. A mi manera de pensar, eso impone
   una carga bastante pesada al lector. En vez de eso intento explicarte solo lo
   que se necesitas saber en ese momento. (Algunas veces incluyo una pequeña
   información extra, para que no haya sorpresas más tarde cuando la información
   adicional sea introducida formalmente.)

   Cuando usted lee este texto, no espera aprender todo la primera vez.
   Frecuentemente, solo necesita hacer, por asi decirlo, un ‘reconocimiento’ con
   alguno de los articulos mencionados. Mi esperanza es haber estructurado el
   texto y dar suficientes pistas para indicar lo que es importante y
   concentrarse en ello.

   Necesitaras “sumergirte” en algunos párrafos; no hay otro modo de
   leerlos. Pero he intentado reducir el número de esos párrafos. Este libro
   pretende ser como una colina accesible, mas que una montaña abrumadora.

   Esta introducción a @e{Programación en Emacs Lisp} viene acompañada de un
   documento complementario. @e{El Manual de Referencia de GNU Emacs Lisp}. El
   manual de referencia tiene más detalles que esta introducción. En el manual
   de referencia, toda la información sobre un asunto está concentrada en un
   solo lugar. Usted debe recurrir a ella si es como el programador citado
   anteriormente. Y, por supuesto, después de haber leido esta @e{Introducción},
   encontrara el @e{Manual de Referencia} util cuando este escribiendo sus
   propios programas.

** Historia de Lisp

   Lisp fué originariamente desarrollado a finales de los años 50 en el
   Instituto Tecnológico de Massachusetts para la investigacion en inteligencia
   artificial. El gran poder del lenguaje Lisp lo hace superior para otros
   propósitos también, como la escritura de comandos de edición y entornos
   integrados.

   GNU Emacs Lisp está fuertemente inspirado en Maclisp, que fue escrito en el
   MIT en la decada de 1960. Está en cierto modo inspirado en Common Lisp, que
   se convirtio en un estándar en los 80. Sin embargo, Emacs Lisp es mucho más
   simple que Common Lisp. (La distribución estándar de Emacs contiene un
   fichero de extensiones opcional, @f{cl.el}, que añade muchas caracteristicas
   de Common Lisp a Emacs Lisp.)

** Nota para principiantes

   Si usted no conoce GNU Emacs, todavia puede leer este documento
   provechosamente. Sin embargo, te recomiendo que aprendas Emacs, al menos
   aprender a moverse alrededor de la pantalla del ordenador. Uno puede aprender
   de manera autodidacta cómo usar Emacs con el tutorial incluido. Para usarlo,
   escriba @k{C-h t}. (Esto significa que debe presionar la tecla @k{CTRL}
   y la @k{h} al mismo tiempo, y luego presionar y soltar @k{t}).

   Con frecuencia, también me refiero a uno de los comandos estándar de Emacs
   listando las teclas que se presionan para invocar el comando y, luego doi el
   nombre del comando entre paréntesis, de la siguiente manera: @k{M-C-\}
   (@c{indent-region}). Esto significa invocar el comando @c{indent-region}
   presionando @k{M-C-\}. (Puede, Si lo desea, cambiar las teclas que se
   presionan para invocar el comando; esto se denomina @:{rebinding}. Véa la
   Sección @l{#Mapas de teclado}.)  La abreviatura @k{M-C-\} significa que usted
   presiona la tecla @k{META}, @k{CTRL}, y @k{\} todo al mismo tiempo. (En
   muchos teclados modernos la tecla @k{META} es etiquetada con @k{ALT}.)
   Algunas veces una combinación como esta se llama @e{keychord}, puesto que es
   similar a tocar un acorde en un piano. Si el teclado no tiene una tecla
   @k{META}, en su lugar se usa la tecla @k{ESC} como prefijo. En este caso
   @k{M-C-\} significa que se presiona y libera @k{ESC} y luego presiona la
   tecla @k{CTRL} y la tecla @k{\} al mismo tiempo. Pero normalmente @k{M-C-\}
   significa presionar la tecla @k{CTRL} junto a la tecla que está marcada como
   @k{ALT} y, al mismo tiempo, presionar la tecla @k{\}.

   Además de pulsar una sola combinación de teclas, se puede prefijar lo que se
   escribe con @k{C-u}, que es llamado el ‘argumento universal’. El atajo
   @k{C-u} pasa a ser un argumento para el comando subsiguiente. Asi, para
   indentar una región de texto plano a 6 espacios, se marca la región, y
   entonces presione @k{C-u 6 M-C-\}. (Si no se especifica un número, Emacs pasa
   el número 4 al comando o ejecuta el comando de forma diferente). Véa la
   Sección @l{info:emacs#Arguments<>Argumentos Numéricos} en @e{El Manual de GNU
   Emacs}.

   Si se está leyendo esto en Info usando GNU Emacs, puedes avanzar a través de
   todo este documento presionando la barra de espacio, @k{SPC}. (Para
   aprender acerca de Info, presiona @k{C-h i} y luego selecciona Info.)

   Una nota sobre terminología: cuando uso la palabra Lisp sola, con frecuencia
   me estoy refiriendo a los diversos dialectos de Lisp en general, pero cuando
   hablo de Emacs Lisp, me estoy refiriendo a GNU Emacs Lisp en particular.

** Agradecimientos

   Estoy agradecido a todos los que me ayudaron con este libro. Mi
   agradecimiento especial a Jim Blandy, Noah Friedman, Jim Kingdon, Roland
   McGrath, Frank Ritter, Randy Smith, Richard M. Stallman, y Melissa
   Weisshaus. Gracias también a Philip Johnson y David Stampe por su ánimo
   paciente. Mis errores son míos.

   ..right >
     Robert J. Chassell @l{mailto:bob@@gnu.org}

* Procesamiento de listas

  Para el ojo inexperto, Lisp es un lenguaje de programación extraño. En
  código Lisp hay paréntesis por todas partes. Algunas personas incluso
  afirman que el nombre signfica ‘Lots of Isolated Silly Parentheses’
  (‘Montones de Paréntesis Aislados Estúpidos’). Pero la protesta no tiene
  fundamento. Lisp significa LISt Processing, y el lenguaje de
  programación maneja @e{listas} (y listas de listas) poniéndolas entre
  paréntesis. Los paréntesis marcan los límites de la lista. Algunas veces
  una lista va precedida por un apóstrofe simple o una marca de cita,
  @'{'}@n{1} Las listas son el fundamento de Lisp.

** Listas Lisp

   En Lisp, una lista tiene el siguiente aspecto: @c{'(rosa violeta margarita tulipan)}.
   Esta lista es precedida por una comilla. Bien, podría estar escrita de la
   siguiende manera, que se parece mas al tipo de lista con la que se está
   familiarizado:

   ..src > elisp
     '(rosa
       violeta
       margarita
       tulipan)
   < src..

   Los elementos de esta lista son los nombres de 4 flores diferentes,
   separados por espacios en blanco y rodeados de paréntesis, como flores en
   un campo con un muro de piedras alrededor de ellas.

   Las listas pueden también tener números dentro, como en esta lista: @c{(+
   2 2)}. Esta lista tiene un signo más, @'{+}, seguido por dos @'{2}, cada
   uno separado por espacios en blanco.

   En Lisp, tanto datos como programas se representan de la misma manera; es
   decir, son a la vez listas de palabras, números, u otras listas, separadas
   por espacios en blanco y rodeadas de paréntesis. (Puesto que un programa son
   datos, un programa puede servir fácilmente como datos para otros; esta es un
   caracteristica muy poderosa de Lisp.)  (A proposito, estas dos marcas de
   paréntesis @e{no} son listas Lisp, porque contienen @'{;} y @'{.} como marcas
   de puntuación.)

   Aquí hay otra lista, esta vez con una lista dentro:

   ..src > elisp
     '(esta lista tiene (una lista dentro de ella))
   < src..

   Los componentes de esta lista son las palabras @'{esta}, @'{lista},
   @'{tiene}, y la lista @'{(una lista dentro de ella)}. La lista interior se
   construye con las palabras @'{una}, @'{lista}, @'{dentro}, @'{de},
   @'{ella}.

*** Átomos Lisp

    En Lisp, lo que hemos estado llamando palabras son en realidad
    @:{átomos}. Este término proviene del significado historico de la palabra
    átomo, que significa ‘indivisible’. En lo que a Lisp concierne, las palabras
    que hemos estado usando en las listas no se pueden dividir en partes mas
    pequeñas, sin perder su significado dentro del programa; lo mismo ocurre con
    números y símbolos de un caracterer como @'{+}. Por otro lado, a diferencia
    de un átomo antiguo, una lista puede dividirse en partes. Vea la seccion
    @l(#@c{car}, @c{cdr}, @c{cons}: Funciones fundamentales).

    En una lista, los átomos se separan unos de otros por espacios en blanco.
    Pueden ir pegados a un paréntesis.

    Técnicamente hablando, una lista en Lisp consiste en paréntesis que rodean
    átomos separados por espacios en blanco o alrededor de otras lista o
    alrededor de ambos átomos y otras listas. Una lista puede tener solo un
    átomo o no tener absolutamente nada en ella. Una lista con nada dentro se
    ve así: @c{()}, y se llama @:{lista vacía}. A diferencia de cualquier otra
    cosa, una lista vacía es tanto un átomo, como una lista al mismo tiempo.

    La representación impresa de átomos y listas se llaman @:{expresiones
    simbólicas} o, más concisamente, @:{expresiones-s}. La palabra @:{expresión}
    por sí misma puede referir o bien a la representación impresa, o al átomo o
    a la lista tal como se encuentra internamente en el ordenador. Con
    frecuencia, las personas usan el término @:{expresión} indiscriminadamente.
    (También, en muchos textos, la palabra @:{forma} se usa como un sinónimo de
    expresión.)

    Por cierto, los átomos que componen nuestro universo fueron nombrados asi
    cuando se pensaba que eran indivisibles; pero se ha encontrado que los
    átomos fisicos no son indivisibles. Las partes pueden dividir un átomo o
    puede fisionarse en 2 partes de igual tamaño. Los átomos físicos se
    nombraron prematuramente, antes de que su verdadera naturaleza fuese
    encontrada. En Lisp, ciertos tipos de átomos, como un array, pueden ser
    separados en partes; pero el mecanismo de hacer esto es diferente del
    mecanismo para dividir una lista. En lo que se refiere a las operaciones de
    lista, los átomos de una lista son indivisibles.

    Al igual que en el español, el significado de las letras que componen un
    átomo Lisp difieren del significado de las letras compuestas como una
    palabra. Por ejemplo, la expresión @'{ay}, es completamente diferente de las
    dos palabras @'{a}, e @'{y}.

    Hay muchos tipos de átomos en la naturaleza, pero solo unos pocos en Lisp:
    por ejemplo, los @:{números}, como 37, 511, o 1729, y los @:{símbolos}, como
    @'{+}, @'{foo}, o @'{forward-line}. Las palabras que hemos listado en los
    ejemplos anteriores son todos símbolos. En una conversacion cotidiana de
    Lisp, la palabra “átomo” no se usa con frecuencia, porque los programadores
    normalmente intentan ser más específicos acerca del tipo de átomo que están
    tratando. La programación Lisp es mayormente sobre símbolos (y algunas veces
    números) dentro de listas. (De ese modo, tres palabras rodeadas de paréntesis son
    una lista apropiada en Lisp, ya que consiste de átomos, que en este caso son
    símbolos, separados por espacios en blanco y encerrados entre paréntesis, sin
    ninguna puntuacion ajena a Lisp.)

    El texto entre comillas––incluso oraciones o párrafos––son también un átomo.
    Aquí hay un ejemplo:

    ..src > elisp
      '(esta lista incluye "texto entre comillas.")
    < src..

    En Lisp, todo el texto citado incluyendo la marca de puntuación y los
    espacios en blanco son un solo átomo. Este tipo de átomo es llamado
    @:{string} (@e(cadena), por ‘cadena de caracteres’) y es el tipo de cosa que
    se utiliza para los mensajes que un ordenador puede imprimir para que un
    humano lea. Las cadenas son un tipo de átomo diferente a los números, o
    símbolos y se utilizan de manera diferente.

*** Espacios en blanco en listas

    La cantidad de espacios en blanco en una lista no importa. Desde el punto
    de vista del lenguaje Lisp,

    ..src > elisp
      '(esta lista
         se ve asi)
    < src..

    es exactamente lo mismo que esto:

    ..src > elisp
      '(esta lista se ve asi)
    < src..

    Ambos ejemplos muestran que en Lisp es la misma lista, la lista hecha de
    los símbolos @'{esta}, @'{lista}, @'{se}, @'{ve}, y @'{asi} en ese orden.

    Los espacios en blanco adicionales y los saltos de línea están diseñados
    para crear una lista más legible para los humanos. Cuando Lisp lee la
    expresión, se deshace de los espacios en blanco extra (pero necesita tener
    al menos un espacio entre los átomos para distinguirlos.)

    Aunque parezca raro, los ejemplos que hemos visto cubren casi todas las
    listas en Lisp. Cualquier otra lista en Lisp se ve más o menos igual a uno
    de estos ejemplos, excepto que la lista puede ser más larga y compleja. En
    resumen, una lista está entre paréntesis, una cadena está entre comillas, un
    símbolo se parece a una palabra, y un número a un número. (Para ciertas
    situaciones, es pueden utilizar corchetes, puntos y otros caracteres
    especiales; sin embargo; iremos bastante lejos sin ellos.)

*** GNU Emacs te ayuda a escribir listas

    Cuando se escribe una expresión Lisp en GNU Emacs usando el modo de
    Interacción Lisp o el modo Emacs Lisp, están disponibles varios comandos
    para formatear la expresión Lisp, de modo que sea fácil de leer. Por
    ejemplo, presionando la tecla @k{TAB} automáticamente se indenta la línea
    donde se encuetra el cursor a la cantidad correcta. Un comando para indentar
    apropiadamente el código en una región está asociado a @k{M-C-\}. La
    indentación está diseñada de modo que se pueda ver qué elementos percecen a
    cada lista––los elementos de una sublista están más indentados que los
    elementos de la lista adjunta.

    Además, cuando escribes un paréntesis de cierre, Emacs mueve momentáneamente
    el cursor hacia el parentesis de apertura correspondiente, para que puedas
    ver cual es. Esto es muy útil, ya que cada lista que se escribe en Lisp debe
    tener sus paréntesis emparejados con sus paréntesis de apertura. (Vea la
    Seccion @l{info:emacs#Major Modes<>Modos Mayores} en @e{El Manual de GNU
    Emacs}, para más información sobre los modos de Emacs.)

** Ejecutar un programa

   Una lista en Lisp––cualquier lista––es un programa listo para ejecutarse. Si
   lo ejecutas (lo que la jerga Lisp llama @:{evaluar}), el ordenador hará una
   de tres cosas: nada excepto devolverte la lista misma; enviar un mensaje de
   error; o, tomar el primer símbolo en la lista como un comando para hacer
   alguna cosa. (¡Normalmente, por supuesto, es la última de estas tres cosas lo
   que realmente quieres!).

   El apóstrofe, @c{'}, que pongo delante de algunas de las listas de ejemplo en
   las secciones anteriores se llama @:{quote} (citar); cuando precede a una
   lista, le dice a Lisp que no haga nada con la lista, ademas de tomarla tal
   como está escrita. Pero si no hay una cita precediendo la lista, el primer
   elemento de la lista es especial: es un comando que el ordenador debe
   obedecer. (En Lisp, estos comandos se llaman @e{funciones}.) La lista @c[(+ 2
   2)] montrada a continuación no tiene una cita delante de ella, por lo que
   Lisp comprende que @c{+} es una instrucción para hacer alguna cosa con el
   resto de la lista: sumar los números que siguen.

   Si estás leyendo esto dentro de GNU Emacs, aquí está como puedes evaluar
   tal lista: coloca tu cursor justo después del paréntesis derecho de la
   siguiente lista y presiona @k{C-x C-e}:

   ..src > elisp
     (+ 2 2)
   < src..

   Verás que el número @c{4} aparece en el área eco. (En la jerga, lo que
   acabas de hacer es “evaluar la lista.” El área de eco es la línea en la
   parte inferior de la pantalla que muestra o hace “eco” del texto.) Ahora
   intenta lo mismo con una lista citada: posiciona el cursor
   justo después de la siguiente lista y presiona @k{C-x C-e}:

   ..src > elisp
     '(esto es una lista citada)
   < src..

   Verás aparecer @c{(esto es una lista citada)} en el área eco.

   En ambos casos, lo que estás haciendo es dar un comando al programa dentro
   de GNU Emacs llamado @:{intérprete Lisp}––dando al intérprete un comando
   para evaluar la expresión. El nombre del intérprete Lisp viene de la
   palabra para la tarea hecha por un humano que viene con el significado de
   una expresión––quien lo “interpreta”.

   También se puede evaluar un átomo que no es parte de una lista––uno que no
   está rodeado por paréntesis; de nuevo, el intérprete Lisp traduce desde la
   expresión legible humanamente al lenguaje del ordenador. Pero antes de
   discutir esto (vea la Seccion @l{#Variables}), vamos a discutir lo que el
   intérprete de Lisp hace cuando cometes un el error.

** Generar un mensaje de error

   No te preocupes si generas un mensaje de error de manera accidental, ahora
   daremos un comando al intérprete de Lisp que genara un mensaje de error.
   Esta es una accion inofensiva; y de hecho, a menudo se intenta generar
   mensajes de error de manera intencional. Una vez se comprende la jerga,
   los mensajes de error pueden ser informativos. En vez de ser llamados
   mensajes de “error”, deberían ser llamados mensajes de “ayuda”. Son como
   letreros para un viajero en un país extraño; descifrarlos puede ser duro,
   pero una vez comprendidos, pueden señalar el camino.

   El mensaje de error es generado por un depurador de codigo incorporado dentro
   de GNU Emacs. Vamos a ‘entrar al depurador’. Se sale del depurador pulsando
   @c{q}.

   Lo que vamos a hacer es evaluar una lista que no tiene cita y ni un
   comando con significado como su primer elemento. Aquí hay una lista casi
   exactamente igual a la que acabamos de usar, pero sin la cita al inicio.
   Coloque el cursor a la derecha donde esta finaliza y presione @k{C-x C-e}:

   ..src > elisp
     (esto es una lista sin cita)
   < src..

   Se abrirá una ventana @f{*Backtrace*} y se verá lo siguiente:

   ..example >
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function esto)
       (esto es una lista sin cita)
       eval((esto es una lista sin cita) nil)
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   < example..

   Tu cursor estará en esta ventana (es posible que tenga que esperar unos pocos
   segundos antes de que sea visible). Para salir del depurador y de su
   ventana, presione:

   ..example >
     q
   < example..

   Por favor, ahora presiona @kbd{q}, para que puedas comprobar que se puede
   salir del depurador. A continuacion, presiona @{C-x C-e} una vez mas para
   re-entrar.

   Basandones en lo que ya sabemos, casi podemos leer este mensaje de error.

   Lees el búfer @f{*Backtrace*} desde abajo hacia arriba; te dice lo que hizo
   Emacs. Cuando se presionaste @k{C-x C-e}, se hace una llamada interactiva al
   comando @c{eval-last-sexp}. @c{eval} es una abreviatura para ‘evaluar’ y
   @c{sexp} es una abreviatura para ‘expresión simbólica’. El comando significa
   ‘evalúa la última expresión simbólica’, que es la expresión inmediatamente
   anterior al cursor.

   Cada linea sober esta cuenta lo que el intérprete Lisp evaluo después. La
   acción más reciente está en la parte superior. El búfer se llama
   @f{*Backtrace*} ya que permite realizar un seguimiento de Emacs hacia atrás.

   En la parte superior del búfer @f{*Backtrace*}, verá la línea:

   ..example >
     Debugger entered--Lisp error: (void-function esto)
   < example..

   El intérprete Lisp intentó evaluar el primer átomo de la lista, la palabra
   @'{esto}. Esta es la acción que ha generado el mensaje de error @'{void-function
   esto}.

   El mensaje contiene las palabras @'{void-function} y @'{esto}.

   La palabra @'{function} fué mencionada antes. Es una palabra muy
   importante. Para nuestros propósitos, podemos definirla diciendo que una
   @:{función} (@e{function}) es un conjunto de instrucciones para decirle al
   ordenador que haga alguna cosa.

   Ahora podemos empezar a entender el mensaje de error: @'{void-function
   esto}. La función (es decir, la palabra @'{esto}) no tiene una definición de
   ningun conjunto de instrucciones que el ordenador pueda realizar.

   La palabra ligeramente extraña, @'{void-function}, está diseñada para cubrir
   la forma en que Emacs Lisp lo implementa, que es cuando un símbolo no tiene
   una definición de función adjunta, el sitio que contiene la instruccion esta
   ‘vacio’ (@'(void)).

   Por otro lado, ya que fuimos capaces de sumar 2 más 2 de manera exitosa,
   evaluando @c{(+ 2 2)}, se puede inferir que el símbolo @c{+} debe tener un
   conjunto de instrucciones que el ordenador ejecuta y estas instrucciones
   deben ser para sumar los números despues del @c{+}.

   Es posible evitar que Emacs entre en el depurador en casos como este. No se
   explicará cómo hacer esto aquí, pero se mencionará como se ve el resultado,
   porque puede que te encuentres con una situación similar si hay un error en
   algún código de Emacs que estes usando. En tales casos, solo verá una línea
   de mensaje de error; aparecer en el área eco con el siguente aspecto:

   ..example >
     Symbol's function definition is void: esto
   < example..

   El mensaje desaparece tan pronto se presione una tecla, aunque sólo sea para
   mover el cursor.

   Conocemos el significado de la palabra @'{Symbol}. Se refiere al primer
   átomo de la lista, la palabra @'{este}. La palabra @'{function} se refiere
   a las instrucciones que indican al ordenador que hacer. (Técnicamente, el
   símbolo le indica al ordenador donde encontrar las instrucciones, pero esta
   es una complicación que podemos ignorar por el momento.)

   El mensaje de error es comprensible: @'{La definición del símbolo
   está vacía: este}. El símbolo (que es, la palabra @'{este}) carece de
   instrucciones para que el ordenador lo lleve a cabo.

** Nombres de símbolos y definiciones de funciones

   Se puede articular otra característica de Lisp basada en lo que hemos
   discutido hasta ahora––una característica importante: un símbolo, como @c{+},
   no es en sí mismo el conjunto de instrucciones que el ordenador lleva a cabo. En
   su lugar, el símbolo se utiliza, quizás temporalmente, como una forma de
   localizar la definición o conjunto de instrucciones. Lo que vemos es el
   nombre con el cual se pueden encontrar las instrucciones. Los nombres de las
   personas funcionan de la misma manera. Por ejemplo puede referirse a mi como
   @'{Bob}; sin embargo, no soy las letras @'{B}, @'{o}, @'{b} pero soy, o fuí,
   conscientemente asociado con una forma de vida particular. El nombre no soy
   yo, pero puede ser usado para referirse a mi.

   En Lisp, un conjunto de instrucciones puede ligarse a varios nombres. Por
   ejemplo, las instrucciones para sumar números pueden ligarse al símbolo
   @c{mas} asi como a el símbolo @c{+} (y se encuentran en algunos dialectos de
   Lisp). Entre los humanos, puede referirse a @'{Robert} tan bien como @'{Bob} y
   con otras palabras también.

   Por otra parte, un símbolo solo puede estar ligado con una función a la
   vez. De lo contrario, el ordenador estaría confundido acerca de qué
   definición usar. Si este fuera el caso entre las gente, solo una persona en
   el mundo podría llamarse @'{Bob}. Sin embargo, la definición de función a la
   que el nombre hace referencia puede cambiarse fácilmente. (Vea la Sección
   @l{#Instalar una Definición de Función}.)

   Ya que Emacs Lisp es extenso, se acostumbra nombrar los símbolos de una
   manera que identifique la parte de Emacs a la que pertenece la función. En
   consecuencia, todos los nombres de funciones relacionadas con Texinfo
   comienzan con @'{texinfo-} y aquellas relacionadas con la lectura de correo
   empiezan con @'{rmail-}.

** El intérprete Lisp

   Basado en lo que hemos visto, ahora podemos empezar a entender lo que hace el
   intéprete Lisp cuando le ordenamos que evalue una lista. Primero, examina si
   hay un símbolo cita antes de la lista; si lo hay, el intérprete solo nos da
   la lista. Por otra parte, si no hay cita, el intéprete mira si el primer
   elemento de la lista tiene una definición de función. De lo contrario, el
   intérprete imprime un mensaje de error.

   Así es como funciona Lisp. Simple. Hay complicaciones añadidas a las que
   llegaremos en un minuto, pero estos son los fundamentos. Claro está, para
   escribir programas Lisp, se necesita saber como escribir definiciones de
   función y vincularlas a nombres, y como hacer esto sin confundirnos a
   nosotros mismos o al ordenador.

   Ahora, una primera complicación. Además de las listas, el intérprete Lisp
   puede evaluar un símbolo no citado y sin paréntesis en torno a el. El
   intérprete intentará determinar el valor del símbolo como una @:{variable}.
   Esta situación se descrita en el apartado de las variables. (Vea la Seccion
   @l{#Variables}.)

   La segunda complicación ocurre debido a que algunas funciones son inusuales y
   no funcionan de la manera habitual. Estas son llamadas @:{formas especiales}
   @%e(special forms). Son usadas para trabajos especiales, como definir una
   función, y no son muchas de ellas. En los siguientes capítulos, se
   presentaran varias de las formas especiales más importantes.

   La tercera y ultima complicación es la siguiente: si la función que el
   intérprete Lisp está examinando no es una forma especial, y si es parte de
   una lista, el intérprete Lisp mira si la lista tiene una lista dentro de
   ella. Si hay una lista interna, el intérprete Lisp primero calcula lo qué
   debe hacer con la lista interna, y luego trabaja en la lista externa. Si
   hay otra lista embebida dentro de la lista interna, trabaja en esta
   primero, y así. Siempre se trabaja en la lista mas interna primero. El
   interprete trabaja primero en la lista más interana, para evaluar el
   resultado de esta lista. El resultado puede ser usado por la expresión
   entre paréntesis.

   Por lo demas, el intérprete trabaja de izquierda a derecha, de una expresión
   a la siguiente.

*** Codigo Compilado

    Otro aspecto de la interpretación: el intérprete Lisp es capaz de
    interpretar dos tipos de entidades: código legible humanamente, en el que
    nos centraremos exclusivamente, y código especialmente procesado, llamado
    @:{compilado}, que no es humanamente legible. El código máquina compilado se
    ejecuta más rápido que el código humanamente legible.

    Tu puedes transformar código legible por humanos en código compilado
    ejecutando uno de los comandos de compilación como @c{byte-compile-file}.
    El código compilado se almacena normalmente en un fichero que finaliza
    con una extensión @f{.elc} en vez de una extensión @f{.el}. Verás ambos
    tipos de ficheros en el directorio @f{emacs/lisp}; los ficheros para leer
    estos tinen la extensión @f{.el}.

    Como una cuestión práctica, para hacer la mayoría de las cosas como
    personalizar o extender Emacs, no necesitas compilar codigo; y no
    comentare el asunto aquí. Vea la Seccion @l{info:emacs#Byte
    Compilation<>Código Compilado} en @e(El Manual de Referencia de GNU
    Emacs), para una descripción completa de la compilacion de código.

** Evaluación

   Cuando el intérprete Lisp trabaja en una expresión, el término para la
   actividad es llamada @:{evaluación}. Decimos que el intérprete ‘evalúa la
   expresión’. Yo he usado este término varias veces antes. La palabra proviene
   de su uso en el lenguaje cotidiano, ‘para determinar el valor o la cantidad de;
   para estimar’ segun el @e{Webster's New Collegiate Dictionary}.

   Después de evaluar una expresión, lo mas probable es que el intérprete Lisp
   @:{devuelva} el valor que el ordenador produce al ejecutar las instrucciones
   que encuentra en la definición de la función, o quizás se de por vencido con
   en esa función y produzca un mensaje de error. (El intérprete también puede
   quedarse colgado, por así decirlo, a una función diferente o puede intentar
   repetir continuamente lo que está haciendo por siempre  en lo que
   se llama un ‘bucle infinito’. Estas acciones son menos comunes; y podemos
   ignorarlas). Con mayor frecuencia, el intérprete devuelve un valor.

   Al mismo tiempo que el intérprete devuelve un valor, también puede realizar
   cualquier otra cosa, como mover un cursor o copiar un fichero; este otro tipo
   de acción se denomina @:{efecto secundario}. Acciones que los humanos
   pensamos que son importantes, como imprimir resultados, con frecuencia son,
   “efectos secundarios” del intérprete Lisp. La jerga puede sonar peculiar,
   pero resulta que es bastante fácil aprender a utilizar los efectos
   secundarios.

   En resumen, la evaluacion de una expresión simbólica normalmente causa que el
   intérprete devuelva un valor y tal vez lleve a cabo un efecto secundario; o
   al menos produca un error.

*** Evaluación de listas internas

    Si la evaluación se aplica a una lista que está dentro de otra lista, la
    lista externa puede usar el valor devuelto por la primer evaluación como
    información cuando se evalua la lista externa. Esto explica por qué las
    expresiones internas se evaluan primero: los valores devueltos son
    usados por las expresiones externas.

    Podemos investigar este proceso evaluando otro ejemplo de sumas. Coloca tu
    cursor después de la siguiente expresión y presiona @k{C-x C-e}:

    ..src > elisp
      (+ 2 (+ 3 3))
    < src..

    El número 8 aparecerá en el área de eco.

    Lo que ocurre es que el intérprete Lisp primero evalúa la expresión
    interna, @c{(+ 3 3)}, para lo cual se devuelve el valor 6; luego
    evalúa la expresión externa como si fuera escrita @c{(+ 2 6)}, que
    devuelve el valor 8. Puesto que no hay más expresiones adjuntas a
    evaluar el intérprete imprime este valor en el área de eco.

    Ahora es fácil comprender el nombre del comando invocado por el atajo @k{C-x
    C-e}: el nombre es @c{eval-last-sexp}. Las letras @c{sexp} son una
    abreviatura para ‘expresión simbólica’, y @c{eval} es una abreviatura para
    ‘evaluar’ @%e(evaluate). El comando significa ‘evaluar la última expresión
    simbólica’.

    Como un experimento, puedes intentar evaluar la expresión poniendo el
    cursor al principio de la siguiente línea inmediatamente después de la
    expresión, o dentro de la expresión.

    Aquí hay otra copia de la expresión:

    ..src > elisp
      (+ 2 (+ 3 3))
    < src..

    Si colocas el cursor al principio de la línea en blanco que sigue
    inmediatamente a la expresión y presionas @k{C-x C-e}, aún se obtendrá el
    valor 8 impreso en el área eco. Ahora coloca el cursor dentro de la
    expresión. Si lo pones justo después del penúltimo paréntesis (de modo que
    parezca estar sobre el último paréntesis), ¡obtendrá un 6 impreso en el área
    de eco! Esto es porque el comando evalúa la expresión @c{(+ 3 3)}.

    Ahora coloca el cursor inmediatamente después de un número. Presiona @k{C-x
    C-e} y obtendras el número en sí. En Lisp, si evalúas un número, obtienes el
    número en sí––así es cómo los números difieren de los símbolos. Si se evalúa
    una lista que inicia con un símbolo como @c{+}, se optiene un valor devuelto
    que es el resultado del ordenador tras ejecutar las instrucciones que
    aparecen en la definición de la función ligada a ese nombre. Si se evalua un
    símbolo por sí mismo, sucede algo diferente, como veremos en la siguiente
    sección.

** Variables

   En Emacs Lisp, un símbolo puede estar ligado a un valor como a una definición
   de función. Las dos son diferentes. La definición de función es un conjunto
   de instrucciones que el ordenador ejecuta. Por otro lado, un valor, es algo,
   como un número o un nombre, que puede variar (es por ello, que tal símbolo se
   llama variable). El valor de un símbolo puede ser cualquier expresión en
   Lisp, por ejemplo un símbolo, número, lista, o cadena. Un símbolo que tiene
   un valor con frecuencia se llama @:{variable}.

   Un símbolo puede tanto una definición de función como un valor asociado a el
   al mismo tiempo. O puede tener solo uno u otro. Los dos son independientes.
   Esto es algo similar a la forma en que el nombre Cambridge puede referirse a
   la ciudad en Massachusetts y tener alguna información ligada al nombre, por
   ejemplo, un “gran centro de programación”.

   Otra forma de pensar en esto es imaginar un símbolo como un mueble con
   cajones. La definición de función se pone en un cajón, el valor en otro, y
   asi sucesivamente. Lo que se pone en el cajón que contiene el valor se puede
   cambiar sin afectar los contenidos del cajón que almacena la definición de
   función, y viceversa.

   La variable @c{fill-column} ilustra un símbolo con un valor adjunto: en
   cada buffer de GNU Emacs, este símbolo se establece en algún valor,
   normalmente 72 o 70, pero algunas veces en algún otro valor. Para encontrar
   el valor de este símbolo, evalúalo por sí mismo. Si estás leyendo esto
   dentro de GNU Emacs, puedes hacerlo poniendo el cursor después del
   símbolo y pulsar @k{C-x C-e}:

   ..src > elisp
     fill-column
   < src..

   Después de presionar @k{C-x C-e}, Emacs imprimió el número 72 en mi área de
   eco. Este es el valor que he establecido para @c{fill-column} mientras
   escribo esto. Puede ser diferente en tu búfer. Observa que el valor devuelto
   como una variable se imprime exactamente de la misma forma que el valor
   devuelto por una función tras ejecutar sus instrucciones. Desde el punto de
   vista del intérprete Lisp, un valor devuelto es un valor devuelto. La clase
   de expresion de la que proviene deja de importar una vez que se conoce el
   valor.

   Un símbolo puede tener cualquier valor ligado a él o, siendo tecnicos, se
   puede @:{enlazar} la variable a un valor: a un número, por ejemplo 72; a una
   cadena, @c{"como esta"}; a una lista, como @c{(abeto pino roble)}; podemos
   incluso asociar una variable a una definición de función.

   Un símbolo puede vincularse a un valor de varias maneras. Vea la Sección
   @l{#Configurando el valor de una variable}, para obtener información sobre
   como hacerlo.

*** Mensaje de error de un símbolo sin una función

    Cuando evaluamos @c{fill-column} para encontrar su valor como una
    variable, no pusimos paréntesis alrededor de la palabra. Esto se debe a
    que no pretendiamos usarla como un nombre de función.

    Si @c{fill-column} fuese el primer o único elemento de una lista, el
    intérprete Lisp intentaría encontrar la definición de función adjunta.
    Pero @c{fill-column} no tiene una definición de función. Trata de evaluar
    esto:

    ..src > elisp
      (fill-column)
    < src..

    Se creará un buffer @f{*Backtrace*} que dice:

    ..example >
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (void-function fill-column)
        (fill-column)
        eval((fill-column))
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    < example..

    (Recuerda, para salir del depurador y hacer que la ventana del depurador
    desaparezca, presiona @k{q} en el buffer @f{*Backtrace*}.)

*** Mensaje de error de un símbolo sin un valor

    Si intenta evaluar un símbolo que no tiene un valor asociado, recibirá un
    mensaje de error. Esto se puede ver experimentando con nuestra suma 2
    más 2. En la siguiente expresión, pon el cursor justo después del
    @c{+}, antes del primer número 2, presiona @k{C-x C-e}:

    ..src > elisp
      (+ 2 2)
    < src..

    En GNU Emacs 22, se creará un buffer @f{*Backtrace*} que dice:

    ..example >
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (void-variable +)
        eval(+ nil)
        elisp--eval-last-sexp(nil)
        eval-last-sexp(nil)
        funcall-interactively(eval-last-sexp nil)
        call-interactively(eval-last-sexp nil nil)
        command-execute(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    < example..

    (De nuevo, puedes salir del depurador pulsando @k{q} en el búfer
    @f{*Backtrace*}.)

    Esta traza inversa es diferente del primer mensaje de error que vimos,
    que decia, @'{Debugger entered--Lisp error: (void-function esto)}. En
    este caso, la función no tiene una valor como variable; mientras en
    el otro mensaje de error, la función (la palabra ‘esto’) no tuvo una
    definición.

    En este experimento con el @c{+}, lo que hicimos fué hacer que el
    intérprete Lisp evalúe el @c{+} y busque el valor de la variable en lugar
    de la definición de la función. Hicimos esto colocando el cursor justo
    después del símbolo en lugar de ponerlo al final de los parentesis que
    cierran la lista como hicimos antes. Como consecuencia, el intérprete
    Lisp evaluó la expresión-s anterior, que en este caso fué el @c{+} en sí.

    Ya que @c{+} no tiene un valor asociado, solo la definición de función,
    el mensaje de error informaba que el valor del símbolo como una variable
    estaba vacío.

** Argumentos

   Para ver cómo la información se pasa a las funciones, veamos de nuevo
   nuestro viejo recurso, la suma de dos más dos. En Lisp, esto se escribe
   de la siguiente manera:

   ..src > elisp
     (+ 2 2)
   < src..

   Si evalúas esta expresión, el número 4 aparecerá en el área de eco. Lo que
   el intérprete de Lisp hace es sumar los números despues del @c{+}.

   Los números sumados por @c{+} se llaman @:{argumentos} de la función
   @c{+}. Estos números son la información que se da o @:{pasa} a la función.

   La palabra ‘argumento’ proviene de la forma en que se usa en
   matemáticas y no se refiere a una disputa entre 2 personas, En su lugar,
   se refiere a la información entregada a la función, en este caso, al
   @c{+}. En Lisp, los argumentos de una función son los átomos o listas que
   siguen a la función. Los valores devueltos por la evaluación de estos
   átomos o listas se transfieren a la función. Funciones diferentes requieren
   diferentes números de argumentos; algunas funciones no requieren ninguno
   en absoluto.@n{2}

*** Tipos de datos de los argumentos

    El tipo de dato que deben transmitirse a una función dependen de que tipo de
    información se utilice. Los argumentos de una función como @c{+} deben
    tener valores númericos, ya que @c{+} suma números. Otras funciones
    utilizan diferentes tipos de datos para sus argumentos.

    Por ejemplo, la función @c{concat} concatena o une dos o más cadenas de
    texto para producir una cadena. Los argumentos son cadenas. Concatenar
    las cadenas de caracteres @c{abc}, @c{def} produce una cadena @c{abcdef}.
    Esto puede verse evaluando lo siguiente:

    ..src > elisp
      (concat "abc" "def")
    < src..

    El valor producido al evaluar esta expresión es @c{"abcdef"}.

    Una función como @c{substring} utiliza una cadena y numeros como
    argumentos. La función devuelve una parte de la cadena, una subcadena del
    primer argumento. Esta función toma tres argumentos. Su primer argumento
    es la cadena de caracteres, el segundo y tercer argumento son números que
    indican el principio y el fin de la subcadena. Los números son un conteo
    del número de caracteres (incluyendo espacios y puntuaciones) desde el
    principio de la cadena.

    Por ejemplo, si evalúa lo siguiente:

    ..src > elisp
      (substring "El rápido zorro marrón saltó." 10 15)
    < src..

    Verá aparecer @c{"zorro"} en el área de eco. Los argumentos son la cadena y
    los dos números.

    Tenga en cuenta que la cadena pasada a @c{substring} es un solo átomo a
    pesar de estar compuesto de varias palabras separadas por espacios. Lisp
    considera todo entre las dos comillas como parte de la cadena, incluyendo
    los espacios. Se puede pensar en la función @c{substring} como una especie
    de ‘acelerador de particulas’ ya que toma un átomo de otro modo indivisible
    y extrae una parte. Sin embargo, @c{substring} solo es capaz de extraer una
    subcadena de un argumento que es una cadena, no de otro tipo de átomo por
    ejemplo un número o símbolo.

*** Un argumento como el valor de una variable o lista

    Un argumento puede ser un símbolo que devuelve un valor cuando se evalua.
    Por ejemplo, evaluar el símbolo @c{fill-column} en si, devuelve un
    número. Este número se puede utilizar en una suma.

    Coloca el cursor después de la siguiente expresión y presiona @k{C-x
    C-e}:

    ..src > elisp
      (+ 2 fill-column)
    < src..

    El valor será dos, mas el número que se obtiene al evaluar solamente
    @c{fill-column}. En mí caso, es 74, porque mi valor de @c{fill-column}
    es 72.

    Como acabamos de ver, un argumento puede ser un símbolo que devuelve un valor
    cuando se evalúa. Además, un argumento puede ser una lista que devuelve
    un valor cuando se evalúa. Por ejemplo, en la siguiente expresión, los
    argumentos de la función @c{concat} son las cadenas @c{"Los "} y
    @c{" zorros rojos."} y la lista @c{(number-to-string (+ 2 fill-column))}.

    ..src > elisp
      (concat "Los " (number-to-string (+ 2 fill-column)) " zorros rojos.")
    < src..

    Si evaluas esta expresión––y si, como con mi Emacs, @c{fill-column} se
    evalúa a 72––aparecerá @c{"Los 74 zorros rojos."} en el área de eco.
    (Ten en cuenta que debes poner espacios después de la palabra @'{Los} y
    antes de la palabra @'{zorros} que aparece en la cadena final. La
    función @c{number-to-string} convierte el entero que devuelve la función
    suma a una cadena. @c{number-to-string} también se conoce como
    @c{int-to-string}.)

*** Número variable de argumentos

    Algunas funciones, como @c{concat}, @c{+}, o @c{*}, toman cualquier
    número de argumentos. (@c{*} es el símbolo para la multiplicacion.)
    Esto puede verse evaluando cada una de las siguientes expresiones de la
    forma habitual.

    En el primer conjunto, las funciones no tienen argumentos:

    ..srci > elisp
      > (+)
      0
      > (*)
      1
    < srci..

    En este conjunto, las funciones tienen un argumento cada una:

    ..srci > elisp
      > (+ 3)
      3
      > (* 3)
      3
    < srci..

    En este conjunto, las funciones tienen tres argumentos cada una:

    ..srci > elisp
      > (+ 3 4 5)
      12
      > (* 3 4 5)
      60
    < srci..

*** Usando el tipo incorrecto de objeto como un argumento

    Cuando a una función se le pasa un argumento del tipo incorrecto, el
    interpréte Lisp genera un mensaje de error. Por ejemplo, la función
    @c{+} espera que los valores de sus argumentos sean números. Como un
    experimento podemos pasar el símbolo citado @c{hola} en lugar de un
    número. Coloca el cursor después de la siguiente expresión y presiona
    @k{C-x C-e}:

    ..src > elisp
      (+ 2 'hola)
    < src..

    Al hacer esto se generará un mensaje de error. Lo qué ha ocurrido es que
    @c{+} ha intentado sumar el 2 al valor devuelto por @c{'hola}, pero el
    valor devuelto por @c{'hola} es el símbolo @c{hola}, no un número. Solo
    los números se pueden sumar. Por tanto @c{+} no pudo llevar a cabo su
    suma.

    Se creará e ingresara a un búfer @f{*Backtrace*} que diga:

    ..example >
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p hola)
        +(2 hola)
        eval((+ 2 (quote hola)) nil)
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp nil nil)
        command-execute(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    < example..

    Como de costumbre, el mensaje de error intenta ser útil y tiene sentido
    después de aprender cómo leerlo.@n{3}

    La primer parte del mensaje de error es sencilla; dice @'{wrong type
    argument} (tipo de argumento incorrecto). A continuación viene la
    misteriosa jerga tecnica @'{number-or-marker-p}. Esta palabra está
    intentando decirte qué tipo de argumento espera @c{+}.

    El símbolo @c{number-or-marker-p} dice que el intérprete Lisp está
    intentando determinar si la información presentada (el valor del argumento)
    es un número o una marca (un objeto especial que representa una posición de
    buffer). Lo que hace es probar si se le estan dando numeros a sumar a
    @c{+}. También prueba si el argumento es algo llamado marcador, que es una
    caracteristica específica de Emacs Lisp. (En Emacs, las ubicaciones en un
    búfer se registran como marcadores. Cuando se establece la marca con el
    comando @k{C-@@} o @k{C-SPC}, su posición se guarda como un marcador. La
    marca se puede consider un número––el número de caracteres es la ubicacion
    desde el comienzo del búfer.)  En Emacs Lisp, @c{+} se puede utilizar para
    sumar el valor numérico de los marcadores como números.

    La @'{p} en @c{number-or-marker-p} es la encarnación de una práctica
    iniciada en los primeros días de la programación Lisp. La @'{p} significa
    ‘predicado’. En la jerga usada por los primeros investigadores de Lisp,
    un predicado se refiere a una función para determinar si alguna propiedad
    es verdadera o falsa. Entonces la @'{p} nos dice que @c{number-or-marker-p}
    es el nombre de una función que determina si el argumento dado es un
    número o una marca. Otros símbolos Lisp que finalizan en @'{p} incluyen
    @c{zerop}, una función que comprueba si su argumento tiene el valor de
    cero, y @c{listp}, una función que comprueba si su argumento es una
    lista.

    Finalmente, la última parte del mensaje de error es el símbolo @c{hola}.
    Este es el valor del argumento que se paso a @c{+}. Si a la suma se le hubiese
    pasado el tipo de objeto correcto, el valor habría sido un número, como
    37, en lugar de un símbolo como @c{hola}. Pero entonces no habrías
    obtenido el mensaje de error.

*** La función @c{message}

    Al igual que @c{+}, la función @c{message} toma un número variable de
    argumentos. Se utiliza para enviar mensajes al usuario y es tan útil que
    vamos la describiremos aqui.

    Se imprime un mensaje en el área de eco. Por ejemplo, puede imprimir un
    mensaje en su área de eco evaluando la siguiente lista:

    ..src > elisp
      (message "¡Este mensaje aparece en el área de eco!")
    < src..

    Toda la cadena entre comillas dobles es un unico argumento y se imprime
    @i{en su totalidad}. (Note que en este ejemplo, el mensaje en sí aparece
    en el área de eco entre comillas dobles; esto se debe a que ves el valor
    devuelto por la función @c{message}. En la mayoría de programas que
    escribiras, el texto se imprimira en el área de eco como un efecto
    secundario de @c{message}, sin las comillas. Vea la Sección @l{#Un
    @c{multiply-by-seven} interactivo} en detalle, para un ejemplo de esto.)

    Sin embargo, si hay un @'{%s} en la cadena de caracteres citada, la
    función @c{message} no imprime el @'{%s} como tal, si no que busca el siguente
    argumento a continuacion de la cadena. Evalúa el segundo argumento e
    imprime el valor en la ubicación de la cadena donde está el @'{%s}.

    Puede ver esto colocando el cursor después de la siguiente expresión y
    presionar @k{C-x C-e}:

    ..src > elisp
      (message "El nombre de este búfer es: %s." (buffer-name))
    < src..

    En Info, @c{"El nombre de este búfer es: *info*."} aparecerá en el área
    de eco. La función @c{buffer-name} devuelve el nombre del búfer como una
    cadena, que la función @c{message} inserta en lugar de @c{%s}.

    Para imprimir un valor como un entero, utiliza @'{%d} de la misma forma
    que @'{%s}. Por ejemplo, para imprimir un mensaje en el área de eco que
    indique el valor de @c{fill-column}, evalúa lo siguiente:

    ..src > elisp
      (message "El valor de fill-column es %d." fill-column)
    < src..

    En mi sistema, cuando evalúo esta lista, @c{"El valor de fill-column es
    72"} aparece en mi área de eco@n{4}.

    Si hay más de un @'{%s} en la cadena citada, el valor del primer
    argumento después de la cadena citada se imprime en la posición del
    primer @'{%s} y el valor del segundo argumento se imprime en la posición
    del segundo @'{%s}, y así sucesivamente.

    Por ejemplo, si evalúa lo siguiente,

    ..src > elisp
      (message "¡Hay %d %s en la oficina!"
               (- fill-column 14) "elefantes rosas")
    < src..

    Un mensaje un poco caprichoso aparecerán en el área de eco. En mi sistema
    dice @c{"¿Hay 58 elefantes rosas en la oficina!"}

    Se evalúa la expresión @c{(- fill-column 14)} y el número resultante
    se inserta en lugar del @'{%d}; y la cadena entre comillas dobles,
    @c{"elefantes rosas"}, se trata como un argumento unico y se inserta
    en lugar del @'{%s}. (Es decir, una cadena entre comillas dobles se
    evalúa así misma, como un número.)

    Por último, aquí está un ejemplo algo complejo que no solo ilustra el
    cálculo de un número, también muestra como se puede usar una expresión
    dentro de una expresión para generar el texto que sustituira el @'{%s}:

    ..src > elisp
      (message "Él vió %d %s"
               (- fill-column 36)
               (concat "rojos "
                       (substring
                        "Los rápidos zorros marrones saltaron." 12 18)
                       " saltando."))
    < src..

    En este ejemplo, @c{message} tiene tres argumentos: la cadena, @c{"Él vió
    %d %s"}, la expresión, @c{(- fill-column 32)}, y la expresion que comienza con
    la función @c{concat}. El valor resultante de la evaluación de @c{(-
    fill-column 32)} se inserta en lugar del @'{%d}; y el valor devuelto por
    la expresión que inicia con @c{concat} se inserta en lugar del @'{%s}.

    Cuando @c(fill-column) es 70 y evaluas la expresión, aparecera el
    mensaje @c{"Él vió 38 rojos zorros saltando."} en tu área de eco.

** Configurando el valor de una variable

   Hay varias formas de asignar un valor a una variable. Una de ellas es
   utilizar la función @c{set} o la función @c{setq}. Otra forma es utilizar
   @c{let} (Vea la Seccion @l{#@c(let)}). (La jerga para este proceso es @:{ligar}
   @%e(bind) una variable a un valor.)

   Las siguientes secciones no solo describen cómo operan @c{set} y @c{setq},
   también ilustran como se pasan los argumentos.

*** Usando @c{set}

    Para establecer el valor del símbolo @c{flores} a la lista @c{'(rosa
    violeta margarita tulipan)}, evalúa la siguiente expresión colocando
    el cursor después de la expresión y presiona @k{C-x C-e}.

    ..src > elisp
      (set 'flores '(rosa violeta margarita tulipan))
    < src..

    La lista @c{(rosa violeta margarita tulipan)} aparecerá en el área de
    eco. Esto es la que @e{devuelve} la función @c{set}. Como efecto secundario,
    el símbolo @c{flores} esta ligado a la lista; es decir, el símbolo
    @c{flores}, puede verse como una variable, que entrega la lista como su
    valor. (Por cierto, este proceso, ilustra como un efecto secundario al
    intérprete Lisp, estableciendo el valor, puede ser el principal efecto que
    nos interesa a los humanos. Esto se debe a que cada función Lisp debe
    devolver un valor si no obtiene un error, pero solo tendrá un efecto
    secundario si está diseñada para tener uno.)

    Después de evaluar la expresión @c{set}, se puede evaluar el símbolo
    @c{flores} y ha de devolver el valor que acaba de establecer. Aquí está
    el símbolo. Coloca el cursor al final de este y presiona @k{C-x C-e}.

    ..src > elisp
      flores
    < src..

    Al evalúar @c{flores}, aparece la lista @c{(rosa violeta margarita tulipan)}
    en el área de eco.

    Por cierto, si se evalúa @c{'flores}, la variable con una cita frente a
    ella, lo que verá en el área de eco es el símbolo en sí mismo, @c{flores}.
    Aquí está el símbolo citado, asi que puedes intentarlo:

    ..src > elisp
      'flores
    < src..

    Tenga en cuenta también, que cuando se utiliza @c{set}, es necesario
    citar ambos argumentos para @c{set}, a menos que los quiera evaluar.
    Puesto que no queremos evaluar, ni la variable @c{flores}, ni la lista
    @c{(rosa violeta margarita tulipan)}, ambos se citan. (Cuando se utiliza
    @c{set} sin citar su primer argumento, el primer argumento se evalúa
    antes de realizar cualquier otra cosa. Si hizo esto y @c{flores} no tenía
    ya un valor, otendria un mensaje de error con el @'{Valor de símbolo como
    variable esta vacío}; por otro lado, si @c{flores} regreso un valor después de
    ser evaluado, @c{set} intentaría establecer el valor que fue devuelto.
    Hay situaciones donde esto es justo lo que la función a de hacer, pero
    estas situaciones son poco frecuentes.)

*** Usando @c{setq}

    Como una cuestión práctica, casi siempre se cita el primer argumento de
    @c{set}. La combinación de @c{set} y un primer argumento citado es tan
    común que tiene nombre propio: la forma especial @c{setq}. Esta forma
    especial es similar a @c{set} excepto que el primer argumento es citado
    automáticamente, por lo que no necesita escribir la marca de cita.
    También, para mayor comodidad, @c{setq} permite asignar varias variables
    diferentes a diferentes valores, todo en una sola expresión.

    Para establecer el valor de la variable @c{carnívoros} a la lista
    @c{'(leon tigre leopardo)} usando @c{setq}, se utiliza la siguiente
    expresión:

    ..src > elisp
      (setq carnivoros '(leon tigre leopardo))
    < src..

    Esto es exactamente igual que usar @c{set} excepto que el primer
    argumento es citado automáticamente por @c{setq}. (La @'{q} en @c{setq}
    significa @c{quote} @%e(cita).)

    Con @c{set}, la expresión que se vería es:

    ..src > elisp
      (set 'carnivoros '(leon tigre leopardo))
    < src..

    Además, @c{setq} se puede utilizar para asignar diferentes valores a
    diferentes variables. El primer argumento se une al valor del segundo
    argumento, el tercer argumento se une a al valor del cuarto argumento, y
    así sucesivamente. Por ejemplo, podría utilizar lo siguiente para asignar
    una lista de árboles al símbolo @c{arboles} y una lista de herbívoros al
    símbolo @c{herbivoros}:

    ..src > elisp
      (setq arboles '(pino abeto roble arce)
            herbivoros '(gacela antilope cebra))
    < src..

    (La expresión podría también haber estado en una sola línea, pero podría
    no caber en una página; y a los humanos les resulta más fácil leer listas
    con un formato agradable.)

    Aunque he estado usando el término ‘asignar’, hay otra forma de pensar
    respecto a el funcionamiento de @c{set} y @c{setq}; y consiste en decir
    que @c{set} y @c{setq} crean un símbolo que @e{apunta} a la lista. Esta
    ultima forma de pensar es muy común y en los proximos capítulos
    encontraremos por lo menos un símbolo con un ‘puntero’ como parte de
    su nombre. El nombre se elige porque el símbolo tiene un valor,
    específicamente una lista, unida a el; o, expresado de otra manera, el
    símbolo se fija para “apuntar” a la lista.

*** Conteo

    He aquí un ejemplo que muestra cómo utilizar @c{setq} en un contador. Es
    posible usar esto para contar cuantas veces una parte de un programa se
    repite. En primer lugar establesca una variable a cero; luego
    sume uno al número cada vez que el programa se repita. Para ello, se
    necesita una variable que sirva como un contador, y dos expresiones: una
    expresión @c{setq} inicial que asigna la variable contador a cero; y una
    segunda expresión @c{setq} que incrementa el contador cada vez se evalue.

    ..src > elisp
      (setq contador 0)                ; Llamemos a esto el inicializador.

      (setq contador (+ contador 1))   ; Este es el incremento.

      contador                         ; Este es el contador.
    < src..

    (El texto que sigue al @'{;} son los comentarios. Vea la Seccion
    @l{#Cambiar una definición de función}.)

    Si evalúas la primera de estas expresiones, el inicializador, @c{(setq
    contador 0)}, y luego evalúas la tercera expresión, @c{contador}, el
    número @c{0} aparecerá en el área de eco. Si a continuación se evalúa la
    segunda expresión, el incremento, @c{(setq contador (+ contador 1))}, el
    contador tendrá el valor 1. Así que si evalúas de nuevo @c{contador}, el
    número @c{1} aparecerá en el área de eco. Cada vez que se evalúa la segunda
    expresión, el valor del contador se incrementara.

    Al evalúar el incremento, @c{(setq contador (+ contador 1))}, el intérprete
    Lisp evalúa en primer lugar la lista interna; esta es la suma. Para evaluar
    esta lista, se debe evaluar la variable @c{contador} y el número @c{1}.
    Cuando evalúa la variable @c{contador}, recibe su valor actual. Se pasa
    este valor y el número @c{1} a @c{+} que los suma. La suma se devuelve como
    el valor de la list interior y pasa a @c{setq} que establece la variable
    @c{contador} a este nuevo valor. Por lo tanto, el valor de la variable
    @c{contador}, cambia.

** Resumen

   Aprender Lisp es como subir una colina en la que la primera parte es la
   mas empinada. Ahora has subido la parte más difícil; lo que queda se
   vuelve más fácil a medida que avanzas hacia adelante.

   En resumen,

   - Los programas Lisp se componen de expresiones, que son listas o átomos
     individuales.

   - La listas se componen de cero o más átomos o listas internas, separadas
     por espacios en blanco y rodeadas por paréntesis. Una lista puede estar
     vacía.

   - Los átomos son símbolos de varios caracteres, como @c{forward-paragraph},
     símbolos de un solo caracter como @c{+}, cadenas de caracteres entre
     comillas dobles, o números.

   - Un número se evalúa a sí mismo.

   - Una cadena entre comillas dobles también se evalúa a sí misma.

   - Cuando se evalúa un símbolo a sí mismo, se devuelve su valor.

   - Cuando se evalúa una lista, el intérprete Lisp mira el primer símbolo en
     la lista y luego la definición de función asociada a ese símbolo. A
     continuación se ejecutan las instrucciones en la definición de la función.

   - Una marca de cita, @c{'}, le indica al intérprete Lisp que devuelva la
     siguiente expresión tal como esta escrita, y no la evalúa como lo haria si
     la cita no estuviera alli.

   - Los argumentos son la información que se pasa a una función. Los
     argumentos de una función se calculan evaluando el resto de los
     elementos de la lista de los cuales la función es el primer elemento.

   - Una función siempre devuelve un valor cuando se evalúa (a menos que
     obtenga un error); además, también se puede llevar a cabo alguna
     acción llamada “efecto secundario”. En muchos casos, el propósito
     principal de una función es crear un efecto secundario.

** Ejercicios

   Unos pocos ejercicios simples:

   - Generar un mensaje de error evaluando un símbolo apropiado que no este
     entre paréntesis.

   - Generar un mensaje de error evaluando un símbolo apropiado situado
     entre paréntesis.

   - Crear un contador que se incrementa en dos en lugar de uno.

   - Escribe una expresión que imprima un mensaje en el área de eco cuando se
     evalue.

* Practicando la Evaluación

  Antes de aprender como escribir una definición de función en Emacs Lisp, es
  útil pasar un poco de tiempo evaluando varias expresiones que ya han sido
  escritas. Estas expresiones serán listas con funciones como su primer (y con
  frecuencia único) elemento. Dado que algunas de las funciones asociadas con
  búfers son a la vez simples e interesantes, empezaremos por ellas. En esta
  sección, vamos a evaluar algunas. En otra sección, estudiaremos el código de
  varias otras funciones relacionadas con búfers, para ver la forma cómo fueron
  escritas.

  @i{Siempre que proporciona un comando de edición} a Emacs Lisp, como el
  comando para mover el cursor o para desplazar por la pantalla, @i{se está
  evaluando una expresión}, cuyo primer elemento es una función. @i{Así es cómo
  funciona Emacs}.

  Al presionar las teclas, haces que el interprete Lisp evalue una expresion y
  asi es como obtienes tus resultados. Incluso escribir texto plano implica
  evalúar una función de Emacs Lisp, en este caso, se utiliza
  @c{self-insert-command}, que simplemente inserta el caracter que escribiste.
  Las funciones que se evalúan presionando atajos de teclado se llaman funciones
  @:{interactivas}, o @:{comandos}; la forma de hacer que una funcion sea
  interactiva se ilustrara en el capítulo sobre cómo escribir definiciones de
  funciones. Vea la Seccion @l{#Crear una Función Interactiva}.

  Además de presionar comandos de teclado, hemos visto una segunda manera de
  evaluar una expresión: colocar el cursor después de una lista y presionar
  @k{C-x C-e}. Esto es lo que haremos en el resto de esta sección. Hay otras
  maneras de evaluar una expresión; que serán descritas a medida que llegemos a
  ellas.

  Ademas de utilizarce para prácticar la evaluación, las funciones que se
  muestran en las siguientes secciones son importantes por derecho propio. Un
  estudio de estas funciones deja claro la distinción entre búfers y ficheros,
  cómo cambiar a un búfer, y como determinar una ubicación dentro de el.

** Nombres de búfer

   Las dos funciones, @c{buffer-name} y @c{buffer-file-name}, muestran la
   diferencia entre un fichero y un búfer. Cuando se evalúa la siguiente
   expresión, @c{(buffer-name)}, el nombre del buffer aparece en el area eco.
   Al evaluar @c{(buffer-file-name)}, el nombre del fichero al que se
   relaciona el búfer aparece en el área de eco. Por lo general, el nombre
   devuelto por @c{(buffer-name)} es el mismo que el nombre del fichero al
   que hace referencia, y el nombre devuelto por @c{(buffer-file-name)} es la
   ruta completa del fichero.

   Un fichero y un búfer son dos entidades diferentes. Un fichero es la
   información grabada de manera permanente en el ordenador (a menos que se
   elimine). Un búfer, por otro lado, es la información dentro de Emacs que
   desaparecerá al final de la sesión de edición (o cuando matas el búfer).
   Por lo general, un búfer contiene información que se ha copiado
   desde un fichero; decimos que el búfer está @:{visitando} ese fichero.
   Esta copia es en la que se trabaja y modifica. Los cambios al búfer no
   cambian el fichero, hasta ser guardados. Al guardar el búfer, el búfer
   se copia en el fichero y por lo tanto se guarda de forma permanente.

   Si está leyendo esto dentro de GNU Emacs, puede evaluar cada una de las
   siguientes expresiones colocando el cursor después de estas y pulsando @k{C-x
   C-e}.

   ..src > elisp
     (buffer-name)

     (buffer-file-name)
   < src..

   Cuando hago esto en el búfer @f(*info*), el valor devuelto evaluando
   @c{(buffer-name)} es @f{"*info*"}, y el valor devuelto evaluando
   @c{(buffer-file-name)} es @f{nil}.

   Por otro lado, mientras escribo este documento, el valor devuelto por la
   evaluación de @c{(buffer-name)} es @c{"introduction.texinfo"}, y el valor
   devuelto por la evaluación de @c{(buffer-file-name)} es
   @c{"/gnu/work/intro/introduction.texinfo"}.

   El primero es el nombre del búfer y el segundo es el nombre del
   fichero. En Info, el nombre del búfer es @f{"*info*"}. Info no apunta a
   ningún fichero, por lo que el resultado de evaluar @c{(buffer-file-name)}]
   es @f{nil}. El símbolo @c{nil} proviene del latin, significa ‘nada’; en
   este caso, significa que el búfer no está asociado con ningun fichero.
   (En Lisp, @c{nil} también se utiliza con el significado de ‘falso’ y es
   sinómino para la lista vacía, @c{()}.)

   Al escribir esto, el nombre de mi búfer es @c{"introduction.texinfo"}. El
   nombre del fichero al que apunta es @c{"/gnu/work/intro/introduction.texinfo"}.

   (En las expresiones, los paréntesis le indican al intérprete Lisp que trate a
   @c{buffer-name} y @c{buffer-file-name} como funciones; sin los paréntesis, el
   intérprete intentaría evaluar los símbolos como variables. Vea la Sección
   @l{#Variables}.)

   A pesar de la distinción entre ficheros y búfers, con frecuencia
   encontrara personas referirse a un fichero cuando quieren un búfer y
   viceversa. De hecho, la mayoría de la gente dice, “Estoy editando un
   fichero”, en lugar de decir, “Estoy editando un búfer que pronto voy a
   guardar en un fichero”. Esto casi siempre queda claro a partir del
   contexto de lo que la gente dice. No obstante, Al tratar con programas de
   ordenador, es importante mantener la distinción en mente, ya que el
   ordenador no es tan inteligente como una persona.

   Por cierto, la palabra ‘búfer’, viene del significado de la palabra como un
   cojín que amortigua la fuerza de una colisión. En los primeros ordenadores,
   un búfer amortiguaba la interacción entre los ficheros y la unidad central de
   procesamiento del ordenador. Los tambores o cintas que contenian un fichero y
   la unidad de procesamiento eran piezas de equipamiento muy diferentes entre
   si, que trabajaban a sus propias velocidades, por rafagas. El búfer hizo
   posible que ambos trabajaran juntos de manera efectiva. Con el tiempo, el
   búfer pasó de ser un intermediario, un lugar de almacenamiento temporal, a
   ser el lugar donde se realiza el trabajo. Esta transformación se parace
   bastante a la de un pequeño puerto que se convierte en una gran ciudad: una
   vez fué simplemente el lugar donde la carga era depositada temporalmente
   antes de ser cargada en los barcos; despues se convirtio en un centro
   comercial y cultural por derecho propio.

   No todos los búfers están asociados con ficheros. Por ejemplo, el búfer
   @f(*scratch*) no visita ningun fichero. Del mismo modo, un búfer
   @f{*Help*} no está asociado a ningun fichero.

   En los viejos tiempos, cuando se carecia de un fichero @f{~/.emacs} y se
   iniciava una sesión Emacs escribiendo unicamente el comando @c{emacs}, sin
   nombrar ningun fichero, Emacs iniciaba con el búfer @f{*scratch*}
   visible. Hoy en día, vera una pantalla de bienvenida. Puede seguir uno de
   los comandos sugeridos en dicha pantalla, visitar un fichero, o presionar
   la barra espaciadora para acceder al búfer @f{*scratch*}.

   Si cambias al búfer @f{*scratch*}, escribe @c{(buffer-name)}, coloca el
   cursor al final de la expresión, y presiona @k{C-x C-e} para evaluar la
   expresión. El nombre @c{*scratch*} será devuelto y aparecerá en el área
   de eco. @c{*scratch*} es el nombre del búfer. Al escribir y evaluar
   @c{(buffer-file-name)} en el búfer @f{*scratch*}, aparecerá @c{nil} en el
   área de eco, igual que cuando evalúas @c{(buffer-file-name)} en Info.

   Por cierto, si estas en el búfer @f{*scratch*} y quieres que el
   valor devuelto por una expresión aparezca en el búfer en sí y no en el
   área de eco, presiona @k{C-u C-x C-e} en lugar de @k{C-x C-e}. Esto hace
   que el valor devuelto aparezca después de la expresión. El búfer se verá
   así:

   ..example >
     (buffer-name)"*scratch*"
   < example..

   No se puede hacer esto en Info ya que Info es de solo lectura y no se
   permitirá cambiar el contenido del búfer. Pero puedes hacer esto en
   cualquier búfer que puedas editar; y cuando escribes código o
   documentación (como este libro), esta caracteristica es muy útil.

** Obtención de Búfers

   La función @c{buffer-name} devuelve el @e{nombre} del búfer; para obtener
   el búfer @e{en sí}, se necesita una función diferente: la función
   @c{current-buffer}. Si utiliza esta función en el código, lo que se
   obtiene es el búfer en sí.

   Un nombre y el objeto o entidad al que se refiere el nombre son
   diferentes entre si. Tu no eres tu nombre, eres una persona a la que se
   refieren los demas por tu nombre. Si pides hablar con Jorge y alguien te
   entrega una tarjeta con las letras @'{J}, @'{o}, @'{r}, @'{g}, y @'{e}
   estritas, podrias divertirte, pero no estarías satisfecho. No quieres
   hablar con el nombre, sino con la persona a la que se refiere el
   nombre. Un búfer es similar: el nombre del búfer scratch es
   @f{*scratch*}, pero el nombre no es el búfer. Para obtener un búfer en
   sí, es necesario utilizar una función como @c{current-buffer}.

   Sin embargo, hay una ligera complicación: si evalúas @c{current-buffer} en
   una expresión por sí sola, como haremos aquí, lo que se ve es una
   representación impresa del nombre del búfer sin el contenido del búfer. Emacs
   funciona de esta forma por dos razones: el búfer puede contener miles de
   líneas––demasiado largo para ser mostrado convenientemente; y, otro búfer
   puede tener el mismo contenido pero un nombre diferente, y es importante
   distinguir entre ellos.

   Aquí hay una expresión que contiene la función:

   ..src > elisp
     (current-buffer)
   < src..

   Si evalúa esta expresión en Info de la manera habitual, aparecerá
   @f{#<buffer *info*>} en el área de eco. El formato especial indica que el
   búfer en sí está siendo devuelto, en lugar de solo su nombre.

   Por cierto, si bien puedes escribir un número o símbolo en un programa, no
   se puede hacer esto con la representación impresa del búfer: la única
   manera de optener un búfer en sí mismo es con una función como
   @c{current-buffer}.

   Un función relacionada es @c{other-buffer}. Esta devuelve el último bufer
   seleccionado distinto al que te encuentras actualmente, no una
   representación impresa de su nombre. Si recientemente has ido y vuelto del
   búfer @f{*scratch*}, @c{other-buffer} devolverá ese búfer.

   Puedes ver esto evaluando la expresión:

   ..src > elisp
     (other-buffer)
   < src..

   Verás que @c{#<buffer *scratch*>} aparece en el área de eco, o el nombre de
   cualquier otro búfer al que allas cambiado anteriormente a partir del más
   reciente@n{5}

** Cambiando búfers

   La función @c{other-buffer} realmente proporciona un búfer cuando se
   utiliza como argumento de una función que requiera uno. Podemos ver esto
   usando @c{other-buffer} y @c{switch-to-buffer} para cambiar a un búfer
   diferente.

   Pero primero, una breve introducción a la función @c{switch-to-buffer}.
   Cuando cambias de ida y vuelta de Info al búfer @f{*scratch*} para evaluar
   @c{(buffer-name)}, normalmente se presiona @k{C-x b} y luego se pasa
   @f{*scratch*}@n{6} en el minibuffer cuando se le solicita el nombre del
   buffer al que quieres cambiar. El atajo, @k{C-x b}, hace que el intérprete
   Lisp evalúe la función interactiva @c{switch-to-buffer}. Como hemos dicho
   anteriormente, así es como funciona Emacs: diferentes atajos de teclado
   llaman o ejecutan diferentes funciones. Por ejemplo, @k{C-f} llama a
   @c{forward-char}, @k{M-e} llama a @c{forward-sentence}, etcétera.

   Al escribir @c{switch-to-buffer} en una expresión, y darle un búfer al
   que cambiar, podemos cambiar de búfer tal y como hace @k{C-x b}.

   ..src > elisp
     (switch-to-buffer (other-buffer))
   < src..

   El símbolo @c{switch-to-buffer} es el primer elemento de la lista, por lo
   que el intérprete Lisp lo tratará como una función y llevara a cabo las
   instrucciones adjuntas al mismo. Pero antes de hacer esto, el intérprete
   observara que @c{other-buffer} está dentro de paréntesis y trabajara en
   este símbolo primero. @c{other-buffer} es el primer (y en este caso, el
   único) elemento de esta lista, por lo que el intérprete llama o ejecuta la
   función. Esto devuelve un búfer distinto al actual. A continuación, el
   intérprete ejecuta @c{switch-to-buffer}, pasando, como argumento, el
   búfer devuelto, que es al que Emacs cambiara. Si estás leyendo esto en
   Emacs, prueba ahora. Evalúa la expresión. (Para regresar, presiona @k{C-x b
   RET}.)@n{7}

   En los ejemplos de las secciones siguentes, veras con más frecuencia la
   función @c{set-buffer} que @c{switch-to-buffer}. Esto se debe a la
   diferencia entre programas de ordenador y los humanos: los humanos
   tienen ojos y esperan ver el búfer en el que están trabajando en la
   terminal de su ordenador. Esto es tan evidente, que se sobreentiende. Sin
   embargo, los programas no tienen ojos. Cuando un programa de ordenador
   trabaja en un búfer, el búfer no necesita ser visible en la pantalla.

   @c{switch-to-buffer} está diseñado para los humanos y hace dos cosas
   diferentes: cambia el búfer a el que Emacs dirige la atención; y cambia
   el búfer mostrado en la ventana al nuevo búfer. @c{set-buffer}, por otro
   lado, solo hace una cosa: cambia la atención del programa del ordenador a
   un búfer diferente. El búfer en la pantalla permanece sin cambios (por
   supuesto, normalmente no pasa nada hasta que el comando termina de
   ejecutarse).

   Además, acabamos introduciendo otro termino tecnico, la palabra
   @:{llamada}. Cuando se evalúa una lista en la que el primer símbolo es una
   función, se llama a esa función. El uso del término viene de la
   noción de la función como una entidad que puede algo hacer por ti cuando
   la ‘llamas’––al igual que un fontanero es una entidad que puede arreglar
   una fuga si lo llamas.

** Tamaño del búfer y la ubicación del punto

   Por último, vamos a ver varias funciones bastante sencillas, @c{buffer-size},
   @c{point}, @c{point-min}, y @c{point-max}. Estas proporcionan información
   sobre el tamaño de un búfer y la ubicación del punto dentro de el.

   La función @c{buffer-size} te dice el tamaño del búfer actual; es decir,
   la función devuelve un conteo del número de caracteres en el buffer.

   ..src > elisp
     (buffer-size)
   < src..

   Puedes evaluar esto de la forma habitual, coloca el cursor después de la
   expresión y presiona @k{C-x C-e}.

   En Emacs, la posición actual del cursor se denomina @:{punto}. La
   expresión @c{(point)} devuelve un número que indica donde esta situado el
   cursor como un conteo del número de caracteres desde el principio del
   búfer hasta el punto.

   Puedes ver el conteo de caracteres del punto para este búfer evaluando la
   siguiente expresión de la forma habitual:

   ..src > elisp
     (point)
   < src..

   Mientras escribo esto, el valor de @c{point} es 65724. La función
   @c{point} se utiliza con frecuencia en algunos de los ejemplos mas
   adelante en este libro.

   El valor del punto depende, por supuesto, de su ubicacion dentro del
   búfer. Si evaluas el punto en este lugar, el número será mayor:

   ..src > elisp
     (point)
   < src..

   Para mí, el valor del punto en esta posición es 66043, lo que significa que
   hay 319 caracteres (incluyendo espacios) entre las dos expresiones.  (Sin
   duda, verás números diferentes, ya que lo habré editado desde que evalue el
   punto por primera vez.)

   La función @c{point-min} es similar a @c{point}, pero devuelve el valor
   mínimo permisible del punto en el búfer actual. Este es el numero 1 a menos
   que @:{narrowing} esté en efecto. (Narrowing @%e{Reduccion} es un mecanismo
   mediante el cual puedes restringirte a ti mismo, o un programa, a operar solo
   en un parte de un búfer. Vea la Sección @l{#Reducir y Extender}.)  Del mismo
   modo, la función @c{point-max} devuelve el valor máximo permisible del punto
   en el búfer actual.

** Ejercicio

   Busca un fichero en el que trabarjar y avanza hasta la mitad. Encuentra el
   nombre de búfer, el nombre del fichero, su tamaño, y la posición en el
   fichero.

* Cómo escribir definiciones de funciones

  Cuando el intérprete Lisp evalúa una lista, mira si el primer símbolo tiene
  una definición de funcion adjunta; o, dicho de otro modo, si el símbolo apunta
  a una definición de función. Si lo hace, el ordenador lleva a cabo las
  instrucciones que aparecen en la definición. Un símbolo que tiene una
  definición de función se llamada, simplemente, una función (aunque hablando
  con propiedad, la definición es la función y el símbolo se refiere a ella.)

  Todas las funciones se defininen en términos de otras funciones, a
  excepción de algunas @:{primitivas} que estan escritas en el lenguaje de
  programación C. Cuando escribas definiciones de funciones, debes
  escribirlas en Emacs Lisp y utilizar otras funciones como bloques de
  construcción. Algunas de las funciones a utilizar estaran a su vez escritas
  en Emacs Lisp (quizás por tí) y otras serán primitivas escritas en C. Las
  funciones primitivas se usan exactamente igual que las escritas en Emacs
  Lisp y se comportan de igual forma. Están escritas en C para que podamos
  ejecutar facilmente GNU Emacs en cualquier ordenador que tenga la potencia
  suficiente y pueda ejecutar C.

  Permíteme volver a enfatizar esto: cuando se escribe código en Emacs Lisp, no
  se distinge entre el uso de funciones escritas en C y el uso de funciones
  escritas en Emacs Lisp. La diferencia es irrevelante. Mencioné la distinción
  solo porque es interesante conocerla. De hecho, a menos de que investigues, no
  sabras si una función ya estrita esta en Emacs Lisp o en C.

** La forma especial @c{defun}

   En Lisp, un símbolo como @c{mark-whole-buffer} tiene un código adjunto que le
   dice al ordenador que hacer cuando se invoca la función. Este código se
   denomina la @:{definición de función} y se crea evaluando una expresión Lisp
   que comienza con el símbolo @c{defun} (que es una abreviatura para @e{define
   function} @%e(definir función)). Debido a que @c{defun} no evalúa sus
   argumentos en la manera habitual, se le llama una @:{forma especial}.

   En las siguientes secciones, vamos a ver las definiciones de función
   partiendo del código fuente de Emacs, como @c{mark-whole-buffer}.
   En esta sección, describiremos una definición de función sencilla para que
   puedas ver su aspecto. Esta definición de función usa aritmética porque es
   un ejemplo simple. A algunas personas les disgustan los ejemplos que usan
   aritmética; sin embargo, si usted es tal persona, no se desespere. Casi
   ningun codigo a estudiar en el resto de esta introducción implica
   aritmética o matemáticas. Los ejemplos involucran principalmente texto en
   una forma u otra.

   Una definición de función tiene un máximo de cinco partes despues de la
   palabra @c{defun}:

   1. El nombre del símbolo al que debe vincularse la definición de función.

   2. Una lista de los argumentos que se pasan a la función. Si no hay
      argumentos que pasar a la función, tendremos una lista vacía, @c{()}.

   3. Documentación que describe la función. (Técnicamente opcional, pero
      muy recomendable.)

   4. Opcionalmente, una expresión para hacer que la función sea interactiva, de
      manera que puede utilizarla presionando @k{M-x} seguido del nombre de la
      función; o pulsando una tecla o atajo de teclado.

   5. El código que indica a el ordenador qué hacer: el @:{cuerpo} de la
      definición de función.

   Es útil pensar que las cinco partes de una definición de función estan
   organizadas como en una plantilla, con ranuras para cada parte:

   ..src > elisp
     (defun nombre-de-función (argumentos…)
       "documentación-opcional…"
       (interactive argument-passing-info)     ; opcional
       cuerpo…)
   < src..

   A modo de ejemplo, aquí está el código de una función que multiplica su
   argumento por 7. (Este ejemplo no es interactivo. Vea la Sección @l{#Crear una
   Función Interactiva}, para obtener esa información.)

   ..src > elisp
     (defun multiplicar-por-siete (numero)
       "Multiplica NUMERO por siete."
       (* 7 numero))
   < src..

   Esta definición comienza con un paréntesis y el símbolo @c{defun} seguido
   por el nombre de la función.

   El nombre de la función es seguido por una lista que contiene los
   argumentos que se pasaran a la función. Esta lista se llama @:{lista de
   argumentos}. En este ejemplo, la lista solo tiene un elemento, el símbolo
   @c{numero}. Cuando se utiliza la función, el símbolo sera asociado al
   valor que se utiliza como argumento de la función.

   En lugar de elegir la palabra @c{numero} para el nombre del argumento,
   podría haber escogido cualquier otro nombre. Por ejemplo, la palabra
   @c{multiplicando}. Escogi la palabra ‘numero’ porque indica qué tipo de
   valor se pretende para este espacio; pero podría haber elegido
   ‘multiplicando’ para indicar el papel que jugara el valor en el
   funcionamiento de la función. Podría haberlo llamado @c{foogle}, pero
   habría sido una mala elección, ya que no comunicaria a los humanos qué
   significa. La elección del nombre es responsabilidad del programador y
   debe elegirse para hacer que el significado de la función quede claro.

   De hecho, puedes elegir cualquier nombre que desees para un símbolo en una
   lista de argumentos, incluso el nombre de un símbolo utilizado en alguna otra
   función: el nombre que utilices en una lista de argumentos es privado
   para esta definición particular. En esta definición, el nombre hace
   referenecia a una entidad diferente a cualquiera que utilice el mismo
   nombre fuera de la definición de función. Supón que tu familia te apoda
   ‘Enano’; cuando tus familiares digan ‘Enano’, queren hacer referencia a
   ti. Pero fuera de tu familia, en una película, por ejemplo, el nombre
   ‘Enano’ se refiere a alguien más. Debido a que el nombre en una lista de
   argumentos es privado para la definición de la función, se puede cambiar
   el valor de un símbolo dentro del cuerpo de una función sin cambiar su
   valor fuera de la función. El efecto es similar al producido por la
   expresión @c{let}. (Vea la sección @l{#@c(let)}.)

   La lista de argumentos es seguida por la cadena de documentación que
   describe la función. Esto es lo ves cuando presionas @k{C-h f} y escribes
   el nombre de una función. Por cierto, cuando escribas una cadena de
   documentación como esta, debes confeccionar la primera linea como una
   frace completa ya que algunos comandos, como @c{apropos}, solo imprimen
   la primera línea de una cadena de documentación de varias líneas.
   Ademas, no debes indentar la segunda línea de la cadena de documentación,
   si tienes una, porque se ve extraño al utilizar @k{C-h f}
   (@c{describe-function}). La cadena de documentación es opcional, pero es
   tan útil, que debería incluirse en casi cualquier función que escribas.

   La tercera línea del ejemplo consiste en el cuerpo de la definición de
   función. (La mayoría de las definiciones de funcion, claro esta, son más
   extensas que esta.) En esta función, el cuerpo es la lista, @c{(* 7
   numero)}, que indica multiplicar el valor de @c{numero} por 7. (En Emacs
   Lisp, @c{*} es la función para la multiplicación, al igual que @c{+} es la
   función de suma.

   Cuando se utiliza la función @c{multiplicar-por-siete}, el argumento
   @c{numero} se evalúa al número que desees usar. He aquí un ejemplo que
   muestra como utilizar @c{multiplicar-por-siete}; pero ¡no intentes evaluar
   esto primero!.

   ..src > elisp
     (multiplicar-por-siete 3)
   < src..

   El símbolo @c{numero}, especificado en la definición de función en la
   siguiente sección, se da o “une a” el valor 3 en el actual uso de la
   función. Note que aunque @c{numero} estaba dentro de paréntesis en la
   definición de función, el argumento pasado a la función
   @c{multiplicar-por-siete} no está entre paréntesis. Los paréntesis se
   escriben en la definición de función para que el ordenador pueda averiguar
   donde termina la lista de argumentos e inicia el resto de la definición de
   función.

   Si evalúas este ejemplo, es probable que obtengas un mensaje de error.
   (¡adelante, intentalo!) Esto se debe a que hemos escrito la definición de
   función, pero aún no se ha comunicado al ordenador sobre la definición––no
   hemos instalado (o ‘cargado’) la definición de función en Emacs. Instalar
   una función es el proceso de comunicar al intérprete Lisp la definición de
   la función. La instalación se describe en la siguiente sección.

** Instalar una definición de función

   Si estás leyendo esto dentro en Emacs, puedes probar la función
   @c{multiplicar-por-siete} evaluando en primer lugar la definición de función y
   luego evaluando @c{(multiplicar-por-siete 3)}. Hay una copia de la
   definición a continuación. Coloca el cursor después del último paréntesis
   de la definición de función y presiona @k{C-x C-e}. Al hacer esto,
   @c{multiplicar-por-siete} aparecerá en el área de eco. (Esto significa
   que cuando una se evalua una definición de función, el valor devuelto es
   el nombre de la función definida.) Al mismo tiempo, esta acción instala la
   definición de función.

   ..src > elisp
     (defun multiplicar-por-siete (numero)
       "Multiplica NUMERO por siete."
       (* 7 numero))
   < src..

   Al evaluar este @c{defun}, estas instanlado @c{multiplicar-por-siete} en
   Emacs. La función ahora es una parte de Emacs tanto como
   @c{forward-word} o cualquier otra función de edición que utilices.
   (@c{multiplicar-por-siete} permanecera instalado hasta que salgas de
   Emacs. Para volver a cargar el código automáticamente cada vez que Emacs
   inicie, revisa la sección @l{#Instalar Código Permanentemente}.)

   Puedes ver el efecto de instalar @c{multiplicar-por-siete} evaluando el
   siguiente ejemplo. Coloca el cursor después de la siguiente expresión y
   presiona @k{C-x C-e}. Aparacerá el número 21 en el área de eco.

   ..src > elisp
     (multiplicar-por-siete 3)
   < src..

   Si lo deseas, puedes leer la documentación de la función presiona @k{C-h
   f} @%c(describe-function) y luego escribe el nombre de la función,
   @c{multiplicar-por-siete}. Al hacer esto, una ventana @f{*Help*}
   aparecerá en tu pantalla diciendo:

   ..example >
     multiplicar-por-siete is a Lisp function.
     (multiplicar-por-siete NUMERO)

     Multiplica NUMERO por siete.
   < example..

   (Para volver a una unica ventana en la pantalla, presiona @k{C-x 1}.)

*** Cambiar una definición de función

    Si deseas modificar el código de @c{multiplicar-por-siete}, simplemente
    vuelve a escribirlo. Para instalar la nueva versión en lugar de la anterior, evalúa
    nuevamente la definición de la función. Esta, es la forma de modificar el
    código en Emacs. Es muy simple,

    A modo de ejemplo, puedes cambiar la función @c{multiplicar-por-siete}
    para sumar el número a sí mismo siete veces en lugar de multiplicar el
    número por siete. Esto produce el mismo resultado, pero por una ruta
    diferente. Al mismo tiempo, añadiremos un comentario al codigo; un
    comentario es texto que el intérprete Lisp ignora, pero un lector humano
    puede encontrar útil o esclarecedor. El comentario es, que esta es la
    “segunda versión”.

    ..src > elisp
      (defun multiplicar-por-siete (numero)       ; Segunda versión.
        "Multiplica NUMERO por siete."
        (+ numero numero numero numero numero numero numero))
    < src..

    El comentario sigue a un punto y coma, @'{;}. En Lisp cualquier cosa en
    una línea despues de un punto y coma es un comentario. El fin de la línea
    es el fin del comentario. Para extender un comentario por dos o más
    líneas, inicia cada línea con un punto y coma.

    Vé las Secciónes @l(#Empieza por un fichero @f{.emacs}) y
    @l{info:emacs#Comments<>Comentarios} en @e(El Manual de Referencia de GNU
    Emacs Lisp), para más informacion sobre los comentarios.

    Puedes instalar esta versión de @c{multiplicar-por-siete} evaluándo esta
    del misma modo en que evaluaste la primer función: coloca el cursor
    después del último paréntesis y presiona @k{C-x C-e}.

    En resumen, asi es como puedes escribir código en Emacs Lisp: escribes una
    función; la instalas; la pruebas; luego haces correcciones o mejoras y la
    vuelves a instalar.

** Crear una función interactiva

   Puedes hacer a una función interactiva colocando una lista que inicia con la
   forma especial @c{interactive} inmediatamente después de la documentación.
   Un usuario puede invocar una función interactiva con @k{M-x} seguido del
   nombre de la función; o con un atajo de teclado ligado a esta, por
   ejemplo, presionando @k{C-n} para @c{next-line} o @k{C-x h} para
   @c{mark-whole-buffer}.

   Cusionamente, cuando llamas a una función interactiva interactivamente, el
   valor devuelto no se muestra automáticamente en el área de eco. Esto se debe
   a que a menudo se llama a una función interactiva por sus efectos
   secundarios, como avanzar hacia adelante una palabra o una línea,
   y no por el valor devuelto. Si el valor devuelto se mostrara en el área
   de eco cada vez que presionas una tecla, seria muy molesto.

   Tanto el uso de la forma especial @c{interactive} y la forma de mostrar
   un valor en el área de eco pueden ilustrarse creando una versión
   interactiva de @c{multiplicar-por-siete}.

   Aquí está el código:

   ..src > elisp
     (defun multiplicar-por-siete (numero)       ; Versión Interactiva.
       "Multiplica NUMERO por siete."
       (interactive "p")
       (message "El resultado es %d" (* 7 numero)))
   < src..

   Para instalar este código coloca el cursor después del ultimo parentesis y
   presiona @k{C-x C-e}. El nombre de la función aparecerá en el área de eco.
   Despues, puedes utilizar este código al presionar @k{C-u} segudo de un
   número, luego @k{M-x multiplicar-por-siete} y finalmente @k{RET}. La
   frase @'{El resultado es …} seguida por el producto, aparecerá en el área
   de eco.

   Hablando en terminos mas generales, puedes invocar una función como ésta
   de dos maneras:

   1. Al escribir un argumento prefijo que contiene el número a pasar, y a
      continuación presionar @k{M-x} y escribir el nombre de la función, como
      ocurre con @k{C-u 3 M-x forward-sentence}; o,

   2. Escribir cualquier tecla o atajo de teclado ligado a la función, como
      ocurre con @k{C-u 3 M-e}.

   Ambos ejemplos operan de forma identica moviendo el punto hacia adelante
   tres oraciones. (Ya que @c{multiply-by-seven} no esta ligado a un atajo, no
   se puede utilizar como ejemplo.)

   (Vea la Seccion @l{#Atajos de teclado}, para aprender como vincular un
   comando a una atajo.)

   Un argumento prefijo se pasa a una función interactiva pulsando la tecla
   @k{META} seguida de un número, por ejemplo, @k{M-3 M-e}, o con @k{C-u} y
   luego un número, por ejemplo, @k{C-u 3 M-e} (si presionas @k{C-u} sin
   ningun número, el valor por defecto es 4).

*** @c{multiplicar-por-siete} interactivo

    Veamos es uso de la forma especial @c{interactive} y luego la función
    @c{message} en la versión interactiva de @c{multiplicar-por-siete}.
    Recordaras que la definición de función tiene este aspecto:

    ..src > elisp
      (defun multiplicar-por-siete (numero)       ; Versión Interactiva.
        "Multiplica NUMERO por siete."
        (interactive "p")
        (message "El resultado es %d" (* 7 numero)))
    < src..

    En esta función, la expresión, @c{(interactive "p")}, es una lista de dos
    elementos. La @c{"p"} le indica a Emacs que debe pasar el argumento
    prefijo a la función y utilizar este valor para el argumento de la
    función.

    El argumento debe ser un número. Esto significa que el símbolo @c{numero}
    estara asociado a un número en la línea:

    ..src > elisp
      (message "El resultado es %d" (* 7 numero))
    < src..

    Por ejemplo, si tu argumento prefijo es 5, el intérprete Lisp evaluará la
    línea como si fuera:

    ..src > elisp
      (message "El resultado es %d" (* 7 5))
    < src..

    (Si estás leyendo esto en GNU Emacs, puedes evaluar esta expresión por ti
    mismo.) Primero, el intérprete evaluará la lista interna, que es @c{(* 7
    5)}. Esto devuelve un valor de 35. A continuación, se evaluará la lista
    externa, pasando los valores del segundo y posteriores elementos de la
    lista a la función @c{message}.

    Como hemos visto, @c{message} es una función Emacs Lisp especialmente
    diseñada para enviar un mensaje de una línea al usuario. (Vea la Seccion
    @l{#La función @c{message}}.) En resumen, la función @c{message} imprime su
    primer argumento en el área de eco tal cual, excepto para las apariciones de
    @'{%d}, o @'{%s} (y varias otras secuencias de control que no hemos
    mencionado). Cuando aparece una secuencia de control, la función busca
    el segundo o posteriores argumentos e imprime el valor del argumento en
    la ubicación donde se encuartra la secuencia de control.

    En la función interactiva @c{multiplicar-por-siete}, la cadena de
    control es @'{%d}, que requiere un número, y el valor devuelto por la
    evaluación de @c{(* 7 5)} es el número 35. Por consiguiente, el número 35
    se imprime en lugar de @'{%d} y el mensaje es @'{El resultado es 35}.

    (Observa que cuando llamas a la función @c{multiplicar-por-siete}, el
    mensaje se imprime sin comillas, pero cuando llamas a @c{message}, el
    texto se imprime entre comillas. Esto se debe a que el valor devuelto por
    @c{message} aparece en el área de eco cuando evalúas una expresión cuyo
    primer elemento es @c{message}; pero si se integra en una función,
    @c{message} imprime el texto como un efecto secundario sin comillas.)

** Diferentes opciones para @c{interactive}

   En el ejemplo, @c{multiplicar-por-siete} utilizo @c{"p"} como el
   argumento para @c{interactive}. Este argumento indica a Emacs que
   interprete cualquer cosa que escriba despues de @k{C-u} o del comando
   @k{META} como un numero que sera el argumento a pasar a la funcion. Emacs
   tiene más de veinte caracteres predefinidos para usar con @c{interactive}.
   En casi todos los casos, una de estas opciones te permitira pasar la
   información correcta de forma interactiva a una función. (Vea la Seccion
   @l{info:elisp#Interactive<>Codigo de Caracteres para @c{interactive}} en @e(El
   Manual de Referencia GNU Emacs Lisp)).

   Considera la función @c{zap-to-char}. Su expresión interactiva es

   ..src > elisp
     (interactive "p\ncZap to char: ")
   < src..

   La primer parte del argumento de @c{interactive} es @'{p}, con el que ya
   estás familiarizado. Este argumento le indica a Emacs intepretar un
   ‘prefijo’, como un número que se pasa a la función. Puedes especificar un
   prefijo presionando @k{C-u} seguido de un número o igualmente con @k{META}
   seguido por un número. El prefijo es un número de caracteres especifico. De
   este modo, si el prefijo es tres y el caracter especificado es @'{x},
   entonces se borrará todo el texto hasta e incluido el tercer @'{x}
   siguiente. Si no se establece un prefijo, entonces borras todo el texto hasta
   e incluido el carácter establecido, pero no más.

   La @'{c} indica a la función el nombre del carácter que va a eliminar.

   Más formalmente, una función con dos o más argumentos puede tener
   información que pasa a cada argumento añadiendo partes en la cadena que
   a continuacion de @c{interactive}. Al hacer esto, la información se
   pasa a cada argumento en el mismo orden que se especifica en la lista
   @c{interactive}. En la cadena, cada parte está separada de la siguente
   parte por un @'{\n}, que significa nueva línea. Por ejemplo, a @'{p} puede
   continuar un @'{\n} y un @'{cZap to char: }. Esto hace que Emacs pase el
   valor del argumento prefijo (si lo hay) y el carácter.

   En este caso, la definición de función se parece a la siguiente, donde
   @c{arg} y @c{char} son los símbolos que @c{interactive} vincula el
   argumento prefijo y el caracter especificado:

   ..src > elisp
     (defun nombre-de-funcion (arg char)
       "documentacion…"
       (interactive "p\ncZap to char: ")
       cuerpo-de-funcion…)
   < src..

   (El espacio después de los dos puntos en el prompt hace que se vea
   mejor. Vea la Seccion @l{#La Definición de @c{copy-to-buffer}}, para un
   ejemplo.)

   Cuando una función no toma argumentos, @c{interactive} no requiere
   ninguno. Una función asi contiene unicamente la expresión
   @c{(interactive)}. La función @c{mark-whole-buffer} es asi.

   Alternativamente, si los códigos especiales de letras no son adecuados
   para su aplicación, puedes pasar tus propios propios argumentos a
   @c{interactive} como una lista.

   Vea la Seccion @l{#La Definición de @c{append-to-buffer}}, para un
   ejemplo. Vea la Sección @l{info:elisp#Using Interactive<>Usando
   @c{interactive}} en @e(El Manual de GNU Emacs Lisp), para una explicación más
   completa sobre esta técnica.

** Instalar Código Permanentemente

   Cuando instalas una definición de función evaluandola, permanecera instalada
   hasta que salgas de Emacs. La proxima vez que inicies una nueva sesión de
   Emacs, la función no sera instalada a menos que evalúes la definición de
   nuevo.

   En algún momento, podrias necesitar que el código se instale
   automáticamente cada vez que inicies una nueva sesión de Emacs. Hay varias
   formas de hacer esto:

   - Si tienes código solo para tu uso, puedes poner el código de la
     definición de función en el fichero de inicialización @f{.emacs}. Cuando
     se inicia Emacs, el fichero @f{.emacs} se evalúa automática y se
     instalan todas sus definiciones de función. Vér la Sección @l{#Tu Fichero
     @f{.emacs}}.

   - Como Alternativa, puedes poner las definiciones de función en uno o más
     ficheros y usar la función @c{load} para hacer que Emacs evalue y con
     ello instale cada una de las funciones en los ficheros. Vea la Seccion
     @l{#Cargando ficheros}.


   - En Tercer lugar, si tienes código que todo tu sitio va a utilizar, es
     normal ponerlo en un fichero llamado @f{site-init.el} que se carga
     cuando se construye Emacs. Esto hace que el código este disponible para
     todos los usuarios de tu máquina. (Mira el fichero @f{INSTALL} que forma
     parte de la distribución Emacs.)

   Finalmente, si tienes código que cualquier usuario de Emacs pueda querer,
   puedes publicarlo en una red de informatica o enviar una copia a la Free
   Software Foundation. (Al hacer esto, por favor licencia el código y su
   documentación bajo una licencia que permita a otras personas ejecutar,
   copiar, estudiar, modificar, y redistribuir el código y te protege de
   quien tome tu trabajo.) Si envias una copia de tu código a la Free
   Software Foundation, y lo proteges apropiadamente de ti mismo y otros,
   puede ser incluido en la siguiente version de Emacs. En gran parte, esta
   es la forma como ha crecido Emacs a través de los años, a traves de donaciones.

** @c{let}

   La expresión @c{let} es una forma especial en Lisp que tendras que
   utilizar en la mayoría de las definiciones de función.

   @c{let} se utiliza para unir o enlazar un símbolo a un valor de tal manera
   que el intérprete no confunda la variable con otra variable del mismo
   nombre que no forme parte de la función.

   Para entender por qué la forma especial @c{let} es necesaria, considera la
   situación donde eres dueño de una casa que generalmente vinculas con ‘la
   casa’, como en la frase, “La casa necesita pintura”. Si visitas a un amigo
   y tu anfitrion hace referencia a ‘la casa’, es probable que se refiera a
   @e{su} casa, no a la tuya, es decir, a una casa diferente.

   Si tu amigo se refiere a su casa y tu crees que el se esta refiriendo a tu
   casa, puedes tener cierta confusión. Lo mismo podría suceder en Lisp si
   una variable que se usa dentro de una función tiene el mismo nombre
   que una variable usada dentro de otra función, y las dos no tienen la
   intencion de referirse al mismo valor. La forma especial @c{let} permite evitar
   este tipo de confusión.

   La forma especial @c{let} evita confusiones. @c{let} crea un nombre para
   una @:{variable local} que eclipsa cualquier uso del mismo nombre fuera de
   la expresión @c{let}. Esto es como entender que cuando tu anfitrion
   se refiera a ‘la casa’, el quiere decir su casa, no la tuya. (Los símbolos
   usados en las listas de argumentos funcionan de la misma manera. Véa la
   Sección @l{#La Forma Especial @c{defun}}.)

   Las variable locales creadas por una expresión @c{let} retienen su valor
   @e{solo} dentro de la expresión @c{let} (y dentro de expresiones
   llamadas dentro de la expresión @c{let}); las variables locales no tiene
   efecto fuera de la expresión @c{let}.

   Otra forma de persar sobre @c{let} es que es como un @c{setq} que es temporal
   y local. Los valores establecidos por @c{let} se deshacen automáticamente
   cuando @c{let} finaliza. La configuración solo afecta a las expresiones que
   se encuentran dentro de los limites de la expresión @c{let}. En jerga
   informatica, diríamos que “la union de un simbolo es visible solo en las
   funciones llamadas en la forma @c{let}; en Emacs Lisp, el alcance es
   dinámico, no léxico.”

   @c{let} puede crear más de una variable a la vez. Ademas, @c{let} da a cada
   variable que crea un valor inicial, ya sea un valor especificado por tí, o
   @c{nil}. (En la jerga, eso se llama ‘enlazar la variable al valor’.)  Después
   de que @c{let} ha creado y enlazado las variables, ejecuta el código en el
   cuerpo del @c{let} y devuelve el valor de la última expresión en el cuerpo,
   como el valor de toda la expresión @c{let}. (‘Ejecutar’ es un término tecnico
   que significa evaluar una lista; proviene del significando de la palabra
   ‘llevar a la practica’ (@e{Oxford English Dictionary}). Ya que evalúas una
   expresión para realizar una acción, ‘ejecutar’ ha evolucionado como un
   sinónimo para ‘evaluar’.)

*** Partes de una expresión @c{let}

    Una expresión @c{let} es una lista de tres partes. La primer parte es el
    símbolo @c{let}. La segunda parte es una lista, llamada @:{varlist}
    (lista de variables), cada uno de cuyos elementos es un símbolo por sí
    mismo o una lista de dos elementos, cuyo primer elemento es un símbolo. La
    tercera parte de la expresión @c{let} es el cuerpo de @c{let}. El cuerpo
    normalmente consiste de una o más listas.

    Una plantilla para una expresión @c{let} tiene el siguente aspecto:

    ..src > elisp
      (let varlist cuerpo…)
    < src..

    Los símbolos de la lista de varibles @%c(varlist) son las variables a las
    que la forma especial @c{let} da valores de inicio. Los símbolos por si
    solos reciven el valor de inicio @c{nil}; y cada símbolo que sea el primer
    elemento de una lista de dos elementos se vincula al valor que se devuelve
    cuando el interprete Lisp evalúa el segundo elemento.

    Por lo tanto, una varlist podria verse asi: @c{(thread (needles 3))}. En
    este caso, en una expresión @c{let}, Emacs une el símbolo @c{thread} a
    un valor inicial de @c{nil}, y une el símbolo @c{needles} a un valor inicial
    de 3.

    Cuando escribes una expresión @c{let}, lo que haces es poner las
    expresiones apropiadas en los espacios de la plantilla de expresión
    @c{let}.

    Si la varlist está compuesta de listas de 2 elementos, como suele ser el
    caso, la plantilla de la expresión @c{let} es la sigiente:

    ..src > elisp
      (let ((variable valor)
            (variable valor)
            …)
        cuerpo…)
    < src..

*** Ejemplo de Expresión @c{let}

    La siguiente expresión crea y da valores los iniciales a las dos variables
    @c{cebra} y @c{tigre}. El cuerpo de la expresión @c{let} es una lista que
    llama a la función @c{message}.

    ..src > elisp
      (let ((cebra 'rayas)
            (tigre 'fiero))
        (message "Un tipo de animal tiene %s y otro es %s."
                 cebra tigre))
    < src..

    Aquí, la varlist es @c{((cebra 'rayas) (tigre 'fiero))}.

    Las dos variables son @c{cebra} y @c{tigre}. Cada variable es el primer
    elemento de una lista de dos elementos y cada valor es el segundo
    elemento de su lista de dos elementos. En la varlist, Emacs une la
    variable @c{cebra} al valor @c{rayas}@n{8}, y la variable @c{tigre}
    al valor @c{fiero}. En este ejemplo, ambos valores son símbolos
    precedidos por una cita. Los valores podrían muy bien haber sido otra
    lista o una cadena. El cuerpo de @c{let} sigue después de la lista que
    contiene las variables. En este ejemplo, el cuerpo es una lista que usa
    la función @c{message} para imprimir una cadena en el área de eco.

    Puedes evaluar el ejemplo de la forma habitual, coloca el cursor después
    del último paréntesis y presiona @k{C-x C-e}. Al hacer esto, aparecerá lo
    siguiente en el área de eco:

    ..src > elisp
      "Un tipo de animal tiene rayas y otro es fiero."
    < src..

    Como hemos visto anteriormente, la función @c{message} imprime su primer
    argumento, excepto @'{%s}. En este ejemplo, el valor de la variable
    @c{cebra} se imprime en la ubicacion del primer @'{%s} y el valor de la
    variable @c{tigre} se imprime en la ubicacion del segundo @'{%s}.

*** Variables sin inicializar en un sentencia @c{let}

    Si no se unen las variables en una sentencia @c{let} con valores
    de inicio específicos, automáticamente seran unidos a un valor de inicio
    @c{nil}, como en la siguiente expresión:

    ..src > elisp
      (let ((abedul 3)
            pino
            abeto
            (roble 'algunos))
        (message
         "Aquí están %d variables con %s, %s, y el valor %s."
         abedul pino abeto roble))
    < src..

    Aquí, la varlist es @c{((abedul 3) pino abeto (roble 'algunos))}.

    Si evalúas esta expresión de la forma habitual, aparecerá lo siguiente en
    el área de eco:

    ..example >
      "Aquí están 3 variables con nil, nil, y el valor algunos."
    < example..

    En este ejemplo, Emacs une el símbolo @c{abedul} al número 3, une los
    símbolos @c{pino} y @c{abeto} a @c{nil}, y el símbolo @c{roble} al
    valor @c{algunos}.

    Observe que en la primera parte de @c{let}, las variables @c{pino} y
    @c{abeto} son unicamente átomos que no están rodeados por paréntesis;
    esto es porque estan siendo unidos a @c{nil}, la lista vacía. Pero
    @c{roble} su une a @c{algunos} por que es parte de la lista @c{(roble
    'algunos)}. De manera similar, @c{abedul} se une al número 3 en una lista
    con este número. (Ya que un número se evalúa a sí mismo, el número no
    necesita ser citado. Ademas, el número se imprime en el mensaje
    utilizando un @'{%d} en lugar de un @'{%s}.) Las cuatro variables como
    grupo son puestas dentro de una lista para delimitarla del cuerpo de
    @c{let}.

** La forma especial @c{if}

   Además de @c{let} y @c{defun}, esta la forma especial condicional @c{if}.
   Esta forma se utiliza para indicar al ordenador que tome decisiones.
   Puedes escribir definiciones de función sin necesidad de utilizar @c{if},
   pero se usa con bastante frecuencia, y es lo suficientemente importante
   como para incluirse aquí. Se utiliza, por ejemplo, en el código de la
   función @c{beginning-of-buffer}.

   La idea básica detras de @c{if}, es que “@e{si} @%e(if) una prueba es verdadera
   @e{entonces} se evalua la expresión”. Si la prueba no es verdadera, la
   expresión no se evalua. Por ejemplo, podría tomar una decisión como, “si
   hace sol y calor, ve a la playa!”

   Al escribir una expresión @c{if} en Lisp no se utiliza la palabra ‘then’;
   la prueba y la acción son los elementos segundo y tercero de la lista cuyo
   primer elemento es @c{if}. No obstante, la parte de la prueba en una
   expresión @c{if} a menudo se llamada @:{parte-si} (if-part) y el segundo
   argumento a menudo se llamada @:{parte-entonces} (then-part).

   Ademas, cuando se escribe una expresión @c{if}, la prueba-verdadero-o-falso
   normalmente se escribe en la misma línea que el símbolo @c{if}, pero la
   acción a llevar a cabo si la prueba es verdadera, “parte-entonces”, se
   escribe en la segunda y suguientes líneas. Esto hace que la expresión @c{if}
   sea mas fácil de leer.

   ..src > elisp
     (if prueba-verdadero-o-falso
         accion-a-realizar-si-el-test-es-cierto)
   < src..

   La prueba-verdadero-o-falso es una expresión que evalua el intérprete
   Lisp.

   Aquí hay un ejemplo que puedes evaluar. La prueba consiste en si el número
   5 es mayor que el número 4. Ya que es asi, se imprime el mensaje @'{¡5 es
   mayor que 4!}.

   ..src > elisp
     (if (> 5 4)                           ; parte-si
         (message "¡5 es mayor que 4!"))   ; parte-entonces
   < src..

   (La función @c{>} comprueba si su primer argumento es mayor que su segundo
   argumento y devuelve verdadero si lo es.)

   Por supuesto, en un caso real, la prueba en una expresión @c{if} no será
   siempre la misma, como en la expresión @c{(> 5 4)}. En su lugar, al menos
   una de las variables utilizadas en la prueba estara unida a un valor de
   antemano desconocido. (Si el valor se conociera de antemano, ¡no necesitariamos
   realizar la prueba!)

   Por ejemplo, el valor puede estar unido a un argumento de una definición
   de función. En la siguiente definición de función, el tipo de animal es un
   valor que se pasa a la función. Si el valor unido a @c{caracteristica} es
   @c{fiero}, entonces se imprime el mensaje, @'{¡Es un tigre!}; de otro
   modo, se devolvera @c{nil}.

   ..src > elisp
     (defun tipo-de-animal (caracteristica)
       "Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
     Si la CARACTERISTICA es el símbolo ‘fiero’,
     entonces advierte que es un tigre."
       (if (equal caracteristica 'fiero)
           (message "¡Es un tigre!")))
   < src..

   Si estás leyendo esto dentro de GNU Emacs, puedes evaluar la definición de
   función de la forma habitual para instalarlo en Emacs, y luego puedes
   evaluar las dos expresiones siguientes para ver los resultados:

   ..src > elisp
     (tipo-de-animal 'fiero)

     (tipo-de-animal 'cebra)
   < src..

   Al evaluar @c{(tipo-de-animal 'fiero)}, veras el siguiente mensaje impreso
   en el área eco: @c{"¡Es un tigre!"}; y cuando se evalúa @c{(tipo-de-animal
   'cebra)} verás @c{nil} impreso en el área de eco.

*** La función @c{tipo-de-animal} en detalle

    Veamos la función @c{tipo-de-animal} en detalle.

    La definición de función @c{tipo-de-animal} se escribio llenando los
    espacios de dos plantillas, la primera para la definición de función como
    un todo, y la segunda para una expresión @c{if}.

    La plantilla para cada función no interactiva es:

    ..src > elisp
      (defun nombre-de-funcion (lista-de-argumentos)
        "documentacion…"
        cuerpo…)
    < src..

    Las partes de la función que coinciden con esta plantilla tienen este aspecto:

    ..src > elisp
      (defun tipo-de-animal (caracteristica)
        "Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
           Si la CARACTERISTICA es el símbolo ‘fiero’,
           entonces advierte que es un tigre."
        cuerpo: la expresion if)
    < src..

    El nombre de función es @c{tipo-de-animal}; se pasa al valor de un
    argumento. A la lista de argumentos le sigue una cadena de documentación
    multilínea. La cadena de documentación se incluiye en el ejemplo porque
    es un buen hábito escribir un cadena de documentación para cada
    definición de función. El cuerpo de la definición de función consiste en
    la expresión @c{if}.

    La plantilla para una expresión @c{if} se ve así:

    ..src > elisp
      (if prueba-verdadero-o-falso
          accion-a-realizar-si-la-prueba-devuelve-verdadero)
    < src..

    En la función @c{tipo-de-animal}, el código para @c{if} se ve así:

    ..src > elisp
      (if (equal caracteristica 'fiero)
          (message "¡Es un tigre!")))
    < src..

    Aquí, está la expresión prueba-verdadero-o-falso

    ..src > elisp
      (equal caracteristica 'fiero)
    < src..

    En Lisp, @c{equal} es una función que determina si su primer argumento es
    igual al segundo. El segundo argumento es el símbolo citado @c{'fiero} y el
    primer argumento es el valor del símbolo @c{característica}––en otras
    palabras, el argumento pasado a esta función.

    En la primer prueba de @c{tipo-de-animal}, el argumento @c{fiero} se pasa
    a @c{tipo-de-animal}. Ya que @c{fiero} es igual a @c{fiero}, la
    expresión, @c{(equal caracteristica 'fiero)}, devuelve el valor
    verdadero. Cuando esto sucede, @c{if} evalúa el segundo argumento o la
    parte-entonces del @c{if}: @c{(message "¡Es un tigre!")}.

    Por otro lado, en la segunda prueba de @c{tipo-de-animal}, se pasa el
    argumento @c{cebra} a @c{tipo-de-animal}. @c{cebra} no es igual a @c{fiero},
    por lo que la parte-entonces no se evalua y la expresión @c{if} devuelve
    @c{nil}).

** Expresiones if–then–else

   Una expresión @c{if} puede tener un tercer argumento opcional, llamado
   @:{else-part} (parte-de-otro-modo), en caso de que la
   prueba-verdadero-o-falso devuelva falso. Cuando esto sucede, el segundo
   argumento o parte-entonces de la expresión @c{if} global @e{no} se evalúa, pero
   el tercer argumento o parte-de-otro-modo @e{se} evalúa. Podría pensar en
   esto como la alternativa del día nublado para la decisión “si es cálido y
   soleado, entonces ir a la playa!, de otro modo leer un libro!”

   La palabra “else” (de otro modo) no se escribe en el código Lisp; la
   parte-de-otro-modo de una expresión @c{if} viene después de la
   parte-entonces. En Lisp, la parte-de-otro-modo suele escribirse al inicio
   de una nueva linea y se indenta menos que la parte-entonces:

   ..src > elisp
     (if prueba-verdadero-o-falso
         accion-a-realizar-si-la-prueba-devuelve-verdadero
       accion-a-realizar-si-la-prueba-devuelve-falso)
   < src..

   Por ejemplo, la siguiente expresión @c{if} imprime el mensaje @'{¡4 no es
   mayor que 5!} al evaluarse en la forma habitual:

   ..src > elisp
     (if (> 4 5)                                   ; parte-if
         (message "¡4 falsamente es mayor que 5!") ; parte-then
       (message "¡4 no es mayor que 5!"))          ; parte-else
   < src..

   Tenga en cuenta que los diferentes niveles de indentación hacen fácil
   distinguir la parte-entonces de la parte-de-otro-modo. (GNU Emacs tiene
   varios comandos que indentan expresiones @c{if} automáticamente. Vea la
   Seccion @l{#GNU Emacs te ayuda a escribir listas}.)

   Podemos ampliar la función @c{tipo-de-animal} para incluir una parte-else
   simplemente incorporando una parte adicional para la expresión @c{if}.

   Puedes ver las consecuencias de hacer esto si evalúas la siguiente versión de
   la definición de función @c{tipo-de-animal} y luego evaluas las dos
   expresiones siguientes que pasan diferentes argumentos a la función.

   ..src > elisp
     (defun tipo-de-animal (caracteristica)
       "Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
     Si la CARACTERISTICA es el símbolo ‘fiero’,
     entonces advierte que es un tigre.
     de otro modo decir que no es fiero"
       (if (equal caracteristica 'fiero)
           (message "¡Es un tigre!")
         (message "!No es feroz!")))

     (tipo-de-animal 'fiero)

     (tipo-de-animal 'cebra)
   < src..

   Al evalar @c{(tipo-de-animal 'fiero)}, verás el siguiente mensaje en el
   área de eco: @c{"¡Es un tigre!"}; pero cuando evalues @c{(tipo-de-animal
   'cebra)}, verás @c{"¡No es feroz!"}.

   (Por supuesto, si @c{característica} fuera @c{muy feroz}, se imprimiria el
   mensaje @c{"¡No es feroz!"}; ¡y sería un error!  Cuando escribas código,
   necesitas tener en cuenta la posibilidad de que algun argumento como este
   será puesto a prueba por @c{if} y acorde a ello escribir tu programa.

** Verdad y Falsedad en Emacs Lisp

   Hay un aspecto importante para la prueba verdadero en una expresión
   @c{if}. Hasta ahora, hemos hablado de ‘verdadero’ y ‘falso’ como valores
   de predicados como si fueran nuevos tipos de objetos Emacs Lisp. De hecho,
   solo nuestro viejo amigo @c{nil} es ‘falso’. Cualquier otra
   cosa––cualquiera en absoluto––es ‘verdadero’.

   La expresión que prueba si es verdadero se interpreta como @:{true}
   (verdadero) si el resultado de la evaluacion es no @c{nil}. En otras
   palabras, el resultado de la prueba se considera verdadero si el valor
   devuelto es un número como 47, una cadena como @c{"hola"}, o un símbolo
   (distinto a @c{nil}) como @c{flores}, o una lista (siempre y cuando no
   este vacía) o incluso ¡un búfer!

   Antes de ilustrar una prueba para verdadero, necesitamos una explicación
   de @c{nil}.

   En Emacs Lisp, el símbolo @c{nil} tiene dos significados. En primer lugar,
   significa que la lista está vacía. En segundo lugar, significa falso y es
   el valor devuelto cuando una prueba-verdadero-o-falso obtiene falso.
   @c{nil} puede escribirse como una lista vacia, @c[()], o como @c(nil). En
   lo referente al interprete Lisp @c[()] y @c(nil) son lo mismo. Los
   humanos, sin embargo, tienden a usar @c{nil} para falso y @c{()} para
   lista vacía.

   En Emacs Lisp, cualquier valor que no sea @c{nil}––no es una lista
   vacía––se considera verdadero. Esto significa que si una evaluación
   devuelve algo que no es una lista vacía, una expresión @c{if} pondra la
   prueba a verdadero. Por ejemplo, si un número se coloca en el lugar de la
   prueba, se evaluara y devolverá su valor, ya que eso es lo que hacen los
   números cuando se evalúan. En esta condicion, la expresión @c{if}
   devuelve verdadero. La expresión devuelve falso solo cuando @c{nil}, o una
   lista vacía, son devueltas al evaluar la expresión.

   Puedes ver esto evaluando las dos expresiones en los ejemplos siguientes.

   En el primer ejemplo, el número 4 se evalua como la prueba en la expresión
   @c{if} y devuelve el numero en si; en consecuencia, se evalua y devuelve
   la parte-then de la expresión: aparece @'{verdadero} en el área de eco. En el
   segundo ejemplo, @c{nil} indica falso; en consecuencia, se evalua y
   devuelve la parte-else de la expresión: aparece @'{falso} en el área de eco.

   ..src > elisp
     (if 4
         'verdadero
       'falso)

     (if nil
         'verdadero
       'falso)
   < src..

   Por cierto, si algún otro valor de utilidad no está disponible para una prueba
   que devuelve verdadero, entonces el intérprete Lisp devolvera el símbolo
   @c{t} para verdadero. Por ejemplo, la expresión @c{(> 5 4)} devuelve @c{t}
   cuando se evalúa, como puedes comprobar si evaluas:

   ..src > elisp
     (> 5 4)
   < src..

   Por otra parte, esta función devuelve @c{nil} si la prueba es falsa.

   ..src > elisp
     (> 4 5)
   < src..

** @c{save-excursion}

   La función @c{save-excursion} es la cuarta y última forma especial que
   discutiremos en este capítulo.

   En los programas Emacs Lisp utilizados para la edición, la función
   @c{save-excursion} es muy común. Guarda la posición del punto y marca,
   ejecuta el cuerpo de la función, y luego restaura el punto y marca a sus
   posiciones previas si sus posiciones fueron cambiadas. Su objetivo
   principal es impedir que el usuario se sorprenda y perturbe por el
   movimiento inesperado del punto o marca.

   Sin embargo, antes de hablar de @c{save-excursion}, puede ser útil examinar
   primero que son el punto y la marca en GNU Emacs. @:{Punto} es la posición
   actual del cursor. Donde sea que se encuentre el cursor, estara el punto. De
   forma más precisa, en los terminales donde el cursor aparece sobre un
   carácter, el punto está inmediatamente antes del carácter. En Emacs Lisp, el
   punto es un numero entero. El primer carácter en un búfer es el número uno,
   el segundo es el número dos, y así sucesivamente. La función @c{point}
   devuelve la posición actual del cursor como un número. Cada búfer tiene su
   propio valor para el punto.

   La @:{marca} es otra posición en el búfer; su valor se puede establecer con
   un comando como @k{C-SPC} @%c(set-mark-command). Si una marca se ha
   establecido, puede utilizar el comando @k{C-x C-x}
   (@c{exchange-point-and-mark}) para hacer que el cursor salte a la marca y
   establecer la marca como la posición anterior del punto. Además, si se
   establece otra marca, la posición de la marca anterior se guarda en el anillo
   de marcas. De este modo puede guardar varias posiciones de la marca. Se
   puede mover el cursor a una marca guardada presionando @k{C-u C-SPC} una o
   más veces.

   La parte del búfer entre el punto y la marca se llamada @:{la región}.
   Numerosos comandos trabajan en la región, incluyendo @c{center-region},
   @c{count-lines-region}, @c{kill-region} y @c{print-region}.

   La forma especial @c{save-excursion} guarda la ubicacion del punto y la
   marca y restaura estas posiciones después de que el interprete Lisp evalua el
   código dentro del cuerpo de la forma especial. De este modo, si el punto
   se encontraba al inicio de un trozo de texto y algún código desplazo el
   punto al final del búfer, @c{save-excursion} volvera a poner el punto
   donde estaba antes, luego que las expresiones en el cuerpo de la funcion
   sean evaluadas.

   En Emacs, con frecuencia una función mueve el punto como parte de su
   funcionamiento interno a pesar de que un usuario no espere esto. Por ejemplo,
   @c{count-lines-region} mueve el punto. Para evitar que el usuario sea
   molestado por saltos inesperados y (desde el punto de vista del usuario)
   innecesarios, @c{save-excursion} se utiliza a menudo para conservar el punto y
   la marca en la posición esperada por el usuario. El uso de @c{save-excursion}
   es bueno para mantener el orden.

   Para asegurarse que la casa se mantiene limpia, @c{save-excursion}
   restaura los valores del punto y la marca incluso si algo va mal en el
   código interno (o, para ser más preciso y usar el lenguaje tecnico
   apropiado, “en caso de salida anormal”). Esta funcionalidad es muy útil.

   Además de registrar los valores del punto y marca, @c{save-excursion}
   registra el buffer actual, y lo restaura. Esto significa que puedes escribir
   código que cambie de bufer y @c{save-excursion} debe volver al bufer
   original. Asi es como se utiliza @c{save-excursion} en @c{append-to-buffer}.
   (Vea la Seccion @l{#La Definición de @c{append-to-buffer}}.)

*** Plantilla para una Expresión @c{save-excursion}

    La plantilla de código usando @c{save-excursion} es simple:

    ..src > elisp
      (save-excursion
        cuerpo…)
    < src..

    El cuerpo de la función es una o más expresiones que serán evaluadas de
    forma secuencial por el intérprete Lisp. Si hay más de una expresión en
    el cuerpo, el valor de la última será devuelto como el valor de la
    función @c{save-excursion}. Las otras expresiones en el cuerpo solo se
    evaluan por sus efectos secundarios; y @c{save-excursion} en sí, solo se
    utiliza por su efecto secundario (que es restaurar las posiciones del
    punto y la marca).

    La siguiente plantilla explica @c{save-excursion}, con más detalle:

    ..src > elisp
      (save-excursion
        primera-expresion-en-el-cuerpo
        segunda-expresion-en-el-cuerpo
        tercera-expresion-en-el-cuerpo
         …
        ultima-expresion-en-el-cuerpo)
    < src..

    Una expresión, por supuesto, puede ser un símbolo por sí mismo o una
    lista.

    En el código Emacs Lisp, una expresión @c{save-excursion} a menudo ocurre
    dentro del cuerpo de una expresión @c{let}. Se ve asi:

    ..src > elisp
      (let varlist
        (save-excursion
          cuerpo…))
    < src..

** Repaso: Cómo escribir definiciones de funciones <> Repaso

   En los últimos capítulos se han introducido un buen número de funciones y
   formas especiales. A continuacion se describen brevemente, junto con
   algunas funciones similares que aun no se han mencionado.

   - @c(eval-last-sexp) ::

     Evalúar la última expresión simbólica antes de la posición actual del
     punto. El valor se imprime en el área de eco a menos que la función se
     invoque con un argumento; en este caso, la salida se imprime en el
     búfer actual. Este comando normalmente esta asociado a @k{C-x C-e}.

   - @c(defun) ::

     Define una función. Esta forma especial consta de hasta cinco partes: el
     nombre, una plantilla para los argumentos que se pasan a la función, la
     documentacion, una declaración interactiva opcional, y el cuerpo de la
     definición.

     Por ejemplo, en las primeras versiones de Emacs, la definición de la
     función @c(back-to-indentation) era como sigue. (Eso es ligeramente más
     complejo ahora que se busca el primer caracter que no es espacio en lugar
     del primer caracter visible.)

     ..src > elisp
       (defun back-to-indentation ()
         "Mueve el punto al primer caracter visible de la linea."
         (interactive)
         (beginning-of-line 1)
         (skip-chars-forward " \t"))
     < src..

   - @c(interactive) ::

     Anuncia al intérprete que la función se puede usar de forma interactiva.
     Esta forma especial puede ir seguida de una cadena con una o más
     partes que pasan la información a los argumentos de la función, de forma
     secuencial. Estas partes pueden también decir al intérprete que solicite
     información. Las partes de la cadena estan separadas por saltos de
     linea, @'{\n}.

     Los codigos de caractere comúnes son:

     - @c(b) :: El nombre de un búfer existente.

     - @c(f) :: El nombre de un fichero existente

     - @c(p) :: El argumento prefijo numérico. (Tenga en cuenta que esta ‘p’ es
       minúscula.)

     - @c(r) :: Punto y marca, como dos argumentos numéricos, el más pequeño
       primero. Este es el unico codigo de una letra que especifica dos
       argumentos sucesivos en lugar de uno.


     Vea la Seccion @l{info:elips#Interactive Codes<>Codigo de caracteres para
     @'{interactive}} en @e(El Manual de Referencia de GNU Emacs Lisp), para
     obtener una lista completa de los codigos de caracteres.

   - @c(let) ::

     Declara una lista de variables para utilizarla dentro del cuerpo de
     @c{let} y darle a cada variable un valor inicial, ya sea @c{nil} o un valor
     específico; luego evaluar el resto de las expresiones en el cuerpo del
     @c{let} y devuelve el valor de la última expresion. Dentro del cuerpo
     del @c{let}, el intérprete Lisp no ve los valores de variables con el
     mismos nombre fuera de @c{let}.

     Por ejemplo,

     ..src > elisp
       (let ((foo (buffer-name))
             (bar (buffer-size)))
         (message
          "Este buffer es %s y tiene %d caracteres."
          foo bar))
     < src..

   - @c(save-excursion) ::

     Registra los valores de punto, marca y el búfer actual antes de evaluar el
     cuerpo de esta forma especial. Restaura los valores de punto, marca y el
     búfer luego de esto.

     Por ejemplo,

     ..src > elisp
       (message "Estamos %d caracteres dentro de este buffer."
                (- (point)
                   (save-excursion
                     (goto-char (point-min)) (point))))
     < src..


   - @c(if) ::

     Evalúa el primer argumento de la función; si es verdadero, evalúa el
     segundo argumento; de otra forma evalúa el tercer argumento, si lo hay.

     La forma especial @c{if} se llamada @:{condicional}. Hay otros
     condicionales en Emacs Lisp, pero @c{if} es quizás el más comúnmente
     usado.

     Por ejemplo,

     ..src > elisp
       (if (= 24 emacs-major-version)
           (message "Esta es la version 24 de Emacs")
         (message "Esta no es la version 24 de Emacs"))
     < src..

   - @c(<), @c(>), @c(<=), @c(>=) ::

     La función @c{<} prueba si su primer argumento es menor que su segundo
     argumento. @c{>}, prueba si el primer argumento es mayor que el
     segundo. Del mismo modo, @c{<=} prueba si el primer argumento es menor o
     igual al segundo y @c{>=} si el primer argumento es mayor o igual al
     segundo. En todos los casos, ambos argumentos deben ser números o
     marcadores (los marcadores indican posiciones en búfers).

   - @c(=) ::

     La función @c{=} prueba si dos argumentos, ambos números o marcadores,
     son iguales.

   - @c(equal), @c(eq) ::

     Prueba si dos objetos son el mismo. @c{equal} utiliza un signicado de la
     palabra ‘mismo’ y @c{eq} utiliza otro: @c{equal} devuelve verdadero si
     los dos objetos tienen una estructura y contenidos similares, por
     ejemplo, dos copias del mismo libro. Por otro lado, @c{eq}, devuelve
     verdadero si ambos argumentos son realmente el mismo objeto.

   - @c(string<), @c(string-lessp), @c(string=), @c(string-equal) ::

     La función @c{string-lessp} prueba si su primer argumento es menor que el
     segundo. Un nombre alternativo mas corto para la misma función (un
     @c{defalias}) es @c{string<}.

     Los argumentos para @c{string-lessp} deben ser cadenas o símbolos; la
     ordenación es lexicográfica, por lo que mayusculas o minusculas son
     significativas. Los nombres impresos de símbolos se utilizan en lugar de
     los símbolos mismos.

     Una cadena vacía, @'{""}, una cadena sin caracteres en ella, es más
     pequeña que cualquier cadena de caracteres.

     @c{string-equal} proporciona la prueba correpondiente para la igualdad.
     Su nombre alternativo es @c{string=}. No hay funciones de prueba
     que correspondan a @c{>}, @c{>=} o @c{<=}.

   - @c(message) ::

     Imprime un mensaje en el área de eco. El primer argumento es una cadena
     que puede contener, @'{%s}, @'{%d}, o @'{%c} para imprimir el valor de
     los argumentos que siguen a la la cadena. El argumento utilizado por
     @'{%s} debe ser una cadena o un simbolo, el argumeto utilizado por
     @'{%d} debe ser un número. El argumento usado por @'{%c} debe ser un
     codigo númerico @e{ASCII}; se imprimira como el caracter con este código
     @e{ASCII}. (No se han mencionado otras secuencias @"(porcentuales) @c(%-)).

   - @c(setq), @c(set) ::

     La función @c{setq} asigna al valor de su primer argumento el valor del
     segundo argumento. El primer argumento se cita automáticamente por
     @c{setq}. Hace lo mismo para los pares sucesisvos de argumentos. Otra
     función, @c{set}, toma solo dos argumentos y evalúa ambos antes de
     asignar el valor devuelto por su primer argumento al valor devuelto por
     el segundo argumento.

   - @c(buffer-name) ::

     Sin un argumento, devuelve el nombre del búfer, como una cadena.

   - @c(buffer-file-name) ::

     Sin un argumento, devuelve el nombre del fichero del búfer que se esta
     visitando.

   - @c(current-buffer) ::

     Devuelve el búfer en el que Emacs se encuentra activo; Puede que no sea
     el búfer que es visible en la pantalla.

   - @c(other-buffer) ::

     Devuelve el ultimo búfer seleccionado mas recientemente (distinto del
     buffer pasado a @c{other-buffer} como un argumento y distinto del búfer
     actual).

   - @c(switch-to-buffer) ::

     Selecciona un búfer de Emacs para activarlo y mostralo en la ventana
     actual para que los usuarios puedan verlo. Normalmente ligado a @k{C-x
     b}.

   - @c(set-buffer) ::

     Cambiar la atención de Emacs a un búfer en el que se ejecutaran
     programas. No altera lo que la ventana está mostrando.

   - @c(buffer-size) ::

     Devuelve el número de caracteres en el búfer actual.

   - @c(point) ::

     Devuelve el valor de la posicion actual del cursor, como un entero
     contando el número de caracteres desde el inicio del búfer.

   - @c(point-min) ::

     Devuelve el valor mínimo admisible del punto en el búfer actual. Esto
     es 1, a menos que narrowing esté activo

   - @c(point-max) ::

     Devuelve el valor máximo admisible del punto en el búfer actual.
     Este es el fin del búfer, a menos que narrowing este activo.

** Ejercicios

   - Escribe una función no interactiva que duplique el valor de su
     argumento, un número. Luego haz la función interactiva.

   - Escribe una función que compruebe si el valor actual de @c{fill-column}
     es mayor que el argumento pasado a la función, y si es así, imprime un
     mensaje apropiado.

* Algunas funciones relacionadas al bufer

  En este capítulo estudiamos en detalle varias de las funciones usadas en
  GNU Emacs. Esto se denomina un “recorrido” (visita o demostracion de un
  area o tarea). Estas funciones se utilizan como ejemplos de código Lisp,
  pero no son ejemplos imaginarios; con excepción del primero, con la
  definición de función simplificada, estas funciones muestran el código real
  usado en GNU Emacs. Se puede aprender mucho de estas definiciones. Las
  funciones descritas aquí están todas relacionadas a búfers. Mas tarde,
  estudiaremos otras funciones.

** Encontrar Más información

   En este recorrido, describire cada nueva función, algunas veces en detalle
   y algunas veces brevemente. Si estás interesado, puedes obtener la
   documentación completa de cualquier función de Emacs Lisp en cualquier
   momento presiona @k{C-h f} y luego escribe el nombre de la función (y
   luego @k{RET}). Del mismo modo, se puede obtener la documentación completa
   de una variable con @k{C-h v}, luego el nombre de la variable (y despues
   @k{RET}).

   Ademas, @c{describe-function} te dira la ubicacion de la definición de la
   función.

   Coloca el punto dentro del nombre del fichero que contiene la función y
   presiona la tecla @k{RET}. En este caso, @k{RET} significa @c{push-button}
   en lugar de ‘return’ o ‘enter’. Emacs te llevara directamente a la
   definición de la función.

   De manera más general, si quieres ver una función en su fichero fuente
   original, puedes utilizar la función @c{find-tag} para saltar a la misma.
   @c{find-tag} trabaja con una amplia variedad de lenguajes, no solo Lisp, y C,
   y tambien funciona con texto en general. Por ejemplo, @c{find-tag} saltará a
   los distintos nodos del codigo fuente de este documento. La función
   @c{find-tag} depende de ‘tablas de etiquetas’ que registran las ubicaciones
   de las funciones, variables, y otros elementos a los que @c{find-tag} salta.

   Para usar el comando @c{find-tag}, presiona @k{M-.} (es decir, presiona la
   tecla punto mientras presionas la tecla @k(META), o presiona @k{ESC} y
   luego la tecla punto), a continuacion, en el prompt, escribe el nombre de
   la función para ver su código fuente, por ejemplo @c{mark-whole-buffer}, y
   luego pulsa @k{RET}. Emacs cambiará de búfer y mostrará el código fuente
   de la función en la pantalla. Para regresar a tu búfer actual, presiona
   @k{C-x b RET}. (En algunos teclados, la tecla @k{META} se etiqueta como
   @k{ALT}.)

   Dependiendo de la configuracion de los valores iniciales por defecto de tu
   copia de Emacs, puede ser necesario especificar la posición de tu ‘tabla de
   etiquetas’, que es un fichero llamado @f{TAGS}. Por ejemplo, si estás
   interesado en el codigo fuente de Emacs, la tabla de etiquetas, si ya ha sido
   creada, estará en un subdirectorio del directorio @f{/usr/local/share/emacs};
   de este modo se usaría el comando @c{M-x visit-tags-table} y se especifica
   una ruta como @f{/usr/local/share/emacs/24.1.1/lisp/TAGS}. Si la tabla de
   etiquetas no ha sido creada, tendrás que crearla por tí mismo. Estara en un
   fichero como @f{/usr/local/src/emacs/src/TAGS}.

   Para crear un fichero @f{TAGS} en un directorio específico, cambia a ese
   directorio en Emacs mediante el comando @k{M-x cd}, o lista el directorio
   con @k{C-x d} @%c(dired). A continuacion ejecuta el comando de
   compilacion, con @c{etags *.el} como:

   ..example >
     M-x compile RET etags *.el RET
   < example..

   Para más información, ver la Seccion @l{#Crea tu propio fichero @f{TAGS}}.

   Después de te familiarices con Emacs Lisp, te encontrarás con frecuencia
   utilizando @c{find-tag} como metodo de navegar atraves del código fuente;
   y crearás tus propias tablas @f{TAGS}.

   Por cierto, los ficheros que contienen código Lisp son llamados
   convencionalmente @:{librerías}. La metáfora se deriva que una librería
   especializada, tal como una librería de leyes o una librería de
   ingeniería, en lugar de una librería general. Cada librería, o fichero,
   contiene funciones que se relacionan con un tema o actividad particular,
   por ejemplo @f{abbrev.el} para el manejo de abreviaturas y otros atajos, y
   @f{help.el} para ayuda en linea. (Algunas veces varias librerías
   proporcionan código para una sola actividad, como los distintos ficheros
   @f{rmail…}  que proporcionan codigo para leer correo electrónico.) En @e{El
   Manual de GNU Emacs}, verás varias frases como “El comando @k{C-h p} te
   permite buscar las librerias estándar de Emacs Lisp por la palabra clave
   del tema.

** Una definición simplificada de @c{beginning-of-buffer}

   El comando @c{beginning-of-buffer} es una buena función para empezar, ya
   que es probable que estes familiarizado con ella y es fácil de
   entender. Usado como un comando interactivo, @c{beginning-of-buffer} mueve
   el cursor al inicio del búfer, dejando la marca en la posición
   anterior. Esta generalmente unido a @k{M-<}.

   En esta sección, vamos a hablar de una versión reducida de la función que
   muestra como se utiliza con mayor frecuencia. Esta función reducida
   funciona como esta escrita, pero no contiene código para una opcion
   compleja. En otra sección, describiremos la función entera. (Vea la Seccion
   @l(#Definición completa de @c{beginning-of-buffer}).

   Antes de mirar el código, vamos a considerar lo que la definición de función
   tiene que contener: debe incluir una expresión que haga la función interactiva
   por lo que se puede llamar escribiendo @k{M-x beginning-of-buffer} o pulsando
   algun atajo como @k{M-<}; debe incluir código para dejar una marca en la posición
   original del búfer; y debe incluir código para mover el cursor al inicio del
   búfer.

   Aquí está el texto completo la versión reducida de la función:

   ..src > elisp
     (defun simplified-beginning-of-buffer ()
       "Mover el punto al inicio del buffer;
     deja la marca en la posicion anterior."
       (interactive)
       (push-mark)
       (goto-char (point-min)))
   < src..

   Al igual que todas las definiciones de función, esta definición tiene
   cinco partes siguiendo la forma especial @c{defun}:

   1. El nombre: en este ejemplo, @c{simplified-beginning-of-buffer}.

   2. Una lista de los argumentos: en este ejemplo, una lista vacía, @c{()},

   3. La cadena de documentación.

   4. La expresión interactiva.

   5. El cuerpo.


   En esta definición de función, la lista de argumentos está vacía; esto
   significa que esta función no requiere ningun argumento. (Cuando nos
   fijamos en la definición de la función completa, veremos que se puede
   pasar un argumento opcional.)

   La expresión interactiva le informa a Emacs que se pretende utilizar la
   función de forma interactiva. En este ejemplo, @c{interactive} no tiene un
   argumento porque @c{simplified-beginning-of-buffer} no requiere uno.

   El cuerpo de la función consiste de dos líneas:

   ..src > elisp
     (push-mark)
     (goto-char (point-min))
   < src..

   La primera de estas líneas es la expresión, @c{(push-mark)}. Cuando el
   interprete Lisp evalua esta expresión, se establece una marca en la
   posición actual del cursor, donde sea que este. La posición de esta marca
   se guarda en el anillo de marcas.

   La siguiente línea es @c{(goto-char (point-min))}. Esta expresión hace
   saltar el cursor hasta el punto mínimo en el búfer, es decir, al inicio
   del búfer (o al inicio de la porción accesible del búfer si narrowed
   esta activo. Vea la Seccion @l{#Reducir y Extender}.)

   El comando @c{push-mark} establece una marca en el sitio donde se encontraba
   el cursor antes de que la expresion expresión @c{(goto-char (point-min))} lo
   moviera al principio del bufer. En consecuencia, puedes, si quieres, volver a
   donde estabas originalmente presionando @k{C-x C-x}.

   ¡Esto es todo lo que hay en la definición de función!

   Cuando leas código como este y te encuentres con una función desconocida,
   como @c{goto-char}, puedes averiguar que es lo que hace mediante el
   comando @c{describe-function}. Para usar este comando, presiona @k{C-h f}
   y luego escribe el nombre de la función y presiona @k{RET}. El comando
   @c{describe-function} imprimirá la cadena de documentacion de la función
   en una ventana @f{*Help*}. Por ejemplo, la documentación de @c{goto-char}
   es:

   ..example >
     Establece el punto a POSICION, un numero o marcador.
     El inicio del buffer es la posicion (point-min), el final es (point-max).
   < example..

   El argumento de la función es la posición deseada.

   (En el caso de @c{describe-function} el prompt te facilita el símbolo
   adelante o anterior al cursor, lo que te puede evitar escribir el nombre de
   la funcion al colocar el cursor encima o después de la función y luego
   presionando @k{C-h f RET}.)

   La definición de la función @c{end-of-buffer} se escribe de la misma forma
   que la definición @c{beginnig-of-buffer} excepto que el cuerpo de la
   función contiene la expresión @c{(goto-char (point-max))} en lugar de
   @c{(goto-char (point-min))}

** La definición de @c{mark-whole-buffer}

   La función @c{mark-whole-buffer} no es mas difícil de entender que la
   función @c{simplified-beginning-of-buffer}. En este caso, sin embargo,
   vamos a ver la función completa, no una versión reducida.

   La función @c{mark-whole-buffer} no se utiliza tan comúnmente como la
   función @c{beginning-of-buffer}, pero no es menos útil: marca un búfer
   completo como una región colocando el punto al inicio y una marca al fin
   del búfer. Generalmente se enlaza a @k{C-x h}.

   En GNU Emacs 22, el código de la función completa se ve asi:

   ..src > elisp
     (defun mark-whole-buffer ()
       "Coloca el punto al inicio y marca el fin del buffer.
     Probablemente no deberias utilizar esta funcion en programas Lisp;
     Por lo general es un error que una funcion Lisp utilice cualquier subrutina
     que utiliza o establece la marca."
       (interactive)
       (push-mark (point))
       (push-mark (point-max) nil t)
       (goto-char (point-min)))
   < src..

   Al igual que todas las demas funciones, la función @c{mark-whole-buffer}
   encaja dentro de la plantilla de una definición de funcion. La
   plantilla luce asi:

   ..src > elisp
     (defun nombre-de-funcion (lista-de-argumentos)
       "documentacion…"
       (expresion-interactiva…)
       cuerpo…)
   < src..

   Asi es cómo funciona la función: el nombre de la función es
   @c{mark-whole-buffer}; le sigue una lista de argumentos vacía, @'{()}, lo que
   significa que la función no requiere argumentos. La documentación viene despues.

   La siguiente línea es una expresión @c{(interactive)} que indica a Emacs
   que la función se utilizara de forma interactiva. Estos detalles son
   similares a la función @c{simplified-beginning-of-buffer} descrita en la
   sección anterior

*** Cuerpo de @c{mark-whole-buffer}

    El cuerpo de la función @c{mark-whole-buffer} consiste en tres líneas de
    código:

    ..src > elisp
      (push-mark (point))
      (push-mark (point-max) nil t)
      (goto-char (point-min))
    < src..

    La primera de estas líneas es la expresión, @c{(push-mark (point))}.

    Esta línea hace exactamente el mismo trabajo que la primera línea del
    cuerpo de la función @c{simplified-beginning-of-buffer}, en la que solo
    se escribe @c[(push-mark)]. En ambos casos, el intérprete Lisp coloca una
    marca en la posición actual del cursor.

    No sé por qué en la expresión @c{mark-whole-buffer} se escribe
    @c{(push-mark (point))} y en la expresión @c{beginning-of-buffer} se
    escribe @c{(push-mark)}. Quizás quien escribió el código no conocia que
    los argumentos de @c{push-mark} son opcionales y que si no se pasa un
    argumento a @c{push-mark}, la función establece automáticamente la marca
    en la posicion del punto por defecto. O quizás la expresión fué escrita
    paralelamente a la estructura de la siguiente línea. En cualquier caso,
    la línea proboca que Emacs determine la posición del punto y coloque una
    marca allí.

    En versiones anteriores de GNU Emacs, la siguiente línea de
    @c{mark-whole-buffer} era @c{(push-mark (point-max))}. Esta expresión
    establece una marca en el punto del búfer que tiene el número más alto. Este
    será el final del búfer (o, si el búfer tiene activo narrowing, el final de
    la porción accesible del búfer. Vea la Seccion @l{#Reducir y Extender}, para
    más informacion sobre norrowing). Después de colocar esta marca, la marca
    anterior, la establecida en el punto, ya no esta configurada, pero Emacs
    recuerda su posición, al igual que todas las otras marcas recientes. Esto
    significa que, si lo deseas, puedes volver a esta posición presionando @k{C-u
    C-SPC} dos veces.

    En GNU Emacs 22, @c{(point-max)} es ligeramente más complicado. La
    línea es

    ..src > elisp
      (push-mark (point-max) nil t)
    < src..

    La expresión funciona casi igual que antes. Se establece una marca en la
    posicion con el numero mas alto posible en el búfer. Sin embargo, en
    esta versión, @c{push-mark} tiene dos argumentos adicionales. El segundo
    argumento de @c{push-mark} es @c{nil}. Esto le indica a la función que debe
    @e{mostrar} un mensaje que dice ‘Mark set’ cuando se coloca la marca. El
    tercer argumento es @c{t}. Esto indica a @c{push-mark} que active la
    marca cuando el modo Transient Mark está activo. Transient Mark mode
    resalta la región activa. Con frecuencia esta desactivado.

    Finalmente, la última línea de la función es @c{(goto-char
    (point-min))}. Esta escrito exactamente de la misma forma como está
    escrito @c{beginning-of-buffer}. La expresión mueve el cursor al punto
    mínimo en el búfer, es decir, al inicio del búferr (o al inicio de la
    porción accesible del búfer). Como resultado de esto, punto se coloca al
    inicio del búfer y la marca se encuentra al final del búfer. Por tanto,
    todo el búfer es la región.

** La definición de @c{append-to-buffer}

   El comando @c{append-to-buffer} es más complejo que el comando
   @c{mark-whole-buffer}. Lo que hace es copiar la región (es decir, la parte
   del búfer entre el punto y la marca) del buffer actual a un búfer
   específico.

   El comando @c{append-to-buffer} utiliza la función @c{insert-buffer-substring}
   para copiar la región. @c{insert-buffer-substring} se describe por su nombre:
   toma una cadena de caracteres de una parte de un búfer, una “subcadena”, y la
   inserta en otro búfer.

   La mayor parte de @c{append-to-buffer} tiene que ver con el establecimiento
   de las condiciones para que @c{insert-buffer-substring} funcione: el código
   debe especificar tanto el búfer al que ira el texto, la ventana fuente y
   destino, y la región que será copiada.

   Aquí está el texto completo de la función:

   ..src > elisp
     (defun append-to-buffer (buffer start end)
       "Agregar a un buffer especifico el texto de la region.
     Este se inserta en ese buffer antes de su punto.

     Cuando se llama desde un programa, se pasan tres argumentes:
     BUFFER (o nombre del buffer), START y END.
     START y END especifican la porcion del buffer actual a copiar."
       (interactive
        (list (read-buffer "Agregar al buffer: " (other-buffer
                                                 (current-buffer) t))
              (region-beginning) (region-end)))
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (let* ((append-to (get-buffer-create buffer))
                  (windows (get-buffer-window-list append-to t t))
                  point)
             (set-buffer append-to)
             (setq point (point))
             (barf-if-buffer-read-only)
             (insert-buffer-substring oldbuf start end)
             (dolist (window windows)
               (when (= (window-point window) point)
                 (set-window-point window (point))))))))
   < src..

   Se puede entender la función si se mira como una serie de plantillas
   rellenas.

   La plantilla exterior es para la definición de función. Esta función, se
   ve como asi (con varios espacios ocupados):

   ..src > elisp
     (defun append-to-buffer (buffer start end)
       "documentacion…"
       (interactive …)
       cuerpo…)
   < src..

   La primer línea de la función incluye su nombre y tres argumentos. Los
   argumentos son el @c{búfer} al cual copiar el texto, @c{start} y @c{end}
   que son el inicio y el fin de la región del buffer actual desde donde se
   va a copiar.

   La siguiente parte de la función es la documentación, que es clara y
   completa. Como es convencional, los tres argumentos estan escritos en
   mayúsculas para que los notes con facilidad. Aun mejor, se describen en el
   mismo orden que en la lista de argumentos.

   Observe que la documentación distingue entre un búfer y su nombre. (La
   función puede manejar cualquiera.)

*** La expresión interactiva @c{append-to-buffer}

    Ya que la función @c{append-to-buffer} se puede utilizar de forma
    interactiva, la función debe tener una expresión @c{interactive}. (Para
    una analisis de @c{interactive}, ve la seccion @l{#Crear una función
    interactiva}.)  La expresión se lee de la siguiente manera:

    ..src > elisp
      (interactive
       (list (read-buffer
              "Agregar al buffer: "
              (other-buffer (current-buffer) t))
             (region-beginning)
             (region-end)))
    < src..

    Esta expresión no tiene letras para representar partes, como se describio
    anteriormente. En su lugar, inicia una lista con estas partes:

    La primer parte de la lista es una expresión para leer el nombre de un
    búfer y devolverlo como una cadena. Es decir @c(read-buffer). La función
    requiere un prompt como primer argumento, @'{"Agregar al buffer: "}. El
    segundo argumento le indica al comando que valor proporcionar si no se
    especifica nada.

    En este caso este segundo argumento es una expresión que contiene la
    función @c{other-buffer}, una excepción, y una @'{t}, para representar
    verdadero.

    El primer argumento de @c{other-buffer}, la excepción, es otra función,
    @c{current-buffer}. Esto no va a ser devuelto. El segundo argumento es el
    símbolo de verdadero, @c{t}. Que le dice a @c{other-buffer} que puede
    mostrar búfers visibles (excepto en este caso, no se mostrará el búfer
    actual, lo cual tiene sentido).

    La expresión se ve asi:

    ..src > elisp
      (other-buffer (current-buffer) t)
    < src..

    El segundo y tercer argumento de la expresión @c{list} son
    @c{(region-beginning)} y @c{(region-end)}. Estas dos funciones
    especifican el inicio y el final del texto que se añade

    Originalmente, el comando utilizaba las letras @'{B} y @'{r}. Toda la
    expresión @c{interactive} se veia así:

    ..src > elisp
      (interactive "BAppend to buffer: \nr")
    < src..

    Pero cuando se hacia esto, el valor por defecto del búfer de cambió era
    invisible. Esto no era lo que se queria.

    (El prompt se separo del segundo argumento con una línea nueva,
    @'{\n}. Seguido por un @'{r} que le indica a Emacs unir los dos
    argumentos que siguen al símbolo @c{buffer} en la lista de argumentos de
    la función (es decir, @c{start} y @c{end}) a los valores del punto y
    marca. Este argumento funcionaba bien.)

*** El cuerpo de @c{append-to-buffer}

    El cuerpo de la función @c{append-to-buffer} inicia con @c{let}.

    Como hemos visto antes (ver Seccion @l{#@c(let)}), el propósito de una
    expresión @c{let} es crear y dar valores iniciales a una o más variables que
    solo se usaran dentro del cuerpo del @c{let}. Esto significa que esa
    variable no se debe confundir con cualquier variable del mismo nombre fuera
    de la expresión @c{let}.

    Podemos ver como la expresión @c{let} encaja en la función como un todo
    mostrando una plantilla de @c{append-to-buffer} con la expresión @c{let}
    en general:

    ..src > elisp
      (defun append-to-buffer (buffer start end)
        "documentacion…"
        (interactive …)
        (let ((variable valor))
              cuerpo…)
    < src..

    La expresión @c{let} tiene tres elementos:

    1. El símbolo @c{let};

    2. Una varlist que contiene, en este caso, una unica lista de dos
       elementos, @c{(variable valor)};

    3. El cuerpo de la expresión @c{let}.


    En la función @c{append-to-buffer}, la varlist es la siguiente:

    ..src > elisp
      (oldbuf (current-buffer))
    < src..

    En esta parte de la expresión @c{let}, la unica variable, @c{oldbuf} se
    une al valor devuelto por la expresión @c{(current-buffer)}. La variable,
    @c{oldbuf}, se utiliza para guardar un registro del búfer en el que
    estás trabajando y desde donde se copiara.

    El elemento o elementos de una varlist esta rodeado por un conjunto de
    paréntesis por lo que el intérprete Lisp puede distinguir la varlist del
    cuerpo del @c{let}. Como consecuencia, la lista de dos elementos dentro
    de la varlist está rodeada por un conjunto circunscrito de paréntesis.
    La línea tiene este aspecto:

    ..src > elisp
      (let ((oldbuf (current-buffer)))
        … )
    < src..

    Los dos paréntesis antes de @c{oldbuf} podrían sorprenderte si no fuera
    porque el primer paréntesis marca el límite de la varlist y el segundo
    paréntesis marca el inicio de la lista de dos elementos, @c{(oldbuf
    (current-buffer))}.

*** @c{save-excursion} en @c{append-to-buffer}

    El cuerpo de la expresión @c{let} dentro de @c{append-to-buffer} consiste
    de una expresión @c{save-excursion}.

    La función @c{save-excursion} guarda las posiciones de punto y marca, y
    restaura estas posiciones después de que las expresiones en el cuerpo de
    @c{save-excursion} completan su ejecución. Además, @c{save-excursion} no
    pierde de vista el búfer original, y lo restaura. Asi es como se utizia
    @c{save-excursion} en @c{append-to-buffer}.

    Por cierto, vale la pena señalar que una función Lisp normalmente se
    formatea de modo que todo lo que esta encerrado en un conjunto de multiples
    lineas se indente más a la derecha que el primer símbolo. En esta
    definición de función, @c{let} se indenta más que @c{defun}, y
    @c{save-excursion} se indenta más que @c{let}, asi:

    ..src > elisp
      (defun …
        …
        …
        (let…
          (save-excursion
            …
    < src..

    Esta convención de formato hace que sea fácil de ver que líneas en el
    cuerpo de @c{save-excursion} estan rodeadas por los parentesis asociados
    con @c{save-excursion}, de igual forma el mismo @c(save-excursion) esta
    rodeado por los paréntesis asociados con @c{let}:

    ..src > elisp
      (let ((oldbuf (current-buffer)))
        (save-excursion
          …
          (set-buffer …)
          (insert-buffer-substring oldbuf start end)
          …))
    < src..

    El uso de la función @c{save-excursion} puede ser visto como el proceso
    de llenar ranuras de una plantilla:

    ..src > elisp
      (save-excursion
        primer-expresion-en-el-cuerpo
        segunda-expresion-en-el-cuerpo
         …
        ultima-expresion-en-el-cuerpo)
    < src..

    En esta función, el cuerpo de @c{save-excursion} contiene solo una
    expresión, la expresión @c{let*}. Ya conoces la función @c{let}. La
    función @c{let*} es diferente. Posee un @'{*} en su nombre. Esto le
    permite a Emacs colocar cada variable de su varlist en secuencia, una
    después de otra.

    Su caracteristica fundamental es que las siguientes variables en la
    varlist puedan hacer uso de los valores establecidos por Emacs
    antes en la varlist. Vea la Seccion @l{#La expresión @c{let*}}.

    Vamos a omitir funciones como @c{let*} y nos centraremos en dos: la
    función @c{set-buffer} y la función @c{insert-buffer-substring}.

    En los viejos tiempos, la expresión @c{set-buffer} era simplemente:

    ..src > elisp
      (set-buffer (get-buffer-create buffer))
    < src..

    pero ahora es

    ..src > elisp
      (set-buffer append-to)
    < src..

    @c{append-to} esta unido al @c{(get-buffer-create-buffer)} anterior en la
    expresión @c{let*}. Esta union extra no sería necesaria excepto que
    @c{append-to} se utiliza despues en la varlist como un argumento para
    @c{get-buffer-window-list}.

    La definición de la función @c{append-to-buffer} inserta texto desde el
    búfer en el que te encuentras actualmente al buffer que se indique. Sucede
    que @c{insert-buffer-substring} copia texto desde otro búfer al búfer
    actual, justo al reves––es por ello que la definición @c{append-to-buffer}
    inicia con un @c{let} que une el símbolo local @c{oldbuf} al valor devuelto
    por @c{current-buffer}.

    La expresión @c{insert-buffer-substring} es la siguiente:

    ..src > elisp
      (insert-buffer-substring oldbuf start end)
    < src..

    La función @c{insert-buffer-substring} copia una cadena @e{desde} el
    búfer especificado como su primer argumento e inserta la cadena dentro
    del búfer actual. En este caso, el argumento de
    @c{insert-buffer-substring} es el valor de la variable creada y vinculada
    por @c{let}, es decir, el valor de @c{oldbuf}, que era el búfer
    actual cuando diste el comando @c{append-to-buffer}.

    Después de que @c{insert-buffer-substring} ha hecho su trabajo,
    @c{save-excursion} restaurará la acción al búfer original y
    @c{append-to-buffer} habrá hecho su trabajo.

    Escrito en forma de esqueletal, los funcionamientos del cuerpo se ven asi:

    ..src > elisp
      (let (unir-oldbuf-al-valor-del-buffer-actual)
        (save-excursion                       ; guarda un registro del buffer.
          cambio-de-buffer
          insertar-subcadena-desde-oldbuf-a-buffer)

        regresar-al-buffer-original-al-terminar
      dejar-que-el-siginificado-local-de-oldbuf-desaparacesca-al-terminar
    < src..

    En resumen, @c{append-to-buffer} funciona de la siguiente manera: guarda el
    valor del búfer actual en la variable @c{oldbuf}. Obtiene el nuevo búfer
    (creando uno si es necesario) y cambia la atención de Emacs a este. Usando
    el valor de @c{oldbuf}, inserta la región del texto desde el búfer antiguo
    dentro del nuevo búfer; y luego usando @c{save-excursion}, regresa al búfer
    original.

    Al observar @c{append-to-buffer}, se ha explorado una función bastante
    compleja. Muestra como usar @c{let} y @c{save-excursion}, y como cambiar
    y volver desde otro buffer. Muchas definiciones de función usan @c{let},
    @c{save-excursion}, y @c{set-buffer} de esta manera.

** Repaso

   Aquí está un breve resumen de las diferentes funciones descritas en este
   capítulo.

   - @c(describe-function), @c(describe-variable) ::

     Imprime la documentación de una función o variable. Convencionalmente
     unidas a @k{C-h f} y @k{C-h v}.

   - @c(find-tag) ::

     Encuentra el fichero que contiene el codigo de una función o variable y
     cambia a dicho buffer, colocando el punto al inicio del elemento.
     Convencionalmente ligado a @k{M-.} (esto es un punto luego de la tecla
     @k{META}).

   - @c(save-excursion) ::

     Guarda la posicion de punto y marca y restaura sus valores tras evaluar
     los argumentos de @c{save-excursion}. Ademas, recuerda el buffer actual
     y regresa a el.

   - @c(push-mark) ::

     Asigna la marca a una posicion y guarda el valor de la marca previa en
     el anillo de marcas. La marca es una ubicacion en el búfer que
     mantendra su posición relativa, incluso si se añade o borra texto del
     búfer.

   - @c(goto-char) ::

     Establece el punto a la ubicacion especificada por el valor del
     argumento, que puede ser un número, una marca, o una expresión que
     devuelve el número de una posición, como @c{(point-min)}.

   - @c(insert-buffer-substring) ::

     Copia una región de texto desde un búfer que se pasa a la función como
     un argumento e inserta la región dentro del búfer actual.

   - @c(mark-whole-buffer) ::

     Marca el búfer completo como una región. Normalmente unido a @k{C-x h}.

   - @c(set-buffer) ::

     Cambia la atención de Emacs a otro búfer, pero no se muestra el cambio
     en la ventana. Se utiliza cuando un programa y no humano trabaja en un
     búfer distinto.

   - @c(get-buffer-create), @c(get-buffer) ::

     Busca el búfer con nombre o crea uno si el búfer con ese nombre no
     existe. La función @c{get-buffer} devuelve @c{nil} si el nombre del
     búfer no existe.

** Ejercicios

   - Escribe tu propia definición de la función @c{simplified-end-of-buffer};
     luego pruebala para ver si funciona.

   - Utiliza @c{if} y @c{get-buffer} para escribir una función que imprima un
     mensaje que te diga si un buffer existe.

   - Usando @c{find-tag}, busca el codigo de la función @c{copy-to-buffer}

* Algunas Funciones Más Complejas

  En este capítulo, nos basamos en lo que hemos aprendido en los capítulos
  anteriores examinando funciones más complejas. La función @c{copy-to-buffer}
  ilustra el uso de dos expresiones @c{save-excursion} en una definición,
  mientras que la función @c{insert-buffer} ilustra el uso de un asterisco en
  una expresión @c{interactive}, el uso de @c{or}, y la importante distinción
  entre un nombre y el objeto al que el nombre hace referencia.

** La definición de @c{copy-to-buffer}

   Después de comprender cómo trabaja @c{append-to-buffer}, es fácil entender
   @c{copy-to-buffer}. Esta función copia texto dentro de un búfer, pero en
   lugar de agregarlo al segundo búfer, sustituye todo el texto anterior en
   el segundo búfer.

   El cuerpo de @c{copy-to-buffer} tiene este aspecto,

   ..src > elisp
     …
     (interactive "BCopy to buffer: \nr")
     (let ((oldbuf (current-buffer)))
       (with-current-buffer (get-buffer-create buffer)
         (barf-if-buffer-read-only)
         (erase-buffer)
         (save-excursion
           (insert-buffer-substring oldbuf start end)))))
   < src..

   La función @c{copy-to-buffer} tiene una expresión @c{interactive} mas
   sencilla que @c{append-to-buffer}.

   La definición dice:

   ..src > elisp
     (with-current-buffer (get-buffer-create buffer) …
   < src..

   En primer lugar, mira en la expresión más interna; que se evalua primero.
   Esta expresión inicia con @c{get-buffer-create buffer}. La función le indica
   al ordenador que utilice el búfer con el nombre específicado como aquel que
   quieres copiar, o si tal búfer no existe, que debe créarlo. Luego, la función
   @c{with-current-buffer} evalúa su cuerpo con este búfer temporal.

   (Esto demuestra otra forma de cambiar la atención de la computadora pero no
   por parte del usuario. La función @c{append-to-buffer} muestro como hacer lo
   mismo con @c{save-excursion} y @c{set-buffer}. @c{with-current-buffer} es un
   nuevo mecanismo, posiblemente mas sencillo.)

   La función @c{barf-if-buffer-read-only} envía un mensaje de error diciendo
   que el búfer es de solo lectura si no se puede modificar.

   La siguiente línea tiene la función @c{erase-buffer} como su único
   contenido. Este función borra el búfer.

   Finalmente, las últimas dos líneas contienen la expresión @c{save-excursion}
   con @c{insert-buffer-substring} como su cuerpo. La expresión
   @c{insert-buffer-substring} copia el texto desde el búfer en el que te
   encuentras (y no has visto que el computador cambie su atención, por lo que no
   sabes que ese búfer ahora se llama @c{oldbuf}).

   Por cierto, esto es lo que se entiende por ‘reemplazo’. Para reemplazar el
   texto Emacs borra el texto anterior y luego inserta el texto nuevo.

   A grandes rasgos, el cuerpo de @c{copy-to-buffer} se ve asi:

   ..src > elisp
     (let (enlazar-oldbuf-al-valor-del-bufer-actual)
         (con-el-bufer-al-que-estas-copiando
           (pero-no-borrar-o-copiar-a-un-bufer-de-solo-lectura)
           (erase-buffer)
           (save-excursion
             insertar-la-subcadena-de-oldbuf-en-el-bufer)))
   < src..

** La definición de @c{insert-buffer}

   @c{insert-buffer} es otra función relacionada con búfers. Este comando copia
   otro búfer @e{dentro} del búfer actual. Es lo contrario a @c{append-to-buffer}
   o @c{copy-to-buffer}, dado que copia una región de texto @e{desde} el búfer
   actual a otro búfer.

   Aquí examinamos en el código original. El código fue simplificado en 2003 y
   es mas dificil de entender.

   (Vea la Seccion @l{#Nuevo Cuerpo para @c{insert-buffer}}, para ver una
   discusión del nuevo cuerpo.)

   Además, este código ilustra el uso de @c{interactive} con un búfer que
   podría ser @:{read-only} (de solo lectura) y la importante distinción entre
   el nombre de un objeto y el objeto al que realmente hace referencia.

   Aquí está el código anterior:

   ..src > elisp
     (defun insert-buffer (buffer)
       "Insertar despues del punto el contenido de BUFFER.
     Coloca la marca despues del texto insertado.
     BUFFER puede ser un buffer o el nombre de un buffer."
       (interactive "*bInsert buffer: ")
       (or (bufferp buffer)
           (setq buffer (get-buffer buffer)))
       (let (start end newmark)
         (save-excursion
           (save-excursion
             (set-buffer buffer)
             (setq start (point-min) end (point-max)))
           (insert-buffer-substring buffer start end)
           (setq newmark (point)))
         (push-mark newmark)))
   < src..

   Al igual que con otras definiciones de función, se puede usar una plantilla
   para ver un esquema de la función:

   ..src > elisp
     (defun insert-buffer (buffer)
       "documentacion…"
       (interactive "*bInsert buffer: ")
       cuerpo…)
   < src..

*** La expresión interactiva en @c{insert-buffer}

    En @c{insert-buffer}, el argumento de la declaración @c{interactive} tiene
    dos partes, un asterisco, @'{*}, y @'{bInsert buffer: }.

**** Un búfer de solo lectura

     El asterisco se utliza cuando el búfer actual es un búfer de solo
     lectura––un búfer que no puede ser modificado. Si se llama a
     @c{insert-buffer} cuando el búfer actual es de solo lectura, se imprime un
     mensaje en el area de eco y el terminal puede emitir un beep o parpadear;
     no se permitira insertar nada en el búfer actual. El asterisco no tiene que
     ser seguido por un salto de linea para separarlo del siguiente argumento.

**** @'{b} en una expresión interactiva

     El siguiente argumento de la expresión interactiva inicia con una letra
     @'{b} minúscula. (Esto es diferente del código para @c{append-to-buffer},
     que utiliza una @'{B} mayúscula. Vea la Seccion @l{#La Definición de
     @c{append-to-buffer}}.) La @'{b} minúscula le indica al intérprete Lisp que
     el argumento de @c{insert-buffer} debe ser un buffer existente o su
     nombre. (La opcion @'{B} mayúscula permite la posibilidad que el búfer no
     exista.)  Emacs te pedira el nombre del búfer, ofreciendo un búfer por
     defecto, con el autocompletado de nombre habilitado. Si el búfer no existe,
     recibiras un mensaje que dice “No match” @%"(no concuerda); tu terminal
     tambien puede emitir un beep.

     El nuevo código simplificado genera una lista @c{interactive}. Este
     utiliza las funciones @c{barf-if-buffer-read-only} y @c{read-buffer} con
     las que ya estamos familiarizados y la forma especial @c{progn} con la que
     no lo estamos. (Se describira mas adelaste).

*** El cuerpo de la función @c{insert-buffer}

    El cuerpo de la función @c{insert-buffer} tiene dos partes principales: una
    expresión @c{or} y una expresión @c{let}. El propósito de la expresión
    @c{or} es asegurar que el argumento @c{buffer} esta unido a un búfer y no
    es solo el nombre de un búfer. El cuerpo de la expresión @c{let} contiene
    el código que copia el otro búfer dentro del búfer actual.

    A grades rasgos, las dos expresiones encajan asi en la función @c{insert-buffer}:

    ..src > elisp
      (defun insert-buffer (buffer)
        "documentacion…"
        (interactive "*bInsert buffer: ")
        (or …
            …
        (let (varlist)
            cuerpo-de-let… )
    < src..

    Para entender como la expresión @c{or} asegura que el argumento @c{buffer}
    esta unido a un buffer y no al nombre de un búfer, primero es necesario
    entender la función @c{or}.

    Antes de hacer esto, permíteme reescribir esta parte de la función
    utilizando @c{if} de esta manera puedes ver como se hace de una manera que
    resulta familiar.

*** @c{insert-buffer} con un @c{if} en lugar de un @c{or}

    El trabajo a realizar es asegurarse de que el valor de @c{buffer} sea un
    búfer en sí mismo y no el nombre de un búfer. Si el valor es el nombre, entonces
    debe optenerse el búfer en sí.

    Puedes imaginarte a tí mismo en una conferencia donde un acomodador está
    observando una lista con tu nombre en ella y mirándote: el acomodador sabe
    “asociar” tu nombre, no a tí; pero cuando el acomodador te encuentra y
    te toma el brazo, el acomodador llega a “asociarte” a tí.

    En Lisp, se podría describir esta situación así:

    ..src > elisp
      (if (not (tomar-al-invitado))
          (encontrar-y-tomar-del-brazo-al-invitado))
    < src..

    Queremos hacer lo mismo con un búfer––si no tenemos el búfer en sí,
    queremos conseguirlo.

    Usando un predicado llamado @c{bufferp} que nos informa si tenemos un búfer
    (en lugar de su nombre), podemos escribir el código de esta manera:

    ..src > elisp
      (if (not (bufferp buffer))              ; parte-if
          (setq buffer (get-buffer buffer)))  ; parte-then
    < src..

    Aquí, la prueba verdadero-o-falso de la expresión @c{if} es @c{(not (bufferp
    buffer))}; y la parte @e(then) es la expresión @c{(setq buffer (get-buffer
    buffer))}.

    En la prueba, la función @c{bufferp} devuelve cierto si su argumento es un
    búfer––sino falso si el argumento es el nombre del búfer. (El último
    carácter del nombre de la función @c{bufferp} es el carácter @'{p}; como
    vimos anteriormente, tal uso de @'{p} es una convención que indica que la
    función es un predicado, que es un término que significa que la función
    determinará si alguna propiedad es verdadera o falsa. Vea la Seccion
    @l(#Usando el tipo incorrecto de objeto como un argumento).)

    La función @c{not} precede la expresión @c{(bufferp buffer)}, así la prueba
    verdadero-o-falso es la siguente:

    ..src > elisp
      (not (bufferp buffer))
    < src..

    @c{not} es una función que devuelve verdadero si su argumento es falso y
    falso si su argumento es verdadero. Por lo que si @c{(bufferp buffer)}
    devuelve cierto, la expresión @c{not} devuelve falso y vice-versa: lo que es
    “no verdadero” es falso y lo que es “no falso” es verdadero.

    Usando esta prueba, la expresión @c{if} funciona de la siguiente manera:
    cuando el valor de la variable @c{buffer} es en realidad un búfer en
    lugar de su nombre, la prueba verdadero-o-falso devuelve falso y la
    expresión @c{if} no evalúa la parte then. Esto está bien, ya que no tenemos
    que hacer nada para la variable @c{buffer} si realmente es un búfer.

    Por otro lado, cuando el valor de @c{buffer} no es un buffer en sí, pero si
    el nombre de un buffer, la prueba verdadero-o-falso devuelve verdadero y se
    evalua la parte then de la expresión. En este caso, la parte then es
    @c{(setq buffer (get-buffer buffer))}. Esta expresión utiliza la función
    @c{get-buffer} para devolver un buffer en real, dado su nombre. Luego @c{setq}
    asigna la variable @c{buffer} reemplazando su valor anterior (que era el
    nombre del buffer).

*** El @c{or} en el cuerpo

    El propósito de la expresión @c{or} en la función @c{insert-buffer} es
    asegurar que el argumento @c{buffer} está asociado a un búfer y no solo al
    nombre de un búfer. La sección previa muestra como se podría haber hecho el
    trabajo usando una expresión @c{if}. Sin embargo, la función
    @c{insert-buffer} utiliza @c{or}. Para entender esto, es necesario entender
    como funciona @c{or}.

    Una función @c{or} puede tener cualquier número de argumentos. Esta evalúa
    un argumento a la ves y devuelve el valor del primero de sus argumentos que
    no es @c{nil}. Ademas, y esta es una caracteristica crucial de @c{or}, es no
    evalúar los argumentos posteriores después de regresar el primer valor
    no-@c{nil}.

    La expresión @c{or} se ve asi:

    ..src > elisp
      (or (bufferp buffer)
          (setq buffer (get-buffer buffer)))
    < src..

    El primer argumento de @c{or} es la expresión @c{(bufferp buffer)}. Esta
    expresión devuelve verdadero (un valor no-@c{nil}) si el búfer es realmente
    un búfer, y no solo el nombre de un búfer. En la expresión @c{or}, si este
    es el caso, la expresión @c{or} devuelve este valor verdadero y no evalúa la
    siguiente expresión––y esto es bueno para nosotros, ya que no queremos hacer
    nada al valor de @c{buffer} si realmente es un búfer.

    Por otro lado, si el valor de @c{(bufferp buffer)} es @c{nil}, si el valor
    de @c{buffer} es el nombre de un buffer, el intérprete Lisp evalúa el
    siguiente elemento de la expresión. Esta es la expresión @c{(setq buffer
    (get-buffer buffer))}. Esta expresión devuelve un valor no-@c{nil}, que es
    el valor para el que asigna la variable @c{buffer}––y este valor es un
    búfer en sí, no el nombre de un búfer.

    El resultado de todo esto es que el símbolo @c{buffer} siempre se enlaza a
    un búfer en sí en vez de al nombre de un búfer. Todo esto es necesario
    debido a que la función @c{set-buffer} en la línea siguiente solo funciona
    con un buffer en sí, no con el nombre de un búfer.

    A proposito, usando @c{or}, la escena con el acomodador se escribiria así:

    ..src > elisp
      (or (tomar-al-invitado) (encontrar-y-tomar-del-brazo-al-invitado))
    < src..

*** La expresión @c{let} en @c{insert-buffer}

    Después de asegurarse que la variable @c{buffer} se refiere a un buffer en
    sí y no solo al nombre de uno, la función @c{insert-buffer} continúa
    con una expresión @c{let}. Esta especifica tres variables locales,
    @c{start}, @c{end} y @c{newmark} y las une al valor inicial @c{nil}. Estas
    variables se utilizan dentro del resto de @c{let} y ocultan temporalmente
    cualquier otra ocurrencia de variables con el mismo nombre en Emacs hasta el
    final de @c{let}.

    El cuerpo de @c{let} contiene dos expresiones @c{save-excursion}. Primero,
    veremos la expresión interna @c{save-excursion} en detalle. La expresión
    se ve asi:

    ..src > elisp
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
    < src..

    La expresión @c{(set-buffer buffer)} cambia la atención de Emacs del
    búfer actual al buffer del que se copiara el texto. En ese búfer las
    variables @c{start} y @c{end} se asignan al inicio y al fin del búfer,
    usando los comandos @c{point-min} y @c{point-max}. Tenga en cuenta que
    aquí tenemos un ejemplo de cómo @c{setq} es capaz de asignar dos variables
    en la misma expresión. El primer argumento de @c{setq} se establece al valor
    del segundo, y su tercer argumento se establece al valor del cuarto.

    Después de evaluar el interior del cuerpo de @c{save-excursion},
    @c{save-excursion} restaura el búfer original, pero @c{start} y @c{end}
    retienen los valores del inicio y fin del búfer del que se copiara el texto.

    La expresión extena de @c{save-excursion} luce asi:

    ..src > elisp
      (save-excursion
        (expresion-interior-de-save-excursion
           (ir-al-nuevo-bufer-y-establecer-start-y-end)
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
    < src..

    La función @c{insert-buffer-substring} copia el texto @e{dento} del búfer
    actual @e{desde} la región indicada por @c{start} y @c{end} en el
    @c{búfer}. Puesto que la totalidad del segundo búfer se encuentra entre
    @c{start} y @c{end}, todo dentro del segundo búfer se copia el el bufer que
    se esta editando. A continuacion, el valor del punto, que será al fin del
    texto insertado, se registra en la variable @c{newmark}.

    Después evaluar el cuerpo del @c{save-excursion} externo, el punto y la
    marca se vuelven a colocar en su posicion original.

    Sin embargo, es conveniente ubicar una marca al fin del texto recien
    insertado y ubicar el punto al principio. La variable @c{newmark} registra
    el fin del texto insertado. En la última línea de la expresión @c{let}, la
    expresión @c{(push-mark newmark)} asigna una marca a esta posición. (La
    posición anterior de la marca aun es accesible; está grabada en el anillo de
    marcas y puedes volver a ella con @k{C-u C-SPC}.) Mientras tanto, el punto
    se encuentra al principio del texto insertado, que es donde estaba antes de
    llamar a la función de insercion, cuya posición fue guardada por la primer
    @c{save-excursion}.

    La expresión @c{let} completa se ve asi:

    ..src > elisp
      (let (start end newmark)
        (save-excursion
          (save-excursion
            (set-buffer buffer)
            (setq start (point-min) end (point-max)))
          (insert-buffer-substring buffer start end)
          (setq newmark (point)))
        (push-mark newmark))
    < src..

    Al igual que la función @c{append-to-buffer}, la función @c{insert-buffer}
    utiliza @c{let}, @c{save-excursion} y @c{set-buffer}. Además, la función
    ilustra una forma de utilizar @c{or}. Todas estas funciones son bloques de
    construccion que vamos a encontrar y utilizar una y otra vez.

*** Nuevo cuerpo para @c{insert-buffer}

    El cuerpo en la versión 22 de GNU Emacs es más confuso que en el original.

    Consta de dos expresiones

    ..src > elisp
        (push-mark
         (save-excursion
           (insert-buffer-substring (get-buffer buffer))
           (point)))

         nil
    < src..

    excepto que, y esto es lo que confunde a los principiantes, se hace un
    trabajo muy importante al interior de la expresión @c{push-mark}.

    La función @c{get-buffer} devuelve un búfer con el nombre proporcionado.
    Notaras que la función @e{no} se llama @c{get-buffer-create}; esta no crea
    un búfer si uno no existe ya. El búfer devuelto por @c{get-buffer}, un
    búfer existente, se pasa a @c{insert-buffer-substring}, que inserta todo el
    búfer (ya que no se especifica ninguna cosa más).

    La posición donde se inserta el buffer se registra por @c{push-mark}.
    Despues la función devuelve @c{nil}, el valor de su último comando. Dicho de
    otra manera, la función @c{insert-buffer} existe solo para producir un
    efecto secundario, insertando otro buffer, no para devolver ningun valor.

** Definición completa de @c{beginning-of-buffer}

   Ya se ha discutido la estructura básica de la función @c{beginning-of-buffer}.
   (Vea la Seccion @l{#Una definición simplificada de @c{beginning-of-buffer}}).
   Esta sección describe la parte compleja de la definición.

   Como se ha descrito anteriormente, cuando se invoca @c{beginning-of-buffer}
   sin argumento, mueve el cursor al inicio del búfer (en realidad, al inicio
   de la porción accesible del búfer), dejando la marca en la posición
   anterior. Sin embargo, cuando el comando se invoca con un número entre uno y
   diez, la función considera que ese número es una fracción del tamaño del búfer,
   medido en decenas, y Emacs mueve el cursor a dicha fracción del reccorrido
   desde el inicio del búfer. Por lo tanto, puedes llamar a esta función con el
   comando de teclado @k{M-<}, que moverá el cursor al principio del búfer, o
   con un comando de teclado como @k{C-u 7 M-<} que moverá el cursor a un 70%
   del recorrido a través del búfer. Si se utiliza un número mayor a diez como
   argumento, se movera al final del búfer.

   La función @c{beginning-of-buffer} puede llamarse con o sin argumentos. El
   uso del argumento es opcional.

*** Argumentos opcionales

    A menos que se diga lo contrario, Lisp espera que una función con un
    argumento en su definición de función sea llamada con un valor para ese
    argumento. Si esto no ocurre, se obtiene un error y un mensaje que dice
    @'{Wrong number of arguments} @%"(Número de argumentos erróneo).

    Sin embargo, los argumentos opcionales son una caracteristica de Lisp: se
    utiliza una @:{palabra clave} en concreto para decirle al intérprete Lisp
    que un argumento es opcional. La palabra clave es @c{&optional}. (El @'{&}
    al frente de @'{optional} es parte de la palabra clave.) En una definición
    de función, si un argumento va despues de la palabra clave @c{&optional}, no
    necesita pasar ningún valor para este argumento al llamar a la función.

    Por lo tanto la primera línea de la definición de función de
    @c{beginning-of-buffer} tiene este aspecto:

    ..src > elisp
      (defun beginning-of-buffer (&optional arg)
    < src..

    En lineas generales, toda la función se ve asi:

    ..src > elisp
      (defun beginning-of-buffer (&optional arg)
        "documentacion…"
        (interactive "P")
        (or (es-el-argumento-una-cons-cell argumento)
            (and ambos-transient-mark-mode-y-mark-active-son-verdadero)
            (push-mark))
        (let (determina-el-tamano-y-lo-establece)
        (goto-char
          (si-hay-un-argumento
              averigua-donde-ir
            de-otro-modo-va-a
            (point-min))))
         do-nicety
    < src..

    La función es similar a la función @c{simplified-beginning-of-buffer}
    excepto que la expresión @c{interactive} tiene @c{"P"} como argumento y la
    función @c{goto-char} es seguida por una expresión if-then-else que
    calcula donde poner el cursor si hay un argumento que no es un cons cell.

    (Puesto que no explico que es un @e(cons cell) en muchos capítulos, por
    favor, considera ignorar la función @c{consp}. Ve la Seccion @l{#Cómo se
    implementan las listas}, y la Seccion @l{info:elisp#Cons Cell Type<>"Cons
    Cell y Tipos de Listas"} en @e(El Manual de Referencia GNU Emacs Lisp)).

    La @c{"P"} en la expresión @c{interactive} le indica a Emacs cómo pasar a la
    funcion argumento prefijo, si es que hay uno, en su forma @"(plana) sin
    procesar. Un argumento prefijo se crea presionando la tecla @k{META} seguida
    por un número, o pulsando @k{C-u} y luego un número. (Si no escribes un
    número, @k{C-u} por defecto pasa un cons cell con un 4. Una @c{"p"}
    minúscula en la expresión @c{interactive} hace que la función convierta un
    argumento prefijo a un número.)

    La prueba verdadero-o-falso de la expresión @c{if} parace compleja, pero no
    lo es: se comprueba si @c{argumento} tiene un valor que no es @c{nil} y si
    es un cons cell. (Esto es lo que hace @c{consp}; comprueba si su argumento
    es un cons cell.) Si @c{argumento} tiene un valor distinto a @c{nil} (y no
    es un cons cell), que será el caso si @c{beginning-of-buffer} se llama con
    un argumento numerico, la prueba verdadero-o-falso devolverá verdadero y se
    evaluara la parte-then de la expresión @c{if}. Por otro lado, si
    @c{beginning-of-bufer} no se llama con un argumento, el valor de
    @c{argumento} será @c{nil} y se evaluara la parte-else de la expresión
    @c{if}. La parte-else es un simple @c{point-min}, y cuando este es el
    resultado, toda la expresión @c{goto-char} es @c{(goto-char (point-min))},
    que es cómo vimos la función @c{beginning-of-buffer} en su forma
    simplificada.

*** @c{beginning-of-buffer} con un argumento

    Cuando se llama a @c{beginning-of-buffer} con un argumento, se evalua una
    expresión que calcula que valor pasar a @c{goto-char}. A primera vista esta
    expresion es bastante compleja. Incluye una expresión @c{if} y mucha
    aritmética. Se ve así:

    ..src > elisp
      (if (> (buffer-size) 10000)
          ;; Evita el desbordamiento en buffers de gran tamaño!
          (* (prefix-numeric-value arg)
             (/ size 10))
        (/ (+ 10
              (* size (prefix-numeric-value arg)))
           10))
    < src..

    Como otras expresiones que parecen complejas, la expresión condicional
    dentro de @c{beginning-of-buffer} se puede desenredar viendola como partes
    de una plantilla, en este caso, la plantilla para una expresión
    if-then-else. En forma esquelética, la expresión se ve así:

    ..src > elisp
      (si (buffer-es-grande
          divide-el-tamaño-del-buffer-por-10-y-multiplicalo-por-arg
        de-otra-forma-utiliza-el-calculo-alternativo
    < src..

    La prueba verdadero-o-falso de la expresión @c{if} interna comprueba el
    tamaño del buffer. La razón de esto es que la vieja versión de Emacs 18
    utilizaba números que no superaban los ocho millones y en el siguiente
    calculo, el programador temía que Emacs pudiera intentar usar numeros
    demasiado grandes si el búfer fuese extenso. El término ‘desbordamiento’,
    que se menciona en el comentario, significa que los números son demaciado
    grandes. Las versiones más recientes de Emacs utilizan números mas grandes,
    pero este código no ha sido tocado, aunque solo sea porque la gente ahora
    mira búfers que son mucho, mucho mas grandes que antes.

    Hay dos casos: si el búfer es grande, o si no lo es.

**** Qué ocurre en un búfer de gran tamaño

     En @c{beginning-of-buffer}, la expresión @c{if} interna prueba si el tamaño
     del búfer es mayor a 10000 caracteres. Para hacer esto, se utiliza la
     función @c{>} y el calculo de @c{size} que previene de la expresión @c(let).

     En los viejos tiempos, se utilizaba la función @c{buffer-size}. No solo se
     llamo varias ocaciones esa funcion, sino que die el tamaño completo del
     búfer, no la parte accesible. El calculo tiene mucho más sentido cuando se
     maneja solo la parte accesible. (Vea la Seccion @l{#Reducir y Extender},
     para obtener más información sobre como centrar la atención en una parte
     ‘accesible’.)

     La linea se ve asi:

     ..src > elisp
       (if (> size 10000)
     < src..

     Cuando el búfer es grande, se evalua la parte @c(then) de la expresión
     @c{if}. Se lee así (después de formatearlo para facilitar la lectura):

     ..src > elisp
       (*
         (prefix-numeric-value arg)
         (/ size 10))
     < src..

     Esta expresión es una multiplicación, con dos argumentos para la función
     @c{*}.

     El primer argumento es @c{(prefix-numeric-value arg)}. Cuando se usa
     @c{"P"} como argumento para @c{interactive}, el valor pasado a la función
     como argumento es un “argumento prefijo en bruto”, y no un número. (Es un
     número en una lista). Para realizar el calculo, se necesita una conversión,
     y @c{prefix-numeric-value} hace el trabajo.

     El segundo argumento es @c{(/ size 10)}. Esta expresión divide el valor
     numérico por diez––el valor numérico del tamaño de la porción accesible del
     búfer. Esto produce un número que indica cuántos caracteres componen
     una decena parte del tamaño del búfer. (En Lisp, @c{/} se utiliza para la
     división, igual que @c{*} se utiliza para la multiplicación.)

     En la expresión de multiplicación como un todo, esta cantidad se
     multiplica por el valor del argumento prefijo––la multiplicación es la
     siguiente:

     ..src > elisp
       (* valor-numerico-del-argumento-prefijo-arg
          numero-de-caracteres-en-una-decima-parte-de-la-porcion-accesible-del-buffer)
     < src..

     Por ejemplo, si el argumento prefijo es @'{7}, el valor de una decima parte
     será multiplicado por 7 para dar una posición al 70% del trayecto.

     El resultado de todo esto es que si la porción accesible del búfer es
     grande, la expresión @c{goto-char} es la siguiente:

     ..src > elisp
       (goto-char (* (prefix-numeric-value arg)
                     (/ size 10)))
     < src..

     Esto coloca el cursor donde lo queremos.

**** Lo que sucede en un búfer pequeño

     Si el búfer contiene menos de 10000 caracteres, se lleva a cabo un calculo
     ligeramente diferente. Podrías pensar que esto no es necesario, ya que el
     primer calculo podría hacer el trabajo. Sin embargo, en un búfer pequeño,
     el primer método puede no colocar el cursor exactamente en la línea
     deseada; el segundo método hace un mejor trabajo.

     El código tiene este aspecto:

     ..src > elisp
       (/ (+ 10 (* size (prefix-numeric-value arg))) 10))
     < src..

     Para averiguar que ocure en este código debemos descubrir como se anidan
     las funciones entre paréntesis. Es mas fácil de leer si se reformate cada
     expresión, indentando la expresión que contiene:

     ..src > elisp
         (/
          (+ 10
             (*
              size
              (prefix-numeric-value arg)))
          10))
     < src..

     Observando los paréntesis, vemos que la operación mas profunda es
     @c{(prefix-numeric-value arg)}, que convierte el argumento prefijo en bruto
     a un número. En la siguiente expresión, este número se multiplica por el
     tamaño de la porción accesible del búfer:

     ..src > elisp
       (* size (prefix-numeric-value arg))
     < src..

     Esta multiplicación crea un número que puede ser mayor al tamaño del
     buffer––siete veces mayor si el argumento es 7, por ejemplo. Luego se suma
     diez a éste numero y finalmente el número es dividido por 10 para
     proporcionar un valor que es un carácter más grande que la posición
     porcentual en el búfer.

     El número que resulta de todo esto se pasa a @c{goto-char} y el cursor
     se mueve a ese punto.

*** Funcion @c{beginning-of-buffer} Completa

    Aquí está el texto completo de la función @c{beginning-of-buffer}:

    ..src > elisp
      (defun beginning-of-buffer (&optional arg)
        "Mueve el punto al principio del bufer;
      deja la marca en la posicion anterior.
      Con el prefijo \\[universal-argument],
      no pone la marca en la posicion anterior.
      Con un argumento numerico N,
      coloca el punto N/10 del camino desde el enicio.

      Si el bufer tiene activo narrowing,
      este comando utiliza el principio y el tamaño
      de la parte accesible del bufer.

      No use este comando en los programas Lisp!
      \(goto-char (point-min)) es mas rapido y evita
      tocar la marca."
        (interactive "P")
        (or (consp arg)
            (and transient-mark-mode mark-active)
            (push-mark))
        (let ((size (- (point-max) (point-min))))
          (goto-char (if (and arg (not (consp arg)))
                         (+ (point-min)
                            (if (> size 10000)
                                ;; Avoid overflow for large buffer sizes!
                                (* (prefix-numeric-value arg)
                                   (/ size 10))
                              (/ (+ 10 (* size (prefix-numeric-value arg)))
                                 10)))
                       (point-min))))
        (if arg (forward-line 1)))
    < src..

    Excepto por dos pequeños puntos, la discusión anterior muestra cómo funciona
    esta función. El primer punto se refiere a un detalle en la cadena de
    documentación, y el segundo se refiere a la última línea de la función.

    En la cadena de documentación, se hace referencia a una expresión:

    ..example >
      \\[universal-argument]
    < example..

    Se usa Un @'{\\} antes del primer corchete de esta expresión. Este @'{\\} le
    indica al intérprete Lisp que sustituya cualquier clave qué se encuentre
    dentro de @'{[…]} por su convinacion de teclado actual. En el caso de
    @c{universal-argument}, suele ser @k{C-u}, pero podría ser distinta. (Véa la
    Sección @l{info:elisp#Documentation Tips<>Consejos para Cadenas de
    Documentación} en @e(El Manual de Referencia de GNU Emacs Lisp), para más
    información.)

    Finalmente, la última línea del comando @c{beginning-of-buffer} indica mover
    el punto al inicio de la siguiente línea si el comando se invoca con un
    argumento:

    ..src > elisp
      (if arg (forward-line 1)))
    < src..

    Esto pone el cursor al inicio de la primer línea despues de la posicion
    inidicada en decenas en el búfer. Esto significa que el cursor siempre se
    localiza @e{al menos} las decenas solicitadas del recorrido del búfer, esta
    es una sutiliza, quizás, no necesaria, pero que, si no ocurriera, seguro
    generaria quejas.

    Por otro lado, tambien significa que si se especifica el comando con @k{C-u},
    pero sin un número, es decir, si el ‘argumento prefijo en bruto’ simplemente
    es un cons cell, entonces el comando te coloca al inicio de la segunda línea
    … no sé si se pretende esto o si nadie ha tratado el código para evitar que
    esto suceda.

** Repaso: Algunas Funciones Más Complejas <> Repaso

   He aquí un breve resumen de algunos de los temas cubiertos en este capítulo.

   - @c(or) ::

     Evalúa cada argumento en secuencia, y devuelve el valor del primer
     argumento que no es @c{nil}, si ninguno devuelve un valor que no sea
     @c{nil}, devuelve @c{nil}. En resumen, devuelve el primer valor verdadero
     de los argumento; devuelve un valor verdadero si uno @e{o} cualquiera de
     los otros es verdadero.

   - @c(and) ::

     Evalúa cada argumento en secuencia, y si alguno es @c{nil}, devuelve
     @c{nil}; si ninguno es @c{nil}, devuelve el valor del último argumento. En
     resumen, devuelve un valor verdadero solo si todos los argumentos son
     verdaderos; devuelve un valor verdadero si uno @e{y} cada uno de los otros
     son verdadero.

   - &optional ::

     Una palabra clave utilizada para indicar que un argumento en una definición
     de función es opcional; esto significa que la función se puede evaluar sin
     el argumento, si se desea.

   - @c(prefix-numeric-value) ::

     Convierte el ‘argumento prefijo en bruto’ producido por @c{(interactive
     "P")} en un valor numérico.

   - @c(forward-line) ::

     Mueve el punto hacia adelante al principio de la siguiente línea, o si el
     argumento es mayor a uno, hacia delante varias líneas. Si no se puede mover
     tan lejos hacia delante como se supone, @c{forward-line} va hacia adelante
     tan lejos como pueda y luego devuelve un conteo del número de líneas
     adicionales que no se pudo mover.

   - @c(erase-buffer) ::

     Elimina todo el contenido del búfer actual.

   - @c(bufferp) ::

     Devuelve @c{t} si su argumento es un búfer; de otro modo devuelve
     @c{nil}.

** Ejercicio con el argumento @c{opcional}

   Escribe una función interactiva con un argumento opcional que comprueve si su
   argumento, un número, es mayor que o igual a, o de lo contrario, menor que el
   valor de @c{fill-column}, y lo informe, en un mensaje. Sin embargo, si no
   pasas un argumento a la función, utiliza 56 como valor por defecto.

* Reducir y Extender

  La reduccion es una funcionalidad de Emacs que hace posible que puedas
  focalizarte en una parte específica de un búfer, y trabajar sin cambiar
  accidentalmente otras partes. La reduccion normalmente se deshabilita ya que
  puede confundir a los principiantes.

  Con la reduccion, el resto del búfer se hace invisible, como si no estuviera
  alli. Esto es una ventaja si, por ejemplo, se quiere reemplazar una palabra en
  una parte del búfer pero no en otra: limitas la parte que deseas y el
  reemplazo se lleva a cabo solo en esa sección, no en el resto del búfer. Las
  búsquedas solo funcionarán con la región reducida, no fuera de ella, de esta
  forma si estás reparando una parte de un documento, puedes mantener fuera la
  parte que no necesitas. (El atajo asociado a @c{narrow-to-region} es @k{C-x n
  n}.)

  Sin embargo, la reduccion hace invisible el resto del búfer, lo que puede
  asustar a quien invoca inadvertidamente la reduccion y piensa que ha eliminado
  una parte de su fichero. Ademas, el comando @c{undo} (usualmente ligado
  a @k{C-x u}) no desactiva la reduccion (ni debe hacerlo), por lo que las personas
  pueden llegar a desesperarse si no saben que pueden devolver el resto del
  buffer visible cor el comando @c{widen} que es @k{C-x n w}.)

  La reduccion es igual de util para el intérprete Lisp como para un humano.
  Con frecuencia, una función Emacs Lisp está diseñada para trabajar solo en
  parte de un búfer; o por el contrario, una función Emacs Lisp necesita
  trabajar en todo un búfer que ha sido reducido. La función @c{what-line}, por
  ejemplo, elimina la reduccion de un búfer, si este tiene alguna reduccion y
  al terminar su trabajo, restaura la reduccion. Por otro lado, la función
  @c{count-lines} utiliza la reduccion para restringirse a sí misma solo a la
  porción del búfer en la que se está interesado y luego restablece la situación
  anterior.

** La forma especial @c{save-restriction}

   En Emacs Lisp, se puede utilizar la forma especial @c{save-restriction} para
   llevar un registro de cualquier reduccion en efecto. Cuando el intérprete
   Lisp se encuentra con @c{save-restriction}, ejecuta el código en el cuerpo
   de la expresión @c{save-restriction}, y luego deshace cualquier cambio en la
   reduccion que el código proboco. Si, por ejemplo, el búfer es reducido y el
   código que sigue al comando @c{save-restriction} se deshace de la reduccion,
   @c{save-restriction} devuelve el búfer a su región reducida.  En el comando
   @c{what-line}, cualquier reduccion del búfer es deshecha por el comando
   @c{widen} inmediatamente despues del comando @c{save-restriction}. Se
   restaura cualquier reduccion original justo antes de finalizar la función.

   La plantilla para una expresión @c{save-restriction} es simple:

   ..src > elisp
     (save-restriction
       cuerpo… )
   < src..

   El cuerpo de @c{save-restriction} es una o más expresiones que seran evaluadas
   de forma secuencial por el intérprete Lisp.

   Finalmente, un punto a tener en cuenta: cuando utilices @c{save-excursion}
   y @c{save-restriction} a la vez, una detras de la otra, debes utilizar
   @c{save-excursion} primero. Si lo escribes en el orden inverso, es posible
   que no registre la reduccion en el búfer al que emacs debe cambiar Emacs
   despues de llamar a @c{save-excursion}. Por lo tanto, cuando escribas a la
   vez @c{save-excursion} y @c{save-restriction} debe ser así:

   ..src > elisp
     (save-excursion
       (save-restriction
         cuerpo…))
   < src..

   En otras circunstancias, cuando no se escriban a la vez, las formas
   especiales @c{save-excursion} y @c{save-restriction} deben escribirse en el
   orden adecuado para la función.

   Por ejemplo,

   ..src > elisp
     (save-restriction
       (widen)
       (save-excursion
       cuerpo…))
   < src..

** @c{what-line}

   El comando @c{what-line} informa el número de la línea en la que el cursor
   esta colocado. La función ilustra el uso de los comandos @c{save-restriction}
   y @c{save-excursion}. Aquí está el texto original de la función:

   ..src > elisp
     (defun what-line ()
       "Imprime el numero de linea actual (en el bufer) del punto."
       (interactive)
       (save-restriction
         (widen)
         (save-excursion
           (beginning-of-line)
           (message "Line %d"
                    (1+ (count-lines 1 (point)))))))
   < src..

   (En versiones recientes de GNU Emacs, la función @c{what-line} se ha ampliado
   para informarte el numero de linea en un búfer reducido, asi como el número
   de línea en un búfer extendido. La versión reciente es más compleja que la
   versión que se muestra aqui. Si te sientes aventurero, puede que quieras
   verla despues de averiguar como funciona esta version. Probablemente
   necesites utilizar @k{C-h f} @%c(describe-function). La nueva versión
   utiliza un condicional para determinar si se ha reducido el búfer.

   (También, utiliza @c{line-number-at-pos}, que entre otras expresiones
   sencillas, como @c{(goto-char (point-min))}, mueve el punto al inicio de la
   línea actual con @c{(forward-line 0)} en lugar de @c{beginning-of-line}.)

   La función @c{what-line} que se muestra aqui tiene una línea de documentación
   y es interactiva, como es de esperar. Las dos líneas siguientes utilizan las
   funciones @c{save-restriction} y @c{widen}.

   La forma especial @c{save-restriction} observa cualquier reduccion activa, en
   el buffer actual y restaura la reduccion despues de evaluar el código de su
   cuerpo.

   La forma especial @c{save-restriction} es seguida por @c{widen}. Esta función
   deshace cualquier reduccion que pudo haber tenido el búfer actual cuando se
   llama a @c{what-line}. (La reduccion que esta alli es la reduccion que
   @c{save-restriction} recuerda.) Esta ampliación hace posible que los comandos
   para el conteo de lineas cuenten desde el inicio del búfer. De lo contrario,
   se habría limitado a contar dentro de la región accesible. Cualquier
   reduccion original se restaura justo antes de completar la funcion por la
   forma especial @c{save-restriction}.

   La llamada a @c{widen} va seguida por @c{save-excursion}, que guarda la
   posición del cursor (es decir, el punto) y la marca, y los restaura después
   despues de que el código en el cuerpo de @c{save-excursion} utiliza la
   función @c{beginning-of-line} para mover el punto.

   (Ten en cuenta que la expresión @c{(widen)} ocurre entre las formas
   especiales @c{save-restriction} y @c{save-excursion}. Cuando escribas las dos
   expresiones @c{save-…} consecutivamente, escribe @c{save-excursion} primero.)

   Las dos últimas líneas de la función @c{what-line} son funciones para contar
   el número de líneas en el búfer y luego imprimir el número en el área de eco.

   ..src > elisp
     (message "Line %d"
              (1+ (count-lines 1 (point)))))))
   < src..

   La función @c{message} imprime un mensaje de una línea en la parte inferior
   de la pantalla de Emacs. El primer argumento esta dentro de comillas y se
   imprime como una cadena de caracteres. Sin embargo, contiene una expresión
   @'{%d} para imprimir el siguiente argumento. @'{%d} imprime el argumento como
   un decimal, por lo que el mensaje dirá algo como @'{Línea 243}.

   El número que se imprime en lugar del @'{%d} se calcula por la última línea
   de la función:

   ..src > elisp
     (1+ (count-lines 1 (point)))
   < src..

   Lo que esto hace es contar las líneas desde la primer posición del búfer
   indicada por el @c{1}, hasta @c{(point)}, y luego sumar uno a este número.
   (La función @c{1+} suma uno a su argumento.) Se suma uno porque la línea 2
   tiene solo una línea antes de ella, y @c{count-lines} cuenta solo las líneas
   @e{antes} de la línea actual.

   Después que @c{count-lines} termina su trabajo, y se imprime el mensaje en el
   área de eco, la función @c{save-excursion} restaura el punto y marca a sus
   posiciones originales; y @c{save-restriction} restaura la reduccion original,
   si la hubiera.

** Ejercicio con Reduccion

   Escribe una función que muestre los primeros 60 caracteres del búfer actual,
   incluso si has reducido el búfer a la mitad de modo que la primer línea sea
   inaccesible. Restaura el punto, marca y la reduccion. Para este ejercicio,
   necesitas utilizar todo un popurri de funciones, incluyendo
   @c{save-restriction}, @c{widen}, @c{goto-char}, @c{point-min}, @c{message}, y
   @c{buffer-substring}.

   (@c{buffer-substring} es una función que no aun no se menciona, tendrás que
   investigarla por tu cuenta; o quizás tengas que utilizar
   @c{buffer-substring-no-properties} o @c{filter-buffer-substring} …, u otras
   funciones. Las propiedades de texto son una funcionalidad que no sera
   discutida aquí. Vea la Seccion @l{info:elisp#Text Properties<>Propiedades de
   Texto} en @e(El Manual de Referencia de Emacs Lisp).)

   Además, ¿realmente se necesita @c{goto-char} o @c{point-min}?  ¿O se puede
   escribir la función sin ellas?

* @c{car}, @c{cdr}, @c{cons}: Funciones fundamentales

  En Lisp, @c{car}, @c{cdr}, y @c{cons} son funciones fundamentales. La función
  @c{cons} se utiliza para construir listas, y las funciones @c{car} y @c{cdr}
  se utilizan para desmontarlas.

  En el recorrido a través de la función @c{copy-region-as-kill}, veremos @c{cons},
  asi como dos variantes de @c{cdr}, llamadas @c{setcdr} y @c{nthcdr}. (Véa la
  Sección @l{#@c{copy-region-as-kill}}.)

  El nombre de la función @c{cons} no es irazonable: es una abreviatura de la
  palabra ‘construct’ @%"(construir). Por otra parte, el origen de los nombres
  @c{car} y @c{cdr}, es esoterico: @c{car} es un acrónimo de la frase ‘Contents
  of the Address part of the Register’ @%"(Contenidos de las Direcciónes parte
  del Registro); y @c{cdr} (pronunciado ‘could-er’) es un acrónimo de la frase
  ‘Contents of the Decrement part of the Register’ @%"(Contenidos de la parte de
  Decremento del Registro). Estas frases se refieren a piezas específicas de
  hardware en el ordenador en el que se desarrollo el Lisp original. Ademas de
  ser obsoletas, las frases han sido completamente irrelevantes por más de 25
  años para cualquiera que piense en Lisp. No obstante, aunque algunos pocos
  académicos valientes han empezado a utilizar nombres más razonables para estas
  funciones, los viejos términos aun continuan en uso. En particular, porque los
  términos se utilizan en el código fuente de Emacs Lisp, los usaremos en esta
  introducción.

** @c{car} y @c{cdr}

   El @c{car} de una lista es sencillamente, el primer elemento de la lista. De
   este modo, el @c{car} de la lista @c{(rosa violeta margarita tulipan)} es
   @c{rosa}.

   Si estás leyendo esto en GNU Emacs, puedes verlo evaluando lo siguiente:

   ..src > elisp
     (car '(rosa violeta margarita tulipan))
   < src..

   Después de evaluar la expresión, aparecerá @c{rosa} en el área de eco.

   Claramente, un nombre más razonable para la función @c{car} sería @c{first} y
   esto es con frecuencia lo que se sugiere.

   @c{car} no elimina el primer elemento de la lista; solo informa de lo que
   es. Después de aplicar @c{car} a una lista, la lista sigue siendo la misma
   que antes. En la jerga, @c{car} es ‘no destructiva’. Esta caracteristica
   resulta ser importante.

   El @c{cdr} de una lista es el resto de la lista, es decir, la función @c{cdr}
   devuelve la parte de la lista que sigue al primer elemento. Por lo tanto,
   mientras que el @c{car} de la lista @c{'(rosa violeta margarita tulipan)} es
   @c{rosa}, el resto de la lista, el valor devuelto por la función @c{cdr}, es
   @c{(violeta margarita tulipan)}.

   Puedes ver esto evaluando lo siguiente del modo habitual:

   ..src > elisp
     (cdr '(rosa violeta margarita tulipan))
   < src..

   Al evaluar esto, aparece @c{(violeta margarita tulipan)} en el área de eco.

   Al igual que @c{car}, @c{cdr} no elimina los elementos de la
   lista––simplemente devuelve un informe del segundo y los subsiguientes
   elementos presentes.

   A propositio, en el ejemplo, se cita la lista de flores. De otra forma, el
   intérprete Lisp intentaría evaluar la lista llamando a @c{rosa} como una
   función. En este ejemplo, no queremos hacer esto.

   Claramente, un nombre más razonable para @c{cdr} sería @c{rest} @%"(resto).

   (Hay una lección aquí: Cuando des nombre a nuevas funciones, considera muy
   cuidadosamente lo que estes haciendo, ya que puedes adherirte a los nombres
   mas tiempo del esperado. La razón por la que este documento perpetúa estos
   nombres se debe a que el código fuente de Emacs Lisp usa, y de no usarlos,
   tendrias dificultades para leer el codigo; por favor, intenta evitar usar
   estos términos por tu cuenta. Las personas que vengan después te lo
   agradecerán.

   Cuando se aplican @c{car} y @c{cdr} a una lista compuesta por símbolos, como
   la lista @c{(pino abeto roble arce)}, el elemento de la lista devuelto por la
   función @c{car} es el símbolo @c{pino} sin ningun paréntesis alrededor.
   @c{pino} es el primer elemento en la lista. Sin embargo, el @c{cdr} de la
   lista es una lista en si misma, @c{(abeto roble arce)}, como puedes observar al
   evaluar las siguientes expresiones:

   ..src > elisp
     (car '(pino abeto roble arce))

     (cdr '(pino abeto roble arce))
   < src..

   Por otro lado, en una lista de listas, el primer elemento es en sí mismo una
   lista. @c{car} devuelve este primer elemento como una lista. Por ejemplo, la
   siguiente lista contiene tres sub-listas, una lista de carnívoros, una lista
   de herbívoros y una lista de mamíferos:

   ..src > elisp
     (car '((leon tigre leopardo)
            (gacela antilope cebra)
            (ballena delfin foca)))
   < src..

   En este ejemplo, el primer elemento de @c{car} de la lista es la lista de
   carnívoros, @c{(leon tigre leopardo)}, y el resto de la lista es
   @c{((gacela antilope cebra) (ballena delfin foca))}.

   ..src > elisp
     (cdr '((leon tigre leopardo)
            (gacela antilope cebra)
            (ballena delfin foca)))
   < src..

   vale la pena decir nuevamente que @c{car} y @c{cdr} son no destructivos––es
   dicir, no modifican ni cambian las listas a las que se aplican. Esto es muy
   importante para su uso.

   En el primer capítulo, en la discusión sobre los átomos, dije que en Lisp,
   “ciertos tipos de átomos, como un arreglo, pueden ser separados en partes;
   pero el mecanismo para hacer esto es diferente del mecanismo para separar una
   lista. Para Lisp, los átomos de una lista son indivisibles.” (Vea la Seccion
   @l{#Átomos Lisp}.) Las funciones @c{car} y @c{cdr} se utilizan para dividir
   listas y se consideran fundamentales en Lisp. Ya que no se puede dividir o
   tener acceso a las partes de un arreglo, un arreglo se considera un
   átomo. Por otro lado, la otra función fundamental, @c{cons}, puede armar o
   construir una lista, pero no un arreglo. (Los arreglos se manejan mediante
   funciones especificas de arreglos. Vea la Seccion
   @l{info:elisp#Arrays<>Arreglos} en el @e(El Manual de Referencia de GNU Emacs
   Lisp).)

** @c{cons}

   La función @c{cons} construye listas; que es lo opuesto a @c{car} y @c{cdr}.
   Por ejemplo, se puede utilizar @c{cons} para hacer una lista de cuatro elementos
   de la lista de tres elementos, @c{(abeto roble arce)}:

   ..src > elisp
     (cons 'pino '(abeto roble arce))
   < src..

   Después de evaluar esto, veras aparecer

   ..src > elisp
     (pino abeto roble arce)
   < src..

   en el área de eco. @c{cons} produce una nueva lista en la que el elemento es
   seguido por los elementos de la lista original.

   Con frecuencia decimos que ‘@c{cons} coloca un nuevo elemento al principio de
   una lista; que agrega o empuja el elemento en la lista’, pero esta frase
   puede ser engañosa, ya que @c{cons} no modifica una lista existente, sino que
   crea una nueva.

   Al igual que @c{car} y @c{cdr}, @c{cons} es no destructivo.

   @c{cons} debe tener una lista a unir.@n{9} No puedes iniciar de la nada
   absoluta. Si estás construyendo una lista, es necesario proporcionar al menos
   una lista vacía al inicio. Aquí hay una serie de expresiones @c{cons} que
   construyen una lista de flores. Si está leyendo esto en GNU Emacs, puedes
   evaluar cada una de las expresiones para corroborar el resultado.

   ..srci > elisp
     > (cons 'tulipan ())
     (tulipan)

     > (cons 'margarita '(tulipan))
     (margarita tulipan)

     > (cons 'violeta '(margarita tulipan))
     (violeta margarita tulipan)

     > (cons 'rosa '(violeta margarita tulipan))
     (rosa violeta margarita tulipan)
   < srci..

   En el primer ejemplo, la lista vacía se muestra como @c{()} y se construye
   una lista compuesta por @c{tulipan} seguida por la lista vacía. Como puedes
   ver, la lista vacía no se muestra en la lista que fué construida. Todo lo que
   ves es @c{(tulipan)}. La lista vacía no cuenta como un elemento de una
   lista porque no hay nada en una lista vacía. En terminos generales, una lista
   vacía es invisible.

   El segundo ejemplo, @c{(cons 'margarita '(tulipan))} construye una nueva
   lista de dos elemento colocando @c{margarita} delante de @c{tulipan}; y el
   tercer ejemplo construye una lista de tres elementos colocando @c{violeta}
   delante de @c{margarita} y @c{tulipan}.

*** Descubrir la longitud de una lista: @c{length}

    Pueden averiguar cuántos elementos hay en una lista utilizando la función
    Lisp @c{length}, como en los siguientes ejemplos:

    ..srci > elisp
      > (length '(tulipan))
      1
      > (length '(margarita tulipan))
      2
      > (length (cons 'violeta '(margarita tulipan)))
      3
    < srci..

    En el tercer ejemplo, la función @c{cons} se utiliza para construir una
    lista de tres elementos que se pasa como argumento a la función @c{length}.

    También podemos utilizar @c{length} para contar el número de elementos en
    una lista vacía:

    ..srci > elisp
      > (length ())
      0
    < srci..

    Como era de esperar, el número de elementos en una lista vacía es cero.

    Un experimento interesante es averiguar qué ocurre si se intenta encontrar
    la longitud de ninguna lista; es decir, si se intenta llamar a @c{length}
    sin darle un argumento, ni siquiera una lista vacía:

    ..src > elisp
      (length )
    < src..

    La que se ve, si evalúas esto, es el mensaje de error

    ..example >
      Lisp error: (wrong-number-of-arguments length 0)
    < example..

    Esto significa que la función recibe un número incorrecto de argumentos,
    cero, cuando se espera algún otro número de argumentos. En este caso, se
    espera un argumento, el argumento es una lista cuya longitud mide la
    función. (Ten en cuenta que @e{una} lista es @e{un} argumento, incluso si la
    lista tiene muchos elementos en su interior.)

    La parte del mensaje de error que dice @'{length} es el nombre de la
    función.

** @c{nthcdr}

   La función @c{nthcdr} se asocia con la función @c{cdr}. Lo que hace es tomar
   la @c{cdr} de una lista repetidamente.

   Si tomas el @c{cdr} de la lista @c{(pino abeto roble arce)}, te devuelve la
   lista @c{(abeto roble arce)}. Si repites esto al retorno, devolverá la lista
   @c{(roble arce)}. (Por supuesto, repetir @c{cdr} en la lista original solo
   dará el @c{cdr} original, ya que la función no cambia la lista. Necesitas
   evaluar el @c{cdr} del @c{cdr} y así sucesivamente.) Si esto contiúa,
   finalmente se devuelve una lista vacía, que en este caso, en vez de mostrarse
   como @c{()} se muestra como @c{nil}.

   Para comprovarlo, aquí hay una serie de @c{cdr}s repetidos.

   ..srci > elisp
     > (cdr '(pino abeto roble arce))
     (abeto roble arce)
     > (cdr '(abeto roble arce))
     (roble arce)
     > (cdr '(roble arce))
     (arce)
     > (cdr '(arce))
     nil
     > (cdr 'nil)
     nil
     > (cdr ())
     nil
   < srci..

   También puedes hacer varios @c{cdr}s sin imprimir los valores intermedios, de
   esta forma:

   ..srci > elisp
     > (cdr (cdr '(pino abeto roble arce)))
     (roble arce)
   < srci..

   En este ejemplo, el intérprete Lisp primero evalúa la lista mas interna. La
   lista mas interna se cita, por lo que solo pasa la lista tal cual al @c{cdr}
   interno. Este @c{cdr} pasa una lista formada por el segundo y los subsiguientes
   elementos de la lista al @c{cdr} externo, que produce una lista compuesta del
   tercer y los subsiguientes elementos de la lista original. En este ejemplo, la
   función @c{cdr} se repite y devuelve una lista que consiste en la lista
   original sin sus primeros dos elementos.

   La función @c{nthcdr} hace lo mismo que repetir la llamada a @c{cdr}. En el
   siguiente ejemplo, el argumento 2 se pasa a la función @c{nthcdr}, junto con
   la lista, y el valor devuelto es la lista sin sus dos primeros elementos, que
   es exactamente los mismos que repetir dos veces @c{cdr} en la lista:

   ..srci > elisp
     > (nthcdr 2 '(pino abeto roble arce))
     (roble arce)
   < srci..

   Utilizando la lista original de cuatro elementos, podemos ver qué ocurre
   cuando se pasan varios argumentos numéricos a @c{nthcdr}, incluyendo 0,
   1, y 5:

   ..srci > elisp
     > ;; Deja la lista como estaba.
     > (nthcdr 0 '(pino abeto roble arce))
     (pino abeto roble arce)
     > ;; Regresa una copia sin el primer elemento.
     > (nthcdr 1 '(pino abeto roble arce))
     (abeto roble arce)
     > ;; Regresa una copia de la lista sin tres elementos.
     > (nthcdr 3 '(pino abeto roble arce))
     (arce)
     > ;; Regresa una copia sin los cuatro elementos.
     > (nthcdr 4 '(pino abeto roble arce))
     nil
     > ;; Regresa una copia sin todos los elementos.
     > (nthcdr 5 '(pino abeto roble arce))
     nil
   < srci..

** @c{nth}

   La función @c{nthcdr} toma el @c{cdr} de una lista repetidamente. La función
   @c{nth} toma el @c{car} del resultado devuelto por @c{nthcdr}. Devuelve el
   enesimo elemento de la lista.

   Por lo tanto, si @c{nth} no estubiera definido en C por velocidad, su
   definición sería:

   ..src > elisp
     (defun nth (n list)
       "Devuelve el N-esimo elemento de la lista.
     N cuenta apartir de cero. Si LIST no es tan largo, devuelve nil."
       (car (nthcdr n list)))
   < src..

   (Originalmente, @c{nth} se definio en Emacs Lisp dentro de @f{subr.el}, pero
   su definición fué rehecha en C en los 1980s.)

   La función @c{nth} devuelve un solo elemento de una lista. Esto puede ser muy
   conveniente.

   Toma en cuenta que los elementos estan numerados apartir del cero, no de
   uno. Es decir, el primer elemento de una lista, su @c{car} es el elemento
   cero. Esto se llama contar en ‘base a cero’ y con frecuencia molesta a las
   personas que estan acostumbradas a que el primer elemento en una lista sea el
   número uno, que es ‘basado en uno’.

   Por ejemplo:

   ..srci > elisp
     > (nth 0 '("uno" "dos" "tres"))
     "uno"

     > (nth 1 '("uno" "dos" "tres"))
     "dos"
   < srci..

   Vale la pena mencionar que @c{nth}, al igual que @c{nthcdr} y @c{cdr}, no
   modifica la lista original––la función es no destructiva. Esto contrasta
   fuertemente con las funciones @c{setcar} y @c{setcdr}.

** @c{setcar}

   Como podrías adivinar desde sus nombres, las funciones @c{setcar} y
   @c{setcdr} asignan el @c{car} o el @c{cdr} de una lista a un nuevo
   valor. Ambos cambian realmente la lista original, a diferencia de @c{car} y
   @c{cdr} que dejan la lista original como estaba. Una forma de averiguar cómo
   funcionan es experimentar. Vamos a empezar con la función @c{setcar}.

   Primero, podemos crear una lista y luego asignar el valor de una variable a
   la lista, usando la función @c{setq}. Aquí hay una lista de animales:

   ..src > elisp
     (setq animales '(antilope jirafa leon tigre))
   < src..

   Si estás leyendo esto dentro de GNU Emacs, puedes evaluar esta expresión de
   la forma habitual, coloca el cursor después de la expresión y presiona @k{C-x
   C-e}. (Estoy haciendo esto aqui mismo, mientras lo escribo. Esta es una de
   las ventajas de tener el intérprete construido dentro del entorno informatico.
   Por cierto, cuando no hay nada en la línea después del paréntesis final, como
   un comentario, el punto puede estar en la siguiente línea. De este modo, si
   tu cursor está en la primera columna de la siguiente línea, no es necesario
   moverlo. En realidad, Emacs permite cualquier cantidad de espacios en blanco
   después del paréntesis final.)

   Cuando evaluamos la variable @c{animales}, vemos que está unida a la lista
   @c{(antilope jirafa leon tigre)}:

   ..srci > elisp
     > animales
     (antilope jirafa leon tigre)
   < srci..

   Dicho de otro modo, la variable @c{animales} apunta a la lista @c{(antilope
   jirafa leon tigre)}.

   A continuacion, evalua la función @c{setcar} mientras le pasas dos
   argumentos, la variable @c{animales} y el símbolo citado @c{hipopotamo}; esto
   se hace escribiendo la lista de tres elementos @c{(setcar animales
   'hipopotamo)} y luego evaluandola de la forma habitual:

   ..src > elisp
     (setcar animales 'hipopotamo)
   < src..

   Después de evaluar esta expresión, evalúa la variable @c{animales} de
   nuevo. Veras que la lista de animales ha cambiado:

   ..srci > elisp
     > animales
     (hipopótamo jirafa leon tigre)
   < srci..

   El primer elemento de la lista, @c{antilope} es reemplazado por
   @c{hipopotamo}.

   Así podemos ver que @c{setcar} no agrega un nuevo elemento a la lista como
   haria @c{cons}; Se reemplaza @c{antílope} con @c{hipopótamo}; esto @e{cambia}
   la lista.

** @c{setcdr}

   La función @c{setcdr} es similar a la función @c{setcar}, excepto que la
   función reemplaza el segundo y subsiguientes elementos de una lista en lugar
   del primer elemento.

   (Para ver cómo cambiar el último elemento de una lista, mira directamente en
   la Seccion @l{#La función @c{kill-new}}, que utiliza las funciones @c{nthcdr}
   y @c{setcdr}.)

   Para ver cómo funciona esto, asigna el valor de la variable a una lista de
   animales domesticados evaluando la siguiente expresión:

   ..src > elisp
     (setq animales-domesticos '(caballo vaca oveja cabra))
   < src..

   Si evalúas la lista, debe devolverte la lista @c{(caballo vaca oveja cabra)}:

   ..srci > elisp
     > animales-domesticos
     (caballo vaca oveja cabra)
   < srci..

   Luego, evalúa @c{setcdr} con dos argumentos, el nombre de la variable que
   tiene una lista como su valor, y la lista a la que se establecera el @c{cdr}
   de la primera lista;

   ..src > elisp
     (setcdr animales-domesticos '(gato perro))
   < src..

   Si evalúas esta expresión, la lista @c{(gato perro)} aparecerá en el área
   echo. Este es el valor devuelto por la función. El resultado que nos interesa
   es el “efecto secundario”, que podemos ver evaluando la variable
   @c{animales-domesticos}:

   ..srci > elisp
     > animales-domesticos
     (caballo gato perro)
   < srci..

   En efecto, la lista cambia de @c{(caballo vaca oveja cabra)} a @c{(caballo
   gato perro)}. El @c{cdr} de la lista cambia de @c{(vaca oveja cabra)} a
   @c{(gato perro)}.

** Ejercicio

   Construye una lista de cuatro pájaros evaluando varias expresiones con
   @c{cons}. Descubre que ocurre cuando aplicas @c{cons} a una lista sobre si
   misma. Reemplaza el primer elemento de la lista de cuatro pájaros con un
   pez. Reemplaza el resto de esta lista con una lista de otros peces.

* Corte y Almacenamiento de Texto

  Siempre se corta o guarda texto de un búfer con un comando ‘kill’, se almacena
  en una lista y puedes traerlo de vuelta con un comando ‘yank’.

  (El uso de la palabra ‘kill’ @%"(matar) en Emacs para procesos que
  específicamente @e{no} destruyen los valores de las entidades es un accidente
  histórico desafortunado. Una palabra mucho más apropiada seria ‘clip’ @%"(cortar)
  ya que eso es lo que hacen los comandos @'(kill); recortan el texto de un
  búfer y lo guardan en un almacenamiento, donde puede traerse de vuelta. Con
  frecuencia me he sentido tentado a sustituir globalmente todas las apariciones
  de ‘kill’ en el codigo de Emacs con ‘clip’ y todas las apariciones de ‘killed’
  (destruido) con ‘clipped’ (cortado).)

  Cuando el texto se corta de un búfer, se almacena en una lista. Fragmentos de
  texto se almacenan en la lista sucesivamente, por lo que la lista podría verse
  así:

  ..src > elisp
    ("una pieza de texto" "pieza anterior")
  < src..

  La función @c{cons} se puede utilizar para crear una nueva lista a partir de
  un trozo de texto (un ‘átomo’, para usar la jerga) y una lista existente,
  como esta:

  ..src > elisp
    (cons "otra pieza"
          '("una pieza de texto" "pieza anterior"))
  < src..

  Si evaluas esta expresión, aparecera una lista de tres elementos en el área
  de eco:

  ..src > elisp
    ("otra pieza" "una pieza de texto" "pieza anterior")
  < src..

  Puedes recuperar cualquier pieza de texto que desees, con las funciones
  @c{car} y @c{nthcdr}. Por ejemplo, en el siguiente código, @c(nthcdr 1 …)
  devuelve la lista con el primer elemento eliminado; y @c{car} devuelve el
  primer elemento de ese resto––el segundo elemento de la lista original:

  ..srci > elisp
    > (car (nthcdr 1 '("otra pieza"
    ^                  "una pieza de texto"
    ^                  "pieza anterior")))
    "una pieza de texto"
  < srci..

  Por supuesto, las funciones reales en Emacs son más complejas que esto. El
  código para el corte y recuperarcion de texto tiene que ser escrito de modo
  que Emacs pueda determinar qué elemento en la lista se quiere––el primero,
  segundo, tercero o cualquier otro. Además, cuando se llega al final de la
  lista, Emacs deberia darte el primer elemento de la lista, en lugar de nada en
  absoluto.

  La lista que contiene los trozos de texto se llama @:(kill ring) @%"(anillo de
  la muerte). En este capítulo se hace una descripción del anillo de la muerte y
  como se utiliza para un primer rastreo en la función @c{zap-to-char}. Esta
  función utiliza (o ‘llama’) a una función que invoca a otra función que
  manipula el anillo de la muerte. Por la tanto, antes de llegar a las montañas,
  debemos escalar las colinas.

  En un capítulo posterior se describe cómo se recupera el texto que se corta de
  un buffer. Ver Sección @l{#Pegando texto}.

** @c{zap-to-char}

   La función @c{zap-to-char} apenas ha variado entre la versión 19 y 22 de GNU
   Emacs. Sin embargo, @c{zap-to-char} llama a otra función, @c{kill-region},
   que ha tenido una reescritura importante.

   La función @c{kill-region} en Emacs 19 es compleja, pero no utiliza código
   que sea importante en este momento. Nos Lo saltaremos.

   La función @c{kill-region} en Emacs 22 es más de fácil de leer que la misma
   función en Emacs 19 e introduce un concepto muy importante, la gestion de
   errores. Caminaremos a través de la función.

   Pero primero, veamos la función interactiva @c{zap-to-char}.

   La función @c{zap-to-char} elimina el texto en la región entre la ubicacion
   del cursor (es decir. del punto) hasta e incluyendo la siguiente aparicion de
   un caracter específicado. El texto que @c{zap-to-char} elimina se pone en el
   anillo de la muerte; y se puede recuperar escribiendo @k{C-y} @%c(yank). Si
   el comando recive un argumento, elimina el texto a través de este número de
   ocurrencias. Por lo tanto, si el cursor estuviera al inicio de esta frase y
   el carácter fuera @'{s}, se eliminaria @'{Por la tanto, }. Si el argumento
   fueran dos, se eliminaria @'{Por lo tanto, si el curs}, hasta e incluiendo la
   @'{s} en @'{cursor}.

   Si no se encuentra el carácter específicado @c{zap-to-char} dirá “Búsqueda
   fallida”, te indicaria el caracter que escribiste, y no eliminara ningun
   texto.

   Para determinar la cantidad de texto a eliminar @c{zap-to-char} utiliza una
   función de búsqueda. Las búsquedas se utilizan ampliamente en código que
   manipula el texto, y vamos a centrar la atención en ellos, asi como en el
   comando de eliminacion.

   Aquí está el texto completo de la función en la versión 22:

   ..src > elisp
     (defun zap-to-char (arg char)
       "Corta e incluye la aparicion de la enesima ocurrencia (ARG) del caracter CHAR.
     Se ignora entre mayusculas y minusculas si ‘case-fold-search’ es no-nil en
     el buffer actual.
     Retrocede si ARG es negativo; error si CHAR no se encuentra."
       (interactive "p\ncZap to char: ")
       (if (char-table-p translation-table-for-input)
           (setq char (or (aref translation-table-for-input char) char)))
       (kill-region (point) (progn
                              (search-forward (char-to-string char) nil nil arg)
                              (point))))
   < src..

   La linea de documentacion esta traducida al español. En la version original
   no se utiliza la palabra ‘Corta’ en su lugar se utiliza ‘kill’.

*** La expresión @c{interactive}

    La expresión interactiva en el comando @c{zap-to-char} es esta:

    ..src > elisp
      (interactive "p\ncZap to char: ")
    < src..

    La parte entre comillas, @c{"p\ncZap to char: "}, especifica dos cosas
    diferentes. Primero, y lo mas sencillo, es la @'{p}. Esta parte se separa de
    la siguiente parte por una línea nueva, @'{\n}. La @'{p} significa que el
    primer argumento de la función será pasando el valor de un ‘prefijo
    procesado’. El argumento prefijo se pasa escribiendo @k{C-u} y un número, o
    @k{M-} y un número. Si la función se llamada interactivamente sin un
    prefijo, se pasa 1 a este argumento.

    La segunda parte de @c{"p\ncZap to char: "} es @'{cZap to char:}. En esta
    parte, la @'{c} minuscula indica que @c{interactive} espera un prompt y que
    el argumento será un caracter. El prompt va despues de @'{c} y es la cadena
    @'{Zap to char: } (con un espacio después de los dos puntos para verse bien).

    Todo lo que esto hace es preparar los argumentos de @c{zap-to-char} para que
    sean del tipo correcto, y darle al usuario un prompt.

    En un búfer de solo lectura, la función @c{zap-to-char} copia el texto al
    anillo de la muerte, pero no lo elimina. El área de eco muestra un mensaje
    diciendo que el búfer es de solo lectura. Ademas, el terminal puede emitir
    un pitido o parpadear.

*** El cuerpo de @c{zap-to-char}

    El cuerpo de la función @c{zap-to-char} contiene el código que mata (es
    decir, elimina) el texto en la región desde la posición actual del cursor
    hasta e incluyendo el carácter especificado.

    La primera parte del código se ve asi:

    ..src > elisp
      (if (char-table-p translation-table-for-input)
          (setq char (or (aref translation-table-for-input char) char)))
      (kill-region (point) (progn
                             (search-forward (char-to-string char) nil nil arg)
                             (point)))
    < src..

    @c{char-table-p} es una función que aun no hemos visto. Determina si su argumento
    es una tabla de caracteres. Si lo es, establece el caracter pasado a
    @c{zap-to-char} a uno de ellos, si ese carácter existe, o al carácter en
    sí. (Esto es importante para ciertos caracteres en lenguas no Europeas. La
    función @c{aref} extrae un elemento desde un arreglo. Esta funcion es
    específica para arreglos y no sera descrita en este documento. Vea la Seccion
    @l{info:elisp#Arrays<>Arreglos} en @e(El Manual de Referencia de GNU Emacs
    Lisp).)

    @c{(point)} es la posición actual del cursor.

    La siguiente parte del código es una expresión utilizando @c{progn}. El
    cuerpo del @c{progn} consiste en llamadas a @c{search-forward} y @c{point}.

    Es fácil comprender cómo funciona @c{progn} después de aprender sobre
    @c{search-forward}, asi que veremos @c{search-forward} y luego @c{progn}.

*** La Función @c{search-forward}

    La función @c{search-forward} se utiliza para localizar el caracter a borrar
    en @c{zap-to-char}. Si la búsqueda es exitosa, @c{search-forward} deja el
    punto inmediatamente después del último carácter en la cadena objetivo. (En
    @c{zap-to-char}, la cadena objetivo tiene solo un carácter longitud.
    @c{zap-to-char} usa la función @c{char-to-string} para asegurar que el
    computador trata este carácter como una cadena). Si la búsqueda es hacia
    atrás, @c{search-forward} deja el punto justo antes del primer carácter en
    el objetivo. Ademas, @c{search-forward} devuelve @c{t} para verdadero. (Por
    lo tanto, desplazar el punto es un ‘efecto secundario’.)

    En @c{zap-to-char}, la función @c{search-forward} se ve así:

    ..src > elisp
      (search-forward (char-to-string char) nil nil arg)
    < src..

    La función @c{search-forward} utiliza cuatro argumentos:

    1. El primer argumento es el objetivo, que esta buscando. Debe ser una
       cadena, como @"{z}.

       Sucede que el argumento pasado a @c{zap-to-char} es un solo
       caracter. Debido a la forma en la que se construyen los computadores, el
       intérprete Lisp puede tratar un solo caracter de forma distinta a una
       cadena de caracteres. Dentro del computador, un solo caracter tiene un
       formato electrónico diferente a una cadena de un caracteres. (Un solo
       caracter con frecuencia puede grabarse en el computador utilizardo
       exactamente un byte; pero una cadena puede ser mas larga, y el equipo
       debe estar listo para ello.) Ya que la función @c{search-forward} busca
       una cadena, el caracter que recive la función @c{zap-to-char} como
       argumento debe convertirse dentro del computador de un formato a otro; de
       lo contrario, la función @c{search-forward} fallará. Se utiliza la
       función @c{char-to-string} para realizar esta conversión.

    2. El segundo argumento limita la búsqueda; se especifica como una posición
       en el búfer. En este caso, la búsqueda puede ir al final del búfer, por
       lo que no se establece ningun limite y el segundo argumento es @c{nil}.

    3. El tercer argumento le dice a la función lo que debe hacer si la búsqueda
       falla––puede señalar un error (e imprimir un mensaje) o puede devolver
       @c{nil}. Un @c{nil} como el tercer argumento hace que la función señåle
       un error cuando la búsqueda falla.

    4. El cuarto argumento de @c{search-forward} es el numero de
       repeticion––cuántas ocurrencias de la cadena hay que buscar. Este
       argumento es opcional y si la función se llamada sin contador de
       repeticion, este argumento pasa el valor 1. Si este argumento es
       negativo, la búsqueda va hacia atrás.


    En formato plantilla, una expresión @c{search-forward} tiene este aspecto:

    ..src > elisp
      (search-forward "cadena-a-buscar"
                      limite-de-busqueda
                      que-hacer-si-la-busqueda-falla
                      contador-de-repeticion)
    < src..

    A continuacion veremos @c{progn}.

*** La forma especial @c{progn}

    @c{progn} es una forma especial que hace que cada uno de sus argumentos sea
    evaluado en secuencia y luego devuelve el valor del último. Las expresiones
    anteriores solo se evaluan por los efectos secundarios que realizan. Los
    valores que producen son descartados.

    La plantilla de una expresión @c{progn} es muy simple:

    ..src > elisp
      (progn
        cuerpo…)
    < src..

    En @c{zap-to-char}, la expresión @c{progn} tiene que hacer dos cosas: poner
    el punto exactamente en la posición correcta; y devolver la posición del
    punto para que @c{kill-region} sepa handa donde cortar.

    El primer argumento de @c{progn} es @c{search-forward}. Cuando
    @c{search-forward} encuentra la cadena, la función deja el punto
    inmediatamente después del último caracter en la cadena objetivo. (En este
    caso la cadena objetivo tiene solo un carácter de longitud.) Si la búsqueda es
    hacia atrás, @c{search-forward} deja el punto justo antes del primer
    carácter objetivo. El movimiento del punto es un efecto secundario.

    El segundo y último argumento de @c{progn} es la expresión @c{(point)}. Esta
    expresión devuelve el valor del punto, que en este caso será la ubicacion a
    la que se ha movido por @c{search-forward}. (En el codigo, una línea le
    indica a la función que debe ir un carácter atras, si va hacia adelante, se
    comentó en 1999; yo no recuerdo si esta caracteriscita o funcion incorrecta
    alguna vez fue parte del codigo distribuido.) El valor de @c{point} es
    devuelto por la expresión @c{progn} y se pasa a @c{kill-region} como el
    segundo argumento de @c{kill-region} .

*** Resumiendo @c{zap-to-char}

    Ahora que hemos visto cómo funcionan @c{search-forward} y @c{progn}, podemos
    ver cómo la función @c{zap-to-como} trabaja como un todo.

    El primer argumento de @c{kill-region} es la posición del cursor cuando se
    da el comando @c{zap-to-char}––el valor de punto en ese momento. Dentro de
    @c{progn}, la funcion de búsqueda mueve el punto justo después del caracter
    a borrar y @c{point} devuelvan el valor esa ubicacion. La función
    @c{kill-region} reune estos dos valores de punto, el primero como el inicio
    de la región y el segundo como el final de la región, y elimina la región.

    La forma especial @c{progn} es necesaria porque el comando @c{kill-region}
    toma dos argumentos; y fallaría si las expresiones @c{search-forward} y
    @c{point} se escribieran en secuencia como dos argumentos adicionales. La
    expresión @c{progn} es solo un argumento para @c{kill-region} y devuelve el
    valor que @c{kill-region} necesita para su segundo argumento.

** @c{kill-region}

   La función @c{zap-to-char} utiliza la función @c{kill-region}. Esta función
   corta texto de una región y copia ese texto al anillo de la muerte, desde el
   que puede recuperarse.

   La versión en Emacs 22 de esta funcion utiliza @c{condition-case} y
   @c{copy-region-as-kill}, ambas seran explicadas. @c{condition-case} es una
   forma especial importante.

   En esencia, la función @c{kill-region} llama a @c{condition-case}, que toma
   tres argumentos. En esta función, el primer argumento no hace nada. El
   segundo argumento contiene el código que hace el trabajo cuando todo va
   bien. El tercer argumento contiene el código que se llama en caso de error.

   Revisaremos el código de @c{condition-case} en un momento. Primero, veamos la
   definición de @c{kill-region}, con comentarios añadidos:

   ..src > elisp
     (defun kill-region (beg end)
       "Kill (\"corta\") el texto entre el punto y la marca.
     Esto elimina el texto del buffer y lo guarda en el anillo de la muerte.
     El comando \\[yank] puede recuperarlo desde alli. … "

       ;; • Puesto que el orden importa, primero pasa el punto.
       (interactive (list (point) (mark)))
       ;; • Y dinos si no podemos cortar el texto.
       ;; ‘A menos que’ sea un ‘if’ sin parte then.
       (unless (and beg end)
         (error "La marca no esta definida, asi que no hay ninguna region"))
       ;; • ‘condition-case’ toma tres argumentos.
       ;;    Si el primer argumento es nil, como aqui,
       ;;    la informacion del error no se almacena
       ;;    para ser utilizado por otra funcion.
       (condition-case nil

           ;; • El segundo argumento de ‘condition-case’ le dice al
           ;;    interprete Lisp que hacer cuando todo va bien.

           ;;    Empieza con una funcion ‘let’ que extrae la cadena y
           ;;    comprueba si existe. Si es asi (eso es lo que comprueba
           ;;    ‘when’), esta llama a una funcion ‘if’ que determina
           ;;    si el comando anterior fue otra llamada a ‘kill-region’;
           ;;    si lo fue, el nuevo texto se añade al texto anterior; si
           ;;    no, se llama a una funcion diferente, ‘kill-new’.

           ;;    La funcion ‘kill-append’ concatena la cadena nueva y antigua.
           ;;    La funcion ‘kill-new’ inserta el texto dentro de un nuevo
           ;;    elemento en el anillo de la muerte.

           ;;    ‘when’ es un ‘if’ sin una parte else. El segundo ‘when’
           ;;    comprueba de nuevo si la cadena actual existe; Ademas,
           ;;    comprueba si el comando anterior fue otra llamada a
           ;;    ‘kill-region’. Si una u otra condicion es verdadera,
           ;;    entonces establece que el comando actual sea ‘kill-region’.
           (let ((string (filter-buffer-substring beg end t)))
             (when string                    ;STRING es nil si BEG = END
               ;; agrega esa cadena al anillo de la muerte, de uno forma u otra.
               (if (eq last-command 'kill-region)
                   ;;    − ‘yank-handler’ es un argumento opcional de
                   ;;    ‘kill-region’ que indica a las funciones ‘kill-append’
                   ;;    y ‘kill-new’ como tratar las propiedades añadidas al
                   ;;    texto, como ‘negrita’ o ‘cursiva’.
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)

         ;;  • El tercer argumento de ‘condition-case’ le dice al interprete
         ;;    que hacer con un error.
         ;;    El tercer argumento tiene una parte de condiciones y una parte cuerpo.
         ;;    Si se cumplen las condiciones (en este caso,
         ;;             si el texto o el buffer son de solo lectura)
         ;;    entonces se ejecuta el cuerpo.
         ;;    La primer parte del tercer argumento es la siguiente:
         ((buffer-read-only text-read-only) ;; la parte if
          ;; …  la parte then
          (copy-region-as-kill beg end)
          ;;    A continuacion, tambien como parte de la parte then, establece
          ;;    this-command, por lo que se establece en un error
          (setq this-command 'kill-region)
          ;;    Finalmente, en la pante then, envia un mensaje si puede copiar
          ;;    el texto en el anillo de la muerte sin señalar un error, pero
          ;;    no lo hace si no puede.
          (if kill-read-only-ok
              (progn (message "Read only text copied to kill ring") nil)
            (barf-if-buffer-read-only)
            ;; Si el buffer no es de solo lectura, el texto lo es.
            (signal 'text-read-only (list (current-buffer)))))
   < src..

*** @c{condition-case}

    Como se ha visto antes (ver la Seccion @l{#Generar un Mensaje de Error}), cuando
    el intérprete de Emacs Lisp tiene problemas evaluando una expresión, te
    proporciona ayuda; en la jerga, esto se llama “Señalar un error”.
    Normalmente, el computador detiene el programa y te muestra un mensaje.

    Sin embargo, algunos programas emprenden acciones complicadas. No deberian
    simplemente detenerse en un error. En la función @c{kill-region}, el error
    mas probable es que intente cortar texto que es de solo lectura y no puede
    ser eliminado. Así que la función @c{kill-region} contiene código para
    manejar esta circunstancia. Este código, que forma el cuerpo de la función
    @c{kill-region}, se encuentra dentro de una forma especial @c{condition-case}.

    La plantilla para @c{condition-case} tiene este aspecto:

    ..src > elisp
      (condition-case
        var
        cuerpo
        gestor-de-errores…)
    < src..

    El segundo argumento, @c{cuerpo} es sencillo. La forma especial
    @c{condition-case} hace que el intérprete Lisp evalúe el código en
    @c{cuerpo}. Si no ocurre ningún error, la forma especial devuelve el valor
    del código y produce efectos secundarios, si los hubiera.

    En resumen, la parte @c{cuerpo} de una expresión @c{condition-case}
    determina qué deberia suceder cuando todo funciona correctamente.

    Sin embargo, si se produce un error, entre sus otras acciones, la función
    genera la señal de error que define uno o más nombres de condicion de error.

    El gestor de errores es el tercer argumento de @c{condition-case}. Un gestor
    de errores tiene dos partes, un @c{nombre-de-condicion} y un @c{cuerpo}. Si
    la parte @c{nombre-de-condicion} de un gestor de errores coincide con un
    nombre de condicion generado por un error, se ejecuta la parte del
    @c{cuerpo} del gestor de errores.

    Como es de esperar, la parte @c{nombre-de-condicion} de un gestor de errores
    puede ser un unico nombre de condicion o una lista de nombres de condición.

    Ademas, una expresión @c{condition-case} completa puede contener más de un
    gestor de errores. Cuando se produce un error, se ejecuta el primer
    gestor aplicable.

    Por ultimo, el primer argumento de la expresión @c{condition-case}, el
    argumento @c{var}, en ocaciones se vincula a una variable que contiene
    información sobre el error. Sin embargo, si este argumento es @c(nil), como
    es el caso en @c{kill-region}, esa información se descarta.

    En resumen, en la función @c{kill-region}, el código @c{condition-case}
    funciona de la siguiente manera:

    ..example >
      Si no hay errores, ejecuta solo este codigo
          pero, si hay errores, ejecuta este otro codigo.
    < example..

*** Macro Lisp

    La parte de la expresión @c{condition-case} que se evalúa en la expectativa
    de que todo va bien si tiene un @c{when}. El código utiliza @c{when} para
    determinar si la variable @c{string} apunta a texto que existe.

    Una expresión @c{when} simplemente es una conveniencia para los
    programadores. Es un @c{if} sin la posibilidad de una cláusula else. En tu
    mente, puedes reemplazar @c{when} con @c{if} y entender lo que pasa. Eso es
    lo que hace el intérprete Lisp.

    Técnicamente hablando, @c{when} es una macro Lisp. Una @:{macro} Lisp te
    permite definir nuevas construcciones de control y otras caracteristicas del
    lenguaje. Le indica al intérprete cómo calcular otra expresión Lisp que a su
    vez calcula el valor. En este caso, la ‘otra expresión’ es una expresión
    @c{if}.

    La definición de la función @c(kill-region) también tiene una macro
    @c{unless}; es lo contario de @c{when}. La macro @c{unless} es un @c{if} sin
    una cláusula @c(then).

    Para optener más informacion sobre las macros Lisp, consulta la Seccion
    @l{#info:elisp#Macros<>Macros} en @e(El Manual de Referencia de Emacs
    Lisp). El lenguaje de programación C también proporciona macros. Estos son
    diferentes, pero también útiles.

    Respecto a la macro @c{when}, en la expresión @c{condition-case}, cuando la
    cadena tiene contenido, se ejecuta otra expresión condicional. Esto es un
    @c{if} tanto con parte @c(then) como con una parte @c(else).

    ..src > elisp
      (if (eq last-command 'kill-region)
          (kill-append string (< end beg) yank-handler)
        (kill-new string nil yank-handler))
    < src..

    La parte @c(then) se evalúa si el comando anterior era otra llamada
    a @c{kill-region}; si no, se evalúa la parte @c(else).

    @c{yank-handler} es un argumento opcional de @c{kill-region} que indica a
    las funciones @c{kill-append} y @c{kill-new} como tratar con propiedades
    agregadas al texto, como ‘negrilla’ o ‘cursiva’.

    @c{last-command} es una variable que viene con Emacs y que no hemos visto
    antes. Normalmente, siempre que se ejecuta una función, Emacs establece el
    valor de @c{last-command} al comando anterior.

    En este segmento de la definición, la expresión @c{if} comprueba si el
    comando anterior fue @c{kill-region}. Si lo fuera,

    ..src > elisp
      (kill-append string (< end beg) yank-handler)
    < src..

    concatena una copia del texto recien cortado al texto cortado previamente en
    el anillo de la muerte.

** @c{copy-region-as-kill}

   La función @c{copy-region-as-kill} copia una región de texto de un búfer
   y (via @c{kill-append} o @c{kill-new}) lo guarda en el @c{kill-ring}.

   Si llamas a @c{copy-region-as-kill} inmediatamente después de un comando
   @c{kill-region}, Emacs agregara el texto recien copiado al texto copiado
   previamente. Esto significa que traes el texto, lo obtienes todo, tanto de
   esta operacion como de la anterior. Por otra parte, si algún otro comando
   precede a @c{copy-region-as-kill}, la función copia el texto dentro de una
   entrada separada en el anillo de la muerte.

   Aquí está el texto completo de la función @c{copy-region-as-kill} de la
   versión 22:

   ..src > elisp
     (defun copy-region-as-kill (beg end)
       "Guarda la region como si fuese cortada, pero no la corta.
     En el modo Transient Mark, desactiva la marca.
     Si ‘interprogram-cut-function’ es no-nil, tambien guarda el texto de una
     ventana del sistema corta y pega."
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (filter-buffer-substring beg end) (< end beg))
         (kill-new (filter-buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)
   < src..

   Como de costumbre, esta función puede dividirse en las partes que la
   componen:

   ..src > elisp
     (defun copy-region-as-kill (lista-de-argumentos)
       "documentacion…"
       (interactive "r")
       cuerpo…)
   < src..

   Los argumentos son @c{beg} y @c{end} y la función es interactiva con @c{"r"},
   por lo que los dos argumentos deben referirse al inicio y al final de la
   región. Si has estado leyendo este documento desde el principio, entender
   estas partes de una función es casi una rutina.

   En la documentación, los comentarios de ‘Transient Mark’ y
   @c{interprogram-cut-function} explican ciertos efectos secundarios.

   Después de asignar una marca, un búfer siempre contiene una región. Si lo
   deseas puedes utilizar el modo Transient Mark para resaltar temporalmente la
   región. (Nadie quiere resaltar la región todo el tiempo, por lo que el modo
   Trasient Mark lo resalta solo en los momentos apropiados. Muchas personas
   desactivan el modo Transient Mark, por lo que la región nunca se resalta.)

   Ademas, un sistema de ventanas permite copiar, cortar y pegar entre diferentes
   programas. En el sistema de ventanas X, por ejemplo, la función
   @c{interprogram-cut-function} es @c{x-select-text}, que funciona con el
   sistema de ventanas equivalente al anillo de la muerte de Emacs.

   El cuerpo de la función @c{copy-region-as-kill} inicia con una cláusula
   @c{if}. Lo que esta cláusula hace es distinguir entre dos situaciones
   diferentes: si este comando se ejecuta o no inmediatamente después de un
   comando @c{kill-region} anterior. En el primer caso, la nueva región se
   concatena al texto copiado previamente. De lo contrario, se inserta al inicio
   del anillo de la muerte como una pedazo separado del texto anterior.

   Las dos ultimas líneas de la función impiden que la región se ilumine si el
   modo Transient Mark está activo.

   El cuerpo de @c{copy-region-as-kill} merece ser discutido en detalle.

*** El cuerpo de @c{copy-region-as-kill}

    @c{copy-region-as-kill} funciona de un modo parecido a la función
    @c{kill-region}. Ambas están escritas de manera que dos o más muertes en una
    fila combinan su texto en una sola entrada. Si sacas el texto del anillo de
    la muerte, se optiene todo en una sola pieza. Ademas, las muertes que matan
    hacia adelante desde la posición actual del cursor se añaden al final del
    texto copiado previamente y los comandos que cortan el texto hacia atrás lo
    añaden al principio del texto copiado previamente. De esta manera, las
    palabras del texto permanecen en el orden correcto.

    Al igual que @c{kill-region}, la función @c{copy-region-as-kill} hace uso de
    la variable @c{last-command} que mantiene el registro del comando Emacs
    anterior.

    Normalmente, siempre que se ejecuta una función, Emacs asigna el valor de
    @c{this-command} a la función que se ejecuta (que en este caso sería
    @c{copy-region-as-kill}). Al mismo tiempo, Emacs asigna el valor de
    @c{last-command} al valor anterior de @c{this-command}.

    En la primer parte del cuerpo de la función @c{copy-region-as-kill}, una
    expresión @c{if} determina si el valor de @c{last-command} es
    @c{kill-region}. Si es así, se evalua la parte then de la expresión @c{if};
    utiliza la función @c{kill-append} para concatenar el texto copiado en esta
    llamada a la función con el texto ya en el primer elemento (el @c{car} del
    anillo de la muerte. Por otro lado, si el valor de @c{last-command} no es
    @c{kill-region}, entonces la función @c{copy-region-as-kill} asigna un nuevo
    elemento al anillo de la muerte usando la función @c{kill-new}.

    La expresión @c{if} se lee da la siguiente manera; se utiliza @c{eq}:

    ..src > elisp
      (if (eq last-command 'kill-region)
          ;; parte then
          (kill-append  (filter-buffer-substring beg end) (< end beg))
        ;; parte else
        (kill-new  (filter-buffer-substring beg end)))
    < src..

    (La función @c{filter-buffer-substring} devuelve una subcadena filtrada del
    búfer, si existe. Opcionalmente––los argumentos no están aquí, por lo que
    tampoco se hace––la función puede borrar el texto inicial o devolver el
    texto sin sus propiedades; esta función es un reemplazo para la antigua
    función @c{buffer-substring}, que vino antes de implementar las propiedades
    de texto.)

    La función @c{eq} prueba si su primer argumento es el mismo objeto Lisp que
    su segundo argumento. La función @c{eq} es similar a la función @c{equal}
    que se utiliza para probar la igualdad, pero difiere en que determina si dos
    representaciones son realmente el mismo objeto dentro de la computadora,
    pero con nombres diferentes. @c{equal} determina si la estructura y el
    contenido de dos expresiones son iguales.

    Si el comando anterior fue @c{kill-region}, entonces el intérprete Emacs
    Lisp llama a la función @c{kill-append}

**** La función @c{kill-append}

     La función @c{kill-new} se ve así:

     ..src > elisp
       (defun kill-append (string before-p &optional yank-handler)
         "Inserta STRING al fin del ultimo corte en el anillo de la muerte.
       Si BEFORE-P no es nil, anexa STRING al corte.
       … "
         (let* ((cur (car kill-ring)))
           (kill-new (if before-p (concat string cur) (concat cur string))
                     (or (= (length cur) 0)
                         (equal yank-handler
                                (get-text-property 0 'yank-handler cur)))
                     yank-handler)))
     < src..

     La función @c{kill-append} es bastante sencilla. Utiliza la función
     @c{kill-new}, que discutiremos con más detalle en un momento.

     (También, la función proporciona un argumento opcional llamado
     @c{yank-handler}; cuando se invoca, este argumento le dice a la función
     cómo tratar con la propiedades añadidas al texto, como ‘negrita’ o
     ‘cursiva’.)

     Tiene una función @c{let*} para asignar el valor del primer elemento del
     anillo de la muerte a @c{cur}. (No se por qué la función no utiliza @c{let}
     en su lugar; solo un valor se asigna en la expresión. ¿Tal vez este es un
     bug que no produce problemas?

     Considera el condicional que es uno de los dos argumentos de @c{kill-new}.
     Utiliza @c{concat} para concatenar el nuevo texto al @c{car} del anillo de
     la muerte. Si agrega el texto antes o despues depende del resultado de la
     expresión @c{if}:

     ..src > elisp
       (if before-p                            ; parte if
           (concat string cur)                 ; parte then
         (concat cur string))                  ; parte else
     < src..

     Si la región cortada está antes de la región que se cortó en el último
     comando, entonces debería ser puesta antes que el material guardado en el
     corte anterior; y, a la inversa, si el texto que se corto esta despues del
     que acaba de cortar, debe añadirse después del texto anterior. La expresión
     @c{if} depende del predicado @c{before-p} para decidir si el texto recien
     guardado debe colocarse antes o después del texto anterior.

     El símbolo @c{before-p} es el nombre de uno de los argumentos para
     @c{kill-append}. Cuando se evalúa la función @c{kill-append}, se asocia al
     valor devuelto evaluando el argumento actual. En este caso, esta es la
     expresión @c{(< end beg)}. Esta expresión no determina directamente si el
     texto cortado en este comando se localiza antes o después del texto cortado
     del último comando; lo que hace es determinar si el valor de la variable
     @c{end} es menor que el valor de la variable @c{beg}. Si es así, significa
     que problamemente el usuario se dirige al principio del búfer. También, el
     resultado de evaluar la expresión del predicado. @c{(< end beg)}, será
     verdadero y el texto se concatena antes del texto anterior. Por otro lado,
     si el valor de la variable @c{end} es mayor que el valor del la variable
     @c{beg}, el texto se agregara después del texto anterior.

     Cuando se prepara el texto recien guardado, la cadena con el nuevo texto se
     concatena antes que el texto anterior:

     ..src > elisp
       (concat string cur)
     < src..

     Pero si el texto será añadido, será concatenado después del viejo texto:

     ..src > elisp
       (concat cur string))
     < src..

     Para comprender cómo funciona esto, primero se necesita revisar la
     función @c{concat}. La función @c{concat} enlaza o une dos cadenas
     de texto. El resultado es una cadena. Por ejemplo:

     ..srci > elisp
       > (concat "abc" "def")
       "abcdef"

       > (concat "nuevo "
       ^         (car '("primer elemento" "segundo elemento")))
       "nuevo primer elemento"

       > (concat (car
       ^         '("primer elemento" "segundo elemento")) " modificado")
       "primer elemento modificado"
     < srci..

     Ahora podemos dar sentido a @c{kill-append}: modifica el contenido del
     anillo de la muerte. El anillo de la muerte es una lista, en la que cada
     elemento es un texto guardado. La función @c{kill-append} usa la función
     @c{kill-new} que a su vez utiliza la función @c{setcar}.

**** La función @c{kill-new}

     La función @c{kill-new} se ve asi:

     ..src > elisp
       (defun kill-new (string &optional replace yank-handler)
         "Hace que STRING sea el último corte en el anillo de la muerte.
       Asigna ‘kill-ring-yank-pointer’ para apuntar a el.

       Si ‘interprogram-cut-function’ es no nulo, aplícalo a STRING.
       El segundo argumento opcional REPLACE no-nulo significa que STRING
        reemplazará el frente del kill ring, en lugar de agregarse a la lista.
       …"
         (if (> (length string) 0)
             (if yank-handler
                 (put-text-property 0 (length string)
                                    'yank-handler yank-handler string))
           (if yank-handler
               (signal 'args-out-of-range
                       (list string "yank-handler specified for empty string"))))
         (if (fboundp 'menu-bar-update-yank-menu)
             (menu-bar-update-yank-menu string (and replace (car kill-ring))))
         (if (and replace kill-ring)
             (setcar kill-ring string)
           (push string kill-ring)
           (if (> (length kill-ring) kill-ring-max)
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     < src..

     (Observa que la función no es interactiva.)

     Como de costumbre, podemos ver esta función en partes.

     La definición de la función tiene un argumento opcional @c{yank-handler},
     que cuando se invoca le dice a la función cómo manejar las propiedades
     añadidas al texto, tales como ‘negrilla’ o ‘cursiva’. Nos Saltaremos eso.

     La primer línea de la documentación tiene sentido:

     ..example >
       Hace que STRING sea el último corte en el anillo de la muerte.
     < example..

     Vamos a saltarnos el resto de la documentación por el momento.

     También, vamos a saltar la expresión @c{if} inicial y las líneas de código
     en @c{menu-bar-update-yank-menu}. Les explicaremos mas tarde.

     Las líneas críticas son estas:

     ..src > elisp
         (if (and replace kill-ring)
             ;; entonces
             (setcar kill-ring string)
           ;; de otra forma
         (push string kill-ring)
           (setq kill-ring (cons string kill-ring))
           (if (> (length kill-ring) kill-ring-max)
               ;; evita desbordar el anillo de la muerte
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     < src..

     El test condicional es @c{(and replace kill-ring)}. Esto será verdadero
     cuando se cumplan dos condiciones: el anillo de la muerte tiene algo en el,
     y la variable @c{replace} es verdadera.

     Cuando la función @c{kill-append} establece @c{replace} como verdadero y
     cuando el anillo de la muerte tiene al menos un elemento en el, se ejecuta
     la expresión @c{setcar}.

     ..src > elisp
       (setcar kill-ring string)
     < src..

     La función @c{setcar} realmente cambia el primer elemento de la lista
     @c{kill-ring} al valor de @c{string}. Eso reemplaza el primer
     elemento.

     Por otro lado, si el anillo de la muerte está vacío, o @c(replace) es
     falso, se ejecuta la parte else de la condición:

     ..src > elisp
       (push string kill-ring)
     < src..

     @c{push} pone su primer argumento dentro del segundo. Es similar a la
     mas antigua

     ..src > elisp
       (setq kill-ring (cons string kill-ring))
     < src..

     o la mas reciente

     ..src > elisp
       (add-to-list kill-ring string)
     < src..

     Cuando es falso, la expresión primero construye una nueva versión del
     anillo de la muerte, añadiendo @c{string} al anillo como un nuevo elemento
     (que es lo que hace @c{push}). Entonces ejecuta una segunda clausula @c{if}.
     Este segundo @c{if} impide que el anillo de la muerte se haga demaciado largo.

     Veamos estas dos expresiones en orden.

     La línea @c{push} de la parte else asigna el nuevo valor del anillo de la
     muerte a los resultados de agregar la cadena que esta siendo cortada al
     viejo anillo de la muerte.

     Podemos ver cómo funciona esto con un ejemplo.

     Primero,

     ..src > elisp
       (setq lista-de-ejemplo '("aqui hay una clausula" "otra clausula"))
     < src..

     Después de evaluar esta expresión con @k{C-x C-e}, se puede evaluar
     @c{lista-de-ejemplo} y ver que devuelve:

     ..srci > elisp
       > lista-de-ejemplo
       ("aquí hay una claúsula" "otra claúsula")
     < srci..

     Ahora, podemos agregar un nuevo elemento a esta lista evaluando la
     siguiente expresión:

     ..src > elisp
       (push "una tercera cláusula" lista-de-ejemplo)
     < src..

     Cuando evaluamos @c{lista-de-ejemplo}, encontramos que su valor es:

     ..srci > elisp
       > lista-de-ejemplo
       ("una tercera claúsula" "aquí hay una claúsula" "otra claúsula")
     < srci..

     Asi pues, la tercer claúsula se añade a la lista con @c{push}.

     Ahora la segunda parte de la claúsula @c{if}. Esta expresión evita que el
     anillo de la muerte crezca demasiado:

     ..src > elisp
       (if (> (length kill-ring) kill-ring-max)
           (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
     < src..

     El código verifica si la longitud del anillo de la muerte es mayor al
     tamaño máximo permitido. Este es el valor de @c{kill-ring-max} (que es 60,
     por defecto). Si el tamaño del anillo de la muerte es demasiado largo,
     entonces este código establece el último elemento del anillo de la muerte a
     @c{nil}. Hace esto usando dos funciones, @c{nthcdr} y @c{setcdr}.

     Vimos @c{setcdr} anteriormente (ver Seccion @l(#@c{setcdr})). Esto asigna
     el @c{cdr} de una lista, asi como @c{setcar} asigna el @c{car} de una
     lista. En este caso, sin embargo, @c{setcdr} no estará configurando el
     @c{cdr} del anillo de la muerte completo; se usa la función @c{nthcdr} para
     asignar el @c{cdr} del último elemento del anillo de la muerte––esto
     significa que desde el @c{cdr} del siguiente al último elemento del anillo
     de la muerte, se asignará el último elemento del anillo de la muerte.

     La función @c{nthcdr} funciona tomando repetidamente el @c{cdr} de una
     lista––toma el @c{cdr} del @c{cdr} del @c{cdr} …. hace esto @m{N} veces y
     devuelve los resultados. (Vea la Seccion @l{#@c{nthcdr}}.)

     De este modo, si teniamos una lista de cuatro elementos que supuestamente
     debia tener tres elementos de longitud, podriamos asignar el @c{cdr} del
     elemento siguiente al último a @c{nil}, y asi acortar la lista. (Si se
     asigna el último elemento en algún otro valor distinto a @c{nil}, que se
     podría hacer, entonces no se habría acortado la lista. Véase Sección
     @l{#@c{setcdr}}.)

     Puedes ver el acortamiento evaluando las tres siguientes expresiones.
     Primero asigna el valor de @c{arboles} a @c{(arce roble pino abedul)} luego
     asigna el @c{cdr} de su segundo @c{cdr} y entonces descubre el valor de
     @c{arboles}.

     ..srci > elisp
       > (setq arboles '(arce roble pino abedul))
       (arce roble pino abedul)

       > (setcdr (nthcdr 2 arboles) nil)
       nil

       > arboles
       (arce roble pino)
     < srci..

     (El valor devuelto por la expresión @c{setcdr} es @c{nil}, ya que en esto
     se establece el @c{cdr}.)

     Repitiendo, en @c{kill-new}, la función @c{nthcdr} toma el @c{cdr} un
     número de veces, que es uno menos que el tamaño máximo permitido del anillo
     de la muerte y @c{setcdr} asigna el @c{cdr} de este elemento (que será el
     resto de los elementos en el anillo de la muerte) en @c{nil}. Esto evita
     el anillo de la muerte crezca demaciado largo.

     La penultima expresión en la función @c{kill-new} es

     ..src > elisp
       (setq kill-ring-yank-pointer kill-ring)
     < src..

     @c{kill-ring-yank-pointer} es una variable global que se establece
     para ser el @c{kill-ring}.

     Apesar de llamar a @c{kill-ring-yank-pointer} un @'{puntero}, es una
     variable al igual que el anillo de la muerte. Sin embargo, el nombre ha
     sido elegido para ayudar a los humanos a entender cómo se usa la variable.

     Ahora, volviendo a una expresión anterior en el cuerpo de la función:

     ..src > elisp
         (if (fboundp 'menu-bar-update-yank-menu)
              (menu-bar-update-yank-menu string (and replace (car kill-ring))))
     < src..

     Empieza con una expresión @c{if}

     En este caso, la expresión prueba primero si @c{menu-bar-update-yank-menu}
     existe como una función, y si es así, se llama. La función @c{fboundp}
     devuelve verdadero si el símbolo que se prueba tiene una definición de
     función que ‘no es nula’. Si el símbolo de la definición de función fuera
     nulo, recibiríamos un mensaje de error, como lo hicimos cuando se crearon
     errores intencionadamente (ver Seccion @l(#Generar un mensaje de error)).

     La parte-entonces contiene una expresión cuyo primer elemento es la función
     @c{and}.

     La forma especial @c{and} evalúa cada uno de sus argumentos hasta que uno
     de los argumentos devuelve un valor o @c{nil}, en cuyo caso la expresión
     @c{and} devuelve @c{nil}; sin embargo, si ninguno de los argumentos
     devuelve una valor @c{nil}, se devuelve el resultado de la evaluación del
     último argumento. (Dado que tal valor no es @c{nil}, en Emacs Lisp se
     considera verdadero.) En otras palabras, una expresión @c{and} devuelve un
     valor cierto solo si todos sus argumentos son verdaderos. (Vea la Seccion
     @l{#Repaso: Algunas Funciones Más Complejas<>Revisar el segundo búfer
     relacionado}.)

     La expresión determina si el segundo argumento
     @c{menu-bar-update-yank-menu} es verdadero o no.

     @c{menu-bar-update-yank-menu} es una de la funciones que permite utilizar
     el menu ‘Seleccionar y Pegar’ en el elemento Editar de la barra de menu;
     usando un ratón, pueden ver las distintas piezas de texto que se han
     guardado y se seleccionar una pieza para pegar.

     La última expresión en la función @c{kill-new} añade la nueva cadena recien
     copiada a cualquier facilidad existente para copiar y pegar texto entre
     diferentes programas que se ejecutan en un sistema de ventanas. En el
     Sistema de Ventanas X, por ejemplo, la función @c{x-select-text} toma la
     cadena y la almacena en la memoria manejada por X. Puede pegar la cadena en
     otro programa, como Xterm.

     La expresión se ve asi:

     ..src > elisp
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     < src..

     Si @c{interprogram-cut-function} existe, entonces Emacs ejecuta
     @c{funcall}, que a su vez llama a su primer argumento como una función y le
     pasa los argumentos restantes. (Incidentalmente, hasta donde puedo ver,
     esta expresión @c{if} podría reemplazarse por una expresión @c{and} similar
     a la de la primer parte de la función.)

     No vamos a discutir mas sobre sistemas de ventanas y otros programas, sino
     simplemente indicar que este es un mecanismo que permite a GNU Emacs
     trabajar bien y fácilmente con otros programas.

     Este código para colocar texto en el anillo de la muerte, concatenandolo
     con un elemento existente o como un nuevo, nos brinda la habilidad para
     traer texto que ha sido cortado del búfer––los comandos de corte
     @%e(yank). Sin embargo, antes de discutir los comandos de corte, es mejor
     aprender cómo se implementan las listas en un ordenador. Esto pondra de
     manifiesto misterios como el uso del término ‘puntero’. Pero antes de eso,
     nos desviaremos a C.

** Disgresión dentro de C

   La función @c{copy-region-as-kill} (ver Seccion @l{#@c{copy-region-as-kill}})
   usa la función @c{filter-buffer-substring}, que a su vez utiliza la función
   @c{delete-and-extract-region}. Eso elimina el contenido de una región y no se
   puede volverlos a recuperar.

   A diferencia del otro código discutido aquí, la función @c{delete-and-extract-region}
   no está escrita en Emacs Lisp; está escrita en C y es una de las
   primitivas del sistema GNU Emacs. Puesto que es muy simple, voy a desviarme
   brevemente de Lisp y describirla aquí.

   Al igual que muchas de las otras primitivas Emacs, @c{delete-and-extract-region}
   se escribe como una instancia de una macro C, una macro es una plantilla de
   codigo. La macro completa se ve asi:

   ..src > c
     DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
            Sdelete_and_extract_region, 2, 2, 0,
            doc: /* Borra el texto entre START y END y lo devuelve.  */)
            (Lisp_Object start, Lisp_Object end)
     {
       validate_region (&start, &end);
       if (XINT (start) == XINT (end))
         return empty_unibyte_string;
       return del_range_1 (XINT (start), XINT (end), 1, 1);
     }
   < src..

   Sin entrar en los detalles del proceso de escritura de la macro, permitame
   señalar que esta macro comienza con la palabra @c{DEFUN}. La palabra
   @c{DEFUN} fué elegida ya que el código tiene el mismo propósito que @c{defun}
   en Lisp. (La macro C @c{DEFUN} se define en en @f{emacs/src/lisp.h}.)

   La palabra @c{DEFUN} tiene siete partes dentro de los paréntesis:

   - La primera parte es el nombre dado a la función en Lisp,
     @c{delete-and-extract-region}.

   - La segunda parte es el nombre de la función en C,
     @c{Fdelete_and_extract_region}. Por convención, comienza con @'{F}. Puesto
     que C no usa guiones en los nombres, en su lugar se utilizan guiones bajos.

   - La tercera parte es el nombre para la estructura constante C que
     registra información en esta función para uso interno. Es el nombre de
     la función en C pero empieza con una @'{S} en vez de una @'{F}.

   - Las partes cuarta y quinta especifican el número mínimo y máximo de
     argumentos que la función puede tener. Esta función requiere exactamente
     2 argumentos.

   - La sexta parte es casi como el argumento que sigue a la declaración
     @c{interactive} en una función escrita en Lisp: una letra seguida, tal vez,
     por un prompt. La única diferencia con Lisp es que si la macro se llama sin
     argumentos. Entonces se escribe un @c{0} (que es una ‘cadena nula’), como
     en esta macro.

     Si fueras a especificar argumentos, se colocarian entre comillas. La macro
     C para @c{goto-char} incluye @c{\"NGoto char \"} en esta posición se indica
     que la función espera un prefijo en bruto, en este caso, una localización
     numérica en un búfer, y proporciona un prompt.


   - La séptima parte es una cadena de documentación, como la de una función
     escrita en Emacs Lisp. Se escribe como un comentario C. (Cuando se escribe
     Emacs, el programa @${lib-src/make-docfile} extrae estos comentarios y los
     usa para crear la documentación “real”.)


   En una macro C, los parámetros formales vienen a continuacion, con una
   declaracion de que tipo de objeto son, seguido por lo que podría llamarse el
   ‘cuerpo’ de la macro. Para @c{delete-and-extract-region} el ‘cuerpo’ se
   compone de las cuatro líneas siguientes:

   ..src > c
     validate_region (&start, &end);
     if (XINT (start) == XINT (end))
       return build_string ("");
     return del_range_1 (XINT (start), XINT (end), 1, 1);
   < src..

   La función @c{validate_region} comprueba si los valores pasados como el
   principio y fin de la región son del tipo apropiado y estan dentro del
   rango. Si las posiciones de inicio principio y fin son las mismas, entonces
   devuelve una cadena vacía.

   La función @c{del_range_1} borra el texto. Es una función compleja que no
   examinaremos. Actualiza el búfer y hace otras cosas. Sin embargo, vale la
   pena mirar los dos argumentos pasados a @c{del_range}. Estos son @c{XINT
   (start)} y @c{XINT (end)}.

   Por lo que respecta al lenguaje C, @c{start} y @c{end} son dos enteros que
   marcan el principio y el fin de la región a eliminar@n{10}.

   En las primeras versiones de Emacs, estos dos números tenian 32 bits de
   longitud, pero el código está lentamente siendo generalizado para manejar
   otras longitudes. Tres de los bits disponibles son usados para especificar el
   tipo de información; los bits restantes se utilizan como ‘contenido’.

   @'{XINT} es una macro C que extrae los números relevantes desde una colección
   larga de bits; los otros tres bits se descartan.

   El comando en @c{delete-and-extract-region} se ve asi:

   ..src > c
     del_range_1 (XINT (start), XINT (end), 1, 1);
   < src..

   Borra la región entre la posición inicial, @c{start}, y la posición final,
   @c{end}.

   Desde el punto de vista de la persona que escribe Lisp, Emacs es muy simple;
   pero oculta en el fondo mucha complejidad para hacer que funcione.

** Inicializando una variable con @c{defvar}

   La función @c{copy-region-as-kill} esta escrita en Emacs Lisp. Dos funciones
   dentro de ella, @c{kill-append} y @c{kill-new}, copian una región en un búfer
   y la guardan en una variable llamada el @c{kill-ring}. Esta sección describe
   cómo se crea e inicializa la variable @c{kill-ring} usando la forma especial
   @c{defvar}.

   (De nuevo se señala que el término @c{kill-ring} es un mal nombre. El texto
   que se corta del búfer puede ser devuelto; no es un anillo de cadaveres, sino
   un anillo de texto resucitable.)

   En Emacs Lisp, una variable como @c{kill-ring} se crea y da un valor inicial
   usando la forma especial @c{defvar}. El nombre proviene de “definir variable”.

   La forma especial @c{defvar} es similar a @c{setq} en la que se establece el
   valor de una variable. Se diferencia de @c{setq} en dos formas: primero solo
   establece el valor de la variable si la variable no tiene ya un valor. Si la
   variable ya tiene un valor, @c{defvar} no sobreescribe el valor
   existente. Segundo, @c{defvar} tiene una cadena de documentación.

   (Otra forma especial, @c{defcustom}, está diseñada para variables que la
   gente personaliza. Tiene más funcionalidades que @c{defvar}. (Véase
   Sección @l{#Especificar variables usando @c{defcustom}}.)

   Se puede ver el valor actual de una variable, cualquier variable, usando la
   función @c{describe-variable}, que normalmente se invoca escribiendo @k{C-h
   v}. Si presionas @k{C-h v} y luego escribes @c{kill-ring} (seguido por
   @k{RET}), veras lo que hay actualmente en tu anillo de la muerte––¡esto puede
   ser bastante grande! Por el contrario, si no has estado haciendo nada en esta
   sesión en Emacs, excepto leer este documento, es posible no tener nada en
   el. También, se verá la documentación para @c{kill-ring}:

   ..example >
     Documentación:
     Lista de secuencias de texto muerto (guardado).
     Ya que el anillo de la muerte se supone que interactua bien con
     el copia-y-pega que ofrecen los sistemas de ventanas, el uso de
     esta variable debería interactuar bien con las funciones
     ‘interprogram-cut-function’ y ‘interprogram-paste-function’.
     Las funciones ‘kill-new’, ‘kill-append’, y ‘current-kill’ deben
     implementar esta interacción; es posible que desee utilizarlas
     en lugar de manipular el anillo de la muerte directamente.
   < example..

   El anillo de la muerte es definido por un @c{defvar} del siguiente modo:

   ..src > elisp
     (defvar kill-ring nil
       "Lista de secuencia de textos cortados.
     …")
   < src..

   En esta definición de variable, a la variable se le da un valor inicial de
   @c{nil}, lo que tiene sentido, ya que si no has guardado nada, no quieres
   nada de vuelta si das un comando @c{yank}. La cadena de documentación se
   escribe igual que la cadena de documentación de un @c{defun}. Al igual que
   con la cadena de documentacion del defun, la primera linea de la
   documentación deberia ser una frase completa, ya que algunos comandos, como
   @c{apropos}, imprimen solo la primer línea de documentación. Las líneas
   sucesivas no deben indentarse; de lo contrario, se veran extrañas cuando se use
   @k{C-h v} @%c(describe-variable).

*** @c{defvar} y un asterisco

    En el pasado, Emacs usaba la forma especial @c{defvar} tanto para variables
    internas que se esperaba que un usuario cambiara como para las que no se
    esperaban cambios de parte del usuario. Aunque todavía se puede usar
    @c{defvar} para variables personalizadas, por favor, usa @c{defcustom} en
    su lugar, ya que esa forma especial proporciona una ruta a los comando de
    personalización. (Vea la Seccion @l{#Especificar variables usando
    @c{defcustom}}.)

    Cuando se especifica una variable utilizando la forma especial @c{defvar},
    se podría distinguir una variable que un usuario podría querer cambiar de
    otros escribiendo, @'{*}, en la primera columna de su cadena de
    documentación. Por ejemplo:

    ..src > elisp
      (defvar shell-command-default-error-buffer nil
        "*Nombre de buffer para ‘shell-command’ … salida de error.
      … ")
    < src..

    Podrías (y todavía puedes) usar el comando @c{set-variable} para cambiar
    temporalmente el valor de @c{shell-command-default-error-buffer}. Sin
    embargo, las opciones configuradas usando @c{set-variable} solo se
    establecen por la duración de tu sesión actual. Los nuevos valores no se
    guardan entre sesiones. Cada vez que Emacs inicia, lee el valor original, a
    menos que cambie el valor dentro de su fichero @f{.emacs}, ya sea configurándolo
    manualmente o utilizando @c{customize}. Vea la Seccion @l{#Tu Fichero
    @f{.emacs}}.

    Para mí, el mayor uso del comando @c{set-variable} es sugerir variables que
    se podría querer establecer en mi fichero @f{.emacs}. Ahora hay más de 700
    variables, demasiadas para recordarlas fácilmente. Afortunadamente, se puede
    presionar @k{TAB} después de llamar al comando @c{M-x set-variable} para ver
    la lista de variables. (Vea la Seccion @l{info:emacs#Examining and Setting
    Variables<>Examinando y Configurando Variables} en @e(El Manual de GNU
    Emacs).)

** Repaso

   Aquí hay un breve resumen de algunas funciones introducidas recientemente.

   - @c(car), @c(cdr) ::

     @c{car} devuelve el primer elemento de una lista; @c{cdr} devuelve el
     segundo y los siguientes elementos de una lista.

     Por ejemplo:

     ..srci > elisp
       > (car '(1 2 3 4 5 6 7))
       1
       > (cdr '(1 2 3 4 5 6 7))
       (2 3 4 5 6 7)
     < srci..

   - @c(cons) ::

     @c{cons} construye una lista enlazando su primer argumento a su segundo
     argumento.

     Por ejemplo:

     ..srci > elisp
       > (cons 1 '(2 3 4))
       (1 2 3 4)
     < srci..

   - @c(funcall) ::

     @c{funcall} evalúa su primer argumento como una función. Pasa los
     argumentos restantes a su primer argumento.

   - @c(nthcdr) ::

     Devuelve el resultado de tomar @c{cdr} ‘n’ veces en una lista. El
     @m(n^{th}) @c{cdr}. El ‘resto del resto’, por asi decirlo.

     Por ejemplo:

     ..srci > elisp
       > (nthcdr 3 '(1 2 3 4 5 6 7))
       (4 5 6 7)
     < srci..

   - @c(setcar), @c(setcdr) ::

     @c{setcar} cambia el primer elemento de una lista; @c{setcdr} cambia el
     segundo y los siguientes elementos de una lista.

     Por ejemplo:

     ..srci > elisp
       > (setq triple '(1 2 3))

       > (setcar triple '37)

       > triple
       (37 2 3)

       > (setcdr triple '("foo" "bar"))

       > triple
       (37 "foo" "bar")
     < srci..

   - @c(progn) ::

     Evalúa cada argumento en secuencia y luego devuelve el valor del
     último.

     Por ejemplo:

     ..srci > elisp
       > (progn 1 2 3 4)
       4
     < srci..

   - @c(save-restriction) ::

     Graba cualquier reduccion @%e(narrowing) que esté en efecto en el búfer
     actual, si lo hay, y restablece esa reduccion despues de evaluar los
     argumentos.

   - @c(search-forward) ::

     Busca una cadena y, si se encuentra, mueve el punto. De manera similar,
     para una expresión regular utiliza @c{re-search-forward}. (Véase Sección
     @l{#Búsqueda de Expresiones Regulares}, para obtener una explicación de los
     patrones y busquedas de expresiones regulares.)

     @c{search-forward} y @c{re-search-forward} toman cuatro argumentos:

     1. La cadena o expresión regular a buscar.

     2. Opcionalmente, el límite de la búsqueda.

     3. Opcionalmente, que haces si la búsqueda falla, devuelve @c{nil} o un
        mensaje de error.

     4. Opcionalmente, cuántas veces repetir la búsqueda; si es negativa, la
        búsqueda va hacia atrás.

   - @c(kill-region), @c(delete-and-extract-region), @c(copy-region-as-kill) ::

     @c{kill-region} corta el texto entre el punto y la marca del búfer y
     almacena ese texto en el anillo de la muerte, para que puedas recuperarlo
     "tirando" de el.

     @c{copy-region-as-kill} copia el texto entre punto y marca dentro del
     anillo de la muerte. La función no corta ni elimina el texto del búfer.


   @c{delete-and-extract-region} elimina el texto entre el punto y la marca del
   búfer. No puede recuperarse. (Este no es un comando interactivo.)

** Ejercicios de Busqueda

   - Escribe una función interactiva que busque una cadena de texto. Si la
     búsqueda encuentra la cadena, deja el punto después de ella y muestra un
     mensaje que diga “¡Encontrado!”. (No uses @c{search-forward} para el nombre
     de esta función; si se haces, se sobreescribirá la versión existente de
     @c{search-forward} que viene con Emacs. En su lugar utiliza un nombre como,
     por ejemplo, @c{test-search}.

   - Escribe una función que imprima el tercer elemento del anillo de la muerte
     en el área de eco, si lo hay; si el anillo de la muerte no contiene un
     tercer elemento, imprime un mensaje apropiado.

* Cómo se implementan las listas

  En Lisp, los átomos se registran de manera sencilla, si la implementación no
  es sencilla en la práctica, es, sin embargo, sencilla en teoría. El átomo
  @'{rosa}, por ejemplo, se graba como las cuatro letras contiguas @'{r}, @'{o},
  @'{s}, @'{a}. Una lista, por otro lado, se guarda de manera diferente. El
  mecanismo es igualmente simple, pero toma un momento acostumbrarse a la
  idea. Una lista se guarda usando una serie de pares de punteros. En las serie,
  el primer puntero de cada par apunta a un átomo o a otra lista, y el segundo
  puntero de cada par apunta al siguiente par, o al símbolo @c{nil}, que marca
  el final de la lista.

  Un puntero por sí mismo es simplemente la dirección electrónica de lo que
  apunta. Por lo tanto, una lista se guarda como una serie de direcciones
  electrónicas.

  Por ejemplo, la lista @c{(rosa violeta tulipan)} tiene tres elementos,
  @'{rosa}, @'{violeta}, y @'{tulipan}. En el ordenador, la dirección
  electrónica de @'{rosa} se registra en un segmento de memoria del ordenador a
  través de la dirección que da la dirección electrónica de donde el átomo
  @'{violeta} está localizado; y esta dirección (la que dice donde se localiza
  @'{violeta}) se guarda junto con una dirección que dice donde se localiza la
  dirección para el átomo @'{tulipan}.

  Esto parece más complicado de lo que es y es más fácil visto en un
  diagrama:

  ..art >
     ___ ___      ___ ___      ___ ___
    |___|___|--> |___|___|--> |___|___|--> nil
      |            |            |
      |            |            |
      ---> rosa    ---> violeta ---> tulipan
  < art..

  En el diagrama, cada caja representa una palabra de la memoria del ordenador
  que contiene un objeto Lisp, normalmente en forma de una dirección de
  memoria. Las cajas, es decir, las direcciones, están en pares. Cada flecha
  apunta a la dirección de un átomo u otro par de direcciones. La primer caja es
  la dirección electrónica de @'{rosa} y la flecha apunta a @'{rosa}; la segunda
  caja es la dirección del siguiente par de cajas, la primera parte de las
  cuales que es la dirección de @'{violeta} y la segunda parte es la dirección
  del siguiente par. La última caja apunta al símbolo @c{nil}, que marca el fin
  de la la lista.

  Cuando una variable se establece en una lista con una función como @c{setq},
  almacena la dirección de la primera caja en la variable. Asi pues, la
  evaluación de la expresión

  ..src > elisp
    (setq ramo '(rosa violeta tulipan))
  < src..

  crea una situación como esta:

  ..art >
    ramo
      |
      |     ___ ___      ___ ___      ___ ___
       --> |___|___|--> |___|___|--> |___|___|--> nil
             |            |            |
             |            |            |
              --> rosa     --> violeta   --> tulipan
  < art..

  En este ejemplo, el símbolo @c{ramo} contiene la dirección del primer par de
  cajas.

  Esta misma lista puede ser ilustrada en un tipo diferente de notación de
  cajas como este:

  ..art >
    ramo
      |
      |    --------------       ----------------       --------------------
      |   | car   | cdr  |     | car     | cdr  |     | car         | cdr  |
       -->| rosa  |   o------->| violeta |   o------->| tulipan     | nil  |
          |       |      |     |         |      |     |             |      |
           --------------       ----------------       --------------------
  < art..

  (Los símbolos consisten en más de un par de direcciones, pero la estructura de
  un símbolo esta formado por direcciones. En efecto, el símbolo @c{ramo}
  consiste de un grupo de cajas-de-direcciones, una de las cuales es la
  dirección de la palabra impresa @'{ramo}, la segunda es la dirección de una
  definición de función adjunta al símbolo, si la hubiera, una tercera parte la
  cual es la dirección del primer par de cajas-de-direccion para la lista
  @c{(rosa violeta tulipan)}, y así sucesivamente. Aquí mostraremos que la
  tercera caja de direcciónes del símbolo apunta al primer par de
  cajas-de-direccion para la lista.)

  Si un símbolo se asigna al @c{cdr} de una lista, la lista en sí no cambia; el
  símbolo simplemente tiene una dirección mas abajo en la lista. (En la jerga,
  @c{car} y @c{cdr} son ‘no destructivos’.) De este modo, la evaluacion de la
  siguiente expresión

  ..src > elisp
    (setq flores (cdr ramo))
  < src..

  produce esto:

  ..art >
    ramo        flores
      |              |
      |     ___ ___  |     ___ ___      ___ ___
       --> |   |   |  --> |   |   |    |   |   |
           |___|___|----> |___|___|--> |___|___|--> nil
             |              |            |
             |              |            |
              --> rosa       --> violeta  --> tulipan
  < art..

  El valor de @c{flores} es @c{(violeta tulipan)}, es decir, el símbolo
  @c{flores} contiene la dirección del par de cajas-de-direcciones, la primera
  de las cuales contiene la dirección de @c{violeta}, y la segunda contiene la
  dirección de @c{tulipan}.

  Un par de cajas-de-direcciones se denomina una @:{cons cell} o @:{par de
  puntos}. Consulte la Seccion @l{info:elisp#Cons Cell Type<>Cons Cell y Tipos
  de Lista} en @e(El Manual de Referencia de Emacs Lisp), y @l{info:elisp#Dotted
  Pair Notation<>Notación de Pares de Puntos} en @e(El Manual de Referencia de
  GNU Emacs Lisp), para más información acerca las celdas cons y pares de
  puntos.

  La función @c{cons} añade un nuevo par de direcciones al frente de una serie
  de direcciones como la que se muestra a continuacion. Por ejemplo, evaluar la
  expresión

  ..src > elisp
    (setq ramo (cons 'lila ramo))
  < src..

  produce:

  ..art >
    ramo                       flores
      |                             |
      |     ___ ___        ___ ___  |     ___ ___       ___ ___
       --> |   |   |      |   |   |  --> |   |   |     |   |   |
           |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
             |              |              |             |
             |              |              |             |
              --> lila      --> rosa       --> violeta    --> tulipan
  < art..

  Sin embargo, esto no cambia el valor del símbolo @c{flores}, como puedes ver
  evaluando lo siguiente,

  ..src > elisp
    (eq (cdr (cdr ramo)) flores)
  < src..

  que devuelve @c{t} para verdadero.

  Hasta que se reinicia, @c{flores} todavía tiene el valor @c{(violeta
  tulipan)}; es decir, tiene la dirección de la celda cons cuya primer dirección
  es @c{violeta}. Ademas, esto no altera ninguna de las celdas cons
  preexistentes; todas ellas todavía están allí.

  De este modo, en Lisp, para obtener el @c{cdr} de una lista, solo tienes que
  obtener la dirección del siguiente celda cons de la serie; al obtener el
  @c{car} de una lista, se obtiene la dirección del primer elemento de la lista;
  al agregar @%c(cons) un nuevo elemento en una lista, se añade una nueva celda
  cons al frente de la lista. ¡Esto es todo lo que hay! ¡La estructura
  subyacente de Lisp es brillantemente simple!

  ¿Y a que se refiere la última dirección en una serie de celda cons? A la
  direccion de la lista vacía, de @c{nil}.

  En resumen, cuando una variable Lisp se establece a un valor, se proporciona
  la dirección de la lista a la que se refiere la variable.

** Símbolos como una caja con cajones

   En una sección anterior, sugeri que se podría imaginar un símbolo como una
   caja con cajones. La definición de función se coloca en un cajón, el valor en
   otro, y así sucesivamente. Lo que se pone en el cajón que contiene el valor puede
   cambiarse sin afectar el contenido del cajón que contiene la definicion de
   función, y viceversa.

   En realidad, lo que se pone en la caja es la dirección del valor o definición
   de función. Es como si encontraras un viejo cofre en el ático, y en uno de
   sus compartimentos hallaras un mapa con la direccion de donde se encuentra el
   tesoro enterrado.

   (Además de su nombre, la definición del símbolo, y un valor de variable, un
   símbolo tiene un ‘cajón’ para una @:{lista de propiedades} que puede utilizar
   para registrar otra información. Las listas de propiedades no se discuten
   aquí; ver la seccion @l{info:elisp#Property Lists<>Listas de Propiedades} en
   @e{El Manual de Referencia de Emacs Lisp}.)

   Aquí hay una representación imaginaria:

   ..art >
                 Caja de Cajones            Contenidos de los Cajones

                 __   o0O0o   __
               /                 \
              ---------------------
             |    direcciones al   |            [asignar a]
             | nombre del simbolo  |            ramo
             |                     |
             +---------------------+
             |  direcciones a la   |
             |   definición del    |            [nada]
             |    simbolo          |
             +---------------------+
             |    direcciones al   |            [asignar a]
             |   valor de variable |            (rosa violeta tulipan)
             |                     |
             +---------------------+
             |    direcciones a la |
             |lista de propiedades |            [no descrito aquí]
             |                     |
             +---------------------+
             |/                   \|
   < art..

** Ejercicio

   Asignar @c{flores} a @c{violeta} y @c{tulipan}. Asignar dos flores más en
   esta lista y asignarla a @c{mas-flores}. Asigna+ el @c{car} de @c{flores} a un
   pez. ¿Qué lista contiene ahora @c{mas-flores}?

* Pegando texto

  Siempre que cortes texto de un búfer con un comando ‘kill’, puede traerse de
  vuelta con un comando ‘yank’. El texto cortado del búfer es puesto en el
  anillo de la muerte y los comandos yank insertan el contenido apropiado del
  anillo de la muerte en un búfer (no necesariamente el búfer original).

  Un simple comando @k{C-y} @%c(yank) inserta el primer elemento del anillo de
  la muerte dentro en el búfer actual. Si el comando @k{C-y} es seguido
  inmediatamente por @k{M-y}, el primer elemento se reemplaza por el segundo
  elemento. Los sucesivos comandos @k{M-y} reemplazan el segundo elemento con el
  tercer, cuarto, o quinto elemento, y así sucesivamente. Cuando se alcanza el
  último elemento del anillo de la muerte, se reemplaza por el primer elemento y
  el ciclo se repite. (Por la tanto, el anillo de la muerte se llama un ‘anillo’
  en lugar de solo una ‘lista’. Sin embargo, la estructura de de datos real que
  contiene el texto es una lista. Vea la Seccion @l{#Apéndice B Manejando el
  anillo de la muerte}, para los detalles de cómo se maneja la lista como un
  anillo.)

** Resumen del anillo de la muerte

   El anillo de la muerte es una lista de cadenas de texto. Esto es lo que se
   ve:

   ..src > elisp
     ("algún texto" "un texto diferente" "aún más texto")
   < src..

   Si este fuera el contenido de mi anillo de la muerte y pulsara @k{C-y},
   la cadena de caracteres que dice @'{algún texto} seria insertada en este
   búfer donde se encuentra mi cursor.

   El comando @c{yank} también se utiliza para duplicar texto copiándolo. El
   texto copiado no se corta del el búfer, sino que se coloca una copia del
   mismo en el anillo de la muerte y se insarta trayendolo de vuelta.

   Se utulizan tres funciones para devolver el texto del anillo de la muerte:
   @c{yank}, que normalmente se asocia a @k{C-y}; @c{yank-pop}, que normalmente
   se asocia a @k{M-y}; y @c{rotate-yank-pointer}, que se utiliza por las otras
   dos funciones.

   Estas funciones se refieren al anillo de la muerte a través de una variable
   llamada @c{kill-ring-yank-pointer}. De hecho, el codigo de inserción para
   ambas funciones @c{yank} y @c{yank-pop} es:

   ..src > elisp
     (insert (car kill-ring-yank-pointer))
   < src..

   (Bueno, no más. En GNU Emacs 22, la función ha sido reemplazada por
   @c{insert-for-yank} que llama repetidamente a @c{insert-for-yank-1} para cada
   segmento a @c{yank-handler}. A su vez, @c{insert-for-yank-1} elimina las
   propiedades del texto insertado de acuerdo a @c{yank-excluded-properties}. De
   otro modo, seria como @c{insert}. Nosotros pegaremos con un @c{insert} plano
   puesto que es mas fácil de comprender.)

   Para empezar a comprender cómo funcionan @c{yank} y @c{yank-pop}, primero hay
   que mirar la variable @c{kill-ring-yank-pointer}.

** La variable @c{kill-ring-yank-pointer}

   @c{kill-ring-yank-pointer} es una variable, de la misma forma que
   @c{kill-ring} es una variable. Esta apunta a alguna cosa siendo asignada al
   valor de lo que apunta, como cualquier otra variable Lisp.

   De este modo, si el valor del anillo de la muerte es:

   ..src > elisp
     ("algún texto" "un texto diferente" "aún más texto")
   < src..

   y @c{kill-ring-yank-pointer} apunta a la segunda oracion, el valor de
   @c{kill-ring-yank-pointer} es:

   ..src > elisp
     ("un texto diferente" "aún más texto")
   < src..

   Como se explico en el capítulo anterior (Vea la Seccion @l{#Cómo se
   implementan las listas}), el ordenador no guarda dos copias diferentes del
   texto apuntadas tanto por @c{kill-ring} como por @c{kill-ring-yank-pointer}.
   Las palabras “un texto diferente” y “aún más texto” no están duplicadas. En
   su lugar, las dos variables apuntan a las mismas piezas de texto. Aquí hay un
   diagrama:

   ..art >
     kill-ring     kill-ring-yank-pointer
         |               |
         |      ___ ___  |     ___ ___      ___ ___
          ---> |   |   |  --> |   |   |    |   |   |
               |___|___|----> |___|___|--> |___|___|--> nil
                 |              |            |
                 |              |            |
                 |              |             --> "aún más texto"
                 |              |
                 |               --> "un texto diferente"
                 |
                  --> "algún texto"
   < art..

   Tanto la variable @c{kill-ring} y como @c{kill-ring-yank-pointer} son
   punteros. Pero el anillo de la muerte en sí normalmente se describe como si
   fuera realmente lo que lo compone. Se habla de @c{kill-ring} como si fuera la
   lista en lugar de ser un puntero a la lista. Por el contrario, se dice que
   @c{kill-ring-yank-pointer} apunta a una lista.

   Estas dos formas de hablar sobre la misma cosa suenan confusas al principio
   pero tienen sentido tras reflexionar. El anillo de la muerte se piensa
   generalmente como la estructura completa de datos que contiene la información
   de lo que se ha cortado reciéntemente de los búfers de Emacs. Por otra parte,
   @c{kill-ring-yank-pointer}, sirve para indicar––es decir, para ‘apuntar
   a’––esa parte del anillo de la muerte de la cual se inserta el primer
   elemento (el @c{car}).

** Ejercicios con @c{yank} y @c{nthcdr}

   - Usando @k{C-h v} @%c(describe-variable), mira en el valor de tu anillo de
     la muerte. Añade varios elementos a tu anillo de la muerte; mira su valor
     de nuevo. Usando @k{M-y} @%c{yank-pop}, muevete alrededor del anillo de la
     muerte. ¿Cuántos elementos habia en tu anillo de la muerte? Encuentra el
     valor de @c{kill-ring-max}. ¿Estaba lleno tu anillo de la muerte, o podrías
     haber guardado más bloques de texto dentro en el?

   - Usando @c{nthcrd} y @c{car}, construye una serie de expresiones para
     devolver el primer, segundo, tercer y cuarto elemento de una lista.

* Bucles y recursión

  Emacs Lisp tiene dos formas principales para hacer que una expresión, o una
  serie de expresiones, sea evaluada repetidamente: una usa un bucle @c{while},
  y la otra @:{recursión}.

  La repetición puede ser muy valiosa. Por ejemplo, para avanzar cuatro
  oraciones, solo necesitas escribir un programa que avance una oracion y luego
  repetir el proceso cuatro veces. Ya que un ordenador no se aburre o se cansa,
  tal acción repetitiva no tiene los efectos nocivos (como un monton de errores)
  que puede tener en los humanos.

  La mayoria de personas escriben sus funciones de Emacs Lisp usando bucles
  @c{while} y sus parientes; pero se puede usar recursión, que provee un una
  manera muy poderosa de pensar para resolver problemas@n{11}.

** @c{while}

   La forma especial @c{while} prueba si el valor devuelto tras evaluar su
   primer argumento es verdadero o falso. Esto es parecido a lo que el
   intérprete Lisp hace con un @c{if}; el intérprete hace lo siguiente, sin
   embargo, lo que el interprete hace despues es diferente.

   En una expresión @c{while}, si el valor devuelto por evaluar el primer
   argumento es falso, el intérprete Lisp omite el resto de la expresión (el
   @:{cuerpo} de la expresión) y no la evalúa. Sin embargo, si el valor es
   verdadero, el intérprete evalúa el cuerpo de la expresión y luego prueba
   nuevamente si el primer argumento de @c{while} es verdadero o falso. Si el
   valor devuelto al evaluar el primer argumento vuelve a ser verdadero, el
   intérprete Lisp vuelve a evaluar el cuerpo de la expresión.

   La plantilla para una expresión @c{while} se ve así:

   ..src > elisp
     (while prueba-verdadero-o-falso
       cuerpo…)
   < src..

   Siempre que la evaluacion de @c(prueba-verdadero-o-falso) en la expresion
   @c{while} devuelva un valor verdadero, el cuerpo sera evaluado repetidamente.
   Este proceso se llama bucle porque el intérprete Lisp repite lo mismo una y
   otra vez, como un avión que hace un bucle. Cuando el resultado de evaluar
   @c(prueba-verdadero-o-falso) es falso, el intérprete no evalúa el resto de la
   expresión @c{while} y ‘sale del bucle’.

   Claramente, si el valor devuelto evaluando el primer argumento de @c{while}
   es siempre cierto, el cuerpo siguiente será evaluado una y otra vez … y otra
   vez … por siempre. Por el contrario, si el valor devuelto nunca es verdadero,
   las expresiones en el cuerpo nunca serán evaluadas. El arte de escribir un
   bucle @c{while} consiste en elegir un mecanismo tal que
   @c(prueba-verdadero-o-falso) devuelva verdadero solo el número de veces que
   requiere evaluar las subsiguientes expresiones, y luego hacer que la prueba
   devuelva falso.

   El valor devuelto evaluando un @c{while} es el valor de
   @c(prueba-verdadero-o-falso). Una consecuencia interesante de esto es que un
   bucle @c{while} que se evalúa sin errores devolverá @c{nil} o falso
   independientemen de si ha hecho el bucle 1 o 100 veces o ninguna. ¿Una
   expresión @c{while} que se evalúa con exito nunca devuelve un valor
   verdadero! Lo que esto significa es que @c{while} siempre se evalua por sus
   efectos secundarios, es decir, las consecuencias de evaluar las expresiones
   dentro del cuerpo del bucle. Esto tiene sentido. No es el mero acto del bucle
   lo que se desea, sino las consecuencias de lo que ocurre cuando las
   expresiones en el bucle se evaluan repetidamente.

*** Un bucle @c{while} y una lista

    Un forma común para controlar un bucle @c{while} es probar si una lista
    tiene algun elemento. Si es haci, el bucle se repite; pero si no, la
    repetición finaliza. Como esta es una tecnica importante, crearemos un
    ejemplo breve para ilustrarla.

    Un manera sencilla de comprobar si una lista tiene elementos es evaluar la
    lista: si no tiene elementos, se trata de una lista vacía y devuelve la
    lista vacía, @c{()}, que es un sinónimo de @c{nil} o falso. Por otro lado,
    una lista con elementos devolverá estos elementos cuando se evalúe. Ya que
    Emacs Lisp considera como verdadero cualquier valor que no sea @c{nil}, una
    lista que devuelve elementos sera verdadero en un bucle @c{while}.

    Por ejemplo, se puede asignar la variable @c{lista-vacia} a @c{nil} para
    evaluar la siguiente expresión @c{setq}:

    ..src > elisp
      (setq lista-vacia ())
    < src..

    Después de evaluar la expresión @c{setq}, se puede evaluar la variable
    @c{lista-vacia} de la manera habitual, colocando el cursor después del
    símbolo y escribiendo @k{C-x C-e}; aparecerá @c{nil} en tu área de eco:

    ..src > elisp
      lista-vacia
    < src..

    Por otro lado, si se asigna una variable como una lista con elementos, la
    lista aparecerá cuando se evalúe la variable, como se puede ver al evaluar
    las dos expresiones siguientes:

    ..src > elisp
      (setq animales '(gacela jirafa leon tigre))

      animales
    < src..

    De este modo, para crear un bucle @c{while} que pruebe si hay algun elemento
    en la lista @c{animales}, la primera parte del bucle se escribira así:

    ..src > elisp
      (while animales
             …
    < src..

    Cuando @c{while} prueba su primer argumento, la evaluacion de la variable
    @c{animales} devuelve una lista. Mientras la lista tenga elementos, el
    @c{while} considera que el resultado de la prueba es verdadero; pero cuando
    la lista esta vacía, se considera que el resultado de la prueba es falso.

    Para prevenir que el bucle @c{while} se ejecute para siempre, es necesario
    proporcionar algún mecanismo para vaciar la lista. Una técnica usada con
    frecuencia es tener una de las expresiones en el cuerpo de @c{while} que
    asigne el valor del @c(cdr) de la lista a la lista. Cada vez que se evalua
    la función @c{cdr}, la lista se va reduciendo, hasta que finalmente solo
    queda la lista vacía. En este punto, la prueba del bucle @c{while} devolverá
    falso, y al mismo tiempo los argumentos ya no se evaluarán.

    Por ejemplo, la lista de animales asociada a la variable @c{animals} puede
    asignarse a el @c{cdr} de la lista original con la siguiente expresión:

    ..src > elisp
      (setq animales (cdr animales))
    < src..

    Si has evaluado las expresiones anteriores y luego evaluas esta expresión,
    veras aparecer @c{(jirafa leon tigre)} en el área de eco. Si evalúas la
    expresión de nuevo, aparecera @c{(leon tigre)}. Si lo evalúas de nuevo una y
    otra vez, veras @c{(tigre)} y despues la lista vacía, mostrada como @c{nil}.

    Una plantilla para un bucle @c{while} usa la función @c{cdr} repetidamente
    para hacer que @c(prueba-verdadero-o-falso) eventualmente evalue a falso
    como se muesta a continuacion:

    ..src > elisp
      (while prueba-si-la-lista-esta-vacia
        cuerpo…
        establece-lista-al-cdr-de-la-lista)
    < src..

    Esto prueba y uso de @c{cdr} puede colocarse en una funcion a la que se pase
    una lista e imprima cada elemento de esta en una línea propia.

*** Un ejemplo: @c{imprimir-elementos-de-la-lista}

    La función @c{imprimir-elementos-de-la-lista} ilustra un bucle @c{while}
    con una lista.

    La función requiere varias líneas para su salida. Si estás leyendo esto en
    una instancia reciente de GNU Emacs, puedes evaluarlo de la forma habitual.

    Si estas usando una versión antigua de Emacs, es necesario copiar las
    expresiones necesarias en el búfer @f{*scratch*} y evaluarlas allí. Esto se
    debe a que el área de eco solo tenía una línea en las versiones antiguas.

    Puedes copiar las expresiones marcando el principio de la región con
    @k{C-SPC} @%c{set-mark-command}, moviendo el cursor al final de la región y
    luego copiar la región usando @k{M-w} (@c{kill-ring-save}, que llama a
    @c{copy-region-as-kill} y proporciona la realimentación visual). En el búfer
    @f{*scratch*}, puedes copiar las expresiones con @k{C-y} @%c{yank}.

    Después de haber copiado las expresiones al búfer @f{*scratch*}, evalúa cada
    expresión en orden. Asegúrate de evaluar la última expresión,
    @c{(imprimir-elementos-de-la-lista animales)}, presionando @k{C-u C-x C-e},
    es decir, pasando un argumento a @c{eval-last-sexp}. Esto hara que el
    resultado de la evaluación se imprima en el búfer @f{*scratch*} en lugar de
    imprimirse en el área de eco. (De lo contrario, veras algo como esto en tu
    área de eco: @c{^Jgacela^J^Jjirafa^J^Jleon^J^Jtigre^Jnil}, en la que cada
    @'{^J} seria una ‘nueva línea’.)

    En una instancia de GNU Emacs reciente, podria evaluar estas expresiones
    directamente, y el área de eco crecerá para mostrar los resultados.

    ..src > elisp
      (setq animales '(gacela jirafa leon tigre))

      (defun imprimir-elementos-de-la-lista (list)
        "Imprime cada elemento de LIST en una línea."
        (while list
          (print (car list))
          (setq list (cdr list))))

      (imprimir-elementos-de-la-lista animales)
    < src..

    Cuando evalúes las tres expresiones en secuencia, verás esto:

    ..example >
      gacela

      jirafa

      leon

      tigre
      nil
    < example..

    Cada elemento de la lista se imprime en una línea propia (que es lo que hace
    la función @c{print}) y luego se imprime el valor devuelto por la función.
    Como la última expresión de la función es el bucle @c{while}, y como los
    bucles @c{while} siempre devuelven @c{nil}, se imprime un @c{nil} después
    del último elemento de la lista.

*** Un bucle con un contador incremental

    Un bucle no es útil a menos que pare cuando debe. Ademas de controlar un
    bucle con una lista, una forma comun de detener un bucle es escribir el
    primer argumento como una prueba que devuelve falso cuando el número
    correcto de repeticiones esta completo. Esto significa que el bucle debe
    tener un contador––una expresión que cuenta cuántas veces el bucle se repite
    a sí mismo.

    La prueba para un bucle con un contador incremental puede ser una expresión
    como @c{(< contador numero-deseado)} que devuelve @c{t} para verdadero si el
    valor de @c{contador} es menor que el @c{numero-deseado} de repeticiones y
    @c{nil} para falso si el valor de @c{contador} es igual o mayor al
    @c{numero-deseado}. La expresión que incrementa el contador puede ser un
    simple @c{setq} como @c{(setq contador (1+ contador))}, donde @c{1+} es una
    función nativa de Emacs Lisp que añade 1 a su argumento. (La expresión
    @c{(1+ contador)} tiene el mismo resultado que @c{(+ contador 1)}, pero es
    mas facil de leer para un humano.)

    La plantilla para un bucle @c{while} controlado por un contador que se
    incrementa se ve asi:

    ..src > elisp
      asignar-un-valor-inicial-al-contador
      (while (< contador numero-deseado)         ; prueba-verdadero-o-falso
        cuerpo…
        (setq contador (1+ contador)))           ; incremento
    < src..

    Ten en cuenta que se necesita asignar el valor inicial de @c{contador}; por
    lo general se asigna en 1.

**** Ejemplo con contador incremental

     Supón que estás jugando en la playa y decides crear un triángulo de
     guijarros, poniendo uno en la primera fila, dos en la segunda fila, tres en
     la tercera fila y así sucesivamente:

     ..example >
          •
         • •
        • • •
       • • • •
     < example..

     (Hace 2500 años, Pitágoras y otros desarrollaron los principios de la
     teoría de números al considerar preguntas como esta.)

     Supón que quieres saber cuántos guijarros necesitarás para hacer un
     triángulo con 7 filas

     Claramente, lo que necesitas hacer es sumar los números de 1 a 7. Hay dos
     maneras de hacer esto; se puede comenzar con el numero más pequeño, uno, y
     sumar la lista en secuencia, 1, 2, 3, 4 y así sucesivamente; o empezar con
     el número más grande y sumar la lista hacia abajo: 7, 6, 5, 4 y así
     sucesivamente. Debido a que ambos mecanismos ilustran formas comunes de escribir
     el bucle @c{while}, crearemos dos ejemplos, uno contando hacia arriba y el
     otro contando hacia abajo. En este primer ejemplo, empezaremos con 1 y
     sumaremos 2, 3, 4, etc.

     Si quieres sumar toda una lista de números, el camino más fácil de hacerlo
     es sumar todos los números a la vez. Sin embargo, si no se sabe de antemano
     cuántos números tendrá la lista, o si se requiere estar preparado para una
     lista muy larga, entonces se necesita diseñar la suma, a modo de , repetir
     un proceso simple muchas veces en vez de hacer un proceso más complejo una
     y otra vez.

     Por ejemplo, en lugar de sumar todos los guijaros a la vez, lo que se puede
     hacer es sumar el número de guijarros en la primera fila, 1, al número en
     la segunda fila, 2, y entonces añadir el total de estas dos filas a la
     tercera fila, 3. Luego se puede sumar el número en la cuarta fila, 4, al
     total de las primeras tres filas; y así sucesivamente.

     La característica crítica del proceso es que cada acción repetitiva sea
     simple. En este caso, en cada paso se suman solo dos números, el número de
     guijarros en la fila y el total ya encontrado. Este proceso de sumar dos
     números se repite una y otra vez hasta que la última fila ha sido añadida
     al total de todas las filas precedentes. En un bucle más complejo la acción
     repetitiva podría no ser tan sencilla, pero será mas simple que hacerlo
     todo de una sola vez.

**** Las partes de la definición de función

     El análisis anterior nos da los huesos de nuestra definición de
     función: primero, necesitaremos una variable que podemos llamar
     @c{total} que será el número total de guijarros. Este será el valor
     devuelto por la función.

     En segundo lugar, sabemos que la función requerirá un argumento: este
     argumento será el número total de filas del triángulo. Puede llamarse
     @c{numero-de-filas}.

     Finalmente, necesitamos una variable para usar como contador. Podriamos
     llamar a esta variable @c{contador}, pero un mejor nombre es
     @c{numero-de-fila}. Esto se debe a que lo que hace el contador en esta
     función es contar filas, y un programa debería escribirse para ser lo mas
     comprensible posible.

     Cuando el intérprete Lisp comience a evaluar las expresiones de la función,
     el valor de @c{total} deberia ser cero, ya que no hemos sumado nada al
     mismo. Entonces la función debe sumar el número de guijarros en la primera
     fila al total, y luego sumar el número de guijarros en la segunda al total,
     y luego sumar el número de guijarros en la tercera fila al total, y así
     sucesivamente, hasta que no queden más filas por sumar.

     Tanto @c{total} como @c{numero-de-fila} se usan solo dentro de la función,
     por lo que pueden ser declarados como variables locales con @c{let} dando
     sus valores iniciales. Evidentemente, el valor inicial para total
     sera 0. El valor inicial de @c{numero-de-fila} sera 1, ya que comenzaremos
     con la primera fila. Esto significa que la declaracion @c{let} se vera asi:

     ..src > elisp
       (let ((total 0)
             (numero-de-fila 1))
         cuerpo…)
     < src..

     Después de declarar y asignar las variables internas, podemos comenzar el
     bucle @c{while}. La expresión que sirve como prueba deberia devolver un
     valor de @c{t} para verdadero siempre que el @c{numero-de-fila} sea menor o
     igual al @c{numero-de-filas}. (Si la prueba devuelve verdadero solo si el
     número de fila es menor que el número de filas en el triángulo, la última
     fila nunca se sumara al total; por lo tanto, el número de fila tiene que
     ser menor o igual al número de filas.)

     Lisp proporciona la función @c{<=} que devuelve verdadero si el valor de su
     primer argumento es menor o igual al valor de su segundo argumento y falso
     de otro modo. Así que la expresión que el @c{while} evaluará como su prueba
     deveria verse asi:

     ..src > elisp
       (<= numero-de-fila numero-de-filas)
     < src..

     El número total de guijarros se puede encontrar sumando repetidamente el
     número de guijarros en una fila al total ya encontrado. Puesto que el
     número de guijarros en la fila es igual al número de la fila, el total
     puede encontrarse añadiendo el número de filas al total. (Claramente, en
     una situación más compleja, el número de guijarros en la fila podría estar
     relacionado con el número de la fila de una manera más complicada; si este
     fuera el caso, el número de la fila sería reemplazado por la expresión
     apropiada.)

     ..src > elisp
       (setq total (+ total numero-de-fila))
     < src..

     Lo que esto hace es asignar el nuevo valor de @c{total} para que sea igual
     a la suma del número de guijarros en la fila al total anterior.

     Después de establecer el valor de @c{total}, se deben establecer las
     condiciones para la siguiente repetición del bucle, si hay alguna. Esto se
     hace incrementando el valor de la variable @c{numero-de-fila}, que sirve
     como contador. Después de incrementar la variable @c{numero-de-fila}, la
     prueba-verdodero-o-falso al principio del bucle @c{while} prueba si su
     valor aun es menor o igual al valor del @c{numero-de-filas} y, si lo es,
     suma el nuevo valor de la variable @c{numero-de-fila} al @c{total} de la
     repetición previa.

     La función nativa @c{1+} en Emacs Lisp añade 1 a un número, por lo que la
     variable @c{numero-de-fila} puede incrementarse con esta expresión:

     ..src > elisp
       (setq numero-de-fila (1+ numero-de-fila))
     < src..

**** Juntando la definición de función

     Hemos creado las partes para la definición de la función; ahora necesitamos
     juntarlas.

     Primero, el contenido de la expresión @c{while}:

     ..src > elisp
       (while (<= numero-de-fila numero-de-filas)    ; prueva-verdadero-o-falso
         (setq total (+ total numero-de-fila))
         (setq numero-de-fila (1+ numero-de-fila)))  ; incremento
     < src..

     Junto con la expresión @c{let} de la varlist, casi completan el cuerpo de
     la definición de función. Sin embargo, se requiere un ultimo elemento, cuya
     necesidad es algo sutil.

     El toque final es colocar la variable @c{total} en una línea por sí misma
     después de la expresión @c{while}. De lo contrario, el valor devuelto por
     la función completa sera el valor de la última expresión en evaluarse
     dentro del cuerpo del @c{let}, y este es el valor devuelto por el @c{while}
     que es siempre @c{nil}.

     Esto puede no ser evidente a primera vista. Casi parece como si la
     expresión de incremento fuera la última expresión de la función
     completa. Pero esa expresión es parte del cuerpo del @c{while}; es el
     último elemento de la lista que empieza con el símbolo @c{while}. Ademas,
     todo el bucle @c{while} es una lista dentro del cuerpo del @c{let}.

     En el esquema, la función tendra este aspecto:

     ..src > elisp
       (defun nombre-de-la-funcion (lista-de-argumentos)
         "documentacion…"
         (let (varlist)
           (while (prueba-verdadero-o-falso)
             cuerpo-de-while… )
           … ))                    ; aqui necesita la expresión final.
     < src..

     El resultado de evaluar el @c{let} es lo que va a ser devuelto por
     @c{defun} ya que @c{let} no está embebidob dentro de ninguna lista que
     contenga, excepto por el @c{defun} como un todo. Sin embargo, si el
     @c{while} es el último elemento de la expresión @c{let}, la función siempre
     devolverá @c{nil}. ¡Esto no es lo que queremos! En vez de eso, queremos el
     valor de la variable @c{total}. Esto se devuelve simplemente colocando el
     símbolo como el último elemento de la lista empezanda por @c{let}. Eso se
     evalúa después de evaluar los elementos precedentes, lo que significa que
     se evaluó después de que se le ha asignado el valor correcto para el total.

     Puede ser mas fácil ver esto imprimiendo la lista iniciada por @c{let} en
     una línea. Este formato hace evidente que las expresiones @c{varlist} y
     @c{while} son el segundo y tercer elementos de la lista iniciado por
     @c{let}, y @c{total} es el último elemento:

     ..src > elisp
       (let (varlist) (while (prueba-verdadero-o-falso) cuerpo-de-while… ) total)
     < src..

     Poniendo todo junto, la definición de la función @c{triangulo} se ve asi:

     ..src > elisp
       (defun triangulo (numero-de-filas)  ; Versión con
                                           ; contador de incremento.
         "Suma el número de guijarros en un triángulo.
       La primera fila tiene un guijarro, la segunda fila dos guijarros,
       la tercera fila tres guijarros, y así sucesivamente.
       El argumento es NUMERO-DE-FILAS."
         (let ((total 0)
               (numero-de-fila 1))
           (while (<= numero-de-fila numero-de-filas)
             (setq total (+ total numero-de-fila))
             (setq numero-de-fila (1+ numero-de-fila)))
           total))
     < src..

     Después de haber instalado @c{triangulo} al evaluar la función, puede
     probarlo. Aquí hay dos ejemplos:

     ..src > elisp
       (triangulo 4)

       (triangulo 7)
     < src..

     La suma de los primeros cuatro números es 10 y la suma de los primeros
     siete números es 28.

*** Bucle con contador decreciente

    Otra manera común de escribir un bucle @c{while} es con una prueba que
    determine si un contador es mayor que cero. Mientras el contador sea mayor
    que cero, el bucle se repite. Pero cuando el contador es igual o menor que
    cero, el bucle se detiene. Para que esto funcione, el contador tiene que
    empezar por encima de cero y luego hacerse mas y mas pequeño por una forma
    que se evalua repetidamente.

    La prueba será una expresión como @c{(> contador 0)} que devuelve @c{t} para
    verdadero si el valor del @c{contador} es mayor que cero, y @c{nil} para
    falso si el valor del @c{contador} es igual a o menor que cero. La expresión
    que hace que el número menor sea cada vez mas pequeño puede ser un simple
    @c{setq} como @c{(setq contador (1- contador)}, donde @c{1-} es una función
    nativa en Emacs Lisp que resta 1 de su argumento.

    La plantilla para un bucle @c{while} decreciente se ve así:

    ..src > elisp
      (while (> contador 0)                   ; prueba-verdadero-o-falso
        cuerpo…
        (setq contador (1- contador)))        ; decremento
    < src..

**** Ejemplo con contador decreciente

     Para ilustrar un bucle con un contador decreciente, reescribiremos la
     función @c{triangulo} para que el contador disminuya a cero.

     Esto es lo inverso de la versión anterior de la función. En este caso, para
     saber cuantos guijarros se necesitan para crear un triángulo con 3 filas,
     se suma el número de guijarros en la tercera fila, 3, al numero en la fila
     anterior, 2, y luego se suman el total de esas dos filas a la fila que lo
     precede, que es 1.

     Del mismo modo, para encontrar el número de guijarros en un triángulo con 7
     filas, se suma el número de guijarros en la fila siete, 7, al número en la
     fila anterior, que es 6, y luego se suma el total de estas dos filas a la
     fila que las precede, que es 5, y así sucesivamente. Como en el ejemplo
     previo, cada suma solo implica sumar dos números, el total de las filas ya
     sumadas y el número de guijarros en la fila que se suma al total. Este
     proceso de sumar dos números se repite una y otra vez hasta que no haya más
     guijarros que agregar.

     Sabemos con cuántos guijarros empezar: el número de guijarros en la última
     fila es igual al número de filas. Si el triángulo tiene siete filas, el
     número de guijarros en la última fila es 7. Del mismo modo, sabemos cuántos
     guijarros hay en la fila anterior: uno menos que el número en la fila
     actual.

**** Las partes de la definición de función

     Empezamos con tres variables: el número total de filas en el triángulo; el
     número de guijarros en una fila; y el número total de guijarros, que es lo
     que queremos calcular. Estas variables pueden llamarse @c{numero-de-filas},
     @c{numero-de-guijarros-en-fila}, y @c{total}, respectivamente.

     Tanto @c{total} como @c{numero-de-guijarros-en-fila} se usan solo dentro de
     la función y se declaran con @c{let}. El valor inicial de @c{total} deberia
     ser cero. Sin embargo, el valor inicial de @c{numero-de-guijarros-en-fila}
     deberia ser igual al número de filas en el triángulo, ya que la suma
     comenzara con la fila más larga.

     Esto significa que el principio de la expresión @c{let} se verá así:

     ..src > elisp
       (let ((total 0)
             (numero-de-guijarros-en-fila numero-de-filas))
         body…)
     < src..

     El número total de guijarros se puede encontrar sumando repetidamente
     el número de guijarros en una fila al total ya encontrado, es decir,
     evaluando repetidamente la siguiente expresión:

     ..src > elisp
       (setq total (+ total numero-de-guijarros-en-fila))
     < src..

     Después de sumar @c{numero-de-guijarros-en-fila} al @c{total}, el
     @c{numero-de-guijarros-en-fila} debe decrecer por uno, ya que la siguiente
     vez que el bucle se repita, la fila anterior se sumara al total.

     El número de guijarros en una fila anterior es uno menos que el número de
     guijarros en la fila actual, por lo que se utilizara la función nativa
     @c{1-} de Emacs para calcular el número de guijarros de la fila
     anterior. Esto se puede hacer con la siguiente expresión:

     ..src > elisp
       (setq numero-de-guijarros-en-fila
             (1- numero-de-guijarros-en-fila))
     < src..

     Finalmente, sabemos que el bucle @c{while} deberia detenerse cuando no
     halla guijarros en una fila. Así que la prueba en el bucle @c{while} es
     simple:

     ..src > elisp
       (while (> numero-de-guijarros-en-fila 0)
     < src..

**** Juntando la definición de función

     Podemos juntar estas expresiones para crear una definición de función que
     funcione. Sin embargo, al examinarlas, encontraremos que una de la
     variables locales ¡es innecesaria!

     La definición de función tiene este aspeto:

     ..src > elisp
       ;;; Primer version decreciente.
       (defun triangulo (numero-de-filas)
         "Suma el número de guijarros en un triángulo."
         (let ((total 0)
               (numero-de-guijarros-en-fila numero-de-filas))
           (while (> numero-de-guijarros-en-fila 0)
             (setq total (+ total numero-de-guijarros-en-fila))
             (setq numero-de-guijarros-en-fila
                   (1- numero-de-guijarros-en-fila)))
           total))
     < src..

     Como esta escrita, esta función funciona.

     Sin embargo, no se necesita @c{numero-de-guijarros-en-fila}.

     Cuando se evalua la función @c{triangle}, el símbolo @c{numero-de-filas} se
     vinculara a un número, dandole un valor inicial. Ese número puede ser
     modificado en el cuerpo de la función como si fuera una variable local, sin
     temor a que tal cambio afecte el valor de la variable fuera de la
     función. Esta es una característica muy útil de Lisp; significa que la
     variable @c{numero-de-filas} se puede utilizar en cualquier lugar de la
     función donde se utilice @c{numero-de-guijarros-en-fila}.

     Aquí hay una segunda versión de la función escrita un poco más
     limpiamente:

     ..src > elisp
       (defun triangulo (numero)                ; Segunda versión.
         "Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO."
         (let ((total 0))
           (while (> numero 0)
             (setq total (+ total numero))
             (setq numero (1- numero)))
           total))
     < src..

     En resumen, un bucle @c{while} escrito apropiadamente constará de tres
     partes:

     1. Una prueba que devuelva falso después de que el bucle se ha repetido el
        número de veces correcto.

     2. Una expresión cuya evaluación repetida devolverá el valor deseado.

     3. Una expresión para cambiar el valor pasado a la prueba-verdadero-o-falso
        para que esta devuelva falso después de que el bucle se haya repetido el
        numero de veces correcto.

** Ahorra tu tiempo: @c{dolist} y @c{dotimes}

   Además de @c{while}, tanto @c{dolist} como @c{dotimes} proveen un
   bucle. Algunas veces estos son mas rápidos de escribir el bucle @c{while}
   equivalente. Ambos son macros Lisp. (Vea la Seccion
   @l{info:elisp#Macros<>Macros} en @e(El Manual de Referencia GNU Emacs Lisp).)

   @c{dolist} funciona como un bucle @c{while} con ‘@c{cdr}s que bajan la
   lista’: @c{dolist} acorta automáticamente con cada bucle––toma el @c{cdr} de
   la lista––y liga el @c{car} de cada versión mas corta al primero de sus
   argumentos.

   @c{dotimes} repite el bucle un número específico de veces: tu especificas el
   número.

*** La macro @c{dolist}

    Supón, por ejemplo, que quieres invertir una lista, para que “primero”,
    “segundo”, “tercero” se convierta en “tercero”, “segundo”, “primero”.

    En la práctica, usarías la función @c{reverse}, como aqui:

    ..src > elisp
      (setq animales '(gacela jirafa leon tigre))

      (reverse animales)
    < src..

    A continuacion se muestra como se podría invertir la lista usando un bucle
    @c{while}:

    ..src > elisp
      (setq animales '(gacela jirafa leon tigre))

      (defun invertir-lista-con-while (lista)
        "Usando while, invierte el orden de LISTA."
        (let (valor)  ; asegura que la lista comienza vacía
          (while lista
            (setq valor (cons (car lista) valor))
            (setq lista (cdr lista)))
          valor))

      (invertir-lista-con-while animales)
    < src..

    Y aquí se ve cómo puedes usar la macro @c{dolist}:

    ..src > elisp
      (setq animales '(gacela jirafa leon tigre))

      (defun invertir-lista-con-dolist (lista)
        "Usando dolist, invierte el orden de LISTA."
        (let (valor)  ; asegura que la lista empieza vacía
          (dolist (elemento lista valor)
            (setq valor (cons elemento valor)))))

      (invertir-lista-con-dolist animales)
    < src..

    Puedes colocar el cursor después del parentesis de cierre de
    cada expresión y pulsar @k{C-x C-e}; en cualquier caso, deberias ver

    ..src > elisp
      (tigre leon jirafa gacela)
    < src..

    en el área de eco.

    Para este ejemplo, la función @c{reverse} obviamente es la mejor opcion. El
    bucle @c{while} es como nuestro primer ejemplo (ver Seccion @l{#Un bucle
    @c{while} y una lista}). @c{while} comprueba si la lista tiene elementos; si
    es así, construye una nueva lista añadiendo el primer elemento de la lista a
    la lista existente (que en la primer iteración del bucle es @c{nil}). Puesto
    que el segundo elemento se asigna delante del primero, y el tercero delante
    del segundo, la lista se invierte.

    En la expresión que usa un bucle @c{while}, la expresión @c{(setq lista (cdr
    lista))} acorta la lista, por lo que el bucle @c{while} termina
    deteniendose. Además, se proporciona la expresión @c{cons} con un nuevo
    primer elemento creando una nueva lista en cada repetición del bucle.

    La expresión @c{dolist} hace lo mismo que la expresión @c{while}, excepto
    que la macro @c{dolist} hace algo del trabajo que tienes que hacer cuando se
    escribe una expresión @c{while}.

    Como un bucle @c{while}, @c{dolist} hace un bucle. Lo que es diferente es
    que @%c(dolist) acorta automáticamente la lista con cada repeticion––con
    ‘@c{cdr}s que bajan la lista’ por su cuenta––y asocia automáticamente el
    @c{car} de cada versión acortada de la lista al primero de sus argumentos.

    En el ejemplo, el @c{car} de cada versión reducida de la lista se vincula al
    símbolo @'{elemento}, la lista en sí se llama @'{lista}, y el valor devuelto
    se llama @'{valor}. El resto de la expresión @c{dolist} es el cuerpo.

    La expresión @c{dolist} asocia el @c{car} de cada versión reducida de la
    lista a @c{elemento} y luego evalúa el cuerpo de la expresión y repite
    el bucle. El resultado es devuelto en @c{valor}.

*** La macro @c{dotimes}

    La macro @c{dotimes} es similar a @c{dolist}, excepto que el bucle se
    repite un número específico de veces.

    Al primer argumento de @c{dotimes} se le asignan los números 0, 1, 2 y así
    sucesivamente cada iteracion, y se devuelve el valor del tercer. Se necesita
    proveer el valor del segundo argumento, que es el numero de veces que la
    macro se repite.

    Por ejemplo, lo siguiente asocia al primer argumento @c(numero) los números
    de 0 en adelante, pero no incluye, el número 3, y luego construye una lista
    de los tres números. (El primer número es 0, el segundo es 1, y el tercero es
    2; esto hace un total de tres, comenzando con cero como el primer número.)

    ..srci > elisp
      > (let (valor)      ; de otro modo, "valor" es una variable vacia
      ^   (dotimes (numero 3 valor)
      ^     (setq valor (cons numero valor))))
      (2 1 0)
    < srci..

    @c{dotimes} devuelve @c{valor}, así que la forma de usar @c{dotimes} es
    operar sobre alguna expresión @c(numero) un numero veces y luego devolver el
    resultado, como una lista o un átomo.

    Aquí hay un ejemplo de un @c{defun} que usa @c{dotimes} para sumar el número
    de guijarros en un triángulo.

    ..src > elisp
      (defun triangulo-utilizando-dotimes (numero-de-filas)
        "Usando dotimes, suma el número de guijarros en un triángulo."
      (let ((total 0))  ; de otro modo total es una variable vacía
        (dotimes (numero numero-de-filas total)
          (setq total (+ total (1+ numero))))))

      (triangulo-utilizando-dotimes 4)
    < src..

** Recursividad

   Una función recursiva contiene código que indica al intérprete Lisp que llame
   a un programa que se ejecuta exactamente como el mismo, pero con argumentos
   ligeramente diferentes. El código funciona exactamente igual porque tiene el
   mismo nombre. Sin embargo, aunque el programa tenga el mismo nombre, no es la
   misma entidad. Eso es diferente. En la jerga, se dice es una ‘instancia’
   diferente.

   Eventualmente, si el programa se escribe correctamente, los ‘argumentos
   ligeramente diferentes’ llegan a ser suficientemente diferentes de los
   primeros argumentos para que se detenga la instancia final.

*** Construyendo robots: Extendiendo la metáfora

    Algunas veces es útil pensar en un programa en ejecución como un robot que
    hace un trabajo. Al hacer su trabajo, una función recursiva llama a un
    segundo robot para que le ayude. El segundo robot es idéntico al primero en
    todos los sentidos, excepto que el segundo robot ayuda al primero y ha
    recibido argumentos diferentes al primero.

    En una función recursiva, el segundo robot puede llamar a un tercero; y el
    tercero puede llamar a un cuarto, y así sucesivamente. Cada uno de ellos es
    una entidad diferente; pero todos son clones.

    Dado que cada robot tiene instrucciones ligeramente diferentes––los
    argumentos difieren de un robot a otro––el último robot deberia saber cuando
    detenerse.

    Expandamos la metáfora en la que un programa de ordenador es un robot.

    Una definición de función proporciona los panos para un robot. Cuando se
    instala una definición de función, que es, cuando se evalúa una forma
    especial @c{defun}, se instala el equipo necesario para construir robots. Es
    como si estuvieras en una fábrica, construyendo una línea de montaje. Los
    robots con el mismo nombre se construyen segun los mismos planos. Así que
    tienen, por asi decirlo, el mismo ‘número de modelo’, pero un ‘número de
    serie’ diferente.

    A menudo decimos que una función recursiva ‘se llama así misma’. Lo que
    queremos decir es que las instrucciones en una función recursiva hacen que
    el intérprete Lisp ejecute una función diferente que tiene el mismo nombre y
    hace el mismo trabajo que la primera, pero con argumentos diferentes.

    Es importante que los argumentos difieran de una instancia a la siguiente;
    de otro modo, el proceso nunca se detendra.

*** Las partes de una definición recursiva

    Una función recursiva típicamente contiene una expresión condicional que
    tiene tres partes:

    1. Una prueva-verdadero-o-falso que determina si la función se vuelve a llamar,
       aquí se llamara @:{prueba-hazlo-de-nuevo}.

    2. El nombre de la función. Cuando este nombre se llama, se crea una nueva
       instancia de la función––un nuevo robot, por asi decirlo––y se le dice qué
       hacer.

    3. Una expresión que devuelve un valor diferente cada vez que se llama a la
       función, aquí se llamara @:{expresion-del-siguiente-paso}.
       Consecuentemente, el argumento (o argumentos) pasados a la nueva
       instancia de la función será diferente del argumento (o argumentos)
       pasados a la instancia previa. Esto hace que la expresión condicional, la
       @:{prueba-hazlo-de-nuevo}, devuelva falso después del número correcto de
       repeticiones.


    Las funciones recursivas pueden ser mucho más simples que cualquier otro
    tipo de funcion. De hecho, cuando las personas comienzan a usarlas, con
    frecuencia se ven tan misteriosamente simples como para ser incomprensibles.
    Al igual que montar en bicicleta, leer la definicion de una función
    recursiva requiere una cierta habilidad, es dificil al principio, pero
    después parece facil.

    Hay varios patrones recursivos diferentes. Un patrón muy simple se ve asi:

    ..src > elisp
      (defun nombre-de-funcion-recursiva (lista-de-argumentos)
        "documentation…"
        (if prueba-hazlo-de-nuevo
          cuerpo…
          (nombre-de-funcion-recursiva expresion-del-siguiente-paso)))
    < src..

    Cada vez que se evalua una función recursiva, se crea una nueva instancia y
    se le dice qué hacer. Los argumentos le dicen a la instancia qué hacer.

    Un argumento es ligado al valor de la expresion-del-siguiente-paso. Cada
    instancia se ejecuta con un valor de la expresion-del-siguiente-paso
    diferente.

    El valor en la expresion-del-siguiente-paso se utiliza en la
    prueba-hazlo-de-nuevo.

    El valor devuelto por la expresion-del-siguiente-paso se pasada a la nueva
    instancia de la función, que lo evalúa para determinar si continua o se
    detiene. La expresion-del-siguiente-paso está diseñada para que la
    prueba-hazlo-de-nuevo devuelva falso cuando la función ya no deba repetirse.

    La prueba-hazlo-de-nuevo a veces se denomina @:{condición de parada}, ya que
    detiene las repeticiones cuando la prueba falla.

*** Recursividad con una lista

    El ejemplo de un bucle @c{while} que imprimia los elementos de una lista
    de números puede escribirse recursivamente. Aquí está el código,
    incluyendo una expresión para asignar el valor de la variable
    @c{animales} a una lista.

    Si estás leyendo esto dentro de Emacs, puedes evaluar esta expresión
    directamente. De lo contrario, debes copiar el ejemplo al búfer
    @f{*scratch*} y evalúar cada expresión alli. Utiliza @k{C-u C-x C-e} para
    evaluar la expresión @c{(imprimir-elementos-recursivamente animales)} de
    manera que se imprima el resultado en el búfer; de otro modo el intérprete
    Lisp colocara los resultados en la línea del área de eco.

    También, coloca el  cursor inmediatamente después del último paréntesis
    de cierre de la función @c{imprimir-elementos-recursivamente}, antes del
    comentario. De lo contrario, el intérprete Lisp intentará evaluar el
    comentario.

    ..src > elisp
      (setq animales '(gacela jirafa leon tigre))

      (defun imprimir-elementos-recursivamente (lista)
        "Imprime cada elemento de LISTA en una línea propia.
      Usa recursión."
        (when lista                               ; prueba-hazlo-de-nuevo
              (print (car lista))                 ; cuerpo
              (imprimir-elementos-recursivamente  ; llamada recursiva
               (cdr lista))))                     ; expresion-del-siguiente-paso

      (imprimir-elementos-recursivamente animales)
    < src..

    La función @c{imprimir-elementos-recursivamente} primero prueba si hay algun
    contenido en la lista; si lo hay, la función imprime el primer elemento de
    la lista, el @c{car} de la lista. Entonces la función se ‘invoca en sí
    misma’, pero se da como su argumento, no la lista completa, pero el segundo
    y subsiguientes elementos de esta, es decir, el @c{cdr} de la lista.

    Dicho de otro modo, si la lista no está vacía, la función invoca otra
    instancia de código que es similar al código inicial, pero es un hilo
    de ejecución diferente, con argumentos diferentes o los de la primera instancia.

    Dicho de otro modo más, si la lista no está vacía, el primer robot ensambla
    un segundo robot y le dice qué hacer; el segundo robot es un individuo
    diferente del primero, pero es del mismo modelo.

    Cuando se produce la segunda evaluación, se evalua la expresión @c{when} y
    si es verdadera, imprime el primer elemento de la lista que recibe como
    argumento (que es el segundo elemento de la lista original). A continuacion
    la función ‘se llama a sí misma’ (la segunda vez) con el @c{cdr} del @c{cdr}
    de la lista original.

    Ten en cuenta que aunque decimos que la función ‘se llama a sí misma’, lo
    que queremos decir es que el intérprete Lisp ensambla e instruye una nueva
    instancia del programa. La nueva instancia es un clon del primero, pero es
    un individuo separado.

    Cada vez que la función ‘se invoca a sí misma’, se invoca con una versión
    mas corta de la lista original. Crea una nueva instancia que funciona en una
    lista mas corta.

    Eventualmente, la función se invoca a sí misma con una lista vacía. Crea una
    nueva instancia cuyo argumento es @c{nil}. La expresión condicional prueba
    el valor de @c{lista}. Ya que el valor de la @c{lista} es @c{nil}, la
    expresión @c{when} devuelve falso así la parte-then no sera evaluada. La
    función como un todo entonces devuelve @c{nil}.

    Cuando se evalúa la expresión @c{(imprimir-elementos-recursivamente animales)} en
    el búfer @f{*scratch*}, se ve este resultado:

    ..example >
      gacela

      jirafa

      leon

      tigre
      nil
    < example..

*** Recursión en lugar de un contador

    La función @c{triangulo} descrita en una sección anterior tambien se puede
    escribir recursivamente. Se vera así:

    ..src > elisp
      (defun triangulo-recursivo (numero)
        "Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.
      Usa recursion."
        (if (= numero 1)                    ; prueba-hazlo-de-nuevo
            1                               ; parte-then
          (+ numero                         ; parte-else
             (triangulo-recursivo           ; llamada recursiva
              (1- numero)))))               ; expresion-del-siguiente-paso

      (triangulo-recursivo 7)
    < src..

    Puedes instalar esta función evaluandola y luego probarla evaluando
    @c{(triangulo-recursivo 7)}. (Recuerda colocar tu cursor inmediatamente
    después del último paréntesis de la definición de la función, antes del
    comentario.) La función se evalúa a 28.

    Para comprender cómo funciona esta función, hay que considerar qué ocurre en
    varios casos cuando la función pasa 1, 2, 3, o 4 como el valor de su
    argumento.

    Primero, ¿que sucede si el valor del argumento es 1?

    La función tiene una expresión @c{if} después de la cadena de
    documentación. Prueba si el valor de @c{numero} es igual a 1; si es
    así, Emacs evalúa la parte-then de la expresión @c{if}, que devuelve el
    número 1 como el valor de la función. (Un triángulo con una fila tiene un
    guijarro dentro.)

    Supón, sin embargo, que el valor del argumento es 2. En este caso, Emacs
    evalúa la parte-else de la expresión @c{if}.

    La parte-else consiste de una suma, la llamada recursiva a
    @c{triangulo-recursivo} y una acción de decremento; y se ve así:

    ..src > elisp
      (+ numero (triangulo-recursivo (1- numero)))
    < src..

    Cuando Emacs evalúa esta expresión, la expresión interna se evalua
    primero; luego las otras partes en secuencia. Aquí están los pasos en
    detalle:

    - Paso 1 Evalúar la expresión interna. ::

      La expresión mas interna es @c{(1- numero)} por lo que Emacs decrementa el valor
      de @c{numero} de 2 a 1.

    - Paso 2 Evalúar la función @c{triangulo-recursivo}.

      El intérprete Lisp crea una instancia individual de
      @c{triangulo-recursivo}. No importa que esta función este contenida dentro
      de sí misma. Emacs pasa el resultado del Paso 1 como el argumento usado
      por esta instancia de la función @c{triangulo-recursivo}

      En este caso, Emacs evalúa @c{triangulo-recursivo} con un argumento
      de 1. Esto significa que esta evaluación de @c{triangulo-recursivo}
      devuelve 1.

    - Paso 3 Evalúar el valor de @c{numero}. ::

      La variable @c{numero} es el segundo elemento de la lista que empieza
      con @c{+}; su valor es 2.

    - Paso 4 Evalúar la expresión @c{+}. ::

      La expresión @c{+} recibe dos argumentos, el primero viene de la
      evaluación del @c{numero} (Paso 3) y el segundo de la evaluación de
      @c{triangulo-recursivo} (Paso 2).

      El resultado de la operacion es la suma de 2 + 1, y se devuelve el número
      3, que es correcto. Un triángulo con dos filas tiene tres guijarros.

**** Un argumento de 3 o 4

     Supón que @c{triangulo-recursivo} se llama con un argumento de 3.

     - Paso 1 Evalúa la prueba-hazlo-de-nuevo. ::

       La expresión @c{if} se evalúa primero. Esto es la prueba-hazlo-de-nuevo y
       devuelve falso, así que se evalua la parte-else de la expresión
       @c{if}. (Tenga en cuenta que en este ejemplo, la prueba-hazlo-de-nuevo
       hace que la función se llame a sí misma cuando la prueba es falsa, no
       cuando es verdadera.)

     - Paso 2 Evalúar la expresión mas profunda de la parte-else. ::

       Se evalua la expresión mas interna de la parte-else, que decrementa 3
       a 2. Esta la expresion-del-siguiente-paso.

     - Paso 3 Evalúar la función @c{triangulo-recursivo}. ::

       El número 2 se pasa a la función @c{triangulo-recursivo}.

       Nosotros ya sabemos lo que ocurre cuando Emacs evalúa
       @c{triangulo-recursivo} con un argumento de 2. Después de pasar a través de
       la secuencia de acciones descritas anteriormente, devuelve un valor
       de 3. Así que eso es lo que ocurrirá aquí.

     - Paso 4 Evalúar la suma. ::

       3 será pasado como argumento a la suma y se sumara al número con el que
       se ha llamado a la función, que es 3.


     El valor devuelto por la función en su conjunto será 6.

     Ahora que sabemos qué ocurrirá cuando se llame a @c{triangulo-recursivo}
     con un argumento de 3, es evidente lo que ocurrirá si se llama con un
     argumento de 4:

     ..tab >
       En la llamada recursiva, la evaluación de

       ..src > elisp
         (triangulo-recursivo (1- 4))
       < src..

       devolvera el valor de evaluar

       ..src > elisp
         (triangulo-recursivo 3)
       < src..

       que es 6 y este valor se sumara a 4 mediante la suma en la tercera
       línea.
     < tab..


     El valor devuelto por la función en su conjunto será 10.

     Cada vez que se evalua @c{triangulo-recursivo}, se evalua una
     versión de sí mismo––una instancia diferente en sí––con un argumento
     mas pequeño, hasta que el argumento es lo suficientemente pequeño para que
     no se evalue a si mismo.

     Ten en cuenta que este particular diseño de una función recursiva
     requiere que las operaciones sean diferidas.

     Antes de que @c{(triangulo-recursivo 7)} pueda calcular su respuesta, debe
     llamar a @c{(triangulo-recursivo 6)}; y antes de que
     @c{(triangulo-recursivo 6)} pueda calcular su respuesta debe llamar a
     @c{(triangulo-recursivo 5)}; y así sucesivamente. Esto decir, el cálculo
     que hace @c{(triangulo-recursivo 7)} debe ser pospuesto hasta que
     @c{(triangulo-recursivo 6)} haga su cálculo; y @c{(triangulo-recursivo 6)}
     debe posponerse hasta que @c{(triangulo-recursivo 5)} se complete; y así
     sucesivamente.

     Si se piensa que cada una de estas instancias de @c{triangulo-recursivo}
     son robots diferentes, el primer robot debe esperar al segundo para
     completar su trabajo, que debe esperar hasta que el tercero se complete, y
     así sucesivamente.

     Hay un camino alrededor de este tipo de espera, que se discutirá en la Seccion
     @l{#Recursividad sin deferencias}.

*** Ejemplo de recursión usando @c{cond}

    La versión de @c{triangulo-recursivo} descrita anteriormente se escribió con la
    forma especial @c{if}. También se puede escribir usando otra forma
    especial llamada @c{cond}. El nombre de la forma especial @c{cond} es una
    abreviación de la palabra @'{conditional}.

    Aunque la forma especial @c{cond} no se usa tan a menudo en las fuentes
    de Emacs como @c{if}, se usa con bastante frecuencia para justificar su
    explicacion.

    La plantilla de una expresión @c{cond} se ve asi:

    ..src > elisp
      (cond
       cuerpo…)
    < src..

    donde el @c{cuerpo} es una serie de listas.

    Escrito de forma más completa, la plantilla se ve asi:

    ..src > elisp
      (cond
       (primera-prueba-verdadero-o-falso primera-consequencia)
       (segunda-prueba-verdadero-o-falso segunda-consequencia)
       (tercera-prueba-verdadero-o-falso tercera-consequencia)
        …)
    < src..

    Cuando el intérprete Lisp evalúa la expresión @c{cond}, evalúa el primer
    elemento (el @c{car} o prueba-verdadero-o-falso) de la primer expresión en
    una serie de expresiones dentro del cuerpo del @c{cond}.

    Si la prueba-verdadero-o-falso devuelve @c{nil} el resto de esa expresión se
    descarta y se evalua la prueba-verdadero-o-falso de la siguiente
    expresión. Cuando se encuentra una expresión cuya prueba-verdadero-o-falso
    devuelve un valor que no es @c{nil}, se evalua el resto de esa expresión. El
    resto puede ser una o más expresiones. Si el resto consiste de
    más de una expresión, las expresiones se evaluan en secuencia y se devuelve el valor
    de la última. Si la expresión no tiene un resto, se devuelve
    el valor de la prueba-verdadero-o-falso.

    Si ninguna de las pruebas prueba-verdadero-o-falso es verdadera, la
    expresión @c{cond} devuelve @c{nil}.

    Asi se ve la función @c{triangle}, usando @c{cond}:

    ..src > elisp
      (defun triangulo-usando-cond (numero)
        (cond ((<= numero 0) 0)
              ((= numero 1) 1)
              ((> numero 1)
               (+ numero (triangulo-usando-cond (1- numero))))))
    < src..

    En este ejemplo, el @c{cond} devuelve 0 si el número es menor o igual a 0,
    devuelve 1 si el número es 1 y evalúa @c{(+ numero (triangulo-usando-cond
    (1- numero)))} si el número es mayor a 1.

*** Patrones recursivos

    Aquí hay tres patrones recursivos comunes. Cada uno implica una lista. La
    recursión no necesita involucrar listas, pero Lisp esta diseñado para listas
    y esto proporciona una idea de sus capacidades primarias.

**** Patrón recursivo: @e{every}

     En el patrón recursivo @c{every}, se desarrolla una acción en cada
     elemento de una lista.

     El patrón básico es:

     - Si una lista esta vacía, devuelve @c{nil}.

     - Si no, actua al principio de la lista (el @c{car} de la lista)

       - a través de una llamada recursiva por la función en el resto (el
         @c{cdr}) de la lista,

       - y, opcionalmente, combina el elemento sobre el que actúa, usando
         @c{cons}, con los resultados de actuar sobre el resto.


     Aquí está el ejemplo:

     ..src > elisp
       (defun cuadrar-cada-uno (lista-de-numeros)
         "El cuadrado de cada LISTA DE NUMEROS, recursivamente."
         (if (not lista-de-numeros)          ; prueba-hazlo-de-nuevo
             nil
           (cons
            (* (car lista-de-numeros) (car lista-de-numeros))
            (cuadrar-cada-uno (cdr lista-de-numeros))))) ; expresion-del-siguiente-paso
     < src..

     ..srci > elisp
       > (cuadrar-cada-uno '(1 2 3))
       (1 4 9)
     < srci..

     Si @c{lista-de-numeros} está vacía, no hay que hacer nada. Pero si tiene
     contenido, se construye una lista combinando el cuadrado del primer
     número en la lista con el resultado de la llamada recursiva.

     (El ejemplo sigue el patrón exactamente: se devuelve @c{nil} si la lista
     de números es vacía. En la práctica, se escribiría el condicional, para que
     lleve a cabo la acción cuando la lista de números no es vacía.)

     La función @c{imprimir-elementos-recursivamente} (Ver Sección @l{#Recursividad
     con una Lista}) es otro ejemplo de un patrón @c{every}, excepto en este
     caso, en vez de juntar los resultados usando @c{cons}, se imprime
     cada elemento de salida.

     La función @c{imprimir-elementos-recursivamente} se ve asi:

     ..src > elisp
       (setq animales '(gacela jirafa leon tigre))

       (defun imprimir-elementos-recursivamente (lista)
         "Imprime cada elemento de LISTA en una línea propia.
       Usa recursión."
         (when lista                               ; prueba-hazlo-de-nuevo
               (print (car lista))                 ; cuerpo
               (imprimir-elementos-recursivamente  ; llamada recursiva
                (cdr lista))))                     ; expresion-del-siguiente-paso

       (imprimir-elementos-recursivamente animales)
     < src..


     El patrón para @c{imprimir-elementos-recursivamente} es:

     - Cuando la lista está vacía, no hacer nada.

     - Pero cuando la lista tiene al menos un elemento,

       - actúa al principio de la lista (el @c{car} de la lista),

       - y hacer una llamada recursiva en el resto (el @c{cdr} de la lista).

**** Patrón recursivo: @e{accumulate}

     Otro patrón recursivo se llama patrón @c{accumulate}. En el patrón
     recursivo @c{accumulate}, se realiza una acción en cada elemento de una
     lista y el resultado de esta acción se acumula con los resultados de
     realizar la acción en los otros elementos.

     Esto es muy parecido al patron ‘every’ usando @c{cons}, excepto que este
     @c{cons} no se utiliza, pero se usa algun otro combinador.

     El patrón es:

     - Si una lista está vacía, devuelve cero u otra constante.

     - De lo contrario, actúa al principio de la lista (el @c{car} de la lista),

       - y combina ese elemento actual, utilizando @c{+} o alguna otra
         función de combinación, con

       - una llamada recursiva a la función con el resto (el @c{cdr}) de la
         lista.


     Aquí hay un ejemplo:

     ..src > elisp
       (defun sumar-elementos (lista-de-numeros)
         "Suma los elementos de LISTA-DE-NUMEROS."
         (if (not lista-de-numeros)
             0
           (+ (car lista-de-numeros) (sumar-elementos (cdr lista-de-numeros)))))
     < src..

     ..srci > elisp
       > (sumar-elementos '(1 2 3 4))
       10
     < srci..

     Consulta la Seccion @l{#Creando una lista de ficheros}, para un ejemplo del
     patrón accumulate.

**** Patrón recursivo: @e{keep}

     Un tercer patrón se llama el patrón @c{keep}. En el patrón recursivo
     @c{keep}, se comprueba cada elemento de una lista; se actúa sobre el elemento
     y los resultados solo se conservan si el elemento cumple un criterio.

     De nuevo, esto es muy parecido al patrón ‘every’, excepto que el elemento
     se descarta a menos que cumpla un criterio.

     El patrón tiene tres partes:

     - Si una lista esta vacía, devuelve @c{nil}.

     - De lo contrario, si el inicio de la lista (el @c{car}) pasa una prueba

       - actuar sobre ese elemento y combinarlo, utilizando @c{cons} con

       - una llamada recursiva a la función con el resto (el @c{cdr}) de la
         lista.

     - De lo contrario, si el inicio de la lista (el @c{car}) falla la prueba

       - saltar ese elemento,

       - y, recursivamente llamar a la función sobre el resto (el @c{cdr}) de la
         lista.

     Aquí hay un ejemplo que usa @c{cond}:

     ..src > elisp
       (defun guardar-palabras-de-tres-letras (lista-palabras)
         "De la LISTA-PALABRAS, guarda las palabras de 3 letras."
         (cond
          ;; Primera prueba-hazlo-de-nuevo: condicion-de-parada
          ((not lista-palabras) nil)

          ;; Segunda prueba-hazlo-de-nuevo: cuando actuar
          ((eq 3 (length (symbol-name (car lista-palabras))))
           ;; combina el elemento actual con la llamada recursiva en
           ;; una lista mas corta
           (cons (car lista-palabras) (guardar-palabras-de-tres-letras (cdr lista-palabras))))

          ;; Tercera prueba-hazlo-de-nuevo: cuando saltar el elemento;
          ;; llamada recursiva con una lista mas corta con la
          ;; expresion-del-siguiente-paso
          (t (guardar-palabras-de-tres-letras (cdr lista-palabras)))))
     < src..


     ..srci > elisp
       > (guardar-palabras-de-tres-letras '(uno dos tres cuatro cinco seis))
       (uno dos)
     < srci..


     No hace falta decir que no es necesario utilizar @c{nil} como la prueba
     para detenerse; y, por su puesto, se pueden combinar estos patrones.

*** Recursividad sin deferencias

    Consideremos de nuevo lo que sucede con la función @c{triangulo-recursivo}.
    Encontraremos que los cálculos intermedios se postergan hasta que se puede
    hacer todo.

    Aquí está la definición de función:

    ..src > elisp
      (defun triangulo-recursivo (numero)
        "Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.
      Usa recursion."
        (if (= numero 1)                    ; prueba-hazlo-de-nuevo
            1                               ; parte-then
          (+ numero                         ; parte-else
             (triangulo-recursivo           ; llamada recursiva
              (1- numero)))))               ; expresion-del-siguiente-paso
    < src..

    ¿Qué ocurre cuando llamamos a esta función con un argumento de 7?

    La primera instancia de la función @c{triangulo-recursivo} suma el
    número 7 al valor devuelto por una segunda instancia de
    @c{triangulo-recursivo}, una instancia a la que se ha pasado un argumento
    de 6. Es decir, el primer cálculo es:

    ..src > elisp
      (+ 7 (triangulo-recursivo 6))
    < src..

    La primera instancia de @c{triangulo-recursivo}––tal vez quieres pensar en
    ella como un pequeño robot––no puede completar su trabajo. Debe pasar el
    cálculo a @c{(triangulo-recursivo 6)} una segunda instancia del programa, a
    un segundo robot. Este segundo individuo es completamente diferente del
    primero; en la jerga, una ‘diferente instancia’. O, dicho de otro modo, es
    un robot diferente. Es del mismo modelo que el primero; calcula números de
    triángulo recursivamente; pero tiene un número de serie diferente.

    ¿Y qué devuelve @c{(triangulo-recursivo 6)}? Devuelve el número 6 sumado al
    valor devuelto de evaluar @c{triangulo-recursivo} con un argumento
    de 5. Usando la metáfora del robot, le pide a otro robot que lo ayude.

    Ahora el total es:

    ..src > elisp
      (+ 7 6 (triangulo-recursivo 5))
    < src..

    ¿Y qué sucede después?

    ..src > elisp
      (+ 7 6 5 (triangulo-recursivo 4))
    < src..

    Cada vez que se llama a @c{triangulo-recursivo}, excepto por la última
    vez, se crea otra instancia del programa––otro robot––y le pide que
    haga un cálculo.

    Eventualmente, se establece y realiza la suma completa:

    ..src > elisp
      (+ 7 6 5 4 3 2 1)
    < src..

    Este diseño de la función difiere el cálculo del primer paso hasta que se
    puede hacer el segundo, y difiere este hasta que se puede hacer el tercero,
    y así sucesivamente. Cada aplazamiento significa el ordenador debe recordar
    que se está esperado. Esto no es un problema cuando solo hay unos pocos
    pasos, como en este ejemplo. Pero puede ser un problema cuando hay más
    pasos.

*** Solucion sin Deferencia

    La solución al problema de deferir operaciones es escribir de una
    manera que no se pospongan las operaciones@n{12}. Esto requiere escribir en un
    patrón diferente, con frecuencia uno que implica escribir dos
    definiciones de función, una función de ‘inicialización’ y una función
    ‘auxiliar’.

    La función de ‘inicializacion’ configura el trabajo; la función ‘auxiliar’
    hace el trabajo.

    Aquí estan las dos definiciones de funcion para sumar números. Son tan
    simples, que me cuesta entenderlas.

    ..src > elisp
      (defun triangulo-inicializacion (numero)
        "Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.
      Este es el componente de ‘inicialización’ de una función doble
      que utiliza recursión"
        (triangulo-recursivo-auxiliar 0 0 numero))
    < src..

    ..src > elisp
      (defun triangulo-recursivo-auxiliar (suma contador numero)
        "Devuelve la SUMA, usando CONTADOR, hasta e incluyendo NUMERO.
      Este es el componente ‘auxiliar’ de una funcion doble que
      utiliza recursión."
        (if (> contador numero)
            suma
          (triangulo-recursivo-auxiliar (+ suma contador)  ; suma
                                        (1+ contador)      ; contador
                                        numero)))          ; número
    < src..

    Instala ambas definiciones de función evaluandolas, luego llama a
    @c{triangulo-inicializacion} con 2 filas:

    ..srci > elisp
      > (triangulo-inicializacion 2)
      3
    < srci..

    La función de ‘inicialización’ llama a la primera instancia de la función
    ‘auxiliar’ con tres argumentos: cero, cero, y un número que es el número
    de filas en el triángulo.

    Los dos primeros argumentos que se pasan a la función ‘auxiliar’ son valores
    de inicialización. Estos valores cambian cuando
    @c{triangulo-recursivo-auxiliar} invoca nuevas instancias.@n{13}

    Veamos que pasa cuando tenemos un triángulo que tiene una fila. (¡Este
    triángulo tendrá un guijarro en el!)

    @c{triangulo-inicializacion} llamará a su auxiliar con los argumentos @c{0 0
    1}. Esta función ejecutará la prueba condicional si @c{(> contador numero)}:

    ..src > elisp
      (> 0 1)
    < src..

    y encontrara que el resultado es falso, por lo que  invocara la parte-else de la
    clausula @c{if}:

    ..src > elisp
          (triangulo-recursivo-auxiliar
           (+ suma contador)  ; suma más contador ⇒ suma
           (1+ contador)      ; incrementa contador ⇒ contador
           numero)            ; numero se mentiene igual
    < src..

    que al inicio calcula:

    ..src > elisp
      (triangulo-recursivo-auxiliar (+ 0 0)  ; suma
                                    (1+ 0)   ; contador
                                    1)       ; numero
    < src..

    que es:

    ..src > elisp
      (triangulo-recursivo-auxiliar 0 1 1)
    < src..

    Una vez mas, @c{(> contador numero)} será falso, por lo que de nuevo, el intérprete
    Lisp evaluará @c{triangulo-recursivo-auxiliar}, creando una nueva instancia
    con nuevos argumentos.

    Esta nueva instancia será;

    ..src > elisp
      (triangulo-recursivo-auxiliar
       (+ suma contador)  ; suma más contador ⇒ suma
       (1+ contador)      ; incrementa contador ⇒ contador
      numero)             ; numero se mentiene igual
    < src..

    que es:

    ..src > elisp
      (triangulo-recursivo-auxiliar 1 2 1)
    < src..

    En este caso, la prueba @c{(> contador numero)} ¡será verdadera!  Así que la
    instancia devolverá el valor de la suma, que es 1, como se esperaba.

    Ahora, vamos a pasar a @c{triangulo-inicializacion} un argumento de 2, para
    encontrar cuántos guijarros hay en un triángulo con dos filas.

    Esta función se llamaria @c{(triangulo-recursivo-auxiliar 0 0 2)}.

    En etapas, las instancias llamadas serán:

    ..example >
                                  suma contador número
      (triangulo-recursivo-auxiliar 0    1       2)

      (triangulo-recursivo-auxiliar 1    2       2)

      (triangulo-recursivo-auxiliar 3    3       2)
    < example..

    Cuando se llama a la última instancia, la prueba @c{(> contador numero)}
    será verdadera, por lo que la instancia devolverá el valor de @c{suma}, que
    será 3.

    Este tipo de patrón ayuda cuando estás escribiendo funciones que pueden
    usar muchos recursos en un ordenador.

** Ejercicio de bucles

   - Escribe una función similar a @c{triangulo} en la que cada fila tiene un
     valor que es el cuadrado del número de la fila. Usa un bucle @c{while}.

   - Escribe una función similar a @c{triangulo} que multiplique en lugar de
     sumar los valores.

   - Reescribe estas dos funciones recursivamente. Reescribe estas funciones
     usando @c{cond}.

   - Escribe una función para el modo Texinfo que crea una entrada índice al
     principio de un párrafo para cada @'{@@dfn} dentro del mismo. (En un
     fichero Texinfo, @'{@@dfn} marca una definición.)

     Muchas de las funciones que necesitaras se describen en los dos capitulos anteriores,
     Secciones @l{#Corte y Almacenamiento de Texto} y @l{#Pegando texto}. Si usas
     @c{forward-paragraph} para poner la entrada de índice al principio del
     párrafo, tendrás que usar @k{C-h f} @%c{describe-function} para
     averiguar como hacer que el comando vaya hacia atrás.

   Para obtener más información, consulta la Seccion
   @l{info:texinfo#Indicating<>Indicando Definiciones, Comandos, etc.}  en el
   @e{Manual de Texinfo} dentro de Emacs. O, tambien puedes consultarlo en
   internet en @l{http://www.gnu.org/software/texinfo/manual/texinfo/}

* Búsqueda de expresiones regulares

  Las búsquedas de expresiones regulares se utilizan extensivamente en GNU
  Emacs. Las dos funciones @c{forward-sentence} y @c{forward-paragraph},
  ilustran bien estas búsquedas. Usan expresiones regulares para encontrar
  donde mover el punto. La frase ‘expresión regular’ se escribe con frecuencia
  como ‘regexp’.

  Las búsquedas de expresiones regulares se describen en la Seccion
  @l{info:emacs#Regexp Search<>Búsqueda de Expresiónes Regulares} en @e{El
  Manual de GNU Emacs}, asi como en la Seccion @l{info:elisp#Regular
  Expressions<>Expresiones Regulares} en @e{El Manual de Referencia de GNU Emacs
  Lisp}. Al escribir este capítulo, estoy suponiendo que tienes al menos un leve
  conocimiento de esto. El punto principal a recordar es que que las expresiones
  regulares te permiten buscar patrones, asi como cadenas literales de
  caracteres. Por ejemplo, el código en @c{forward-sentence} busca el patrón de
  posibles caracteres que podrían marcar el final de una oracion, y mueve el
  punto a ese lugar.

  Antes de mirar el código de la función @c{forward-sentence}, vale la pena
  considerar cual debe ser el patrón que marca el final de una oracion. El
  patrón se discute en la siguiente sección; a continuacion se describe
  la funcion de busqueda de expresiónes regulares, @c{re-search-forward}. La función
  @c{forward-sentence} se describe en la sección siguiente. Finalmente, la
  función @c{forward-paragraph} se describe en la última sección de este
  capítulo. @c{forward-paragraph} es una función compleja que introduce
  varias caracteristicas nuevas.

** La expresión regular de @c{sentence-end}

   El símbolo @c{sentence-end} esta ligado al patrón que marca el fin de una
   oracion. ¿Cuál deberia ser esta expresión regular?

   Claramente, una oracion puede terminarse por un punto, una signo de
   interrogación, o un signo de exclamación. De hecho, en inglés, solo las
   oraciones que terminan con uno de estos tres caracteres deberían considerse
   como el final de una oracion. Esto significa que el patrón debe incluir el
   conjunto de caracteres:

   ..example >
     [.?!]
   < example..

   Sin embargo, no queremos que @c{forward-sentence} salte simplemente a un
   punto, a un signo de interrogacion o a un signo de exclamación, porque tal
   carácter podría utilizarse en medio de una oracion. Un punto, por ejemplo,
   se usa después de abreviaturas. Así, que se necesita otra información.

   Segun la convención, escribes dos espacios despues de cada oracion, pero solo
   un espacio después de un punto, un signo de interrogacion o un signo de
   exclamación en el cuerpo de una oracion. Asi que un punto, un signo de
   interrogacion o de exclamacion seguido por dos espacios es un buen indicador
   de un final de oracion. Sin embargo, en un archivo, los dos espacios pueden
   ser un tabulador o el fin de una línea. Esto significa que la expresión
   regular incluiría estos tres elementos como alternativas.

   Este grupo de alternativas se vera asi:

   ..example >
     \\($\\| \\|  \\)
            ^   ^^
           TAB  SPC
   < example..

   Aquí, @'{$} indica el fin de la línea, ademas he señalado en la expresión
   donde se inserta el tabulador y los dos espacios. Ambos se insertan poniendo
   los caracteres reales en la expresión.

   Antes de los parentesis y las barras verticales, se requiere dos
   barras invertidas @'{\\}: la primera barra invertida cita la
   siguiente barra invertida en Emacs; y la segunda indica que el siguiente
   caracter, el paréntesis o la barra vertical, es especial.

   También, una oracion puede ser seguida por uno o más retornos de carro, como
   aqui:

   ..example >
     [
     ]*
   < example..

   Al igual que los tabuladores y espacios, un retorno de carro se inserta en
   una expresión regular insertándolo literalmente. El asterisco indica
   que el @k{RET} se repite cero o más veces.

   Pero una oracion no consiste solo en un punto, o un signo de interrogacion o
   de exclamación seguido de un espacio apropiado: una cita de cierre
   o una llave de cierre  de algún tipo puede preceder al
   espacio. De hecho, más de una marca o paréntesis pueden preceder el
   espacio. Estas requieren una expresión parecida a esta:

   ..example >
     []\"')}]*
   < example..

   En esta expresión, el primer @'{]} es el primer caracter en la expresión;
   el segundo caracter es @'{"}, que está precedido por un @'{\} para decirle
   a Emacs que el @'{"} @e{no} es especial. Los últimos tres caracteres son @'{'},
   @'{)}, y @'(}).

   Todo esto sugiere cual deberia ser el patrón de la expresión regular para que
   coincida con el final de una oracion; y, de hecho, si evaluamos
   @c{sentence-end} encontraremos que devuelve el siguiente valor:

   ..srci > elisp
     > sentence-end
     "[.?!][]\"')}]*\\($\\|     \\|  \\)[
     ]*"
   < srci..

   (Bieno, no en GNU Emacs 22; eso se debe a un esfuerzo por hacer el proceso
   simple y manejar más símbolos y lenguajes. Cuando el valor de
   @c{sentence-end} es @c{nil}, entonces utiliza el valor definido por la
   función @c{sentence-end}. (Aquí se utiliza la diferencia entre un valor y una
   función en Emacs Lisp.) La función devuelve un valor construido a partir de
   las variables @c{sentence-end-base}, @c{sentence-end-double-space},
   @c{sentence-end-without-period}, y @c{sentence-end-without-space}. La
   variable crítica es @c{sentence-end-base}; su valor global es similar al
   descrito anteriormente, pero también contiene dos marcas de cita
   adicionales. Estas tienen diferentes grados de curvatura. La variable
   @c{sentence-end-without-period}, cuando es verdad, le dice a Emacs que una
   oracion puede finalizar sin un punto, como en texto en Tailandés.)

** La Función @c{re-search-forward}

   La función @c{re-search-forward} es similar a la función
   @c{search-forward}. (Vea la Seccion @l{#La Función @c{search-forward}}.)

   @c{re-search-forward} busca una expresión regular. Si la búsqueda es exitosa,
   deja el punto inmediatamente después del último caracter en el objetivo. Si
   la búsqueda es hacia atrás, deja el punto antes del primer caracter en el
   objetivo. Puede decirle a @c{re-search-forward} que regrese @c{t} por
   verdadero. (El movimiento del punto es por la tanto un ‘efecto secundario’.)

   Al igual que @c{search-forward}, la función @c{re-search-forward} toma cuatro
   argumentos:

   1. El primer argumento es la expresión regular que busca la función. La
      expresión regular será una cadena entre comillas.

   2. El segundo argumento opcional limita el grado de busqueda de la función;
      es un valor ligado con una posición especifica en el búfer.

   3. El tercer argumento opcional especifica cómo la función responde al
      fallo: @c{nil} como tercer argumento hace que la función señale
      un error (e imprima un mensaje) cuando la búsqueda falla; cualquier
      otro valor hace que se devuelva @c{nil} si la búsqueda falla y @c{t} si la
      búsqueda tiene éxito.

   4. El cuarto argumento opcional es el contador de repeticiones. Un conteo
      negativo hace que @c{re-search-forward} busque hacia atrás.


   La plantilla para @c{re-search-forward} se ve asi:

   ..src > elisp
     (re-search-forward "expresion-regular"
                        limite-de-busqueda
                        que-hacer-si-falla-la-busqueda
                        contador-de-repeticiones)
   < src..

   El segundo, tercer, y cuarto argumentos son opcionales. Sin embargo, si se
   quiere pasar un valor a uno o ambos de los últimos dos argumentos, se debe
   también pasar un valor a todos los argumentos precedentes. De otro modo,
   el intérprete Lisp confundira el argumento al que estás pasando el valor.

   En la función @c{forward-sentence}, la expresión regular será el valor de
   la variable @c{sentence-end}. En forma simple, esto es:

   ..example >
     "[.?!][]\"')}]*\\($\\|  \\|  \\)[
     ]*"
   < example..

   El límite de la búsqueda será el fin del párrafo (ya que una oracion no puede
   ir mas alla de un párrafo). Si la búsqueda falla, la función devuelve @c{nil}, y
   el argumento del contador de repeticion será pasado a la función
   @c{forward-sentence}.

** La Función @c{forward-sentence}

   El comando para mover el cursor hacia adelante de una oracion es una
   ilustración directa de cómo usar búsqueda de expresiones regulares en Emacs
   Lisp. De hecho, la función parece más larga y más complicada de lo que es;
   esto se debe a que la función está diseñada para ir hacia atrás y hacia
   adelante; y, opcionalmente, mas de una oracion. La función normalmente
   está asociada al comando @k{M-e}.

   Aquí está la código de @c{forward-sentence}:

   ..src > elisp
     (defun forward-sentence (&optional arg)
       "Avansa al siguiente ‘sentence-end’. Con un argumento, se repite.
     Con un argumento negativo, avanza hacia atras repetidamente al ‘sentence-beginning’.

     La variable ‘sentence-end’ es una expresión regular que corresponde a el
     fin de las oraciones. Ademas, cada limite de párrafo tambien termina oraciones."
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point))
             (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            (if (and (re-search-backward sentence-end par-beg t)
                     (or (< (match-end 0) pos)
                         (re-search-backward sentence-end par-beg t)))
                (goto-char (match-end 0))
              (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            (if (re-search-forward sentence-end par-end t)
                (skip-chars-backward " \t\n")
              (goto-char par-end)))
           (setq arg (1- arg)))
         (constrain-to-field nil opoint t)))
   < src..

   La función parece larga a primera vista y es mejor mirar primero su
   esqueleto, y luego su músculo. La forma de ver el esqueleto es mirar
   las expresiones que comienzan en las columnas de la izquierda:

   ..src > elisp
     (defun forward-sentence (&optional arg)
       "documentacion…"
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point)) (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            resto-del-cuerpo-del-bucle-while-cuando-va-hacia-atras
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            resto-del-cuerpo-del-bucle-while-cuando-va-hacia-adelante
         manejar-formularios-y-equivalentes
   < src..

   ¡Esto parece mucho mas simple! La definición de la función consiste en la
   documentación, una expresión @c{interactive}, una expresión @c{or}, una
   expresión @c{let}, y bucles @c{while}.

   Veamos cada una de estas partes por separado.

   Observamos que la documentación es completa y comprensible.

   La función tiene una declaración @c{interactive "p"}. Esto signifca que el
   argumento prefijo procesado, si lo hay, pasa a la función como su
   argumento. (Este será un número.) Si no se pasa un argumento a la función (es
   opcional) entonces el argumento @c{arg} será vinculara a 1.

   Cuando @c{forward-sentence} se llama no interactivamente sin un argumento,
   @c{arg} está vinculado a @c{nil}. La expresión @c{or} maneja esto. Lo que
   hace es dejar el valor de @c{arg} como esta, pero solo si @c{arg} está ligado
   a un valor; de otro modo asigna el valor de @c{arg} a 1, en el caso de
   @c{arg} está ligado a @c{nil}.

   Lo siguiente es un @c{let}. Especifica los valores de dos variables
   locales @c{point} y @c{sentence-end}. El valor local de punto, desde antes
   de la búsqueda, se utiliza en la función @c{constrain-to-field} que maneja
   formularios y equivalentes. La variable @c{sentence-end} se establece por
   la función @c{sentence-end}.

*** Los bucles @c{while}

    Siguen dos bucles @c{while}. El primer @c{while} tiene una
    prueba-verdadero-o-falso que es verdadero si el argumento prefijo de
    @c{forward-sentence} es un número negativo. Esto es para retroceder. El
    cuerpo de este bucle es similar al cuerpo del segundo @c{while},
    pero no es exactamente el mismo. Pasaremos de este bucle @c{while} y
    nos centraremos en el segundo @c{while}.

    El segundo bucle @c{while} es para mover el punto hacia adelante. Su
    esqueleto se parece a esto:

    ..src > elisp
      (while (> arg 0)            ; prueba-verdadero-o-falso
        (let varlist
          (if (prueba-verdadero-o-falso)
              parte-then
            parte-else
        (setq arg (1- arg))))     ; decremento del bucle while
    < src..

    El bucle @c{while} es de tipo decreciente. (Vea la Seccion @l{#Bucle con
    contador decreciente}.) Tiene una prueba-verdadero-o-falso que regresa
    verdadero siempre y cuando el contador (en este caso, la variable @c{arg})
    sea mayor que cero; y tiene un decremento que resta 1 del valor del contador
    cada vez que el bucle se repite.

    Si no se da un argumento prefijo a @c{forward-sentece}, que es lo mas
    habitual, este bucle @c{while} se ejecutará una vez, ya que el valor de
    @c{arg} será 1.

    El cuerpo del cuerpo @c{while} consite en una expresión @c{let}, que crea
    y vincula una variable local, y tiene, como su cuerpo, una expresión @c{if}.

    El cuerpo del bucle @c{while} se ve asi:

    ..src > elisp
      (let ((par-end
             (save-excursion (end-of-paragraph-text) (point))))
        (if (re-search-forward sentence-end par-end t)
            (skip-chars-backward " \t\n")
          (goto-char par-end)))
    < src..

    La expresión @c{let} crea y liga la variable local @c{par-end}. Como
    veremos, esta variable local está diseñada para proporcionar un limite a la
    búsqueda de la expresiónes regulares. Si la búsqueda falla no encuentra una
    oracion apropiada que termine en el párrafo, se detendra al llegar al final
    del párrafo.

    Pero primero, examinaremos cómo @c{par-end} se liga al valor del
    fin del párrafo. Lo que ocurre es que el @c{let} asigna el
    valor de @c{par-end} al valor devuelto cuando el intérprete evalúa la
    expresión.

    ..src > elisp
      (save-excursion (end-of-paragraph-text) (point))
    < src..

    En esta expresión, @c{(end-of-paragraph-text)} mueve el punto al fin del
    párrafo, @c{(point)} devuelve el valor del punto, y luego
    @c{save-excursion} restaura el punto a su posición original. De este
    modo, el @c{let} liga @c{par-end} al valor devuelto por la expresión
    @c{save-excursion}, que es la posición del fin del párrafo.  (La función
    @c{end-of-paragraph-text} utiliza @c{forward-paragraph}, que discutiremos en
    breve.)

    A continuacion Emacs evalúa el cuerpo del @c{let}, que es una expresión
    @c{if}:

    ..src > elisp
      (if (re-search-forward sentence-end par-end t) ; parte-if
          (skip-chars-backward " \t\n")              ; parte-then
        (goto-char par-end)))                        ; parte-else
    < src..

    El @c{if} comprueba si su primer argumento es verdadero y es así, evalúa su parte
    then; de lo contrario, el intérprete Emacs Lisp evalúa la parte else. La
    prueba-verdadero-o-falso de la expresión @c{if} es la búsqueda de la expresión
    regular.

    Puede parecer extraño tener lo que parece ser ‘trabajo real’ de la función
    @c{forward-sentence} enterrado aqui, pero esta es una forma común de
    realizar este tipo de operaciónes en Lisp.

*** La búsqueda de expresiones regulares

    La función @c{re-search-forward} busca el fin de la oracion, es decir,
    el patrón definido por la expresión regular @c{sentence-end}. Si el
    patrón es encontrado––si se encuentra el fin de la oracion––entonces la
    función @c{re-search-forward} hace dos cosas:

    1. La función @c{re-search-forward} realiza un efecto secundario, que es mover
       el punto al final de la ocurrencia encontrada.

    2. La función @c{re-search-forward} devuelve un valor verdadero. Este es
       el valor recibido por el @c{if}, y significa que la búsqueda fué
       exitosa.


    El efecto secundario, el movimiento del punto se completa antes de que la
    función @c{if} reciva el valor devuelto por la conclusión exitosa de la
    búsqueda.

    Cuando la función @c{if} recibe el valor verdadero desde una llamada exitosa
    a @c{re-search-forward}, el @c{if} evalúa la parte-then que es la expresión
    @c{(skip-chars-backward "\t\n")}. Esta expresión se mueve hacia atrás a
    través de cualquier espacio en blanco, tabulador o retorno de carro hasta
    encontrar un caracter imprimible y deja el punto después del caracter.
    Como el punto ya se ha movido al final del patron que marca el final de la
    oracion, esta accion deja el punto justo despues del caracter imprimible de
    cierre de la oracion, que suele ser un punto.

    Por otro lado, si la función @c{re-search-forward} no encuentra
    un patrón que marque el fin de la oracion, la función devuelve falso. El
    falso provoca que @c{if} evalue su tercer argumento, que es
    @c{(goto-char par-end)}: esto mueve el punto al final del párrafo.

    (Y si el texto está en una forma o equivalente, y el punto puede que no se
    mueva completamente, entonces entra en juego la función
    @c{constrain-to-field}.)

    La búsqueda de expresiones regulares son excepcionalmente útiles y el
    patrón ilustrado por @c{re-search-forward}, en el que la búsqueda es la
    prueba de una expresión @c{if}, es facil de manejar. Veras o escribirás código
    incorporando este patrón con frecuencia.

** @c{forward-paragraph}: una mina de oro de funciones

   La función @c{forward-paragraph} mueve el punto al fin del párrafo. Por
   lo general esta asociado a @k(M-}) y hace uso de un número de funciones
   que son importantes en sí mismas, incluyendo @c{let*}, @c{match-beginning}, y
   @c{looking-at}.

   La definición de función de @c{forward-paragraph} es considerablemente
   mas extensa que la definición de función de @c{forward-sentence} porque
   trabaja con un párrafo, cada línea de la cual puede empezar con un prefijo de
   relleno.

   Un prefijo de relleno consiste en una cadena de caracteres que se repite al
   principio de cada línea. Por ejemplo, en el código Lisp, es una convención
   empezar cada línea de un comentario de un párrafo extenso con @'{;;; }. En el
   modo Texto, cuatro espacios en blanco forman otro prefijo común de relleno,
   creando un párrafo indentado. (Véa la Sección @l{info:emacs#Fill Prefix} en
   @e(El Manual de GNU Emacs) para más información acerca de los prefijos de
   relleno.)

   La existencia de un prefijo de relleno significa que, además de poder
   encontrar el fin de un párrafo cuyas líneas empiezan en la columna más a la
   izquierda, la función @c{forward-paragraph} debe ser capaz de encontrar el
   final de un párrafo cuando todas o muchas de las líneas en el búfer
   empiezan con el prefijo de relleno.

   Ademas, a veces es práctico ignorar un prefijo de relleno que existe,
   como lo pueden ser las líneas en blanco que separan los párrafos. Esto es una
   complicación añadida.

   En vez de imprimir toda la función @c{forward-paragraph}, solo
   imprimiremos partes de la misma. ¡Leer sin preparación, la función puede
   ser desalentador!

   En general, la función tiene este aspecto:

   ..src > elisp
     (defun forward-paragraph (&optional arg)
       "documentacion…"
       (interactive "p")
       (or arg (setq arg 1))
       (let*
           varlist
         (while (and (< arg 0) (not (bobp)))     ; codigo-de-movimiento-hacia-atras
           …
         (while (and (> arg 0) (not (eobp)))     ; codigo-de-movimiento-hacia-adelante
           …
   < src..

   Las primeras partes de la función son rutinarias: la  lista de argumentos
   de la función consiste en un argumento opcional. Luego se presenta
   la documentación.

   La letra minúscula @'c{p} en la declaración @c{interactive} significa que el
   argumento prefijo se procesa, si lo hay, pasa a la función. Este será un
   número, y es el contador de repeticion de cuántos párrafos se moverá el
   punto. La expresión @c{or} en la siguiente línea maneja el caso común cuando
   no se pasa ningun argumento a la función, esto ocurre si la función se
   llama desde otro código en lugar de interactivamente. Este caso fue descrito
   anteriormente. (Vea la Seccion @l{#La Función @c{forward-sentence}}.) Ahora
   llegamos al final de la parte familiar de esta función.

*** La expresión @c{let*}

    La siguiente línea en la función @c{forward-paragraph} empieza con una
    expresión @c{let*}. Esto es diferente a @c{let}. El símbolo es
    @c{let*} no @c{let}.

    La forma especial @c{let*} es como @c{let} excepto que Emacs establece cada
    variable en secuencia, una después de otra, y las variables en la última
    parte de la varlist pueden hacen uso de los valores a los que Emacs asignó
    las variables al principio la varlist.

    (Seccion @l{@c{save-excursion} en @c{append-to-buffer}}.)

    En la expresión @c{let*} en esta función, Emacs asigna un total de siete
    variables: @c{opoint}, @c{fill-prefix-regexp}, @c{parstart}, @c{parsep},
    @c{sp-parstart}, @c{start}, y @c{found-start}.

    La variable @c{parsep} aparece dos veces, primero, para eliminar instancias
    de @'{^}, y segundo, para manejar prefijos de relleno.

    La variable @c{opoint} es solo el valor de @c{point}. Como se puede
    adivinar, se usa en una expresión @c{constrain-to-field}, igual que
    en @c{forward-sentence}.

    La variable @c{fill-prefix-regexp} se establece con el valor devuelto de
    evaluar la siguiente lista:

    ..src > elisp
      (and fill-prefix
           (not (equal fill-prefix ""))
           (not paragraph-ignore-fill-prefix)
           (regexp-quote fill-prefix))
    < src..

    Esta es una expresión cuyo primer elemento es la forma especial @c{and}.

    Como aprendimos anteriormente (Sección @l(#La función @c{kill-new})), la
    forma especial @c{and} evalúa cada uno de sus argumentos hasta uno de los
    argumentos devuelve un valor @c{nil}, en cuyo caso la expresión @c{and}
    devuelve @c{nil}; sin embargo, si ninguno de los argumentos devuelve un
    valor @c{nil}, se devuelve el valor resultante de evaluar el último
    argumento. (Puesto que tal valor no es @c{nil}, se considera verdadero en
    Lisp.) En otras palabras, una expresión @c{and} devuelve un valor verdadero
    solo si todos sus argumentos son verdaderos.

    En este caso, la variable @c{fill-prefix-regexp} se vincula a un valor no
    @c{nil} solo si las cuatro expresiones siguientes producen un valor
    verdadero (es decir, un valor no @c{nil}) cuando se evalúan; de lo
    contrario, la variable @c{fill-prefix-regexp} se vincula a @c{nil}.

    - @c(fill-prefix) ::

      Cuando se evalua esta variable, se devuelve el valor del prefijo de
      relleno, si lo hay. Si no hay prefijo relleno, esta variable devuelve
      @c{nil}.

    - @c[(not (equal fill-prefix "")] ::

      Esta expresión comprueba si un prefijo de relleno existente es una cadena
      vacía, es decir, una cadena sin caracteres. Una cadena vacía no es
      un prefijo de relleno útil.

    - @c[(not paragraph-ignore-fill-prefix)] ::

      Esta expresión devuelve @c{nil} si la variable
      @c{paragraph-ignore-fill-prefix} ha sido activada al asignarle un valor
      verdadero como @c{t}.

    - @c[(regexp-quote fill-prefix)] ::

      Este es el último argumento pasado a la forma especial @c{and}. Si todos
      los argumentos de @c{and} son verdaderos, el valor resultante de
      evaluar esta expresión será devuelto por la expresión @c{and} y
      asociado a la variable @c{fill-prefix-regexp},


    El resultado de evaluar esta expresión @c{and} con éxito es que
    @c{fill-prefix-regexp} sera ligada al valor de @c{fill-prefix} como fué
    modificado por la función @c{regexp-quote}. Lo que @c{regexp-quote} hace es
    leer una cadena y devolver la expresión regular que coincida exactamente con
    la cadena y nada más. Esto significa que el valor de @c{fill-prefix-regexp} será
    asignado a un valor que coincida exactamente con el prefijo si existe. De lo
    contrario, la variable sera ligada a @c{nil}.

    Las siguientes dos variables locales en la expresión @c{let*} están
    diseñadas para eliminar instancias de @'{^} de @c{parstart} y @c{parsep},
    las variables locales que indican el inicio del párrafo y el separador de
    párrafos. La siguiente expresión establece @c{parsep} de nuevo. Esto es para
    manejar prefijos de relleno.

    Esta es el ajuste que requiere la llamada de la definición
    @c{let*} en lugar de @c{let}. La prueba-verdadero-o-falso del @c{if} depende
    de si la variable @c{fill-prefix-regexp} evalúa a @c{nil} o algún otro
    valor.

    Si @c{fill-prefix-regexp} no tiene un valor, Emacs evalúa la parte else
    de la expresión @c{if} y vinculara @c{parsep} a su valor local. (@c{parsep}
    es una expresión regular que coincide con la separacion de párrafos.)

    Pero si @c{fill-prefix-regexp} tiene un valor, Emacs evalúa la parte-then
    de la expresión @c{if} y enlaza @c{parsep} a una expresión regular que
    incluye @c{fill-prefix-regexp} como parte del patrón.

    Específicamente, @c{parsep} se asigna al valor original del separador del
    párrafo, la expresión regular concatenada con una expresión alternativa que
    consiste en @c{fill-prefix-regexp} seguido por espacios en blanco opcionales
    halta el fin de la línea. (El espacio en blanco se define con @"c{[ \t]*$}.)
    El @'{\\|} define esta porción del regexp como una alternativa a @c{parsep}.

    De acuerdo a un comentario en el código, la siguiente variable local,
    @c{sp-parstart}, se utiliza para la busqueda, y luego los dos finales,
    @c{start} y @c{found-start}, se asignan a @c{nil}.

    Ahora entramos en el cuerpo del @c{let*}. La primera parte del cuerpo del
    @c{let*} trata el caso cuando la función recibe un argumento negativo y por
    lo tanto se mueve hacia atrás. Omitiremos esta sección.

*** El bucle @c{while} hacia adelante

    La segunda parte del cuerpo del @c{let*} maneja el movimiento hacia
    adelante. Es un bucle @c{while} que se repite mientras el valor de @c{arg}
    es mayor a cero. En el uso más común de la función el valor del argumento es
    1, por lo que el cuerpo del bucle @c{while} se evalúa exactamente una vez, y
    el cursor avanza hacia adelante un párrafo.

    Esta parte maneja tres situaciones: cuando el punto está entre párrafos,
    cuando hay un prefijo de relleno y cuando no hay un prefijo de relleno.

    El bucle @c{while} se ve así:

    ..src > elisp
      ;; avanza hacia adelante y no al final del búfer
      (while (and (> arg 0) (not (eobp)))

        ;; entre párrafos
        ;; Avanzar sobre linesa de separacion...
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (looking-at parsep))
          (forward-line 1))
        ;;  Esto decrementa el bucle
        (unless (eobp) (setq arg (1- arg)))
        ;; ... y una línea más
        (forward-line 1)

        (if fill-prefix-regexp
            ;; Hay un prefijo de relleno; sobreescribe parstart;
            ;; avanzamos línea a línea
            (while (and (not (eobp))
                        (progn (move-to-left-margin) (not (eobp)))
                        (not (looking-at parsep))
                        (looking-at fill-prefix-regexp))
              (forward-line 1))

          ;; No hay prefijo de relleno;
          ;; avanzamos caracter por caracter
          (while (and (re-search-forward sp-parstart nil 1)
                      (progn (setq start (match-beginning 0))
                             (goto-char start)
                             (not (eobp)))
                      (progn (move-to-left-margin)
                             (not (looking-at parsep)))
                      (or (not (looking-at parstart))
                          (and use-hard-newlines
                               (not (get-text-property (1- start) 'hard)))))
            (forward-char 1))

          ;; y si no hay prefijo de relleno y si no estamos al final
          ;; ir a lo que fué encontrado en la búsqueda de expresiones regulares
          ;; para sp-parstart
          (if (< (point) (point-max))
              (goto-char start))))
    < src..

    Se puede ver que esto es un contador de decremento @c{while}, usando la
    expresión @c{(setq arg (1- arg))} como decremento. Esta expresión no está
    lejos del @c{while}, pero está oculta en otra macro Lisp, una macro
    @c{unless}. A menos que estemos al final del búfer––eso es lo que la función
    @c{eobp} determina; es una abreviación de @'{End of Buffer P}––disminuimos
    el valor de @c{arg} por uno.

    (Si estamos al fin del búfer, ya no podemos avanzar mas y el siguiente bucle
    de la expresión @c{while} sera falso ya que la prueba es un @c{and} con
    @c{(not (eobp))}. La función @c{not} significa exactamente lo que se espera;
    es otro nombre para @c{null}, una función que devuelve verdadero cuando su
    argumento es falso.)

    Curiosamento, el contador del bucle no disminuye hasta que dejamos el
    espacio entre párrafos, a menos que lleguemos al fin del búfer o dejemos de
    ver el valor local del separador del párrafo.

    El segundo @c{while} también tiene una expresión @c{(move-to-left-margin)}.
    La función es autoexplicativa. Está dentro de una expresión @c{progn} y no
    el último elemento de su cuerpo, por lo que solo se invoca por su efecto
    secundario, que es mover el punto al margen izquierdo de la línea actual.

    La función @c{looking-at} también es auto-explicativa; devuelve
    verdadero si el texto después del punto coincide con la expresión regular dada
    como su argumento.

    El resto del cuerpo del bucle parece complejo al principio, pero tiene
    sentido cuando llegas a entenderlo.

    Primero considera lo que sucede si hay un prefijo de relleno:

    ..src > elisp
      (if fill-prefix-regexp
          ;; Hay un prefijo de relleno; sobreescribe parstart;
          ;; avanzamos línea a línea
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
    < src..

    Esta expresión mueve el punto hacia adelante línea por línea siempre y
    cuando se cumplan las cuatro condiciones:

    1. El punto no está al final del búfer.

    2. Podemos movernos al margen izquierdo del texto y no estamos al fin del
       búfer.

    3. El siguiente punto no separa los párrafos.

    4. El patrón que sigue al punto es la expresión regular del prefijo de relleno.


    La última condición puede ser un puzzle, hasta que se recuerde qué el punto
    fue movido al principio de la línea anteriormente en la función
    @c{forward-paragraph}. Esto significa que si el texto tiene un prefijo
    de relleno, la función @c{looking-at} se verá.

    Considera qué ocurre cuando no hay un prefijo lleno.

    ..src > elisp
      (while (and (re-search-forward sp-parstart nil 1)
                  (progn (setq start (match-beginning 0))
                         (goto-char start)
                         (not (eobp)))
                  (progn (move-to-left-margin)
                         (not (looking-at parsep)))
                  (or (not (looking-at parstart))
                      (and use-hard-newlines
                           (not (get-text-property (1- start) 'hard)))))
        (forward-char 1))
    < src..

    El bucle @c{while} nos lleva a la busqueda de @c{sp-parstart}, que es la
    combinación de posibles espacios en blanco con el valor local del inicio de
    un párrafo o de un separador de párrafos. (Los dos últimos se encuentran
    dentro de una expresión que comienza con @c{\(?:} así que no están
    referenciadas por la función @c{match-beginning}.)

    Las dos expresiones,

    ..src > elisp
      (setq start (match-beginning 0))
      (goto-char start)
    < src..

    significan ir al comienzo del texto localizado con la expresión regular.

    La expresión @c{(match-beginning 0)} es nueva. Devuelve un número que
    especifica la ubicacion del inicio del texto que coincidio con la última
    búsqueda.

    La función @c{match-beginning} se utiliza aquí debido a una característica
    de la búsqueda hacia adelante: una búsqueda exitosa hacia adelante,
    independientemente de si se trata de una búsqueda simple o una expresión
    regular, mueve el punto al fin del texto encontrado. En este caso,
    una búsqueda exitosa mueve el punto al fin del patrón de @c{sp-parstart}.

    Sin embargo, queremos poner el punto al fin del actual párrafo, no en algún
    otro lugar. De hecho, dado que la búsqueda posiblemente incluye el separador
    de párrafos, el punto puede finalizar al principio del siguiente a menos que
    utilicemos una expresión que incluya @c{match-beginning}.

    Cuando se le da un argumento de 0, @c{match-beginning} devuelve la posición
    de inicio del texto coincidente con la búsqueda más reciente. En este caso,
    la búsqueda más reciente de @c{sp-parstart}. La expresión
    @c{(match-beginning 0)} devuelve la posición del comienzo de ese patrón, en
    lugar de la posición final de este patrón.

    (Incidentalmente, cuando se pasa un número positivo como un argumento, la
    función @c{match-beginning} devuelve la localización de punto de la
    expresión con paréntesis en la última búsqueda a menos que la expresión con
    paréntesis empiece con @c{\(?:}. No sé porque @c{\(?:} aparece aquí, ya que
    el argumento es 0.)

    La última expresión cuando no hay prefijo de relleno es

    ..src > elisp
      (if (< (point) (point-max))
          (goto-char start))))
    < src..

    Esto dice que si no hay prefijo lleno y no estamos al final, el punto
    deberia moverse al principio de lo que sea que sea haya encontrado al buscar la
    expresión regular de @c{sp-parstart}.

    La definición completa de la función @c{forward-paragraph} no solo
    incluye código para avanzar, también código para retroceder.

    Si estás leyendo esto dentro de GNU Emacs y quieres ver la función
    completa, puedes escribir @k{C-h f} @%c(describe-function) y el nombre
    de la función. Esto proporciona la documentación de función y el nombre de la
    librería que contiene el codigo fuente de la función. Coloca el punto sobre
    el nombre de la librería y presionar la tecla @k(RET); serás llevado
    directamente al codigo fuente. (¡Asegúrate de instalar las fuentes! ¡Sin
    eso, eres como una persona que intenta conducir un coche con los ojos
    cerrados!)

** Crea tu propio fichero @f{TAGS}

   Ademas de @k{C-h f} @%c(describe-function), otra forma de ver el codigo de
   una función es escribir @k{M-.} @%c(find-tag) y el nombre de la función
   cuando se solicite. Es un buen hábito para obtenerlo. El comando @k{M-.}
   @%c(find-tag) te lleva directamente al codigo de una función, variable, o
   nodo. La función depende de tablas de etiquetas para saber donde ir.

   Si la función @c{find-tag} pregunta primero por el nombre de una tabla
   @f{TAGS}, dale el nombre de un fichero @f{TAGS} como
   @f{/usr/local/src/emacs/src/TAGS}. (La ruta exacta a tu fichero @f{TAGS}
   depende de cómo instalaste tu copia de Emacs. Yo he provisto la localización
   tanto de mi codigo fuente de C, como de Emacs Lisp.)

   Tambien puedes crear tu propio fichero @f{TAGS} para directorios que
   carecen de uno.

   Con frecuencia se necesita construir e instalar tablas de etiquetas por
   uno mismo. Estas no son construidas automáticamente. Una tabla de etiquetas
   nombra como un fichero @f{TAGS}; el nombre va en letras mayúsculas.

   Puedes crear un fichero @f{TAGS} llamando al programa @c{etags} que
   viene como parte de la distribución de Emacs. Por lo general, @c{etags} se
   compila e instala cuando se construye Emacs. (@c{etags} no es una
   función Lisp o una parte de Emacs; es un programa C.)

   Para crear el fichero @f{TAGS}, primero cambia al directorio en el que se
   quiera crear el fichero. En Emacs se puede hacer esto con el comando
   @k{M-x cd}, o visitando un fichero en el directorio, o listando el
   directorio con @k{C-x d} @%c(dired). A continuacion, ejecute el comando  de
   compilacion, con @c{etags *.el} como el comando a ejecutar

   ..example >
     M-x compile RET etags *.el RET
   < example..

   para crear un fichero @f{TAGS} para Emacs Lisp.

   Por ejemplo, si se tiene un gran número de ficheros en el directorio
   @f{~/emacs}, como en mi caso––yo tengo 137 ficheros @f{.el}, de los cuales cargo
   12––se puede crear un fichero @f{TAGS} para los ficheros Emacs Lisp en
   ese directorio.

   El programa @${etags} recive todos los ‘comodines’ usuales del shell. Por
   ejemplo, si tienes dos directorios para los que deseas un unico fichero
   @f{TAGS}, ingresa @c{etags *.el ../elisp/*.el}, donde @f{../elisp/} es el
   segundo directorio:

   ..example >
     M-x compile RET etags *.el ../elisp/*.el RET
   < example..

   Ingresa

   ..example >
     M-x compile RET etags --help RET
   < example..

   para ver una lista de las opciones aceptadas por @${etags} asi como
   una lista de lenguajes soportados.

   El programa @${etags} maneja más de 20 lenguajes, incluyendo Emacs Lisp,
   Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java, LaTeX, Pascal,
   Perl, Postscript, Python, TeX, Texinfo, makefiles, y la mayoría de
   ensambladores. El programa no tiene interruptores para especificar el lenguaje;
   reconoce el lenguaje en un fichero de entrada segun su nombre y contenido.

   @f{etags} es muy útil cuando estas escribiendo código y quieres referirse a
   funciones que ya has escrito. Simplemente ejecuta de nuevo @${etags} a medida
   que escribas nuevas funciones, para que formen parte del fichero @f{TAGS}.

   Si crees que ya existe un fichero @f{TAGS} apropiado para lo que buscas, pero
   no conoces donde está, puedes usar el programa @${locate} para intentar
   encontrarlo.

   Escribe @k{M-x locate RET TAGS RET} y Emacs listará los nombres de rutas
   completos de todos tus ficheros @f{TAGS}. En mi sistema, este comando muestra
   34 fichero @f{TAGS}. Por otra parte, un sistema ‘vainilla’ instalado
   recientemente no contenía ningun fichero @f{TAGS}.

   Si la tabla de etiquetas que buscas ya ha sido creada, puedes utilizar el
   comando @c{M-x visit-tags-table} para especificarlo. De lo contrario, tendras
   que crear la tabla de etiquetas por tí mismo y luego utilizar @c{M-x
   visit-tags-table}.

*** Construyendo Etiquetas en el codigo de Emacs

    El codigo fuente de GNU Emacs vienen con un @f{Makefile} que contiene un comando
    @${etags} sofisticado que crea, recoge, y une tablas de etiquetas con
    todo el codigo de Emacs y coloca la información dentro de un fichero
    @f{TAGS} en el directorio @f{src/}. (El directorio @f{src/} está debajo
    del nivel superior de tu directorio Emacs.)

    Para construir este fichero @f{TAGS}, debes ir nivel superior de directorio
    con el codigo fuente de Emacs y ejecutar el comando de compilacion @${make
    tags}:

    ..example >
      M-x compile RET make tags RET
    < example..

    (El comando @${make tags} trabaja bien con las fuentes de GNU Emacs, tan
    bien como con otros paquetes de codigo fuente.)

    Para más información, mira @l{info:emacs#Tags<>Tablas de Etiquetas} en @e(El
    Manual de GNU Emacs).

** Repaso

   Aquí hay un breve resumen de algunas funciones recientemente introducidas.

   - @c(while) ::

     Evalúa repetidamente el cuerpo de la expresión simpre y cuando el primer
     elemento del cuerpo se evalue como verdadero. Entonces devuelve @c{nil}. (La
     expresión se evalua solo por sus efectos secundarios.)

     Por ejemplo:

     ..srci > elisp
       > (let ((foo 2))
       ^   (while (> foo 0)
       ^     (insert (format "foo es %d.\n" foo))
       ^     (setq foo (1- foo))))
       foo es 2.
       foo es 1.
       nil
     < srci..

     (La función @c{insert} inserta sus argumentos en el punto; la función
     @c{format} devuelve una cadena formateada a partir de sus argumentos de la
     forma que @c{message} formatea sus argumentos; @c{\n} produce una nueva
     línea.)

   - @c(re-search-forward) ::

     Busca un patrón, y si se encuentra, mueve el punto al final de la coincidencia.

     Igual que @c{search-forward}, toma cuatro argumentos:

     1. Una expresión regular que especifica el patrón a buscar. (¡Recuerda
        poner comillas alrededor de este argumento!)

     2. Opcionalmente, el límite de la búsqueda.

     3. Opcionalmente, que hacer si la búsqueda falla, devuelve @c{nil} o un
        mensaje de error.

     4. Opcionalmente, cuántas veces se puede repetir la búsqueda; si es
        negativa, la búsqueda va hacia atrás.


   - @c(let*) ::

     Asocia algunas variables localmente a valores particulares, y luego evalúa
     los argumentos restantes, devolviendo el valor del último. Al asociar las
     variables locales, se pueden usan los valores locales de variables
     declaradas anteriormente.

     Por ejemplo:

     ..srci > elisp
       > (let* ((foo 7)
       ^       (bar (* 3 foo)))
       ^   (message "`bar' es %d." bar))
       ‘bar’ es 21.
     < srci..

   - @c(match-beginning) ::

     Devuelve la posición del inicio del texto encontrado por la última
     búsqueda de una expresión regular.

   - @c(looking-at) ::

     Devuelve @c{t} por verdadero si el texto después del punto coincide con el
     argumento, que debería ser una expresión regular.

   - @c(eobp) ::

     Devuelve @c{t} por verdadero si el punto está al final de la parte
     accesible de un búfer. El final de la parte accesible es el final del
     búfer sin reduccion; es el final de la parte reducida en un búfer
     reducido.

** Ejercicios con @c{re-search-forward}

   - Escribe una función para buscar para una expresión que coincida con dos o más
     líneas en blanco consecutivas.

   - Escribe una función para buscar palabras duplicadas, como ‘el el’. Vea la
     Seccion @l{info:emacs#Regexps} en @e(El Manual de GNU Emacs), para obtener
     información de cómo escribir una regexp (una expresión regular) para que
     coincida con una cadena compuesta de dos mitades idénticas. Puedes idear
     varias regexps; algunos son mejores que otras. La función que
     yo utilizo se describe en un apéndice, junto con varias regexps. Vea la
     Seccion @l{#Apéndice A La función @c{the-the}}.

* Contando: repetición y regexps

  La repetición y búsqueda de expresiones regulares son herramientas
  poderosas que con frecuencia se usan cuando se escribe código en Emacs
  Lisp. Este capítulo ilustra el uso de búsqueda de expresiones regulares a
  través de la construcción de comandos de contaje de palabras usando bucles
  @c{while} y recursión.

  La distribución de Emacs estándar contiene una función para contar el
  número de líneas en una región.

  Hay verdadero tipo de pregunta escrita para contar palabras. De este modo, si
  se escribe un ensayo, puede limitarse a 800 palabras; si se escribe una
  novela, te puedes disciplinar a ti mismo a escribir 1000 palabras al
  día. Parece raro, pero durante mucho tiempo, a Emacs le faltó un comando
  para contar palabras. Quizás la gente usaba Emacs mayoritariamente para
  codificar o documentar cosas que no requieren contar palabras, o quizás se
  restringían al sistema operativo el comando de contar palabras, @c{wc}. De
  manera alternativa, la gente puede seguir la convención de las editoriales
  y computaban un contaje de palabras dividiendo el número de caracteres en
  un documento por cinco.

  Hay mucho caminos para implementar un comando para contar palabras. Aquí
  hay algunos ejemplos, que pueden desear compararse con el comando de Emacs
  estándar, @c{count-words-region}.

** La función @c{count-words-example}

   Un comando de contar palabras podría contar palabras en una línea,
   párrafo, región, o búfer. ¿Qué comando funcionaría? Se podría diseñar el
   comando para contar el número de palabras en un búfer completo. Sin
   embargo, la tradición Emacs anima a la flexibilidad––se puede querer
   contar palabras solo en una sección, en vez de en todo un búfer. Así,
   tiene más sentido diseñar el comando para contar el número de palabras en
   una región. Una vez tienes un comando @c{count-words-region}, se puede, si
   desea, contar palabras en un búfer completo marcándolo con @k{C-x h} @%c(mark-whole-buffer).

   Claramente, contar palabras es un acto repetitivo: empezando desde el
   principio de la región, se cuenta la primera palabra, entonces la segunda
   palabra, entonces la tercera palabra, y así sucesivamente, hasta que logres el fin de la
   región. Esto significa que contar palabras se ajusta idealmente a
   recursión o a un bucle @c{while}.

   Primero, implementaremos el comando de contar palabras con un bucle
   @c{while}, entonces con la recursión. El comando, de acuerdo, será
   interactivo.

   La plantilla para una definición de función interactiva es, como siempre:

   ..src > elisp
     (defun name-of-function (argument-list)
       "documentation…"
       (interactive-expression…)
       body…)
   < src..

   Lo que necesitamos hacer es rellenar los slots.

   El nombre de la función sería auto-explicativo y similar al nombre del
   @c{count-lines-region} existente. Esto hace que el nombre sea fácil de
   recordar. @c{count-words-region} es una buena elección. Puesto que el
   nombre se usa ahora para el comando de Emacs estándar para contar
   palabras, nosotros nombraremos nuestra implementación como
   @c{count-words-example}.

   La función cuenta palabras con una región. Esto significa que el argumento
   lista debe contener símbolos que son asociados a las dos posiciones, el
   principio y fin de la región. Estas dos posiciones puede ser llamadas
   @'{beginning} y @'{end} respectivamente. La primera línea de la
   documentación sería una frase simple, desde que esto es todo lo que está
   impreso como documentación por un comando tal como @c{apropos}. La
   expresión interactiva será de la forma @'{(interactive "r")}, puesto que
   causará que Emacs pase al principio y fin de la región a la lista de
   argumentos de función. Todo esto es rutina.

   El cuerpo de la función necesita ser escrita para hacer tres tareas:
   primero, configurar condiciones bajo las que el bucle @c{while} pueda
   contar palabras, segundo, ejecutar el bucle @c{while}, y tercero, enviar
   un mensaje al usuario.

   Cuando un usuario llama a @c{count-words-example}, apunta a que puede estar al
   principio o fin de la región. Sin embargo, el proceso de conteo debe
   empezar al principio de la región. Esto significa que querremos poner el
   punto que hay si eso no está allí. Ejecutando @c{(goto-char beginning)}
   asegura esto. De acuerdo, querremos devolver el punto a su posición
   esperada cuando la función finalice su trabajo. Por esta razón, el cuerpo
   debe ser encerrado en una expresión @c{save-excursion}.

   La parte central del cuerpo de la función consiste en un bucle @c{while}
   en el que una expresión salta el punto hacia delante palabra por palabra,
   y otra expresión cuenta estos saltos. Si la prueba-verdadero-o-falso del
   bucle @c{while} es verdadero, el punto saltaría hacia adelante, y si es
   falso el punto estaría al fin de la región.

   Nosotros podríamos usar @c{(forward-word 1)} como la expresión para mover
   el punto hacia adelante palabra por palabra, pero eso es fácil de ver que
   Emacs identifica como una ‘palabra’ si se usa una búsqueda de expresión
   regular.

   Una expresión regular busca lo que encuentra el patrón que se está
   buscando deja el punto después del último carácter emparejado. Esto
   significa que una sucesión de palabras exitosas busquen que moverá el
   punto adelante palabra por palabra.

   Como materia práctica, se quiere que la expresión regular se busque para
   saltar a través de un espacio en blanco y puntúe entre palabras tan bien a
   través de las palabras en sí. Una expresión regexp que rechaza para saltar
   a través de espacios en blanco entre palabras ¡nunca saltaría más de una
   palabra!. Esto significa que el regexp incluiría el espacio en blanco y la
   puntuación sigue a una palabra cualquiera, como la palabra en sí. (Una
   palabra puede finalizar un búfer y no tiene cualquier espacio en blanco o
   puntuación, así esta parte del regexp debe ser opcional.)

   De este modo, queremos para el regexp es un patrón definiendo una o más
   palabras de caracteres que constituyen caracteres seguidos, opcionalmente,
   por uno o más caracteres que no son palabras constituyentes. La expresión
   regular para esto es:

   ..example >
     \w+\W*
   < example..

   La tabla de sintaxis del búfer determina qué caracteres son y no son
   palabras constituyentes. Para más información acerca de sintaxis, Vease
   Sección @"{Tablas de Sintaxis} @e(El Manual de Referencia de GNU Emacs
   Lisp).

   La expresión se parece a esto:

   ..src > elisp
     (re-search-forward "\\w+\\W*")
   < src..

   (Note que las barras invertidas que preceden el @'{w} y @'{W}. Una barra
   invertida tiene significado especial al intérprete Emacs Lisp. Eso indica
   que el caracter siguiente es interpretado de manera diferente que la
   normal. Por ejemplo, los dos caracteres, @'{\n}, son una @'{nueva línea},
   en vez de una barra invertida seguida por @'{\n}. Dos barras invertidas en
   una fila para una ‘barra invertida no especial’, así Emacs Lisp interpreta
   el fin de mirar una barra invertida simple seguida por una letra. Así
   descubre la letra que es especial.)

   Se necesita un contador para contar cuántas palabras hay; esta variables
   debe primero ser asignado a 0 y entonces incrementados cada vez que Emacs
   va alrededor del bucle @c{while}. La expresión de incremento es simple:

   ..src > elisp
     (setq count (1+ count))
   < src..

   Finalmente, se quiere contar al usuario cuántas palabras hay en la
   región. La función @c{message} presenta este tipo de información al
   usuario. El mensaje tiene que ser fraseado de manera que se lea
   apropiadamente sin cuidado de cuantas palabras hay en la región: no se
   quiere decir que “hay una palabra en la región”. El conflicto entre
   singular y plural no es gramatical. Se puede resolver este problema usando
   una expresión condicional que evalúa diferentes mensajes dependiendo en el
   número de palabras en la región. Hay tres posibilidades: no palabras en la
   región, una palabra en la región, y más de una palabra. Esto significa que
   la forma especial @c{cond} es apropiada.

   Todo esto lidera a la siguiente definición de función:

   ..src > elisp
     ;;; ¡La Primera versión; tiene errores!
     (defun count-words-region (beginning end)
       "Imprime el número de palabras en la región.
     Las palabras están definidas al menos una palabra
     constituida de caracteres seguido por al menos un
     caracter que no constituye palabra. La tabla de
     sintaxis del búfer determina qué caracteres hay."
       (interactive "r")
       (message "Contando palaras en la región ... ")

     ;;; 1. Configurar condiciones apropiadas.
       (save-excursion
         (goto-char beginning)
         (let ((count 0))

     ;;; @e{2. Ejecutar el} @e{bucle} while.
           (while (< (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))

     ;;; 3. Enviar un mensaje al usuario.
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message
                   "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   < src..

   Como se escribe, la función funciona, pero no en todas las circunstancias.

*** El error de espacio en blanco en @c{count-words-example}

    El comando @c{count-words-example} descrito en la sección precedente tiene
    dos errores, o incluso, un error con dos manifestaciones. Primero, si se
    marca una región conteniendo solo espacio en blanco en el medio de algún
    texto el comando ¡@c{count-words-example} cuenta que la región contiene una
    palabra!. Segundo, si se marca una región conteniendo solo espacios en
    blanco al final del búfer o la porción accesible de un búfer encogido,
    el comando muestra un mensaje de error que se parece a esto:

    ..example >
      Búsqueda fallida: "\\w+\\W*"
    < example..

    Si está leyendo esto en Info en GNU Emacs, se puede testear para estos
    errores por sí mismo.

    Primero, evalúa la función de la manera usual para instalarlo.

    Si se desea, se puede también instalar este atajo para ser evaluado:

    ..src > elisp
      (global-set-key "\C-c=" 'count-words-example)
    < src..

    Para conducir el primer test, asigna marca y punto al principio y fin de
    la siguiente línea y entonces escribe @k{C-c =} (o @k{M-x
    count-words-example} si no se ha asignado @k{C-c =}):

    ..example >
          uno   dos  tres
    < example..

    Emacs te contará, correctamente, que la región tiene tres palabras.

    Repite la prueba, pero marca el lugar al principio de la línea y emplaza el
    punto justo @e{antes} de la palabra @'{uno}. De nuevo escribe el comando
    @k{C-c =} (o @k{M-x count-words-example}). Emacs cuenta que la región no
    tiene palabras, puesto que eso está compuesto solo por espacios en blanco
    al principio de la línea. ¡Pero en vez de que Emacs cuente que la región
    tiene una palabra!

    Para el tercer test, copia la línea de ejemplo al fin del búfer
    @f{*scratch*} y entonces escribe varios espacios al fin de la
    línea. Posiciona la marca correcta después de la palabra @'{tres} y
    apunta al fin de la línea. (El fin de la línea será el fin del búfer.)
    Escribe @k{C-c =} (o @k{M-x count-words-example}) como se hizo antes. De
    nuevo, Emacs te contaría que la región no tiene palabras, puesto que eso
    está compuesto solo de los espacios en blanco al fin de la línea. En vez
    de eso, Emacs muestra un mensaje de error diciendo @'{Búsqueda fallida}.

    Los dos errores queman el mismo problema.

    Considere la primera manifestación del error, en el que el comando te
    cuenta que el espacio en blanco al principio de la línea contiene una
    palabra. Lo que ocurre es esto: El comando @c{M-x count-words-example} mueve
    el punto al principio de la región. La prueba @c{while} si el valor del
    punto es más pequeño de lo que el valor de @c{end}, que es. Por
    consiguiente, en la expresión regular se busca y encuentra la primera
    palabra. Eso deja el punto después de la palabra. @c{count} que se
    establece a uno. El bucle @c{while} repite; pero esta vez el valor del
    punto es más largo que el valor de @c{end}, el bucle sale; y la función
    muestra un mensaje diciendo el número de palabras en la región es uno. En
    breve, la expresión regular busca y encuentra la palabra incluso aunque
    eso esté fuera de la región marcada.

    En la segunda manifestación del error, la región es un espacio en blanco
    al fin del búfer. Emacs dice @'{Búsqueda fallida}. Lo que ocurre es que
    prueba-verdadero-o-falso en el bucle @c{while} chequea verdad, así la expresión
    de búsqueda es ejecutada. Pero desde que no hay más palabras en el
    buffer, la búsqueda falla.

    En ambas manifestaciones del error, la búsqueda extiende o intenta
    extenderse fuera de la región.

    La solución es limitar la búsqueda a la región––esto es una acción simple
    y limpia, pero como tu puedes tener que llegar a esperar, eso no es tan
    simple como se podría pensar.

    Como se ha visto, la función @c{re-search-forward} toma un patrón de
    búsqueda como su primer argumento. Pero además de este primer, argumento
    obligatorio, se aceptan tres argumentos opcionales. El segundo argumento
    opcional asocia la búsqueda. El tercer argumento opcional, si @c{t},
    causa la función a devolver @c{nil} en vez de la señal un error si la
    búsqueda falla. El cuarto argumento opcional es un contador repetido. (En
    Emacs, se puede ver una documentación de la función escribiendo @k{C-h
    f}, el nombre de la función, y entonces @k{RET}.)

    En la definición @c{count-words-example}, el valor del fin de la región es
    tomada por la variable @c{end} que es pasada como un argumento para la
    función. De este modo, se puede añadir @c{end} como un argumento para la
    búsqueda de la expresión de búsqueda:

    ..src > elisp
      (re-search-forward "\\w+\\W*" fin)
    < src..

    Sin embargo, si se crea solo este cambio a la definición
    @c{count-words-example} y entonces se chequea la nueva versión de la
    definición en una extensión de espacio en blanco, se recibirá un mensaje
    de error diciendo @'{Búsqueda fallida}.

    Lo que ocurre es esto: la búsqueda se limita a la región, y falla como se
    espera porque no hay caracteres de palabras constituyentes en la
    región. Puesto que eso falla, se recibe un mensaje de error. Pero no
    queremos recibir un mensaje de error en este caso; se quiere recibir el
    mensaje que "La región no tiene palabras".

    La solución a este problema es proveer @c{re-search-forward} con un
    tercer argumento de @c{t}, que causa la función para devolver @c{nil} en
    vez la señalar un error si la búsqueda falla.

    Sin embargo, si se crea este cambio y se intenta, se verá el mensaje
    “Contando palabras en la región ...” y … se guardará viendo qué mensaje
    …, hasta que se escribe @k{C-g} @%c(keyboard-quit).

    Aquí está lo que ocurre: la búsqueda está limitada a la región, como
    antes, y eso falla porque no hay caracteres no constituyentes de palabras
    en la región, como se espera. Por tanto, la expresión
    @c{re-search-forward} devuelve @c{nil}. Eso no hace nada más. En
    particular, no mueve el punto, que hace como un efecto secundario si se
    encuentra la búsqueda objetiva. Después la expresión
    @c{re-search-forward} devuelve @c{nil}, la siguiente expresión en el
    bucle @c{while} está evaluado. Esta expresión incrementa el
    contador. Entonces el bucle repite. La prueba prueba-verdadero-o-falso chequea
    verdadero porque el valor del punto es todavía menor que el valor final,
    desde que la expresión @c{re-search-forward} no movería el punto. … y el
    ciclo repite …

    La definición @c{count-words-example} requiere todavía de otra modificación
    para causar el prueba-verdadero-o-falso del bucle @c{while} para probar falso
    si la búsqueda falla. Pon otro camino, hay dos condiciones que deben ser
    satisfechas en el prueba-verdadero-o-falso antes que el contador de palabras
    variable se incremente: el punto debe todavía estar con la región y la
    expresión de búsqueda debe haber encontrado una palabra para contar.

    Por ambas la primera condición y la segunda condición deben ser ciertas
    juntas, las dos expresiones, la región chequea y la expresión de
    búsqueda, puede estar unido con una forma especial @c{and} y embebido en
    el bucle @c{while} como el prueba-verdadero-o-falso, como esto:

    ..src > elisp
      (and (< (point) end) (re-search-forward "\\w+\\W*" end t))
    < src..

    (Para información acerca de @c{and}, ver @"{La función @c{kill-new}}.)

    La expresión @c{re-search-forward} devuelve @c{t} si la búsqueda es
    exitosa y como efecto secundario se mueve el punto. Consiguientemente, como
    las palabras se encuentran, el punto es movido a través de la
    región. Cuando la búsqueda de la expresión falla para encontrar otra
    palabra, o cuando el punto logra el fin de la región, la prueba
    prueba-verdadero-o-falso es falso, el bucle @c{while} existe, y la función
    @c{count-words-example} muestra uno u otro de sus mensajes.

    Después de incorporar estos cambios finales, el @c{count-words-example}
    funciona sin errores (¡o al menos, sin los errores que yo haya
    encontrado!. Aquí está lo que parece:

    ..src > elisp
      ;;; @e{Versión final:} @c{while}
      (defun count-words-example (beginning end)
        "Imprime número de palabras en la región."
        (interactive "r")
        (message "Contando palabras en la región ... ")

      ;;; 1. Configura condiciones apropiadas.
        (save-excursion
          (let ((count 0))
            (goto-char beginning)

      ;;; @e{2. Ejecuta el} @e{bucle} while
            (while (and (< (point) end)
                        (re-search-forward "\\w+\\W*" end t))
              (setq count (1+ count)))

      ;;; 3. Enviar un mensaje al usuario.
            (cond ((zerop count)
                   (message
                    "La región no tiene palabras."))
                  ((= 1 count)
                   (message
                    "La región tiene 1 palabra."))
                  (t
                   (message
                    "La región tiene %d palabras." count))))))
    < src..

** Cuenta palabras recursivamente

   Se puede escribir la función para contar palabras tanto de manera
   recursiva como con un bucle @c{while}. Permita ver cómo se hace.

   Primero, se necesita reconocer que la función @c{count-words-example} tiene
   tres trabajos: eso configura las condiciones apropiadas para contar lo que
   ocurre; eso cuenta las palabras en la región; y envía un mensaje al
   usuario contando cuántas palabras hay.

   Si se escribe una función recursiva simple para hacer cualquier cosa se
   recibirá un mensaje para cada llamada recursiva. Si la región contiene 13
   palabras, se recibirán trece mensajes, uno correcto después del otro. ¡No
   queremos esto!. En vez de eso, se deben escribir dos funciones para hacer
   el trabajo, una (la función recursiva) será usada dentro de la otra. Una
   función configurará las condiciones y muestra el mensaje; la otra
   devolverá el contador de palabras.

   Permítase comenzar con la función que causa el mensaje que se muestra. Se
   puede continuar por llamarse @c{count-words-example}.

   Esta es la función que el usuario llama. Será interactiva. En realidad,
   será similar a nuestras versiones previas de esta función, excepto que
   llamará @c{recursive-count-words} para determinar cuántas palabras hay en
   la región.

   Se puede construir una plantilla legible para esta función, basada en
   versiones previas:

   ..src > elisp
     ;; Versión Recursiva; usa la búsqueda de la expresión regular
     (defun count-words-example (beginning end)
       "documentation…"
       (interactive-expression…)

     ;;; 1. Configura condiciones apropiadas.
       (explanatory message)
       (set-up functions…

     ;;; 2. Contar las palabras.
         recursive call

     ;;; 3. Envía un mensaje al usuario.
         message providing word count))
   < src..

   La definición parece sencilla, excepto que como el contador devuelve la
   llamada recursiva que debe ser pasada al mensaje mostrando el contaje de
   palabras. Un pequeño pensamiento sugiere que esto puede ser hecho haciendo
   uso de una expresión @c{let} al número de palabras en la región, como se
   devuelve por la llamada recursiva; y entonces la expresión @c{cond}, que
   usa la asociación, puede mostrar el valor al usuario.

   Con frecuencia, uno piensa que se puede asociar una expresión @c{let} como
   algo secundario al trabajo ‘primario’ de una función. Pero en este caso,
   se podría considerar el trabajo ‘primario’ de la función, contando
   palabras, esto es hecho con la expresión @c{let}.

   Usando @c{let}, la definición de función se parece a:

   ..src > elisp
     (defun count-words-example (beginning end)
       "Imprime el número de palabras en la región."
       (interactive "r")

     ;;; 1. Configura condiciones apropiadas.
       (message "Contando palabras en la región ... ")
       (save-excursion
         (goto-char beginning)

     ;;; 2. Contar las palabras.
         (let ((count (recursive-count-words end)))

     ;;; 3. Enviar un mensaje al usuario.
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message
                   "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   < src..

   Lo siguiente, que se necesita es escribir la función de contaje recursivo.

   Una función recursiva tiene al menos tres partes: el ‘prueba-hazlo-de-nuevo’, la
   ‘expresion-del-siguiente-paso’, y la llamada recursiva.

   La prueba-hazlo-de-nuevo determina si la función será o no llamada de
   nuevo. Puesto que estamos contando palabras en una región y puede causar
   que una función se mueva el punto hacia delante por cada palabra, el
   prueba-hazlo-de-nuevo puede probar si el punto está todavía con la región. El
   prueba-hazlo-de-nuevo encontraría el valor del punto y determina si el punto está
   antes, en, o después del valor del fin de la región. Se puede usar la
   función @c{point} para localizar el punto. Claramente, se debe pasar el
   valor del fin de la región a la función de contaje recursivo como un
   argumento.

   Además, el prueba-hazlo-de-nuevo también chequea si la búsqueda encuentra una
   palabra. Si no, la función no se llamaría de nuevo.

   La expresion-del-siguiente-paso cambia un valor así que cuando la función
   recursiva se supone que debe parar de llamarse así misma, se para. Más
   precisamente, los cambios de expresion-del-siguiente-paso cambia un valor así en
   el momento adecuado, el prueba-hazlo-de-nuevo para la función recursiva de la
   llamada en sí de nuevo. En este caso, la expresion-del-siguiente-paso puede ser la
   expresión que mueve el punto hacia adelante, palabra por palabra.

   La tercera parte de una función recursiva es la llamada recursiva.

   En algún lugar, también, se necesita una parte que hace el ‘trabajo’ de la
   función, una parte que es el contaje. ¡Una parte vital!

   Pero ya, tenemos un guión de la función recursiva de contaje:

   ..src > elisp
     (defun recursive-count-words (region-end)
       "documentation…"
        prueba-hazlo-de-nuevo
        expresion-del-siguiente-paso
        recursive call)
   < src..

   Ahora se necesita rellenar los slots. Permite comenzar con el caso más
   simple primero: si se apunta debajo del fin de la región, no puede haber
   palabras en la región, así la función devuelve cero. De otro modo, si la
   búsqueda falla no hay palabras para contar, así la función devolvería
   cero.

   Por otro lado, si se apunta con la región y la búsqueda tiene éxito, la
   función se llamaría de nuevo.

   De este modo, prueba-hazlo-de-nuevo se vería así:

   ..src > elisp
     (and (< (point) region-end)
          (re-search-forward "\\w+\\W*" region-end t))
   < src..

   Note que la expresión de búsqueda es parte del prueba-hazlo-de-nuevo --- la
   función devuelve @c{t} si su búsqueda tiene éxito y @c{nil} si
   falla. (Vea la Seccion @l{Error de espacio en blanco, , El Error de Espacio
   en Blanco en @c{count-words-example}}), para una explicación de cómo
   @c{re-search-forward} funciona.)

   La prueba-hazlo-de-nuevo es la prueba true-or-false de una cláusula
   @c{if}. Claramente si el prueba-hazlo-de-nuevo tiene éxito, la then-part de la
   cláusula @c{if} llamaría a la función; pero si eso falla, la else-part
   devolvería cero desde que el punto está fuera de la región o la búsqueda
   falló porque no había palabras a encontrar.

   Pero antes de considerar la llamada recursiva, se necesita considerar la
   expresion-del-siguiente-paso. ¿Qué es eso? De manera interesante, eso es la parte
   de la búsqueda del prueba-hazlo-de-nuevo.

   Además para devolver @c{t} o @c{nil} para el prueba-hazlo-de-nuevo,
   @c{re-search-forward} mueve el punto hacia adelante como un efecto secundario
   de una búsqueda exitosa. Esta es la acción que cambia el valor de punto
   así que la función recursiva para de llamarse a sí misma cuando el punto
   complete su movimiento a través de la región. Por consiguiente, la
   expresión @c{re-search-forward} es la expresion-del-siguiente-paso.

   En esquema, entonces, el cuerpo de la función @c{recursive-count-words} se
   parece a esto:

   ..src > elisp
     (if prueba-hazlo-de-nuevo-and-next-step-combined
         ;; then
         recursive-call-returning-count
       ;; else
       return-zero)
   < src..

   ¿Cómo incorporar el mecanismo que cuenta?

   Si no estás acostumbrado a escribir funciones recursivas, una pregunta
   como esta puede ser un problema. Pero eso puede y sería enfocado
   sistemáticamente.

   Se sabe que el mecanismo de contaje sería asociado en algún lugar con la
   llamada recursiva. En vez de eso, desde que la expresion-del-siguiente-paso mueve
   el punto hacia adelante por una palabra, y desde que una llamada recursiva
   es hecha para cada palabra, el mecanismo de contaje debe ser una expresión
   que añade uno al valor devuelto por una llamada para
   @c{recursive-count-words}

   Considera varias casos:

   - Si hay dos palabras en la región, la función devolverá un valor
     resultante de añadir uno al valor devuelto al contar la primera palabra,
     más el número devuelto al contar las palabras que permanecen en la
     región, que en este caso es una.

   - Si hay una palabra en la región, la función devolvería un valor
     resultante de añadir uno al valor devuelto cuando eso cuenta esta
     palabra más el número devuelto cuando eso cuenta las palabras que
     permanecen en la región, que en este caso es cero.


   - Si no hay palabras en la región, la función devolvería cero.


   Desde el esquema se puede ver que la parte else del @c{if} devuelve cero
   para el caso en el que no hay palabras. Esto significa que la parte then
   del @c{if} debe devolver un valor resultante de añadir uno al valor
   devuelto desde el contaje de las palabras que permanecen.

   La expresión se parece a esto, donde @c{1+} es una función que añade uno a
   su argumento.

   ..src > elisp
     (1+ (recursive-count-words region-end))
   < src..

   La función completa @c{recursive-count-words} entonces se parecerá e esto:

   ..src > elisp
     (defun recursive-count-words (region-end)
       "documentation…"

     ;;; 1. prueba-hazlo-de-nuevo
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; 2. then-part: la llamada recursiva
           (1+ (recursive-count-words region-end))

     ;;; 3. else-part
         0))
   < src..

   Permíteme examinar cómo esto funciona:

   Si no hay palabras en la región, la parte else de la expresión @c{if} es
   evaluada y, por tanto, la función devuelve cero.

   Si hay una palabra en la región, el valor del punto es menor que el valor
   de @c{region-end} y la búsqueda tiene éxito. En este caso, el
   prueba-verdadero-o-falso de la expresión @c{if} chequea verdadero, y la then-part
   de la expresión @c{if} es evaluada. La expresión de contaje se
   evalúa. Esta expresión devuelve un valor (que será el valor devuelto por
   la función completa) que es la suma de uno añadida al valor devuelto por
   una llamada recursiva.

   Mientras tanto, la expresion-del-siguiente-paso ha causado el punto para saltar a
   través de la primera (y en este caso única) palabra en la región. Esto
   significa que cuando @c{(recursive-count-words region-end)} está evaluada
   una segunda vez, como un resultado de la llamada recursiva, el valor del
   punto será igual o mayor que el valor de la región final. Así esta vez,
   @c{recursive-count-words} devolverá cero. El cero será añadido a uno, y la
   evaluación original de @c{recursive-count-words} devolverá uno más cero
   (uno) que es la cantidad correcta.

   Claramente, si hay dos palabras en la región, la primera llamada a
   @c{recursive-count-words} devuelve uno que se añade al valor devuelto por
   el siguiente @c{recursive-count-words} en una región donde está la palabra
   que permanece––que es, eso añadir uno a uno, produciendo dos, que es la
   cantidad correcta.

   Similarmente, si hay tres palabras en la región, la primera llamada
   @c{recursive-count-words} devuelve uno añadido al valor devuelto llamado
   @c{recursive-count-words} en una región conteniendo las dos palabras que
   faltan––y así sucesivamente.

   Con documentación completa las dos funciones se parecen a esto:

   La función recursiva:

   ..src > elisp
     (defun recursive-count-words (region-end)
       "Número de palabras entre punto y REGION-END."

     ;;; 1. prueba-hazlo-de-nuevo
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; 2. then-part: la llamada recursiva
           (1+ (recursive-count-words region-end))

     ;;; 3. else-part
         0))
   < src..

   El envoltorio:

   ..src > elisp
     ;;; Versión Recursiva
     (defun count-words-example (beginning end)
       "Imprime el número de palabras en la región.

     Las palabras son definidas como al menos una palabra constituyente
     seguida por al menos un caracter que es una palabra constituyente. La
     tabla de sintaxis del buffer determina qué caracter hay.
       (interactive "r")
       (message "Contando palabras en la región ... ")
       (save-excursion
         (goto-char beginning)
         (let ((count (recursive-count-words end)))
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   < src..

** Ejercicio: contando puntuación

   Usando un bucle @c{while}, escriba una función para contar el número de
   marcas de puntuación en una región––periodo, coma, punto y coma, dos
   puntos, exclamación, marca y marca de pregunta. Haga lo mismo usando
   recursión.

* Contando palabras en una @c{defun}

  El siguiente proyecto es contar el número de palabras en una definición de
  función. Claramente, esto se puede hacer usando alguna variante de
  @c{count-words-example}. Vea la Seccion @l{Contando palabras, , Contando
  palabras: repetición y regexps}. Si se está ahora yendo a contar las
  palabras en una definición, es suficientemente fácil marcar la definición
  con el comando @k{C-M-h} @%c(mark-defun), y entonces se llama a
  @c{count-words-example}.

  Sin embargo, soy más ambicioso: Yo quiero contar las palabras y símbolos en
  cada definición en las fuentes de Emacs y entonces imprimir un grafo que
  muestre cuántas funciones hay de cada tamaño: cuántas contienen de 40 a 49
  palabras o símbolos, cuántas contienen de 50 a 59 palabras o símbolos, y
  así. Yo he sido con frecuencia curioso de cómo es una función típica, y
  esto se contará.

  Descrito en una frase, el proyecto desanima; pero dividido dentro de
  numerosos pequeños pasos, cada uno de los que podemos tomar en un momento,
  el proyecto llegar ser menos atemorizante. Permítenos considerar qué pasos
  deben ser:

  - Primero, escribe una función para contar las palabras en una
    definición. Esto incluye el problema de manejar símbolos tan bien como
    palabras.

  - Segundo, escribe una función para listar los números de palabras en cada
    función en un fichero. Esta función puede usar la función
    @c{count-words-in-defun}.

  - Tercero, escribe una función para listar los números de palabras en cada
    función en cada uno de varios ficheros. Esto encola automáticamente
    encontrando varios ficheros, cambiándolos, y contando las palabras en las
    definiciones con ellos.

  - Cuarto, escribe una función para convertir la lista de números que
    nosotros creamos en tres pasos para un formulario que se ajustará para
    imprimir un grafo.


  - Quinto, escribe una función para imprimir los resultados como un grafo.


  ¡Esto es un proyecto! Pero si tomamos cada paso lentamente, eso no será
  difícil.

** ¿Qué contar?

   Cuando nosotros primero empezamos pensando acerca del contaje de palabras
   en una definición de función, la primera pregunta es (o podría ser) ¿qué
   se va a contar?  Cuando se habla de ‘palabras’ con repecto a una
   definición de función Lisp, estamos actualmente hablando, en parte, de
   ‘símbolos’. Por ejemplo, la siguiente función @c{multiply-by-seven}
   contiene los cinco símbolos @c{defun}, @c{multipy-by-seven}, @c{number},
   @c{*}, y @c{7}. Además, en la cadena de documentación, contiene cuatro
   palabras @'{Multiplicar}, @'{NUMBER}, @'{por}, y @'{siete}. El símbolo
   @'{número} es repetido, así la definición contiene un total de diez
   palabras y símbolos.

   ..src > elisp
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
   < src..

   Sin embargo, si se marca la definición @c{multiply-by-seven} con @k{C-M-h}
   (@c{mark-defun}), y entonces se llama a @c{count-words-example} dentro, se
   encontrará que @c{count-words-example} ¡reclama la definición tiene once
   palabras, no diez! ¡Alguna cosa está mal!

   El problema es doble: @c{count-words-example} no cuenta el @'{*} como una
   palabra, y eso cuenta el símbolo simple, @c{multiply-by-seven},
   conteniendo tres palabras. Las conexiones son tratadas como si fueran
   espacios entre palabras en vez de conectores entre palabras
   @'{multiply-by-seven} se cuenta como si fuese escrito
   @'{multiply-by-seven}.

   La causa de esta confusión es la expresión regular que busca la definición
   @c{count-words-example} que mueve el punto hacia delante palabra por
   palabra. En la versión canónica de @c{count-words-example}, el regexp es:

   ..example >
     "\\w+\\W*"
   < example..

   Esta expresión regular es un patrón definiendo una o más palabras
   constituyendo caracteres posiblemente seguidos por uno o más caracteres
   que no son palabras constituyentes. Esto significa que los ‘caracteres que
   constituyen palabras’ nos traen la cuestión de la sintaxis, que es el
   valor de una sección en sí.

** ¿Qué constituye una palabra o símbolo?

   Emacs trata diferentes caracteres perteneciendo a diferentes @:{categorías
   de sintaxis}. Por ejemplo, la expresión regular, @'{\\w+}, es un patrón
   especificando uno o más caracteres de @e{palabras constituyentes}. Los
   caracteres de palabras constituyentes son miembros de una categoría de
   sintaxis. Otras categoría de sintaxis incluye la clase de caracteres de
   puntuación, tales como el espacio en blanco o el caracter de
   tabulación. (Para más información, ver Seccion @"{La Tabla de Sintaxis} en
   @e(El Manual GNU Emacs), y Seccion @"{Tablas de Sintaxis} en @e(El Manual
   de Referencia GNU Emacs Lisp).)

   Las tablas de sintaxis especifican qué caracteres pertenecen a qué
   categorías. Normalmente un guión no está especificado como un ‘caracter
   constituido por una palabra’. En vez de eso, se especificó como estando en
   la ‘clase de caracteres que son parte de los nombres de símbolos, pero no
   las palabras.’  Esto significa que la función @c{count-words-example} se trata
   del mismo modo que trata un espacio en blanco entre palabras, que es el
   por qué @c{count-words-example} cuenta @'{multiply-by-seven} como tres
   palabras.

   Hay dos caminos para causar que Emacs cuente @'{multiply-by-seven} como un
   símbolo: modificar la tabla de sintaxis o modificar la expresión regular.

   Se podría redefinir un guión (@e{hyphen}) como un caracter que constituye
   una palabra modificando la tabla de sintaxis que Emacs guarda por cada
   modo. Esta acción serviría nuestro propósito, excepto que una conexión es
   meramente el caracter más común con símbolos que no son típicamente un
   caracter de palabra constituyente; hay otros, también.

   Alternativamente, se puede redefinir la expresión regular @e{regexp} usada
   en la definición @c{count-words} así como incluir símbolos. Este
   procedimiento tiene el mérito de la claridad, pero la tarea es un pequeño
   truco.

   La primera parte es suficientemente simple: el patrón debe asignarse “al
   menos un carácter que es una palabra o símbolo constituyente”. De este
   modo:

   ..example >
     "\\(\\w\\|\\s_\\)+"
   < example..

   El @'{\\(} es la primera parte del constructo que agrupa esto que incluye
   el @'{\\w} y el @'{\\s_} como alternativas, separadas por los @'{\\|}. El
   @'{\\w} asocia cualquier caracter de palabra constituyente y el @'{\\s_}
   asocia cualquier caracter que es parte de un nombre de símbolo pero no una
   palabra de caracteres constituyente. El @'{+} sigue al grupo que indica
   que la palabra o símbolo constituyan caracteres que deben ser asociados al
   menos por uno.

   Sin embargo, la segunda parte de regexp es más difícil de diseñar. Lo que
   queremos es seguir la primera parte con “opcionalmente uno o más
   caracteres que no constituyen una palabra o símbolo”. Primero, se pensaba
   que se podría definir esto con lo siguiente:

   ..example >
     "\\(\\W\\|\\S_\\)*"
   < example..

   Las mayúsculas @'{W} y @'{S} asocian caracteres que @e{no} son
   constituyente de palabra o símbolo. Desafortunadamente, esta expresión
   asocia cualquier caracter que sea o no una palabra constituyente no un
   símbolo constituyente. ¡Esto asocia cualquier caracter!

   Entonces se notificó que cada palabra o símbolo en mi región test fué
   seguida por algún espacio (espacio en blanco, tabulador, o nueva
   línea). Así yo intenté emplazar un patrón para asociar uno o más espacios
   en blanco después del patrón para una o más palabras o símbolos
   constituyentes. Esto falló, también. Palabras y símbolos son con
   frecuencia separados por espacios en blanco, pero en el código actual los
   paréntesis pueden seguir símbolos y puntuación puede seguir las
   palabras. Así finalmente, se diseño un patrón en el que la palabra o
   símbolo constituyente es seguido opcionalmente por caracteres que no son
   espacios en blanco y entonces son seguidos opcionalmente por espacios en
   blanco.

   Aquí está la expresión regular completa:

   ..example >
     "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
   < example..

** La función @c{count-words-in-defun}

   Se ha visto que hay varios caminos para escribir una función
   @c{count-word-region}. Para escribir un @c{count-words-in-defun}, se
   necesita solamente adaptar una de estas versiones.

   La versión que usa un bucle @c{while} es fácil de comprender, así estoy
   yendo a adaptar esto. Porque @c{count-words-in-defun} será parte de un
   programa más complejo, eso no necesita ser interactivo y no necesita
   mostrar un mensaje pero solo devuelve el contaje. Estas consideraciones
   simplifican la definición un poco.

   Por otro lado, @c{count-words-in-defun} será usado con un buffer que
   contiene definiciones de función. Consiguientemente, es razonable
   preguntar que la función determina si se llamó cuando el punto está con
   una definición de función, y eso es, para devolver el contaje para esta
   definición. Esto añade complejidad a la definición, pero nos guarda desde
   la necesidad de pasar argumentos a la función.

   Estas consideraciones nos llevan a preparar la siguiente plantilla:

   ..src > elisp
     (defun count-words-in-defun ()
       "documentation…"
       (set up…
          (while loop…)
        return count)
   < src..

   Así, el trabajo es rellenar los slots.

   Primero, la configuración.

   Estamos presuponiendo que esta función será llamada con un búfer
   conteniendo definiciones de función. Apunta si será con una definición de
   función o no. Para que @c{count-words-in-defun} funcione, el punto debe
   moverse al principio de la definición, un contador debe empezar a cero, y
   el bucle contando debe parar cuando el punto logre el fin de la
   definición.

   La función @c{beginning-of-defun} busca atrás para un delimitador de
   apertura tal como @'{(} al principio de una línea, y mueve el punto a esta
   posición, o sino al límite de la búsqueda. En la práctica, esto significa
   que @c{beginning-of-defun} mueve el punto al principio de un cierre o
   definición de función precedente, o sino al principio del buffer.

   El bucle @c{while} requiere un contador para guardar la traza de las
   palabras o símbolos siendo contados. Una expresión @c{let} puede ser usado
   para crear una variable local para este propósito, y lo asocia a un valor
   inicial de cero.

   La función @c{end-of-defun} funciona como @c{beginning-of-defun} excepto
   que mueve el punto al fin de la definición. @c{end-of-defun} puede ser
   usado como parte de una expresión que determina la posición del fin de la
   definición.

   La configuración para @c{count-words-in-defun} toma forma rápidamente:
   primero movemos el punto al principio de la definición, entonces se crea
   una variable local para manejar el conteo, y finalmente, se graba la
   posición del fin de la definición así el bucle @c{while} conocerá cuando
   parar el bucle.

   El código se parece a esto:

   ..src > elisp
     (beginning-of-defun)
     (let ((count 0)
           (end (save-excursion (end-of-defun) (point))))
   < src..

   El código es simple. La única ligera complicación es probablemente ir al
   @c{end}: eso está asociado a la posición del fin de la definición por una
   expresión @c{save-excursion} que devuelve el valor del punto después de
   @c{end-of-defun} temporalmente se mueve al fin de la definición.

   La segunda parte del @c{count-words-in-defun}, después de la
   configuración, es el bucle @c{while}.

   El bucle debe contener una expresión que mueva el punto hacia adelante
   palabra por palabra y símbolo por símbolo, y otra expresión que cuente los
   saltos. La prueba-verdadero-o-falso para el bucle @c{while} probaría
   verdadero tan largo como el punto debería saltar hacia adelante, y falso
   si apunta al fin de la definición. Ya se ha redefinido la expresión
   regular para esto, así el bucle es sencillo:

   ..src > elisp
     (while (and (< (point) end)
                 (re-search-forward
                  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t)
       (setq count (1+ count)))
   < src..

   La tercera parte de la definición devuelve el contaje de palabras y
   símbolos. Esta parte es la última expresión con el cuerpo de la expresión
   @c{let}, y puede ser, muy la variable local @c{count}, que cuando se
   evalúa devuelve el contaje.

   Puesto junto, la definición @c{count-words-in-defun} se ve así:

   ..src > elisp
     (defun count-words-in-defun ()
       "Devuelve el número de palabras y símbolos en una defun."
       (beginning-of-defun)
       (let ((count 0)
             (end (save-excursion (end-of-defun) (point))))
         (while
             (and (< (point) end)
                  (re-search-forward
                   "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
                   end t))
           (setq count (1+ count)))
         count))
   < src..

   ¿Cómo se chequea esto? La función no es interactiva, pero es fácil poner
   un envoltorio alrededor de la función para hacerla interactiva; se puede
   usar casi el mismo código como la versión recursiva de
   @c{count-words-example}:

   ..src > elisp
     ;;; Versión Interactiva.
     (defun count-words-defun ()
       "Número de palabras y símbolos en una definición
       de función."
       (interactive)
       (message
        "Contando palabras y símbolos en la definición de función ... ")
       (let ((count (count-words-in-defun)))
         (cond
          ((zerop count)
           (message
            "La definición NO tiene palabras o símbolos."))
          ((= 1 count)
           (message
            "La definición tiene 1 palabra o símbolo."))
          (t
           (message
            "La definición tiene %d palabras o símbolos." count)))))
   < src..

   Permite reutilizar @k{C-c =} como un atajo conveniente:

   ..src > elisp
     (global-set-key "\C-c=" 'count-words-defun)
   < src..

   Ahora se puede intentar @c{count-words-defun}: instala ambas funciones
   @c{count-words-in-defun} y @c{count-words-defun}, y asigna el atajo, y
   entonces emplaza el cursor con la siguiente definición:

   ..src > elisp
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
          ⇒ 10
   < src..

   ¡Éxito! La definición tiene 10 palabras y símbolos.

   El siguiente problema es contar los números de palabras y símbolos en
   varias definiciones con un fichero simple.

** Contar varias @c{defuns} en un fichero

   Un fichero tal como @f{simple.el} puede tener un centenar o más
   definiciones de función dentro. Nuestro objetivo es recoger estadísticas
   en muchos ficheros, pero en un primer paso, nuestro objetivo inmediato es
   recoger estadísticas en un fichero.

   La información será una serie de números, cada número siendo el tamaño de
   una definición de función. Se pueden almacenar los números en una lista.

   Se sabe que se querrá incorporar la información considerando un fichero
   con información acerca de muchos otros ficheros; esto significa que la
   función para contar el tamaño de contaje con un fichero solo necesita
   devolver la lista de tamaños. Eso no necesita y no mostraría mensajes.

   Los comando de contar palabras contienen una expresión para saltar el
   punto hacia adelante palabra por palabra y otra expresión para contar los
   saltos. La función devuelve los tamaños de definiciones que pueden ser
   diseñadas para trabajar del mismo modo, con una expresión para saltar el
   punto hacia la definición por definición y otra expresión para construir
   el tamaño de la lista.

   Esta frase del problema hace elemental escribir la definición de
   función. Claramente, empezaremos el conteo al principio del fichero, así
   el primer comando será @c{(goto-char (point-min))}. Lo siguiente, es
   empezar el bucle @c{while}; y este true-or-false del bucle puede ser una
   búsqueda de expresión regular para la siguiente definición de función ---
   así en el momento que la búsqueda tiene éxito, el punto se mueve hacia
   adelante y entonces el cuerpo del bucle es evaluado. El cuerpo necesita
   una expresión que construye la lista de tamaños. @c{cons}, la lista de
   construcción del comando, puede ser usado para crear la lista. Esto es
   casi todo lo que hay.

   Aquí está este fragmento de código que se ve así:

   ..src > elisp
     (goto-char (point-min))
     (while (re-search-forward "^(defun" nil t)
       (setq lengths-list
             (cons (count-words-in-defun) lengths-list)))
   < src..

   Dejamos fuera el mecanismo para encontrar el fichero que contiene las
   definiciones de función.

   En ejemplos previos, nosotros habíamos usado esto, el fichero Info, o
   cambiamos atrás y adelante a algún otro búfer, tal como el búfer
   @f{*scratch*}.

   Encontrar un fichero es un nuevo proceso que no tenemos todavía discutido.

** Encontrar un fichero

   Para encontrar un fichero en Emacs, se usa el comando @k{C-x C-f} @%c(find-file). Este comando es casi, pero no bastante correcto para el
   problema de tamaños.

   Permita mirar el fuente para @c{find-file}:

   ..src > elisp
     (defun find-file (filename)
       "Edita el fichero FILENAME.
     Cambia a un búfer visitando el fichero FILENAME,
     creando uno si no existe ya."
       (interactive "FFind file: ")
       (switch-to-buffer (find-file-noselect filename)))
   < src..

   (La versión más reciente de la definición de función @c{find-file} permite
   comodines especiales para visitar múltiples ficheros; que hacen la
   definición más compleja y no se discutirá aquí, ya que no es relevante. Se
   pueden ver sus fuentes usando @k{M-.} @%c(find-tag) o @k{C-h f} @%c(describe-function).)

   La definición que se está mostrando posee una documentación corta, pero
   completa y una especificación interactiva que muestra un nombre de fichero
   cuando se usa el comando interactivamente. El cuerpo de la definición
   contiene dos funciones, @c{find-file-noselect} y @c{switch-to-buffer}.

   De acuerdo a su documentación como muestra por @k{C-h f} (el comando
   @c{describe-function}), la función @c{find-file-noselect} lee el fichero
   nombrado dentro de un búfer y devuelve el búfer. (Su versión más
   reciente incluye un argumento comodín, también, así como otro para leer un
   fichero literalmente y otro que suprime mensajes de aviso. Estos
   argumentos opcionales son irrelevantes.)

   Sin embargo, la función @c{find-file-noselect} no selecciona el búfer en
   el que se pone el fichero. Emacs no cambia su atención (o la tuya si estás
   usando @c{find-file-noselect}) al búfer seleccionado. Esto es lo que
   @c{switch-to-buffer} hace: eso cambia el búfer al que se dirige la
   atención de Emacs; y eso cambia el búfer mostrado en la ventana al nuevo
   búfer. Se ha discutido el búfer cambiando a otro lugar. (Vea la Seccion
   @l{Cambiando búfers}.)

   En este proyecto de histograma, no se necesita mostrar cada fichero en la
   pantalla como el programa determina el tamaño de cada definición con
   eso. En vez de emplear @c{switch-to-buffer}, se puede trabajar con
   @c{set-buffer}, que redirige la atención del programa de ordenador para un
   búfer diferente pero no lo muestra en pantalla. Así en vez llamar a
   @c{find-file} para hacer el trabajo, debe escribir nuestra expresión.

   La tarea es fácil: usar @c{find-file-noselect} y @c{set-buffer}.

** @c{lengths-list-file} en detalle

   El núcleo de la función @c{lengths-list-file} es un bucle @c{while}
   conteniendo una función para mover el punto hacia delante ‘función a
   función’ y una función para contar el número de palabras y símbolos en
   cada función. Este núcleo debe ser rodeado por funciones que hacen otras
   tareas varias, incluyendo encontrar el fichero, y asegurando que el punto
   empieza al principio del fichero. La definición de la función se parece a:

   ..src > elisp
     (defun lengths-list-file (filename)
       "Devuelve la lista de tamaños de definiciones con FILE.
     La lista devuelta es una lista de números.
     Cada número es el número de palabras o
     símbolos en una definición."
       (message "Trabajando en `%s' ... " filename)
       (save-excursion
         (let ((buffer (find-file-noselect filename))
               (lengths-list))
           (set-buffer buffer)
           (setq buffer-read-only t)
           (widen)
           (goto-char (point-min))
           (while (re-search-forward "^(defun" nil t)
             (setq lengths-list
                   (cons (count-words-in-defun) lengths-list)))
           (kill-buffer buffer)
           lengths-list)))
   < src..

   La función pasa un argumento, el nombre del fichero en el que se
   trabajará. Eso tiene cuatro líneas de documentación, pero sin
   especificación interactiva. Para evitar la preocupación de si se ha
   estropeado el programa o no, la primera línea del cuerpo es un mensaje de
   aviso.

   La siguiente línea contiene un @c{save-excursion} que devuelve a Emacs la
   atención al actual búfer cuando la función se completa. Esto es útil en
   caso de embeber esta función en otra función que presume que el punto
   restaura el búfer original.

   En la varlist de la expresión @c{let}, Emacs encuentra el fichero y ajusta
   la variable local @c{buffer} al búfer conteniendo el fichero. Al mismo
   tiempo, Emacs crea @c{lengths-list} como una variable local.

   Lo siguiente, Emacs cambia su atención al búfer.

   En la siguiente línea, Emacs crea el búfer de solo lectura. Idealmente,
   esta línea no es necesaria. Ninguna de las funciones para contar palabras
   y símbolos en una definición de función cambiaría el búfer. Debajo, el
   búfer no está yendo para ser guardado, incluso si eso fuese
   cambiado. Esta línea es enteramente la consecuencia grata, quizás excesiva
   precaución. La razón para la precaución es que esta función y esta se
   llama a trabajar en las fuentes para Emacs y eso es un inconveniente si
   están inadvertidamente modificadas. Eso va sin decir que no se realizó una
   necesidad para esta línea hasta que un experimento fué cambiado hacia un
   lado y empezó a modificar mis ficheros de fuentes Emacs …

   Lo siguiente llama a alargar el búfer si eso está encogido. Esta función
   es normalmente innecesaria––Emacs crea un búfer fresco si ninguno ya
   existe; pero si un búfer está visitando el fichero que ya existe que
   Emacs devuelve uno. En este caso, el búfer puede ser encogido y debe ser
   amplio. Si se quiere ser completamente ‘amigo del usuario’, se pondría en
   orden para guardar la restricción y la localización del punto, pero no.

   La expresión @c{(goto-char (point-min))} mueve el punto al principio del
   búfer.

   Entonces llega un bucle @c{while} en el que se devuelve el ‘trabajo’ de la
   función. En el bucle, Emacs determina el tamaño de cada definición y
   construye una lista de tamaños conteniendo la información.

   Emacs corta el búfer después de trabajar a través de eso. Esto es guardar
   espacio dentro de Emacs. Mi versión de GNU Emacs 19 contenía 300 ficheros
   fuente de interés; GNU Emacs 22 contiene a través de un millar de ficheros
   fuente. Otra función aplicará @c{lengths-list-file} a cada uno de los
   ficheros.

   Finalmente, la última expresión con la expresión @c{let} es la variable
   @c{lengths-list}; su valor es devuelto como el valor de la función
   completa.

   Se puede probar esta función instalándolo en el modo usual. Entonces
   posiciona tu cursor después de la siguiente expresión y escribe @k{C-x C-e} @%c(eval-last-sexp).

   ..src > elisp
     (lengths-list-file
      "/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el")
   < src..

   (Se puede necesitar cambiar la ruta del fichero; el único aquí es para GNU
   Emacs versión 22.1.1. Para cambiar la expresión, cópialo al búfer
   @f{*scratch*} y edítalo.

   (También, para ver el tamaño completo de la lista, en vez de una versión
   truncada se puede tener que evaluar lo siguiente:

   ..src > elisp
     (custom-set-variables '(eval-expression-print-length nil))
   < src..

   (Vea la Seccion @l{Especificar Variables usando @c{defcustom}}. Entonces
   evalúa la expresión @c{lengths-list-file}.)

   La lista de tamaños para @f{debug.el} toma menos de un segundo para
   producirse esto en GNU Emacs 22:

   ..src > elisp
     (83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
   < src..

   (Usando mi vieja máquina, la versión 19 lista tamaños para @f{debug.el}
   que en siete segundos para producen esto:

   ..src > elisp
     (75 41 80 62 20 45 44 68 45 12 34 235)
   < src..

   (La versión nueva de @f{debug.el} contiene más defuns que la temprana; y
   mi nueva máquina es más rápida que la vieja.

   Nótese que el tamaño de la última definición en el fichero es el primero
   en la lista.

** Contar palabras en @c{defuns} en diferentes ficheros

   En la sección previa, se creaba una función que devuelve una lista de los
   tamaños de cada definición en un fichero. Ahora, se quiere definir una
   función para devolver una lista maestra de los tamaños de las definiciones
   en una lista de ficheros.

   Trabajar en cada elemento de una lista de ficheros es un acto repetitivo,
   así se puede usar un bucle @c{while} o recursión.

   El diseño usando un bucle @c{while} es rutina. El argumento que se pasaba
   a la función es una lista de ficheros. Como se vió pronto (Vease Sección
   @l{Ejemplo de bucle}), se puede escribir un bucle @c{while} de un modo que
   el cuerpo del bucle es evaluado si tal lista contiene elementos, pero sale
   del bucle si la lista está vacía. Para que este diseño funcione, el cuerpo
   del bucle debe contener una expresión que ordene la lista cada vez que el
   cuerpo es evaluado, de modo que finalmente la lista esté vacía. La técnica
   normal es asignar el valor de la lista para el valor del @c{cdr} de la
   lista cada vez que el cuerpo es evaluado.

   La plantilla se ve así:

   ..src > elisp
     (while test-whether-list-is-empty
       body…
       set-list-to-cdr-of-list)
   < src..

   También, recuérdanos que un bucle @c{while} devuelve @c{nil} (el resultado
   de evaluar el prueba-verdadero-o-falso), no el resultado de cualquier evaluación
   con su cuerpo. (Las evaluaciones con el cuerpo del bucle son hechas para
   sus efectos secundarios.) Sin embargo, la expresión que asigna la lista de
   tamaños es parte del cuerpo––y que es el valor que queremos devuelto por
   la función como un todo. Para hacer esto cerramos el bucle @c{while} con
   una expresión @c{let}, y pone en orden que el último elemento de la
   expresión @c{let} contiene el valor de lista de tamaños. (Vea la Seccion
   @l{Ejemplo de Incremento, , El Ejemplo del Bucle con un Contador de
   Incremento}.)

   Estas consideraciones lideran directamente a la función en sí:

   ..src > elisp
     ;;; @e{Usar bucle @c{while}.}
     (defun lengths-list-many-files (list-of-files)
       "Devuelve la lista de tamaños de funciones en LIST-OF-FILES."
       (let (lengths-list)

     ;;; prueba-verdadero-o-falso
         (while list-of-files
           (setq lengths-list
                 (append
                  lengths-list

     ;;; Genera una lista de tamaños.
                  (lengths-list-file
                   (expand-file-name (car list-of-files)))))

     ;;; Crea una lista ordenada de ficheros.
           (setq list-of-files (cdr list-of-files)))

     ;;; Devuelve la lista final de valores de tamaños.
         lengths-list))
   < src..

   @c{expand-file-name} es una función construida que convierte un nombre de
   fichero al absoluto, forma de nombre de ruta. La función emplea el nombre
   del directorio en el que la función se llama.

   De este modo, si @c{expand-file-name} es llamado en @c{debug.el} cuando
   Emacs está visitando el directorio
   @f{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/}

   ..example >
     debug.el
   < example..

   llega a ser

   ..example >
     /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
   < example..

   El único nuevo elemento de esta definición de función es la todavía no
   estudiada función @c{append}, que merece una corta sección en sí.

*** La función @c{append}

    La función @c{append} adjunta una lista a otra. De este modo,

    ..src > elisp
      (append '(1 2 3 4) '(5 6 7 8))
    < src..

    produce la lista

    ..src > elisp
      (1 2 3 4 5 6 7 8)
    < src..

    Esto es exactamente cómo queremos adjuntar dos listas de tamaños
    producidas por @c{lengths-list-file} a cualquier otra. Los resultados
    contrastan con @c{cons},

    ..src > elisp
      (cons '(1 2 3 4) '(5 6 7 8))
    < src..

    que construye una nueva lista en el que el primer argumento para @c{cons}
    llega a ser el primer elemento de la nueva lista:

    ..src > elisp
      ((1 2 3 4) 5 6 7 8)
    < src..

** Recursivamente cuenta palabras en diferentes ficheros

   Bajo un bucle @c{while}, se puede trabajar cada lista de ficheros con
   recursión. Una versión recursiva de @c{lengths-list-many-files} es corta y
   simple.

   La función recursiva tiene las partes normales: el ‘prueba-hazlo-de-nuevo’, la
   ‘expresion-del-siguiente-paso’, y la llamada recursiva. El ‘prueba-hazlo-de-nuevo’
   determina si la función se llamaría, que hará si la @c{list-of-files}
   contiene los elementos que permanecen; la ‘expresion-del-siguiente-paso’ resetea
   el @c{list-of-files} al @c{cdr} en sí, así finalmente la lista será
   vacía; y la llamada recursiva llama en sí a la lista ordenada. ¡La función
   completa está ordenada por esta descripción!

   ..src > elisp
     (defun recursive-lengths-list-many-files (list-of-files)
       "Devuelve la lista de tamaños de cada defun en LIST-OF-FILES."
       (if list-of-files                     ; prueba-hazlo-de-nuevo
           (append
            (lengths-list-file
             (expand-file-name (car list-of-files)))
            (recursive-lengths-list-many-files
             (cdr list-of-files)))))
   < src..

   En una frase, la función devuelve de tamaños de la lista para la el
   primero de la @c{list-of-files} al resultado de llamarse así mismo al
   resto de @c{list-of-files}.

   Aquí hay un test @c{recursive-lengths-list-many-files}, a lo largo de los
   resultados de ejecutar @c{lengths-list-file} en cada uno de los ficheros
   individualmente.

   Instala @c{recursive-lengths-list-many-files} y @c{lengths-list-file}, si
   es necesario, y entonces evalúa las siguientes expresiones. Se puede
   necesitar cambiar las rutas de ficheros; aquí se trabaja cuando este
   fichero Info y las fuentes de Emacs están localizadas en sus lugares
   personales. Para cambiar las expresiones, cópialas al búfer
   @f{*scratch*}, edítalos y entonces evalúalos.

   Los resultados son mostrados después del @'{⇒}. (Estos resultados son para
   ficheros de Emacs versión 22.1.1; ficheros desde otras versiones de Emacs
   puede producir diferentes resultados.)

   ..src > elisp
     (cd "/usr/local/share/emacs/22.1.1/")

     (lengths-list-file "./lisp/macros.el")
          ⇒ (283 263 480 90)

     (lengths-list-file "./lisp/mail/mailalias.el")
          ⇒ (38 32 29 95 178 180 321 218 324)

     (lengths-list-file "./lisp/makesum.el")
          ⇒ (85 181)

       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mail/mailalias.el"
          "./lisp/makesum.el"))
            ⇒ (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)
   < src..

   La función @c{recursive-lengths-list-many-files} produce la salida que
   queremos.

   El siguiente paso es preparar el dato en la lista para mostrarlo en un
   grafo.

** Preparar los datos para mostrarlos en un grafo

   La función @c{recursive-lengths-list-many-files} devuelve una lista de
   números. Cada número graba el tamaño de una definición de función. Lo que
   se necesita hacer ahora es transformar estos datos dentro de una lista de
   números ajustado para generar un grafo. La nueva lista contará cuántas
   definiciones de funciones contienen menos de 10 palabras y símbolos,
   cuantas contienen entre 10 y 19 palabras y símbolos, cuántas contienen
   entre 20 y 29 palabras y símbolos, y así sucesivamente.

   En breve, se necesita ir a través el tamaño de la lista producida por la
   función @c{recursive-lengths-list-many-files} y contar el número de defuns
   con cada rango de tamaños, y produce una lista de esto de números.

   Basado en lo que hemos hecho antes, se prevee que no sería difícil
   escribir una función que ‘@c{cdr}s’ bajo la lista de tamaños, parece que
   cada elemento, determina que rango de tamaños está dentro, e incrementa un
   contador para este rango.

   Sin embargo, antes de empezar a escribir tal función, nosotros
   consideraríamos las ventajas de ordenar los tamaños de la lista primero,
   así los números son ordenados desde el más pequeño al más largo. Primero,
   ordenando se hará fácil contar los números en cada rango, desde dos
   números adyacentes será el mismo rango del tamaño en rangos
   adyacentes. Segundo, inspeccionando una lista ordenada, se puede descubrir
   el número mayor y menor, y esto significa determinar el rango de tamaño
   mayor y menor que necesitará.

*** Ordenando listas

    Emacs contiene una función para listas ordenadas, llamadas (como se
    podría adivinar) @c{sort}. La función @c{sort} toma dos argumentos, la
    lista es ordenada, y un predicado que determina si la primera de dos
    elementos de lista es “menor” que la segunda.

    Como se vió antes (Vease Sección @"{Usando el Tipo Incorrecto de Objeto
    como un Argumento}), un predicado es una función que determina si alguna
    propiedad es verdadera o falsa. La función @c{sort} reordenará una lista
    de acuerdo a lo que la propiedad del predicado usa; esto significa que
    @c{sort} puede ser usado para ordenar listas no numéricas por un criterio
    no numérico --- eso puede, por ejemplo, alfabetizar una lista.

    La función @c{<} se usa cuando se ordena una lista numérica. Por ejemplo,

    ..src > elisp
      (sort '(4 8 21 17 33 7 21 7) '<)
    < src..

    produce esto:

    ..src > elisp
      (4 7 7 8 17 21 21 33)
    < src..

    (Note que en este ejemplo, ambos argumentos se citan así que los símbolos
    no se evalúan antes de ser pasados por @c{sort} como argumentos.)

    Ordenando la lista devuelta por la función
    @c{recursive-lengths-list-many-files} es honesta; eso usa la función
    @c{<}:

    ..src > elisp
      (sort
       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mailalias.el"
          "./lisp/makesum.el"))
       '<)
    < src..

    que produce:

    ..src > elisp
      (29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)
    < src..

    (Note que en este ejemplo, el primer argumento para @c{sort} no está
    citado, desde que la expresión debe ser evaluado así como producir la
    lista que es pasada para @c{sort}.)

*** Creando una lista de ficheros

    La función @c{recursive-lengths-list-many-files} requiere una lista de
    fichero como argumento. Para nuestros ejemplos de test, se construyeron
    tal como una lista a mano; pero el directorio fuente de Emacs Lisp es
    demasiado grande para hacer esto. Así, se escribirá una función para
    hacer el trabajo. En esta función, se usa tanto un bucle @c{while} como
    una llamada recursiva.

    En viejas versiones de GNU Emacs no hizo falta tener que escribir esta
    función, puesto que todos los ficheros @'{.el} en un directorio. En vez
    de eso, se puede ser capaz de usar la función @c{directory-files}, que
    lista los nombres de fichero que hay en un directorio simple.

    Sin embargo, las versiones reciente Emacs emplazan ficheros de Emacs Lisp
    en subdirectorios del directorio de alto nivel @f{lisp}. Esto facilita la
    navegación. Por ejemplo, todos los ficheros de correo relacionados que
    están en el subdirectorio llamado @f{mail}. Pero al mismo tiempo, esta
    facilidad fuerza a crear un fichero listando la función que desciende
    dentro de los subdirectorios.

    Se puede crear esta función, llamada @c{files-en-below-directory}, usando
    funciones familiares tales como @c{car}, @c{nthcdr}, y @c{substring} en
    conjunción con una función existente llamada
    @c{directory-files-and-attributes}. Esta última función no solo listas de
    ficheros en un directorio, incluyendo los nombres de subdirectorios, pero
    también sus atributos.

    Para empezar nuestro objetivo: crear una función que nos permita
    alimentas ficheros a @c{recursive-lengths-list-many-files} como una lista
    que se parece a esto (pero con más elementos):

    ..src > elisp
      ("./lisp/macros.el"
       "./lisp/mail/rmail.el"
       "./lisp/makesum.el")
    < src..

    La función @c{directory-files-and-attributes} devuelve una lista de
    listas. Cada una de las listas con la lista principal consiste de 13
    elementos. El primer elemento es una cadena que contiene el nombre del
    fichero––que, en GNU/Linux, puede ser un ‘directorio fichero’, que dice,
    un fichero con los atributos especiales de un directorio. El segundo
    elemento de la lista es @c{t} para un directorio, es una cadena para el
    enlace simbólico (la cadena es el nombre enlazado), o @c{nil}.

    Por ejemplo, el primer fichero @'{.el} en el directorio es
    @f{abbrev.el}. Su nombre es
    @f{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} y no es un directorio o
    un enlace simbólico.

    Esto es cómo @c{directory-files-and-attributes} lista este fichero y sus
    atributos:

    ..src > elisp
      ("abbrev.el"
      nil
      1
      1000
      100
      (20615 27034 579989 697000)
      (17905 55681 0 0)
      (20615 26327 734791 805000)
      13188
      "-rw-r--r--"
      nil
      2971624
      773)
    < src..

    Por otro lado, @f{mail/} es un directorio con el directorio @f{lisp/}. El
    principio del listado se parece a esto:

    ..src > elisp
      ("mail"
      t
      …
      )
    < src..

    (Para aprender acerca de los diferentes atributos, mira en la
    documentación de @c{file-attributes}. Tenga en mente que la función
    @c{file-attributes} no lista el nombre del fichero, así su primer
    elemento es @c{directory-files-and-attributes} que es el segundo
    elemento.)

    Se querrán nuestras nuevas funciones, @c{files-in-below-directory}, para
    listar los fichero @'{.el} en el directorio eso es contado para probar,
    y en los directorios bajo este directorio.

    Esto nos da una sugestión de como construir @c{files-in-below-directory}:
    con un directorio, la función añadir los nombres de ficheros @'{.el} a
    una lista; y si, con un directorio, la función viene con un
    subdirectorio, iría dentro de este subdirectorio y repite sus acciones.

    Sin embargo, nosotros notaríamos que cada directorio contiene un nombre
    que se refiere a sí mismo, llamado @f{.}, (“dot”) y un nombre que se
    refiere a su directorio padre, llamado @f{..} (“doble punto”). (En @f{/},
    el directorio raíz, @f{..} se refiere así mismo, desde que @f{/} no tiene
    padre.) Claramente, no que se quiere nuestra función
    @c{files-in-below-directory} para introducir estos directorio, desde que
    ellos siempre nos lideran, directamente o indirectamente, al directorio
    actual.

    Consecuentemente, nuestra función @c{files-in-below-directory} debe hacer
    varias tareas:

    - Chequee para ver si se está mirando en un nombre de fichero que
      finaliza en @'{.el} y si es así, se añade el nombre a una lista.

    - Chequee para ver si está mirando en un nombre de fichero que es el
      nombre de un directorio; y si es así,

      - Chequee para ver si está mirando en @f{.} o @f{..}; y si es así sal.


      - O además, ve dentro de este directorio y repite el proceso.


    Se permite escribir una definición de función para hacer estas tareas. Se
    usará un bucle @c{while} para mover de un nombre de fichero a otro con un
    directorio chequeando lo que necesita ser hecho; y se usa una llamada
    recursiva para repetir las acciones en cada subdirectorio. El patrón
    recursivo es ‘acumular’ (Vease Sección @l{Patrón recursivo:
    @e{accumulate}}) usando @c{append} para combinar.

    Aquí está la función:

    ..src > elisp
      (defun files-in-below-directory (directory)
        "Lista los ficheros .el en DIRECTORIO y en sus subdirectorios."
        ;; Aunque la función será usada no interactivamente,
        ;; será fácil probar si lo hacemos interactivo.
        ;; El directorio tendrá un nombre tal como
        ;;  "/usr/local/share/emacs/22.1.1/lisp/"
        (interactive "DNombre del Directorio: ")
        (let (el-files-list
              (current-directory-list
               (directory-files-and-attributes directory t)))
          ;; mientras estamos en el directorio actual
          (while current-directory-list
            (cond
             ;; chequee para ver si el nombre del fichero finaliza en ‘.el’
             ;; y si es así, añade su nombre a una lista.
             ((equal ".el" (substring (car (car current-directory-list)) -3))
              (setq el-files-list
                    (cons (car (car current-directory-list)) el-files-list)))
             ;; chequee si el nombre del fichero es un directorio
             ((eq t (car (cdr (car current-directory-list))))
              ;; decide si salir o hacer recursión
              (if
                  (equal "."
                         (substring (car (car current-directory-list)) -1))
                  ;; entonces no hagas nada puesto que el nombre del fichero es
                  ;; el actual directorio o padre, "." o ".."
                  ()
                ;; else desciende dentro del directorio y repite el proceso
                (setq el-files-list
                      (append
                       (files-in-below-directory
                        (car (car current-directory-list)))
                       el-files-list)))))
            ;; mueve al siguiente fichero en la lista; esto también
            ;; ordena la lista así mientras el bucle
            ;; eventualmente llega a un fin
            (setq current-directory-list (cdr current-directory-list)))
          ;; devuelve los ficheros
          el-files-list))
    < src..

    Las funciones @c{files-in-below-directory} @c{directory-files} toma un
    argumento, el nombre de un directorio.

    De este modo, en mi sistema,

    ..src > elisp
      (length
       (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
    < src..

    se cuenta que dentro y debajo de mi directorio de fuentes Lisp hay 1031
    ficheros @'{.el}

    @c{files-in-below-directory} devuelve una lista en orden alfabético
    inverso. Una expresión para ordenar la lista en orden que parece como
    este:

    ..src > elisp
      (sort
       (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
       'string-lessp)
    < src..

*** Contando definiciones de función

    Nuestro objetivo inmediato es generar una lista que cuenta, cuantas
    definiciones de funciones contienen menos de 10 palabras y símbolos,
    cuantas contienen entre 10 y 19 palabras y símbolos, cuantas contienen
    entre 20 y 29 palabras y símbolos, y así sucesivamente.

    Con una lista ordenada de números, es fácil: se cuentan cuantos elementos
    de la lista son más pequeños de 10, entonces, se devuelven los números
    contados, se cuenta cuantos son más pequeños de 20, entonces se devuelven
    los números contados, después se cuentan los que son más pequeños de 30,
    y así sucesivamente. Cada uno de los números, 10, 20, 30, 40, y como, es más grande que
    el tope de este rango. Se puede llamar a la lista de tales números, la
    lista @c{top-of-ranges}.

    Si se desea, se podría generar esta lista automáticamente, pero es más
    simple escribir una lista manualmente. Aquí está:

    ..src > elisp
      (defvar top-of-ranges
       '(10  20  30  40  50
         60  70  80  90 100
        110 120 130 140 150
        160 170 180 190 200
        210 220 230 240 250
        260 270 280 290 300)
       "Listar especificando rangos para ‘defuns-per-range’.")
    < src..

    Para cambiar los rangos, se edita esta lista.

    Lo siguiente, que se necesita es escribir la función que crea la lista
    del número de definiciones con cada rango. Claramente, esta función debe
    tomar el @c{sorted-lengths} y las listas @c{top-of-ranges} listas como
    argumentos.

    La función @c{defuns-per-range} debe hacer dos cosas una y otra vez: eso
    debe contar el número de definiciones con un rango específico por el
    actual valor top-of-range; y eso debe dividir al siguiente gran valor en
    la lista @c{top-of-ranges} después de contar el número de definiciones en
    el rango actual. Desde que cada una de estas acciones es repetitiva, se
    puede usar los bucles @c{while} para el trabajo. Un bucle cuenta el
    número de definiciones en el rango definido por el valor actual
    top-of-range, y el otro bucle selecciona cada uno de los valores
    top-of-range en turno.

    Varias entradas de la lista @c{sorted-lengths} se cuentan para cada
    rango; esto significa que el bucle para la lista @c{sorted-lengths} será
    dentro del bucle para la lista @c{top-of-ranges}, como un pequeño adorno
    dentro de un gran adorno.

    El bucle interno cuenta el número de definiciones con el rango. Eso es un
    simple contaje del tipo en el que se ha visto antes. (Vea la Seccion @l{Un
    bucle con un contaje incremental}). La prueba true-or-false del bucle
    chequea si el valor desde la lista @c{sorted-lengths} es más pequeña que
    el actual valor de lo alto del rango. Si es así, la función incrementa el
    contador y se chequea el siguiente valor desde la lista
    @c{sorted-lengths}.

    El bucle interno se parece a esto:

    ..src > elisp
      (while length-element-smaller-than-top-of-range
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
    < src..

    El bucle de fuera debe empezar con el valor más bajo de la lista
    @c{top-of-ranges}, y entonces se asigna a cada uno de los valores
    superiores exitosos a su vez. Esto puede ser hecho con un bucle como
    este:

    ..src > elisp
      (while top-of-ranges
        body-of-loop…
        (setq top-of-ranges (cdr top-of-ranges)))
    < src..

    Se ponen juntos, los dos bucles como este:

    ..src > elisp
      (while top-of-ranges

        ;; Contar el número de elementos con el actual rango.
        (while length-element-smaller-than-top-of-range
          (setq number-within-range (1+ number-within-range))
          (setq sorted-lengths (cdr sorted-lengths)))

        ;; Mover al siguiente rango.
        (setq top-of-ranges (cdr top-of-ranges)))
    < src..

    Además, en cada circuito del bucle exterior, Emacs grabaría el número de
    definiciones con este rango (el valor de @c{number-within-range}) en una
    lista. Se puede usar @c{cons} para este propósito. (Vea la Seccion
    @l{@c{cons}}.)

    La función @c{cons} trabaja bien, excepto que la lista que se construye
    contendrá el número de definiciones para el alto rango y su principio el
    número de definiciones para el más bajo rango a su fin. Esto es porque
    @c{cons} adjunta nuevos elementos de la lista al principio de la lista, y
    desde los dos bucles que hacen cálculos a través de la lista de tamaños
    desde lo bajo finaliza primero, el @c{defuns-per-range-list} finalizará
    el primer número más largo. Pero lo que se quiere es imprimir nuestro
    grafo con pequeños valores primero y el más grande después. La solución
    es invertir el orden del @c{defuns-per-range-list}. Nosotros podemos
    hacer esto usando la función @c{nreverse}, que invierte el orden de una
    lista.

    Por ejemplo,

    ..src > elisp
      (nreverse '(1 2 3 4))
    < src..

    produce:

    ..src > elisp
      (4 3 2 1)
    < src..

    Note que la función @c{nreverse} es “destructiva”––que es, cambiar la
    lista a la que se aplica; esto contrasta con las funciones @c{car} y
    @c{cdr}, que no son destructivas. En este caso, no se quiere que el
    original @c{defuns-per-range-list}, de manera que no hay materia que se
    destruya. (La función @c{reverse} provee un copia inversa de una lista,
    dejando la lista original como es.)

    Pon todo junto, el @c{defuns-per-range} se parece a esto:

    ..src > elisp
      (defun defuns-per-range (sorted-lengths top-of-ranges)
        "funciones de SORTED-LENGTHS en cada rango TOP-OF-RANGES."
        (let ((top-of-range (car top-of-ranges))
              (number-within-range 0)
              defuns-per-range-list)

          ;; Bucle Exterior.
          (while top-of-ranges

            ;; Bucle Interno.
            (while (and
                    ;; Necesita el número para la prueba numérico.
                    (car sorted-lengths)
                    (< (car sorted-lengths) top-of-range))

              ;; Contar número de definiciones con el rango actual.
              (setq number-within-range (1+ number-within-range))
              (setq sorted-lengths (cdr sorted-lengths)))

            ;; Sal del bucle interno pero permanece con el bucle externo.

            (setq defuns-per-range-list
                  (cons number-within-range defuns-per-range-list))
            (setq number-within-range 0)      ; Resetear el contaje a cero.

            ;; Mover al siguiente rango.
            (setq top-of-ranges (cdr top-of-ranges))
            ;; Especifica el siguiente mejor rango de valores.
            (setq top-of-range (car top-of-ranges)))

          ;; Salir del bucle externo y contar el número de defuns más
          ;; largas que
          ;; el valor más largo del valor top-of-range.
          (setq defuns-per-range-list
                (cons
                 (length sorted-lengths)
                 defuns-per-range-list))

          ;; Devuelve una lista del número de definiciones con cada rango,
          ;;  del más pequeño al más largo.
          (nreverse defuns-per-range-list)))
    < src..

    La función es simple excepto para una pequeña funcionalidad. La prueba
    verdadero-o-falso para el bucle interno se parece a esto:

    ..src > elisp
      (and (car sorted-lengths)
           (< (car sorted-lengths) top-of-range))
    < src..

    en vez de algo como esto:

    ..src > elisp
      (< (car sorted-lengths) top-of-range)
    < src..

    El propósito del test es determinar si el primer ítem en la lista
    @c{sorted-lengths} es menor que el valor de lo mejor del rango.

    La versión simple del test trabaja bien a menos que la lista
    @c{sorted-lengths} tiene un valor @c{nil}. En este caso, la expresión
    @c{(car sorted-lengths)} devuelve @c{nil}. La función @c{<} no se puede
    compara un número a @c{nil}, que es una lista vacía, así Emacs señala un
    error y para la función desde el intento de continuar la ejecución.

    La lista @c{sorted-lengths} siempre llega a ser @c{nil} cuando el
    contador logra el fin de la lista. Esto significa que cualquier intento
    de usar la función @c{defuns-per-range} con la versión simple del test
    fallará.

    Se resuelve el problema usando @c{(car sorted-lengths)} en conjunción con
    la expresión @c{and}. La expresión @c{(car sorted-lengths)} devuelve un
    valor no @c{nil} tan largo como la lista que tiene al menos un número con
    eso, pero devuelve @c{nil} si la lista está vacía. La expresión @c{and}
    primero evalúa el @c{(car sorted-lengths)}, y si eso es @c{nil}, devuelve
    falso @e{sin} evaluar la expresión @c{<} y devuelve este valor como el
    valor de la expresión @c{and}.

    Este camino, evita un error.  (Para información acerca de @c{and}, ver
    @l{La función @c{kill-new}}

    Aquí hay un pequeño test de la función @c{defuns-per-range}. Primero,
    evalúa la expresión que ajusta (una resumida) lista @c{top-of-ranges} a
    la lista de valores, entonces evalúa la expresión para ajustar la lista
    @c{sorted-lengths}, y entonces evalúa la función @c{defuns-per-range}.

    ..src > elisp
      ;; (La lista ordenada que usará después.)
      (setq top-of-ranges
       '(110 120 130 140 150
         160 170 180 190 200))

      (setq sorted-lengths
            '(85 86 110 116 122 129 154 176 179 200 265 300 300))

      (defuns-per-range sorted-lengths top-of-ranges)
    < src..

    La lista devuelta se parece a esto:

    ..src > elisp
      (2 2 2 0 0 1 0 2 0 0 4)
    < src..

    Dentro, hay dos elementos de la lista @c{sorted-lengths} menores de 110,
    dos elementos entre 110 y 119, dos elementos entre 120 y 129 y así sucesivamente. Hay
    cuatro elementos con un valor de 200 o superior.

* Leyendo un grafo

  Nuestro objetivo es construir un grafo mostrando los números de
  definiciones de función de varios tamaños en las fuentes de Emacs lisp.

  Como una materia práctica, si se estuviese creando un grafo, probablemente
  usarías un programa tal como @c{gnuplot} para hacer el
  trabajo. (@c{gnuplot} está bien integrado dentro de GNU Emacs.) En este
  caso, sin embargo, creamos uno desde cero, y en el proceso lo reconstruimos
  nosotros mismos con algo de lo que se aprende antes y así poder aprender
  más.

  En este capítulo, primero se escribe un grafo simple imprimiendo la
  función. Esta primera definición será un @:{prototipo}, una función escrita
  rápidamente nos permite reconocer este territorio de crear un grafo. Se
  descubren dragones, o resulta que son mitos. Después de olisquear el
  terreno, nos sentiremos más confidentes y mejoraremos la función para
  etiquetar las coordenadas automáticamente.

  Puesto que Emacs está diseñado para ser flexible y trabajar con todo tipo
  de terminales, incluyendo los terminales de caracteres, el grafo necesitará
  ser hecho desde símbolos de ‘escritura’. Un asterisco hará; como nosotros
  mejoramos la función de impresión del grafo, se puede crear la elección del
  símbolo como una opción de usuario.

  Se puede llamar a esta función @c{graph-body-print}; se tomará un
  @c{numbers-list} como su único argumento. En esta fase, no se etiquetará el
  grafo, pero se imprime su cuerpo.

  La función @c{graph-body-print} inserta una columna vertical de asteriscos
  para cada elemento en la lista @c{numbers-list}. La altura de cada línea
  está determinada por el valor de este elemento de la @c{numbers-list}.

  Insertar columnas es un acto repetitivo; que significa que esta función
  debe ser escrita con un bucle @c{while} o recursivamente.

  Nuestro primer reto es descubrir como imprimir una columna de
  asteriscos. Normalmente, en Emacs, se imprimen caracteres dentro de una
  pantalla horizontalmente, línea a línea, escribiendo. Se tienen dos rutas
  que se pueden seguir: escribir nuestra función column-insertion o descubrir
  si una que exista en Emacs.

  Para ver si hay uno en Emacs, se puede usar el comando @k{M-x
  apropos}. Este comando es como el comando @k{C-h a} @%c(command-apropos),
  excepto que último encuentra solo estas funciones que son comandos. El
  comando @k{M-x apropos} lista todos los símbolos que se asocian a una
  expresión regular, incluyendo funciones que no son interactivas.

  Lo que se quiere buscar es algún comando que imprima o inserte
  columnas. Muy probablemente, el nombre de la función contendrá la palabra
  ‘print’ o la palabra ‘insert’ o la palabra ‘column’. Por esta razón,
  podemos simplemente escribir @k{M-x apropos RET print \|insert\|column RET}
  y se ve el resultado. En mi sistema, este comando toma todavía algún
  tiempo, y entonces se produce una lista de 79 funciones y variables. Ahora
  no se tarda mucho y se produce una lista de 211 funciones y
  variables. Escaneando la lista, la única función que se ve como si se
  pudiera hacer el trabajo que es @c{insert-rectangle}.

  En realidad, esta es la función que queremos; su documentación dice:

  ..example >
    insert-rectangle:
    Insertar texto de RECTANGLE con la esquina izquierda a punto
    La primera línea de RECTANGLE es insertada al punto
    su segunda línea es insertada a un punto verticalmente
    bajo el punto, etc.
    El RECTANGLE debería ser una lista de cadenas.
    Después de este comando, la marca está en la esquina izquierda
    superior y el punto en la esquina derecha inferior.
  < example..

  Se puede ejecutar un test rápido, para asegurar que hace lo que se espera
  de eso.

  Aquí está el resultado de emplazar el cursor después de la expresión
  @c{insert-rectangle} y escribiendo @k{C-u C-x C-e} @%c(eval-last-sexp). La
  función inserta las cadenas @'{"primero"}, @'{"segundo"}, y @'{"tercero"}
  en el punto. También la función devuelve @c{nil}.

  ..src > elisp
    (insert-rectangle '("primero" "segundo" "tercer"))primero
                                                  segundo
                                                  terceronil
  < src..

  De acuerdo, no se inserta el texto de la expresión @c{insert-rectangle} en
  sí dentro del búfer en el que se marca el grafo, pero se llamará la
  función de nuestro programa. Nosotros, sin embargo, tenemos que asegurar
  que el punto está en el búfer en el lugar donde la función
  @c{insert-rectangle} insertará la columna de cadenas.

  Si se está leyendo esto en Info, se puede ver como este trabajo cambia a
  otro búfer, tal como el búfer @f{*scratch*}, emplazando el punto a algún
  lugar en el búfer, se escribe @k{M::}, después se escribe la expresión
  @c{insert-rectangle} dentro del minibúfer en la consola, y entonces se
  escribe @k{RET}. Esto causa que Emacs evalúe la expresión en el minibúfer,
  pero usa como el valor del punto la posición del punto en el búfer
  @f{*scratch*}. (@k{M::} es el atajo para @c{eval-expression}. @c{nil}
  tampoco aparece en el búfer @f{*scratch*} desde que la expresión se evalúa
  en el minibúfer.)

  Se encuentra cuando hacer esto hasta el punto que finaliza al fin de la
  última línea insertada––es decir, esta función mueve el punto como un
  efecto secundario. Si se iba a repetir el comando, con el punto en esta
  posición, la siguiente inserción sería debajo y a la derecha de la
  inserción previa. ¡Nosotros no queremos esto!. Si se está yendo a crear un
  gráfico de barras, las columnas necesitan estar debajo unas de otras.

  Así se descubre que cada ciclo del bucle @c{while} de column-inserting debe
  reposicionar el punto al lugar que queremos, y este lugar estará arriba, no
  abajo, de la columna. Más allá, se recuerda que cuando se imprime un grafo,
  no esperan todas las columnas para estar a la misma altura. Esto significa
  que el alto de cada columna puede estar a una altura diferente desde una
  previa. Nosotros simplemente reposicionamos el punto a la misma línea cada
  vez, pero movido cubriendo a la derecha––o quizás se puede …

  Estamos planeando crear las columnas de la barra gráfica sin asteriscos. El
  número de asteriscos en la columna es el número específico por el elemento
  actual del @c{numbers-list}. Necesitamos construir una lista de asteriscos
  del tamaño derecho para cada llamada a @c{insert-rectangle}. Si esta lista
  consiste únicamente del número requerido de asteriscos, entonces tendremos
  la posición de punto el número correcto de líneas bajo la base del gráfico
  para imprimirse correctamente. Esto podría ser difícil.

  Alternativamente, si podemos figurarnos algún camino para pasar
  @c{insert-rectangle} del mismo tamaño cada vez, entonces podemos posicionar
  el punto en la misma línea cada vez, pero se mueve a través de una columna
  a la derecha por cada nueva columna. Si hacemos esto, sin embargo, alguna
  de las entradas en la lista pasaba a @c{insert-rectangle} y deben ser
  espacios en blanco en vez de asteriscos. Por ejemplo, si la altura máxima
  del grafo es 5, pero la altura de la columna es 3, entonces
  @c{insert-rectangle} requiere un argumento que se parezca a esto:

  ..src > elisp
    (" " " " "*" "*" "*")
  < src..

  Esta última propuesta no es tan difícil, de hecho se puede determinar la
  altura de la columna. Hay dos caminos para nosotros especificar la altura
  de la columna: se puede arbitrariamente situar lo que será, lo que
  funcionaría bien para gráficas de esta altura; o podemos buscar a través de
  la lista de números y usar la altura máxima de la lista como la altura
  máxima del grafo. Si la última operación fuera difícil, entonces el
  procedimiento formal sería fácil, pero hay una función construida en Emacs
  para determinar el máximo de sus argumentos. Se puede usar esta función. La
  función se llamaba @c{max} y eso devuelve el mayor de sus argumentos, que
  deben ser números. De este modo, por ejemplo,

  ..src > elisp
    (max  3 4 6 5 7 3)
  < src..

  devuelve 7. (Una función correspondiente llamada @c{min} devuelve lo más
  pequeño de todos sus argumentos.)

  Sin embargo, no podemos simplemente llama a @c{max} en el @c{numbers-list};
  la función @c{max} espera números como sus argumentos, no una lista de
  números. De este modo, la siguiente expresión,

  ..src > elisp
    (max  '(3 4 6 5 7 3))
  < src..

  produce el siguiente mensaje error;

  ..example >
    Mal tipo de argumento: number-or-marker-p, (3 4 6 5 7 3)
  < example..

  Se necesita una función que pasa una lista de argumentos a una
  función. Esta función es @c{apply}. Esta función ‘aplica’ su primer
  argumento (una función) para los argumentos que permanecen, el último puede
  ser una lista.

  Por ejemplo,

  ..src > elisp
    (apply 'max 3 4 7 3 '(4 8 5))
  < src..

  devuelve 8

  (Incidentalmente, yo no sabría cómo aprender acerca de esta función sin un
  libro tal como este. Eso es posible descubrir otras funciones, como
  @c{search-forward} o @c{insert-rectangle}, adivinando una parte de sus
  nombres y entonces usando @c{apropos}. Incluso aunque su base metafórica es
  clara––‘apply’ su primer argumento al resto––dudo que un novicio vendría
  con esta palabra particular usando @c{apropos} u otra ayuda. De acuerdo,
  podría ser incorrecto; después de todo, la función fué primero llamada por
  alguien quien lo había inventado.

  El segundo y subsiguientes argumentos para @c{apply} son opcionales, así se
  puede usar @c{apply} para llamar a una función y pasan los elementos de una
  lista, como este, que también devuelve 8:

  ..src > elisp
    (apply 'max '(4 8 5))
  < src..

  Este camino tardío usará @c{apply}. La función
  @c{recursive-lengths-list-many-files} devuelve una lista de números que se
  puede aplicar a @c{max} (se podría también aplicar @e{(hacer apply)} a la
  lista de números ordenados; eso no importa si la lista está o no).

  Aquí, la operación para encontrar el tamaño máximo del grafo es este:

  ..src > elisp
    (setq max-graph-height (apply 'max numbers-list))
  < src..

  Ahora se puede devolver la pregunta de como crear una lista de cadenas para
  una columna del grafo. Cuenta la máxima altura del grafo y el número de
  asteriscos que aparecerían en la columna, la función devolverá una lista de
  cadenas para el comando a insertar @c{insert-rectangle}.

  Cada columna se realiza con asteriscos o espacios en blanco. Puesto que la
  función pasa el valor del alto de la columna y el número de asteriscos en
  el columna, el número de espacios en blanco puede ser encontrado
  sustrayendo el número de asteriscos desde lo alto de la columna. Dado el
  número de espacios en blanco y el número de asteriscos, dos bucles
  @c{while} puede ser usado para construir la lista:

  ..src > elisp
    ;;; Primera versión.
    (defun column-of-graph (max-graph-height actual-height)
      "Devuelve la lista de cadenas que una columna de un grafo."
      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))

        ;; Llenar asteriscos.
        (while (> actual-height 0)
          (setq insert-list (cons "*" insert-list))
          (setq actual-height (1- actual-height)))

        ;; Rellena espacios en blanco.
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons " " insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))

        ;; Devuelve la lista completa.
        insert-list))
  < src..

  Si se instala esta función y entonces evalúa la siguiente expresión se verá
  que devuelve la lista como se desea:

  ..src > elisp
    (column-of-graph 5 3)
  < src..

  devuelve

  ..src > elisp
    (" " " " "*" "*" "*")
  < src..

  Como está escrito, @c{column-of-graph} contiene una grieta mayor: los
  símbolos usados para el espacio en blanco para las entradas marcadas en la
  columna son ‘codificadas duras’ como un espacio y un asterisco. Esto está
  bien para un prototipo, pero tu, u otro usuario, puede desear usar otros
  símbolos. Por ejemplo, chequeando la función grafo, tu quieres usar un
  periodo en vez del espacio, asegura el punto que está siendo recolocando
  apropiadamente cada vez que la función @c{insert-rectangle} se llama; o se
  podría querer sustituir un signo @'{+} u otro símbolo para el asterisco. Se
  podría incluso querer hacer un graph-column que es más que un ancho de
  columna. El programa debería ser más flexible. El camino para hacer esto es
  reemplazar el espacio en blanco y el asterisco con dos variables que se
  puede llamar @c{graph-blank} y @c{graph-symbol} y define estas variables
  separadamente.

  También la documentación no está escrita. Estas consideraciones nos llevan
  también a la segunda versión de la función:

  ..src > elisp
    (defvar graph-symbol "*"
      "Cadena usada como símbolo en grafo, normalmente un asterisco.")

    (defvar graph-blank " "
      "La cadena como un espacio en blanco en grafo, normalmente un
      espacio en blanco.
    graph-blank debe ser el mismo número de columnas amplio como graph-symbol.")
  < src..

  (Para una explicación de @c{defvar}, ver @l{Inicializando una Variable con
  @c{defvar}}.)

  ..src > elisp
    ;;; Segunda versión.
    (defun column-of-graph (max-graph-height actual-height)
      "Devuelve cadenas MAX-GRAPH-HEIGHT; ACTUAL-HEIGHT son
      símbolos de grafos.

    Los graph-symbols son entradas contiguo al fin de la lista.
    La lista será insertado como una columna de un grafo.
    Las cadenas son tanto graph-blank o graph-symbol.

      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))

        ;; @e{Rellenar en @c{graph-symbols}.}
        (while (> actual-height 0)
          (setq insert-list (cons graph-symbol insert-list))
          (setq actual-height (1- actual-height)))

        ;; @e{Rellenar en @c{graph-blanks}.}
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons graph-blank insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))

        ;; Devuelve la lista completa.
        insert-list))
  < src..

  Si se desea, podríamos reescribir @c{column-of-graph} una tercera vez para
  proporcionar opcionalmente un gráfico de líneas, como gráfico de
  barras. Esto no sería duro de hacer. Un camino para pensar en un grafo de
  líneas es que no es más que un grafo de barras en el que la parte de cada
  barra que está debajo del alto es blanco. Para construir una columna para
  gráfico de líneas, la función primero construyen una lista de espacios en
  blanco que es una más ordenada que el valor, entonces usa @c{cons} para
  adjuntar un símbolo gráfico a la lista; entonces eso usa @c{cons} de nuevo
  para adjuntar el ‘alto de espacios en blanco’ a la lista.

  Es fácil ver como escribir tal función, pero puesto que no se necesita eso,
  no se hará. Pero el trabajo podría ser hecho, y si eso se hiciera, se haría
  con @c{column-of-graph}. Incluso más importante, no se valora nada más que
  pocos cambios que tendrían que ser hechos de cualquier otra manera. La
  mejora, que se desea hacer, es simple.

  Ahora, finalmente, volvemos a nuestra primera función de grafo
  impresa. Esto imprime el cuerpo de un grafo, no las etiquetas para los ejes
  horizontal y vertical, así se puede llamar este @c{graph-body-print}.

** La función @c{graph-body-print}

   Después de nuestra preparación en la sección precedente, la función
   @c{graph-body-print} es simple. La función imprimirá la columna después de
   la columna de asteriscos y espacios en blanco, usando los elementos de la
   lista de números para especificar el número de asteriscos en cada
   columna. Esto es un acto repetitivo, que significa que se puede usar un
   bucle @c{while} que decrementa o una función recursiva para el trabajo. En
   esta sección, se escribirá la definición usando un bucle @c{while}.

   La función @c{column-of-graph} requiere el alto del grafo como un
   argumento, así se asigna y guarda esto como una variable local.

   Esto lidera a la siguiente plantilla para el bucle @c{while} versión de
   esta función:

   ..src > elisp
     (defun graph-body-print (numbers-list)
       "documentation…"
       (let ((height  …
              …))

         (while numbers-list
           insert-columns-and-reposition-point
           (setq numbers-list (cdr numbers-list)))))
   < src..

   Necesitamos rellenar los slots de la plantilla.

   Claramente, se puede usar la expresión @c{(apply 'max numbers-list)} para
   determinar el alto del grafo.

   El bucle @c{while} iterará a través de @c{numbers-list} un elemento a la
   vez. Como eso está ordenado por la expresión @c{(setq numbers-list (cdr
   numbers-list))}, el @c{car} de cada instancia de la lista es el valor del
   argumento para @c{column-of-graph}.

   En cada ciclo del bucle @c{while}, la función @c{insert-rectangle} inserta
   la lista devuelta por @c{column-of-graph}. Desde que la función
   @c{insert-rectangle}, se necesita guardar la localización de punto al
   tiempo que el rectángulo se inserta, mueve atrás a esta posición después
   de que el rectángulo es insertado, y entonces se mueve horizontalmente al
   siguiente lugar desde el que @c{insert-rectangle} se llama.

   Si las columnas se insertan en un carácter amplio, será si los espacios en
   blanco y asteriscos se usan, el comando de reposición es simple
   @c{(forward-char 1)}; sin embargo, el ancho de una columna puede ser más
   grande que uno. Esto significa que el comando de reposicionamiento sería
   escrito @c{(forward-char symbol-width)}. El mejor lugar para asociar la
   variable @c{symbol-width} al valor del width de la columna grafo está en
   la varlist de la expresión @c{let}.

   Estas consideraciones lideran a la siguiente definición de función:

   ..src > elisp
     (defun graph-body-print (numbers-list)
       "Imprime un gráfico de barras de la NUMBERS-LIST.
     La numbers-list consiste en los valores del eje Y."

       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)

         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; Dibuja la columna del grafo por columna.
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; Emplaza el punto para etiquetas de ejes X.
         (forward-line height)
         (insert "\n")
     ))
   < src..

   La expresión inesperada en esta función es la expresión @c{(sit-for 0)} en
   el bucle @c{while}. Esta expresión hace que el grafo imprima la operación
   más interesante para vigilar lo que sería de otro modo. La expresión causa
   que Emacs pare (sit-for 0) para un momento cero y entonces redibuje la
   pantalla. Puesto aquí, eso causa que Emacs redibuje la pantalla columna
   por columna. Sin eso, Emacs no redibujaría la pantalla hasta que la
   función exista.

   Se puede probar @c{graph-body-print} con una pequeña lista de números.

   1. Instala @c{graph-symbol}, @c{graph-blank}, @c{column-of-graph}, que
      están en @l{Leyendo un grafo}, and @c{graph-body-print}.

   2. Copia la siguiente expresión:

      ..src > elisp
        (graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
      < src..

   3. Cambia al búfer @f{*scratch*} y emplaza el cursor donde quiere que el
      grafo empiece.

   4. Escribe @k{M::} @%c(eval-expression).

   5. Pega la expresión @c{graph-body-print} dentro del minibúfer con
      @k{C-y} @%c(yank).

   6. Presiona @k{RET} para evaluar la expresión @c{graph-body-print}.


   Emacs imprimirá un grafo como este:

   ..example >
             *
         *   **
         *  ****
        *** ****
       ********* *
      ************
     *************
   < example..

** La función @c{recursive-graph-body-print}

   La función @c{graph-body-print} puede también ser escrito
   recursivamente. La solución recursiva es dividida dentro de dos partes:
   una fuera ‘wrapper’ @e{envoltorio} que usa una expresión @c{let} para
   determinar los valores varias variables que solo necesitan ser encontradas
   una vez, tal como la máxima altura del grafo, y una función dentro que es
   llamada recursivamente para imprimir el grafo.

   El ‘envoltorio’ no es complicado:

   ..src > elisp
     (defun recursive-graph-body-print (numbers-list)
       "Imprime un gráfico de barras del NUMBERS-LIST.
     El numbers-list consiste en los valores del eje Y."
       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)
         (recursive-graph-body-print-internal
          numbers-list
          height
          symbol-width)))
   < src..

   La función recursiva es un poco más difícil. Eso tiene cuatro partes: el
   ‘prueba-hazlo-de-nuevo’, el código impreso, la llamada recursiva, y la
   ‘expresion-del-siguiente-paso’. El ‘prueba-hazlo-de-nuevo’ es una expresión @c{when}
   determina si la @c{numbers-list} contiene cualquier elemento que
   permanece; si hace eso, la función imprime una columna del grafo usando el
   código impreso y se llama así mismo de nuevo. La función se llama así
   misma de nuevo de acuerdo al valor producido por la ‘expresion-del-siguiente-paso’
   que causa para llamar a actuar en una versión ordenada de la
   @c{numbers-list}.

   ..src > elisp
     (defun recursive-graph-body-print-internal
       (numbers-list height symbol-width)
       "Imprime un gráfico de barras.
     Usado con la función recursive-graph-body-print."

       (when numbers-list
             (setq from-position (point))
             (insert-rectangle
              (column-of-graph height (car numbers-list)))
             (goto-char from-position)
             (forward-char symbol-width)
             (sit-for 0)     ; Dibuja un gráfico columna por columna.
             (recursive-graph-body-print-internal
              (cdr numbers-list) height symbol-width)))
   < src..

   Después de la siguiente instalación, esta expresión puede ser chequeada;
   aquí hay un ejemplo:

   ..src > elisp
     (recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
   < src..

   Aquí está lo que @c{recursive-graph-body-print} produce:

   ..example >
         *
        **   *
       ****  *
       **** ***
     * *********
     ************
     *************
   < example..

   Cada una de estas dos funciones, @c{graph-body-print} o
   @c{recursive-graph-body-print}, crea el cuerpo de un grafo.

** Necesidad para ejes impresos

   Un grafo necesita ejes impresos, así se puede orientar a tí mismo. Para un
   proyecto do-once, eso puede ser razonable dibujar los ejes a mano usando
   el modo de emacs Picture, pero un grafo dibuja la función que puede ser
   usada más de una vez.

   Por esta razón, se han escrito mejoras a la función básica
   @c{print-graph-body} que automáticamente imprime etiquetas para los ejes
   horizontal y vertical. Puesto que la etiqueta de imprimir funciones no
   contiene mucho material nuevo, se ha emplazado su descripción en un
   apéndice Vea la Seccion @l{Un Grafo con Ejes Etiquetados}.

** Ejercicio

   Escribe una versión de línea de grafo de la funciones de impresión del
   grafo.

* Tu fichero @f{.emacs}

  “No te tiene que gustar Emacs para lo que te gusta”––esto que parece una
  frase paradójica es el secreto de GNU Emacs. En realidad, Emacs es una
  herramienta genérica. La mayoría de la gente que usa Emacs, lo personaliza
  para ajustarlo a sus necesidades.

  GNU Emacs está mayoritariamente escrito en Emacs Lisp; esto significa que
  escribiendo expresiones en Emacs Lisp se puede modificar o extender Emacs.

  Hay quien aprecia la configuración por defecto de Emacs. Después de todo,
  Emacs empieza en modo C cuando se edita un fichero C, empieza en modo
  Fortran cuando se edita un fichero Fortran, y empieza en modo Fundamental
  cuando se edita un fichero no adornado. Esto tiene sentido, si no sabes
  quien está yendo a usar Emacs. ¿Quién sabe lo que una persona espera hacer
  con un fichero no adornado? El modo fundamental es el modo correcto por
  defecto para tal fichero, tal como el modo C es lo correcto para editar
  código C. (Suficientes lenguajes de programación tienen sintaxis que
  permiten compartir funcionalidades, tal como el modo C es ahora
  proporcionado por el modo CC, la ‘Colección C’.)

  Pero cuando se conoce quien está yendo a usar Emacs––tu, tu mismo––entonces
  eso tiene sentido para personalizar Emacs.

  Por ejemplo, yo raramente quiero el modo Fundamental cuando edito un
  fichero de otro modo no distinguido; yo quiero el modo Texto. Esto es por
  lo que yo personalizo Emacs: así eso se ajusta a mí.

  Se puede personalizar y extender Emacs escribiendo o adaptando un fichero
  @f{~/.emacs}. Esto es un fichero de inicialización personal; sus
  contenidos, escritos en Emacs Lisp, cuentan a Emacs qué hacer.@n{14}

  Un fichero @f{~/.emacs} contiene código Emacs Lisp. Se puede escribir este
  código por uno mismo; o se puede usar la funcionalidad @c{customize} para
  escribir el código para ti. Se puede combinar tus propias expresiones y
  expresiones auto-escritas personalizadas en tu fichero @f{.emacs}.

  (Yo prefiero por mí mismo escribir mis propias expresiones, excepto para
  estas, fuentes particularmente, que se encuentran fáciles de manipular
  usando el comando @c{customize}. Yo combino los dos métodos.)

  La mayoría de este capítulo es acerca de escribir expresiones por uno
  mismo. Eso describe un fichero @f{.emacs} simple; para más información,
  mira @"{El Fichero de Inicio} en @e(El Manual GNU Emacs), y la Seccion
  @"{El Fichero de Inicio} en @e(El Manual de Referencia GNU Emacs Lisp).

** Fichero de inicialización site-wide

   Además de tu fichero de inicialización personal, Emacs automáticamente
   carga varios ficheros de inicialización amplios, si existen. Tienen la
   misma forma que tu fichero @f{.emacs}, pero se cargan por cualquiera.

   Dos ficheros de incialización, @f{site-load.el} y @f{site-init.el}, están
   cargados dentro de Emacs y volcados @e{dumped} sin una versión dumped de
   Emacs se creó, como es más común. (Las copias dumped de Emacs cargan más
   rápidamente. Sin embargo, puesto que un fichero se carga y compila, un
   cambio no llega a ser un cambio en Emacs a menos que se cargue por uno
   mismo o se recompile Emacs. Vea la Seccion @"(Construyendo Emacs) en @e(El
   Manual de Referencia de GNU Emacs Lisp), y el fichero @f{INSTALL})

   Los otros tres ficheros de inicialización se cargan automáticamente cada
   vez que se inicia Emacs, si existen. Son @f{site-start.el}, que se carga
   @e{antes} que tu fichero @f{.emacs}, y @f{default.el}, y el tipo de
   fichero terminal, que se cargan @e{después} de tu fichero @f{.emacs}.

   Las configuraciones y definiciones en tu fichero @f{.emacs}
   sobreescribirán las configuraciones en conflicto y definiciones en un
   fichero @f{site-start.el}, si eso existe; pero las configuraciones y
   definiciones en un @f{default.el} o el tipo de fichero terminal
   sobreescribirá estos en tu fichero @f{.emacs}. (Se pueden prevenir
   interferencias desde un tipo de fichero terminal configurando
   @c{term-file-prefix} para @c{nil}. Vea la Seccion @l{Una extensión simple:
   @c{line-to-top-of-window}}.)

   El fichero @f{INSTALL} que viene en la distribución contiene descripciones
   de los fichero @f{site-init.el} y @f{site-load.el}.

   Los ficheros @f{loadup.el}, @f{startup.el}, y @f{loaddefs.el} controlan la
   carga. Estos ficheros están en el directorio @f{lisp} de la distribución
   Emacs y tiene valor de uso.

   El fichero @f{loaddefs.el} contiene buenas sugerencias como las que poner
   dentro de tu propio fichero @f{.emacs}, o dentro de un fichero de
   inicialización amplio.

** Especificar variables usando @c{defcustom}

   Se pueden especificar variables usando @c{defcustom} así que la gente
   pueda usar la funcionalidad de Emacs @c{customize} para asignar sus
   valores. (No se puede usar @c{customize} para escribir definiciones de
   función; pero se pueden escribir @c{defuns} en tu fichero @f{.emacs}. En
   vez de eso, se puede escribir cualquier expresión Lisp en tu fichero
   @f{.emacs}).

   La funcionalidad @c{customize} depende de la forma especial
   @c{defcustom}. Aunque se puede usar @c{defvar} o @c{setq} para las
   variables que los usuarios asignan, la forma especial @c{defcustom} está
   diseñada para el trabajo.

   Se puede usar tu conocimiento de @c{defvar} para escribir los primeros
   tres argumentos para @c{defcustom}. El primer argumento para @c{defcustom}
   es el nombre de la variable. El segundo argumento es el valor inicial de
   la variable, cualquiera; y este valor es asignado solo si el valor no ha
   sido ya asignado. El tercer argumento es la documentación.

   El cuarto y subsiguientes argumentos para @c{defcustom} especifican los
   tipos y opciones; estos no son funcionales en @c{defvar}. (Estos
   argumentos son opcionales.)

   Cada uno de estos argumentos consiste de una palabra seguido de una
   palabra por un valor. Cada palabra clave empieza con los dos puntos @'{:}.

   Por ejemplo, la variable de opciones personalizable @c{text-mode-hook} se
   parece a esto:

   ..src > elisp
     (defcustom text-mode-hook nil
       "El hook normal se ejecuta cuando se introduce en modo texto y
       muchos modos relacionados."
       :type 'hook
       :options '(turn-on-auto-fill flyspell-mode)
       :group 'data)
   < src..

   El nombre de la variable es @c{text-mode-hook}; no tiene valor por
   defecto; y su cadena de documentación cuenta lo que hace.

   La palabra clave @c{:type} le cuenta a Emacs el tipo de datos para los que
   @c{text-mode-hook} sería asignado y como muestra el valor en un búfer de
   Personalización.

   La palabra clave @c{:options} especifica una lista sugerida de valores
   para la variable. Normalmente, @c{:options} se asocia a un gancho
   (@e{hook}. La lista es solo una sugerencia; esa no es exclusiva; una
   persona quien asigna la variable puede asignarse a otros valores; la lista
   mostrada siguiendo la palabra clave @c{:options} se pretende ofrecer
   elecciones convenientes a un usuario.

   Finalmente, la palabra clave @c{:group} cuenta el comando de
   Personalización de Emacs en el que el grupo de la variable está
   localizado. Esto cuenta dónde encontralo.

   La función @c{defcustom} reconoce más de una docena de palabras
   clave. Para más información, mire @"{Escribiendo las Definiciones de
   Personalización} en @e(El Manual de Referencia GNU Emacs Lisp).

   Considere @c{text-mode-hook} como un ejemplo.

   Hay dos caminos para personalizar esta variable. Se puede usar el comando
   de personalización o escribir las expresiones apropiadas por uno mismo.

   Usando el comando de personalización, se puede escribir:

   ..example >
     M-x customize
   < example..

   y encuentre que el grupo para editar ficheros de datos se llama
   ‘datos’. Introduzca este grupo. El Hook @e{Disparador} es el primer
   miembro. Se puede hacer click en sus opciones varias, tal como
   @c{turn-on-auto-fill}, para asignar los valores. Después de hacer click en
   el botón.

   ..example >
     Guárdalo para Futuras Sesiones
   < example..

   Emacs escribirá una expresión en tu fichero @f{.emacs}. Se parecerá a
   esto:

   ..src > elisp
     (custom-set-variables
       ;; custom-set-variables fué añadido por Custom.
       ;; Si se edita a mano, tu podrías liarte,
       ;; así que ten cuidado.
       ;; Tu fichero init contendría solo esta instancia.
       ;; Si hay más de uno, ellos no quieren trabajar.
      '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
   < src..

   (La función @c{text-mode-hook-identify} cuenta
   @c{toggle-text-mode-auto-fill} que buffers hay en modo Texto. Eso viene
   automáticamente)

   La función @c{custom-set-variables} funciona de alguna manera diferente
   más de un @c{setq}. Mientras yo nunca he aprendido las diferencias, yo
   modifico las expresiones @c{custom-set-variable} en mi fichero @f{.emacs}
   a mano: yo creo los cambios en los que aparecen a mi para ser una manera
   razonable y no tener problemas. Otros prefieren usar el comando de
   Personalización y permitir a Emacs hacer el trabajo para ellos.

   Otra función @c{custom-set-…} es @c{custom-set-faces}. Esta función asigna
   varios tipos de fuentes. A través del tiempo, yo he asignado un
   considerable número de tipos. Algo de tiempo, yo las reseteo usando
   @c{customize}; otras veces, simplemente edito la expresión
   @c{custom-set-faces} en mi fichero @f{.emacs} en sí.

   El segundo modo de personalizar tu @c{text-mode-hook} es asignarte a tí
   mismo en tu fichero @f{.emacs} usando código que no tiene nada que hacer
   con las funciones @c{custom-set-…}.

   Cuando se hace esto, y después usa @c{customize}, se verá un mensaje que
   dice:

   ..example >
     CHANGED fuera de Personalizar; operando dentro aquí
     puede ser no confiable.
   < example..

   Este mensaje es solo un aviso. Si se puede cliquear en el botón a

   ..example >
     Guárdalo para Futuras Sesiones
   < example..

   Emacs escribirá una expresión @c{custom-set-…} cerca del fin de tu fichero
   @f{.emacs} que será evaluado después de que tu expresión sea escrita a
   mano. Por esta razón, se sobreescribirá tu expresión escrita a
   mano. Ningún daño será hecho. Cuando se haga esto, sin embargo, ten
   cuidado para recordar que expresión está activa; si olvidas, puedes
   confundirte por tí mismo.

   Tan largo como se recuerda donde los valores son configurados, no habrá
   problemas. En cualquier eventos, los valores son siempre configurados en
   tu fichero de inicialización, que es normalmente llamado @f{.emacs}.

   Yo mismo hago un @c{customize} para cualquier cosa. Mayoritariamente,
   escribo expresiones por mí mismo.

   Incidentalmente, para ser una definición concerniente más completa:
   @c{defsubst} define una función inline. La sintaxis es solo como esta de
   @c{defun}. @c{defconst} define un símbolo como una constante. El intento
   es que ningún programa o usuario cambiarían un valor asignado por
   @c{defconst}. (Se puede cambiar; el valor asignado es una variable; pero
   por favor no lo haga.)

** Empieza por un fichero @f{.emacs}

   Cuando se abre Emacs, se carga tu fichero @f{.emacs} a menos que se cuente
   que no se especifique @'{-q} en la línea de comandos. (El comando @c{emacs
   -q} tu da un Emacs plano, fuera.)

   Un fichero @f{.emacs} contiene expresiones Lisp. Con frecuencia, no hay
   más expresiones para configura valores; algunas veces esas son
   definiciones de funciones.

   Vea la Seccion @l{info:emacs#Init File<>El Fichero de Inicio} @f{~/.emacs} en
   @e(El Manual GNU Emacs), para una corta descripción de fichero de
   inicialización.

   Este capítulo cubre algo del mismo suelo, pero es un paseo entre extractos
   desde un completo, largamente usado fichero @f{.emacs}––por mí.

   La primera parte del fichero consiste en comentario: me recuerdo a mí
   mismo. Por ahora, yo recuerdo estas cosas, pero cuando empecé, no.

   ..src > elisp
     ;;;; fichero .emacs de Bob
     ; Robert J. Chassell
     ; 26 de Septiembre de 1985
   < src..

   ¡Mira en esta fecha! Yo empecé este fichero hace mucho tiempo. Yo he
   estado añadiendo cosas desde siempre.

   ..src > elisp
     ; Cada sección en este fichero es introducido por una
     ; línea empezando con cuatro puntos y comas y cada
     ; entrada es introducida por una línea empezando con
     ; tres puntos y comas.
   < src..

   Esto describe las convenciones usuales para comentarios en Emacs
   Lisp. Cada cosa en una línea que sigue un punto y coma es un
   comentario. Dos, tres, y cuatro puntos y coma son usados como subsección y
   marcas de sección. (Vea la Seccion @"{Comentarios} en @e(El Manual de
   Referencia GNU Emacs Lisp), para más comentarios.)

   ..src > elisp
     ;;;; La Tecla de Ayuda
     ; Control-h es la tecla de ayuda;
     ; después escribiendo control-h, escribe una letra a
     ; indica el asunto acerca del que quieres ayuda.
     ; Para una explicación de la facilidad de ayuda,
     ; escribe control-h dos veces en una fila.
   < src..

   Solo recuerda: escribe @k{C-h} dos veces para ayudar.

   ..src > elisp
     ; Para informarse acerca de cualquier modo, escribe control-h m
     ; mientras esté en este modo. Por ejemplo, para encontrar
     ; acerca del modo correo, introduce el modo correo y entonces
     ; escribe control-h m.
   < src..

   ‘Modo ayuda’, como yo llamo a esto, es muy útil. Usualmente, se cuenta
   todo lo que se necesita saber.

   De acuerdo, no se necesitan incluir comentarios y ficheros como estos
   @f{.emacs}. Yo los incluí en el mío porque se olvida el Modo ayuda o las
   convenciones para comentarios––pero era capaz de recordar ver aquí
   recordármelo a mí mismo.

** Modo texto y auto relleno

   Ahora regresa a la parte que ‘vuelve’ al modo Texto y modo Auto Relleno.

   ..src > elisp
     ;;; Modo texto modo Auto Fill
     ;; Las siguiente dos líneas puestas en Emacs dentro de
     ;; modo Texto y en el modo Auto Fill, son para escritores que
     ;; quieren empezar a escribir prosa en vez de código.
     (setq-default major-mode 'text-mode)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   < src..

   ¡Aquí está la primera parte de este fichero @f{.emacs} que hace alguna
   cosa bajo recuerdo de un humano olvidado!

   La primera de las dos líneas entre paréntesis cuentan a Emacs a cambiar al
   modo Texto que se encuentra un fichero, @e{a menos que} el fichero iría
   dentro de algún otro modo, tal como el modo C.

   Cuando Emacs lee un fichero, eso parece la extensión al nombre del
   fichero. (La extensión es la parte que viene después de un @'{.}.) Si el
   fichero finaliza con una extensión @'{.c} o @'{.h} entonces Emacs cambia
   al modo C. También, Emacs parece al principio una línea no blanca del
   fichero; si la línea dice @'{-*- C -*-}, Emacs cambia al modo C. Emacs
   posee una lista de extensiones y especificaciones que usa
   automáticamente. Además, Emacs se ve cerca de la última página por buffer,
   “lista variables locales”.

   Mira las secciones “Cómo los Modos Mayores son Elegidos” y “Variables
   Locales en Fichero” en @e{El Manual GNU Emacs}.

   Ahora, regresa al fichero @f{.emacs}.

   Aquí está la línea de nuevo; ¿cómo funciona?

   ..src > elisp
     (setq major-mode 'text-mode)
   < src..

   Esta línea es un resumen, pero completa la expresión Emacs Lisp.

   Ya estamos familiarizados con @c{setq}. Eso asigna la siguiente variable,
   @c{major-mode}, al subsiguiente valor, que es @c{text-mode}. La marca de
   cita simple antes de @c{text-mode} cuenta a Emacs como tratar directamente
   con el símbolo, no con cualquier cosa que pudiera existir. Vea la Seccion
   @l{Configurando el Valor de una Variable}, por un recuerdo de como
   @c{setq} funciona. El principal punto es que no hay diferencia entre el
   procedimiento que se usa para asignar un valor en su fichero @f{.emacs} y
   el procedimiento que se usa en cualquier lugar más en Emacs.

   Aquí está la siguiente línea:

   ..src > elisp
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   < src..

   En esta línea, el comando @c{add-hook} añade @c{turn-on-auto-fill} para la
   variable.

   ¡@c{turn-on-auto-fill} es el nombre de un programa, que se adivina!,
   cambia al modo Auto Fill.

   Cada vez que Emacs cambia al modo texto, Emacs ejecuta el comando ‘hooked’
   dentro de modo Texto. Así que cada vez que Emacs cambia al modo Texto,
   Emacs también cambia al modo de autoajuste.

   En breve, la primera línea causa a Emacs a entrar en modo Texto cuando se
   edite un fichero, a menos que la extensión del nombre del fichero, una
   línea no en blanco, variables locales para contar a Emacs de otro modo.

   El modo texto entre otras acciones, asigna la tabla de sintaxis para
   trabajar adecuadamente a escritores. En modo texto, Emacs considera un
   apóstrofe como parte de una palabra como una letra; pero Emacs no
   considera un período o un espacio como parte de una palabra. De este modo,
   @k{M-f} se mueve hacia tí a través de @'{eso}. Por otro lado, en modo C,
   @k{M-f} para solo después del @'{t} de @'{eso}.

   La segunda línea causa que Emacs active el modo Auto Fill cuando cambia al
   modo Texto. En modo Auto Fill, Emacs automáticamente rompe una línea que
   es demasiado amplio y trae la parte excesivamente amplia de la línea de
   debajo a la siguiente línea. Emacs rompe líneas entre palabras con ellas.

   Cuando el modo Auto Fill está desactivado, las líneas continúan a la
   derecha como se escriben. Dependiendo de como configuras el valor de
   @c{truncate-lines}, las palabras que se escribe si desaparecen al lado
   derecho de la pantalla, o lo demás son mostradas, en un modo feo e
   ilegible, como una línea de continuación en la pantalla.

   Además, en esta parte de mi fichero @f{.emacs}, yo cuento a Emacs el
   ajuste de comandos para insertar dos espacios después de dos puntos:

   ..src > elisp
     (setq colon-double-space t)
   < src..

** Alias de correo

   Aquí hay un @c{setq} que ‘activa’ el alias de correo, para más ocasiones.

   ..src > elisp
     ;;; Modo Correo
     ; Para entrar en el modo correo, escribe ‘C-x m’
     ; Para introducir RMAIL (para leer el correo),
     ; escribe ‘M-x rmail’
     (setq mail-aliases t)
   < src..

   Este comando @c{setq} asigna el valor de la variable @c{mail-aliases} al
   @c{t}. Desde que @c{t} significa verdadero, la línea dice, en efecto, “Sí uso
   alias de correo.”

   Los alias de correo son nombres cortos convenientes para largas
   direcciones de correo o para listas de direcciones de correo. El fichero
   donde guardar tus ‘aliases’ es @f{~/.mailrc}. Se escribe un alias como
   este:

   ..example >
     alias geo george@@foobar.wiz.edu
   < example..

   Cuando se escribe un mensaje a Jorge, la dirección a @'{geo}; el correo
   automáticamente expandirá @'{geo} a la dirección completa.

** Indentar modo de tabulaciones

   Por defecto, Emacs inserta tabulaciones en lugar en múltiples espacios
   cuando se formatea una región. (Por ejemplo, se podrían indentar muchas
   líneas de texto todo a la vez con el comando @c{indent-region}.) Los
   tabuladores se ven bien en un terminal o con impresión ordinaria, pero
   ellos producen mala salida de indentación cuando se usa T@_(E)X o Texinfo
   puesto que T@_(E)X ignora tabuladores.

   Lo siguiente desactiva el modo de Indentar Tabulaciones:

   ..src > elisp
     ;;; Prevenir Tabulaciones Extrañas
     (setq-default indent-tabs-mode nil)
   < src..

   Note que esta línea usa @c{setq-default} en vez de el comando @c{setq} que
   hemos visto antes. El comando @c{setq-default} asigna valores solo en
   búfers que no tienen sus propios valores locales para la variable.

   Ver secciones “Tabuladores versus Espacios” y “Variables Locales en
   Ficheros” en @e{El Manual de GNU Emacs}.

** Atajos de teclado

   Ahora para algunos atajos personales:

   ..src > elisp
     ;;; Compara ventanas
     (global-set-key "\C-cw" 'compare-windows)
   < src..

   @c{compare-windows} es un comando excelente que compara el texto en tu
   ventana actual con texto de la siguiente ventana. Eso hace la comparación
   empezando al punto en cada ventana, moviendo a través del texto en cada
   ventana tan lejos como ellos asocian. Yo uso este comando todo el tiempo.

   Esto también muestra como configurar una tecla globalmente, para todo los
   modos

   El comando es @c{global-set-key}. Es seguido por el atajo. En un fichero
   @f{.emacs}, el atajo es escrito como se ve: @c{\C-c} que se asocia a
   ‘control-c’, que significa ‘presionar la tecla de control y la tecla @k{c}
   al mismo tiempo’. La @c{w} significa ‘presionar la tecla @k{w}’. El atajo
   es rodeado por dobles comillas. En la documentación, se escribiría esto
   como @k{C-c w}. (Si estuviera asociando una tecla @k{META}, tal como
   @k{M-c}, en vez de una tecla de @k{CTRL}, se escribiría @c{\M-c} en su
   fichero @f{.emacs}. Vea la Seccion @"{Reasociando Teclas en Su Fichero
   Init} en @e(El Manual de GNU Emacs), para más detalles.)

   El comando invocado por las teclas es @c{compare-windows}. Note que
   @c{compare-windows} es precedido por una comilla simple; de otro modo,
   Emacs primero intentaría evaluar el símbolo para determinar su valor.

   Estas tres cosas, las marcas de dobles comillas, la barra invertida antes
   de la @'{C}, y la marca de comilla simple son partes necesarias de atajos
   de teclado que tiendo a olvidar. Afortunadamente, he llegado a recordar
   que miraría mi fichero @f{.emacs} existente, y lo adaptaría a lo que hay.

   Como para el atajo en sí: @k{C-c w}, combina la tecla prefija, @k{C-c},
   con un caracter simple, en este caso, @k{w}. Este conjunto de teclas,
   @k{C-c} seguido por un caracter simple, es estrictamente reservado para un
   uso propio individual. (Esto se llama teclas ‘propias’, puesto que estas
   son para su propio uso). Siempre sería capaz de crear tal atajo para el
   uso propio sin pisar fuerte en algún atajo más. Si siempre se escribe una
   extensión a Emacs, por favor, evite tomar cualquiera de estas teclas para
   uso público. Se cree que una tecla como @k{C-c C-w} en vez de eso. De otra
   manera, ejecutará sin sus ‘propias’ teclas.

   Aquí hay otro atajo, con un comentario:

   ..src > elisp
     ;;; Atajo para ‘occur’
     ; Yo uso mucho occur, así permite asignarlo a una tecla:
     (global-set-key "\C-co" 'occur)
   < src..

   El comando @c{occur} muestra todas las líneas en el buffer actual que
   contiene un emparejamiento para una expresión regular. Asociar las líneas
   que se muestran en un búfer llamado @f{*Occur*}. Este buffer sirve como
   un menu para saltar a ocurrencias.

   Aquí se muestra como desasignar una tecla, así no funciona:

   ..src > elisp
     ;;; Desasociar ‘C-x f’
     (global-unset-key "\C-xf")
   < src..

   Hay una razón para esta no asociación: Yo encontré inadvertidamente
   escrito @k{C-x f} cuando significó escribir @k{C-x C-f}. En vez de
   encontrar un fichero, como se pretende, accidentalmente asigna el ancho
   para el fichero lleno, casi siempre a un tamaño que no quería. Puesto que
   duramente se reseteó mi ancho por defecto, yo simplemente disocié la
   tecla.

   Lo siguiente reasocia una tecla existente:

   ..src > elisp
     ;;; Reasocia ‘C-x C-b’ al ‘buffer-menu’
     (global-set-key "\C-x\C-b" 'buffer-menu)
   < src..

   Por defecto, @k{C-x C-b} ejecute el comando @c{list-buffers}. Este comando
   lista sus buffers en @e{otra} ventana. Desde que casi siempre se quiere
   hacer alguna cosa en esta ventana, se prefiere el comando @c{buffer-menu},
   que no solo lista los buffers, pero mueve el punto dentro de esta ventana.

** Mapas de teclado

   Emacs usa @:{keymaps} para grabar qué teclas llaman a qué comandos. Cuando
   se use @c{global-set-key} para asignar los atajos de teclados a un simple
   comando en todo @c{current-global-map}.

   Modos específicos, tales como modo C o modo Texto, tiene sus propios mapas
   de teclado; mapas de teclado de modo específico sobreescribe el mapa
   global que es compartido por todos los buffers.

   La función @c{global-set-key} asocia, o reasocia, el mapa de teclado
   global. Por ejemplo, las siguientes asociaciones la tecla @k{C-x C-b} a la
   función @c{buffer-menu}:

   ..src > elisp
     (global-set-key "\C-x\C-b" 'buffer-menu)
   < src..

   Mapas de teclado específico de modo son asociados usando la función
   @c{define-key}, que toma un mapa de teclado específico como un argumento,
   tan bien como la tecla y el comando. Por ejemplo, mi fichero @f{.emacs}
   contiene la siguiente expresión asociada al comando
   @c{texinfo-insert-@@group} comando a @k{C-c C-c g}:

   ..src > elisp
     (define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
   < src..

   La función @c{texinfo-insert-@@group} en sí es una pequeña extensión del
   modo Texinfo que inserta @'{@@group} dentro de un fichero Texinfo. Se usa
   este comando todo el tiempo y se prefieren escribir los tres atajos @k{C-c
   C-c g} en vez de los seis atajos @k{@@ g r o u p}. (@'{@@group} y su
   asociación @'{@@end group} son comandos que guarda todo el texto cerrado
   junto a una página; muchos ejemplos multi-línea en este libro están
   rodeados por @'{@@group … @@end group}.)

   Aquí está la definición de función @c{texinfo-insert-@@group}:

   ..src > elisp
     (defun texinfo-insert-@@group ()
       "Inserta la cadena @@group en un búfer Texinfo."
       (interactive)
       (beginning-of-line)
       (insert "@@group\n"))
   < src..

   (De acuerdo, podría haber usado el modo Abbrev para dejar de escribir, en
   vez de escribir una función para insertar una palabra; pero prefiero
   atajos de teclado consitentes con otro modo Texinfo para atajos de
   teclado.)

   Verá numerosas expresiones @c{define-key} en @f{loaddefs.el} tan bien como
   en varios modos de librerías, tal como @f{cc-mode.el} y @f{lisp-mode.el}.

   Vea la Seccion @"{Personalizando Atajos de Teclado} en @e(El Manual GNU
   Emacs), y @"{Mapas de Teclado} en @e(El Manual de Referencia GNU Emacs
   Lisp), para más información acerca de mapas de teclado.

** Cargando ficheros

   Muchas personas en la comunidad de GNU Emacs han escrito extensiones a
   Emacs. Hace tiempo, que estas extensiones son con frecuencia incluidas en
   las nuevas entregas @e{releases}. Por ejemplo, los paquetes Calendario y
   Diario son ahora parte del estándar GNU Emacs, como es Calc.

   Se puede usar un comando @c{load} para evaluar un fichero completo que
   significa instalar todas las funciones y variables en el fichero
   Emacs. Por ejemplo:

   ..src > elisp
     (load "~/emacs/slowsplit")
   < src..

   Esto evalúa, es decir, carga, el fichero @f{slowsplit.el} o si eso existe,
   lo más rápido, el fichero compilado @f{slowsplit.elc} desde el
   subdirectorio @f{emacs} del directorio home. El fichero contiene la
   función @c{split-window-quietly}, que John Robinson escribió en 1989.

   La función @c{split-window-quietly} divide una ventana con el mínimo de
   redisplay. Yo lo instalé en 1989 porque trabajó bien con los terminales de
   1200 baudios que entonces estaba usando. Ahora, ocasionalmente vengo a
   través de una conexión lenta, pero continúa usando la función porque me
   gusta el camino que deja arriba del búfer en el bajo de las nuevas
   ventanas y arriba en la ventana superior.

   Para reemplazar el atajo de teclado por defecto
   @c{split-window-vertically}, se debe también desasignar esta tecla y
   asociar las teclas a @c{split-window-quietly}, como este:

   ..src > elisp
     (global-unset-key "\C-x2")
     (global-set-key "\C-x2" 'split-window-quietly)
   < src..

   Si se cargan muchas extensiones, como yo hago, entonces en vez de
   especificar la posición exacta del fichero, como se muestra arriba, se
   puede especificar que directorio como parte del @c{load-path} de
   Emacs. Entonces, cuando Emacs carga un fichero, buscará que directorio tan
   bien como su lista por defecto de directorios. (La lista por defecto es
   especificada en @f{paths.h} cuando Emacs se construye.)

   El comando siguiente añade tu directorio @f{~/emacs} a la ruta existente:

   ..src > elisp
     ;;; Ruta Emacs
     (setq load-path (cons "~/emacs" load-path))
   < src..

   Incidentalmente, @c{load-library} es un interfaz interactivo a la función
   @c{load}. La función se parece a esto:

   ..src > elisp
     (defun load-library (library)
       "Carga la librería llamada LIBRARY.
     Esto es una interfaz a la función ‘load’."
       (interactive
        (list (completing-read "Carga la librería: "
                               (apply-partially 'locate-file-completion-table
                                                load-path
                                                (get-load-suffixes)))))
       (load library))
   < src..

   El nombre de la función, @c{load-libray}, viene desde el uso de ‘library’
   como un sinónimo para ‘file’. La fuente para el comando @c{load-library}
   está en la librería @f{files.el}.

   Otro comando interactivo que hace un trabajo ligeramente diferente es
   @c{load-file}. Vea la Seccion @"{Librerías de Código Lisp para Emacs} en
   @e(El Manual GNU Emacs), para información en la distinción entre
   @c{load-library} y este comando.

** Autoloading

   En vez de instalar una función cargando el fichero que lo contiene, o
   evaluando la definición de función, se puede hacer la función disponible
   pero actualmente no se instala hasta la primera vez llamada. Este proceso
   se llama @:{autocarga} (@e{autoloading}).

   Cuando se ejecuta una función de autocarga, Emacs automáticamente evalúa
   el fichero que contiene la definición, y entonces llama a la función.

   Emacs empieza rápido con funciones de autocarga, puesto que sus librerías
   no se cargan bien; pero si necesita esperar un momento cuando su primer
   uso tal como una función, mientras que el fichero que lo contiene se
   evalúa.

   Raramente las funciones usadas son frecuentemente autocargadas. La
   librería @f{loaddefs.el} coniene cientos de funciones autocargadas, desde
   @c{bookmark-set} a @c{wordstar-mode}. Si se usa una función ‘rara’
   frecuentemente, se debería cargar este fichero de función con una
   expresión de @c{load} en tu fichero @f{.emacs}.

   En mi fichero @f{.emacs}, se cargan 14 librerías que contienen funciones
   que de otro modo serían autocargadas. (Actualmente, eso habría sido mejor
   para incluir estos ficheros en mi Emacs ‘volcado’, pero se olvida. Véase
   Sección @"{Construyendo Emacs} en @e(El Manual de Referencia GNU Emacs
   Lisp), y el fichero @f{INSTALL} para más acerca de volcados.)

   Se puede también querer incluir expresiones autocargadas en tu fichero
   @f{.emacs}. @c{autoload} es una función construida que toma cinco
   argumento, los tres finales de los que son opcionales. El primer argumento
   es el nombre de la función para ser autocargada. El segundo es el nombre
   del fichero para ser cargado. El tercer argumento es documentación para la
   función, y el cuarto cuenta si la función puede ser llamada
   interactivmente. El quinto argumento cuenta que tipo de
   objeto––@c{autoload} puede manejar un mapa de teclado o macro tan bien
   como una función (por defecto es una función).

   Aquí hay un ejemplo típico:

   ..src > elisp
     (autoload 'html-helper-mode
       "html-helper-mode" "Editar documentos HTML" t)
   < src..

   (@c{html-helper-mode} es una vieja alternativa a @c{html-mode}, que es una
   parte estándar de la distribución.)

   Esta expresión autocarga la función @c{html-helper-mode}. Esto se toma
   desde el fichero @f{html-helper-mode-el} (o desde la versión compilada
   @f{html-helper-mode.elc}, si eso existe). El fichero debe ser localizado
   en un directorio específico por @c{load-path}. La documentación dice que
   esto es un modo para ayudar a editar documentos escritos en Lenguaje de
   Marcas de Hiper Texto. Se puede llamar este modo interactivamente
   escribiendo @k{M-x html-helper-mode}. (Se necesitan duplicar las funciones
   regulares de documentación en la expresión de autocarga porque la función
   regular no está todavía cargada, así su documentación no está disponible.)

   Vea la Seccion @"{Autocarga} en @e(El Manual de Referencia de GNU Emacs
   Lisp), para más información.

** Una extensión simple: @c{line-to-top-of-window}

   Aquí hay una simple extensión a Emacs que mueve el punto de línea arriba
   de la ventana. Yo uso esto todo el tiempo, para hacer fácil de leer el
   texto.

   Se puede poner el siguiente código dentro de un fichero separado y entonce
   cargarlo desde tu fichero @f{.emacs}, o se puede incluir con tu fichero
   @f{.emacs}.

   Aquí está la definición

   ..src > elisp
     ;;; Línea a lo alto de la ventana;
     ;;; reemplaza tres secuencias de atajos de teclado  C-u 0 C-l
     (defun line-to-top-of-window ()
       "Mueve la línea que apunta a lo alto de la ventana."
       (interactive)
       (recenter 0))
   < src..

   Ahora el atajo.

   En estos días, las teclas de función así como los eventos del ratón y
   caracteres no @c{ascii} son escritos con corchetes, sin marcas de
   citas. (En Emacs versión 18 y anteriores, se tenía que escribir diferentes
   teclas de función asignadas por cada diferente creación del terminal.)

   Se puede asociar @c{line-to-top-of-window} a la tecla de función @k{F6}
   así:

   ..src > elisp
     (global-set-key [f6] 'line-to-top-of-window)
   < src..

   Para más información, mira @"{Reasociando Teclas en tu fichero init} en
   @e{El Manual GNU Emacs}.

   Si ejecutas dos versiones de GNU Emacs, tal como las versiones 22 y 23, y
   usas un fichero @f{.emacs}, se puede seleccionar qué código evalúa el
   siguiente condicional:

   ..src > elisp
     (cond
      ((= 22 emacs-major-version)
       ;; evalúa la version 22
       ( … ))
      ((= 23 emacs-major-version)
       ;; evalúa la version 23
       ( … )))
   < src..

   Por ejemplo, en versiones más recientes se ocultan los cursores por
   defecto. Si se odia tal ocultación se escribe lo siguiente en mi fichero
   @f{.emacs}@n{15}:

   ..src > elisp
     (when (>= emacs-major-version 21)
       (blink-cursor-mode 0)
       ;; Inserta la nueva línea cuando se presiona ‘C-n’ (next-line)
       ;; al fin del búfer
       (setq next-line-add-newlines t)
       ;; Cambia la imagen viendo
       (auto-image-file-mode t)
       ;; Activa la barra de menu (esta barra tiene texto)
       ;; (Usa un argumento numérico para activarlo)
       (menu-bar-mode 1)
        ;; Desactiva la barra de herramientas (esta barra tiene iconos)
        ;; (Usa argumentos numéricos para activarlo)
        (tool-bar-mode nil)
       ;; Desactiva el modo tooltip para la tool bar
       ;; (Este modo causa explicaciones de iconos al pop up)
       ;; (Usa el argumento numérico para activarlo)
       (tooltip-mode nil)
       ;; Si los tooltips activados, crea consejos aparecen en el prompt
       (setq tooltip-delay 0.1)  ; por defecto es de 0.7 segundos
        )
   < src..

** Colores X11

   Se pueden especificar colores cuando se usa Emacs con el Sistema de
   Ventanas X del MIT.

   Si disgustan los colores por defecto y especifica unos propios.

   Aquí están las expresiones en un fichero @f{.emacs} que establecen los
   valores:

   ..src > elisp
     ;; Asigna el color del cursor
     (set-cursor-color "white")

     ;; Asigna el color del ratón
     (set-mouse-color "white")

     ;; Asigna foreground y background
     (set-foreground-color "white")
     (set-background-color "darkblue")

     ;;; Asigna colores para isearch y drag
     (set-face-foreground 'highlight "white")
     (set-face-background 'highlight "blue")

     (set-face-foreground 'region "cyan")
     (set-face-background 'region "blue")

     (set-face-foreground 'secondary-selection "skyblue")
     (set-face-background 'secondary-selection "darkblue")

     ;; Asigna colores al calendario
     (setq calendar-load-hook
           '(lambda ()
              (set-face-foreground 'diary-face   "skyblue")
              (set-face-background 'holiday-face "slate blue")
              (set-face-foreground 'holiday-face "white")))
   < src..

   Las varias sombras de azul disparan mi ojo y me preveen de ver la ventana
   desplegada.

   Alternativamente, se podrían haber configurado mis especificaciones en
   varios ficheros inicialización de X. Por ejemplo, se podría asignar el
   foreground, background, cursor y puntero (por ej., ratón) colores en mi
   fichero @f{~/.Xresources} como esto:

   ..example >
     Emacs*foreground:   white
     Emacs*background:   darkblue
     Emacs*cursorColor:  white
     Emacs*pointerColor: white
   < example..

   En cualquier evento que no es parte de Emacs, se asigna el color raíz de
   mi ventana X en mi fichero @f{~/.xinitrc}, como este@n{16}

   ..example >
     xsetroot -solid Navy -fg white &
   < example..

** Configuraciones misceláneas para un fichero @f{.emacs}

   Aquí hay unas pocas configuraciones misceláneas:


   - Asigna la forma y color del ratón del cursor:

     ..src > elisp
       ; Formas de Cursor están definidas en
       ; ‘/usr/include/X11/cursorfont.h’;
       ; por ejemplo, el cursor ‘objetivo’ es número 128;
       ; el cursor ‘top_left_arrow’ es el número 132.

       (let ((mpointer (x-get-resource "*mpointer"
                                       "*emacs*mpointer")))
         ;; Si no se ha asignado tu puntero de ratón
         ;; entonces asignalo, de otro modo, déjalo así:
         (if (eq mpointer nil)
             (setq mpointer "132")) ; top_left_arrow
         (setq x-pointer-shape (string-to-int mpointer))
         (set-mouse-color "white"))
     < src..

   - O se pueden asignar los valores de una variedad de funcionalidades en
     una alist, como esta:

     ..src > elisp
       (setq-default
        default-frame-alist
        '((cursor-color . "white")
          (mouse-color . "white")
          (foreground-color . "white")
          (background-color . "DodgerBlue4")
          ;; (cursor-type . bar)
          (cursor-type . box)
          (tool-bar-lines . 0)
          (menu-bar-lines . 1)
          (width . 80)
          (height . 58)
          (font .
                "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
          ))
     < src..

   - Convierte @k{@k{CTRL}-h} dentro @k{DEL} y @k{DEL} dentro de
     @k{@k{CTRL}-h}.

     (Algunos viejos teclados lo necesitan, aunque yo no he visto el problema
     recientemente.)

     ..src > elisp
       ;; Traducir ‘C-h’ a <DEL>.
       ; (keyboard-translate ?\C-h ?\C-?)

       ;; Traducir <DEL> a ‘C-h’.
       (keyboard-translate ?\C-? ?\C-h)
     < src..

   - ¡Desactiva un cursor oculto!

     ..src > elisp
       (if (fboundp 'blink-cursor-mode)
           (blink-cursor-mode -1))
     < src..

     o empieza GNU Emacs con el comando @c{emacs -nbc}.

   - Cuando se usa ‘grep’

     - @'{-i} :: Ignore distinciones de letras

     - @'{-n} :: El prefijo de cada línea de la salida con el número de
       líneas

     - @'{-H} :: Imprime el nombre de fichero para cada cadena encontrada.

     - @'{-e} :: Protege patrones empezando con un caracter de guión, @'{-}

       ..src > elisp
         (setq grep-command "grep -i -nH -e ")
       < src..

   - Encuentra un búfer existente, incluso si eso tiene un nombre diferente ::

     Esto evita problemas con enlaces simbólicos.

     ..src > elisp
       (setq find-file-existing-other-name t)
     < src..

   - Configura tu entorno de lenguaje y el método de entrada por defecto

     ..src > elisp
       (set-language-environment "latin-1")
       ;; Recuerda que se puede habilitar o deshabilitar el texto de lenguaje
       ;; multilingüe con el comando @c{toggle-input-method'} (@k{C-\})
       (setq default-input-method "latin-1-prefix")
     < src..

     Si se quiere escribir con el caracter Chino ‘GB’, asigna esto:

     ..src > elisp
       (set-language-environment "Chinese-GB")
       (setq default-input-method "chinese-tonepy")
     < src..

*** Arreglando Atajos de Teclados

    Algunos sistemas asocian teclas de maneras no agradables. Algunas veces,
    por ejemplo, la tecla @k{CTRL} en un modo perverso en vez de la lejanía a
    la izquierda de la fila.

    Normalmente, cuando las personas arreglan estos atajos de teclado, no se
    cambia su fichero @f{~/.emacs}. En vez de eso, se asocian las teclas
    apropiadas en sus consolas con los comandos @c{loadkeys} o
    @c{install-keymap} en su script de inicio y entonces incluyen comandos
    @c{xmodmap} en su fichero @f{.xinitrc} o @f{.Xsession} para X Windows.

    Para un script de inicio:

    ..example >
      loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

      or

      install-keymap emacs2
    < example..

    Para un fichero @f{.xinitrc} o un fichero @f{.Xsession} cuando la tecla
    @k{Caps Lock} es que tan lejos de la fila del home:

    ..example >
      # Asocia la tecla etiquetada ‘Caps Lock’ a ‘Control’
      # (Tal como un interfaz de usuario roto sugiere que el teclado hecho
      # piensa que los ordenadores son máquinas de escribir desde 1885.)

      xmodmap -e "clear Lock"
      xmodmap -e "add Control = Caps_Lock"
    < example..

    En un @f{.xinitrc} o @f{.Xsession}, para convertir una tecla @k{ALT} a
    una tecla @k{META}:

    ..example >
      # Algunos teclados mal diseñados tienen una tecla etiquetada ALT y no Meta
      xmodmap -e "keysym Alt_L = Meta_L Alt_L"
    < example..

** Una línea modificada

   Finalmente, una funcionalidad que realmente me gusta: un mode line
   modificado.

   Cuando se trabaja a través de una red, se olvida que máquina se está
   usando. También, se tiende a perder la traza de donde se está, y a qué
   línea se apunta.

   Así se resetea mi mode line para que se parezca a esto:

   ..example >
     ::-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
   < example..

   Estoy visitando un fichero llamado @f{foo.texi}, en mi máquina
   @f{rattlesnake} en mi búfer @f{/home/bob}. Yo estoy en la línea 1, en
   modo Texinfo, y estoy arriba del búfer.

   Mi fichero @f{.emacs} tiene una sección que se parece a esto:

   ..src > elisp
     ;; Asigna un Mode Line que nos cuente que máquina, que directorio,
     ;; y que línea estoy on, más la información de client.
     (setq-default mode-line-format
      (quote
       (#("-" 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        "    "
        mode-line-buffer-identification
        "    "
        (:eval (substring
                (system-name) 0 (string-match "\\..+" (system-name))))
        ":"
        default-directory
        #(" " 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (line-number-mode " Line %l ")
        global-mode-string
        #("   %[(" 0 6
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (:eval (mode-line-mode-name))
        mode-line-process
        minor-mode-alist
        #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
        ")%] "
        (-3 . "%P")
        ;;   "-%-"
        )))
   < src..

   Aquí, se redefine el mode line por defecto. La mayoría de las partes son
   desde el original; pero yo creo unos pocos cambios. Yo asigno el formato
   de mode line @e{default} así como permitir varios modos, tales como Info,
   para sobreescribirlo.

   Muchos elementos en la lista son auto-explicativos: @c{mode-line-modified}
   es una variable que cuenta si el búfer ha sido modificado, @c{mode-name}
   cuenta el nombre del modo, y así sucesivamente. Sin embargo, el formato parece
   complicado porque las dos funcionalidades no han sido discutidas.


   La nueva cadena de formato tiene una sintaxis especial:

   ..src > elisp
     #("-" 0 1 (help-echo "mouse-1: select window, ..."))
   < src..

   El @c{#(} empieza una lista. El primer elemento de la lista es la cadena
   en sí, solo un @'{-}. El segundo y tercer elemento especifica el rango a
   través del cuarto elemento aplicado. Un rango empieza @e{después} un
   carácter, así un cero significa el rango que empieza solo después del
   primer caracter; un 1 significa que el rango finaliza solo después del
   primer caracter. El tercer elemento es la propiedad para el rango. Eso
   consiste en una lista de propiedades, un nombre de propiedad, en este
   caso, @'{help-echo}, seguido por un valor, en este caso, una cadena. El
   segundo, tercer y cuarto elemento de este nuevo formato de cadena puede
   ser repetido.

   Vea la Seccion @"{Propiedades de Texto} en @e{El Manual de Referencia de
   GNU Emacs Lisp}, y ver @"{Formato Mode Line} en @e{El Manual de Referencia
   de GNU Emacs Lisp}, para más información.

   @c{mode-line-buffer-identification} muestra el nombre del buffer. Eso es
   una lista empezando por @c{(#("%12b" 0 4 …}. El @c{#(} empieza la lista.

   El @'{"%12b"} muestra el nombre del actual búfer, usando la función
   @c{buffer-name} con la que estamos familiarizados; el ‘12’ especifica el
   número máximo de caracteres que serán mostrados. Cuando un nombre tiene
   pocos caracteres, el espacio en blanco se añade para rellenar este
   número. (Los nombres del búfer puede y con frecuencia serán más largos de
   12 caracteres; esta longitud funciona bien en la típica ventana de 80
   columnas de ancho.)

   @c{:eval} dice evaluar la siguiente forma y usa el resultado como una
   cadena para mostrarse. En este caso, la expresión muestra el primer
   componente del sistema completo. El fin del primer componente es un @'{.}
   (‘periodo’), así se usa la función @c{string-match} para contar el tamaño
   del primer componente. La subcadena desde el caracter cero a este tamaño
   del primer componente. La subcadena desde el caracter cero a este tamaño
   es el nombre de la máquina.

   Esta es la expresión:

   ..src > elisp
     (:eval (substring
             (system-name) 0 (string-match "\\..+" (system-name))))
   < src..

   @'{%[} y @'{%]} causa un par de corchetes que aparezcan por cada edición
   nivel de edición recursiva editando el nivel. @'{%n} dice ‘Encoger’ cuando
   esto puede hacerse. @'{%P} te cuenta el porcentaje del búfer que está
   debajo de la ventana, o ‘arriba’, ‘abajo’, o ‘todo’. (Una minúscula @'{p}
   cuenta el porcentaje bajo el alto de la ventana.) @'{%-} inserta
   suficientes guiones para rellenar la línea.

   Recuerda, “No tiene que gustarte Emacs para que le gustes”––Emacs puede
   tener diferentes colores, diferentes comandos, y diferentes teclas que un
   Emacs por defecto.

   Por otro lado, si se quiere traer un plano ‘fuera de la caja’ Emacs, sin
   personalización, escribe:

   ..example >
     emacs -q
   < example..

   Esto inicializará un Emacs que @e{no} cargue tu @f{~/.emacs} fichero de
   inicialización. Uno plano, el que trae Emacs por defecto. Nada más.

* Depurando

  GNU Emacs tiene dos depuradores, @c{debug} y @c{edebug}. El primero es
  construido dentro de las tripas de Emacs y está siempre contigo; el segundo
  requiere que exista una función antes de que se pueda usar.

  Ambos depuradores son descritos extensivamente en Seccion @"{Depurando} en
  @e{El Manual de Referencia GNU Emacs Lisp}. En este capítulo, se explicará
  un breve ejemplo de esto.

** @c{depurar}

   Supón que se ha escrito una definición de función que se pretende devolver
   la suma de los números 1 a través de un número dado. (Esta es la función
   @c{triangle} discutida pronto. Vea la Seccion @l{Ejemplo de Decremento, ,
   Ejemplo con Contador de Decremento}, para una discusión.)

   Sin embargo, tu definición de función tiene un error. Se ha malescrito
   @'{1=} por @'{1-}. Aquí está la definición rota:

   ..src > elisp
     (defun triangle-bugged (number)
       "Devuelve suma de números 1 a través de NUMBER inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (setq number (1= number)))      ; Error aquí.
         total))
   < src..

   Si se está leyendo esto en Info, se puede evaluar esta definición en el
   modo normal. Se verá que @c{triangle-bugged} aparece en el área de eco.

   Ahora evalúa la función @c{triangle-bugged} con un argumento de 4:

   ..src > elisp
     (triangle-bugged 4)
   < src..

   En un GNU Emacs reciente, se creará e introducirá un búfer
   @f{*Backtrace*} que dice:

   ..example >
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
       (1= number)
       (setq number (1= number))
       (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
       (let ((total 0)) (while (> number 0) (setq total ...)
         (setq number ...)) total)
       triangle-bugged(4)
       eval((triangle-bugged 4))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   < example..

   (Se ha reformateado este ejemplo ligeramente; el depurador no contiene
   muchas líneas. Así, se puede salir del depurador escribiendo @k{q} en el
   buffer @f{*Backtrace*}.)

   En la práctica, debido a un error tan simple como este, la línea de ‘error
   Lisp’ explica lo que se necesita saber para corregir la definición. La
   función @c{1=} está ‘vacía’.

   Sin embargo, si no se conoce con bastante certeza lo que está pasando, se
   puede leer la traza completa.

   En este caso, se necesita ejecutar una versión reciente de GNU Emacs, que
   automáticamente empieza el depurador que pone en el búfer
   @f{*Backtrace*}; o además, se necesita para empezar el depurador
   manualmente como se describe debajo.

   Lee el búfer @f{*Backtrace*} de abajo a arriba; eso cuenta lo que le hizo
   a Emacs tener un error. Emacs hace una llamada interactiva a @k{C-x C-e} @%c(eval-last-sexp), que lleva a la evaluación de la expresión
   @c{triangle-bugged}. Cada línea de debajo cuenta lo que el intérprete Lisp
   evaluó.

   La tercera línea desde lo alto del búfer es

   ..src > elisp
     (setq number (1= number))
   < src..

   Emacs intentó evaluar esta expresión; para hacerlo así, se intentó evaluar
   la expresión interna para ser mostrada en la segunda línea desde arriba:

   ..src > elisp
     (1= number)
   < src..

   Aquí es donde el error ocurre; como se dice en la línea de arriba:

   ..example >
     Debugger entered--Lisp error: (void-function 1=)
   < example..

   Se puede corregir el error, reevalúa la definición de función, y entonces
   se puede testear de nuevo.

** @c{debug-on-entry}

   Un GNU Emacs actual abre el depurador automáticamente cuando la función
   tiene un error.

   Incidentalmente, se puede empezar el depurador manualmente para todas las
   versiones de Emacs; la ventaja es que el depurador se ejecuta incluso si
   no se tiene un error en su código. Algunas veces, ¡su código estará libre
   de errores!

   Se puede introducir el depurador cuando se llama a la función llamando
   @c{debug-on-entry}.

   Tipo:

   ..example >
     M-x debug-on-entry RET triangle-bugged RET
   < example..

   Ahora, evalúa lo siguiente:

   ..src > elisp
     (triangle-bugged 5)
   < src..

   Todas las versiones de Emacs crearán un búfer @f{*Backtrace*} y cuenta tu
   que eso es el principio para evaluar la función @c{triangle-bugged}:

   ..example >
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--entering a function:
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   < example..

   En el búfer @f{*Backtrace*}, escribe @k{d}. Emacs evaluará la primera
   expresión en @c{triangle-bugged}; el búfer se parece a esto:

   ..example >
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   < example..

   Ahora, escribe @k{d} de nuevo, ocho veces, lentamente. Cada vez que se
   escribe @k{d} Emacs evaluará otra expresión en la definición de función.

   Eventualmente, el búfer se parece a esto:

   ..example >
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (setq number (1= number))
     * (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   < example..

   Finalmente, después se escribe @k{d} dos veces más, Emacs logrará el error
   y las dos líneas superiores del buffer @f{*Backtrace*} se ve así:

   ..example >
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
     * (1= number)
     …
     ---------- Buffer: *Backtrace* ----------
   < example..

   Escribiendo @k{d}, sería capaz de pasear a través de la función.

   Se puede salir de un buffer @f{*Backtrace*} escribiendo @k{q}; esto se
   sale de la traza, pero no cancela @c{debug-on-entry}.

   Para cancelar el efecto de @c{debug-on-entry}, llama a
   @c{cancel-debug-on-entry} y el nombre de la función, como esto:

   ..example >
     M-x cancel-debug-on-entry RET triangle-bugged RET
   < example..

   (Si está leyendo esto en Info, cancela @c{debug-on-entry} ahora.)

** @c{debug-on-quit} y @c{(debug)}

   Adición a la configuración @c{debug-on-error} o llamando
   @c{debug-on-entry}, hay otros dos caminos para empezar @c{debug}.

   Se puede empezar @c{debug} siempre y cuando se escribe
   @k{C-g} @%c(keyboard-quit) se configura la variable @c{debug-on-quit} para
   @c{t}. Esto es útil para depurar bucles infinitos.

   O, se puede insertar un línea que dice @c{(debug)} dentro de tu código
   donde se quiere que el depurador empiece, así:

   ..src > elisp
     (defun triangle-bugged (number)
       "Devuelve suma de números 1 a través de NUMERO inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (debug)                         ; Empieza el depurador.
           (setq number (1= number)))      ; Error aquí.
         total))
   < src..

   La función @c{debug} se describe en detalle en @"{El Depurador Lisp} en
   @e{El Manual de Referencia GNU Emacs Lisp}.

** El depurador de nivel de fuentes @c{edebug}

   Edebug es un depurador a nivel de fuentes Edebug que normalmente muestra
   las fuentes del código que se está depurando, con una flecha a la
   izquierda que muestra que línea se está actualmente ejecutando.

   Se puede pasear a través de la ejecución de una función, línea a línea, o
   ejecutarse rápidamente hasta lograr un @:{punto de ruptura} donde la
   ejecución pare.

   Edebug se describe en Seccion @"{edebug} en @e{El Manual de Referencia de
   GNU Emacs Lisp}.

   Aquí hay una función con errores para @c{triangulo-recursivo}. Véase
   Sección @l{Recursión en lugar de un contador}, para una revisión de eso.

   ..src > elisp
     (defun triangulo-recursivo-bugged (number)
       "Devuelve la suma of números 1 a través de NUMBER inclusive.
     Usa recursión."
       (if (= number 1)
           1
         (+ number
            (triangulo-recursivo-bugged
             (1= number)))))               ; Error aquí.
   < src..

   Normalmente, se instalaría esta definición colocando su cursor después
   de la función cerrando paréntesis y escribiendo @k{C-x C-e}
   (@c{eval-last-sexp}) o lo demás colocando tu cursor con la definición y
   escribiendo @k{C-M-x} @%c(eval-defun). (Por defecto, el comando
   @c{eval-defun} funciona solo en modo Emacs Lisp o en el modo de
   interacción de Lisp.)

   Sin embargo, para preparar esta definición de función para Edebug, se debe
   primero @:{instrumentar} el código usando un comando diferente. Se puede
   hacer esto coloca el cursor dentro o después de la definición y
   escribiendo

   ..example >
     M-x edebug-defun RET
   < example..

   Esto causará que Emacs cargue Edebug automáticamente si eso no está ya
   cargado y, apropiadamente prepara la función.

   Después de preparar la función, emplaza tu cursor después de la siguiente
   expresión y escribe @k{C-x C-e} @%c(eval-last-sexp):

   ..src > elisp
     (triangulo-recursivo-bugged 3)
   < src..

   Se vuelve a las fuentes de @c{triangulo-recursivo-bugged} y el cursor se
   posiciona al principio del @c{if} de la línea de la función. También, se
   verá una flecha en la mano izquierda al lado de esta línea donde la
   función se está ejecutando. (En los siguientes ejemplos, se muestra la
   flecha con @'{=>}; en un sistema de ventanas, se puede ver la flecha como
   un triángulo sólido en el ‘borde’ de la ventana.)

   ..example >
     =>★(if (= number 1)
   < example..

   En el ejemplo, la posición del punto es mostrado con una estrella,
   @'{★} (en Info, eso es mostrado como @'{-!-}).

   Si ahora se presiona @k{SPC}, el punto se moverá a la siguiente expresión
   para ejecutarse; la línea se parece a esto:

   ..example >
     =>(if ★(= number 1)
   < example..

   Como se continua presionando @k{SPC}, el puntero se moverá desde la
   expresión a la expresión. Al mismo tiempo, siempre y cuando una expresión
   devuelva un valor, este valor será mostrado en el área de eco. Por ejemplo,
   después de mover el punto pasado @c{number}, se verá lo siguiente:

   ..example >
     Resultado: 3 (#o3, #x3, ?\C-c)
   < example..

   Esto significa el valor de @c{number} es 3, que son tres octales, tres
   hexadecimales, y @c{ascii} ‘control-c’ (la tercera letra del alfabeto, en
   caso de que se necesite conocer esta información).

   Uno puede continuar moviéndose a través del código hasta que logre la
   línea con el error. Antes de la evaluación, esta línea se parece a esto:

   ..example >
     =>        ★(1= number)))))               ; Error aquí.
   < example..

   Cuando se presiona @k{SPC} una vez de nuevo, se producirá un mensaje de
   error que dice:

   ..example >
     La definición de la función está vacío: 1=
   < example..

   Este es el error.

   Presiona @k{q} para salir de Edebug.

   Para eliminar la instrumentación desde una definición de función,
   simplemente se reevalúa con un comando que no lo instrumente. Por ejemplo,
   se podría posicionar su cursor después de la definición cerrando
   paréntesis y escribiendo @k{C-x C-e}.

   Edebug hace un gran trato antes de entrar en una función. Se puede dirigir
   así mismo, parando solo en un error o en puntos específicos, se puede
   causar para mostrar los valores cambiantes de varias expresiones; se puede
   encontrar cuantas veces una función se llama, y más.

   Edebug se describe en @"{edebug} en @e{El Manual de Referencia de GNU
   Emacs Lisp}.

** Ejercicios de depuración

   - Instale la función @c{count-words-example} y provoque que se introduzca el
     depurador construido cuando se llame. Ejecute el comando en una región
     conteniendo dos palabras. Se necesitará presionar @k{d} un número
     remarcable de veces. En el sistema, es un ‘hook’ llamado después que el
     comando se finaliza. (Para información sobre hooks, mira Seccion
     @"{Resumen del Comando Bucle} en @e{El Manual de Referencia GNU Emacs
     Lisp}.)

   - Copie @c{count-words-example} dentro del búfer @f{*scratch*}, instrumente
     la función para Edebug, y navegue a través de su ejecución. La función
     no necesita tener un error, aunque se puede introducir uno si se
     desea. Si a la función le falta un error, el paseo se completa sin
     problemas.

   - Mientras se ejecuta Edebug, escriba @k{?} para ver una lista de todos
     los comandos Edebug. (El @c{global-edebug-prefix} normalmente es @k{C-x
     X}, por ej: @k{CTRL-x} seguido por una tecla mayúscula @k{X}; use
     este prefijo para comandos hechos fuera del búfer de depuración
     Edebug.)

   - En el búfer de depuración Edebug, usa el comando
     @k{p} @%c(edebug-bounce-point) para ver si @c{count-words-example} está
     funcionando.

   - Mueve el punto a algún sitio debajo de la función y entonces escribe el
     comando @k{h} @%c(edebug-goto-here) para saltar a esta localización.

   - Usa el comando @k{t} @%c(edebug-trace-mode) para causar que Edebug
     pasee a través de la función en sí; usa una letra mayúscula @k{T} para
     @c{edebug-Trace-fast-mode}.

   - Asigna un punto de ruptura, entonces ejecuta Edebug en modo Traza hasta
     que se logre el punto de parada.

* Conclusión

  Ahora se ha llegado al fin de esta Introducción. Se ha aprendido lo
  suficiente acerca de programación en Emacs Lisp para asignar valores, para
  escribir ficheros @f{.emacs} para tí mismo y tus amigos, y escribir
  personalizaciones simples y extensiones a Emacs.

  Este es un lugar para parar. O, si se desea, se puede ir adelante, y
  aprender más por uno mismo.

  Se han aprendido algunas bases de programación. Pero solo algunas. Todavía
  hay muchas cosas que son fáciles de usar que no se han tocado.

  Otra idea para seguir es leer las fuentes de Emacs y en @e{El Manual de
  Referencia de GNU Emacs}.

  Las fuentes de Emacs Lisp son una aventura. Cuando se leen las fuentes
  vienen a través de una función o expresión que nos es familiar, se necesita
  imaginar o encontrar qué se hace.

  Ir al Manual de Referencia. Eso está a través del completo, limpio y fácil
  de leer descripción de Emacs Lisp. Está escrito no solo para expertos, pero
  sí para gente que conoce lo que usted conoce. (El @e{Manual de Referencia}
  viene con la distribución de GNU Emacs. Como esta introducción, viene como
  un fichero fuente Texinfo, así se puede leer on-line como un libro
  impreso.)

  Ir a otra ayuda on-line que sea parte de GNU Emacs: la documentación
  on-line para todas las funciones y variables, y @c{find-tag}, el programa
  que va a las fuentes.

  Aquí hay un ejemplo de cómo explorar las fuentes. Porque su nombre,
  @f{simple.el} es el fichero que se vió primero, hace tiempo. Como eso
  ocurre alguna de las funciones en @f{simple.el} son complicadas, o al menos
  parece complicado a primera vista. La función @c{open-line}, por ejemplo,
  parece complicada.

  Se puede querer pasear a través de esta función lentamente, como nosotros
  hicimos la función @c{forward-sentence}. (Vea la Seccion @l{La función
  @c{forward-sentence}}.) O se puede querer salir de esta función y mirar en
  otra, tal como @c{split-line}. No se necesita leer todas las funciones. De
  acuerdo a @c{count-words-in-defun}, la función @c{split-line} contiene 102
  palabras y símbolos.

  Incluso aunque sean pocas, @c{split-line} contiene expresiones que no se
  han estudiado: @c{skip-chars-forward}, @c{indent-to}, @c{current-column} y
  @c{insert-and-inherit}.

  Considera la función @c{skip-chars-forward}. (Eso es parte de la definición
  de función para @c{back-to-indentation}, que muestra la @l(Repaso: Cómo
  escribir definiciones de funciones<>Repaso).)

  En GNU Emacs, se puede encontrar más acerca de @c{skip-chars-forward}
  escribiendo @k{C-h f} @%c(describe-function) y el nombre de la
  función. Esto te da la documentación de función.

  Se puede ser capaz de adivinar que se hace por una función bien llamada tal
  como @c{indent-to}; o se puede buscar, también. Incidentalmente, la función
  @c{describe-function} en sí está en @f{help.el}; esta es una de estas
  largas, pero descifrables funciones. ¡Se puede buscar @c{describe-function}
  usando el comando @k{C-h f}!

  En esta instancia, desde el código es Lisp, el búfer @f{*Help*} contiene
  el nombre de la librería conteniendo las fuentes de la función. Se puede
  poner el punto a través del nombre de la librería y presiona la tecla RET,
  que está en esta situación está asociado a @c{help-follow}, y se toma
  directamente de las fuentes, en el mismo camino que @k{M-.} @%c(find-tag).

  La definición para @c{describe-function} ilustra como personalizar las
  expresiones @c{interactive} sin usar los códigos de caracter estándar y eso
  muestra como crear un búfer temporal.

  (La función @c{indent-to} es escrita en C en vez de Emacs Lisp; eso es una
  función ‘construida’. @c{help-follow} toma su fuente como @c{find-tag},
  cuando se configura apropiadamente.)

  Se puede mirar en las fuentes de la función usando @c{find-tag}, que está
  asociado a @k{M-.}. Finalmente, se puede encontrar que el Manual de
  Referencia tiene que decir visitando el manual en Info, y escribiendo
  @k{i} @%c(Info-index) y el nombre de la función, o buscando la función en el
  índice a una copia impresa del manual.

  Similarmente, se puede encontrar que significa por @c{insert-and-inherit}.

  Otros ficheros fuente interesantes incluyen @f{paragraphs.el},
  @f{loaddefs.el} y @f{loadup.el}. El fichero @f{paragraphs.el} incluye
  ordenar, funciones fácilmente comprendidas tan bien como las largas. El
  fichero @f{loaddefs.el} contiene muchos autoloads estándar y muchos mapas
  de teclado. Nunca se ha buscado en todo; solo en las partes. @f{loadup.el}
  es el fichero que carga las partes estándar de Emacs; eso cuenta un gran
  trato acerca de cómo Emacs está construido. (Vea la Seccion @"{Construyendo
  Emacs} en @e{El Manual de Referencia GNU Emacs Lisp}, para más acerca de
  construcción.)

  Como dije, se han aprendido algunas cosas; sin embargo, y de manera muy
  importante, se han tocado fuertes aspectos de la programación; no se ha
  dicho nada acerca de como ordenar la información, excepto para usar la
  función predefinida @c{sort}; no se ha dicho nada acerca de cómo almacenar
  la información, excepto para usar variables y listas; no se ha dicho nada
  acerca de como escribir programas que escriben programas. Esto son asuntos
  para otro tipo diferente de libro, un diferente tipo de aprendizaje.

  Lo que se ha hecho es aprender lo suficiente para hacer mucho trabajo
  práctico con GNU Emacs. Lo que se ha hecho es comenzar. Este es el fin del
  principio de una gran amistad.

** Apéndice A La función @c{the-the}

   Algunas veces cuando se se escribe texto, se duplican palabras––como con
   “se se” cerca del principio de esta frase. Se encuentra que lo más
   frecuente, es duplicar “el”; aquí, se llama a la función para detectar las
   palabras duplicadas, @c{the-the}.

   Como primer paso, se podrían usar las siguientes expresiones regulares
   para buscar duplicados:

   ..example >
     \\(\\w+[ \t\n]+\\)\\1
   < example..

   Este regexp asocia uno o más caracteres que constituyen palabras seguidas
   por uno o más espacios, tabuladores, o nuevas líneas. Sin embargo, eso no
   detecta palabras duplicadas en diferentes líneas, desde la finalización de
   la primera palabra, el fin de la línea, es diferente desde el fin de la
   segunda palabra, un espacio. (Para más información acerca de expresiones
   regulares, mira el Capitulo 12 @l{Búsqueda de Expresiones Regulares}, tan
   bien como la Seccion @"{Sintaxis de Expresiones Regulares} en @e{El Manual
   de GNU Emacs}, y la Seccion @"{Expresiones Regulares} en @e{El Manual de
   Referencia GNU Emacs Lisp}.)

   Se podrían intentar buscar caracteres duplicados pero no si el patrón
   detecta dobles tales como las dos ocurrencias de ‘th’ en ‘with the’.

   Otro posible regexp busca caracteres constituyentes de palabras seguidos
   por caracteres de no palabras constituyentes, reduplicadas. Aquí, @'{\\w+}
   asocia a una o más caracteres de palabras constituyente y @'{\\W*} asocia
   cero o más caracteres que no constituyen palabras.

   ..example >
     \\(\\(\\w+\\)\\W*\\)\\1
   < example..

   De nuevo, no útil.

   Aquí está el patrón que uso. No es perfecto, pero suficientemente
   bueno. @'{\\b} asocia la cadena vacía provista al principio o fin de una
   palabra; @'{[^@@ \n\t]+} asocia una o más ocurrencias de qué caracteres
   que @e{no} son un @@-signo, espacio, nueva línea, o tabulador.

   ..example >
     \\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
   < example..

   Uno puede escribir expresiones más complicadas, pero esta expresión es
   suficientemente buena así.

   Aquí está la función @c{the-the}, como se incluye en mi fichero
   @f{.emacs}, a lo largo de un atajo global manejable:

   ..src > elisp
     (defun the-the ()
       "Busca hacia adelante para una palabra duplicada."
       (interactive)
       (message "Buscando palabras duplicadas ...")
       (push-mark)
       ;; Este regexp no es perfecto
       ;; pero es limpiamente bueno a pesar de todo:
       (if (re-search-forward
            "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
           (message "Palabra encontrada duplicada.")
         (message "Fin de búfer")))

     ;; Asocia ‘the-the’ a  C-c \
     (global-set-key "\C-c\\" 'the-the)
   < src..

   Aquí está la prueba del texto:

   ..example >
     uno dos tres cuatro cinco
     cinco seis siete
   < example..

   Se pueden sustituir las otras expresiones regulares mostradas debajo en la
   definición de función y se prueba cada una de ellas en esta lista.

** Apéndice B Manejando el anillo de la muerte

   El anillo de la muerte es una lista que es transformada dentro de un
   anillo que trabaja con la función @c{current-kill}. Los comandos @c{yank}
   y @c{yank-pop} usan la función @c{current-kill}.

   Este apéndice describe la función @c{current-kill} y los comandos @c{yank}
   y @c{yank-pop}, pero primero, considere los trabajo del kill ring.

   El anillo de la muerte tiene el tamaño máximo de sesenta
   elementos; hacer una explicación con este número máximo quedaría demasiado
   larga. En vez de eso, pensemos qué ocurre si se asígna a cuatro. Por
   favor, evalúe lo siguiente:

   ..src > elisp
     (setq old-kill-ring-max kill-ring-max)
     (setq kill-ring-max 4)
   < src..

   Entonces, por favor, copie cada línea del siguiente ejemplo indentado
   dentro del anillo de la muerte. Se puede cortar cada línea
   con @k{C-k} o marcarla y copiarla con @k{M-w}.

   (En un búfer de solo lectura, tal como el búfer @f{*info*}, el comando
   kill, @k{C-k} @%c(kill-line), no eliminará el texto, solamente lo mueve
   al anillo de la muerte. Sin embargo, el ordenador puede
   avisar con un beep. Alternativamente, para silenciar, se puede copiar la
   región de cada línea con el comando @k{M-w} @%c(kill-ring-save). Se debe
   marcar cada línea de este comando para tener éxito, pero no importa si al
   final se posiciona en el punto o la marca).

   Por favor, invoque las llamadas en orden, de modo que los cinco elementos
   rellenen el anillo de la muerte.

   ..example >
     primero algo de texto
     segunda pieza de texto
     tercera línea
     cuarta línea de texto
     quinto bit de texto
   < example..

   Entonces encuentra el valor de @c{kill-ring} evaluando

   ..example >
     kill-ring
   < example..

   Eso es:

   ..src > elisp
     ("quinto bit de texto" "cuarta línea de texto"
     "tercera línea" "segunda pieza de texto")
   < src..

   El primer elemento, @'{primero algo de texto}, fué borrado.

   Para devolver el viejo valor para el tamaño del kill ring, evalúe:

   ..src > elisp
     (setq kill-ring-max old-kill-ring-max)
   < src..

*** La función @c{current-kill}

    La función @c{current-kill} cambia el elemento en el anillo de la muerte
    @e{kill ring} para el que el @c{kill-ring-yank-pointer} apunta. (También,
    la función @c{kill-new} asigna @c{kill-ring-yank-pointer} para apuntar al
    último elemento del anillo de la muerte. La función
    @c{kill-new} se usa directamente o indirectamente por @c{kill-append},
    @c{copy-region-as-kill}, @c{kill-ring-save}, @c{kill-line}, y
    @c{kill-region}.)

    La función @c{current-kill} es usada por @c{yank} y por
    @c{yank-pop}. Aquí está el código para @c{current-kill}:

    ..src > elisp
      (defun current-kill (n &optional do-not-move)
      "Rota el punto de pegue por N lugares, y entonces devuelve lo cortado.
      Si N es cero, ‘interprogram-paste-function’ se asigna, y si se llama
      devuelve una cadena, entonces esta cadena se añade al frente del
      anillo de la muerte y devuelve el último corte.
      Si el argumento opcional DO-NOT-MOVE es no nulo, entonces no muevas el
      punto de pegue; solo devuelve el Nth corte hacia adelante.
         (let ((interprogram-paste (and (= n 0)
                                        interprogram-paste-function
                                        (funcall interprogram-paste-function)))))
          (if interprogram-paste
              (progn
                ;; Deshabilita el programa de la función de corte cuando se
                ;; añade el nuevo texto al anillo de la muerte,
                ;; así Emacs no intenta poseer la selección
                ;; con idéntico texto.
                (let ((interprogram-cut-function nil))
                  (kill-new interprogram-paste))
                interprogram-paste)
            (or kill-ring (error "Kill ring is empty"))
            (let ((ARGth-kill-element
                   (nthcdr (mod (- n (length kill-ring-yank-pointer))
                                (length kill-ring))
                           kill-ring)))
              (or do-not-move
                  (setq kill-ring-yank-pointer ARGth-kill-element))
              (car ARGth-kill-element)))))
    < src..

    Recuerde también que la función @c{kill-new} asigna
    @c{kill-ring-yank-pointer} al último elemento del anillo de la muerte
    @e{kill ring}, que significa que todas las funciones lo llaman y asigna
    el valor de manera indirecta: @c{kill-append}, @c{copy-region-as-kill},
    @c{kill-ring-save}, @c{kill-line} y @c{kill-region}.

    Aquí está la línea en @c{kill-new}, que se explica en la @l{La función
    @c{kill-new}}.

    ..src > elisp
      (setq kill-ring-yank-pointer kill-ring)
    < src..

    La función @c{current-kill} parece compleja, pero usual, eso puede ser
    comprendido tomándolo aparte pieza por pieza. Primero míralo en la forma
    esquelética:

    ..src > elisp
      (defun current-kill (n &optional do-not-move)
        "Rota el punto a pegar por N lugares, y entonces devuelve el texto cortado."
        (let varlist
          body…)
    < src..

    Esta función tiene dos argumentos, uno es opcional. Hay una cadena de
    documentación. @e{No} es una función interactiva.

    El cuerpo de la definición de función es una expresión @c{let}, que por
    sí misma tiene tanto un cuerpo como una @V{varlist}.

    La expresión @c{let} declara una variable que será solo usable con las
    asociaciones de esta función. Esta variable se llama
    @c{interprogram-paste} y se copia a otro programa. No se copia con esta
    instancia de GNU Emacs. La mayoría de los sistemas de ventanas proveen
    una facilidad para pegar el interprograma. Tristemente, esta facilidad
    normalmente provee solo el último elemento. La mayoría de los sistemas de
    ventanas no han adoptado un anillo de muchas posibilidades, incluso
    aunque Emacs haya provisto esto durante décadas.

    La expresión @c{if} tiene dos partes, una si existe
    @c{interprogram-paste} y otra si no.

    Permítenos considerar el ‘si no’ o la parte else de la función
    @c{current-kill}. (La parte then usa la función @c{kill-new}, que ya
    hemos descrito. Vea la Seccion @l{La función @c{kill-new}.})

    ..src > elisp
      (or kill-ring (error "El Kill ring está vacío"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element))
    < src..

    El código primero chequea si el anillo de la muerte tiene
    contenido; de otro modo señala un error.

    Note que la expresión @c{or} es muy similar para testear el tamaño con un
    @c{if}:

    ..src > elisp
      (if (zerop (length kill-ring))          ; parte-si
          (error "Anillo de la muerte vacío"))       ; parte-entonces
        ;; No hay parte-resto
    < src..

    Si no hay nada en el anillo de la muerte, su tamaño debe
    ser cero y un mensaje de error se envía al usuario: @'{El kill ring está
    vacío}. La función @c{current-kill} usa una expresión @c{or} que es
    simple. Pero una expresión @c{if} recuerda lo que lleva.

    Esta expresión @c{if} usa la función @c{zerop} que devuelve verdadero si el
    valor que se chequea es cero. Cuando @c{zerop} chequea verdadero, la parte
    then del @c{if} se evalúa. La parte then es una lista empezando con la
    función @c{error}, que es una función que es similar a la función
    @c{message} (Vease Sección @l{message, , La Función @c{message}}) que
    imprime un mensaje de una línea en el área de eco. Sin embargo, además de
    imprimir un mensaje, @c{error} también evalúa la función que está
    embebida. Esto significa que el resto de la función no será evaluada si
    el tamaño del anillo de la muerte es cero.

    Entonces la función @c{current-kill} selecciona el elemento a
    devolver. La selección depende del número de lugares que @c{current-kill}
    rota y donde @c{kill-ring-yank-pointer} apunta.

    Lo siguiente, si el argumento @c{do-not-move} opcional es verdadero o el
    actual valor de @c{kill-ring-yank-pointer} se establece al punto de la
    lista. Finalmente, otra expresión devuelve el primer elemento de la lista
    incluso si el argumento @c{do-not-move} es verdadero.

    En mi opinión, es ligeramente erróneo, al menos para humanos, usar el
    término ‘error’ como el nombre de la función @c{error}. Un término mejor
    sería ‘cancelar’. Estrictamente hablando, de acuerdo, no se puede
    apuntar, mucho menos rotar un puntero a una lista que no tiene tamaño,
    así desde el punto de vista del ordenador, la palabra ‘error’ es
    correcta. Pero un humano espera intentar algo, si solo si se encuentra el
    anillo de la muerte esté lleno o vacío. Esto es un acto de
    exploración.

    Desde el punto de vista humano, el acto de exploración y descubrimiento
    no es necesariamente un error, y por esta razón no sería etiquetado como
    tal, incluso las vocales de un ordenador. Como tal, el código en Emacs
    implica que un humano que está actuando virtuosamente, explorando su
    entorno, está teniendo un error. Esto está mal. Incluso aunque el
    ordenador tome los mismos pasos como cuando hay ‘error’, un término tal
    como ‘cancelar’ tendría una clara connotación.

    Entre otras acciones, la else-part de la expresión @c{if} asigna el valor
    de @c{kill-ring-yank-pointer} a @c{ARGth-kill-element} cuando el kill
    ring @e{anillo de la muerte} tiene alguna cosa dentro y el valor de
    @c{do-not-move} es @c{nil}.

    El código se parece a esto:

    ..src > elisp
      (nthcdr (mod (- n (length kill-ring-yank-pointer))
                   (length kill-ring))
              kill-ring)))
    < src..

    Esto necesita algún examen. A menos que no se suponga mover el puntero, la
    función @c{current-kill} cambia donde @c{kill-ring-yank-pointer}
    apunta. Esto es lo que la expresión @c{(setq kill-ring-yank-pointer
    ARGth-kill-element)} hace. También, claramente, @c{ARGth-kill-element}
    está siendo asignado para ser igual a algún @c{cdr} del anillo de la
    muerte, usando la función @c{nthcdr} que está descrita en
    una sección temprana. (Vea la Seccion @l{copy-region-as-kill}.)  ¿Cómo se
    hace?

    Como se ha visto antes (Vease Sección @l{nthcdr}), la función @c{nthcdr}
    funciona repetidamente tomando el @c{cdr} de una lista––eso toma el
    @c{cdr}, del @c{cdr}, del @c{cdr}, …

    Las siguientes dos expresiones producen el mismo resultado:

    ..src > elisp
      (setq kill-ring-yank-pointer (cdr kill-ring))

      (setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
    < src..

    Sin embargo, la expresión @c{nthcdr} es más complicada. Usa la función
    @c{mod} para determinar que @c{cdr} para seleccionar.

    (Se recordará buscar funciones propias primero, en vez de esto, tendremos
    que ir dentro del @c{mod}.)

    La función @c{mod} devuelve el valor de su primer argumento módulo el
    segundo; que es decir, eso devuelve el resto después de dividir el primer
    argumento por el segundo. El valor devuelto tiene el mismo signo que el
    segundo argumento.

    De este modo,

    ..src > elisp
      (mod 12 4)
        ⇒ 0  ;; porque no hay resto
      (mod 13 4)
        ⇒ 1
    < src..

    En este caso, el primer argumento es con frecuencia pequeño que el
    segundo. Que está bien.

    ..src > elisp
      (mod 0 4)
        ⇒ 0
      (mod 1 4)
        ⇒ 1
    < src..

    Se puede adivinar lo que la función @c{-} hace. Eso es como @c{+} pero
    sustrae en vez de añadir; la función @c{-} sustrae su segundo argumento
    desde el primero. También, ya se sabe que la función @c{length} hace
    (Vease Sección @l{#Descubrir la longitud de una lista: @c{length}}). Eso
    devuelve el tamaño de una lista.

    Y @c{n} es el nombre del argumento requerido a la función
    @c{current-kill}.

    Así cuando el primer argumento a @c{nthcdr} es cero, la expresión
    @c{nthcdr} devuelve la lista entera, como se puede ver evaluando lo
    siguiente:

    ..src > elisp
      ;; kill-ring-yank-pointer @e{and} kill-ring @e{tener un tamaño de cuatro}
      ;; @e{and} (mod (- 0 4) 4) ⇒ 0
      (nthcdr (mod (- 0 4) 4)
              '("cuarta línea de texto"
                "tercera línea"
                "segunda pieza de texto"
                "primero algo de texto"))
    < src..

    Cuando el primer argumento a la función @c{current-kill} es uno, la
    expresión @c{nthcdr} devuelve la lista sin su primer elemento.

    ..src > elisp
      (nthcdr (mod (- 1 4) 4)
              '("cuarta línea de texto"
                "tercera línea"
                "segunda pieza de texto"
                "primero algo de texto"))
    < src..

    Incidentalmente, tanto @c{kill-ring} y @c{kill-ring-yank-pointer} son
    @:{variables globales}. Esto significa que cualquier expresión en Emacs
    Lisp puede acceder a ellas. Ellas no son como las variables locales
    asignadas por @c{let} o como los símbolos en una lista de argumentos. Las
    variables locales pueden solo ser accedidas con el @c{let} que los define
    o la función que los especifica en una lista de argumentos (y con
    expresiones llamadas por ellos).

*** @c{pegar}

    Después de aprender acerca de @c{current-kill}, el código para la función
    @c{yank} es casi fácil.

    La función @c{yank} no usa la variable @c{kill-ring-yank-pointer}
    directamente. Eso llama a @c{insert-for-yank} que llama a @c{current-kill}
    que asigna la variable @c{kill-ring-yank-pointer}.

    El código se parece a esto:

    ..src > elisp
      (defun yank (&optional arg)
        "Reinserta (\"pega\") el último logro del texto cortado.
      Más precisamente, reinserta el texto cortado más recientemente.
      Pon el punto al final, y asigna la marca al principio.
      Solo con \\[universal-argument] como argumento, lo mismo pero pon el
      punto al principio (y la marca al final). Con el argumento N, reinserta
      el N más recientemente cortado.
      Cuando este comando inserta texto cortado dentro del búfer, eso
      honra a ‘yank-excluded-properties’ y ‘yank-handler’ como se describe
      la cadena de documentación para ‘insert-for-yank-1’, que se ve.
      Ver también el comando \\[yank-pop]."
        (interactive "*P")
        (setq yank-window-start (window-start))
        ;; Si no tenemos todo el camino a través, crea last-command que
        ;; indique esto para el siguiente comando.
        (setq this-command t)
        (push-mark (point))
        (insert-for-yank (current-kill (cond
                                        ((listp arg) 0)
                                        ((eq arg '-) -2)
                                        (t (1- arg)))))
        (if (consp arg)
            ;; Esto es como like exchange-point-and-mark,
            ;;     pero no activa la marca.
            ;; Es limpio evitar la activación, incluso aunque el comando
            ;; loop would desactivaría la marca porque se
            ;; insertara el texto.
            (goto-char (prog1 (mark t)
                         (set-marker (mark-marker) (point) (current-buffer)))))
        ;; Si tenemos todo el camino, haz que this-command lo indique.
        (if (eq this-command t)
            (setq this-command 'yank))
        nil)
    < src..

    La expresión clave es @c{insert-for-yank}, que inserta la cadena devuelta
    por @c{current-kill}, pero elimina algo de propiedades de texto desde eso.

    Sin embargo, antes de tener esta expresión, la función asigna el valor de
    @c{yank-window-start} a la posición devuelta por la expresión
    @c{(window-start)}, la posición que muestra lo que actualmente empieza. La
    función @c{yank} también asigna @c{this-command} y empuja la marca.

    Después de pegar el elemento apropiado, si el argumento opcional es un
    @c{cons} en vez de un número o nada, se pone el punto al principio del
    texto pegado y se marca al final.

    (La función @c{prog1} es como @c{progn} pero devuelve el valor de su primer
    argumento en vez del valor de su último argumento. Su primer argumento
    fuerza devolver la marca del búfer como un entero. Se puede ver la
    documentación para estas funciones emplazando el punto a través de ellas en
    este búfer y entonces escribiendo @k{C-h f} @%c(describe-function) seguido
    por un @k{RET}; por defecto es la función.)

    La última parte de la función cuenta que hacer cuando eso sucede.

*** @c{yank-pop}

    Después de comprender @c{yank} y @c{current-kill}, se conoce como enfocar
    la función @c{yank-pop}. Dejando fuera la documentación para guardar el
    espacio, se parece a esto:

    ..src > elisp
      (defun yank-pop (&optional arg)
        "…"
        (interactive "*p")
        (if (not (eq last-command 'yank))
            (error "El comando previo no fué un corte"))
        (setq this-command 'yank)
        (unless arg (setq arg 1))
        (let ((inhibit-read-only t)
              (before (< (point) (mark t))))
          (if before
              (funcall (or yank-undo-function 'delete-region) (point) (mark t))
            (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
          (setq yank-undo-function nil)
          (set-marker (mark-marker) (point) (current-buffer))
          (insert-for-yank (current-kill arg))
          ;; Asigna la ventana a volver donde estaba el comando yank,
          ;; si es posible
          (set-window-start (selected-window) yank-window-start t)
          (if before
              ;; Esto es como exchange-point-and-mark,
              ;; pero no activa la marca.
              ;; Es limpio evitar la activación, incluso aunque el comando
              ;; desactivase la marca porque se insertara el texto.
              (goto-char (prog1 (mark t)
                           (set-marker (mark-marker)
                                       (point)
                                       (current-buffer))))))
        nil)
    < src..

    La función es interactive con una pequeña @'{p} así el argumento prefijo
    es procesado y pasado a la función. El comando puede solo ser usado
    después del yank previo; de otro modo un mensaje de error se envía. Este
    chequeo usa la variable @c{last-command} que se asigna por @c{yank} y
    discutida de algún modo. (Vea la Seccion @l{copy-region-as-kill}.)

    La cláusula @c{let} asigna la variable @c{before} a verdadero o falso
    dependiendo de si el punto está antes o después de la marca y entonce la
    región entre punto y marca se borra. Esta es la región que fué insertada
    por el yank previo y eso es este texto que será reemplazado.

    @c{funcall} llama a su primer argumento como una función, pasando los
    argumentos que permanecen. El primer argumento es el que la expresión
    @c{or} devuelve. Los dos argumentos que permanecen son las posiciones de
    punto y marca asignadas por el comando @c{yank} precedente.

    Hay más, pero esta es la parte más dura.

*** El fichero @f{ring.el}

    De manera interesante, GNU Emacs posee un fichero llamado @f{ring.el} que
    provee muchas de las funcionalidades que ahora se discuten. Pero las
    funciones tales como @c{kill-ring-yank-pointer} no usan esta librería,
    posiblemente porque fueron escritas pronto.

** Apéndice C @t(Un grafo con ejes etiquetados)

   Los ejes impresos ayudan a comprender un grafo. Para crear escalas. En un
   capítulo anterior (Vease Sección @l{Leyendo un grafo, , Leyendo un
   grafo}), se escribió el código para imprimir el cuerpo de un grafo. Aquí
   se escribe el código para imprimir y etiquetar ejes horizontales y
   verticales, a lo largo del cuerpo en sí.

   Puesto que las inserciones rellenan un búfer a la derecha y debajo del
   punto, el nuevo grafo imprime la función que primero imprimiría el eje
   vertical Y, después el cuerpo del grafo, y finalmente el eje horizontal
   X. Esta secuencia nos da los contenidos de la función:

   1. Configura código.

   2. Imprime el eje Y.

   3. Imprime el cuerpo del grafo.


   4. Imprime el eje X.


   Aquí hay un ejemplo de como se ve un grafo finalizado:

   ..example >
     0 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
   < example..

   En este grafo, en ambos ejes vertical y horizontal se etiquetan con
   números. Sin embargo, en algunos grafos, el eje horizontal es tiempo y
   estaría mejor etiquetarlo con meses, así:

   ..example >
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
       Enero Junio Enero
   < example..

   Dentro, con un pequeño pensamiento, se puede fácilmente venir con una
   variedad de esquemas de etiquetado verticales y horizontales. Nuestra
   tarea podría llegar a ser complicada. Pero las complicaciones generan
   confusión. En vez de permitir esto, es mejor elegir un simple esquema de
   etiquetado para nuestro primer esfuerzo, y modificarlo o reemplazarlo
   después.

   Estas consideraciones sugieren el siguiente outline para la función
   @c{print-graph}:

   ..src > elisp
     (defun print-graph (numbers-list)
       "documentation…"
       (let ((height  …
             …))
         (print-Y-axis height … )
         (graph-body-print numbers-list)
         (print-X-axis … )))
   < src..

   Nosotros podemos trabajar en cada parte de la definición de función
   @c{print-graph}.

*** La varlist @c{print-graph}

    Para escribir la función @c{print-graph}, la primera tarea es escribir la
    varlist en la expresión @c{let}. (Nosotros dejaremos por ahora cualquier
    pensamiento acerca de hacer la función interactive o acerca de los
    contenidos de su cadena de documentación.)

    La varlist asignaría varios valores. Claramente, la etiqueta superior del
    eje vertical debe ser al menos la altura del grafo, que significa que
    debe obtener esta información aquí. Note que la función
    @c{print-graph-body} también requiere esta información. No hay razón para
    calcular la altura del grafo en dos lugares diferentes, así cambiaría
    @c{print-graph-body} desde el camino que definimos pronto para tomar
    ventaja del cálculo.

    De manera similar, tanto la función para imprimir la etiqueta del eje X y
    la función @c{print-graph-body} se necesita aprender el valor del ancho
    de cada símbolo. Se puede desarrollar el cálculo aquí y cambiar la
    definición para @c{print-graph-body} desde el camino que se definió en el
    capítulo previo.

    El tamaño de la etiqueta para el eje horizontal debe ser al menos tan
    largo como el grafo. Sin embargo, esta información es usada solo en la
    función que imprime el eje horizontal, así no necesita calcularse aquí.

    Estos pensamientos nos llevan directamente a la siguiente forma para la
    varlist en el @c{let} para @c{print-graph}:

    ..src > elisp
      (let ((height (apply 'max numbers-list)) ; Primera versión.
            (symbol-width (length graph-blank)))
    < src..

    Como se verá, esta expresión no es bastante correcta.

*** La función @c{print-Y-axis}

    El trabajo de la función @c{print-Y-axis} es imprimir una etiqueta para el
    eje vertical que se parece a esto:

    ..example >
          10 -




           5 -



           1 -
    < example..

    La función se pasaría a lo alto del grafo, y así construyen e insertan los
    números y marcas apropiados.

    Es suficientemente fácil ver en la figura que la etiqueta del eje Y pero
    se puede decir en palabras, y entonces escribir una definición de función
    para hacer el trabajo es otra materia. No es bastante verdad decir que se
    quiere un número y un tic cada cinco líneas: solo hay tres líneas entre el
    @'{1} y el @'{5} (líneas 2, 3 y 4), pero cuatro líneas entre el @'{5} y el
    @'{10} (líneas 6, 7, 8 y 9). Es mejor decir que se quiere un número y un
    tic en la quinta línea desde abajo a cada línea que es un múltiplo de
    cinco.

    La siguiente cuestión es a que altura se etiquetaría. Supón que la máxima
    altura de la columna mayor del grafo es siete. La etiqueta superior en el
    eje Y sería @'{5 -}, ¿y el grafo se pegaría debajo de la etiqueta?, ¿o la
    etiqueta superior sería @'{7 -}, y marcar la vertical del grafo? ¿o sería
    la etiqueta superior @c{10 -}, que es múltiplo de cinco, y es superior al
    valor más alto del grafo?

    La última forma es preferida. La mayoría de los grafos son rectángulos
    cuyos lados son un número integral de pasos a lo largo––5, 10, 15, y así
    para un paso a distancia de cinco. Pero tan pronto se decide usar un paso
    alto para el eje vertical, se descubre que la expresión simple en la
    varlist para la altura de la computación es errónea. La expresión es
    @c{(apply 'max numbers-list)}. Esto devuelve la altura precisa, no la
    altura máxima más de lo que es necesario para redondear el múltiplo de
    cinco. Una expresión más compleja es requerida.

    Como es normal en casos como este, un problema complejo llega a ser simple
    si está dividido en varios problemas pequeños.

    Primero, considere el caso cuando el valor superior del grafo es un
    múltiplo integral de cinco––cuando eso es 5, 10, 15, o algún múltiplo de
    cinco. Se puede usar este valor como la altura del eje Y.

    Un camino simple y limpio para determinar si un número es múltiplo de
    cinco se divide por cinco y mira si la división devuelve resto. Si no hay
    resto, el número es un múltiplo de cinco. De este modo, siete dividido
    tiene un resto de dos, y siete no es un entero múltiplo de cinco. Dicho de
    otra manera, recordando la escuela, cinco entre siete es uno y me llevo
    dos. Sin embargo, diez entre dos, no tiene resto: diez es un múltiplo
    entero de cinco.

**** Viaje lateral: Calcula un resto

     En Lisp, la función para calcular un resto es @c{%}. La función devuelve
     el resto de su primer argumento dividido por su segundo argumento. Como
     ocurre, @c{%} es una función en Emacs Lisp que no se puede implementar
     usando @c{apropos}: no se puede encontrar nada si se escribe @k{M-x
     apropos @k{RET} resto @k{RET}}. El único camino para aprender la
     existencia de @c{%} es leer acerca de eso en un libro tal como este o en
     las fuentes de Emacs Lisp.

     Se puede probar la función @c{%} evaluando las siguientes dos
     expresiones:

     ..src > elisp
       (% 7 5)

       (% 10 5)
     < src..

     La primera expresión devuelve 2 y la segunda expresión devuelve 0.

     Para probar si el valor devuelto es cero o algún otro número, se puede
     usar la función @c{zerop}. Esta función devuelve @c{t} si su argumento
     debe ser un número, es cero.

     ..src > elisp
       (zerop (% 7 5))
            ⇒ nil

       (zerop (% 10 5))
            ⇒ t
     < src..

     De este modo, la siguiente expresión devolverá @c{t} si la altura del
     grafo es divisible por cinco:

     ..src > elisp
       (zerop (% height 5))
     < src..

     (El valor de @c{height}, de acuerdo, puede ser encontrado desde
     @c{(apply 'max numbers-list)}.)

     Por otro lado, si el valor de @c{height} no es un múltiplo de cinco,
     nosotros queremos resetear el valor al siguiente múltiplo de cinco. Esta
     es la aritmética sencilla usando funciones con las que ya se está
     familiarizado. Primero, se divide el valor de @c{height} por cinco para
     determinar cuantas veces cinco va dentro del número. De este modo, cinco
     va dentro doce veces. Si se añade uno a este cociente y se multiplica
     por cinco, obtendremos el valor del siguiente múltiplo de cinco que es
     más largo que el mayor. Cinco va dentro de doce dos veces. Añade uno a
     dos, y multiplica por cinco; el resultado es quince, que es el siguiente
     múltiplo de cinco que es mayor de doce. La expresión Lisp para esto es:

     ..src > elisp
       (* (1+ (/ height 5)) 5)
     < src..

     Por ejemplo, si se evalúa lo siguiente, el resultado es 15:

     ..src > elisp
       (* (1+ (/ 12 5)) 5)
     < src..

     Todo a través de esta discusión, se ha estado usando ‘cinco’ como el
     valor para las etiquetas espaciadas en el eje Y; pero se puede querer
     usar algún otro valor. Generalmente, reemplazaría ‘cinco’ con una
     variable a la que poder asignar un valor. El mejor nombre que puedo
     pensar para esta variable es @c{Y-axis-label-spacing}.

     Usando este término, y una expresión @c{if}, se produce lo siguiente:

     ..src > elisp
       (if (zerop (% height Y-axis-label-spacing))
           height
         ;; else
         (* (1+ (/ height Y-axis-label-spacing))
            Y-axis-label-spacing))
     < src..

     Esta expresión devuelve el valor de @c{height} en sí si la altura es
     incluso un múltiplo del valor del @c{Y-axis-label-spacing} o lo demás
     computa y devuelve un valor de @c{height} que es igual al siguiente
     múltiplo mayor del valor del @c{Y-axis-label-spacing}.

     Se puede ahora incluir esta expresión en la expresión @c{let} de la
     función @c{print-graph} (después de la primera configuración del valor
     de @c{Y-axis-label-spacing}):

     ..src > elisp
       (defvar Y-axis-label-spacing 5
         "Número de líneas desde una etiqueta del eje Y al siguiente.")

       …
       (let* ((height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; else
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (symbol-width (length graph-blank))))
       …
     < src..

     (Note que el uso de la función @c{let*}: el valor inicial de la altura
     es calculada una vez por la expresión @c{(apply 'max numbers-list)} y
     entonces el valor resultado de @c{height} es usado para computar su
     valor final. Vea la Seccion @l{La expresión @c{let*}}, para más acerca de
     @c{let*}.)

**** Construye un elemento del eje Y

     Cuando se imprime el eje vertical, se quieren insertar cadenas tales
     como @'{5 -} y @'{10 - } cada cinco líneas. Más allá, se quieren los
     números agitados para alinear, así pocos números deben ser acuñados con
     espacios de guía. Si alguna de las cadenas usan dos dígitos, las cadenas
     con un simple dígito deben incluir una guía en blanco antes del número.

     Para figurarse el tamaño del número, se usa la función @c{length}. Pero
     la función @c{length} funciona solo con una cadena, no con un
     número. Así el número tiene que ser convertido desde un número a una
     cadena. Esto se hace con la función @c{number-to-string}. Por ejemplo,

     ..src > elisp
       (length (number-to-string 35))
            ⇒ 2

       (length (number-to-string 100))
            ⇒ 3
     < src..

     (@c{number-to-string} se llama @c{int-to-string}; se verá este nombre
     alternativo en varias fuentes.)

     Además, en cada etiqueta, cada número es seguido por una cadena tal como
     @'{ - }, que llamará al marcador @c{Y-axis-tic}. Esta variable está
     definida con @c{defvar}:

     ..src > elisp
       (defvar Y-axis-tic " - "
          "La Cadena que sigue el número en una etiqueta del eje Y.")
     < src..

     El tamaño de la etiqueta Y es la suma del tamaño del eje Y y el tamaño
     del número del alto del grafo.

     ..src > elisp
       (length (concat (number-to-string height) Y-axis-tic)))
     < src..

     Este valor será calculado por la función @c{print-graph} en su varlist
     como @c{full-Y-label-width} y se pasa dentro. (Note que no se pensaba en
     incluir esto en el varlist cuando se propuso.)

     Para crear un eje vertical completo, una marca de tic es concatenada con
     un número; y los dos juntos pueden ser precedidos por uno o más espacios
     dependiendo de cómo de largo es el número. La etiqueta consiste de tres
     partes: los espacios que se lideran (opcional), el número, y la marca
     tic. La función se pasa al valor del número para la fila específica, y
     el valor del ancho de la línea de arriba, que es calculada (solo una
     vez) por @c{print-graph}.

     ..src > elisp
       (defun Y-axis-element (number full-Y-label-width)
         "Construye una etiqueta NUMERADA
       Un elemento numerado se parece a esto ‘ 5 - ’,
       y está tan acuñado como se necesita así todo se
       alinea con el elemento para el número mayor."
         (let* ((leading-spaces
                (- full-Y-label-width
                   (length
                    (concat (number-to-string number)
                            Y-axis-tic)))))
           (concat
            (make-string leading-spaces ? )
            (number-to-string number)
            Y-axis-tic)))
     < src..

     La función @c{Y-axis-element} concatena junto los espacios que se
     lideran si cualquiera; el número, como una cadena; y la marca tic.

     Para imaginarnos cuantos espacios guía la etiqueta necesita, la función
     sustrae el tamaño de la etiqueta––el tamaño del número más el tamaño de
     la marca tic––desde el ancho de la etiqueta deseada.

     Los espacios en blanco se insertan usando la función
     @c{make-string}. Esta función tiene dos argumentos: lo primero cuenta
     como de larga será a cadena y el segundo es un símbolo para el caracter
     a insertar, en un formato espcial. El formato es una marca de pregunta
     seguida por un espacio en blanco, como este, @'{?}. Vea la Seccion
     @"{Tipo de Caracter} en @e{El Manual de Referencia Emacs Lisp}, para una
     descripción de la sintaxis para caracteres. (De acuerdo, se podría
     querer reemplazar el espacio en blanco por algún otro caracter …. Tu
     sabes qué hacer.)

     La función @c{number-to-string} es usada en la expresión de
     concatenación, para convertir el número a una cadena que es concatenada
     con los espacios que se lideran y la marca de tic.

**** Crea un eje de la columna Y

     Las funciones precedentes proporcionan todas las herramientas necesarias
     para construir una función que genera una lista de cadenas enumeradas y
     en blanco para inserta como la etiqueta para el eje vertical:

     ..src > elisp
       (defun Y-axis-column (height width-of-label)
         "Construye la lista de ejes Y etiquetadas y cadenas en blanco.
       Para height @e{la altura} de la línea de debajo y width-of-label."
         (let (Y-axis)
           (while (> height 1)
             (if (zerop (% height Y-axis-label-spacing))
                 ;; Insertar etiqueta.
                 (setq Y-axis
                       (cons
                        (Y-axis-element height width-of-label)
                        Y-axis))
               ;; Else, insertar blancos.
               (setq Y-axis
                     (cons
                      (make-string width-of-label ? )
                      Y-axis)))
             (setq height (1- height)))
           ;; Insertar la línea base.
           (setq Y-axis
                 (cons (Y-axis-element 1 width-of-label) Y-axis))
           (nreverse Y-axis)))
     < src..

     En esta función, nosotros empezamos con el valor de @c{height} y
     repetitivamente sustrae uno desde su valor. Después de cada sustración,
     se chequea para ver si el valor es una integral múltiple del
     @c{Y-axis-label-spacing}. Si eso es, se construye una etiqueta numerada
     usando la función @c{Y-axis-element}; si no, se construye una etiqueta
     blanca usando la función @c{make-string}. La línea base consiste del
     número uno seguido por una marca tic.

**** La versión no demasiado final de @c{print-Y-axis}

     La lista construida por la función @c{Y-axis-column} está pasada a la
     función @c{print-Y-axis}, que inserta la lista como una columna.

     ..src > elisp
       (defun print-Y-axis (height full-Y-label-width)
         "Inserta el eje Y usando HEIGHT y FULL-Y-LABEL-WIDTH.
       La altura debe ser la máxima altura del grafo.
       El ancho completo es el ancho del mayor elemento de la
       etiqueta"
       ;; El valor del alto y full-Y-label-width
       ;; son pasadas por ‘print-graph’.
         (let ((start (point)))
           (insert-rectangle
            (Y-axis-column height full-Y-label-width))
           ;; Posiciona el punto listo para inserta el grafo.
           (goto-char start)
           ;; @e{Mueve el punto hacia adelante por valor de} full-Y-label-width
           (forward-char full-Y-label-width)))
     < src..

     El @c{print-Y-axis} usa la función @c{insert-rectangle} para inserta el
     eje Y creado por la función @c{Y-axis-column}. Además, eso emplaza el
     punto en la posición correcta para imprimir el cuerpo del grafo.

     Se puede probar @c{print-Y-axis}:

     - Instalar

       ..example >
         Y-axis-label-spacing
         Y-axis-tic
         Y-axis-element
         Y-axis-column
         print-Y-axis
       < example..

     - Copia la siguiente expresión:

       ..src > elisp
         (print-Y-axis 12 5)
       < src..

     - Cambia al búfer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M::} @%c(eval-expression).

     - Pega la expresión @c{graph-body-print} dentro del minibúfer con
       @k{C-y} @%c(yank).


     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá etiquetas verticalmente, el primero siendo @'{10 -
     }. (La función @c{print-graph} pasará el valor de
     @c{height-of-top-line}, que en este caso finalizará en 15, por esto lo
     que se obtiene podría aparecer como un error.)

*** La función @c{print-X-axis}

    Las etiquetas del eje X son como las etiquetas del eje Y, excepto que los
    ticks son un línea debajo de los números. Las etiquetas se parece como
    esto:

    ..example >
      |   |    |    |
      1   5   10   15
    < example..

    El primer tic está bajo la primera columna del grafo y está precedido por
    varios espacios en blanco. Estos espacios proporcionan la habitación en
    filas de debajo para las etiquetas del eje Y. El segundo, tercer, cuarto,
    y subsiguientes ticks son todos espaciados igualmente, de acuerdo al valor
    de @c{X-axis-label-spacing}.

    La segunda fila del eje X consiste de números, precedidos por varios
    espacios en blanco y también separado de acuerdo al valor de la variable
    @c{X-axis-label-spacing}.

    El valor de la variable @c{X-axis-label-spacing} sería medido en unidades
    de @c{symbol-width}, puesto que se puede querer cambiar el ancho de los
    símbolos que estás usando para imprimir el cuerpo del grafo sin cambiar
    los caminos del grafo que está etiquetado.

    La función @c{print-X-axis} está construida más o menos del mismo modo
    como que la función @c{print-Y-axis} excepto que tiene dos líneas: la
    línea de marcas tic y los números. Nosotros escribiremos una función
    separado a imprimir cada línea y entonces combinarlo con la función
    @c{print-X-axis}.

    Esto es un proceso de tres pasos:

    1. Escribe una función para imprimir el eje X marca tic,
       @c{print-X-axis-tic-line}.

    2. Escribe una función imprime los números X,
       @c{print-X-axis-numbered-line}.

    3. Escribe una función para imprimir ambas líneas, la función
       @c{print-X-axis}, usando @c{print-X-axis-tic-line} y
       @c{print-X-axis-numbered-line}.

**** Eje X marca tic

     La primera función imprimiría las marcas de tic del eje X. Se deben
     especificar las marcas en sí y su espacio:

     ..src > elisp
       (defvar X-axis-label-spacing
         (if (boundp 'graph-blank)
             (* 5 (length graph-blank)) 5)
         "Números de unidades desde un eje X al siguiente.")
     < src..

     (Note que el valor de @c{graph-blank} est'a asignado por otro
     @c{defvar}. El predicado @c{boundp} chequea si ya ha sido asignado;
     @c{boundp} devuelve @c{nil} si no lo tiene. Si @c{graph-blank} fuera
     disociado y no usara esta construcción condicional, en un GNU Emacs
     reciente, se introduciría el depurador y mirará un mensaje de error
     diciendo @'{Debugger entered--Lisp error: (void-variable graph-blank)}

     Aquí está el @c{defvar} para @c{X-axis-tic-symbol}:

     ..src > elisp
       (defvar X-axis-tic-symbol "|"
         "Cadena para insertar para apuntar a una columna en el eje X.")
     < src..

     El objetivo es crear una línea que se parece a esto:

     ..example >
       |   |    |    |
     < example..

     El primer tic es indentado así que está bajo la primera columna, que es
     indentado para proveer espacio para las etiquetas del eje Y.

     Un elemento tic consiste en espacios en blanco que se extienden desde un
     tic al siguiente más un símbolo tic. El número de espacios en blanco se
     determinan por el ancho del símbolo tic y el @c{X-axis-label-spacing}.

     El código se parece a esto:

     ..src > elisp
       ;;; X-axis-tic-element
       …
       (concat
        (make-string
         ;; Crea una cadena de blancos.
         (-  (* symbol-width X-axis-label-spacing)
             (length X-axis-tic-symbol))
         ? )
        ;; Concatena blancos con símbolos.
        X-axis-tic-symbol)
       …
     < src..

     Lo siguiente, determina cuantos espacios en blanco son necesarios para
     indentar la primera marca tic a la primera del grafo. Esto usa el valor
     de @c{full-Y-label-width} pasaba por la función @c{print-graph}.

     El código para crear @c{X-axis-leading-spaces} se parece a esto:

     ..src > elisp
       ;; X-axis-leading-spaces
       …
       (make-string full-Y-label-width ? )
       …
     < src..

     También necesita determinar el tamaño del eje horizontal, que es el
     tamaño de la lista de números, y el número de ticks en el eje
     horizontal:

     ..src > elisp
       ;; X-length
       …
       (length numbers-list)

       ;; tic-width
       …
       (* symbol-width X-axis-label-spacing)

       ;; number-of-X-ticks
       (if (zerop (% (X-length tic-width)))
           (/ (X-length tic-width))
         (1+ (/ (X-length tic-width))))
     < src..

     Todo esto lidera directamente a la función para imprimir el eje X:

     ..src > elisp
       (defun print-X-axis-tic-line
         (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
         "Imprime ticks para el eje X."
           (insert X-axis-leading-spaces)
           (insert X-axis-tic-symbol)  ; En la primera columna.
           ;; Inserta el segundo tic en el lugar adecuado.
           (insert (concat
                    (make-string
                     (-  (* symbol-width X-axis-label-spacing)
                         ;; Inserta el espacio en blanco al segundo símbolo tic.
                         (* 2 (length X-axis-tic-symbol)))
                     ? )
                    X-axis-tic-symbol))
           ;; Inserta los ticks que permanecen.
           (while (> number-of-X-tics 1)
             (insert X-axis-tic-element)
             (setq number-of-X-tics (1- number-of-X-tics))))
     < src..

     La línea de números es igualmente simple:

     Primero, creamos un elemento numerado con espacios en blanco antes de
     cada número:

     ..src > elisp
       (defun X-axis-element (number)
         "Construye un elemento del eje X numerado."
         (let ((leading-spaces
                (-  (* symbol-width X-axis-label-spacing)
                    (length (number-to-string number)))))
           (concat (make-string leading-spaces ? )
                   (number-to-string number))))
     < src..

     Lo siguiente, se crea la función para imprimir la línea numerada,
     empezando con el número “1” para la primera columna:

     ..src > elisp
       (defun print-X-axis-numbered-line
         (number-of-X-tics X-axis-leading-spaces)
         "Imprime la líneas de números del eje X"
         (let ((number X-axis-label-spacing))
           (insert X-axis-leading-spaces)
           (insert "1")
           (insert (concat
                    (make-string
                     ;; Inserta espacios en blanco al siguiente número.
                     (-  (* symbol-width X-axis-label-spacing) 2)
                     ? )
                    (number-to-string number)))
           ;; Insertar números.
           (setq number (+ number X-axis-label-spacing))
           (while (> number-of-X-tics 1)
             (insert (X-axis-element number))
             (setq number (+ number X-axis-label-spacing))
             (setq number-of-X-tics (1- number-of-X-tics)))))
     < src..

     Finalmente, se necesita escribir lo que @c{print-X-axis} que usa
     @c{print-X-axis-tic-line} y @c{print-X-axis-numbered-line}.

     La función debe determinar los valores locales de las variables usadas
     por @c{print-X-axis-tic-line} y @c{print-X-axis-numbered-line}, y
     entonces eso debe llamarlas. También, debe imprimir el retorno de carro
     que separe las dos líneas.

     La función consiste de una varlist que especifica cinco variables
     locales, y llama cada una de las dos líneas imprimiendo funciones:

     ..src > elisp
       (defun print-X-axis (numbers-list)
         "Imprime el eje X etique al tamaño de NUMBERS-LIST."
         (let* ((leading-spaces
                 (make-string full-Y-label-width ? ))
              ;; symbol-width @e{se provee por} graph-body-print
              (tic-width (* symbol-width X-axis-label-spacing))
              (X-length (length numbers-list))
              (X-tic
               (concat
                (make-string
                 ;; Crea una cadena de espacios en blanco.
                 (-  (* symbol-width X-axis-label-spacing)
                     (length X-axis-tic-symbol))
                 ? )
                ;; Concatena espacio en blanco con símbolos
                tic.
                X-axis-tic-symbol))
              (tic-number
               (if (zerop (% X-length tic-width))
                   (/ X-length tic-width)
                 (1+ (/ X-length tic-width)))))
           (print-X-axis-tic-line tic-number leading-spaces X-tic)
           (insert "\n")
           (print-X-axis-numbered-line tic-number leading-spaces)))
     < src..

     Se puede testear @c{print-X-axis}:

     - Instale @c{X-axis-tic-symbol}, @c{X-axis-label-spacing},
       @c{print-X-axis-tic-line}, tanto como @c{X-axis-element},
       @c{print-X-axis-numbered-line}, y @c{print-X-axis}.

     - Copia la siguiente expresión:

       ..src > elisp
         (progn
          (let ((full-Y-label-width 5)
                (symbol-width 1))
            (print-X-axis
             '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
       < src..

     - Cambia al búfer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M::} @%c(eval-expression).

     - Pegue la expresión de test dentro del minibuffer con @k{C-y}
       (@c{yank}).


     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá el eje horizontal así

     ..example >
       |   |    |    |    |
       1   5   10   15   20
     < example..

** Imprimiendo el grafo completo

   Ahora estamos listos para imprimir el grafo completo.

   La función para imprimir el grafo con las etiquetas apropiadas sigue el
   esquema que creamos antes (Vease Sección @l{Un Grafo con Ejes
   Etiquetados}), pero con adiciones.

   Aquí está el esquema:

   ..src > elisp
     (defun print-graph (numbers-list)
       "documentation…"
       (let ((height  …
             …))
         (print-Y-axis height … )
         (graph-body-print numbers-list)
         (print-X-axis … )))
   < src..

   La versión final es diferente desde que se planea en dos caminos: primero,
   contiene los valores adicionales calculadas una vez que en la varlist;
   segundo, eso trae una opción para específicar las etiquetas se incrementa
   la fila. Esta última funcionalidad cambia a ser esencial; de otro modo, un
   grafo puede tener más filas que ajustarse en una muestra o en una hoja de
   papel.

   Esta nueva funcionalidad requiere un cambio a la función
   @c{Y-axis-column}, para añadir @c{vertical-step} para eso. Esta función es
   parece a esto:

   ..src > elisp
     ;;; Versión Final.
     (defun Y-axis-column
       (height width-of-label &optional vertical-step)
       "Construye una lista de etiquetas para el eje Y.
     HEIGHT es la máxima altura del grafo.
     WIDTH-OF-LABEL es el máximo ancho de la etiqueta.
     VERTICAL-STEP, una opción, es un entero positivo
     que especifica cuanto una etiqueta de eje Y incrementa
     cada línea. Por ejemplo, un paso de 5
     significa que cada línea es cinco unidades
     del grafo."
       (let (Y-axis
             (number-per-line (or vertical-step 1)))
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; Inserta etiqueta.
               (setq Y-axis
                     (cons
                      (Y-axis-element
                       (* height number-per-line)
                       width-of-label)
                      Y-axis))
             ;; Else, inserta espacios en blanco.
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; Inserta línea base.
         (setq Y-axis (cons (Y-axis-element
                             (or vertical-step 1)
                             width-of-label)
                            Y-axis))
         (nreverse Y-axis)))
   < src..

   Los valores para la máxima altura del grafo y el ancho de un símbolo se
   computan por @c{print-graph} es su expresión @c{let}; así
   @c{graph-body-print} debe ser cambiado para aceptarlos.

   ..src > elisp
     ;;; Versión Final.
     (defun graph-body-print (numbers-list height symbol-width)
       "Imprime una gráfica de barras del NUMBERS-LIST.
     El numbers-list consiste en los valores del eje Y.
     HEIGHT es la máxisma altura del grafo.
     SYMBOL-WIDTH es el número de cada columna."
       (let (from-position)
         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; Dibuja el grafo columna por columna.
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; Posiciona el punto para las etiquetas del eje X.
         (forward-line height)
         (insert "\n")))
   < src..

   Finalmente, el código para la función @c{print-graph}:

   ..src > elisp
     ;;; Versión Final.
     (defun print-graph
       (numbers-list &optional vertical-step)
       "El gráfico de barras etiquetadas del NUMBERS-LIST.
     El numbers-list consiste en los valores de eje Y.

     Opcionalmente, VERTICAL-STEP, un entero positivo, especifica cuanto el
     eje Y incrementa cada línea. Por ejemplo, un paso de 5
     significa que cada fila es de cinco unidades.
       (let* ((symbol-width (length graph-blank))
              ;; @c{height} @e{en ambos es el número más largo}
              ;; y el número con la mayoría de los digitos.
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; else
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))

         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
          numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list)))
   < src..

**** Testeando @c{print-graph}

     Se puede probar la función @c{print-graph} con una lista ordenada de
     números:

     - Instala las versiones finales de @c{Y-axis-column},
       @c{graph-body-print}, y @c{print-graph} (además del resto del código.)

     - Copia la siguiente expresión:

       ..src > elisp
         (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
       < src..

     - Cambia al búfer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M::} @%c(eval-expression).

     - Pegue la expresión de test dentro del minibuffer con @k{C-y}
       (@c{yank}).


     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá un grafo que se parece a:

     ..example >
       10 -


                *
               **   *
        5 -   ****  *
              **** ***
            * *********
            ************
        1 - *************

            |   |    |    |
            1   5   10   15
     < example..

     Por otro lado, si se pasa a @c{print-graph} un @c{vertical-step} valor
     de 2, evaluando esta expresión:

     ..src > elisp
       (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
     < src..

     El grafo se parece a esto:

     ..example >
       20 -


                *
               **   *
       10 -   ****  *
              **** ***
            * *********
            ************
        2 - *************

            |   |    |    |
            1   5   10   15
     < example..

     (Una pregunta: ¿es el ‘2’ debajo del eje vertical un error o una
     funcionalidad? Si se piensa que es un error, y sería un ‘1’, (o incluso
     un ‘0’), se pueden modificar las fuentes.)

**** Creando gráficas de números de palabras y símbolos

     Ahora para el gráfico para el que todo este código fué escrito: un
     gráfico que muestra cuantas definiciones de función contienen unas pocas
     10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y
     símbolos, cuantos contienen entre 20 y 29 palabras y símbolos, y así sucesivamente.

     Esto es un proceso de múltiples pasos. Primero asegúrate que has cargado
     todo el requisito del código.

     Eso es una buena idea para eliminar el valor de @c{top-of-ranges} en
     caso de que has asignado a algún valor diferente. Se puede evaluar lo
     siguiente:

     ..src > elisp
       (setq top-of-ranges
        '(10  20  30  40  50
          60  70  80  90 100
         110 120 130 140 150
         160 170 180 190 200
         210 220 230 240 250
         260 270 280 290 300)
     < src..

     Lo siguiente crea una lista del número de palabras y símbolos en cada
     rango.

     Evalúa lo siguiente:

     ..src > elisp
       (setq list-for-graph
              (defuns-per-range
                (sort
                 (recursive-lengths-list-many-files
                  (directory-files "/usr/local/emacs/lisp"
                                   t ".+el$"))
                 '<)
                top-of-ranges))
     < src..

     En mi vieja máquina, esto lleva como una hora. Se parece a 303 ficheros
     Lisp en mi copia de Emacs version 19.23. Después de toda esta
     computación, el @c{list-for-graph} tenía este valor:

     ..src > elisp
       (537 1027 955 785 594 483 349 292 224 199 166 120 116 99
       90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
     < src..

     Esto significa que mi copia de Emacs tiene 537 definiciones de funciones
     con poco menos de 10 palabras o símbolos en sí, 1027 definiciones de
     función con 10 a 19 palabras o símbolos dentro, 955 definiciones de
     función con 20 a 29 palabras o símbolos dentro, y así sucesivamente.

     Claramente, solo buscando esta lista se puede ver que la mayoría de
     definiciones de función contienen de diez a treinta palabras y símbolos.

     Ahora para imprimir. Nosotros @e{no} queremos imprimir un grafo que es
     de 1030 líneas de alto …. En vez de eso, imprimiría un grafo que es
     mejor que venticinco líneas de alto. Un grafo cuya altura puede ser
     mostrada en casi cualquier monitor, y fácilmente impreso en una hoja de
     papel.

     Esto significa que cada valor en @c{list-for-graph} debe ser reducido a
     un quinceavo de su valor presente.

     Aquí hay una corta función para hacer esto, usando dos funciones que no
     se han visto todavía, @c{mapcar} y @c{lambda}.

     ..src > elisp
       (defun one-fiftieth (full-range)
         "Devuelve la lista, con el cincuenteavo de cada elemento."
        (mapcar '(lambda (arg) (/ arg 50)) full-range))
     < src..

**** Una expresión @c{lambda}: Anonimicidad útil

     @c{lambda} es el símbolo para una función anónima, una función sin un
     nombre. Cada vez que se use una función anónima, se necesita incluir su
     cuerpo completo.

     De este modo,

     ..src > elisp
       (lambda (arg) (/ arg 50))
     < src..

     es una definición de función que dice ‘devuelve el valor resultante de
     dividir cualquier cosa que es pasada como @c{arg} por 50’.

     Pronto, por ejemplo, se tenía una función @c{multiply-by-seven}; se
     multiplica su argumento por 7. Esta función es similar, excepto que
     divide su argumento por 50; y, no tiene nombre. El equivalente anónimo
     de @c{multiply-by-seven} es:

     ..src > elisp
       (lambda (number) (* 7 number))
     < src..

     (Vea la Seccion @l{La forma especial @c{defun}}.)

     Si queremos multiplicar 3 por 7, podemos escribir:

     ..art >
       (multiply-by-seven 3)
        \_______________/ ^
                |         |
             función  argumento
     < art..

     Esta expresión devuelve 21.

     De manera similar, se puede escribir:

     ..art >
       ((lambda (number) (* 7 number)) 3)
        \____________________________/ ^
                      |                |
             función anónima     argumento
     < art..

     Si queremos dividir 100 por 50, se puede escribir:

     ..art >
       ((lambda (arg) (/ arg 50)) 100)
        \______________________/  \_/
                    |              |
            función anónima   argumento
     < art..

     Esta expresión devuelve 2. El 100 es pasado para la función, que divide
     este número por 50.

     Vea la Seccion @"{Expresiones Lambda} en @e{El Manual de Referencia GNU
     Emacs Lisp}, para más acerca de @c{lambda}. Lisp y expresiones Lambda se
     derivan del Cálculo Lambda.

*** La función @c{mapcar}

    @c{mapcar} es una función que llama a su primer argumento con cada
    elemento de su segundo argumento. El segundo argumento debe ser una
    secuencia.

    La parte @'{map} del nombre viene de la frase matemática, ‘mapeando a
    través de un dominio’, significa hace apply a una función a cada uno de
    los elementos en un dominio. La frase matemática está basada en la
    metáfora de un superviviente paseando, un paso en un momento, a través de
    un área él está mapeando. Y @'{car}, de acuerdo, viene desde la noción
    Lisp del primero de una lista.

    Por ejemplo,

    ..src > elisp
      (mapcar '1+ '(2 4 6))
           ⇒ (3 5 7)
    < src..

    La función @c{1+} añade uno a su argumento, es ejecutada en @e{each} de
    la lista, y una nueva lista es devuelta.

    En contraste con esto @c{apply}, se aplica su primer argumento a todo lo
    que permanece. (Vea la Seccion @l{Leyendo un grafo}, para una explicación
    de @c{apply}.)

    En la definición de @c{one-fiftieth}, el primer argumento es la función
    anónima:

    ..src > elisp
      (lambda (arg) (/ arg 50))
    < src..

    y el segundo argumento es @c{full-range}, que será asociado para
    @c{list-for-graph}.

    La expresión completa se parece a esto:

    ..src > elisp
      (mapcar (lambda (arg) (/ arg 50)) full-range))
    < src..

    Vea la Seccion @"{Mapeando Funciones} en @e{El Manual de Referencia de GNU
    Emacs Lisp}, para más acerca de @c{mapcar}.

    Usando la función @c{one-fiftieth}, se puede generar una lista en el que
    cada elemento es un cincuenteavo del tamaño del correspondiente elemento
    en @c{list-for-graph}.

    ..src > elisp
      (setq fiftieth-list-for-graph
            (one-fiftieth list-for-graph))
    < src..

    La lista resultante se parece a esto:

    ..src > elisp
      (10 20 19 15 11 9 6 5 4 3 3 2 2
      1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
    < src..

    Así, ¡ya estamos casi listos para imprimir!  (También se notifica la
    pérdida de información: muchos de los rangos superiores son 0, esto
    significa que menos de 50 funciones tenían muchas palabras o
    símbolos––pero no necesariamente significando que niguna tenía muchas
    palabras o símbolos.)

**** Otro error … más insidioso

     ¡Se dijo ‘casi listo para imprimir’! De acuerdo, hay un error en la
     función @c{print-graph} …. Esta tiene una opción @c{vertical-step}, pero
     no una opción @c{horizontal-step}. La escala @c{top-of-range} va desde
     10 a 300 por decenas. Pero la función @c{print-graph} imprimirá solo uno
     por uno.

     Esto es un ejemplo clásico de lo que algunos consideramos el tipo más
     insidioso de error, el error de omisión. Este no es el tipo de error que
     se puede encontrar estudiando el código, para eso no es el código; es
     una funcionalidad omitida. Tus mejores acciones son probar tu programa
     pronto y con frecuencia; e intentar poner en orden, tanto como se pueda,
     escribir código que sea fácil de comprender y fácil de cambiar. Intenta
     ser consciente, siempre y cuando se pueda, esto es siempre que tengas
     que escribir, @e{será} reescrito, si no pronto, eventualmente. Un máximo
     duro de seguir.

     Esta es la función @c{print-X-axis-numbered-line} que necesita el
     trabajo; y entonces el @c{print-X-axis} y la función @c{print-graph}
     necesita ser adaptada. No se necesita mucho para ser hecho; hay uno
     simpático: los números podrían alinearse con marcas de tic. Esto toma un
     pequeño pensamiento.

     Aquí está el @c{print-X-axis-numbered-line} corregido:

     ..src > elisp
       (defun print-X-axis-numbered-line
         (number-of-X-tics X-axis-leading-spaces
          &optional horizontal-step)
         "Imprime la líneas de números X-axis"
         (let ((number X-axis-label-spacing)
               (horizontal-step (or horizontal-step 1)))
           (insert X-axis-leading-spaces)
           ;; Elimina espacios extra de guía.
           (delete-char
            (- (1-
                (length (number-to-string horizontal-step)))))
           (insert (concat
                    (make-string
                     ;; Inserta espacio en blanco.
                     (-  (* symbol-width
                            X-axis-label-spacing)
                         (1-
                          (length
                           (number-to-string horizontal-step)))
                         2)
                     ? )
                    (number-to-string
                     (* number horizontal-step))))
           ;; Insertar los números que permanecen.
           (setq number (+ number X-axis-label-spacing))
           (while (> number-of-X-tics 1)
             (insert (X-axis-element
                      (* number horizontal-step)))
             (setq number (+ number X-axis-label-spacing))
             (setq number-of-X-tics (1- number-of-X-tics)))))
     < src..

     Si se está leyendo esto en Info, se pueden ver las nuevas versiones
     @c{print-X-axis} y @c{print-graph} y los evaluarlas. Si se está leyendo
     esto en un libro impreso, se pueden ver las líneas cambiadas aquí (el
     texto completo es mucho para imprimir).

     ..src > elisp
       (defun print-X-axis (numbers-list horizontal-step)
         …
           (print-X-axis-numbered-line
            tic-number leading-spaces horizontal-step))
       (defun print-graph
         (numbers-list
          &optional vertical-step horizontal-step)
         …
           (print-X-axis numbers-list horizontal-step))
     < src..

**** El gráfico impreso

     Cuando esté hecho e instalado, se puede llamar al comando
     @c{print-graph} como esto:

     ..src > elisp
       (print-graph fiftieth-list-for-graph 50 10)
     < src..

     Aquí está el gráfico:

     ..example >
       1000 -  *
               **
               **
               **
               **
        750 -  ***
               ***
               ***
               ***
               ****
        500 - *****
              ******
              ******
              ******
              *******
        250 - ********
              *********                     *
              ***********                   *
              *************                 *
         50 - ***************** *           *
              |   |    |    |    |    |    |    |
             10  50  100  150  200  250  300  350
     < example..


     El grupo largo de funciones contienen de 10 a 19 palabras y símbolos.

** Apéndice D Software Libre y Manuales Libres @%b{por Richard M. Stallman}

   La mayor deficiencia en sistemas operativos libres no está en el
   software––es la falta de buenos manuales libres que se puedan incluir en
   estos sistemas. Muchos de nuestros programas más importantes no vienen con
   manuales completos. La documentación es una parte esencial de cualquier
   paquete de software; cuando un paquete de software libre no viene con un
   manual libre, es una brecha mayor. Nosotros tenemos muchas brechas hoy.

   Érase una vez, hace muchos años, se piensa que aprendería Perl. Se tiene
   una copia de un manual libre, pero se encontró difícil de leer. Cuando
   pregunto a los usuarios de Perl acerca de alternativas, me contaron que
   serían mejor los manuales introductorios––pero estos no eran libres.

   ¿Por qué era esto? Los autores de los buenos manuales los habían escrito
   para O'Reilly Associates, que los publicaron con términos restrictivos––no
   copiando, no modificando, los ficheros fuentes están disponibles––que los
   excluyen desde la comunidad de software libre.

   No era la primera vez que esto ocurría, y (para nuestra comunidad es una
   gran pérdida) eso está lejos desde el último. Las editoriales de manuales
   privativos han logrado que muchos autores restrinjan sus manuales desde
   entonces. Muchas veces se ha oido que un usuario de GNU hábil me cuente
   que un manual que está escribiendo, con el que él espera ayudar al
   proyecto GNU––y entonces tenía mis esperanzas frustradas, como se ha
   procedió a explicar que él tenía que haber firmado un contrato con una
   editorial que restringiría eso, así que no puede usarlo.

   Debido a que escribir buen inglés es una habilidad rara entre
   programadores, se pueden perder manuales por este motivo.

   La documentación, como el software, es una cuestión de libertad, no de
   precio. El problema con estos manuales no eran que O'Reilly Associates
   impusiera un precio por las copias impresas––que en sí estaban bien. La
   Free Software Foundation @e{Fundación por el Software Libre}
   @l{http://shop.fsf.org, vende copias impresas} de
   @l{http://www.gnu.org/doc/doc.html, manuales libres de GNU}, también. Pero
   los manuales de GNU están disponibles en forma de código fuente, mientras
   que estos manuales están disponibles solo en papel. Los manuales de GNU
   vienen con permiso para copiar y modificar; los manuales de Perl no. Estas
   restricciones son un problema.

   El criterio para un manual libre es parecido al del software libre: es una
   cuestión de dar a todos los usuarios ciertas libertades. La redistribución
   (incluyendo redistribución comercial) debe ser permitida, así el manual
   puede acompañar cada copia del programa, en líne o en papel. El permiso
   para modificar es crucial también.

   Como regla general, no se cree que sea esencial para la gente tener
   permisos para modificar todas las partes de artículos y libro. Las
   cuestiones para escritos no son necesariamente las mismas como estas para
   el software. Por ejemplo, no se sabe si se está obligado a dar permisos
   para modificar artículos como este, que describen nuestras acciones y
   nuestras vistas.

   Pero hay una razón particular de por qué la libertad de modificar es
   crucial para la documentación de software libre. Cuando las personas
   ejercita su derecho a modificar el software, y añadir o cambiar sus
   funcionalidades, si son consciente ellos cambiarán el manual también––así
   se puede proveer documentación usable y cuidada con el programa
   modificado. Un manual que prohibe a los programadores ser consciente y
   finalizar el trabajo, o más precisamente requiere escribir un nuevo manual
   desde cero si ellos cambian el programa, no se ajusta a las necesidades de
   nuestra comunidad.

   Mientras una serie de prohibiciones en la modificación es inaceptable,
   algunos tipos de límites en el método de modificar no tiene tanto
   problema. Por ejemplo, los requisitos para preservar la noticia de autores
   del copyright, los términos de distribución, o la lista de autores, estén
   ok. Eso es también no da problemas para requerir versiones modificadas
   para incluir notificar que fueron modificadas, incluso tienen secciones
   enteras que puede no ser eliminadas o cambiadas, tan largo como estas
   secciones tratan con asuntos no técnicos. (Algunos manuales de GNU los
   tienen).

   Estos tipos de restricciones no son un problema porque, como materia
   práctica, no para al programador consciente desde la adaptación del manual
   para ajustar el programa modificado. En otras palabras, no se bloquea la
   comunidad del software libre haciendo el uso completo del manual.

   Sin embargo, debe ser posible modificar todo el contenido técnico del
   manual, y entonces se distribuye el resultado en todos los medios usuales,
   a través de todos los canales usuales; de otro modo, las restricciones
   bloquean la comunidad, el manual no es libre, y así no se necesita otro
   manual.

   Desafortunadamente, con frecuencia es duro encontrar a alguien a escribir
   otro manual cuando un manual privativo. El obstáculo es que muchos usuario
   piensan que un manual privativo es suficientemente bueno––así ellos no ven
   la necesidad de escribir un manual libre. Ellos no ven que el sistema
   operativo tiene un gazapo que necesita se rellenado.

   ¿Por qué los usuarios piensan que los manuales privativos son
   suficientemente buenos? Algunos no han considerado la cuestión. Espero que
   este artículo hará alguna cosa para cambiar esto.

   Otros usuarios considera manuales privativos aceptables para la misma
   razón así muchas personas software privativo aceptable: ellos judgan en
   términos puramente prácticos, no usando la liberta como un criterio. Estas
   personas son tituladas a sus opiniones, pero desde que estas opciones
   crezcan desde valores que no incluyen libertad, ellas no están guiadas por
   esto quienes valoran la libertad.

   Por favor, populariza esta cuestión. Se continúa a perder manuales para
   publicación privativa. Si se populariza que los manuales privativos no son
   suficientes, quizás la siguiente persona que quiere ayudar a GNU
   escribiendo documentación realizará, antes de que sea demasiado tarde, lo
   que él debe que todo sea libre.

   Se puede también animar editoriales comerciales a vender manuales libres o
   con copyleft en vez de uno privativo. Un camino que se puede ayudar esto
   chequea los términos de la distribución de un manual antes de que se
   compre, y preferimos manuales copyleft a los no copyleft.

   Note: La Fundación para el Software Libre mantiene una página en su sitio
   Web que liste libros libres disponibles desde otras editoriales:
   @l{http://www.gnu.org/doc/other-free-books.html}

* Appendix E GNU Free Documentation License

  ..center >
    Version 1.3, 3 November 2008
  < center..

  Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
  <http://fsf.org/>

  Everyone is permitted to copy and distribute verbatim copies of this
  license document, but changing it is not allowed.

** 0. PREAMBLE

   The purpose of this License is to make a manual, textbook, or other
   functional and useful document "free" in the sense of freedom: to assure
   everyone the effective freedom to copy and redistribute it, with or
   without modifying it, either commercially or noncommercially.
   Secondarily, this License preserves for the author and publisher a way to
   get credit for their work, while not being considered responsible for
   modifications made by others.

   This License is a kind of "copyleft", which means that derivative works of
   the document must themselves be free in the same sense. It complements
   the GNU General Public License, which is a copyleft license designed for
   free software.

   We have designed this License in order to use it for manuals for free
   software, because free software needs free documentation: a free program
   should come with manuals providing the same freedoms that the software
   does. But this License is not limited to software manuals; it can be used
   for any textual work, regardless of subject matter or whether it is
   published as a printed book. We recommend this License principally for
   works whose purpose is instruction or reference.

** 1. APPLICABILITY AND DEFINITIONS

   This License applies to any manual or other work, in any medium, that
   contains a notice placed by the copyright holder saying it can be
   distributed under the terms of this License. Such a notice grants a
   world-wide, royalty-free license, unlimited in duration, to use that work
   under the conditions stated herein. The "Document", below, refers to any
   such manual or work. Any member of the public is a licensee, and is
   addressed as "you". You accept the license if you copy, modify or
   distribute the work in a way requiring permission under copyright law.

   A "Modified Version" of the Document means any work containing the
   Document or a portion of it, either copied verbatim, or with modifications
   and/or translated into another language.

   A "Secondary Section" is a named appendix or a front-matter section of the
   Document that deals exclusively with the relationship of the publishers or
   authors of the Document to the Document's overall subject (or to related
   matters) and contains nothing that could fall directly within that overall
   subject.  (Thus, if the Document is in part a textbook of mathematics, a
   Secondary Section may not explain any mathematics.)  The relationship
   could be a matter of historical connection with the subject or with
   related matters, or of legal, commercial, philosophical, ethical or
   political position regarding them.

   The "Invariant Sections" are certain Secondary Sections whose titles are
   designated, as being those of Invariant Sections, in the notice that says
   that the Document is released under this License. If a section does not
   fit the above definition of Secondary then it is not allowed to be
   designated as Invariant. The Document may contain zero Invariant
   Sections. If the Document does not identify any Invariant Sections then
   there are none.

   The "Cover Texts" are certain short passages of text that are listed, as
   Front-Cover Texts or Back-Cover Texts, in the notice that says that the
   Document is released under this License. A Front-Cover Text may be at
   most 5 words, and a Back-Cover Text may be at most 25 words.

   A "Transparent" copy of the Document means a machine-readable copy,
   represented in a format whose specification is available to the general
   public, that is suitable for revising the document straightforwardly with
   generic text editors or (for images composed of pixels) generic paint
   programs or (for drawings) some widely available drawing editor, and that
   is suitable for input to text formatters or for automatic translation to a
   variety of formats suitable for input to text formatters. A copy made in
   an otherwise Transparent file format whose markup, or absence of markup,
   has been arranged to thwart or discourage subsequent modification by
   readers is not Transparent. An image format is not Transparent if used
   for any substantial amount of text. A copy that is not "Transparent" is
   called "Opaque".

   Examples of suitable formats for Transparent copies include plain ASCII
   without markup, Texinfo input format, LaTeX input format, SGML or XML
   using a publicly available DTD, and standard-conforming simple HTML,
   PostScript or PDF designed for human modification. Examples of
   transparent image formats include PNG, XCF and JPG. Opaque formats
   include proprietary formats that can be read and edited only by
   proprietary word processors, SGML or XML for which the DTD and/or
   processing tools are not generally available, and the machine-generated
   HTML, PostScript or PDF produced by some word processors for output
   purposes only.

   The "Title Page" means, for a printed book, the title page itself, plus
   such following pages as are needed to hold, legibly, the material this
   License requires to appear in the title page. For works in formats which
   do not have any title page as such, "Title Page" means the text near the
   most prominent appearance of the work's title, preceding the beginning of
   the body of the text.

   The "publisher" means any person or entity that distributes copies of the
   Document to the public.

   A section "Entitled XYZ" means a named subunit of the Document whose title
   either is precisely XYZ or contains XYZ in parentheses following text that
   translates XYZ in another language.  (Here XYZ stands for a specific
   section name mentioned below, such as "Acknowledgements", "Dedications",
   "Endorsements", or "History".)  To "Preserve the Title" of such a section
   when you modify the Document means that it remains a section "Entitled
   XYZ" according to this definition.

   The Document may include Warranty Disclaimers next to the notice which
   states that this License applies to the Document. These Warranty
   Disclaimers are considered to be included by reference in this License,
   but only as regards disclaiming warranties: any other implication that
   these Warranty Disclaimers may have is void and has no effect on the
   meaning of this License.

** 2. VERBATIM COPYING

   You may copy and distribute the Document in any medium, either
   commercially or noncommercially, provided that this License, the copyright
   notices, and the license notice saying this License applies to the
   Document are reproduced in all copies, and that you add no other
   conditions whatsoever to those of this License. You may not use technical
   measures to obstruct or control the reading or further copying of the
   copies you make or distribute. However, you may accept compensation in
   exchange for copies. If you distribute a large enough number of copies
   you must also follow the conditions in section 3.

   You may also lend copies, under the same conditions stated above, and you
   may publicly display copies.

** 3. COPYING IN QUANTITY

   If you publish printed copies (or copies in media that commonly have
   printed covers) of the Document, numbering more than 100, and the
   Document's license notice requires Cover Texts, you must enclose the
   copies in covers that carry, clearly and legibly, all these Cover Texts:
   Front-Cover Texts on the front cover, and Back-Cover Texts on the back
   cover. Both covers must also clearly and legibly identify you as the
   publisher of these copies. The front cover must present the full title
   with all words of the title equally prominent and visible. You may add
   other material on the covers in addition. Copying with changes limited to
   the covers, as long as they preserve the title of the Document and satisfy
   these conditions, can be treated as verbatim copying in other respects.

   If the required texts for either cover are too voluminous to fit legibly,
   you should put the first ones listed (as many as fit reasonably) on the
   actual cover, and continue the rest onto adjacent pages.

   If you publish or distribute Opaque copies of the Document numbering more
   than 100, you must either include a machine-readable Transparent copy
   along with each Opaque copy, or state in or with each Opaque copy a
   computer-network location from which the general network-using public has
   access to download using public-standard network protocols a complete
   Transparent copy of the Document, free of added material. If you use the
   latter option, you must take reasonably prudent steps, when you begin
   distribution of Opaque copies in quantity, to ensure that this Transparent
   copy will remain thus accessible at the stated location until at least one
   year after the last time you distribute an Opaque copy (directly or
   through your agents or retailers) of that edition to the public.

   It is requested, but not required, that you contact the authors of the
   Document well before redistributing any large number of copies, to give
   them a chance to provide you with an updated version of the Document.

** 4. MODIFICATIONS

   You may copy and distribute a Modified Version of the Document under the
   conditions of sections 2 and 3 above, provided that you release the
   Modified Version under precisely this License, with the Modified Version
   filling the role of the Document, thus licensing distribution and
   modification of the Modified Version to whoever possesses a copy of it.
   In addition, you must do these things in the Modified Version:

   A. Use in the Title Page (and on the covers, if any) a title distinct from
      that of the Document, and from those of previous versions (which
      should, if there were any, be listed in the History section of the
      Document). You may use the same title as a previous version if the
      original publisher of that version gives permission.

   B. List on the Title Page, as authors, one or more persons or entities
      responsible for authorship of the modifications in the Modified
      Version, together with at least five of the principal authors of the
      Document (all of its principal authors, if it has fewer than five),
      unless they release you from this requirement.

   C. State on the Title page the name of the publisher of the Modified
      Version, as the publisher.

   D. Preserve all the copyright notices of the Document.

   E. Add an appropriate copyright notice for your modifications adjacent to
      the other copyright notices.

   F. Include, immediately after the copyright notices, a license notice
      giving the public permission to use the Modified Version under the
      terms of this License, in the form shown in the Addendum below.

   G. Preserve in that license notice the full lists of Invariant Sections
      and required Cover Texts given in the Document's license notice.

   H. Include an unaltered copy of this License.

   I. Preserve the section Entitled "History", Preserve its Title, and add to
      it an item stating at least the title, year, new authors, and publisher
      of the Modified Version as given on the Title Page. If there is no
      section Entitled "History" in the Document, create one stating the
      title, year, authors, and publisher of the Document as given on its
      Title Page, then add an item describing the Modified Version as stated
      in the previous sentence.

   J. Preserve the network location, if any, given in the Document for public
      access to a Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was based on.
      These may be placed in the "History" section. You may omit a network
      location for a work that was published at least four years before the
      Document itself, or if the original publisher of the version it refers
      to gives permission.

   K. For any section Entitled "Acknowledgements" or "Dedications", Preserve
      the Title of the section, and preserve in the section all the substance
      and tone of each of the contributor acknowledgements and/or dedications
      given therein.

   L. Preserve all the Invariant Sections of the Document, unaltered in their
      text and in their titles. Section numbers or the equivalent are not
      considered part of the section titles.

   M. Delete any section Entitled "Endorsements". Such a section may not be
      included in the Modified Version.

   N. Do not retitle any existing section to be Entitled "Endorsements" or to
      conflict in title with any Invariant Section.

   O. Preserve any Warranty Disclaimers.


   If the Modified Version includes new front-matter sections or appendices
   that qualify as Secondary Sections and contain no material copied from the
   Document, you may at your option designate some or all of these sections
   as invariant. To do this, add their titles to the list of Invariant
   Sections in the Modified Version's license notice. These titles must be
   distinct from any other section titles.

   You may add a section Entitled "Endorsements", provided it contains
   nothing but endorsements of your Modified Version by various parties--for
   example, statements of peer review or that the text has been approved by
   an organization as the authoritative definition of a standard.

   You may add a passage of up to five words as a Front-Cover Text, and a
   passage of up to 25 words as a Back-Cover Text, to the end of the list of
   Cover Texts in the Modified Version. Only one passage of Front-Cover Text
   and one of Back-Cover Text may be added by (or through arrangements made
   by) any one entity. If the Document already includes a cover text for the
   same cover, previously added by you or by arrangement made by the same
   entity you are acting on behalf of, you may not add another; but you may
   replace the old one, on explicit permission from the previous publisher
   that added the old one.

   The author(s) and publisher(s) of the Document do not by this License give
   permission to use their names for publicity for or to assert or imply
   endorsement of any Modified Version.

** 5. COMBINING DOCUMENTS

   You may combine the Document with other documents released under this
   License, under the terms defined in section 4 above for modified versions,
   provided that you include in the combination all of the Invariant Sections
   of all of the original documents, unmodified, and list them all as
   Invariant Sections of your combined work in its license notice, and that
   you preserve all their Warranty Disclaimers.

   The combined work need only contain one copy of this License, and multiple
   identical Invariant Sections may be replaced with a single copy. If there
   are multiple Invariant Sections with the same name but different contents,
   make the title of each such section unique by adding at the end of it, in
   parentheses, the name of the original author or publisher of that section
   if known, or else a unique number. Make the same adjustment to the
   section titles in the list of Invariant Sections in the license notice of
   the combined work.

   In the combination, you must combine any sections Entitled "History" in
   the various original documents, forming one section Entitled "History";
   likewise combine any sections Entitled "Acknowledgements", and any
   sections Entitled "Dedications". You must delete all sections Entitled
   "Endorsements".

** 6. COLLECTIONS OF DOCUMENTS

   You may make a collection consisting of the Document and other documents
   released under this License, and replace the individual copies of this
   License in the various documents with a single copy that is included in
   the collection, provided that you follow the rules of this License for
   verbatim copying of each of the documents in all other respects.

   You may extract a single document from such a collection, and distribute
   it individually under this License, provided you insert a copy of this
   License into the extracted document, and follow this License in all other
   respects regarding verbatim copying of that document.

** 7. AGGREGATION WITH INDEPENDENT WORKS

   A compilation of the Document or its derivatives with other separate and
   independent documents or works, in or on a volume of a storage or
   distribution medium, is called an "aggregate" if the copyright resulting
   from the compilation is not used to limit the legal rights of the
   compilation's users beyond what the individual works permit. When the
   Document is included in an aggregate, this License does not apply to the
   other works in the aggregate which are not themselves derivative works of
   the Document.

   If the Cover Text requirement of section 3 is applicable to these copies
   of the Document, then if the Document is less than one half of the entire
   aggregate, the Document's Cover Texts may be placed on covers that bracket
   the Document within the aggregate, or the electronic equivalent of covers
   if the Document is in electronic form. Otherwise they must appear on
   printed covers that bracket the whole aggregate.

** 8. TRANSLATION

   Translation is considered a kind of modification, so you may distribute
   translations of the Document under the terms of section 4. Replacing
   Invariant Sections with translations requires special permission from
   their copyright holders, but you may include translations of some or all
   Invariant Sections in addition to the original versions of these Invariant
   Sections. You may include a translation of this License, and all the
   license notices in the Document, and any Warranty Disclaimers, provided
   that you also include the original English version of this License and the
   original versions of those notices and disclaimers. In case of a
   disagreement between the translation and the original version of this
   License or a notice or disclaimer, the original version will prevail.

   If a section in the Document is Entitled "Acknowledgements",
   "Dedications", or "History", the requirement (section 4) to Preserve its
   Title (section 1) will typically require changing the actual title.

** 9. TERMINATION

   You may not copy, modify, sublicense, or distribute the Document except as
   expressly provided under this License. Any attempt otherwise to copy,
   modify, sublicense, or distribute it is void, and will automatically
   terminate your rights under this License.

   However, if you cease all violation of this License, then your license
   from a particular copyright holder is reinstated (a) provisionally, unless
   and until the copyright holder explicitly and finally terminates your
   license, and (b) permanently, if the copyright holder fails to notify you
   of the violation by some reasonable means prior to 60 days after the
   cessation.

   Moreover, your license from a particular copyright holder is reinstated
   permanently if the copyright holder notifies you of the violation by some
   reasonable means, this is the first time you have received notice of
   violation of this License (for any work) from that copyright holder, and
   you cure the violation prior to 30 days after your receipt of the notice.

   Termination of your rights under this section does not terminate the
   licenses of parties who have received copies or rights from you under this
   License. If your rights have been terminated and not permanently
   reinstated, receipt of a copy of some or all of the same material does not
   give you any rights to use it.

** 10. FUTURE REVISIONS OF THIS LICENSE

   The Free Software Foundation may publish new, revised versions of the GNU
   Free Documentation License from time to time. Such new versions will be
   similar in spirit to the present version, but may differ in detail to
   address new problems or concerns. See http://www.gnu.org/copyleft/.

   Each version of the License is given a distinguishing version number. If
   the Document specifies that a particular numbered version of this License
   "or any later version" applies to it, you have the option of following the
   terms and conditions either of that specified version or of any later
   version that has been published (not as a draft) by the Free Software
   Foundation. If the Document does not specify a version number of this
   License, you may choose any version ever published (not as a draft) by the
   Free Software Foundation. If the Document specifies that a proxy can
   decide which future versions of this License can be used, that proxy's
   public statement of acceptance of a version permanently authorizes you to
   choose that version for the Document.

** 11. RELICENSING

   "Massive Multiauthor Collaboration Site" (or "MMC Site") means any World
   Wide Web server that publishes copyrightable works and also provides
   prominent facilities for anybody to edit those works. A public wiki that
   anybody can edit is an example of such a server. A "Massive Multiauthor
   Collaboration" (or "MMC") contained in the site means any set of
   copyrightable works thus published on the MMC site.

   "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license
   published by Creative Commons Corporation, a not-for-profit corporation
   with a principal place of business in San Francisco, California, as well
   as future copyleft versions of that license published by that same
   organization.

   "Incorporate" means to publish or republish a Document, in whole or in
   part, as part of another Document.

   An MMC is "eligible for relicensing" if it is licensed under this License,
   and if all works that were first published under this License somewhere
   other than this MMC, and subsequently incorporated in whole or in part
   into the MMC, (1) had no cover texts or invariant sections, and (2) were
   thus incorporated prior to November 1, 2008.

   The operator of an MMC Site may republish an MMC contained in the site
   under CC-BY-SA on the same site at any time before August 1, 2009,
   provided the MMC is eligible for relicensing.

* ADDENDUM: How to use this License for your documents

  To use this License in a document you have written, include a copy of the
  License in the document and put the following copyright and license notices
  just after the title page:

  ..pre >
    Copyright (c)  YEAR  YOUR NAME.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
  < pre..

  If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
  replace the "with...Texts." line with this:

  ..pre >
    with the Invariant Sections being LIST THEIR TITLES, with the
    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
  < pre..

  If you have Invariant Sections without Cover Texts, or some other
  combination of the three, merge those two alternatives to suit the
  situation.

  If your document contains nontrivial examples of program code, we recommend
  releasing these examples in parallel under your choice of free software
  license, such as the GNU General Public License, to permit their use in
  free software.

** Acerca del Autor

   Robert J. Chassell ha trabajado con GNU Emacs desde 1985. Él
   escribe, edita y enseña Emacs y Emacs Lisp, y habla alrededor del
   mundo acerca de la libertad del software. Chassell es Director
   fundador y Tesorero de la Fundación por el Software Libre (FSF). Él
   se graduó la Universidad de Cambridge, en Inglaterra. Él tiene un
   interés contínuo en historia económica y social y vuela su
   propio aeroplano

* footnotes

 :: @N{1} :: El apóstrofo o comilla es una abreviación para la función
    @c{quote}; no es necesario pensar en las funciones ahora; las funciones
    se definen en la Seccion @l{Generar un mensaje de error}.

 :: @N{2} :: Es curioso seguir el camino por el que la palabra ‘argumento’
    llego a tener dos significados distintos, uno en matemáticas y otro en el
    inglés cotidiano. De acuerdo al @e{Oxford English Dictionary}, la palabra
    deriva del Latín para @'{dejar claro, probar}; por lo tanto, paso a
    significar, por un hilo de derivación, ‘la evidencia ofrecida como prueba’,
    es decir ‘la informacion que se ofrece’, que conduce a su significado en
    Lisp. Pero en el otro hilo de la derivación, paso a significar ‘afirmar de
    una manera contra la cual otros pueden hacer afirmaciones contrarias’, lo
    que llevó al significado de la palabra como disputa. (Tenga en cuenta que la
    palabra Inglésa tiene dos definiciones distintas al mismo tiempo. En
    contraste, en Emacs Lisp, un símbolo no puede tener dos definiciones de
    funcion diferentes al mismo tiempo.)

 :: @N{3} :: @c{(quote hola)} es una expansión de la abreviatura @c{'hola}.

 :: @N{4} :: En realidad, puede utilizar @c{%s} para imprimir un número. No
    es específico. @c{%d} solo imprime la parte de un número a la izquierda
    del punto decimal, excluyendo cualquier cosa que no sea un número.

 :: @N{5} :: En realidad, por defecto, si el búfer desde el que acabas de
    cambiar es visible por tí en otra ventana, @c{other-buffer} elegirá el
    búfer más reciente que no puedas ver; esta es una sutileza que a menudo
    olvido.

 :: @N{6} :: O mejor dicho, para evitar escribir, probablemente solo necesites
    pulsar @k{RET} si @f{*scratch*} es el buffer por defecto, de ser
    diferente, solo escribe parte del nombre, por ejemplo @c{*sc}, luego
    presiona la tecla @k{TAB} para hacer que se expanda el nombre completo, y
    finalmente pulsa @k{RET}.

 :: @N{7} :: Recuerda, esta expresión te desplaza al buffer diferente más
    reciente que no puedas ver. Si realmente quieres ir al ultimo búfer
    seleccionado, incluso si es visible, es necesario evaluar la siguiente
    expresión más compleja:

    ..src > elisp
      (switch-to-buffer (other-buffer (current-buffer) t))
    < src..

    En este caso, el primer argumento de @c{other-buffer} le dice a que búfer
    saltar––el actual––y el segundo argumento @c{other-buffer} le indica que
    esta BIEN cambiar a un búfer visible. La utilidad de @c{switch-to-buffer} es
    llevarte a una ventana invisible ya que probablemente usarias
    @k{C-x o} @%c(other-window) para ir a otro búfer visible.

 :: @N{8} :: Segun Jared Diamond en @e{Guns, Germs, and Steel}, “…
    las cebras se vuelven increiblemente peligrosas a medida que envejecen”
    pero la afirmacion aquí es que no llegan a ser feroces como un tigre. (1997,
    W. W. Norton and Co., ISBN 0-393-03894-2, pagina 171)

 :: @N{9} :: Actualmente, se puede @c{cons} un elemento para un átomo para
    producir a para punteado. Los pares punteados no se discuten aquí; ver
    Seccion "Notación de Para Punteado" en @e(El Manual de Referencia de GNU
    Emacs Lisp).

 :: @N{10} :: Más precisamente, y requiriendo conocimiento más experto para
    entender, los dos enteros son del tipo ‘Lisp_Object’, que también puede
    ser una unión C en lugar de un tipo entero.

 :: @N{11} :: Puedes escribir funciones recursivas para ser frugales o
    derrochar recursos mentales o computacionales; como sucede, los métodos que
    la gente encuentra fáciles––que son frugales de ‘recursos mentales’––algunas
    veces usan considerables recursos del computador. Emacs fué diseñado para
    ejecutarse en máquinas que ahora consideramos limitadas y su configuracion
    por defecto es conservadora. Es posible que desees incrementar los valores de
    @c{max-specdl-size} y @c{max-lisp-eval-depth}. En mi fichero @f{.emacs}, yo
    los asigno a 15 o 30 veces su valor predeterminado.

 :: @N{12} :: La frase @:{recursion de cola} se utiliza para describir tal
    proceso, uno que usa ‘espacio constante’.

 :: @N{13} :: La jerga es ligeramente confusa: @c{triangulo-recursivo-auxiliar}
    usa un proceso que es iterativo en un procedimiento que es recursivo. El
    proceso se llama iterativo porque el ordenador necesita solo grabar los tres
    valores, @c{suma}, @c{contador}, y @c{número}: el procedimiento es recursivo
    porque la función ‘se llama a sí misma’. Por otra parte, tanto el proceso
    como el procedimiento usado por @c{triangulo-recursivo} se denominan
    recursivos. La palabra ‘recursivo’ tiene significados diferentes en los dos
    contextos.

 :: @N{14} :: Tu puedes también añadir @f{.el} para @f{~/.emacs} y llama a un
    fichero @f{~/.emacs}. En el pasado, fué prohibido escribir los atajos de
    teclado extra que el nombre @f{~/.emacs.el} requiere, pero ahora
    puedes. El nuevo formato es consistente con las conveniciones de nombre
    del fichero Emacs Lisp; el viejo formato guarda la escritura.

 :: @N{15} :: Cuando se empiezan las instancias de Emacs que no cargan mi
    fichero @f{.emacs} o cualquier fichero, también se puede deshabilitar la
    ocultación:

    ..example >
      emacs -q --no-site-file -eval
      '(blink-cursor-mode nil)' @exdent O ahora, usando un conjunto más
      sofisticado de opciones, emacs -Q - D
    < example..

 :: @N{16} :: también se ejecutan gestores de ventanas más modernos, tales
    como Enlightenment, Gnome, o KDE; en estos casos, con frecuencia se
    especifica una imagen en vez de un color plano.
