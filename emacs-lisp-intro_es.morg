@ -*- mode: org; -*-
@title     Una introducción a la programación en Emacs Lisp
@subtitle  Revisada la tercera edición
@author    Robert J. Chassell
@traductor David Arroyo Menéndez
@define    edition-number="3.10"
@define    COUNT-WORDS="count-words-example"

Esto es una @e{Introducción a la Programación en Emacs Lisp},
para personas que no son programadoras.

Traducido desde la edición @v{edition-number}.

Copyright ® 2015 Libremanuals.

Publicado por:

Libremanuals, @l{http://www.libremanuals.net/}

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; there being no Invariant
Section, with the Front-Cover Texts being “A GNU Manual”, and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled “GNU Free Documentation License”.

(a) The FSF's Back-Cover Text is: “You have the freedom to copy and modify
this GNU manual.  Buying copies from the FSF supports it in developing GNU
and promoting software freedom.”

* Prefacio

  La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje de
  programación llamado Emacs Lisp. El código escrito en este lenguaje de
  programación es el software––el conjunto de instrucciones––que cuenta al
  ordenador qué hacer cuando tu le das comandos. Emacs está diseñado de forma
  que se puede escribir nuevo código en Emacs Lisp y fácilmente instalarlo
  como una extensión al editor.

  (GNU Emacs se define muchas veces como un “editor extensible”, pero hace
  mucho más que proporcionar capacidad de edición. Es mejor referirse a Emacs
  como un “entorno de computación extensible”. Sin embargo, esta frase es un
  poco pretenciosa. Es más fácil referirse a Emacs simplemente como un
  editor. De hecho, cada cosa que se hace en Emacs––encontrar la fecha Maya y
  fases de la luna, simplificar polinomios, depurar código, administrar
  ficheros, leer cartas, escribir libros––todas estas actividades son maneras
  de editar en un sentido amplio de la palabra.)

  Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un lenguaje de
  programación completo. Se puede usar Emacs Lisp del mismo modo que con
  cualquier otro lenguaje de programación.

  Quizás se quiere comprender la programación; quizás se quiere extender
  Emacs; o quizás se quiere llegar a ser un programador. Esta introducción a
  Emacs Lisp está diseñada para ayudar a empezar en todo esto: para guiarse
  en el aprendizaje de los fundamentos de programación, y de manera más
  importante, para enseñar como uno mismo puede ir más allá.

** Leyendo este texto

   A través de este libro, se verán pequeños programas de ejemplo que se
   pueden ejecutar dentro de Emacs. Si se lee este documento en Info dentro
   de GNU Emacs, se pueden ejecutar los programas tal y como aparecen. (Esto
   es fácil de hacer y se explica cuando los ejemplos se presentan).
   Alternativamente, se puede leer esta introducción como un libro impreso
   mientras se está sentando con un ordenador ejecutando Emacs. (Esto es lo
   que me gusta hacer; me gustan los libros impresos.) Si no se está
   ejecutando Emacs, todavía se puede leer este libro, pero en este caso, lo
   mejor es tratarlo como una novela, o como una guía de viaje a un país aún
   no visitado: interesante, pero no es lo mismo que estar allí.

   Gran parte de esta introducción se dedica a paseos guiados de código usado
   en GNU Emacs. Estos paseos están diseñados para dos propósitos: primero,
   familiarizarse con código real que funciona (código que se usa cada día);
   y, segundo, familiarizarse con cómo funciona Emacs. Es interesante ver
   cómo se implementa un entorno completamente operativo. También, espero que
   se adquiera el hábito de navegar a través del código fuente. Se puede
   aprender mucho comparando código de otros con el propio, ganando nuevas
   ideas. Tener GNU Emacs es como tener la cueva del dragón de los tesoros.

   Además de aprender acerca de Emacs como editor y Emacs Lisp como lenguaje
   de programación, los ejemplos y visitas guiadas le darán una oportunidad
   para familiarizarse con Emacs como un entorno de programación Lisp. GNU
   Emacs soporta programación y provee herramientas que llegarán a usarse
   cómodamente, como @k{M-.} (la clave que invoca el comando @c{find-tag}).
   También aprendera sobre búffers y otros objetos que forman parte del
   entorno. Aprender estas funcionalidades de Emacs es como aprender nuevas
   rutas alrededor de tu hogar.

   @ignore
     In addition, I have written several programs as extended examples.
     Although these are examples, the programs are real.  I use them.
     Other people use them.  You may use them.  Beyond the fragments of
     programs used for illustrations, there is very little in here that is
     ‘just for teaching purposes’; what you see is used.  This is a great
     advantage of Emacs Lisp: it is easy to learn to use it for work.
   @end ignore

   Finalmente, espero poder transmitir algunas habilidades para utilizar
   Emacs para aprender aspectos de programación que no se conocen. Con
   frecuencia se puede usar Emacs para ayudarte a entender un rompecabezas o
   para encontrar la manera de hacer algo nuevo. Este auto-descubrimiento no
   es solo un placer, también es una ventaja.

** Para quien está esto escrito

   Este texto está escrito como una introducción elemental para personas que
   no son programadoras. Quien ya programa, puede no estar satisfecho con
   este libro. La razón es que un programador puede tener que convertirse en
   experto leyendo manuales de referencia y este texto no está organizado
   como un manual de referencia.

   Un programador experto que revisó este texto me dijo:

   @quote
     Prefiero aprender desde manuales de referencia. Yo “me sumerjo” en cada
     párrafo y “subo a por aire” entre párrafos.

     Cuando llego al fin de un párrafo, asumo que este asunto está hecho,
     finalizado, que conozco cada cosa que necesito (con la posible excepción
     del caso en el que el siguiente párrafo empiece hablando acerca de eso
     mismo en más detalle). Yo espero que un manual de referencia bien
     escrito no tendrá un montón de redundancia, y tendrá excelentes punteros
     a (un) lugar donde está la información que quiero.
   @end quote

   ¡Esta introducción no está escrita para esta persona!

   Primero, intento decir cada cosa al menos tres veces: primero,
   introducirlo; segundo, mostrarlo en contexto; y tercero, mostrarlo en un
   contexto diferente, o revisarlo.

   Segundo, yo no siempre pongo toda la información acerca de un asunto en un
   mismo lugar, ni mucho menos en un párrafo. Desde mi punto de vista, se
   necesita una carga bastante fuerte en el lector. En vez de eso intento
   explicar solo lo que se necesita saber en el momento. (Algunas veces
   incluyo una pequeña información extra, para que no haya sorpresas más
   tarde cuando la información adicional se presente formalmente.)

   Cuando uno lee este texto, no espera aprender todo la primera vez.
   Frecuentemente, solo necesita hacer un `reconocimiento' con alguno de los
   elementos mencionados. Mi esperanza es haber estructurado el texto y dar
   suficientes indicios que dejarán alerta de lo que es importante y
   concentrarse en ellos.

   Es necesario “sumergirse” en algunos párrafos; no hay otro modo de
   leerlos. Pero yo he intentado guardar el número de tales párrafos. Este
   libro pretende ser como una colina asequible, en vez de una montaña
   abrumadora.

   Esta introducción de @e{Programación en Emacs Lisp} viene acompañada de un
   documento complementario.  @l{El Manual de Referencia de GNU Emacs Lisp}.
   El manual de referencia tiene más detalles que esta introducción. En el
   manual de referencia, toda la información sobre un asunto está concentrada
   en un lugar. Se debe cambiar si es como el programador citado arriba. Y,
   por supuesto, después de haber leido esta @e{Introducción}, será muy útil
   consultar el @e{Manual de Referencia} al escribir programas propios.

** Historia de Lisp

   Lisp fué originariamente desarrollado en los 50 en el Instituto
   Tecnológico de Massachusetts para investigar en inteligencia artificial.
   El gran poder del lenguaje Lisp lo hace superior para otros propósitos
   también, tal como escribir comandos de edición y entornos integrados.

   GNU Emacs Lisp está fuertemente inspirado en Maclisp, que está escrito en
   el MIT en los sesenta. Está en cierto modo inspirado en Common Lisp, que
   llega a ser un estándar en los 80. Sin embargo, Emacs Lisp es mucho más
   simple que Common Lisp. (La distribución estándar de Emacs contiene un
   fichero de extensiones opcional, @f{cl.el}, que añade muchas
   funcionalidades a Emacs Lisp.)

** Una nota para principiantes

   Aunque no se conozca GNU Emacs, este documento puede resultar útil. Sin
   embargo, es mejor aprender Emacs, al menos aprender a moverse alrededor de
   la pantalla del ordenador. Uno puede aprender de manera autodidacta cómo
   usar Emacs con el tutorial on-line. Para usarlo, se debe escribir @k{C-h
   t}. (Esto significa que se presione la tecla @k{CTRL} y la @k{h} al mismo
   tiempo, y después se presiona @k{t}).

   Con frecuencia, también aludo a uno de los comandos de Emacs estándar
   listando las teclas que se presionan para invocar el comando y, luego dar
   el nombre del comando entre paréntesis, asi: @k{M-C-\}
   (@c{indent-region}). Esto significa invocar el comando @c{indent-region}
   presionando @k{M-C-\}. (Si lo desea, puede cambiar las teclas que son
   presionadas para invocar el comando; esto se llama @:{rebinding}. Véase
   Sección @l{Mapas de teclado}.)  La abreviación @k{M-C-\} significa que se
   presiona la tecla @k{META}, @k{CTRL}, y @k{\} todo al mismo tiempo. (En
   muchos teclados modernos la tecla @k{META} es etiquetada con @k{ALT}.)
   Algunas veces una combinación como esta se llama @e{keychord}, puesto que
   es similar a tocar un acorde en un piano. Si el teclado no tiene una tecla
   @k{META}, en su lugar se usa la tecla @k{ESC} como prefijo. En este caso
   @k{M-C-\} significa que se presiona y libera @k{ESC} y luego presiona la
   tecla @k{CTRL} y la tecla @k{\} al mismo tiempo. Pero normalmente
   @k{M-C-\} significa presionar la tecla @k{CTRL} junto a la tecla que está
   etiquetada @k{ALT} y, al mismo tiempo, presionar la tecla @k{\}.

   Además de pulsar una sola combinación de teclas, se puede prefijar lo que
   se escribe con @k{C-u}, que es llamado el ‘argumento universal’. El atajo
   @k{C-u} pasa a ser un argumento para el comando subsiguiente. De este
   modo, para indentar una región de texto plano a 6 espacios, se marca la
   región, y entonces se presiona @k{C-u 6 M-C-\}. (Si no se especifica un
   número, Emacs pasa el número 4 al comando o de otra manera ejecuta el
   comando de manera diferente). Véase Sección
   @l{info:emacs#Arguments<>Argumentos Numéricos} en @e{El Manual de GNU
   Emacs}.

   Si se está leyendo esto en Info usando GNU Emacs, se puede avanzar a
   través de este documento completo solo presionando la barra de espacio,
   @k{SPC}. (Para aprender acerca de Info, presiona @k{C-h i} y luego
   selecciona Info.)

   Una nota en terminología: cuando uso la palabra Lisp sola, con frecuencia
   me estoy refiriendo a los dialectos de Lisp en general, pero cuando hablo
   de Emacs Lisp, me estoy refiriendo a GNU Emacs Lisp en particular.

** Se agradece

   Estoy agradecido a todas las personas que me ayudaron con este libro.
   Especialmente agradecido a Jim Blandy, Noah Friedman, Jim Kingdon, Roland
   McGrath, Frank Ritter, Randy Smith, Richard M. Stallman, y Melissa
   Weisshaus. Gracias también a Philip Johnson y David Stampe por su ánimo
   paciente. Mis errores son míos.

   @right
     Robert J. Chassell
     @l{mailto:bob@gnu.org}
   @end right

* Procesamiento de listas

  Para el ojo inexperto, Lisp es un lenguaje de programación extraño. En
  código Lisp hay paréntesis por todas partes. Algunas personas incluso
  reclaman que el nombre signfica ‘Lots of Isolated Silly Parentheses’
  (‘Montones de Paréntesis Aislados Estúpidos’). Pero la protesta no tiene
  fundamento. Lisp es para procesamiento de listas, y el lenguaje de
  programación maneja @e{listas} (y listas de listas) poniéndolas entre
  paréntesis. Los paréntesis marcan los límites de la lista. Algunas veces
  una lista va precedida por un apóstrofe simple o una marca de cita,
  @'{'}@n{1} Las listas son el fundamento de Lisp.

** Listas Lisp

   En Lisp, una lista como esta: @c{'(rosa violeta margarita tulipan)}.
   Esta lista es precedida por una comilla. Bien, podría estar escrita de la
   siguiende manera, que se parece mas al tipo de lista con la que se está
   familiarizado:

   @src elisp
     '(rosa
       violeta
       margarita
       tulipan)
   @end src

   Los elementos de esta lista son los nombres de 4 flores diferentes,
   separados por espacios en blanco y rodeados de paréntesis, como flores en
   un campo con un muro de piedras alrededor de ellas.

   Las listas pueden también tener números dentro, como en esta lista: @c{(+
   2 2)}. Esta lista tiene un signo más, @'{+}, seguido por dos @'{2}, cada
   uno separado por espacios en blanco.

   En Lisp, tanto datos como programas están representados de la misma
   manera; es decir, son a la vez listas de palabras, números, u otras
   listas, separadas por espacios en blanco y rodeadas de paréntesis. (Puesto
   que un programa son datos, un programa puede fácilmente servir datos a
   otros programas; esta es una funcionalidad muy poderosa de Lisp.)
   (Incidentalmente, estas dos marcas de paréntesis @e{no} son listas Lisp,
   porque contienen @'{;} y @'{.} como marcas de puntuación.)

   Aquí hay otra lista, esta vez con una lista dentro:

   @src elisp
     '(esta lista tiene (una lista dentro de ella))
   @end src

   Los componentes de esta lista son las palabras @'{esta}, @'{lista},
   @'{tiene}, y la lista @'{(una lista dentro de ella)}. La lista interior se
   construye con las palabras @'{una}, @'{lista}, @'{dentro}, @'{de},
   @'{ella}.

*** Átomos Lisp

    En Lisp, lo que hemos estado llamando palabras son en realidad
    @:{átomos}. Este término viene del significado historico de la palabra
    átomo, que significa ‘indivisible’. En lo que a Lisp concierne, las
    palabras que hemos estado usando en las listas no pueden ser divididas en
    pequeñas partes, sin perder su significado dentro del programa; lo mismo
    ocurre con números y símbolos de un caracterer como @'{+}. Por otro lado,
    a diferencia de un átomo, una lista puede ser dividida en pequeñas
    partes. Ver @l(@c{car}, @c{cdr}, @c{cons}: Funciones fundamentales).

    En una lista, los átomos se separan unos de otros por espacios en blanco.
    Pueden ir pegados a un paréntesis.

    Técnicamente hablando, una lista en Lisp consiste de paréntesis alrededor
    de átomos separados por espacios en blanco o alrededor de otras lista o
    alrededor de ambos átomos u otras listas. Una lista puede tener solo un
    átomo o no tener absolutamente nada en ella.  Una lista con nada dentro
    se ve así: @c{()}, y se llama @:{lista vacía}. A diferencia de cualquier
    otra cosa, una lista vacía es tanto un átomo, como una lista al mismo
    tiempo.

    La representación impresa de átomos y listas se llaman @:{expresiones
    simbólicas} o, más concisamente, @:{s-expresiones}.  La palabra
    @:{expresión} por sí misma puede referir o bien a la representación
    impresa, o al átomo o a la lista como se maneja internamente en el
    ordenador. Con frecuencia, las personas usan el término @:{expresión}
    indiscriminadamente. (También, en muchos textos, la palabra @:{forma} se
    usa como un sinónimo para la expresión.)

    Por cierto, los átomos que componen nuestro universo fueron nombrados asi
    cuando se pensaba que eran indivisibles; pero se ha encontrado que los
    átomos fisicos no son indivisibles. Las partes pueden dividir un átomo o
    puede fisionarse en 2 partes de igual tamaño. Los átomos físicos se
    nombraron prematuramente, antes de que su verdadera naturaleza fuese
    encontrada. En Lisp, ciertos tipos de átomos, como un array, pueden ser
    separados en partes; pero el mecanismo de hacer esto es diferente de el
    mecanismo para dividir una lista. En lo que se refiere a operaciones de
    lista, los átomos de una lista son indivisibles.

    Como en español, el significado de las letras que componen un átomo Lisp
    difiere del significado de las letras compuestas como una palabra. Por
    ejemplo, la expresión @'{ay}, es completamente diferente de las dos
    palabras @'{a}, e @'{y}.

    Hay muchos tipos de átomos en la naturaleza, pero solo unos pocos en
    Lisp: por ejemplo, @:{números}, tales como 37, 511, o 1729, y
    @:{símbolos}, tales como @'{+}, @'{foo}, o @'{forward-line}. Las palabras
    que hemos listado en los ejemplos anteriores son todos símbolos. En una
    conversacion cotidiana de Lisp, la palabra “átomo” no se usa con
    frecuencia, porque los programadores normalmente intentan ser más
    específicos acerca de que tipo de átomo están tratando. La programación
    Lisp es sobre todo de símbolos (y algunas veces números) con listas. (De
    ese modo, tres palabras rodeadas de paréntesis son una apropiada lista en
    Lisp, ya que consiste de átomos, que en este caso son símbolos, separados
    por espacios en blanco y cerrados por paréntesis, sin ninguna puntuacion
    no Lisp.)

    Texto entre comillas––incluso frases o párrafos––son también un átomo.
    Aquí hay un ejemplo:

    @src elisp
      '(esta lista incluye "texto entre comillas.")
    @end elisp

    En Lisp, todo el texto citado incluyendo la marca de puntuación y los
    espacios en blanco son un solo átomo. Este tipo de átomo es llamado
    @:{string} (por ‘cadena de caracteres’) y es el tipo de cosa que es usada
    para mensajes que un ordenador puede imprimir para que un humano lea. Las
    cadenas son un tipo de átomo diferente a los números, o símbolos y se
    usan de manera diferente.

*** Espacios en blanco en listas

    La cantidad de espacios en blanco en una lista no importa. Desde el punto
    de vista del lenguaje Lisp,

    @src elisp
      '(esta lista
         parece esto)
    @end src

    es exactamente lo mismo que esto:

    @src elisp
      '(esta lista parece esto)
    @end src

    Ambos ejemplos muestran que en Lisp es la misma lista, la lista hecha de
    los símbolos @'{esta}, @'{lista}, @'{parece}, y @'{esto} en este orden.

    Los espacios en blanco adicionales y los saltos de línea están diseñados para
    crear una lista más legible por humanos. Cuando Lisp lee la expresión,
    asimila los espacios en blanco extra (pero necesita tener al menos un
    espacio entre átomos en orden para contarlos aparte.)

    Aunque parezca raro, los ejemplos que hemos visto cubren casi todo lo que
    aparece en las listas Lisp. Cualquier otra lista en Lisp se ve más o
    menos igual a uno de estos ejemplos, excepto que la lista puede ser más
    larga y más compleja. En resumen, una lista está entre paréntesis, una
    cadena está entre comillas, un símbolo parece como una palabra, y un
    número parece un número. (Para ciertas situaciones, corchetes, puntos y
    otros caracteres especiales pueden ser usados; sin embargo; iremos
    bastante lejos sin ellos.)

*** GNU Emacs te ayuda a escribir listas

    Cuando se escribe una expresión Lisp en GNU Emacs usando bien el modo de
    Interacción Lisp o el modo Emacs Lisp, están disponibles varios comandos
    para formatear la expresión Lisp, de modo que sea fácil de leer. Por
    ejemplo, presionando la tecla @k{TAB} automáticamente se indenta la línea
    donde se encuetra el cursor a la cantidad correcta. Un comando para
    indentar apropiadamente el código en una región está asociado a
    @k{M-C-\}. La indentación está diseñada de modo que se pueda ver qué
    elementos percecen a cada lista––los elementos de una sublista están más
    indentados que los elementos de una lista cerrada.

    Además, cuando se escribe un paréntesis de cierre, Emacs momentáneamente
    salta el cursor atrás para hacer el matching (emparejamiento) con el
    paréntesis de apertura, para ver cuál es. Esto es muy útil, ya que cada
    lista que se escribe en Lisp debe tener sus paréntesis emparejados con
    sus paréntesis de apertura. (Ver Seccion @l{info:emacs#Major Modes<>Modos
    Mayores} en @e{El Manual de GNU Emacs}, para más información acerca de
    modos de Emacs.)

** Ejecutar un programa

   Una lista en Lisp––cualquier lista––es un programa listo para ser
   ejecutado. Si lo ejecutas (lo que la jerga Lisp llama @:{evaluar}), el
   ordenador hará una de tres cosas: nada excepto devolverte la lista misma;
   enviar un mensaje de error; o, tomar el primer símbolo en la lista como
   un comando para hacer alguna cosa. (¡Normalmente, es lo último de estas
   tres cosas de lo que realmente se quiere!).

   El apóstrofe, @c{'}, que se pone enfrente de algunos ejemplos de lista en
   secciones anteriores se llama @:{quote}; (citar); cuando precede a una
   lista, se informa a Lisp no hacer nada con la lista, mas que tomala tal
   como está escrita. Pero si no hay una cita precediendo la lista, el primer
   ítem de la lista es especial: es un comando para que el ordenador
   obedezca. (En Lisp, estos comandos son llamados @e{funciones}.) A
   continuación se muestra la lista no citada @c{(+ 2 2)}, por lo que Lisp
   comprende que @c{+} es una instrucción para hacer alguna cosa con el resto
   de la lista: suma los números que siguen.

   Si estás leyendo esto dentro de GNU Emacs, aquí está como puedes evaluar
   una lista: coloca tu cursor justo después del paréntesis derecho de la
   siguiente lista y presiona @k{C-x C-e}:

   @src elisp
     (+ 2 2)
   @end src

   Verás que el número @c{4} aparece en el área echo. (En la jerga, lo que
   acabas de hacer es “evaluar la lista.” El área echo es la línea en la
   parte inferior de la pantalla que muestra o hace “echo” del texto.) Ahora
   intenta la misma cosa con una lista citada: posiciona el cursor
   justo después de la siguiente lista y presiona @k{C-x C-e}:

   @src elisp
     '(esto es una lista citada)
   @end src

   Verás aparecer @c{(esto es una lista citada)} en el área echo.

   En ambos casos, lo que estás haciendo es dar un comando al programa dentro
   de GNU Emacs llamado @:{intérprete Lisp}––dando al intérprete un comando
   para evaluar la expresión. El nombre del intérprete Lisp viene de la
   palabra para la tarea hecha por un humano que viene con el significado de
   una expresión––quien lo “interpreta”.

   También se puede evaluar un átomo que no es parte de una lista––uno que no
   está rodeado por paréntesis; de nuevo, el intérprete Lisp traduce desde la
   expresión humanamente legible al lenguaje del ordenador. Pero antes de
   discutir esto (ver Seccion @l{Variables}), vamos a discutir lo que el
   intérprete de Lisp hace cuando tu creas el error.

** Generar un mensaje de error

   No se preocupe si genera un mensaje de error de manera accidental, ahora
   daremos un comando al intérprete de Lisp que genara un mensaje de error.
   Esta es una accion inofensiva; y de hecho, a menudo se intenta generar
   mensajes de error de manera intencional. Una vez se comprende la jerga,
   los mensajes de error pueden ser informativos. En vez de ser llamados
   mensajes de “error”, deberían ser llamados mensajes de “ayuda”. Son como
   letreros para un viajero en un país extraño; descifrarlos puede ser duro,
   pero una vez comprendidos, pueden señalar el camino.

   El mensaje de error es generado por un depurador de codigo incorporado
   dentro de GNU Emacs. Así se ‘entra al depurador’. Se puede salir del
   depurador pulsando @c{q}.

   Lo que se hace es evaluar una lista que no está citada y no tiene un
   comando con significado como su primer elemento. Aquí hay una lista casi
   exactamente igual a la que acabamos de usar, pero sin la cita al inicio.
   Coloque el cursor a la derecha donde esta finaliza y presione @k{C-x C-e}:

   @elisp
     (esto es una lista sin cita)
   @end src

   @ignore
     What you see depends on which version of Emacs you are running.

     In GNU Emacs version 24, a @f{*Backtrace*} window will open up and
     you will see the following in it:
   @end ignore

   Se abrirá una ventana @f{*Backtrace*} y se verá lo siguiente:

   @example
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function esto)
       (esto es una lista sin cita)
       eval((esto es una lista sin cita) nil)
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end example

   Su cursor estará en esta ventana (puede tener que esperar unos pocos
   segundos antes de que sea visible). Para salir del depurador y de su
   ventana, presione:

   @example
     q
   @end example

   Por favor, ahora pulsa @kbd{q}, as@'{@dotless{i}} se comprueba que se
   puede salir del depurador. A continuacion, presione "@kbd{C-x C-e} una vez
   mas para re-entrar.

   Sobre la base de lo que ya sabemos, casi podemos leer este mensaje de
   error.

   Leer el búffer @f{*Backtrace*} de abajo hacia arriba; informa lo que Emacs
   ha hecho. Cuando se presiona @k{C-x C-e}, se hace una llamada interactiva
   a el comando @c{eval-last-sexp}. @c{eval} es una abreviatura para
   ‘evaluar’ y @c{sexp} es una abreviatura para ‘expresión simbólica’.  El
   comando significa ‘evalúa la última expresión simbólica’, que es la
   expresión justo antes de tu cursor.

   Cada linea anterior a esta cuenta lo que el intérprete Lisp evaluo
   después. La acción más reciente está en la parte superior. El búffer es
   llamado @f{*Backtrace*} ya que permite realizar un seguimiento de Emacs
   hacia atrás.

   En la parte superior del búffer @f{*Backtrace*}, verá la línea:

   @example
     Debugger entered--Lisp error: (void-function esto)
   @end example

   El intérprete Lisp intentó evaluar el primer átomo de la lista, la palabra
   @'{esto}. Esta es la acción que generó el mensaje de error @'{void-function
   esto}.

   El mensaje contiene las palabras @'{void-function} y @'{esto}.

   La palabra @'{function} fué mencionada antes. Es una palabra muy
   importante. Para nuestros propósitos, podemos definirla diciendo que una
   @:{función} (@e{function}) es un conjunto de instrucciones para decirle al
   ordenador que haga alguna cosa.

   Ahora podemos empezar a comprender el mensaje de error: @'{void-function
   esto}. La función (que es, la palabra @'{esto}) no tiene la definición de
   ningun conjunto de instrucciones que el ordenador pueda realizar.

   La palabra ligeramente extraña, @'{void-function}, está diseñada para
   cubrir la forma en que Emacs Lisp lo implementa, que es cuando un símbolo
   no tiene una definición de función atribuido, el sitio que contiene la
   instruccion esta ‘vacio’ (@'(void)).

   Por otro lado, ya que fuimos capaces de sumar 2 más 2 de manera
   exitosa, evaluando @c{(+ 2 2)}, se puede inferir que el símbolo @c{+} debe
   tener un conjunto de instrucciones que el ordenador ejecuta y estas
   instrucciones deben sumar los números despues del @c{+}.

   Es posible evitar que Emacs entre en el depurador en casos como este. No
   se explicará cómo hacer esto aquí, pero se mencionará un resultado asi,
   porque se puede encontrar una situación similar si hay un error en algún
   código de Emacs que este usando. En tales casos, verá solo una línea del
   mensaje de error; aparecer en el área echo con el siguente aspecto:

   @example
     Symbol's function definition is void:@: esto
   @end example

   @ignore
     (Also, your terminal may beep at you––some do, some don't; and others
     blink.  This is just a device to get your attention.)
   @end ignore

   El mensaje aparece tan pronto se presiona una tecla, aunque sólo sea para
   mover el cursor.

   Conocemos el significado de la palabra @'{Symbol}. Se refiere al primer
   átomo de la lista, la palabra @'{este}. La palabra @'{function} se refiere
   a las instrucciones que dicen al ordenador que hacer. (Técnicamente, el
   símbolo indica al ordenador donde encontrar las instrucciones, pero esta
   es una complicación que podemos ignorar por el momento.)

   El mensaje de error puede ser comprendido: @'{La definición del símbolo
   está vacía: este}. El símbolo (que es, la palabra @'{este}) carece de
   instrucciones que el ordenador realize.

** Nombres de símbolos y definiciones de funciones

   Se puede articular otra característica de Lisp basada en lo que se
   discutió hace tiempo––una característica importante: un símbolo, como
   @c{+}, no es en sí mismo el conjunto de instrucciones que el ordenador
   realiza. En su lugar, el símbolo es usado, quizás temporalmente, como una
   manera de localizar la definición o conjunto de instrucciones. Lo que
   vemos es el nombre con el cual se pueden encontrar las instrucciones. Los
   nombres de las personas funcionan de la misma manera. Por ejemplo puede
   referirse a mi como @'{Bob}; sin embargo, no soy las letras @'{B}, @'{o},
   @'{b} pero soy, o fuí, conscientemente asociado con una forma de vida
   particular. El nombre no soy yo, pero puede ser usado para referirme.

   En Lisp, un conjunto de instrucciones puede ligarse a varios nombres. Por
   ejemplo, las instrucciones de ordenador para sumar números pueden ligarse
   al símbolo @c{más} asi como a el símbolo @c{+} (y se encuentran en algunos
   dialectos de Lisp). Entre humanos, puede referirse a @'{Robert} tan bien
   como @'{Bob} y con otras palabras también.

   Por otra parte, un símbolo puede estar ligado solo con una función a la
   vez. De lo contrario, el ordenador estaría confundido acerca de qué
   definición usar. Si este fuera el caso, solo una persona en el mundo
   podría llamarse @'{Bob}. Sin embargo, la definición de función a la que el
   nombre hace referencia puede cambiarse fácilmente. (Ver Sección
   @l{Instalar una Definición de Función}.)

   Ya que Emacs Lisp es extenso, se acostumbra nombrar los símbolos de manera
   que pueda establecerse a que parte de Emacs pertenece la función. En
   consecuencia, todos los nombres de funciones relacionadas con Texinfo
   empiezan con @'{texinfo-} y aquellas relacionadas con la lectura de correo
   empiezan con @'{rmail-}.

** El intérprete Lisp

   Basado en lo que se ha visto, ahora podemos empezar a entender lo que hace
   el intéprete de Lisp cuando mandamos a evaluar una lista. Primero, examina
   si hay un símbolo cita antes de la lista; si lo hay, el intérprete nos da
   la lista. Por otro lado, si no hay cita, el intéprete mira si el primer
   elemento en la lista tiene una definición de función. Si no, el intérprete
   imprime un mensaje de error.

   Así es como Lisp trabaja. Simple. Hay complicaciones añadidas que veremos
   en un minuto, pero estos son los fundamentos. Claro está, para escribir
   programas Lisp, se necesita conocer como escribir definiciones de función
   y vincularlas a nombres, y como hacer esto sin confundirnos a nosotros
   mismos o al ordenador.

   Ahora, una primera complicación. Además de las listas, el intérprete Lisp
   puede evaluar un símbolo no citado que no tiene paréntesis en torno a el.
   El intérprete Lisp intentará determinar el valor del símbolo como una
   @:{variable}.  Esta situación es descrita en el apartado de las variables.
   (Ver @l{Variables}.)

   La segunda complicación ocurre debido a que algunas funciones son
   inusuales y no funcionan de la manera habitual. Estas son llamadas
   @:{formas especiales}. Son usadas para trabajos especiales, como definir
   una función, y no son muchas de ellas. En los siguientes capítulos, se
   presentaran varias de las formas especiales más importantes.

   La tercera y final complicación es la siguiente: si la función que el
   intérprete Lisp está buscando no es una forma especial, y si es parte de
   una lista, el intérprete Lisp mira si la lista tiene una lista dentro de
   ella. Si hay una lista dentro, el intérprete Lisp primero descubre qué
   hacer con la lista interior, y luego trabaja en la lista exterior. Si aún
   hay otra lista embebida dentro de la lista interna, trabaja en esta
   primero, y así. Siempre se trabaja en la lista m@'as interna primero. El
   interprete trabaja en la lista más interana primero, para evaluar el
   resultado de esta lista. El resultado puede ser usado por la expresión
   entre paréntesis.

   Por lo demas, el intérprete trabaja de izquierda a derecha, desde una
   expresión a la siguiente.

*** Compilación de bytes

    Otro aspecto de interpretación: el intérprete Lisp es capaz de
    interpretar dos tipos de entidad: código humanamente legible, en el que
    nos centraremos exclusivamente, y código especialmente procesado, llamado
    @:{byte compilado}, que no es humanamente legible. El código máquina
    compilado se ejecuta más rápido que el código humanamente legible.

    Tu puedes transformar código legible por humanos en código compilado
    ejecutando uno de los comandos de compilació como @c{byte-compile-file}.
    El código compilado es normalmente almacenado en un fichero que finaliza
    con una extensión @f{.elc} en vez de una extensión @f{.el}. Verás ambos
    tipos de ficheros en el directorio @f{emacs/lisp}; los ficheros para leer
    estos tinen la extensión @f{.el}.

    Como una cuestión práctica, para hacer la mayoría de las cosas como
    personalizar o extender Emacs, no necesitas compilar codigo; y no
    comentare el asunto aquí. Ver Seccion @l{info:emacs#Byte
    Compilation<>Código Compilado) en @e(El Manual de Referencia de GNU
    Emacs), para una completa descripción de la compilacion de código.

** Evaluación

   Cuando el intérprete Lisp trabaja en una expresión, el término para la
   actividad es llamada @:{evaluación}. Decimos que el intérprete ‘evalúa la
   expresión’. Yo he usado este término varias veces antes. La palabra proviene
   dee su uso en el lenguaje cotidiano, ‘para determinar el valor o la cantidad de;
   para estimar’ de acuerdo a @e{Webster's New Collegiate Dictionary}.

   Después de evaluar una expresión, el intérprete Lisp normalmente
   @:{devuelve} el valor que el ordenador produce al llevar a cabo las
   instrucciones encontradas en la definición de la función, o quizás dará
   esta función y producirá un mensaje de error. (El intérprete puede también
   quedarse colgado, por así decirlo, a una función diferente o puede intentar
   repetir continuamente lo que está haciendo para siempre y siempre en lo que
   se llama un ‘bucle infinito’. Estas acciones son menos comunes; y
   pueden ignorarse). Más frecuentemente, el intérprete devuelve un valor.

   Al mismo tiempo que el intérprete devuelve un valor, puede también
   realizar cualquier otra cosa, como mover un cursor o copiar un fichero;
   este otro tipo de acción es llamado @:{efecto secundario}.  Acciones que
   los humanos creen que son importantes tales como imprimir resultados, con
   frecuencia son, “efectos secundarios” del intérprete Lisp. La jerga puede
   sonar peculiar, pero resulta que es bastante fácil aprender a utilizar los
   efectos secundarios.

   En resumen, evaluar una expresión simbólica normalmente causa que el
   intérprete devuelva un valor y tal vez llevar a cabo un efecto secundario;
   o al menos produce un error.

*** Evaluación de listas internas

    Si la evaluación se aplica a una lista que está dentro de una lista, la
    lista externa puede usar el valor devuelto por la primera evaluación como
    información cuando la lista externa es evaluada. Esto explica por qué las
    expresiones internas son evaluadas primero: los valores devueltos son
    usados por las expresiones externas.

    Nosotros podemos investigar este proceso evaluando otro ejemplo
    adicional. Coloca tu cursor después de la siguiente expresión y presiona
    @k{C-x C-e}:

    @example
      (+ 2 (+ 3 3))
    @end example

    El número 8 aparecerá en el área echo.

    Lo que ocurre es que el intérprete Lisp primero evalúa la expresión
    interna, @c{(+ 3 3)}, para que el valor 6 se devuelva; a continuación
    evalúa la expresión externa como si fuera escrita @c{(+ 2 6)}, que
    devuelve el valor 8. Puesto que no hay más expresiones entre parentesis a
    evaluar el intérprete imprime este valor en el área echo.

    Ahora es fácil comprender el nombre del comandos invocado por el atajo
    @k{C-x C-e}: el nombre es @c{eval-last-sexp}. Las letras @c{sexp} son una
    abreviatura para ‘expresión simbólica’, y @c{eval} es una abreviatura
    para ‘evaluar’. El comando significa ‘evaluar la última expresión
    simbólica’.

    Como un experimento, puedes intentar evaluar la expresión poniendo el
    cursor al principio de la siguiente línea inmediatamente después de la
    expresión, o dentro de la expresión.

    Aquí hay otra copia de la expresión:

    @example
      (+ 2 (+ 3 3))
    @end example

    Si se coloca el cursor al principio de la línea en blanco que sigue
    inmediatamente a la expresión y presionas @k{C-x C-e}, aún se obtendrá el
    valor 8 impreso en el área echo. Ahora coloca el cursor dentro de la
    expresión. Si lo coloca justo después del penúltimo paréntesis (dara la
    impresión de situarse sobre el último paréntesis), ¡obtendrá un 6 impreso
    en el área echo! Esto es porque el comando evalúa la expresión @c{(+ 3
    3)}.

    Ahora coloque el cursor inmediatamente después de un número.  Presiona
    @k{C-x C-e} y obtendra el número en sí. En Lisp, si evalúas un número,
    obtienes el número en sí––así es cómo los números difieren de los
    símbolos. Si se evalúa una lista que inicia con un símbolo como @c{+},
    tendrás un valor devuelto que es el resultado del ordenador tras ejecutar
    las instrucciones que aparecen en la definición de la función ligada a
    ese nombre. Si un símbolo por sí mismo es evaluado, algo diferente
    sucede, como veremos en la siguiente sección.

** Variables



   En Emacs Lisp, un símbolo puede estar ligado a un valor como a una
   definición de función. Las dos son diferentes. La definición de función es
   un conjunto de instrucciones que el ordenador ejecuta. Por otro lado, un
   valor, es algo, como un número o un nombre, que puede variar (es por ello,
   que tal símbolo es llamado variable). El valor de un símbolo puede ser
   cualquier expresión en Lisp, por ejemplo un símbolo, número, lista, o
   cadena. Un símbolo que tiene un valor es con frecuencia llamado una
   @:{variable}.

   Un símbolo puede tener ambos, una definición de función y un valor adjunto
   al mismo tiempo. O puede tener solo uno u otro. Los dos son
   independientes.  Esto es algo similar a la forma en que el nombre
   Cambridge puede referirse a la ciudad en Massachusetts y tener alguna
   información ligada al nombre, por ejemplo, un “gran centro de
   programación”.

   @ignore
     (Incidentally, in Emacs Lisp, a symbol can have two
     other things attached to it, too: a property list and a documentation
     string; these are discussed later.)
   @end ignore

   Otra forma de pensar en esto es imaginar un símbolo como un mueble con
   cajones. La definición de función se pone en un cajón, el valor en otro, y
   asi sucesivamente. Lo que se pone en el cajón que contiene el valor puede
   ser cambiado sin afectar los contenidos del cajón que almacena la
   definición de función, y viceversa.

   La variable @c{fill-column} ilustra un símbolo con un valor adjunto: en
   cada buffer de GNU Emacs, este símbolo se establece a algún valor,
   normalmente 72 o 70, pero algunas veces a algún otro valor. Para encontrar
   el valor de este símbolo, evalúalo por sí mismo. Si está leyendo esto
   dentro de GNU Emacs, puedes hacer esto poniendo el cursor después del
   símbolo y pulsar @k{C-x C-e}:

   @example
     fill-column
   @end example

   Después de presionar @k{C-x C-e}, Emacs imprimió el número 72 en mi área
   echo. Este es el valor que he establecido para @c{fill-column} mientras
   escribo esto. Puede ser diferente en tu búffer. Observe que el valor
   devuelto como una variable es impreso exactamente de la misma forma que el
   valor devuelto por una función tras ejecutar sus instrucciones.  Desde el
   punto de vista del intérprete Lisp, un valor devuelto es un valor
   devuelto. Que tipo tipo de expresión sea, deja de importar una vez que el
   valor se conoce.

   Un símbolo puede tener cualquier valor ligado a él o, siendo tecnicos, se
   puede @:{bind} (enlazar) la variable a un valor: a un número, por ejemplo
   72; a una cadena, @c{\"como esta\"}; a una lista, como @c{(abeto pino
   roble)}; podemos incluso asociar una variable a una definición de función.

   Un símbolo puede vincularse a un valor de varias maneras. Ver Sección
   @l{Configurando el valor de una variable}, para obtener información sobre
   una manera de hacer esto.

*** Mensaje de error de un símbolo sin una función

    Cuando evaluamos @c{fill-column} para encontrar su valor como una
    variable, no se ponen paréntesis alrededor de la palabra. Esto se debe a
    que no pretendemos usarlo como un nombre de función.

    Si @c{fill-column} fuese el primer o único elemento de una lista, el
    intérprete Lisp intentaría encontrar la definición de función adjunta.
    Pero @c{fill-column} no tiene una definición de función. Trata de evaluar
    esto:

    @example
      (fill-column)
    @end example

    Se creará un buffer @f{*Backtrace*} que dice:

    @example
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (void-function fill-column)
        (fill-column)
        eval((fill-column))
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    @end example

    (Recuerda, para salir del depurador y hacer que la ventana del depurador
    desaparezca, presiona @k{q} en el buffer @f{*Backtrace*}.)

*** Mensaje de error de un símbolo sin un valor

    Si intenta evaluar un símbolo que no tiene un valor asociado, recibirá un
    mensaje de error. Esto se puede ver experimentando con nuestra suma 2
    más 2. En la siguiente expresión, pon el cursor justo después del
    @c{+}, antes del primer número 2, presiona @k{C-x C-e}:

    @src elisp
      (+ 2 2)
    @end src

    En GNU Emacs 24, se creará un buffer @f{*Backtrace*} que dice:

    @example
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (void-variable +)
        eval(+ nil)
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp nil nil)
        command-execute(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    @end example

    (De nuevo, se puede salir del depurador pulsando @k{q} en el búffer
    @f{*Backtrace*}.)

    Esta traza inversa es diferente del primer mensaje de error que vimos,
    que decia, @'{Debugger entered--Lisp error: (void-function esto)}. En
    este caso, la función no tiene una valor como una variable; mientras en
    el otro mensaje de error, la función (la palabra ‘esto’) no tuvo una
    definición.

    En este experimento con el @c{+}, lo que hicimos fué hacer que el
    intérprete Lisp evalúe el @c{+} y busque el valor de la variable en lugar
    de la definición de la función. Hicimos esto colocando el cursor justo
    después del símbolo en lugar de ponerlo al final de los parentesis que
    cierran la lista como hicimos antes. Como consecuencia, el intérprete
    Lisp evaluó la s-expresión anterior, que en este caso fué el @c{+} en sí.

    Ya que @c{+} no tiene un valor asociado, solo la definición de función,
    el mensaje de error informa que el valor del símbolo como una variable
    estaba vacío.

** Argumentos

   Para ver cómo la información se pasa a las funciones, veamos de nuevo
   nuestro viejo recurso, la suma de dos más dos. En Lisp, esto se escribe
   como sigue:

   @src elisp
     (+ 2 2)
   @end src

   Si se evalúa esta expresión, el número 4 aparecerá en tu área echo. Lo que
   el intérprete de Lisp hace es sumar los números despues del @c{+}.

   Los números sumados por @c{+} son llamados @:{argumentos} de la función
   @c{+}. Estos números son la información que se da o @:{pasa} a la función.

   La palabra ‘argumento’ proviene de la forma en que se utiliza en las
   matemáticas y no se refiere a una disputa entre 2 personas, En su lugar,
   se refiere a la información entregada a la función, en este caso, al
   @c{+}. En Lisp, los argumentos de una función son los átomos o listas que
   siguen a la función. Los valores devueltos por la evaluación de estos
   átomos o listas son pasados a la función. Funciones diferentes requieren
   diferentes números de argumentos; algunas funciones no requieren ninguno
   en absoluto.@n{2}

*** Tipos de dato de los argumentos

    El tipo de dato que debe ser pasado a una función dependen de que tipo de
    información se utiliza. Los argumentos de una función como @c{+} deben
    tener valores númericos, ya que @c{+} suma números. Otras funciones
    utilizan diferentes tipos de datos para sus argumentos.

    Por ejemplo, la función @c{concat} concatena o une dos o más cadenas de
    texto para producir una cadena. Los argumentos son cadenas. Concatenar
    las cadenas de caracteres @c{abc}, @c{def} produce una cadena @c{abcdef}.
    Esto puede ser visto evaluando lo siguiente:

    @src elisp
      (concat "abc" "def")
    @end src

    El valor producido por la evaluación de esta expresión es @c{"abcdef"}.

    Una función como @c{substring} utiliza ambos una cadena y numeros como
    argumentos. La función devuelve una parte de la cadena, una subcadena del
    primer argumento. Esta función toma tres argumentos. Su primer argumento
    es la cadena de caracteres, el segundo y tercer argumento son números que
    indican el principio y el fin de la subcadena. Los números son un conteo
    del número de caracteres (incluyendo espacios y puntuaciones) desde el
    principio de la cadena.

    Por ejemplo, si evalúa lo siguiente:

    @src elisp
      (substring "El rápido zorro marrón saltó." 10 15)
    @end elisp

    Verá @c{"zorro"} aparecer en el área echo. Los argumentos son la cadena y
    los dos números.

    Tenga en cuenta que la cadena pasada a @c{substring} es un solo átomo a
    pesar de estar compuesto de varias palabras separadas por espacios. Lisp
    considera que cualquier cosa entre dos marcas de cita es parte de la
    cadena, incluyendo los espacios. Se puede pensar en la función
    @c{substring} como una tipo de ‘acelerador de particulas’ ya que toma un
    átomo de otro modo indivisible y extrae una parte. Sin embargo,
    @c{substring} solo es capaz de extraer una subcadena de un argumento que
    es una cadena, no de otro tipo de átomo por ejemplo un número o símbolo.

*** Un argumento como el valor de una variable o lista

    Un argumento puede ser un símbolo que devuelve un valor al ser evaluado.
    Por ejemplo, evaluar el símbolo @c{fill-column} en si, devuelve un
    número. Este número se puede utilizar en una suma.

    Coloca el cursor después de la siguiente expresión y presiona @k{C-x
    C-e}:

    @src elisp
      (+ 2 fill-column)
    @end src

    El valor será dos mas el número que se obtiene al evaluar solamente
    @c{fill-column}. En mí caso, es 74, porque mi valor de @c{fill-column}
    es 72.

    Como acabamos de ver, un argumento puede ser un símbolo que devuelve un valor
    cuando se evalúa. Además, un argumento puede ser una lista que devuelve
    un valor cuando se evalúa. Por ejemplo, en la siguiente expresión, los
    argumentos de la función @c{concat} son las cadenas @c{"Los"} y @c{"
    zorros rojos."} y la lista @c{(number-to-string (+ 2 fill-column))}.

    @src elisp
      (concat "Los " (number-to-string (+ 2 fill-column)) " zorros rojos.")
    @end src

    Si se evalúa esta expresión––y si, como con mi Emacs, @c{fill-column} se
    evalúa a 72––aparecerá @c{"Los 74 zorros rojos."} en el área echo.
    (Tenga en cuenta que deben poner espacios después de la palabra @'{Los} y
    antes de la palabra @'{rojos} que aparecerán en la cadena final. La
    función @c{number-to-string} convierte el entero que devuelve la función
    suma a una cadena. @c{number-to-string} también se conoce como
    @c{int-to-string}.)

*** Número variable de argumentos

    Algunas funciones, como @c{concat}, @c{+}, o @c{*}, toman cualquier
    número de argumentos. (El @c{*} es el símbolo para la multiplicacion.)
    Esto puede verse evaluando cada una de las siguientes expresiones de la
    forma habitual. Lo que verás en el área echo se imprime en este texto
    después de @'{⇒}, que se puede leer como ‘evaluar a’.

    En el primer conjunto, las funciones no tienen argumentos:

    @example
      (+)       ⇒ 0

      (*)       ⇒ 1
    @end example

    En este conjunto, las funciones tienen un argumento cada una:

    @example
      (+ 3)     ⇒ 3

      (* 3)     ⇒ 3
    @end example

    En este conjunto, las funciones tienen tres argumentos cada una:

    @example
      (+ 3 4 5) ⇒ 12

      (* 3 4 5) ⇒ 60
    @end example

*** Usando el tipo incorrecto de objeto como un argumento

    Cuando a una función se le pasa un argumento del tipo incorrecto, el
    interpréte Lisp produce un mensaje de error. Por ejemplo, la función
    @c{+} espera que los valores de sus argumentos sean números. Como un
    experimento podemos pasar el símbolo citado @c{hola} en lugar de un
    número. Coloca el cursor después de la siguiente expresión y presiona
    @k{C-x C-e}:

    @src elisp
      (+ 2 'hola)
    @end src

    Al hacer esto se generará un mensaje de error. Lo qué ha ocurrido es que
    @c{+} ha intentado sumar el 2 al valor devuelto por @c{'hola}, pero el
    valor devuelto por @c{'hola} es el símbolo @c{hola}, no un número. Solo
    los números se pueden sumar. Por tanto @c{+} no pudo llevar a cabo su
    suma.

    Se creará e ingresara a un búffer @f{*Backtrace*} que dice:

    @example
      ---------- Buffer: *Backtrace* ----------
      Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p hola)
        +(2 hola)
        eval((+ 2 (quote hola)) nil)
        eval-last-sexp-1(nil)
        eval-last-sexp(nil)
        call-interactively(eval-last-sexp nil nil)
        command-execute(eval-last-sexp)
      ---------- Buffer: *Backtrace* ----------
    @end example

    Como de costumbre, el mensaje de error intenta ser útil y tiene sentido
    después de aprender cómo leerlo.@n{3}

    La primera parte del mensaje de error es sencilla; dice @'{wrong type
    argument} (tipo de argumento incorrecto). A continueción viene la
    misteriosa palabra tecnica @'{number-or-marker-p}. Esta palabra está
    intentando decirte qué tipo de argumento espera @c{+}.

    El símbolo @c{number-or-marker-p} dice que el intérprete Lisp está
    intentando determinar si la información presentada (el valor del
    argumento) es un número o una marca (un objeto especial que representa
    una posición de buffer). Lo que hace es probar si se le estan dando
    numeros a sumar a @c{+}. También chequea si el argumento es algo llamado
    marcador, que es una caracteristica específica de Emacs Lisp. (En Emacs,
    las ubicaciones en un búffer se registran como marcadores. Cuando se
    establece la marca con el comando @k{C-@@} o @k{C-SPC}, su posición se
    guarda como un marcador. La marca puede ser considerada como un
    número––el número de caracteres es la ubicacion desde el comienzo del
    búffer.)  En Emacs Lisp, @c{+} se puede utilizar para sumar el valor
    numérico de los marcadores como números.

    La @'{p} en @c{number-or-marker-p} es la encarnación de una práctica
    iniciada en los primeros días de la programación Lisp. La @'{p} significa
    ‘predicado’. En la jerga usada por los primeros investigadores de Lisp,
    un predicado se refiere a una función para determinar si alguna propiedad
    es verdadera o falsa. Entonces la @'{p} nos dice que @c{number-or-marker-p}
    es el nombre de una función que determina si el argumento dado es un
    número o una marca. Otros símbolos Lisp que finalizan en @'{p} incluyen
    @c{zerop}, una función que comprueba si su argumento tienen el valor de
    cero, y @c{listp}, una función que comprueba si su argumento es una
    lista.

    Finalmente, la última parte del mensaje de error es el símbolo @c{hola}.
    Este es el valor del argumento dado a @c{+}. Si a la suma se le hubiese
    pasado el tipo correcto de objeto, el valor habría sido un número, como
    37, en lugar de un símbolo como @c{hola}. Pero entonces no habrías
    obtenido el mensaje de error.

*** La función @c{message}

    Al igual que @c{+}, la función @c{message} toma un número variable de
    argumentos. Se utiliza para enviar mensajes al usuario y es tan útil que
    vamos a describirla.

    Se imprime un mensaje en el área echo. Por ejemplo, puede imprimir un
    mensaje en su área echo evaluando la siguiente lista:

    @src elisp
      (message "¡Este mensaje aparece en el área echo!")
    @end elisp

    Toda la cadena entre comillas dobles es un unico argumento y se imprime
    @i{en su totalidad}. (Note que en este ejemplo, el mensaje en sí aparece
    en el área echo entre comillas dobles; esto se debe a que ves el valor
    devuelto por la función @c{message}. En la mayoría de programas que
    escribiras, el texto será impreso en el área echo como un efecto
    secundario de @c{message}, sin las comillas. Ver Sección @l{Un
    @c{multiply-by-seven} interactivo} en detalle, para un ejemplo de esto.)

    Sin embargo, si hay un @'{%s} en la cadena de caracteres citada, la
    función @c{message} no imprime el @'{%s} como tal, pero mira el siguente
    argumento a continuacion de la cadena. Se evalúa el segundo argumento e
    imprime el valor en la ubicación de la cadena donde está el @'{%s}.

    Puede ver esto colocando el cursor después de la siguiente expresión y
    presionar @k{C-x C-e}:

    @src elisp
      (message "El nombre de este búffer es: %s." (buffer-name))
    @end src

    En Info, @c{"El nombre de este búffer es: *info*."} aparecerá en el área
    echo. La función @c{buffer-name} devuelve el nombre del búffer como una
    cadena, que la función @c{message} inserta en lugar de @c{%s}.

    Para imprimir un valor como un entero, utiliza @'{%d} de la misma forma
    que @'{%s}. Por ejemplo, para imprimir un mensaje en el área echo que
    indique el valor de @c{fill-column}, evalúa lo siguiente:

    @src elisp
      (message "El valor de fill-column es %d." fill-column)
    @end src

    En mi sistema, cuando evalúo esta lista, @c{"El valor de fill-column es
    72"} aparece en mi área echo@n{4}.

    Si hay más de un @'{%s} en la cadena citada, el valor del primer
    argumento después de la cadena citada se imprime en la posición del
    primer @'{%s} y el valor del segundo argumento se imprime en la posición
    del segundo @'{%s}, y así sucesivamente.

    Por ejemplo, si se evalúa lo siguiente,

    @src elisp
      (message "¡Hay %d %s en la oficina!"
               (- fill-column 14) "elefantes rosas")
    @end src

    Un mensaje un poco caprichoso aparecerán en el área echo. En mi sistema
    dice @c{"¿Hay 58 elefantes rosas en la oficina!"}

    Se evalúa la expresión @c{(- fill-column 14)} y el número resultante
    se inserta en lugar del @'{%d}; y la cadena entre comillas dobles,
    @c{"elefantes rosas"}, se trata como un solo argumento y se inserta
    en lugar del @'{%s}. (Es decir, una cadena entre comillas dobles se
    evalúa así misma, como un número.)

    Por último, aquí está un ejemplo algo complejo que no solo ilustra el
    cálculo de un número, también muestra como se puede usar una expresión
    dentro de una expresión para generar el texto que sustituira el @'{%s}:

    @src elisp
      (message "Él vió %d %s"
               (- fill-column 36)
               (concat "rojos "
                       (substring
                        "Los rápidos zorros marrones saltaron." 12 18)
                       " saltando."))
    @end src

    En este ejemplo, @c{message} tiene tres argumentos: la cadena, @c{"Él vió
    %d %s"}, la expresión, @c{(- fill-column 32)}, y la expresion a partir de
    la función @c{concat}. El valor resultante de la evaluación de @c{(-
    fill-column 32)} se inserta en lugar del @'{%d}; y el valor devuelto por
    la expresión que inicia con @c{concat} se inserta en lugar del @'{%s}.

    Cuando @c(fill-column) es 70 y se evalúa la expresión, aparecera el
    mensaje @c{"Él vió 38 rojos zorros saltando."} en tu área echo.

** Configurando el valor de una variable

   Hay varias formas de asignar un valor a una variable. Una de ellas es
   utilizar la función @c{set} o la función @c{setq}.  Otra forma es utilizar
   @c{let} (vease Seccion @lc{let}). (La jerga para este proceso es @:{bind}
   (ligar) una variable a un valor.)

   Las siguientes secciones no solo describen cómo operan @c{set} y @c{setq},
   también ilustran como se pasan los argumentos.

*** Usando @c{set}

    Para establecer el valor del símbolo @c{flores} a la lista @c{'(rosa
    violeta margarita tulipan)}, evalúa la siguiente expresión colocando
    el cursor después de la expresión y presiona @k{C-x C-e}.

    @src elisp
      (set 'flores '(rosa violeta margarita tulipan))
    @end src

    La lista @c{(rosa violeta margarita tulipan)} aparecerá en el área
    echo. Esto es @e{devuelto} por la función @c{set}. Como efecto
    secundario, el símbolo @c{flores} esta ligado a la lista; es decir, el
    símbolo @c{flores}, puede verse como una variable, que entrega la lista
    como su valor. (Por cierto, este proceso, ilustra como un efecto
    secundario al intérprete Lisp, estableciendo el valor, puede ser el
    principal efecto en el que los humanos estamos interesados. Esto se debe
    a que cada función Lisp debe devolver un valor si no obtiene un error,
    pero solo tendrá un efecto secundario si está diseñado para tener uno.)

    Después de evaluar la expresión @c{set}, se puede evaluar el símbolo
    @c{flores} y ha de devolver el valor que acaba de establecer. Aquí está
    el símbolo. Coloca el cursor al final de este y presiona @k{C-x C-e}.

    @src elisp
      flores
    @end src

    Al evalúar @c{flores}, aparece la lista @c{(rosa violeta margarita
    tulipan)} en el área echo.

    Por cierto, si se evalúa @c{'flores}, la variable con una cita frente a
    ella, lo que verá en el área echo es el símbolo en sí mismo: @c{flores}.
    Aquí está el símbolo citado, para que pueda probar esto:

    @src elisp
      'flores
    @end src

    También tenga en cuenta, que cuando se utiliza @c{set}, es necesario
    citar ambos argumentos de @c{set}, a menos que los quiera evaluar.
    Puesto que no queremos evaluar, ni la variable @c{flores}, ni la lista
    @c{(rosa violeta margarita tulipan)}, ambos se citan. (Cuando se utiliza
    @c{set} sin citar su primer argumento, el primer argumento se evalúa
    antes de realizar cualquier otra cosa. Si hizo esto y @c{flores} no tenía
    ya un valor, otendria un mensaje de error con el @'{Valor de símbolo como
    variable vacío}; por otro lado, si @c{flores} regreso un valor después de
    ser evaluado, @c{set} intentaría establecer el valor que fue devuelto.
    Hay situaciones donde esto es justo lo que la función a de hacer, pero
    estas situaciones son poco frecuentes.)

*** Usando @c{setq}

    Como una cuestión práctica, casi siempre se cita el primer argumento de
    @c{set}. La combinación de @c{set} y un primer argumento citado es tan
    común que tiene nombre propio: la forma especial @c{setq}. Esta forma
    especial es igual a @c{set} excepto que el primer argumento es citado
    automáticamente, por lo que no necesita escribir la marca de cita.
    También, para mayor comodidad, @c{setq} permite asignar varias variables
    diferentes a diferentes valores, todo en una expresión.

    Para establecer el valor de la variable @c{carnívoros} a la lista
    @c{'(leon tigre leopardo)} usando @c{setq}, se utiliza la siguiente
    expresión:

    @src elisp
      (setq carnivoros '(leon tigre leopardo))
    @end src

    Esto es exactamente igual que usar @c{set} excepto que el primer
    argumento se cita automáticamente por @c{setq}. (La @'{q} en @c{setq}
    significa @c{quote}.)

    Con @c{set}, la expresión que se vería es:

    @src elisp
      (set 'carnivoros '(leon tigre leopardo))
    @end src

    Además, @c{setq} se puede utilizar para asignar diferentes valores a
    diferentes variables. El primer argumento se une a al valor del segundo
    argumento, el tercer argumento se une a al valor del cuarto argumento, y
    así sucesivamente. Por ejemplo, podría utilizar lo siguiente para asignar
    una lista de árboles al símbolo @c{arboles} y una lista de herbívoros al
    símbolo @c{herbivoros}:

    @src elisp
      (setq arboles '(pino abeto roble arce)
            herbivoros '(gacela antilope cebra))
    @end src

    (La expresión podría también haber estado en una sola línea, pero podría
    no caber en una página; y a los humanos les resulta más fácil leer listas
    con un formato agradable.)

    Aunque he estado usando el término ‘asignar’, hay otra forma de pensar
    respecto a el funcionamiento de @c{set} y @c{setq}; y consiste en decir
    que @c{set} y @c{setq} crean un símbolo que @e{apunta} a la lista. Esta
    ultima forma de pensar es muy común y en los proximos capítulos
    deberiamos encontrar al menos un símbolo con un ‘puntero’ como parte de
    su nombre. El nombre es elegido porque el símbolo tiene un valor,
    específicamente una lista, unida a el; o, expresado de otra manera, el
    símbolo se ajusta para “apuntar” a la lista.

*** Contando

    He aquí un ejemplo que muestra cómo utilizar @c{setq} en un contador. Es
    posible usar esto para contar cuantas veces una parte de un programa se
    repite. En primer lugar establesca una variable a cero; a continuación
    suma uno al número cada vez que el programa se repita. Para ello, se
    necesita una variable que sirva como un contador, y dos expresiones: una
    expresión @c{setq} inicial que asigna la variable contador a cero; y una
    segunda expresión @c{setq} que incrementa el contador cada vez se evalua.

    @src elisp
      (setq contador 0)                ; Llamemos a esto el inicializador.

      (setq contador (+ contador 1))   ; Este es el incremento.

      contador                         ; Este es el contador.
    @end src

    (El texto que sigue al @'{;} son los comentarios. Véase Sección
    @l{Cambiar una definición de función}.)

    Si evalúas la primera de estas expresiones, el inicializador, @c{(setq
    contador 0)}, y luego evalúas la tercera expresión, @c{contador}, el
    número @c{0} aparecerá en el área echo. Si a continuación se evalúa la
    segunda expresión, el incremento, @c{(setq contador (+ contador 1))}, el
    contador tendrá el valor 1. Así que si evalúas de nuevo @c{contador}, el
    número @c{1} aparecerá en el área echo. Cada vez que se evalúa la segunda
    expresión, el valor del contador será incrementado.

    Al evalúar el incremento, @c{(setq contador (+ contador 1))}, el
    intérprete Lisp evalúa en primer lugar la lista interna; esto es la
    suma. Con el fín de evaluar esta lista, se debe evaluar la variable
    @c{contador} y el número @c{1}. Cuando evalúa la variable @c{contador},
    se recibe su valor actual. Se pasa este valor y el número @c{1} a @c{+}
    que los suma. La suma se devuelve como el valor de la list interior y
    pasa a @c{setq} que establece la variable @c{contador} a este nuevo
    valor. Por lo tanto, el valor de la variable @c{contador}, cambia.

** Resumen

   Aprender Lisp es como subir una colina en la que la primera parte es la
   mas empinada. Ahora has subido la parte más difícil; lo que queda se
   vuelve más fácil a medida que avanzas hacia adelante.

   En resumen,

   - Los programas Lisp se componen de expresiones, que son listas o átomos
     individuales.

   - La listas se componen de cero o más átomos o listas internas, separadas
     por espacios en blanco y rodeadas por paréntesis. Una lista puede estar
     vacía.

   - Los átomos son símbolos de varios caracteres, como
     @c{forward-paragraph}, símbolos de un solo caracter como @c{+}, cadenas
     de caracteres entre comillas dobles, o números.

   - Un número se evalúa a sí mismo.

   - Una cadena entre comillas dobles también se evalúa a sí misma.

   - Cuando se evalúa un símbolo a sí mismo, se devuelve su valor.

   - Cuando se evalúa una lista, el intérprete Lisp mira el primer símbolo en
     la lista y luego la definición de función asociada a ese símbolo. A
     continuación, las instrucciones en la definición de función se llevan a
     cabo.

   - Una marca de cita, @c{'}, le indica al intérprete Lisp que devuelva la
     siguiente expresión como esta escrita, y no la evalúa como lo haria si
     la cita no estuviera alli.

   - Los argumentos son la información que se pasa a una función. Los
     argumentos de una función se calculan evaluando el resto de los
     elementos de la lista de los que la función es el primer elemento.

   - Una función siempre devuelve un valor cuando se evalúa (a menos que
     obtenga un error); además, también se puede llevar a cabo algun tipo de
     acción llamado “efecto secundario”. En muchos casos, el propósito
     principal de una función es crear un efecto secundario.

** Ejercicios

   Unos ejercicios sencillos:

   - Generar un mensaje de error evaluando un símbolo apropiado que no está
     entre paréntesis.

   - Generar un mensaje de error evaluando un símbolo apropiado que está
     entre paréntesis.

   - Crear un contador que se incrementa en dos en lugar de uno.

   - Escribe una expresión que imprima un mensaje en el área eco cuando se
     evalua.

* Practicando evaluación

  Antes de aprender como escribir una definición de función en Emacs Lisp, es
  útil gastar un poco de tiempo evaluando diversas expresiones que ya han
  sido escritas. Estas expresiones serán listas con funciones como su primer
  (y con frecuencia único) elemento. Dado que algunas de las funciones
  asociadas con búffers son a la vez simples e interesantes, vamos a iniciar
  con estas. En esta sección, vamos a evaluar algunas de este tipo. En otra
  sección, estudiaremos el código de varias otras funciones relacionadas con
  búffers, para ver la forma cómo fueron escritas.

  @i{Siempre que proporciona un comando de edición} a Emacs Lisp, como el
  comando para mover el cursor o para desplazarse por la pantalla, @i{se está
  evaluando una expresión,} de la cual el primer elemento es una función.
  @i{Así es cómo funciona Emacs}.

  Al presionar las teclas, se provoca una evaluacion de parte del intérprete
  Lisp que devuelve resultados. Incluso escribir texto plano implica evalúar
  una función Emacs Lisp, en este caso, se utiliza @c{self-insert-command},
  que simplemente inserta el caracter escrito.  Las funciones que se evalúan
  presionando atajos de teclado se llaman funciones @:{interactive}, o
  @:{comandos}; como crear una función interactive será ilustrado en el
  capítulo sobre cómo escribir definiciones de funciones. Ver @l{Crear una
  Función Interactiva}.

  Además de presionar comandos de teclado, hemos visto una segunda manera de
  evaluar una expresión: colocar el cursor después de una lista y presionar
  @k{C-x C-e}. Esto es lo que se hará en el resto de esta sección. Hay otras
  maneras de evaluar una expresión; que serán descritas cuando llegemos a
  ellas.

  Ademas de utilizarce para prácticar la evaluación, las funciones mostradas
  en las siguientes secciones son importantes por derecho propio. Un estudio
  de estas funciones deja claro la distinción entre búffers y ficheros, cómo
  cambiar a un búffer, y como determinar una ubicación dentro de ella.

** Nombres de búffer

   Las dos funciones, @c{buffer-name} y @c{buffer-file-name}, muestran la
   diferencia entre un fichero y un búffer. Cuando se evalúa la siguiente
   expresión, @c{(buffer-name)}, el nombre del buffer aparece en el area eco.
   Al evaluar @c{(buffer-file-name)}, el nombre del fichero al que se
   relaciona el búffer aparece en el área echo. Por lo general, el nombre
   devuelto por @c{(buffer-name)} es el mismo que el nombre del fichero al
   que hace referencia, y el nombre devuelto por @c{(buffer-file-name)} es la
   ruta completa del fichero.

   Un fichero y un búffer son dos entidades diferentes. Un fichero es la
   información grabada de manera permanente en el ordenador (a menos que se
   elimine). Un búffer, por otro lado, es la información dentro de Emacs que
   desaparecerá al final de la sesión de edición (o cuando matas el
   búffer). Por lo general, un búffer contiene información que se ha copiado
   desde un fichero; decimos que el búffer está @:{visitando} este fichero.
   Esta copia es la que se trabaja y modifica. Los cambios al búffer no
   cambian el fichero, hasta ser guardados. Al guardar el búffer, el búffer
   se copia en el fichero y por lo tanto se guarda de forma permanente.

   Si está leyendo esto dentro de GNU Emacs dentro de Info, puede evaluar
   cada una de las siguientes expresiones colocando el cursor después de
   estas y pulsando @k{C-x C-e}.

   @src elisp
     (buffer-name)

     (buffer-file-name)
   @src elisp

   Cuando hago esto en Info, el valor devuelto para la evaluación de
   @c{(buffer-name)} es @f{"*info*"}, y el valor devuelto por evaluar
   @c{(buffer-file-name)} es @f{nil}.

   Por otro lado, mientras escribo este documento, el valor devuelto por la
   evaluación de @c{(buffer-name)} es @f{"introduction.texinfo"}, y el valor
   devuelto por la evaluación de @c{(buffer-file-name)} es
   @f{"/gnu/work/intro/introduction.texinfo"}.

   El primero es el nombre del búffer y el segundo es el nombre del
   fichero. En Info, el nombre del búffer es @f{"*info*"}. Info no apunta a
   ningún fichero, por lo que el resultado de evaluar @c{(buffer-file-name)}]
   es @f{nil}. El símbolo @c{nil} proviene del latin, significa ‘nada’; en
   este caso, significa que el búffer no está asociado con ningun fichero.
   (En Lisp, @c{nil} también se utiliza con el significado de ‘falso’ y es
   sinómino para lista vacía, @c{()}.)

   Al escribir esto, el nombre de mi búffer es @f{"introduction.texinfo"}. El
   nombre del fichero al que apunta es @f{"/gnu/work/intro/introduction.texinfo"}.

   (En las expresiones, los paréntesis le indican al intérprete Lisp tratar a
   @c{buffer-name} y @c{buffer-file-name} como funciones; sin los paréntesis,
   el intérprete intentaría evaluar los símbolos como variables. Véase la
   Sección @l{Variables}.)

   A pesar de la distinción entre ficheros y búffers, con frecuencia
   encontrara personas referirse a un fichero cuando quieren un búffer y
   vice-versa. De hecho, la mayoría de la gente dice, “Estoy editando un
   fichero,” en lugar de decir, “Estoy editando un búffer que pronto voy a
   guardar en un fichero.” Esto casi siempre queda claro a partir del
   contexto de lo que la gente dice. No obstante, Al tratar con programas de
   ordenador, es importante mantener la distinción en mente, ya que el
   ordenador no tan inteligente como una persona.

   Por cierto, la palabra ‘búffer’, viene del significado de la palabra como
   un cojín que amortigua la fuerza de una colisión. En los primeros
   ordenadores, un búffer amortiguaba la interacción entre los ficheros y la
   unidad central de procesamiento de la computadora. Los tambores o cintas
   que contenian un fichero y la unidad de procesamiento eran piezas de
   equipamiento muy diferentes entre si, trabajando a sus propias
   velocidades, por rachas. El búffer hizo posible que ambos trabajaran
   juntos de manera efectiva. Con el tiempo, el búffer pasó de ser un
   intermediario, a un lugar de almacenamiento temporalmente, donde se
   realiza el trabajo. Esta transformación se parace bastante a la de un
   pequeño puerto que se convierte en una gran ciudad: una vez fué el lugar
   donde la carga era depositada temporalmente antes de ser cargada en los
   barcos; despues se convirtio en un centro comercial y cultural por derecho
   propio.

   No todos los búffers están asociados con ficheros. Por ejemplo, el búffer
   @f(*scratch*) no visita ningun fichero. Del mismo modo, un búffer
   @f{*Help*} no está asociado a ningun fichero.

   En los viejos tiempos, cuando se carecia de un fichero @f{~/.emacs} y se
   iniciava una sesión Emacs escribiendo unicamente el comando @c{emacs}, sin
   nombrar ningun fichero, Emacs iniciaba con el búffer @f{*scratch*}
   visible. Hoy en día, vera una pantalla de vienvenida. Puede seguir uno de
   los comandos sugeridos en dicha pantalla, visitar un fichero, o presionar
   la barra espaciadora para llegar al búffer @f{*scratch*}.

   Si cambia al búffer @f{*scratch*}, escriba @c{(buffer-name)}, coloque el
   cursor al final de la expresión, y presione @k{C-x C-e} para evaluar la
   expresión. El nombre @c{*scratch*} será devuelto y aparecerá en el área
   echo. @c{*scratch*} es el nombre del búffer. Al escribir y evaluar
   @c{(buffer-file-name)} en el búffer @f{*scratch*}, aparecerá @c{nil} en el
   área echo, igual que cuando evalúa @c{(buffer-file-name)} en Info.

   Por cierto, si se encuentra en el búffer @f{*scratch*} y quiere que el
   valor devuelto por una expresión aparesca en el búffer en sí y no en el
   área echo, presione @k{C-u C-x C-e} en lugar de @k{C-x C-e}. Esto causa
   que el valor devuelto aparezca después de la expresión. El búffer se verá
   así:

   @example
     (buffer-name)"*scratch*"
   @end example

   No se puede hacer esto en Info ya que Info es de solo lectura y no se
   permitirá cambiar el contenido del búffer. Pero puedes hacer esto en
   cualquier búffer que se pueda editar; y cuando se escribe código o
   documentación (como este libro), esta función es muy útil.

** Obtención de Búffers

   La función @c{buffer-name} devuelve el @e{nombre} del búffer; para obtener
   el búffer @e{en sí}, se necesita una función diferente: la función
   @c{current-buffer}. Si utiliza esta función en el código, lo que se
   obtiene es el búffer en sí.

   Un nombre y el objeto o entidad a la que se refiere el nombre son
   diferentes entre si. Tu no eres tu nombre, eres una persona a la que se
   refieren los demas por tu nombre. Si pides hablar con Jorge y alguien te
   entrega una tarjeta con las letras @'{J}, @'{o}, @'{r}, @'{g}, y @'{e}
   estritas, podrias divertirte, pero no estarías satisfecho. No quieres
   hablar con el nombre, sino con la persona a la que se refiere el
   nombre. Un búffer es similar: el nombre del búffer scratch es
   @f{*scratch*}, pero el nombre no es el búffer. Para obtener un búffer en
   sí, es necesario utilizar una función como @c{current-buffer}.

   Sin embargo, hay una ligera complicación: si evalúas @c{current-buffer} en
   una expresión por sí sola, como haremos aquí, lo que se ve es una
   representación impresa del nombre del búffer sin los contenidos del
   búffer. Emacs funciona de esta forma por dos razones: el búffer puede
   contener miles de líneas––demasiado largo para ser mostrado
   convenientemente; y, otro búffer puede tener el mismo contenido pero un
   nombre diferente, y es importante distinguir entre ellos.

   Aquí hay una expresión conteniendo la función:

   @src elisp
     (current-buffer)
   @src

   Si evalúa esta expresión en Info de la manera habitual, aparecerá
   @f{#<buffer *info*>} en el área echo. El formato especial indica que el
   búffer en sí está siendo devuelto, en lugar de solo su nombre.

   Por cierto, si bien puedes escribir un número o símbolo en un programa, no
   se puede hacer esto con la representación impresa del búffer: la única
   manera de optener un búffer en sí mismo es con una función tal como
   @c{current-buffer}.

   Un función relacionada es @c{other-buffer}. Esta devuelve el último buffer
   seleccionado distinto al que te encuentras actualmente, no una
   representación impresa de su nombre. Si recientemente has ido y vuelto del
   búffer @f{*scratch*}, @c{other-buffer} devolverá este búffer.

   Se puede ver esto evaluando la expresión:

   @src elisp
     (other-buffer)
   @end src

   Verás que @f{#<buffer *scratch*>} aparece en el área echo, o el nombre de
   cualquier otro búffer cambiado anteriormente a partir del más reciente{5}

** Cambiando búffers

   La función @c{other-buffer} realmente proporciona un búffer cuando se
   utiliza como argumento de una función que requiera uno. Podemos ver esto
   usando @c{other-buffer} y @c{switch-to-buffer} para cambiar a un búffer
   diferente.

   Pero primero, una breve introducción a la función @c{switch-to-buffer}.
   Cuando cambia de ida y vuelta de Info al búffer @f{*scratch*} para evaluar
   @c{(buffer-name)}, normalmente se presiona @k{C-x b} y luego se pasa
   @f{*scratch*}@n{6} en el minibuffer cuando se le solicita el nombre del
   buffer al que quiere cambiar. El atajo, @k{C-x b}, hace que el intérprete
   Lisp evalúe la función interactiva @c{switch-to-buffer}. Como hemos dicho
   anteriormente, así es como funciona Emacs: diferentes atajos de teclado
   llaman o ejecutan diferentes funciones. Por ejemplo, @k{C-f} llama a
   @c{forward-char}, @k{M-e} llama a @c{forward-sentence}, etcétera.

   Al escribir @c{switch-to-buffer} en una expresión, y darle un búffer al
   que cambiar, podemos cambiar de búffer tal y como hace @k{C-x b}.

   @src elisp
     (switch-to-buffer (other-buffer))
   @end src

   El símbolo @c{switch-to-buffer} es el primer elemento de la lista, por lo
   que el intérprete Lisp lo tratará como una función y llevara a cabo las
   instrucciones adjuntas al mismo. Pero antes de hacer esto, el intérprete
   observara que @c{other-buffer} está dentro de paréntesis y trabajara en
   este símbolo primero. @c{other-buffer} es el primer (y en este caso, el
   único) elemento de esta lista, por lo que el intérprete llama o ejecuta la
   función. Esto devuelve un búffer distinto al actual. A continuación, el
   intérprete ejecuta @c{switch-to-buffer}, pasando, como argumento, el
   búffer devuelto, que es al que Emacs cambia. Si estás leyendo esto en
   Info, prueba esto ahora. Evalúa la expresión. (Para regresar, presiona @k{C-x b
   RET}.)@n{7}

   En los ejemplos de las secciones siguentes, veras con más frecuencia la
   función @c{set-buffer} que @c{switch-to-buffer}. Esto es debido a la
   diferencia entre programas de ordenador y seres humanos: los humanos
   tienen ojos y esperan ver el búffer en el que están trabajando en la
   terminal de su ordenador. Esto es tan evidente, que se sobreentiende. Sin
   embargo, los programas no tienen ojos. Cuando un programa de ordenador
   trabaja en un búffer, el búffer no necesita ser visible en la pantalla.

   @c{switch-to-buffer} está diseñado para los seres humanos y hace dos cosas
   diferentes: cambia el búffer a el que Emacs dirige la atención; y cambia
   el búffer mostrado en la ventana al nuevo búffer. @c{set-buffer}, por otro
   lado, solo hace una cosa: cambia la atención del programa del ordenador a
   un búffer diferente. El búffer en la pantalla permanece sin cambios (por
   supuesto, normalmente no pasa nada hasta que el comando termina de
   ejecutarse).

   Además, acabamos introduciendo otro termino tecnico, la palabra
   @:{llamada}. Cuando se evalúa una lista en la que el primer símbolo es una
   función, estás llamando a esa función. El uso del término viene de la
   noción de la función como una entidad que puede algo hacer por ti cuando
   la ‘llamas’––al igual que un fontanero es una entidad que puede arreglar
   una fuga si lo llamas.

** Tamaño del búffer y la ubicación del punto

   Por último, vamos a ver varias funciones bastante simples,
   @c{buffer-size}, @c{point}, @c{point-min}, y @c{point-max}. Estas entregan
   información sobre el tamaño de un búffer y la ubicación del punto dentro
   de este.

   La función @c{buffer-size} te dice el tamaño del búffer actual; es decir,
   la función devuelve un conteo del número de caracteres en el buffer.

   @src elisp
     (buffer-size)
   @end src

   Puedes evaluar esto de la forma habitual, coloca el cursor después de la
   expresión y presiona @k{C-x C-e}.

   En Emacs, la posición actual del cursor se denomina @:{punto}. La
   expresión @c{(point)} devuelve un número que informa donde esta situado el
   cursor como un conteo del número de caracteres desde el principio del
   búffer hasta el punto.

   Puedes ver el conteo de caracteres del punto para este búffer evaluando la
   siguiente expresión de la forma habitual:

   @src elisp
     (point)
   @end src

   Mientras escribo esto, el valor de @c{point} es 65724. La función
   @c{point} se utiliza con frecuencia en algunos de los ejemplos mas
   adelante en este libro.

   El valor del punto depende, por supuesto, de su ubicacion dentro del
   búffer. Si evaluas el punto en este lugar, el número será mayor:

   @src elisp
     (point)
   @end src

   Para mí, el valor del punto en esta posición es 66043, lo que significa
   que hay 319 caracteres (incluyendo espacios) entre las dos expresiones.
   (Sin duda, verá números diferentes, puesto que habré editado esto desde el
   primer punto evaluado.)

   La función @c{point-min} es similar a @c{point}, pero devuelve el valor
   mínimo permisible del punto en el búffer actual. Este es el numero 1 a menos
   que @:{narrowing} esté en vigor. (Narrowing, @e{Reduccion} es un mecanismo
   mediarte el cual puedes restringirte a ti mismo, o un programa, a operar solo
   en un parte de un búffer. Ver Sección @l{Reducir y Extender}.)  Del mismo
   modo, la función @c{point-max} devuelve el valor máximo permisible del punto
   en el búffer actual.

** Ejercicio

   Busca un fichero en el que trabarjar y avanza hasta la mitad. Encuentra el
   nombre de búffer, el nombre del fichero, su tamaño, y la posición en el
   fichero.

* Cómo escribir definiciones de funciones

  Cuando el intérprete Lisp evalúa una lista, mira si el primer símbolo en la
  lista tiene una definición ligada a este; o, dicho de otro modo, si el
  símbolo apunta a una definición de función. Si lo hace, el ordenador lleva
  a cabo las instrucciones que aparecen en la definición. Un símbolo que
  tiene una definición de función se llamada, simplemente, una función
  (aunque hablando con propiedad, la definición es la función y el símbolo se
  refiere a ella.)

  Todas las funciones se defininen en términos de otras funciones, a
  excepción de algunas @:{primitivas} que estan escritas en el lenguaje de
  programación C. Cuando escribas definiciones de funciones, debes
  escribirlas en Emacs Lisp y utilizar otras funciones como bloques de
  construcción. Algunas de las funciones a utilizar estaran a su vez escritas
  en Emacs Lisp (quizás por tí) y algunas serán primitivas escritas en C. Las
  funciones primitivas se usan exactamente igual que las escritas en Emacs
  Lisp y se comportan de igual forma. Están escritas en C para que podamos
  ejecutar facilmente GNU Emacs en cualquier ordenador que tenga la potencia
  suficiente y pueda ejecutar C.

  Permíteme volver a enfatizar esto: cuando se escribe código en Emacs Lisp,
  no se distinge entre el uso de funciones escritas en C y el uso de
  funciones escritas en Emacs Lisp. La diferencia es irrevelante. Mencioné la
  distinción solo porque es interesante conocerla. De hecho, a menos de que
  investigues, no sabras si una función previamente escrita esta en Emacs
  Lisp o en C.

** La forma especial @c{defun}

   En Lisp, un símbolo como @c{mark-whole-buffer} tiene código unido a el que
   le dice al ordenador que hacer cuando se invoca la función. Este código se
   denomina la @:{definición de función} y se crea mediante la evaluación de
   una expresión Lisp que comienza con el símbolo @c{defun} (que es una
   abreviatura para @e{define function} (definir función)). Porque @c{defun}
   no evalúa sus argumentos en la forma habitual, esto se llama @:{forma
   especial}.

   En las siguientes secciones, vamos a ver las definiciones de función
   partiendo del código fuente de Emacs, por ejemplo @c{mark-whole-buffer}.
   En esta sección, describiremos una definición de función sencilla para que
   puedas ver su aspecto. Esta definición de función usa aritmética porque es
   un ejemplo simple. A algunas personas les disgustan los ejemplos usando
   aritmética; sin embargo, si usted es tal persona, no se desespere. Casi
   ningun codigo a estudiar en el resto de esta introducción implica
   aritmética o matemáticas. Los ejemplos involucran principalmente texto en
   una forma u otra.

   Una definición de función tiene un máximo de cinco partes despues de la
   palabra @c{defun}:

   1. El nombre del símbolo al que la definición de función debe vincularse.

   2. Una lista de los argumentos que se pasan a la función. Si no hay
      argumentos que pasar a la función, tendremos una lista vacía, @c{()}.

   3. Documentación describiendo la función. (Técnicamente opcional, pero
      fuertemente recomendada.)

   4. Opcionalmente, una expresión para hacer que la función interactive
      pueda usarse presionando @k{M-x} seguido del nombre de la función; o
      pulsando una tecla o atajo de teclado.

   5. El código que indica a el ordenador qué hacer: el @:{cuerpo} de la
      definición de función.


   Es útil pensar en las cinco partes de una definición de función siendo
   organizadas como una plantilla, con slots para cada parte:

   @src elisp
     (defun nombre-de-función (argumentos…)
       "documentación-opcional…"
       (interactive argument-passing-info)     ; opcional
       cuerpo…)
   @end src

   A modo de ejemplo, aquí está el código de una función que multiplica su
   argumento por 7. (Este ejemplo no es interactivo. Ver Sección @l{Crear una
   Función Interactiva}, para esta información.)

   @src elisp
     (defun multiplicar-por-siente (numero)
       "Multiplica NUMERO por siete."
       (* 7 numero))
   @end src

   Esta definición comienza con un paréntesis y el símbolo @c{defun} seguido
   por el nombre de la función.

   El nombre de la función es seguido por una lista que contiene los
   argumentos que se pasan a la función. Esta lista se llama @:{lista de
   argumentos}. En este ejemplo, la lista solo tiene un elemento, el símbolo
   @c{numero}. Cuando se utiliza la función, el símbolo sera asociado al
   valor que se utiliza como argumento de la función

   En lugar de elegir la palabra @c{numero} para el nombre del argumento,
   podría haber escogido cualquier otro nombre. Por ejemplo, la palabra
   @c{multiplicando}. Escogi la palabra ‘numero’ porque indica qué tipo de
   valor se pretende para este espacio; pero podría haber elegido
   ‘multiplicando’ para indicar el papel que jugara el valor en el
   funcionamiento de la función. Podría haberlo llamado @c{foogle}, pero
   habría sido una mala elección, ya que no comunicaria a los humanos qué
   significa. La elección del nombre es responsabilidad del programador y
   debe elegirse para hacer que el significado de la función sea claro.

   De hecho, puedes elegir cualquier nombre que desees para un símbolo en una
   lista de argumentos, incluso el nombre de un símbolo usado en alguna otra
   función: el nombre que utilices en una lista de argumentos esta privado
   para esta definición particular. En esta definición, el nombre hace
   referenecia a una entidad diferente a cualquiera que utilice el mismo
   nombre fuera de la definición de función. Supón que tu familia te apoda
   ‘Enano’; cuando tus familiares digan ‘Enano’, queren hacer referencia a
   ti. Pero fuera de tu familia, en una película, por ejemplo, el nombre
   ‘Enano’ se refiere a alguien más. Debido a que el nombre en una lista de
   argumentos es privado para la definición de la función, se puede cambiar
   el valor de un símbolo dentro del cuerpo de una función sin cambiar su
   valor fuera de la función. El efecto es similar al producido por la
   expresión @c{let}. (Ver sección @lc{let}.)

   @ignore
     Note also that we discuss the word ‘number’ in two different ways: as a
     symbol that appears in the code, and as the name of something that will
     be replaced by a something else during the evaluation of the function.
     In the first case, @c{number} is a symbol, not a number; it happens
     that within the function, it is a variable who value is the number in
     question, but our primary interest in it is as a symbol.  On the other
     hand, when we are talking about the function, our interest is that we
     will substitute a number for the word @V{number}.  To keep this
     distinction clear, we use different typography for the two
     circumstances.  When we talk about this function, or about how it works,
     we refer to this number by writing @V{number}.  In the function
     itself, we refer to it by writing @c{number}.
   @end ignore

   La lista de argumentos es seguida por la cadena de documentación que
   describe la función. Esto es lo ves cuando presionas @k{C-h f} y escribes
   el nombre de una función. Por cierto, cuando escribas una cadena de
   documentación como esta, debes confeccionar la primera linea como una
   sentencia completa ya que algunos comandos, como @c{apropos}, imprimen
   solo la primera línea de una cadena de documentación de varias líneas.
   Ademas, no debes indentar la segunda línea de la cadena de documentación,
   si tienes una, porque se ve extraño al utilizar @k{C-h f}
   (@c{describe-function}). La cadena de documentación es opcional, pero es
   tan útil, que deberías incluirla en casi cualquier función que escribas.

   La tercera línea del ejemplo consiste en el cuerpo de la definición de
   función. (La mayoría de las definiciones de funcion, claro esta, son más
   extensas que esta.) En esta función, el cuerpo es la lista, @c{(* 7
   numero)}, que indica multiplicar el valor de @c{numero} por 7. (En Emacs
   Lisp, @c{*} es la función para la multiplicación, al igual que @c{+} es la
   función de la adición.

   Cuando se utiliza la función @c{multiplicar-por-siente}, el argumento
   @c{numero} se evalúa al número que desees usar. He aquí un ejemplo que
   muestra como utilizar @c{multiplicar-por-siete}; pero ¡no intentes evaluar
   esto primero!.

   @src elisp
     (multiplicar-por-siente 3)
   @end src

   El símbolo @c{numero}, especificado en la definición de función en la
   siguiente sección, se da o “une a” el valor 3 en el actual uso de la
   función. Note que aunque @c{numero} estaba dentro de paréntesis en la
   definición de función, el argumento pasado a la función
   @c{multiplicar-por-siente} no está entre paréntesis. Los paréntesis se
   escriben en la definición de función para que el ordenador pueda averiguar
   donde termina la lista de argumentos e inicia el resto de la definición de
   función.

   Si evalúas este ejemplo, es probable que obtengas un mensaje de error.
   (¡adelante, intentalo!) Esto se debe a que hemos escrito la definición de
   función, pero aún no se ha comunicado al ordenador sobre la definición––no
   hemos instalado (o ‘cargado’) la definición de función en Emacs. Instalar
   una función es el proceso de comunicar al intérprete Lisp la definición de
   la función. La instalación se describe en la siguiente sección.

** Instalar una definición de función

   Si estás leyendo esto dentro en Emacs, puedes probar la función
   @c{multiply-by-seven} evaluando en primer lugar la definición de función y
   luego evaluar @c{(multiplicar-por-siente 3)}. Hay una copia de la
   definición a continuación. Coloca el cursor después del último paréntesis
   de la definición de función y presiona @k{C-x C-e}. Al hacer esto,
   @c{multiplicar-por-siente} aparecerá en el área echo. (Lo que significa es
   que cuando una se evalua una definición de función, el valor devuelto es
   el nombre de la función definida.) Al mismo tiempo, esta acción instala la
   definición de función.

   @src elisp
     (defun multiplicar-por-siente (numero)
       "Multiplica NUMERO por siete."
       (* 7 numero))
   @end src

   Al evaluar este @c{defun}, estas instanlado @c{multiplicar-por-siente} en
   Emacs. La función ahora es una parte de Emacs tan importante como
   @c{forward-word} o cualquier otra función de edición que utilices.
   (@c{multiplicar-por-siente} seguira instalado hasta que salgas de
   Emacs. Para volver a cargar el código automáticamente cada vez que Emacs
   inicie, revisa la sección @l{Instalar Código Permanentemente}.)

   Puedes ver el efecto de instalar @c{multiplicar-por-siente} evaluando el
   siguiente ejemplo. Coloca el cursor después de la siguiente expresión y
   presiona @k{C-x C-e}. El número 21 aparacerá en el área echo.

   @src elisp
     (multiplicar-por-siente 3)
   @end src

   Si lo deseas, puedes leer la documentación de la función presiona @k{C-h
   f} (@c{describe-function}) y luego escribe el nombre de la función,
   @c{multiplicar-por-siente}. Al hacer esto, una ventana @f{*Help*}
   aparecerá en tu pantalla diciendo:

   @example
     multiplicar-por-siente is a Lisp function.
     (multiplicar-por-siente NUMERO)

     Multiplica NUMERO por siete.
   @end example

   (Para volver a una sola ventana en la pantalla, presiona @k{C-x 1}.)

*** Cambiar una definición de función

    Si deseas modificar el código de @c{multiplicar-por-siente}, simplemente
    reescríbelo. Para instalar la nueva versión en lugar de la vieja, evalúa
    la nueva definición de la función. Esta, es la forma de modificar el
    código en Emacs. Es muy simple,

    A modo de ejemplo, puedes cambiar la función @c{multiplicar-por-siente}
    para sumar el número a sí mismo siete veces en lugar de multiplicar el
    número por siete. Esto produce el mismo resultado, pero por una ruta
    diferente. Al mismo tiempo, añadiremos un comentario al codigo; un
    comentario es texto que el intérprete Lisp ignora, pero un lector humano
    puede encontrarlo útil o esclarecedor. El comentario es que esta es la
    “segunda versión”.

    @src elisp
      (defun multiplicar-por-siente (numero)       ; Segunda versión.
        "Multiplica NUMERO por siete."
        (+ numero numero numero numero numero numero numero))
    @end src

    El comentario sigue a un punto y coma, @'{;}. En Lisp cualquier cosa en
    una línea despues de un punto y coma es un comentario. El fin de la línea
    es el fin del comentario. Para extender un comentario por dos o más
    líneas, inicia cada línea con un punto y coma.

    Véa las Secciónes @l(Empieza por un fichero @f{.emacs}) y
    @l{info:emacs#Comments<>Comentarios} en @e(El Manual de Referencia de GNU
    Emacs Lisp), para más informacion sobre los comentarios.

    Puedes instalar esta versión de @c{multiplicar-por-siente} evaluándo esta
    de la misma forma en que evaluaste la primer función: coloca el cursor
    después del último paréntesis y presiona @k{C-x C-e}.

    En resumen, esta es la forma en que puedes escribir código en Emacs Lisp:
    escribes una función; la instalas; la pruebas; luego haces correcciones y
    mejoras e instálalas de nuevo.

** Crear una función interactiva

   Haces a una función interactiva colocando una lista que inicia con la
   clase especial @c{interactive} inmediatamente después de la documentación.
   Un usuario puede invocar una función interactiva con @k{M-x} y seguido del
   nombre de la función; o con un atajo de teclado ligado a esta, por
   ejemplo, pulsa @k{C-n} para @c{next-line} o @k{C-x h} para
   @c{mark-whole-buffer}.

   Cusionamente, cuando llamas a una función interactiva interactivamente, el
   valor devuelto no se muestra automáticamente en el área echo. Esto se debe
   a que a menudo se llama a una función interactiva por sus efectos
   secundarios, tales como avanzar hacia hacia adelante por palabra o línea,
   y no por el valor devuelto. Si el valor devuelto se mostrara en el área
   echo cada vez que se presiona una tecla, seria una gran distraccion.

   Tanto el uso de la clase especial @c{interactive} y una forma de mostrar
   un valor en el área echo pueden ilustrarse creando una versión
   interactiva de @c{multiplicar-por-siente}.

   Aquí está el código:

   @src elisp
     (defun multiplicar-por-siente (numero)       ; Versión Interactiva.
       "Multiplica NUMERO por siete."
       (interactive "p")
       (message "El resultado es %d" (* 7 numero)))
   @end src

   Para instalar este código coloca el cursor después del ultimo parentesis y
   presiona @k{C-x C-e}. El nombre de la función aparecerá en el área echo.
   Despues, puedes utilizar este código al presionar @k{C-u} segudo de un
   número, luego @k{M-x multiplicar-por-siente} y finalmente @k{RET}. La
   frase @'{El resultado es …} seguida por el producto aparecerá en el área
   echo.

   Hablando en terminos mas generales, puedes invocar una función como ésta
   de dos maneras:

   1. Al escribir un argumento prefijo que contiene el número a pasar, y a
      continuación presionar @k{M-x} y escribir el nombre de la función, como
      ocurre con @k{C-u 3 M-x forward-sentence}; o,

   2. Al escribir cualquier tecla o atajo de teclado ligado a la función a
      tratar, como ocurre con @k{C-u 3 M-e}.


   Ambos ejemplos operan de forma identica moviendo el punto hacia adelante
   tres frases. (Si @c{multiply-by-seven} no estuviese ligado a una tecla, no
   podria ser usado como ejemplo de enlace a tecla.

   (Véase Sección @l{Atajos de teclado}, para aprender como vincular un
   comando a una tecla.)

   Un argumento prefijo se pasa a una función interactiva pulsando la tecla
   @k{META} seguida de un número, por ejemplo, @k{M-3 M-e}, o con @k{C-u} y
   luego un número, por ejemplo, @k{C-u 3 M-e} (si presionas @k{C-u} sin
   ningun número, el valor por defecto es 4).

*** @c{multiplicar-por-siente} interactivo

    Veamos la clase especial @c{interactive} y despues la función @c{message}
    en la versión interactiva de @c{multiplicar-por-siente}.  Recordaras que
    la definición de función tiene el siguente aspecto:

    @src elisp
      (defun multiplicar-por-siente (numero)       ; Versión Interactiva.
        "Multiplica NUMERO por siete."
        (interactive "p")
        (message "El resultado es %d" (* 7 numero)))
    @end src

    En esta función, la expresión, @c{(interactive "p")}, es una lista de dos
    elementos. La @c{"p"} le indica a Emacs que debe pasar el argumento
    prefijo a la función y utilizar este valor para el argumento de la
    función.

    El argumento debe ser un número. Esto significa que el símbolo @c{numero}
    estara asociado a un número en la línea:

    @src elisp
      (message "El resultado es %d" (* 7 numero))
    @end src

    Por ejemplo, si tu argumento prefijo es 5, el intérprete Lisp evaluará la
    línea como si fuera:

    @src elisp
      (message "El resultado es %d" (* 7 5))
    @end src

    (Si estás leyendo esto en GNU Emacs, puedes evaluar esta expresión por ti
    mismo.) Primero, el intérprete evaluará la lista interna, que es @c{(* 7
    5)}. Esto devuelve un valor de 35. A continuación, se evaluará la lista
    externa, pasando los valores del segundo y posteriores elementos de la
    lista a la función @c{message}.

    Como hemos visto, @c{message} es una función Emacs Lisp especialmente
    diseñada para enviar un mensaje de una línea al usuario. (Véase Sección
    @l{La función @c{message}}) En resumen, la función @c{message} imprime su
    primer argumento en el área echo tal cual, exceptuando las apariciones de
    @'{%d}, o @'{%s} (y varias otras secuencias de control que no hemos
    mencionado).  Cuando aparece una secuencia de control, la función observa
    el segundo o posteriores argumentos e imprime el valor del argumento en
    la ubicación donde se encuartra la secuencia de control.

    En la función interactiva @c{multiplicar-por-siente}, la cadena de
    control es @'{%d}, que requiere un número, y el valor devuelto por la
    evaluación de @c{(* 7 5)} es el número 35. Por consiguiente, el número 35
    se imprime en lugar de @'{%d} y el mensaje es @'{El resultado es 35}.

    (Observa que cuando llamas a la función @c{multiplicar-por-siente}, el
    mensaje se imprime sin comillas, pero cuando llamas a @c{message}, el
    texto se imprime entre comillas. Esto se debe a que el valor devuelto por
    @c{message} aparece en el área echo cuando evalúas una expresión cuyo
    primer elemento es @c{message}; pero si se integra en una función,
    @c{message} imprime el texto como un efecto secundario sin comillas.)

** Diferentes opciones para @c{interactive}

   En el ejemplo, @c{multiplicar-por-siente} utiliza @c{"p"} como el
   argumento para @c{interactive}. Este argumento indica a Emacs que
   interprete cualquer cosa que escriba despues de @k{C-u} o del comando
   @k{META} como un numero que sera el argumento a pasar a la funcion. Emacs
   tiene más de veinte caracteres predefinidos para usar con @c{interactive}.
   En casi todos los casos, una de estas opciones te permitira pasar la
   información adecuada interactivamente a una función. (Véase Sección
   @l{info:emacs#Interactive<>Code Characters for @c{interactive}} en @e(El
   Manual de Referencia GNU Emacs Lisp)).

   Considera la función @c{zap-to-char}. Su expresión interactiva es

   @src elisp
     (interactive "p\ncZap to char: ")
   @end src

   La primer parte del argumento de @c{interactive} es @'{p}, con el que ya
   estás familiarizado. Este argumento le indica a Emacs intepretar un
   ‘prefijo’, como un número que se pasa a la función. Puedes especificar un
   prefijo presionando @k{C-u} seguido por un número o igualmente con
   @k{META} seguido por un número. El prefijo es un número de caracteres
   especifico.  De este modo, si el prefijo es tres y el caracter es
   establecido es @'{x}, entonces se borrará todo el texto incluido el tercer
   @'{x} siguiente. Si no se establece un prefijo, entonces borras todo el
   texto incluido el cuarto carácter establecido, pero no más.

   La @'{c} indica a la función el nombre del carácter que va a eliminar.

   Más formalmente, una función con dos o más argumentos puede tener
   información que pasa a cada argumento añadiendo partes en la cadena que
   viene despues de @c{interactive}. Cuando haces esto, la información se
   pasa a cada argumento en el mismo orden que se especifica en la lista
   @c{interactive}. En la cadena, cada parte está separada de la siguente
   parte por un @'{\n}, que significa nueva línea. Por ejemplo, a @'{p} puede
   continuar un @'{\n} y un @'{cZap to char:@:}. Esto hace que Emacs pase el
   valor del argumento prefijo (si lo hay) y el carácter.

   En este caso, la definición de función se parace a la siguiente, donde
   @c{arg} y @c{char} son los símbolos que @c{interactive} vincula el
   argumento prefijo y el caracter especificado:

   @src elisp
     (defun nombre-de-funcion (arg char)
       "documentacion…"
       (interactive "p\ncZap to char: ")
       cuerpo-de-funcion…)
   @end src

   (El espacio después del punto y coma en el prompt hace que se vea
   mejor. Véase Sección @l{La Definición de @c{copy-to-buffer}}, para un
   ejemplo.)

   Cuando una función no toma argumentos, @c{interactive} no requiere
   ninguno. Una función asi contiene inicamente la expresión
   @c{(interactive)}. La función @c{mark-whole-buffer} es asi.

   Alternativamente, si los códigos de letras especiales no son adecuardos
   para tu aplicación, puedes pasar tus propios propios argumentos a
   @c{interactive} como una lista.

   Ver @l{La Definición de @c{append-to-buffer}}, para un ejemplo. Ver
   Sección @l{info:emacs#Using Interactive<>Usando @c{interactive}} en @e(El
   Manual de GNU Emacs Lisp), para una explicación más completa acerca de
   esta técnica.

** Instalar código permanentemente

   Cuando instalas una definición de función evaluada por ti, permanecera
   instalada hasta que salgas de Emacs. La proxima vez que se inicies una
   nueva sesión de Emacs, la función no sera instalada a menos que evalúes de
   nuevo la definición.

   En algún momento, podrias necesitar que el código se instale
   automáticamente cada vez que inicies una nueva sesión de Emacs. Hay varias
   formas de hacer esto:

   - Si tienes código solo para tu uso, puedes poner el código de la
     definición de función en el fichero de inicialización @f{.emacs}. Cuando
     se inicia Emacs, el fichero @f{.emacs} se evalúa automática y se
     instalan todas sus definiciones de función. Vér Sección @l{Tu Fichero
     @f{.emacs}}.

   - Como Alternativa, puedes poner las definiciones de función en uno o más
     ficheros y usar la función @c{load} para hacer que Emacs evalue y con
     ello instale cada una de las funciones en los ficheros. Véase Sección
     @l{Cargando ficheros}.


   - En Tercer lugar, si tienes código que todo tu sitio va a utilizar, es
     normal ponerlo en un fichero llamado @f{site-init.el} que se carga
     cuando se construye Emacs. Esto hace que el código este disponible a
     cualquiera que use tu máquina. (Mira el fichero @f{INSTALL} que forma
     parte de la distribución Emacs.)


   Finalmente, si tienes código que cualquier usuario de Emacs puede querer,
   puedes publicarlo en una red de ordenadores o enviar una copia a la Free
   Software Foundation. (Al hacer esto, por favor licencia el código y su
   documentación bajo una licencia que permita a otras personas ejecutar,
   copiar, estudiar, modificar, y redistribuir el código y te protege de
   quien tome tu trabajo.) Si envias una copia de tu código a la Free
   Software Foundation, y lo proteges apropiadamente de ti mismo y otros,
   puede ser incluido en la siguiente version de Emacs. En gran parte, esta
   es la forma como ha crecido Emacs a través de los años, por donaciones.

** @c{let}

   La expresión @c{let} es una forma especial en Lisp que tendras que
   utilizar en la mayoría de las definiciones de función.

   @c{let} se utiliza para unir o enlazar un símbolo a un valor de tal manera
   que el intérprete no confunda la variable con otra variable del mismo
   nombre que no forma parte de la función.

   Para entender por qué la forma especial @c{let} es necesaria, considera la
   situación donde eres dueño de una casa que generalmente vinculas con ‘la
   casa’, como en la frase, “La casa necesita pintura”. Si visitas a un amigo
   y tu anfitrion hace referencia a ‘la casa’, es probable que se refiera a
   @e{su} casa, no a la tuya, es decir, es una casa distinta.

   Si tu amigo se refiere a su casa y tu crees que el se esta refiriendo a tu
   casa, puedes tener cierta confusión. Lo mismo podría suceder en Lisp si
   una variable que se utiliza dentro de una función tiene el mismo nombre
   que una variable usada dentro de otra función, y las dos no tienen la
   intencion de referirse al mismo valor. La forma especial @c{let} previene
   este tipo de confusión.

   La forma especial @c{let} evita confusiones. @c{let} crea un nombre para
   una @:{variable local} que eclipsa cualquier uso del mismo nombre fuera de
   la expresión @c{let}. Esto es como entender que siempre que tu anfitrion
   se refiera a ‘la casa’, significa su casa, no la tuya. (Los símbolos
   usados en las listas de argumentos funcionan de la misma manera. Véase
   Sección @l{La Forma Especial @c{defun}}.)

   Las variable locales creadas por una expresión @c{let} conservan su valor
   @e{solo} dentro de la expresión @c{let} misma (y dentro de expresiones
   llamadas dentro de la expresión @c{let}); las variables locales no tiene
   efecto fuera de la expresión @c{let}.

   Otra forma de persar respecto a @c{let} es que es como un @c{setq} que es
   temporal y local. Los valores establecidos por @c{let} son automáticamente
   deshechos cuando termina el @c{let}. La configuración solo afecta a las
   expresiones que se encuentran dentro de los limites de la expresión
   @c{let}. En jerga informatica, diríamos “la union de un simbolo es visible
   solo en las funciones llamadas en la forma @c{let}; en Emacs Lisp, el
   alcance es dinámico, no léxico.”

   @c{let} puede crear más de una variable a la vez. Ademas, @c{let} da a
   cada variable que crea un valor inicial, ya sea un valor especificado por
   tí, o @c{nil}. (En la jerga, eso se llama ‘unir la variable al valor’.)
   Después que @c{let} ha creado y unido las variables, ejecuta el código en
   el cuerpo del @c{let} y devuelve el valor de la última expresión en el
   cuerpo, como el valor de toda la expresión @c{let}. (‘Ejecutar’ es un
   término tecnico que significa evaluar una lista; proviene del significando
   de la palabra ‘llevar a la practica’ (@e{Diccionario de Inglés de
   Oxford}). Dado que evalúas una expresión para realizar una acción,
   ‘ejecutar’ ha evolucionado como un sinónimo para ‘evaluar’.)

*** Partes de una expresión @c{let}

    Una expresión @c{let} es una lista de tres partes. La primer parte es el
    símbolo @c{let}. La segunda parte es una lista, denominada @:{varlist}
    (lista de variables), cada uno de cuyos elementos es un símbolo por sí
    mismo o una lista de dos elementos, el primer elemento es un símbolo. La
    tercera parte de la expresión @c{let} es el cuerpo del @c{let}. El cuerpo
    normalmente consiste de una o más listas.

    Una plantilla para una expresión @c{let} tiene el siguente aspecto:

    @src elisp
      (let varlist cuerpo…)
    @end src

    Los símbolos de la lista de varibles (@c(varlist)) son las variables que
    dan los valores iniciales para la forma especial @c{let}. Los símbolos
    por si solos reciven el valor inicial de @c{nil}; y cada símbolo que es
    el primer elemento de una lista de dos elementos es unido al valor
    devuelto cuando el interprete Lisp evalúa el segundo elemento.

    De este modo, una varlist como: @c{(thread (needles 3))}. En este caso,
    dentro una expresión @c{let}, Emacs une el símbolo @c{thread} a un valor
    inicial de @c{nil}, y une el símbolo @c{needles} a un valor inicial de 3.

    Cuando escribes una expresión @c{let}, lo que haces es poner las
    expresiones apropiadas en los huecos de la plantilla de expresión
    @c{let}.

    Si la varlist está compuesta de listas de 2 elementos, como suele ser el
    caso, la plantilla de la expresión @c{let} es la sigiente:

    @src elisp
      (let ((variable valor)
            (variable valor)
            …)
        cuerpo…)
    @end src

*** Ejemplo de Expresión @c{let}

    La siguiente expresión crea y da valores iniciales a las dos variables
    @c{cebra} y @c{tigre}. El cuerpo de la expresión @c{let} es una lista que
    llama a la función @c{message}.

    @src elisp
      (let ((cebra 'rayas)
            (tigre 'fiero))
        (message "Un tipo de animal tiene %s y otro es %s."
                 cebra tigre))
    @end src

    Aquí, la varlist es @c{((cebra 'rayas) (tigre 'fiero))}.

    Las dos variables son @c{cebra} y @c{tigre}. Cada variable es el primer
    elemento de una lista de dos elementos y cada valor es el segundo
    elemento de su lista de dos elementos. En la varlist, Emacs une la
    variable @c{cebra} al valor @c{rayas}@n{8}, y une la variable @c{tigre}
    al valor @c{fiero}. En este ejemplo, ambos valores son símbolos
    precedidos por una cita. Los valores podrían muy bien haber sido otra
    lista o una cadena. El cuerpo de @c{let} sigue después de la lista que
    contiene las variables. En este ejemplo, el cuerpo es una lista que usa
    la función @c{message} para imprimir una cadena en el área echo.

    Puedes evaluar el ejemplo de la forma habitual, coloca el cursor después
    del último paréntesis y presiona @k{C-x C-e}. Al hacer esto, aparecerá lo
    siguiente en el área echo:

    @src elisp
      "Un tipo de animal tiene rayas y otro es fiero."
    @end src

    Como hemos visto antes, la función @c{message} imprime su primer
    argumento, excepto por @'{%s}. En este ejemplo, el valor de la variable
    @c{cebra} se imprime en la ubicacion del primer @'{%s} y el valor de la
    variable @c{tigre} se imprime en la ubicacion del segundo @'{%s}.

*** Variables sin inicializar en un sentencia @c{let}

    Si no se une a las variables en una sentencia @c{let} con valores
    iniciales específicos, automáticamente seran unidos a un valor inicial de
    @c{nil}, como en la siguiente expresión:

    @src elisp
      (let ((abedul 3)
            pino
            abeto
            (roble 'algunos))
        (message
         "Aquí están %d variables con %s, %s, y el valor %s."
         abedul pino abeto roble))
    @end src

    Aquí, la varlist es @c{((abedul 3) pino abeto (roble 'algunos))}.

    Si evalúas esta expresión de la forma habitual, aparecerá lo siguiente en
    el área echo:

    @example
      "Aquí están 3 variables con nil, nil, y el valor algunos."
    @end example

    En este ejemplo, Emacs une el símbolo @c{abedul} al número 3, une los
    símbolos @c{pino} y @c{abeto} a @c{nil}, y une el símbolo @c{roble} al
    valor @c{algunos}.

    Observe que en la primera parte de @c{let}, las variables @c{pino} y
    @c{abeto} son unicamente átomos que no están rodeados por paréntesis;
    esto se debe a que estan siendo unidos a @c{nil}, la lista vacía. Pero
    @c{roble} su une a @c{algunos} por esto es parte de la lista @c{(roble
    'algunos)}. De manera similar, @c{abedul} se une al número 3 en una lista
    con este número. (Ya que un número se evalúa a sí mismo, el número no
    necesita ser citado. Ademas, el número se imprime en el mensaje
    utilizando un @'{%d} en lugar de un @'{%s}.) Las cuatro variables como un
    grupo son puestas dentro de una lista para delimitarla de el cuerpo de
    @c{let}.

** La forma especial @c{if}

   Además de @c{let} y @c{defun}, esta la forma especial condicional @c{if}.
   Esta forma se utiliza para indicar al computador que tome decisiones.
   Puedes escribir definiciones de función sin necesidad de utilizar @c{if},
   pero se usa con bastante frecuencia, y es lo suficientemente importante
   como para incluirse aquí. Se utiliza, por ejemplo, en el código de la
   función @c{beginning-of-buffer}.

   La idea básica detras de @c{if}, es que “@e{if} (si) una prueba es verdad
   @e{then} (entonces) se evalua la expresión”. Si la prueba no es verdad, la
   expresión no se evalua. Por ejemplo, podría tomar una decisión como, “si
   es cálido y soleado, entonces ir a la playa!”

   Al escribir una expresión @c{if} en Lisp no se utiliza la palabra ‘then’;
   la prueba y la acción son los elementos segundo y tercero de la lista cuyo
   primer elemento es @c{if}. No obstante, la parte de la prueba en una
   expresión @c{if} a menudo se llamada @:{if-part} (parte-si) y el segundo
   argumento a menudo se llamada @:{then-part} (parte-entonces).

   Ademas, cuando se escribe una expresión @c{if}, la
   prueba-verdadero-o-falso normalmente se escribe en la misma línea que el
   símbolo @c{if}, pero la acción a llevar a cabo si la prueba es verdadera,
   “then-part” (@e{parte-entonces}), se escribe en la segunda y suguientes
   líneas. Esto hace que la expresión @c{if} sea mas fácil de leer.

   @src elisp
     (if prueba-verdadero-o-falso
         accion-a-realizar-si-el-test-es-cierto)
   @end src

   La prueba-verdadero-o-falso es una expresión que evalua el intérprete
   Lisp.

   Aquí hay un ejemplo que puedes evaluar. La prueba consiste en si el número
   5 es mayor que el número 4. Ya que es asi, se imprime el mensaje @'{¡5 es
   mayor que 4!}.

   @src elisp
     (if (> 5 4)                           ; parte-si
         (message "¡5 es mayor que 4!"))   ; parte-entonces
   @end src

   (La función @c{>} comprueba si su primer argumento es mayor que su segundo
   argumento y devuelve verdadero si lo es.)

   Por supuesto, en un caso real, la prueba en una expresión @c{if} no será
   siempre la misma, como en la expresión @c{(> 5 4)}. En su lugar, al menos
   una de las variables utilizadas en la prueba estara unida a un valor de
   antemano desconocido. (Si el valor se conoce de antemano, ¡no necesitamos
   realizar la prueba!)

   Por ejemplo, el valor puede estar unido a un argumento de una definición
   de función. En la siguiente definición de función, el tipo de animal es un
   valor que se pasa a la función. Si el valor unido a @c{caracteristica} es
   @c{fiero}, entonces se imprime el mensaje, @'{¡Es un tigre!}; de otro
   modo, se devolvera @c{nil}.

   @src elisp
     (defun tipo-de-animal (caracteristica)
       "Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.
          Si la CARACTERISTICA es el símbolo ‘fiero’,
          entonces advierte que es un tigre."
       (if (equal caracteristica 'fiero)
           (message "¡Es un tigre!")))
   @end src

   Si estás leyendo esto dentro de GNU Emacs, puedes evaluar la definición de
   función de la forma habitual para instalarlo en Emacs, y luego puedes
   evaluar las dos expresiones siguientes para ver los resultados:


   @src elisp
     (tipo-de-animal 'fiero)

     (tipo-de-animal 'cebra)
   @end src

   Al evaluar @c{(tipo-de-animal 'fiero)}, veras el siguiente mensaje impreso
   en el área eco: @c{"¡Es un tigre!"}; y cuando se evalúa @c{(tipo-de-animal
   'cebra)} verás @c{nil} impreso en el área echo.

*** La función @c{tipo-de-animal} en detalle

    Veamos la función @c{tipo-de-animal} en detalle.

    La definición de función @c{tipo-de-animal} se escribio llenando los
    espacios de dos plantillas, la primera para la definición de función como
    un todo, y la segunda para una expresión @c{if}.

    La plantilla para cada función no interactiva es:

    @src elisp
      (defun nombre-de-funcion (lista-de-argumentos)
        "documentacion…"
        cuerpo…)
    @end src

    Las partes de la función que encajan con esta plantilla se ven asi:

    @src elisp
      (defun tipo-de-animal (caracteristica)
        "Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.
           Si la CARACTERISTICA es el símbolo ‘fiero’,
           entonces advierte que es un tigre."
        (cuerpo: la expresion if))
    @end src

    El nombre de función es @c{tipo-de-animal}; se pasa al valor de un
    argumento. A la lista de argumentos le sigue una cadena de documentación
    multi-línea. La cadena de documentación se incluiye en el ejemplo porque
    es un buen hábito escribir la cadena de documentación para cada
    definición de función. El cuerpo de la definición de función consiste en
    la expresión @c{if}.

    La plantilla para una expresión @c{if} se ve así:

    @src elisp
      (if prueba-verdadero-o-falso
          accion-a-realizar-si-la-prueba-devuelve-verdadero)
    @end src

    En la función @c{tipo-de-animal}, el código para @c{if} se ve así:

    @src elisp
      (if (equal caracteristica 'fiero)
          (message "¡Es un tigre!")))
    @end src

    Aquí, está la expresión prueba-verdadero-o-falso

    @src elisp
      (equal caracteristica 'fiero)
    @end src

    En Lisp, @c{equal} es una función que determina si su primer argumento es
    igual a su segundo argumento. El segundo argumento es el símbolo
    citado @c{'fiero} y el primer argumento es el valor del símbolo
    @c{característico}––en otras palabras, el argumento pasado a esta
    función.

    En la primer prueba de @c{tipo-de-animal}, el argumento @c{fiero} se pasa
    a @c{tipo-de-animal}. Ya que @c{fiero} es igual a @c{fiero}, la
    expresión, @c{(equal caracteristica 'fiero)}, devuelve el valor
    verdadero. Cuando esto sucede, @c{if} evalúa el segundo argumento o la
    parte-entonces del @c{if}: @c{(message "¡Es un tigre!")}.

    Por otro lado, en la segunda prueba de @c{tipo-de-animal}, se pasa el
    argumento @c{cebra} a @c{tipo-de-animal}. @c{cebra} no es igual a
    @c{fiero}, por lo que la parte-entonces no se evalua y se devuelve
    @c{nil} por la expresión @c{if}).

** Expresiones if–then–else

   Una expresión @c{if} puede tener un tercer argumento opcional, llamado
   @:{else-part} (parte-de-otro-modo), en caso de que la
   prueba-verdadero-o-falso devuelva falso. Cuando esto sucede, el segundo
   argumento o then-part de la expresión @c{if} global @e{no} se evalúa, pero
   el tercer argumento o parte-de-otro-modo @e{se} evalúa. Podría pensar en
   esto como la alternativa del día nublado para la decisión “si es cálido y
   soleado, entonces ir a la playa!, de otro modo leer un libro!”

   La palabra “else” (de otro modo) no se escribe en el código Lisp; la
   parte-de-otro-modo de una expresión @c{if} viene después de la
   parte-entonces. En Lisp, la parte-de-otro-modo suele escribirse al inicio
   de una nueva linea y se indenta menos que la parte-entonces:

   @src elisp
     (if prueba-verdadero-o-falso
         accion-a-realizar-si-la-prueba-devuelve-verdadero
       accion-a-realizar-si-la-prueba-devuelve-falso)
   @end src

   Por ejemplo, la siguiente expresión @c{if} imprime el mensaje @'{¡4 no es
   mayor que 5!} al evaluarse en la forma habitual:

   @example
     (if (> 4 5)                                   ; parte-if
         (message "¡4 falsamente es mayor que 5!") ; parte-then
       (message "¡4 no es mayor que 5!"))          ; parte-else
   @end example

   Tenga en cuenta que los diferentes niveles de indentación hacen fácil
   distinguir la parte-entonces de la parte-de-otro-modo. (GNU Emacs tiene
   varios comandos que indentan automáticamente expresiones @c{if} de forma
   apropiada. Véase Sección @l{GNU Emacs te ayuda a escribir listas}.)

   Podemos ampliar la función @c{tipo-de-animal} para incluir una parte-else
   simplemente incorporando una parte adicional para la expresión @c{if}.

   Puedes ver las consecuencias de hacer esto si evalúas para instalar la
   siguiente versión de la definición de función @c{tipo-de-animal} y luego
   evaluas las dos expresiones suguientes que pasan diferentes argumentos a
   la función.

   @src elisp
     (defun tipo-de-animal (caracteristica)
       "Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.
          Si la CARACTERISTICA es el símbolo ‘fiero’,
          entonces advierte que es un tigre.
          de otro modo decir que no es fiero"
       (if (equal caracteristica 'fiero)
           (message "¡Es un tigre!")
         (message "!No es feroz!")))

     (tipo-de-animal 'fiero)
     (tipo-de-animal 'cebra)
   @end example

   Al evalar @c{(tipo-de-animal 'fiero)}, verás el siguiente mensaje en el
   área echo: @c{"¡Es un tigre!"}; pero cuando evalues @c{(tipo-de-animal
   'cebra)}, verás @c{"¡No es feroz!"}.

   (Por supuesto, si @c{característica} fuera @c{muy feroz}, se imprimiria el
   mensaje @c{"¡No es feroz!"}; ¡y sería un error!  Cuando escribas código,
   necesitas tener en cuenta la posibilidad de que algun argumento como este
   será puesto a prueba por @c{if} y acorde a ello escribir tu programa.

** Verdad y Falsedad en Emacs Lisp

   Hay un aspecto importante para la prueba verdadero en una expresión
   @c{if}. Hasta ahora, hemos hablado de ‘verdadero’ y ‘falso’ como valores
   de predicados como si fueran nuevos tipos de objetos Emacs Lisp. De hecho,
   solo nuestro viejo amigo @c{nil} es ‘falso’. Cualquier otra
   cosa––cualquiera en absoluto––es ‘verdadero’.

   La expresión que prueba si es verdadero se interpreta como (@:{true})
   (verdadero) si el resultado de la evaluacion es no @c{nil}. En otras
   palabras, el resultado de la prueba se considera verdadero si el valor
   devuelto es un número como 47, una cadena como @c{"hola"}, o un símbolo
   (distinto a @c{nil}) como @c{flores}, o una lista (siempre y cuando no
   este vacía) o incluso ¡un búffer!

   Antes de ilustrar una prueba para verdadero, necesitamos una explicación
   de @c{nil}.

   En Emacs Lisp, el símbolo @c{nil} tiene dos significados. En primer lugar,
   significa que la lista está vacía. En segundo lugar, significa falso y es
   el valor devuelto cuando una prueba-verdadero-o-falso obtiene falso.
   @c{nil} puede escribirse como una lista vacia, @c[()], o como @c(nil). En
   lo referente al interprete Lisp @c[()] y @c(nil) son lo mismo. Los
   humanos, sin embargo, tienden a usar @c{nil} para falso y @c{()} para
   lista vacía.

   En Emacs Lisp, cualquier valor que no sea @c{nil}––no es una lista
   vacía––es considerado verdadero. Esto significa que si una evaluación
   devuelve algo que no es una lista vacía, una expresión @c{if} pondra a
   prueba verdadero. Por ejemplo, si un número se coloca en el lugar de la
   prueba, será evaluado y devolverá su valor, ya que eso es lo que hacen los
   números cuando se evalúan. En este condicional, la expresión @c{if}
   devuelve verdadero. La expresión prueba falso solo cuando @c{nil}, o una
   lista vacía, son devueltas al evaluar la expresión.

   Puedes ver esto evaluando las dos expresiones en los siguientes ejemplos.

   En el primer ejemplo, el número 4 se evalua como la prueba en la expresión
   @c{if} y devuelve el numero en si; en consecuencia, se evalua y devuelve
   la then-part de la expresión: aparece @'{verdadero} en el área echo. En el
   segundo ejemplo, @c{nil} indica falso; en consecuencia, se evalua y
   devuelve la else-part de la expresión: aparece @'{falso} en el área echo.

   @src elisp
     (if 4
         'verdadero
       'falso)

     (if nil
         'verdadero
       'falso)
   @end src

   Por cierto, si algún otro valor de utilidad no está disponible para una prueba
   que devuelve verdadero, entonces el intérprete Lisp devolvera el símbolo
   @c{t} para verdadero. Por ejemplo, la expresión @c{(> 5 4)} devuelve @c{t}
   cuando se evalúa, como puedes comprobar al evaluarlo:

   @src elisp
     (> 5 4)
   @end src

   Por otra parte, esta función devuelve @c{nil} si la prueba es falso.

   @src elisp
     (> 4 5)
   @end src

** @c{save-excursion}

   La función @c{save-excursion} es la cuarta y última forma especial vamos a
   discutir en este capítulo.

   En los programas Emacs Lisp utilizados para edición, la función
   @c{save-excursion} es muy común. Guarda la posición del punto y la marca,
   ejecuta el cuerpo de la función, y luego restaura el punto y marca a sus
   posiciones previas si sus posiciones fueron cambiadas. Su objetivo
   principal es impedir que el usuario sea sorprendido y perturbado por el
   movimiento inesperado del punto o la marca.

   Antes de hablar de @c{save-excursion}, puede ser útil examinar primero que
   son el punto y la marca en GNU Emacs. @:{Punto} es la posición actual del
   cursor. Donde sea que se encuentre el cursor, estara el punto. De forma
   más precisa, en los terminales donde aparece el cursor sobre un carácter,
   el punto está inmediatamente antes del carácter. En Emacs Lisp, el punto
   es un numero entero. El primer carácter en un búffer es el número uno, el
   segundo es el número dos, y así sucesivamente. La función @c{point}
   devuelve la posición actual del cursor como un número. Cada búffer tiene
   su propio valor para el punto.

   La @:{marca} es otra posición en el búffer; su valor se puede establecer
   con un comando como @k{C-SPC} (@c{set-mark-command}). Si una marca se ha
   establecido, puede utilizar el comando @k{C-x C-x}
   (@c{exchange-point-and-mark}) para hacer que el cursor salte a la marca y
   establecer la marca en la posición previa del punto. Además, si se
   establece otra marca, la posición le da marca anterior se guarda en el
   historico de marcas, puede guardar muchas posiciones de las marcas de esta
   forma. Se puede saltar el cursor a una marca guardada presionando @k{C-u
   C-SPC} una o más veces.

   La parte del búffer entre el punto y la marca se llamada @:{la
   región}. Numerosos comandos trabajan en la región, incluyendo
   @c{center-region}, @c{count-lines-region}, @c{kill-region} y
   @c{print-region}.

   La forma especial @c{save-excursion} guarda las posiciones del punto y la
   marca y restaura estas posiciones después que el interprete Lisp evalua el
   código dentro del cuerpo de la forma especial. De este modo, si el punto
   se encontraba al inicio de un trozo de texto y algún código movido el
   punto al final del búffer, @c{save-excursion} pondria el punto de nuevo
   donde estaba antes, luego que las expresiones en el cuerpo de la funcion
   fueran evaluadas.

   En Emacs, con frecuencia una función mueve el punto como parte de su
   funcionamiento interno a pesar de que un usuario no espere esto. Por
   ejemplo, @c{count-lines-region} mueve el punto. Para evitar que el usuario
   sea molestado por los saltos que sol a la vez inesperados e (desde el
   punto de vista del usuario) innecesarios, @c{save-excursion} se utiliza a
   menudo para mantener el punto y la marca en la posición esperada por el
   usuario. El uso de @c{save-excursion} es bueno para mantener el orden.

   Para asegurarse que la casa se mantiene limpia, @c{save-excursion}
   restaura los valores del punto y la marca incluso si algo va mal en el
   código dentro de ella (o, para ser más preciso y usar el lenguaje tecnico
   apropiado, “en caso de salida anormal”). Esta funcionalidad es muy útil.

   Además de registrar los valores del punto y marca, @c{save-excursion} no
   pierde de vista el buffer actual, y lo restaura, también. Esto significa
   que puedes escribir código que cambie el buffer y @c{save-excursion} debe
   volver al buffer original. Asi es como se utiliza @c{save-excursion} en
   @c{append-to-buffer}. (Véase Sección @l{La Definición de
   @c{append-to-buffer}}.)

*** Plantilla para una Expresión @c{save-excursion}

    La plantilla de código usando @c{save-excursion} es simple:

    @src elisp
      (save-excursion
        cuerpo…)
    @end src

    El cuerpo de la función es una o más expresiones que serán evaluadas de
    forma secuencial por el intérprete Lisp. Si hay más de una expresión en
    el cuerpo, el valor de la última será devuelto como el valor de la
    función @c{save-excursion}. Las otras expresiones en el cuerpo solo se
    evaluan por sus efectos secundarios; y @c{save-excursion} en sí solo se
    utiliza por su efecto secundario (que es restaurar las posiciones del
    punto y la marca).

    La siguiente plantilla explica @c{save-excursion}, con más detalle:

    @src elisp
      (save-excursion
        primera-expresion-en-el-cuerpo
        segunda-expresion-en-el-cuerpo
        tercera-expresion-en-el-cuerpo
         …
        ultima-expresion-en-el-cuerpo)
    @end src

    Una expresión, por supuesto, puede ser un símbolo por sí mismo o una
    lista.

    En el código Emacs Lisp, una expresión @c{save-excursion} a menudo ocurre
    dentro del cuerpo de una expresión @c{let}. Se ve asi:

    @src elisp
      (let varlist
        (save-excursion
          cuerpo…))
    @end src

** @t(Repaso: Cómo escribir definiciones de funciones<>Repaso)

   En los últimos capítulos se han introducido un buen número de funciones y
   formas especiales. A continuacion se describen brevemente, junto con
   algunas funciones similares que aun no han sido mencionadas.

   - eval-last-sexp ::

     Evalúar la última expresión simbólica antes de la posición actual del
     punto. El valor se imprime en el área echo a menos que la función se
     invoque con un argumento; en este caso, la salida se imprime en el
     búffer actual. Este comando está normalmente esta asociado a @k{C-x
     C-e}.

   - defun ::

     Definir la función. Esta forma especial tiene hasta cinco partes: el
     nombre una plantilla para los argumentos que se pasan a la función, la
     documentacion, una declaración interactiva opcional, y el cuerpo de la
     definición.

     Por ejemplo, en las primeras versiones de Emacs, la definición de
     función era como sigue. (Eso es ligeramente más complejo ahora que se
     busca el primer caracter que no es espacio en lugar del primer caracter
     visible.)

     @src elisp
       (defun volver-a-la-indentacion ()
         "Mueve el punto al primer caracter visible de la linea."
         (interactive)
         (beginning-of-line 1)
         (skip-chars-forward " \t"))
     @end src

   - interactive ::

     Anuncia al intérprete que la función se puede usar de forma interactiva.
     Esta forma especial puede ser seguida por una cadena con una o más
     partes que pasan la información a los argumentos de la función, de forma
     secuencial. Estas partes pueden también decir al intérprete que solicite
     información. Las Partes de la cadena estan separadas por saltos de
     linea, @'{\n}.

     Los codigos de caractere comúnes son:

     - b :: El nombre de un búffer existente.

     - f :: El nombre de un fichero existente

     - p :: El argumento prefijo numérico. (Tenga en cuenta que esta ‘p’ es
       minúscula.)

     - r :: Punto y marca, como dos argumentos numéricos, el más pequeño
       primero. Este es el unico codigo de una letra que especifica dos
       argumentos sucesivos en vez de uno.


     Véase Sección @l{info:elips#Interactive Codes<>Codigo de caracteres para
     @'{interactive}} en @e(El Manual de Referencia de GNU Emacs Lisp), para
     obtener una lista completa de los codigos de caracteres.

   - let ::

     Declarar que una lista de variables para utilizarla dentro del cuerpo de
     @c{let} y darle a cada una un valor inicial, ya sea @c{nil} o un valor
     específico; luego evaluar el resto de las expresiones en el cuerpo del
     @c{let} y devolver el valor de la última expresion. Dentro del cuerpo
     del @c{let}, el intérprete Lisp no ve los valores de variables con el
     mismos nombre fuera de @c{let}.

     Por ejemplo,

     @src elisp
       (let ((foo (buffer-name))
             (bar (buffer-size)))
         (message
          "Este buffer es %s y tiene %d caracteres."
          foo bar))
     @end src

   - save-excursion ::

     Registra los valores de punto y marca y el búffer actual antes de
     evaluar el cuerpo de esta forma especial. Restaura los valores de punto
     y marca y el búffer luego de esto.

     Por ejemplo,

     @src elisp
       (message "Estamos %d caracteres dentro de este buffer."
                (- (point)
                   (save-excursion
                     (goto-char (point-min)) (point))))
     @end src


   - if ::

     Evalúa el primer argumento a la función; si es verdadero, evalúa el
     segundo argumento; de otra forma evalúa el tercer argumento, si hay uno.

     La forma especial @c{if} se llamada @:{condicional}. Hay otros
     condicionales en Emacs Lisp, pero @c{if} es quizás el más comúnmente
     usado.

     Por ejemplo,

     @src elisp
       (if (= 24 emacs-major-version)
           (message "Esta es la version 24 de Emacs")
         (message "Esta no es la version 24 de Emacs"))
     @end src

   - <  ::
     >  ::
     <= ::
     >= ::

     La función @c{<} prueba si su primer argumento es menor que su segundo
     argumento. Una función correspondiente, @c{>}, prueba si el primer
     argumento es mayor que el segundo. Del mismo modo, @c{<=} prueba si el
     primer argumento es menor o igual al segundo y @c{>=} prueba si el
     primer argumento es mayor o igual al segundo. En todos los casos, ambos
     argumentos deben ser números o marcadores (los marcadores indican
     posiciones en búffers).

   - = ::

     La función @c{=} prueba si dos argumentos, ambos números o marcadores,
     son iguales.

   - equal ::
     eq    ::

     Prueba si dos objetos son el mismo. @c{equal} utiliza un signicado de la
     palabra ‘mismo’ y @c{eq} utiliza otro: @c{equal} devuelve verdadero si
     los dos objetos tienen una estructura y contenidos similares, por
     ejemplo, dos copias del mismo libro. Por otro lado, @c{eq}, devuelve
     verdadero si ambos argumentos son realmente el mismo objeto.

   - string<      ::
     string-lessp ::
     string=      ::
     string-equal ::

     La función @c{string-lessp} prueba si su primer argumento menor que el
     segundo. Un nombre alternativo mas corto para la misma función (un
     @c{defalias}) es @c{string<}.

     Los argumentos para @c{string-lessp} deben ser cadenas o símbolos; la
     ordenación es lexicográfica, por lo que mayusculas o minusculas son
     significativas. Los nombres impresos de símbolos se utilizan en lugar de
     los propias símbolos.

     Una cadena vacía, @'{""}, una cadena sin caracteres en ella, es más
     pequeña que cualquier cadena de caracteres.

     @c{string-equal} proporciona la prueba correpondiente para la igualdad.
     Su nombre corto alternativo es @c{string=}. No hay funciones de prueba
     que correspondan a @c{>}, @c{>=} o @c{<=}.

   - message ::

     Imprime un mensaje en el área echo. El primer argumento es una cadena
     que puede contener, @'{%s}, @'{%d}, o @'{%c} para imprimir el valor de
     los argumentos que siguen a la la cadena. El argumento utilizado por
     @'{%s} debe ser una cadena o un simbolo, el argumeto utilizado por
     @'{%d} debe ser un número. El argumento usado por @'{%c} debe ser un
     codigo númerico @e{ASCII}; se imprimira como el caracter con este código
     @e{ASCII}. (Otras se han mencionado otras secuencias @c(%-)).

   - setq ::
     set  ::

     La función @c{setq} asigna el valor de su primer argumento al valor del
     segundo argumento. El primer argumento es citado automáticamente por
     @c{setq}. No hace lo mismo para pares sucesisvos de argumentos. Otra
     función, @c{set}, toma solo dos argumentos y evalúa ambos antes de
     asignar el valor devuelto por su primer argumento al valor devuelto por
     el segundo argumento.

   - buffer-name ::

     Sin un argumento, devuelve el nombre del búffer, como una cadena.

   - buffer-file-name ::

     Sin un argumento, devuelve el nombre del fichero del búffer que se esta
     visitando.

   - current-buffer ::

     Devuelve el búffer en el que Emacs se encuentra activo; Puede que no sea
     el búffer que es visible en la pantalla.

   - other-buffer ::

     Devuelve el ultimo búffer seleccionado (que no sea el buffer pasado a
     @c{other-buffer} como un argumento y que no sea el búffer actual).

   - switch-to-buffer ::

     Selecciona un búffer de Emacs para activarlo y mostralo en la ventana
     actual para que los usuarios puedan verlo. Normalmente ligado a @k{C-x
     b}.

   - set-buffer ::

     Cambiar la atención de Emacs a un búffer en el que se ejecutaran
     programas. No altera lo que la ventana está mostrando.

   - buffer-size ::

     Devuelve el número de caracteres en el búffer actual.

   - point ::

     Devuelve el valor de la posicion actual del cursor, como un entero
     contando el número de caracteres desde el inicio del búffer.

   - point-min ::

     Devuelve el valor mínimo permisible del punto en el búffer actual. Esto
     es 1, a menos que narrowing esté activo

   - point-max ::

     Devuelve el valor del máximo permisible del punto en el búffer actual.
     Esto es el fin del búffer, a menos que narrowing este activo.

** Ejercicios

   - Escribe una función no interactiva que diplique el valor de su
     argumento, un número. Luego haz la función interactiva.

   - Escribe una función que compruebe si el valor actual de @c{fill-column}
     es mayor que el argumento pasado a la función, y si es así, imprime un
     mensaje apropiado.

* Algunas funcienes relacionadas al buffer

  En este capítulo estudiamos en detalle varias de las funciones usadas en
  GNU Emacs. Esto se llama un “walk-through” (visita o demostracion de un
  area o tarea). Estas funciones se utilizan como ejemplos de código Lisp,
  pero no son ejemplos imaginarios; con excepción del primero, con la
  definición de función simplificada, estas funciones muestran el código real
  usado en GNU Emacs. Se puede aprender mucho de estas definiciones. Las
  funciones descritas aquí están todas relacionadas a búffers. Mas tarde,
  estudiaremos otras funciones.

** Encontrar Más información

   En este recorrido, describire cada nueva función, algunas veces en detalle
   y algunas veces brevemente. Si estás interesado, puedes obtener la
   documentación completa de cualquier función de Emacs Lisp en cualquier
   momento presiona @k{C-h f} y luego escribe el nombre de la función (y
   luego @k{RET}). Del mismo modo, se puede obtener la documentación completa
   de una variable con @k{C-h v}, luego el nombre de la variable (y despues
   @k{RET}).

   Ademas, @c{describe-function} te dira la ubicacion de la definición de la
   función.

   Coloca el punto dentro del nombre del fichero que contiene la función y
   presiona la tecla @k{RET}. En este caso, @k{RET} significa @c{push-button}
   en lugar de ‘return’ o ‘enter’. Emacs te llevara directamente a la
   definición de la función.

   De manera más general, si quieres ver una función en su fichero fuente
   original, puedes utilizar la función @c{find-tag} para saltar a la misma.
   @c{find-tag} trabaja con una amplia variedad de lenguajes, no solo Lisp, y
   C, y tambien funciona con texto que no codigo de programacion. Por
   ejemplo, @c{find-tag} saltará a los distintos nodos del codigo fuente de
   este documento. La función @c{find-tag} depende de ‘tablas de etiquetas’
   que registran las ubicaciones de las funciones, variables, y otros
   elementos a los que @c{find-tag} salta.

   Para usar el comando @c{find-tag}, presiona @k{M-.} (es decir, presiona la
   tecla punto mientras presionas la tecla @k(META), o presiona @k{ESC} y
   luego la tecla punto), a continuacion, en es prompt, escribe el nombre de
   la función para ver su código fuente, por ejemplo @c{mark-whole-buffer}, y
   luego pulsa @k{RET}. Emacs cambiará de búffer y mostrará el código fuente
   de la función en la pantalla. Para regresar a tu búffer actual, presiona
   @k{C-x b RET}. (En algunos teclados, la tecla @k{META} se etiqueta como
   @k{ALT}.)

   Dependiendo de la configuracion de los valores iniciales por defecto de tu
   copia de Emacs, puede ser necesario especificar la posición de tu ‘tabla
   de tags’, que es un fichero llamado @f{TAGS}. Por ejemplo, si estás
   interesado en el codigo fuente de Emacs, la tabla de tags, si ya ha sido
   creada, estará en un subdirectorio del directorio
   @f{/usr/local/share/emacs}; de este modo se usaría el comando @c{M-x
   visit-tags-table} y se especifica una ruta como
   @f{/usr/local/share/emacs/24.1.1/lisp/TAGS}. Si la tabla de etiquetas no
   ha sido creada, tendrás que crearla por tí mismo. Estara en un fichero
   como @f{/usr/local/src/emacs/src/TAGS}.

   Para crear un fichero @f{TAGS} en un directorio específico, cambia a ese
   directorio en Emacs mediante el comando @k{M-x cd}, o lista el directorio
   con @k{C-x d} (@c(dired)). A continuacion ejecuta el comando de
   compilacion, con @c{etags *.el} como comando a ejecutar:

   @example
     M-x compile RET etags *.el RET
   @end example

   Para más información, ver @l{Crea tu propio fichero @f{TAGS}}.

   Después de te familiarices con Emacs Lisp, te encontrarás con frecuencia
   utilizando @c{find-tag} como metodo de navegar atraves del código fuente;
   y crearás tus propias tablas @f{TAGS}.

   Por cierto, los ficheros que contienen código Lisp son llamados
   convencionalmente @:{librerías}. La metáfora se deriva que una librería
   especializada, tal como una librería de leyes o una librería de
   ingeniería, en lugar de una librería general. Cada librería, o fichero,
   contiene funciones que se relacionan con un tema o actividad determinado,
   por ejemplo @f{abbrev.el} para el manejo de abreviaturas y otros atajos, y
   @f{help.el} para ayuda on-line. (Algunas veces varias librerías
   proporcionan código para una sola actividad, como los distintos ficheros
   @f{rmail…}  que proporcionan para leer correo electrónico.) En @e{El
   Manual de GNU Emacs}, verás varias frases como “El comando @k{C-h p} te
   permite buscar las librerias estándar de Emacs Lisp por la palabra clave
   del tema.

** Una definición simplificada de @c{beginning-of-buffer}

   El comando @c{beginning-of-buffer} es una buena función para empezar, ya
   que es probable que estes familiarizado con ella y es fácil de
   entender. Usado como un comando interactivo, @c{beginning-of-buffer} mueve
   el cursor al inicio del búffer, dejando la marca en la posición
   anterior. Esta generalmente unido a @k{M-<}.

   En esta sección, vamos a hablar de une versión reducida de la función que
   muestra como se utiliza con mayor frecuencia. Esta función reducida
   funciona como esta escrita, pero no contiene código para una opcion
   compleja. En otra sección, describiremos la función entera. (Véase Sección
   @l(Definición completa de @c{beginning-of-buffer}).

   Antes de mirar el código, vamos a considerar lo que la definición de
   función tiene que contener: debe incluir una expresión que haga la función
   interactiva por lo que se puede llamar escribiendo @k{M-x
   beginning-of-buffer} o pulsando uno atajos como @k{M-<}; debe incluir
   código para dejar una marca en la posición original del búffer; y debe
   incluir código para mover el cursor al inicio del búffer.

   Aquí está el texto completo la versión reducida de la función:

   @src elisp
     (defun simplified-beginning-of-buffer ()
       "Mover el punto al inicio del buffer;
     dejar marca en la posicion anterior."
       (interactive)
       (push-mark)
       (goto-char (point-min)))
   @end src

   Al igual que todas las definiciones de función, esta definición tiene
   cinco partes siguiendo la forma especial @c{defun}:

   1. El nombre: en este ejemplo, @c{simplified-beginning-of-buffer}.

   2. Una lista de los argumentos: en este ejemplo, una lista vacía, @c{()},

   3. La cadena de documentación.

   4. La expresión interactiva.

   5. El cuerpo.


   En esta definición de función, la lista de argumentos está vacía; esto
   significa que esta función no requiere ningun argumento. (Cuando nos
   fijamos en la definición de la función completa, veremos que se puede
   pasar un argumento opcional.)

   La expresión interactiva le informa a Emacs que se pretende utilizar la
   función de forma interactiva. En este ejemplo, @c{interactive} no tiene un
   argumento porque @c{simplified-beginning-of-buffer} no requiere uno.

   El cuerpo de la función consiste de dos líneas:

   @src elisp
     (push-mark)
     (goto-char (point-min))
   @end src

   La primera de estas líneas es la expresión, @c{(push-mark)}. Cuando el
   interprete Lisp evalua esta expresión, se establece una marca en la
   posición actual del cursor, donde sea que este. La posición de esta marca
   se guarda en el anillo de marcas.

   La siguiente línea es @c{(goto-char (point-min))}. Esta expresión hace
   saltar el cursor hasta el punto mínimo en el búffer, es decir, al inicio
   del búffer (o al inicio de la porción accesible del búffer si narrowed
   esta activo. Véase Sección @l{Reducir y Extender}.)

   El comando @c{push-mark} establece una marca en el sitio donde se
   encontraba el cursor antes de transladarse al inicio del búffer por la
   expresión @c{(goto-char (point-min))}. En consecuencia, puedes, si
   quieres, volver a donde estabas originalmente presionando @k{C-x C-x}.

   ¡Esto es todo lo que hay en la definición de función!

   Cuando leas código como este y te encuentres con una función desconocida,
   como @c{goto-char}, puedes averiguar que es lo que hace mediante el
   comando @c{describe-function}. Para usar este comando, presiona @k{C-h f}
   y luego escribe el nombre de la función y presiona @k{RET}. El comando
   @c{describe-function} imprimirá la cadena de documentacion de la función
   en una ventana @f{*Help*}. Por ejemplo, la documentación de @c{goto-char}
   es:

   @example
     Establece el punto a POSICION, un numero o marcador.
     El inicio del buffer es la posicion (point-min), el final es (point-max).
   @end example

   El argumento de la función es la posición deseada.

   (En el caso de @c{describe-function} el prompt te facilita el símbolo
   debajo o anterior al cursor, lo que te puede evitar escribir el nombre de
   la funcion al colocar el cursor a la justo sobre o después de la función y
   luego presionar @k{C-h f RET}.)

   La definición de la función @c{end-of-buffer} se escribe de la misma forma
   que la definición @c{beginnig-of-buffer} excepto que el cuerpo de la
   función contiene la expresión @c{(goto-char (point-max))} en lugar de
   @c{(goto-char (point-min))}

** La definición de @c{mark-whole-buffer}

   La función @c{mark-whole-buffer} no es mas difícil de entender que la
   función @c{simplified-beginning-of-buffer}. En este caso, sin embargo,
   vamos a ver la función completa, no una versión reducida.

   La función @c{mark-whole-buffer} no se utiliza tan comúnmente como la
   función @c{beginning-of-buffer}, pero no es menos útil: marca un búffer
   completo como una región colocando el punto al inicio y una marca al fin
   del búffer. Generalmente se une a @k{C-x h}.

   En GNU Emacs 22, el código de la función completa se ve asi:

   @src elisp
     (defun mark-whole-buffer ()
       "Coloca el punto al inicio y marca el fin del buffer.
     Probablemente no deberias utilizar esta funcion en programas Lisp;
     Por lo general es un error para una funcion Lisp utilizar cualquier subrutino
     que utiliza o establece la marca."
       (interactive)
       (push-mark (point))
       (push-mark (point-max) nil t)
       (goto-char (point-min)))
   @end src

   Al igual que todas las demas funciones, la función @c{mark-whole-buffer}
   se ajusta dentro de la plantilla de una definición de funcion. La
   plantilla luce asi:

   @src elisp
     (defun nombre-de-funcion (lista-de-argumentos)
       "documentacion…"
       (expresion-interactiva…)
       cuerpo…)
   @end src

   Aquí el cómo funciona la función: el nombre de la función es
   @c{mark-whole-buffer}; es seguido por una lista de argumentos vacía,
   @'{()}, que significa que la función no requiere argumentos. La
   documentación viene a continuacion.

   La siguiente línea es una expresión @c{(interactive)} que indica a Emacs
   que la función se utilizara de forma interactiva. Estos detalles son
   similares a la función @c{simplified-beginning-of-buffer} descrita en la
   sección anterior

*** Cuerpo de @c{mark-whole-buffer}

    El cuerpo de la función @c{mark-whole-buffer} consiste en tres líneas de
    código:

    @src elisp
      (push-mark (point))
      (push-mark (point-max) nil t)
      (goto-char (point-min))
    @end src

    La primera de estas líneas es la expresión, @c{(push-mark (point))}.

    Esta línea hace exactamente el mismo trabajo que la primera línea del
    cuerpo de la función @c{simplified-beginning-of-buffer}, en la que solo
    se escribe @c[(push-mark)]. En ambos casos, el intérprete Lisp coloca una
    marca en la posición actual del cursor.

    No sé por qué en la expresión @c{mark-whole-buffer} se escribe
    @c{(push-mark (point))} y en la expresión @c{beginning-of-buffer} se
    escribe @c{(push-mark)}. Quizás quien escribió el código no conocia que
    los argumentos de @c{push-mark} son opcionales y que si no se pasa un
    argumento a @c{push-mark}, la función establece automáticamente la marca
    en la posicion del punto por defecto. O quizás la expresión fué escrita
    paralelamente a la estructura de la siguiente línea. En cualquier caso,
    la línea proboca que Emacs determine la posición del punto y coloque una
    marca allí.

    En versiones anteriores de GNU Emacs, la siguiente línea de
    @c{mark-whole-buffer} era @c{(push-mark (point-max))}. Esta expresión
    establece una marca en el punto del búffer que tiene el número más
    alto. Este será el final del búffer (o, si el búffer tiene actio
    narrowing, el final de la porción accesible del búffer. Véase Sección
    @l{Reducir y Extender}, para más informacon sobre
    norrowing). Después de colocar esta marca, la marca anterior, la
    establecida en el punto, ya no esta configurada, pero Emacs recuerda su
    posición, al igual que recuerda todas las demas marcas recientes. Esto
    significa que se puedes, si lo deseas, volver a esta posición presionando
    @k{C-u C-SPC} dos veces.

    En GNU Emacs 22, @c{(point-max)} es ligeramente más complicado. La
    línea es

    @src elisp
      (push-mark (point-max) nil t)
    @end src

    La expresión funciona casi igual que antes. Se establece una marca en la
    posicion con la numeracion mas alta posible en el búffer. Sin embargo, en
    esta versión, @c{push-mark} tiene dos argumentos adicionales. El segundo
    argumento de @c{push-mark} es @c{nil}. Esto indica a la función que debe
    @e{mostrar} un mensaje que dice ‘Mark set’ cuando se coloca la marca. El
    tercer argumento es @c{t}. Esto indica a @c{push-mark} que active la
    marca cuando el modo Transient Mark está activo. Transient Mark mode
    resalta la región activa. Con frecuencia esta desactivado.

    Finalmente, la última línea de la función es @c{(goto-char
    (point-min))}. Esta escrito exactamente de la misma forma como está
    escrito @c{beginning-of-buffer}. La expresión mueve el cursor al punto
    mínimo en el búffer, es decir, al inicio del búfferr (o al inicio de la
    porción accesible del búffer). Como resultado de esto, punto se coloca al
    inicio del búffer y la marca se encuentra al final del búffer. Por tanto,
    todo el búffer es la región.

** La definición de @c{append-to-buffer}

   El comando @c{append-to-buffer} es más complejo que el comando
   @c{mark-whole-buffer}. Lo que hace es copiar la región (es decir, la parte
   del búffer entre el punto y la marca) del buffer actual a un búffer
   específico.

   El comando @c{append-to-buffer} utiliza la función
   @c{insert-buffer-substring} para copiar la región.
   @c{insert-buffer-substring} se describe por su nombre: toma una cadena de
   caracteres de una parte de un búffer, una “subcadena”, y la inserta en
   otro búffer.

   La mayor parte de @c{append-to-buffer} corresponde a establecer la
   condiciones para que @c{insert-buffer-substring} funcione: el código debe
   especificar tanto el búffer al que ira el texto, la ventana fuente y
   destino, y la región que será copiada.

   Aquí está el texto completo de la función:

   @src elisp
     (defun append-to-buffer (buffer start end)
       "Agregar a un buffer especifico el texto de la region.
     Este se inserta en ese buffer antes de su punto.

     Cuando se llama desde un programa, se pasan tres argumentes:
     BUFFER (o nombre del buffer), START y END.
     START y END especifican la porcion del buffer actual a copiar."
       (interactive
        (list (read-buffer "Agregar al buffer: " (other-buffer
                                                 (current-buffer) t))
              (region-beginning) (region-end)))
       (let ((oldbuf (current-buffer)))
         (save-excursion
           (let* ((append-to (get-buffer-create buffer))
                  (windows (get-buffer-window-list append-to t t))
                  point)
             (set-buffer append-to)
             (setq point (point))
             (barf-if-buffer-read-only)
             (insert-buffer-substring oldbuf start end)
             (dolist (window windows)
               (when (= (window-point window) point)
                 (set-window-point window (point))))))))
   @end src

   Se puede entender la función si se mira como una serie de plantillas
   rellenas.

   La plantilla exterior es para la definición de función. Esta función, se
   ve como esto (con varios espacios ocupados):

   @src elisp
     (defun append-to-buffer (buffer start end)
       "documentacion…"
       (interactive …)
       cuerpo…)
   @end src

   La primer línea de la función incluye su nombre y tres argumentos. Los
   argumentos son el @c{búffer} al cual copiar el texto, @c{start} y @c{end}
   que son el inicio y el fin de la región del buffer actual desde donde se
   va a copiar.

   La siguiente parte de la función es la documentación, que es clara y
   completa. Como es convencional, los tres argumentos estan escritos en
   mayúsculas para que los noces con facilidad. Aun mejor, se describen en el
   mismo orden que en la lista de argumentos.

   Observe que la documentación distingue entre un búffer y su nombre. (La
   función puede manejar cualquiera.)

*** La expresión interactiva @c{append-to-buffer}

    Ya que la función @c{append-to-buffer} se puede utilizar de forma
    interactiva, la función debe tener una expresión @c{interactive}. (Para
    una analisis de @c{interactive}, ve la seccion @l{Crear una función
    interactiva}.)  La expresión se lee de la siguiente manera:

    @src elisp
      (interactive
       (list (read-buffer
              "Agregar al buffer: "
              (other-buffer (current-buffer) t))
             (region-beginning)
             (region-end)))
    @end src

    Esta expresión no tiene letras para representar partes, como se describio
    anteriormente. En su lugar, inicia una lista con estas partes:

    La primer parte de la lista es una expresión para leer el nombre de un
    búffer y devolverlo como una cadena. Es decir @c(read-buffer). La función
    requiere una prompt como primer argumento, @'{"Agregar al buffer: "}. El
    segundo argumento le indica al comando que valor proporcionar si no se
    especifica nada.

    En este caso este segundo argumento es una expresión que contiene la
    función @c{other-buffer}, una excepción, y una @'{t}, para representar
    verdadero.

    El primer argumento de @c{other-buffer}, la excepción, es otra función,
    @c{current-buffer}. Esto no va a ser devuelto. El segundo argumento es el
    símbolo de verdadero, @c{t}. Que le dice a @c{other-buffer} que puede
    mostrar búffers visibles (excepto en este caso, no se mostrará el búffer
    actual, lo cual tiene sentido).

    La expresión se ve asi:

    @src elisp
      (other-buffer (current-buffer) t)
    @end src

    El segundo y tercer argumento de la expresión @c{list} son
    @c{(region-beginning)} y @c{(region-end)}. Estas dos funciones
    especifican el inicio y el final del texto que se añade

    Originalmente, el comando utilizaba las letras @'{B} y @'{r}. Toda la
    expresión @c{interactive} se veia así:

    @src elisp
      (interactive "BAppend to buffer:@: \nr")
    @end src

    Pero cuando se hacia esto, el valor por defecto del búffer de cambió era
    invisible. Esto no era lo buscado.

    (El prompt se separo del segundo argumento con una línea nueva,
    @'{\n}. Seguido por un @'{r} que le indica a Emacs unir los dos
    argumentos que siguen al símbolo @c{buffer} en la lista de argumentos de
    la función (es decir, @c{start} y @c{end}) a los valores del punto y
    marca. Este argumento funcionaba bien.)

*** El cuerpo de @c{append-to-buffer}

    El cuerpo de la función @c{append-to-buffer} inicia con @c{let}.

    Como hemos visto antes (ver Seccion @lc{let}), el propósito de una
    expresión @c{let} es crear y dar valores iniciales a una o más variable
    que solo serán utilizadas dentro del cuerpo del @c{let}. Esto significa
    que esa variable no se debe confundir con cualquier variable del mismo
    nombre fuera de la expresión @c{let}.

    Podemos ver como la expresión @c{let} encaja en la función como un todo
    mostrando una plantilla de @c{append-to-buffer} con la expresión @c{let}
    en resumen:

    @src elisp
      (defun append-to-buffer (buffer start end)
        "documentacion…"
        (interactive …)
        (let ((variable valor))
              cuerpo…)
    @end src

    La expresión @c{let} tiene tres elementos:

    1. El símbolo @c{let};

    2. Una varlist que contiene, en este caso, una unica lista de dos
       elementos, @c{(variable valor)};

    3. El cuerpo de la expresión @c{let}.


    En la función @c{append-to-buffer}, la varlist es la siguiente:

    @src elisp
      (oldbuf (current-buffer))
    @end src

    En esta parte de la expresión @c{let}, la unica variable, @c{oldbuf} se
    une al valor devuelto por la expresión @c{(current-buffer)}. La variable,
    @c{oldbuf}, se utiliza para guardar un registro del búffer en el que
    estás trabajando y desde donde se copiara.

    El elemento o elementos de una varlist esta rodeado por un conjunto de
    paréntesis por lo que el intérprete Lisp puede distinguir la varlist del
    cuerpo del @c{let}. Como consecuencia, la lista de dos elementos dentro
    de la varlist está rodeada por un conjunto circunscrito de paréntesis.
    La línea tiene este aspecto:

    @src elisp
      (let ((oldbuf (current-buffer)))
        … )
    @end src

    Los dos paréntesis antes de @c{oldbuf} podrían sorprenderte si no fuera
    porque el primer paréntesis marca el límite de la varlist y el segundo
    paréntesis marca el inicio de la lista de dos elementos, @c{(oldbuf
    (current-buffer))}.

*** @c{save-excursion} en @c{append-to-buffer}

    El cuerpo de la expresión @c{let} dentro de @c{append-to-buffer} consiste
    de una expresión @c{save-excursion}.

    La función @c{save-excursion} guarda las posiciones de punto y marca, y
    restaura estas posiciones después de que las expresiones en el cuerpo de
    @c{save-excursion} completan su ejecución. Además, @c{save-excursion} no
    pierde de vista el búffer original, y lo restaura. Asi es como se utizia
    @c{save-excursion} en @c{append-to-buffer}.

    Por cierto, vale la pena señalar que una función Lisp normalmente se
    formatea de modo que todo lo que se encierre en un conjunto de multiples
    lineas se indente más a la derecha que el primer símbolo. En esta
    definición de función, @c{let} se indenta más que @c{defun}, y
    @c{save-excursion} se indenta más que @c{let}, asi:

    @src elisp
      (defun …
        …
        …
        (let…
          (save-excursion
            …
    @end src

    Esta convención de formato hace que sea fácil de ver que líneas en el
    cuerpo de @c{save-excursion} son encerradas por los parentesis asociados
    con @c{save-excurion}, de igual forma el mismo @c(save-excursion) esta
    encerrado por los paréntesis asociados con @c{let}:

    @src elisp
      (let ((oldbuf (current-buffer)))
        (save-excursion
          …
          (set-buffer …)
          (insert-buffer-substring oldbuf start end)
          …))
    @end src

    El uso de la función @c{save-excursion} puede ser visto como el proceso
    de llenar espacios de una plantilla:

    @src elisp
      (save-excursion
        primer-expresion-en-el-cuerpo
        segunda-expresion-en-el-cuerpo
         …
        ultima-expresion-en-el-cuerpo)
    @end src

    En esta función, el cuerpo de @c{save-excursion} contiene solo una
    expresión, la expresión @c{let*}. Ya conoces la función @c{let}. La
    función @c{let*} es diferente. Posee un @'{*} en su nombre. Esto le
    permite a Emacs colocar cada variable de su varlist en secuencia, una
    después de otra.

    Su caracteristica fundamental es que las siguientes variables en la
    varlist puedan hacer uso de los valores establecidos por Emacs
    anteriomente en la varlist. Véase Sección @l{La expresión @c{let*}}.

    Vamos a omitir funciones como @c{let*} y nos centraremos en dos: la
    función @c{set-buffer} y la función @c{insert-buffer-substring}.

    En los viejos tiempos, la expresión @c{set-buffer} era simplemente:

    @src elisp
      (set-buffer (get-buffer-create buffer))
    @end src

    pero ahora es

    @src elisp
      (set-buffer append-to)
    @end src

    @c{append-to} esta unido al @c{(get-buffer-create-buffer)} anterior en la
    expresión @c{let*}. Esta union extra no sería necesaria excepto que
    @c{append-to} se utiliza despues en la varlist como un argumento para
    @c{get-buffer-window-list}.

    La definición de la función @c{append-to-buffer} inserta texto desde el
    búffer en el que estás actualmente al buffer que se indique. Sucede que
    @c{insert-buffer-substring} copia texto desde otro búffer al búffer
    actual, todo lo contrario––es por ello que la definición
    @c{append-to-buffer} inicia con un @c{let} que une el símbolo local
    @c{oldbuf} al valor devuelto por @c{current-buffer}.

    La expresión @c{insert-buffer-substring} es la siguiente:

    @src elisp
      (insert-buffer-substring oldbuf start end)
    @end src

    La función @c{insert-buffer-substring} copia una cadena @e{desde} el
    búffer especificado como su primer argumento e inserta la cadena dentro
    del búffer actual. En este caso, el argumento de
    @c{insert-buffer-substring} es el valor de la variable creada y vinculada
    por el @c{let}, es decir, el valor de @c{oldbuf}, que era el búffer
    actual cuando diste el comando @c{append-to-buffer}.

    Después de que @c{insert-buffer-substring} ha hecho su trabajo,
    @c{save-excursion} restaurará la acción al búffer original y
    @c{append-to-buffer} habrá hecho su trabajo.

    Escrito en forma de esquema, los funcionamientos del cuerpo se ven asi:

    @src elisp
      (let (unir-oldbuf-al-valor-del-buffer-actual)
        (save-excursion                       ; guarda un registro del buffer.
          cambio-de-buffer
          ensertar-substring-desde-oldbuf-a-buffer)

        regresar-al-buffer-original-al-terminar
      dejar-que-el-siginificado-local-de-oldbuf-desaparacesca-al-terminar
    @end src

    En resumen, @c{append-to-buffer} funciona como sigue: se guarda el valor
    del búffer actual en la variable llamada @c{oldbuf}. Se obtiene el nuevo
    búffer (creando uno si es necesario) y cambia la atención de Emacs a
    este. Usando el valor de @c{oldbuf}, inserta la región del texto desde el
    búffer antiguo dentro del nuevo búffer; y luego se usando
    @c{save-excursion}, regresas a tu búffer original.

    Al observar @c{append-to-buffer}, se ha explorado una función bastante
    compleja. Muestra como usar @c{let} y @c{save-excursion}, y como cambiar
    y volver desde otro buffer. Muchas definiciones de función usan @c{let},
    @c{save-excursion}, y @c{set-buffer} de esta manera.

** Repaso

   Aquí está un breve resumen de las diferentes funciones descritas en este
   capítulo.

   - describe-function ::
   - describe-variable ::

     Imprime la documentación de una función o variable. Convencionalmente
     unidas a @k{C-h f} y @k{C-h v}.

   - find-tag ::

     Encuentra el fichero que contiene la codigo de una función o variable y
     cambia a dicho buffer, colocando el punto al inicio del elemento.
     Convencionalmente unido a @k{M-.} (esto es un punto luego de la tecla
     @k{META}).

   - save-excursion ::

     Guarda la posicion de punto y marca y restaura sus valores tras evaluar
     los argumentos de @c{save-excursion}. Ademas, recuerda el buffer actual
     y regresa a el.

   - push-mark ::

     Asigna la marca a una posicion y guarda el valor de la marca previa en
     el anillo de marcas. La marca es una ubicacion en el búffer que
     mantendra su posición relativa, incluso si se añade o borra texto del
     búffer.

   - goto-char ::

     Establece el punto a la ubicacion especificada por el valor del
     argumento, que puede ser un número, una marca, o una expresión que
     devuelve el número de una posición, como @c{(point-min)}.

   - insert-buffer-substring ::

     Copia una región de texto desde un búffer que se pasa a la función como
     un argumento e inserta la región dentro del búffer actual.

   - mark-whole-buffer ::

     Marca el búffer completo como una región. Normalmente unido a @k{C-x h}.

   - set-buffer ::

     Cambia la atención de Emacs a otro búffer, pero no se muestra el cambio
     en la ventana. Se utiliza cuando un programa y no humano trabaja en un
     búffer distinto.

   - get-buffer-create ::
     get-buffer        ::

     Busca el búffer nombrado o crea uno si el búffer con ese nombre no
     existe. La función @c{get-buffer} devuelve @c{nil} si el nombre del
     búffer no existe.

** Ejercicios

   - Escribe tu propia definición de la función @c{simplified-end-of-buffer};
     luego pruebala para ver si funciona.

   - Utiliza @c{if} y @c{get-buffer} para escribir una función que imprima un
     mensaje que te diga si un buffer existe.

   - Utilizando @c{find-tag}, busca el codigo para la función
     @c{copy-to-buffer}

* Algunas Funciones Más Complejas

  En este capítulo, nos basamos en lo que hemos aprendido en los capítulos
  anteriores examinando funciones más complejas. La función @c{copy-to-buffer}
  ilustra el uso de dos expresiones @c{save-excursion} en una definición,
  mientras que la función @c{insert-buffer} ilustra el uso de un asterisco en
  una expresión @c{interactive}, el uso de @c{or}, y la importante distinción
  entre un nombre y el objeto al que el nombre hace referencia.

** La definición de @c{copy-to-buffer}

   Después de comprender cómo trabaja @c{append-to-buffer}, es fácil entender
   @c{copy-to-buffer}. Esta función copia texto dentro de un búffer, pero en
   lugar de agregarlo al segundo búffer, se sustituye todo el texto anterior en
   el segundo búffer.

   El cuerpo de @c{copy-to-buffer} tiene este aspecto,

   @src elisp
     …
     (interactive "BCopy to buffer: \nr")
     (let ((oldbuf (current-buffer)))
       (with-current-buffer (get-buffer-create buffer)
         (barf-if-buffer-read-only)
         (erase-buffer)
         (save-excursion
           (insert-buffer-substring oldbuf start end)))))
   @end src

   La función @c{copy-to-buffer} tiene una expresión @c{interactive} mas
   sencilla que @c{append-to-buffer}.

   Despues la definición dice:

   @src elisp
     (with-current-buffer (get-buffer-create buffer) …
   @end src

   En primer lugar, mira en la expresión más interna; que se evalua primero.
   Esta expresión inicia con @c{get-buffer-create buffer}. La función le indica
   a la computadora que utilice el búffer con el nombre específicado como aquel
   al que quieres copiar, o si tal búffer no existe, créarlo. Luego, la función
   @c{with-current-buffer} evalúa su cuerpo con este búffer temporal actual.

   (Esto demuestra otra forma de cambiar la atención de la computadora pero no
   por parte del usuario. La función @c{append-to-buffer} muestro como hacer lo
   mismo con @c{save-excursion} y @c{set-buffer}. @c{with-current-buffer} es un
   nuevo mecanismo, posiblemente mas sencillo.)

   La función @c{barf-if-buffer-read-only} envía un mensaje de error diciendo
   que el búffer es de solo lectura si no se puede modificar.

   La siguiente línea tiene la función @c{erase-buffer} como su único
   contenido. Este función borra el búffer.

   Finalmente, las últimas dos líneas contienen la expresión @c{save-excursion}
   con @c{insert-buffer-substring} como su cuerpo. La expresión
   @c{insert-buffer-substring} copia el texto desde el búffer en el que te
   encuentras (no has visto que el computador cambie su atención, por lo que no
   sabes que ese búffer ahora se llama @c{oldbuf}).

   Por cierto, esto es lo que se entiende por ‘reemplazo’. Para reemplazar el
   texto Emacs borra el texto anterior y luego inserta el texto nuevo.

   A grandes rasgos, el cuerpo de @c{copy-to-buffer} se ve asi:

   @src elisp
     (let (@V{bind-}@c{oldbuf}@V{-to-value-of-}@c{current-buffer})
         (@V{with-the-buffer-you-are-copying-to}
           (@V{but-do-not-erase-or-copy-to-a-read-only-buffer})
           (erase-buffer)
           (save-excursion
             @V{insert-substring-from-}@c{oldbuf}@V{-into-buffer})))
   @end src

** La definición de @c{insert-buffer}

   @c{insert-buffer} es otra función relacionada con búffers. Este comando copia
   otro búffer @e{dentro} del búffer actual. Es lo contrario a
   @c{append-to-buffer} o @c{copy-to-buffer}, dado que copia una región de texto
   @e{desde} el búffer actual a otro búffer.

   Aquí examinamos en el código original. El código fue simplificado en 2003 y
   es mas dificil de comprender.

   (Véase Sección @l{Nuevo Cuerpo para @c{insert-buffer}}, para ver una
   discusión del nuevo cuerpo.)

   Además, este código ilustra el uso de @c{interactive} con un búffer que
   podría ser @:{read-only} (de solo lectura) y la importante distinción entre
   el nombre de un objeto y el objeto al que realmente hace referencia.

   Aquí está el código anterior:

   @src elisp
     (defun insert-buffer (buffer)
       "Inserta despues del punto el contenido de BUFFER.
     Coloca la marca despues del texto insertado.
     BUFFER puede ser un buffer un el nombre de un buffer."
       (interactive "*bInsert buffer:@: ")
       (or (bufferp buffer)
           (setq buffer (get-buffer buffer)))
       (let (start end newmark)
         (save-excursion
           (save-excursion
             (set-buffer buffer)
             (setq start (point-min) end (point-max)))
           (insert-buffer-substring buffer start end)
           (setq newmark (point)))
         (push-mark newmark)))
   @end src

   Al igual que con otras definiciones de función, se puede usar una plantilla
   para ver un esquema de la función:

   @src elisp
     (defun insert-buffer (buffer)
       "documentacion…"
       (interactive "*bInsert buffer:@: ")
       cuerpo…)
   @end src

*** La expresión interactiva en @c{insert-buffer}

    En @c{insert-buffer}, el argumetno de la declaración @c{interactive} tiene
    dos partes, un asterisco, @'{*}, y @'{bInsert buffer:@: }.

**** Un búffer de solo lectura

     El asterisco se utliza cuando el búffer actual es un búffer de solo
     lectura––un búffer que no puede ser modificado. Si @c{insert-buffer} se
     llama cuando el búffer actual es de solo lectura, se imprime un mensaje en
     el area echo a este efecto y el terminal puede emitir un beep o parpadear;
     no se te permitira insertar nada en el búffer actual. El asterisco no tiene
     que ser seguido por un salto de linea para separarlo del siguiente
     argumento.

**** @'{b} en una expresión interactiva

     El siguiente argumento de la expresión interactiva inicia con una letra
     @'{b} minúscula. (Esta es diferente del código para @c{append-to-buffer},
     que utiliza una @'{B} mayúscula. Véase Sección @l{La Definición de
     @c{append-to-buffer}}.) La @'{b} minúscula le indica al intérprete Lisp que
     el argumento de @c{insert-buffer} debe ser un buffer existente o su
     nombre. (La opcion @'{B} mayúscula prevee la posibilidad que no exista el
     búffer.)  Emacs te pedira el nombre del búffer, ofreciendo un búffer por
     defecto, con el autocompletado de nombre habilitado. Si el búffer no
     existe, recibiras un mensaje que dice “No concuerda”; tu terminal tambien
     puede emitir un beep.

     El código nuevo y simplificado genera una lista @c{interactive}. Este
     utiliza las funciones @c{barf-if-buffer-read-only} y @c{read-buffer} con
     las que ya estamos familiarizados y la forma especial @c{progn} con la que
     no. (Se describe mas adelaste).

*** El cuerpo de la función @c{insert-buffer}

    El cuerpo de la función @c{insert-buffer} tiene dos partes principales: una
    expresión @c{or} y una expresión @c{let}. El propósito de la expresión
    @c{or} es asegurar que el argumento @c{buffer} esta unido a un búffer y no
    es solo el nombre de un búffer. El cuerpo de la expresión @c{let} contiene
    el código que copia el otra búffer dentro del búffer actual.

    A grades rasgos, las dos expresiones encajan en la función @c{insert-buffer}
    de esta manera:

    @src elisp
      (defun insert-buffer (buffer)
        "documentacion…"
        (interactive "*bInsert buffer:@: ")
        (or …
            …
        (let (varlist)
            cuerpo-de-let… )
    @end src

    Para entender como la expresión @c{or} asegura que el argumento @c{buffer}
    esta unido a un buffer y no al nombre de un búffer, primero es necesario
    entender la función @c{or}.

    Antes de hacer esto, permíteme reescribir esta parte de la función
    utilizando @c{if} de esta manera puedes ver como se hace de una manera que
    será familiar.

*** @c{insert-buffer} con un @c{if} en lugar de un @c{or}

    El trabajo a realizar es asegurarse de que el valor de @c{buffer} es un
    búffer en sí y no el nombre de un búffer. Si el valor es el nombre, entonces
    debe optenerse el búffer en sí.

    Puedes imaginarte a tí mismo en una conferencia donde un acomodador está
    observando una lista con tu nombre en ella y mirándote: el acomodador sabe
    “asociar” tu nombre, pero no a tí; pero cuando el acomodador te encuentra y
    te toma el brazo, el acomodador llega a “asociarte” a tí.

    En Lisp, se podría describir esta situación así:

    @src elisp
      (if (not (tomando-al-invitado))
          (encontrar-y-tomar-del-brazo-al-invitado))
    @end src

    Queremos hacer lo mismo con un búffer––si no tenemos el búffer en sí,
    queremos conseguirlo.

    Usando un predicado llamado @c{bufferp} que nos informa si tenemos un búffer
    (en lugar de su nombre), podemos escribir el código de esta manera:

    @src elisp
      (if (not (bufferp buffer))              ; parte-if
          (setq buffer (get-buffer buffer)))  ; parte-then
    @end src

    Aquí, la prueba verdadero-o-falso de la expresión @c{if} es @c{(not (bufferp
    buffer))}; y la parte @e(then) es la expresión @c{(setq buffer (get-buffer
    buffer))}.

    En la prueba, la función @c{bufferp} devuelve cierto si su argumento es un
    búffer––sino falso si el argumento es el nombre del búffer. (El último
    carácter del nombre de la función @c{bufferp} es el carácter @'{p}; como
    vimos anteriormente, tal uso de @'{p} es una convención que indica que la
    función es un predicado, que es un término que significa que la función
    determinará si alguna propiedad es verdadera o falsa. Véase Sección
    @l(Usando el tipo incorrecto de objeto como un argumento).)

    La función @c{not} precede la expresión @c{(bufferp buffer)}, así la prueba
    verdadero-o-falso es la siguente:

    @src elisp
      (not (bufferp buffer))
    @end src

    @c{not} es una función que devuelve verdadero si su argumento es falso y
    falso si su argumento es verdadero. Por lo que si @c{(bufferp buffer)}
    devuelve cierto, la expresión @c{not} devuelve falso y vice-versa: lo que es
    “no cierto” es falso y lo que es “no falso” es verdadero.

    Usando esta prueba, la expresión @c{if} funciona como sigue: cuando el valor
    de la variable @c{buffer} está en realidad en un búffer en lugar de su
    nombre, la prueba verdadero-o-falso devuelve falso y la expresión @c{if} no
    evalúa la parte then. Esto está bien, ya que no tenemos que hacer nada para
    la variable @c{buffer} si realmente es un búffer.

    Por otro lado, cuando el valor de @c{buffer} no es un buffer en sí, pero si
    el nombre de un buffer, la prueba verdadero-o-falso devuelve verdadero y se
    evalua la parte then de la expresión. En este caso, la parte then es
    @c{(setq buffer (get-buffer buffer))}. Esta expresión utiliza la función
    @c{get-buffer} para devolver un buffer en sí, dado su nombre. Luego @c{setq}
    asigna la variable @c{buffer} reemplazando su valor anterior (que era el
    nombre del buffer).

*** El @c{or} en el cuerpo

    El propósito de la expresión @c{or} en la función @c{insert-buffer} es
    asegurar que el argumento @c{buffer} está asociado a un búffer y no solo al
    nombre de un búffer. La sección previa muestra como se podría haber hecho el
    trabajo usando una expresión @c{if}. Sin embargo, la función
    @c{insert-buffer} realmente utiliza @c{or}. Para entender esto, es necesario
    entender funciona como @c{or}.

    Una función @c{or} puede tener cualquier número de argumentos. Esta evalúa
    un argumento a la ves y devuelve el valor del primero de sus argumentos que
    no es @c{nil}. Ademas, y esta es una caracteristica crucial de @c{or}, es no
    evalúa los argumentos posteriores después de regresar el primer valor
    no-@c{nil}.

    La expresión @c{or} luce asi:

    @src elisp
      (or (bufferp buffer)
          (setq buffer (get-buffer buffer)))
    @end src

    El primer argumento de @c{or} es la expresión @c{(bufferp buffer)}. Esta
    expresión devuelve verdadero (un valor no-@c{nil}) si el búffer es realmente
    un búffer, y no solo el nombre de un búffer. En la expresión @c{or}, si este
    es el caso, la expresión @c{or} devuelve este valor verdadero y no evalúa la
    siguiente expresión––y esto es bueno para nosotros, ya que no queremos hacer
    nada al valor de @c{buffer} si realmente es un búffer.

    Por otro lado, si el valor de @c{(bufferp buffer)} es @c{nil}, si el valor
    de @c{buffer} es el nombre de un buffer, el intérprete Lisp evalúa el
    siguiente elemento de la expresión. Esta es la expresión @c{(setq buffer
    (get-buffer buffer))}. Esta expresión devuelve un valor no-@c{nil}, que es
    el valor para el que asigna la variable @c{buffer}––y este valor es un
    búffer en sí, no el nombre de un búffer.

    El resultado de todo esto es que el símbolo @c{buffer} siempre es unido a un
    búffer en sí en vez de al nombre de un búffer. Todo esto es necesario debido
    a que la función @c{set-buffer} en la línea siguiente solo funciona con un
    buffer en sí, no con el nombre de un búffer.

    Incidentalmente, usando @c{or}, la situación con el acomodador se escribiria
    así:

    @src elisp
      (or (holding-on-to-guest) (find-and-take-arm-of-guest))
    @end src

*** La expresión @c{let} en @c{insert-buffer}

    Después de asegurarse que la variable @c{buffer} se refiere a un buffer en
    sí y no solo al nombre de un buffer, la función @c{insert-buffer} continúa
    con una expresión @c{let}. Esta especifica tres variables locales,
    @c{start}, @c{end} y @c{newmark} y las une al valor inicial @c{nil}. Estas
    variables se utilizan dentro del resto de @c{let} y oculta temporalmente
    cualquier otra ocurrencia de variables con el mismo nombre en Emacs hasta el
    fin de @c{let}.

    El cuerpo de @c{let} contiene dos expresiones @c{save-excursion}. Primero,
    miremos la expresión @c{save-excursion} al interior en detalle. La expresión
    se ve asi:

    @src elisp
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
    @end src

    La expresión @c{(set-buffer buffer)} cambia la atención de Emacs de el
    búffer actual a el que contene el texto a copiar. En ese búffer las
    variables @c{start} y @c{end} se asignadan al inicio y al fin del búffer,
    usando los comandos @c{point-min} y @c{point-max}. Tenga en cuenta que
    tenemos aquí un ejemplo de cómo @c{setq} es capaz de asignar dos variables
    en la misma expresión. El primer argumento de @c{setq} se establece al valor
    del segundo, y su tercer argumento se establece al valor del cuarto.

    Después el cuerpo del @c{save-excursion} interno es evaluado,
    @c{save-excursion} restaura el búffer original, pero @c{start} y @c{end}
    retienen los valores del inicio y fin del búffer del que se copia el texto.

    La expresión exterior @c{save-excursion} luce asi:

    @src elisp
      (save-excursion
        (inner-save-excursion-expression
           (go-to-new-buffer-and-set-start-and-end)
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
    @end src

    La función @c{insert-buffer-substring} copia el texto @e{dento} del búffer
    actual @e{desde} la región indicada por @c{start} y @c{end} en el
    @c{búffer}. Dado que la totalidad del segundo búffer se encuentra entre
    @c{start} y @c{end}, se copia todo dentro del búffer que estás editando. A
    continuacion, el valor de punto, que será al fin del texto insertado, se
    registra en la variable @c{newmark}.

    Después evaluar el cuerpo del @c{save-excursion} externo, el punto y la
    marca se vuelven a colocar en su posicion original.

    Sin embargo, es conveniente localizar una marca al fin del texto recien
    insertado y localizar el punto a su comienzo. La variable @c{newmark}
    registra el fin del texto insertado. En la última línea de la expresión
    @c{let}, la expresión @c{(push-mark newmark)} asigna una marca a esta
    posición. (La posición anterior de la marca aun es accesible; está grabada
    en el anillo de marcas y puede volver a ella con @k{C-u C-SPC}.)  Mientras
    tanto, el punto está localizado al principio del texto insertado, que es
    donde estaba antes de llamar a la función de insercion, posición que fue
    guardada por la primer @c{save-excursion}.

    La expresión @c{let} completa se ve asi:

    @src elisp
      (let (start end newmark)
        (save-excursion
          (save-excursion
            (set-buffer buffer)
            (setq start (point-min) end (point-max)))
          (insert-buffer-substring buffer start end)
          (setq newmark (point)))
        (push-mark newmark))
    @end src

    Al igual que la función @c{append-to-buffer}, la función @c{insert-buffer}
    utiliza @c{let}, @c{save-excursion} y @c{set-buffer}. Además, la función
    ilustra una forma de utilizar @c{or}. Todas estas funciones son bloques de
    construccion que vamos a encontrar y utilizar una y otra vez.

*** Nuevo cuerpo para @c{insert-buffer}

    El cuerpo en la versión 22 de GNU Emacs es más confuso que en el original.

    Se compone de dos expresiones

    @src elisp
        (push-mark
         (save-excursion
           (insert-buffer-substring (get-buffer buffer))
           (point)))

         nil
    @end src

    excepto, y esto es lo que confunde a los principiantes, un trabajo muy
    importante se realiza al interior de la expresión @c{push-mark}.

    La función @c{get-buffer} devuelve un búffer con el nombre proporcionado.
    Notaras que la función @e{no} se llama @c{get-buffer-create}; esta no crea
    un búffer si uno no existe ya. El búffer devuelto por @c{get-buffer}, un
    búffer existente, se pasa a @c{insert-buffer-substring}, que inserta todo el
    búffer (ya que no se especifica ninguna cosa más).

    La posición donde se inserta el buffer se registra por @c{push-mark}.
    Despues la función devuelve @c{nil}, el valor de su último comando. Dicho de
    otra manera, la función @c{insert-buffer} existe solo para producir un
    efecto secundario, insertar otro buffer, no para devolver ningun valor.

** Definición completa de @c{beginning-of-buffer}

   La estructura básica de la función @c{beginning-of-buffer} ya ha sido
   discutida. (Véase Sección @l{Una definición simplificada de
   @c{beginning-of-buffer}}). Esta sección describe la parte compleja de la
   definición.

   Como se ha descrito anteriormente, cuando se invoca @c{beginning-of-buffer}
   sin argumento, mueve el cursor al inicio del búffer (en realidad, al inicio
   de la porción accesible del búffer), dejando la marca en la posición
   anterior. Sin embargo, cuando el comando se invoca con un número entre uno y
   diez, la función considera el número sera una fracción del tamaño del búffer,
   medido en decenas, y Emacs mueve el cursor a dicha fracción del reccorrido
   desde el inicio del búffer. Por lo tanto, puedes llamar a esta función con el
   comando de teclado @k{M-<}, que moverá el cursor al principio del búffer, o
   con un comando de teclado como @k{C-u 7 M-<} que moverá el cursor a un 70%
   del recorrido a través del búffer. Si se utiliza un número mayor a diez como
   argumento, se movera al final del búffer.

   La función @c{beginning-of-buffer} puede llamarse con o sin argumentos. El
   uso del argumento es opcional.

*** Argumentos opcionales

    A menos que se diga lo contrario, Lisp espera que una función con un
    argumento en su definición de función se llame con un valor para este
    argumento. Si esto no ocurre, se obtiene un error y un mensaje que dice
    @'{Wrong number of arguments} (@"(Número de argumentos erróneo)).

    Sin embargo, los argumentos opcionales son una caracteristica de Lisp: se
    utiliza una @:{palabra clave} en concreto para comunicar al intérprete Lisp
    que un argumento es opcional. La palabra clave es @c{&optional}. (El @'{&}
    al frente de @'{optional} es parte de la palabra clave.) En una definición
    de función, si un argumento va despues de la palabra clave @c{&optional}, no
    necesita pasar ningún valor para este argumento al llamar a la función.

    Por lo tanto la primera línea de la definición de función de
    @c{beginning-of-buffer} tiene este aspecto :

    @src elisp
      (defun beginning-of-buffer (&optional arg)
    @end src

    En resumen, toda la función se ve asi:

    @src elisp
      (defun beginning-of-buffer (&optional arg)
        "documentacion…"
        (interactive "P")
        (or (es-el-argumento-de-una-cons-cell argumento)
            (and ambos-transient-mark-mode-y-mark-active-son-verdadero)
            (push-mark))
        (let (determina-el-tamano-y-lo-establece)
        (goto-char
          (si-hay-un-argumento
              averigua-donde-ir
            de-otro-modo-va-a
            (point-min))))
         do-nicety
    @end src

    La función es similar a la función @c{simplified-beginning-of-buffer}
    excepto que la expresión @c{interactive} tiene @c{"P"} como argumento y la
    función @c{goto-char} es seguida por una expresión @c(if-then-else) que
    calcula donde poner el cursor si hay un argumento que no es un cons cell.

    (Puesto que no explico un cons cell en muchos capítulos, por favor,
    considera ignorar la función @c{consp}. Ve la seccion @l{Cómo se implementan
    las listas}, y la Seccion @l{info:elisp#Cons Cell Type<>"Cons Cell y Tipos
    de Listas"} en @e(El Manual de Referencia GNU Emacs Lisp)).

    La @c{"P"} en la expresión @c{interactive} le indica a Emacs cómo pasar un
    argumento prefijo, si es que hay uno, a la función en forma plana. Un
    argumento prefijo se crea presionando la tecla @k{META} seguida por un
    número, o pulsando @k{C-u} y luego un número. (Si no escribes un número,
    @k{C-u} por defecto es un cons cell con un 4. Una @c{"p"} minúscula en la
    expresión @c{interactive} hace que la función convierta un argumento prefijo
    a un número.)

    La prueba verdadero-o-falso de la expresión @c{if} parace compleja, pero no
    lo es: se comprueba si @c{argumento} tiene un valor que no es @c{nil} y si
    es un cons cell. (Esto es lo que hace @c{consp}; comprueba si su argumento
    es un cons cell.) Si @c{argumento} tiene un valor distinto a @c{nil} (y no
    es un cons cell.), que será el caso si @c{beginning-of-buffer} se llama con
    un argumento numerico, la prueba verdadero-o-falso devolverá verdadero y se
    evaluara la parte @c(then) de la expresión @c{if}. Por otro lado, si
    @c{beginning-of-bufer} no se llama con un argumento, el valor de
    @c{argumento} será @c{nil} y se evaluara la parte @c(else) de la expresión
    @c{if}. La parte @c(else) es un simple @c{point-min}, y cuando este es el
    resultado, toda la expresión @c{goto-char} es @c{(goto-char (point-min))},
    que es cómo vimos la función @c{beginning-of-buffer} en su forma
    simplificada.

*** @c{beginning-of-buffer} con un argumento

    Cuando se llama a @c{beginning-of-buffer} con un argumento, se evalua una
    expresión que calcula el valor a pasa a @c{goto-char}. A primera vista esta
    expresion es bastante compleja. Incluye una expresión @c{if} y mucha
    aritmética. Se ve así:

    @src elisp
      (if (> (buffer-size) 10000)
          ;; Evita el desbordamiento en buffers de gran tamaño!
                                (* (prefix-numeric-value arg)
                                   (/ size 10))
        (/
         (+ 10
            (*
             size (prefix-numeric-value arg))) 10)))
    @end src

    Como otras expresiones que paracen complejas, la expresión condicional
    dentro de @c{beginning-of-buffer} se puede desenredar viendola como partes
    de una plantilla, en este caso, la plantilla para una expresión
    if-then-else. En forma esquelética, la expresión se ve así:

    @src elisp
      (si (buffer-es-grande
          divide-el-tamaño-del-buffer-por-10-y-multiplicalo-por-arg
        de-otra-forma-utiliza-el-calculo-alternativo
    @end src

    La prueba verdadero-o-falso de la expresión @c{if} interna comprueba el
    tamaño del buffer. La razón de esto es que la vieja versión de Emacs 18
    utilizaba números no son más grandes que 8 millones mas o menos y el
    programador temía que Emacs pudiera intentar usar numeros demasiado largos
    si el búffer fuese extenso. El término ‘desbordamiento’, que se menciona en
    el comentario, significa que los números son mas grandes. Las versiones más
    recientes de Emacs utilizan números largos, pero este código no ha sido
    tocado, solo porque la gente ahora mira búffers que son mucho, mucho mas
    grandes de lo que nunca fueron.

    Hay dos casos: si el búffer es grande, o si no lo es.

**** Qué ocurre en un búffer de gran tamaño

     En @c{beginning-of-buffer}, la expresión @c{if} interna prueba si el tamaño
     del búffer es mayor a 10000 caracteres. Para hacer esto, se utiliza la
     función @c{>} y el calculo de @c{size} que viene desde la expresión let.

     En los viejos tiempos, se utilizo la función @c{buffer-size}. No solo se
     llamaba en repetidas ocaciones, se daba el tamaño completo del búffer, no
     la parte accesible. El calculo tiene mucho más sentido cuando se maneja
     solo la parte accesible. (Véase Sección @l{Reducir y Extender}, para
     más información concentra la atención en una parte ‘accesible’.)

     La linea se ve asi:

     @src elisp
       (if (> size 10000)
     @end src

     Cuando el búffer es grande, se evalua la parte @c(then) de la expresión
     @c{if}. Esto se lee así (después de darle un formato facil de leer):

     @src elisp
       (*
         (prefix-numeric-value arg)
         (/ size 10))
     @end src

     Esta expresión es una multiplicación, con dos argumentos para la función
     @c{*}.

     El primer argumento es @c{(prefix-numeric-value arg)}. Cuando se usa
     @c{"P"} como argumento para @c{interactive}, el valor dado a la función
     como argumento es un “argumento prefijo en bruto”, y no un número. (Es un
     número en una lista). Para realizar el calculo, se necesita una conversión,
     y @c{prefix-numeric-value} hace el trabajo.

     El segundo argumento es @c{(/ size 10)}. Esta expresión divide el valor
     numérico por diez––el valor numérico del tamaño de la porción accesible del
     búffer. Esto produce un número que indica cuántos caracteres constituyen
     una decena parte del tamaño del búffer. (En Lisp, @c{/} se utiliza para la
     división, igual que @c{*} se utiliza para la multiplicación.)

     En la expresión de multiplicación en su conjunto, esta cantidad se
     multiplica por el valor del argumento prefijo––la multiplicación es la
     siguiente:

     @src elisp
       (* valor-numerico-del-argumento-prefijo-arg
          numero-de-caracteres-en-una-decima-parte-de-la-porcion-accesible-del-buffer)
     @end src

     Por ejemplo, si el argumento prefijo es @'{7}, el valor de una decima parte
     será multiplicado por 7 para dar una posición al 70% del trayecto.

     El resultado de todo esto es que si la porción accesible del búffer es
     grande, la expresión @c{goto-char} es la siguiente:

     @src elisp
       (goto-char (* (prefix-numeric-value arg)
                     (/ size 10)))
     @end src

     Esto coloca el cursor donde lo queremos.

**** Qué ocurre en un búffer pequeño

     Si el búffer contiene menos de 10000 caracteres, se lleva a cabo un calculo
     ligeramente diferente. Podrías pensar que esto no es necesario, ya que el
     primer calculo podría hacer el trabajo. Sin embargo, en un búffer pequeño,
     el primer método puede no colocar el cursor exactamente en la línea
     deseada; el segundo método hace un mejor trabajo.

     El código tiene este aspecto:

     @src elisp
       (/ (+ 10 (* size (prefix-numeric-value arg))) 10))
     @end src

     Para averiguar que ocure en este código debemos descubrier como se anidan
     las funciones entre paréntesis. Es mas fácil de leer si se reformatea cada
     expresión, indentando la expresión que contiene:

     @src elisp
         (/
          (+ 10
             (*
              size
              (prefix-numeric-value arg)))
          10))
     @end src

     Observando los paréntesis, vemos que la operación mas profunda es
     @c{(prefix-numeric-value arg)}, que convierte el argumento prefijo en bruto
     a un número. En la siguiente expresión, este número se multiplica por el
     tamaño de la porción accesible del búffer:

     @src elisp
       (* size (prefix-numeric-value arg))
     @end src

     Esta multiplicación crea un número que puede ser mayor al tamaño del
     buffer––siete veces mayor si el argumento es 7, por ejemplo. Luego se suma
     diez a éste numero y finalmente el número es dividido por 10 para
     proporcionar un valor que es un carácter más grande que la posición de
     porcentaje en el búffer.

     El número que resulta de todo esto se pasa a @c{goto-char} y el cursor
     se mueve a este punto.

*** Funcion @c{beginning-of-buffer} Completa

    Aquí está el texto completo de la función @c{beginning-of-buffer}:

    @src elisp
      (defun beginning-of-buffer (&optional arg)
        "Move point to the beginning of the buffer;
      leave mark at previous position.
      With \\[universal-argument] prefix,
      do not set mark at previous position.
      With numeric arg N,
      put point N/10 of the way from the beginning.

      If the buffer is narrowed,
      this command uses the beginning and size
      of the accessible part of the buffer.

      Don't use this command in Lisp programs!
      \(goto-char (point-min)) is faster
      and avoids clobbering the mark."
        (interactive "P")
        (or (consp arg)
            (and transient-mark-mode mark-active)
            (push-mark))
        (let ((size (- (point-max) (point-min))))
          (goto-char (if (and arg (not (consp arg)))
                         (+ (point-min)
                            (if (> size 10000)
                                ;; Avoid overflow for large buffer sizes!
                                (* (prefix-numeric-value arg)
                                   (/ size 10))
                              (/ (+ 10 (* size (prefix-numeric-value arg)))
                                 10)))
                       (point-min))))
        (if arg (forward-line 1)))
    @end src

    Excepto por dos pequeños puntos, la discusión anterior muestra cómo funciona
    esta función. El primer punto se refiere a un detalle en la cadena de
    documentación, y el segundo concierne a la última línea de la función.

    En la cadena de documentación, se hace referencia a una expresión:

    @example
      \\[universal-argument]
    @end example

    Se usa Un @'{\\} antes del primer corchete de esta expresión. Este @'{\\} le
    indica al intérprete Lisp sustituir cualquier clave qué se encuentre dentro
    de @'{[…]} por su convinacion de teclado actual. En el caso de
    @c{universal-argument}, suele ser @k{C-u}, pero podría ser distinta. (Véase
    Sección @l{info:elisp#Documentation Tips<>Consejos para Cadenas de
    Documentación} en @e(El Manual de Referencia de GNU Emacs Lisp), para más
    información.)

    Finalmente, la última línea del comando @c{beginning-of-buffer} indica mover
    el punto al inicio de la siguiente línea si el comando se invoca con un
    argumento:

    @src elisp
      (if arg (forward-line 1)))
    @end src

    Esto pone el cursor al inicio de la primera línea a continuacion de la
    posicion inidicada en decenas en el búffer. Esto significa que el cursor
    siempre se localiza @e{al menos} las decenas solicitadas del recorrido del
    búffer, esta es una sutiliza, quizás, no necesaria, pero que, de no ocurri,
    seguro generaria quejas.

    Por otro lado, esto significa que si se especifica el comando con @k{C-u},
    sin un número, que es decir, si el ‘argumento prefijo en bruto’ simplemente
    es un cons cell, entonces el comando te coloca al inicio de la segunda línea
    … no sé si se pretende esto o si nadie ha tratado el código para evitar que
    esto suceda.

** @t(Repaso-2<>Repaso)

   Aquí esta un breve resumen de algunos de lo temas cubiertos en este capítulo.

   - or ::

     Evalúa cada argumento en secuencia, y devuelve el valor del primer
     argumento que no es @c{nil}, si ninguno devuelve un valor que no sea
     @c{nil}, devuelve @c{nil}. En resumen, devuelve el primer valor verdadero
     de los argumento; devuelve un valor verdadero si uno @e{o} cualquiera de
     los otros es verdadero.

   - and ::

     Evalúa cada argumento en secuencia, y si alguno es @c{nil}, devuelve
     @c{nil}; si ninguno es @c{nil}, devuelve el valor del último argumento. En
     resumen, devuelve un valor verdadero solo si todos los argumentos son
     verdaderos; devuelve un valor verdadero si uno @e{y} cada uno de los otros
     son verdadero.

   - &optional ::

     Una palabra clave utilizada para indicar que un argumento en una definición
     de función es opcional; esto significa que la función se puede evaluar sin
     el argumento, si se desea.

   - prefix-numeric-value ::

     Convierte el ‘argumento prefijo en bruto’ producido por @c{(interactive
     "P")} en un valor numérico.

   - forward-line ::

     Mueve el punto hacia delante al principio de la siguiente línea, o si el
     argumento es mayor a uno, hacia delante varias líneas. Si no se puede mover
     tan lejos hacia delante como se supone, @c{forward-line} va hacia adelante
     tan lejos como pueda y luego devuelve un recuento del número de líneas
     adicionales que no pudo moverse.

   - erase-buffer ::

     Elimina todo el contenido del búffer actual.

   - bufferp ::

     Devuelve @c{t} si su argumento es un búffer; de otro modo devuelve
     @c{nil}.

** Ejercicio de argumento @c{opcional}

   Escribe una función interactiva con un argumento opcional que pruebe si su
   argumento, un número, es mayor que o igual a, o de lo contrario, menor que el
   valor de @c{fill-column}, y te lo indique, en un mensaje. Sin embargo, si no
   pasas un argumento a la función, utiliza 56 como valor por defecto.

* Reducir y Extender

  La Reduccion es una funcionalidad de Emacs que hace posible que puedas
  focalizarte en una parte específica de un búffer, y trabajar sin el cambio
  accidental a otras partes. La reduccion normalmente se deshabilita puesto que
  puede confundir a los principiantes.

  Con la reduccion, el resto del búffer se hace invisible, como si no estuviera
  alli. Esto es una ventaja si, por ejemplo, se quiere reemplazar una palabra en
  una parte del búffer pero no en otra: limitas la parte que deseas y el
  reemplazo se lleva a cabo solo en esa sección, no en el resto del búffer. Las
  búsquedas solo funcionarán con la región reducida, no fuera de ella, de esta
  forma si estás reparando una parte de un documento, puedes mantener fuera la
  parte que no necesitas reparar solo reduciendo la region que deseas. (La tecla
  asociada a @c{narrow-to-region} es @k{C-x n n}.)

  Sin embargo, la reduccion hace invisible el resto del búffer, esto puede
  asustar a quien invoca inadvertidamente la reduccion y piensa que ha eliminado
  una parte de su fichero. Por otra parte, el comando @c{undo} (usualmente unido
  a @k{C-x u}) no apaga (ni debe hacerlo) la reduccion, por lo que las personas
  pueden llegar a desesperarse si no saben que pueden devolver el resto del
  buffer visible cor el comando @c{widen} que es @k{C-x n w}.)

  La Reduccion es igual de util para el intérprete Lisp como para un humano.
  Con frecuencia, una función Emacs Lisp está diseñada para trabajar solo en
  parte de un búffer; o por el contrario, una función Emacs Lisp necesita
  trabajar en todo un búffer que ha sido reducido. La función @c{what-line}, por
  ejemplo, ilimina la reduccion de un búffer, si este tiene alguna reduccion y
  al terminar su trabajo, restaura la reduccion. Por otro lado, la función
  @c{count-lines} utiliza la reduccion para restringirse a sí misma solo a la
  porción del búffer en la que se está interesado y luego restaura la situación
  anterior.

** La forma especial @c{save-restriction}

   En Emacs Lisp, se puede utilizar la forma especial @c{save-restriction} para
   realizar un seguimiento de cualquier reduccion en efecto. Cuando el
   intérprete Lisp se encuentra con @c{save-restriction}, se ejecuta el código
   en el cuerpo de la expresión @c{save-restriction}, y luego deshace cualquier
   cambio en la reduccion que el código proboco. Si, por ejemplo, el búffer es
   reducido y el código que sigue al comando @c{save-restriction} se deshace de
   la reduccion, @c{save-restriction} devuelve el búffer a su región reducida.
   En el comando @c{what-line}, cualquier reduccion del búffer es deshecha por
   el comando @c{widen} inmediatamente despues del comando @c{save-restriction}.
   Se restaura cualquier reduccion original justo antes de finalizar la función.

   La plantilla para una expresión @c{save-restriction} es simple:

   @src elisp
     (save-restriction
       cuerpo… )
   @end src

   El cuerpo de @c{save-restriction} es una o más expresiones que son evaluadas
   de forma secuencial por el intérprete Lisp.

   Finalmente, un punto a tener en cuenta: cuando se utiliza @c{save-excursion}
   y @c{save-restriction} a la vez, una detras de la otra, debes utilizar
   @c{save-excursion} primero. Si lo escribes en el orden inverso, es posible
   que no registre la reduccion en el búffer a la que emacs debe cambiar Emacs
   despues de llamar a @c{save-excursion}. Por la tanto, cuando escribas a la
   vez @c{save-excursion} y @c{save-restriction} debe ser así:

   @src elisp
     (save-excursion
       (save-restriction
         cuerpo…))
   @end src

   En otras circunstancias, cuando no se escriban a la vez, las formas
   especiales @c{save-excursion} y @c{save-restriction} deben escribirse en el
   orden adecuado para la función.

   Por ejemplo,

   @src elisp
     (save-restriction
       (widen)
       (save-excursion
       cuerpo…))
   @end src

** @c{what-line}

   El comando @c{what-line} informa el número de la línea en la que el cursor
   esta colocado. La función ilustra el uso de los comandos @c{save-restriction}
   y @c{save-excursion}. Aquí está el texto original de la función:

   @src elisp
     (defun what-line ()
       "Print the current line number (in the buffer) of point."
       (interactive)
       (save-restriction
         (widen)
         (save-excursion
           (beginning-of-line)
           (message "Line %d"
                    (1+ (count-lines 1 (point)))))))
   @end src

   (En versiones recientes de GNU Emacs, la función @c{what-line} se ha ampliado
   para informarte el numero de linea en un búffer reducido, asi como el número
   de línea en un búffer amplio. La versión reciente es más compleja que la
   versión que se muestra aqui. Si te sientes aventurero, puede que quieras
   verla despues de averiguar como funciona esta version. Probablemente
   necesites utilizar @k{C-h f} (@c{describe-function}). La nueva versión
   utiliza un condicional para determinar si se ha reducido el búffer.

   (También, utiliza @c{line-number-at-pos}, que entre otras expresiones
   simples, como @c{(goto-char (point-min))}, mueve el punto al inicio de la
   línea actual con @c{(forward-line 0)} en lugar de @c{beginning-of-line}.)

   La función @c{what-line} que se muestra aqui tiene una línea de documentación
   y es interactiva, como era de esperar. Las dos líneas siguientes utilizan las
   funciones @c{save-restriction} y @c{widen}.

   La forma especial @c{save-restriction} observa cualquier reduccion activa, en
   el buffer actual y restaura la reduccion despues de evaluar el código de su
   cuerpo.

   La forma especial @c{save-restriction} es seguida por @c{widen}. Esta función
   deshace cualquier reduccion que pudo haber tenido el búffer actual cuando se
   llama a @c{what-line}. (La reduccion que esta alli es la reduccion que
   @c{save-restriction} recuerda.) Esta ampliación hace posible que los comandos
   para el conteo de lineas cuenten desde el inicio del búffer. De lo contrario,
   se habría limitado a contar dentro de la región accesible. Cualquier
   reduccion original se restaura justo antes de completar la funcion por la
   forma especial @c{save-restriction}.

   La llamada a @c{widen} va seguida por @c{save-excursion}, que guarda la
   posición del cursor (es decir, el punto) y la marca, y los restaura después
   despues de que el código en el cuerpo de @c{save-excursion} utiliza la
   función @c{beginning-of-line} para mover el punto.

   (Ten en cuenta que la expresión @c{(widen)} ocurre entre las formas
   especiales @c{save-restriction} y @c{save-excursion}. Cuando escribas las dos
   expresiones @c{save-…} consecutivamente, escribe @c{save-excursion} primero.)

   Las dos últimas líneas de la función @c{what-line} son funciones para contar
   el número de líneas en el búffer y luego imprimirlo el número en el área
   echo.

   @src elisp
     (message "Line %d"
              (1+ (count-lines 1 (point)))))))
   @end src

   La función @c{message} imprime un mensaje de una línea en la parte inferior
   de la pantalla de Emacs. El primer argumento va dentro de marcas de cita y se
   imprime como una cadena de caracteres. Sin embargo, puede contener una
   expresión @'{%d} para imprimir el siguiente argumento. @'{%d} imprime el
   argumento como un decimal, por lo que el mensaje dirá algo como @'{Línea
   243}.

   El número que se imprime en lugar del @'{%d} se calcula por la última línea
   de la función:

   @src elisp
     (1+ (count-lines 1 (point)))
   @end src

   Lo que hace esto es contar las líneas desde la primer posición del búffer
   indicada por el @c{1}, hasta @c{(point)}, y luego sumar uno a este número.
   (La función @c{1+} suma uno a su argumento.) Se suma uno porque la línea 2
   tiene solo una línea antes de ella, y @c{count-lines} cuenta solo las líneas
   @e{antes} de la línea actual.

   Después que @c{count-lines} termina su trabajo, y se imprime el mensaje en el
   área echo, la función @c{save-excursion} restaura el punto y marca a sus
   posiciones originales; y @c{save-restriction} restaura la reduccion original,
   si la hay.

** Ejercicio de Reduccion

   Escribe una función que muestre los primeros 60 caracteres del búffer actual,
   incluso si has reducido el búffer despues mitad de modo que la primera línea
   es inaccesible. Restaura el punto, marca y la reduccion. Para este ejercicio,
   necesitas utilizar todo un popurri de funciones, incluyendo
   @c{save-restriction}, @c{widen}, @c{goto-char}, @c{point-min}, @c{message}, y
   @c{buffer-substring}.

   (@c{buffer-substring} es una función que no aun no se menciona, tendrás que
   investigarla por tu cuenta; o quizás tengas que utilizar
   @c{buffer-substring-no-properties} o @c{filter-buffer-substring} …, u otras
   funciones. Las propiedades de texto son una funcionalidad que no sera
   discutida aquí.  Véase Sección @l{info:elisp#Text Properties<>Propiedades de
   Texto} en @e(El Manual de Referencia de Emacs Lisp).)

   Además, ¿realmente se necesita @c{goto-char} o @c{point-min}?  ¿O se puede
   escribir la función sin ellas?

* @c{car}, @c{cdr}, @c{cons}: Funciones fundamentales

  En Lisp, @c{car}, @c{cdr}, y @c{cons} son funciones fundamentales. La
  función @c{cons} es usada para construir listas, y las funciones @c{car} y
  @c{cdr} son usadas para tomarlas aparte.

  En el paseo guiado a través de la función @c{copy-region-as-kill}, se verá
  @c{cons} tan bien como dos variantes de @c{cdr}, llamadas @c{setcdr} y
  @c{nthcdr}. (Véase Sección @l{copy-region-as-kill}.)

  El nombre de la función @c{cons} es razonable: es una abreviación de la
  palabra ‘constructo’. Los orígenes de los nombres @c{car} y @c{cdr}, por
  otro lado, son esotéricos: @c{car} es un acrónimo de la frase ‘Contenidos
  de la parte de la Dirección del Registro’; y @c{cdr} (pronunciado
  ‘could-er’) es un acrónimo de la frase ‘Contenidos del Decremento del
  Registro’. Estas frases se refieren a piezas específicas de hardware en el
  ordenador en el que el Lisp original fué desarrollado. El resto de frases
  han sido completamente irrelevantes por más de 25 años a cualquiera
  pensando acerca de Lisp. Ninguno, excepto unos pocos académicos valientes
  han empezado a usar nombres más razonables para estas funciones, los viejos
  términos están todavía en uso. En particular, los términos usados en el
  código fuente Emacs Lisp, que usaremos en esta introducción.

** @c{car} y @c{cdr}

   El @Cc{car} de una lista es, bastante simple, el primer ítem en la
   lista. De este modo, el @Cc{car} de la lista @c{(rosa violeta margarita
   tulipan)} es @c{rosa}.

   Si está leyendo en Info y en GNU Emacs, se puede ver esto evaluando lo
   siguiente:

   @example
     (car '(rosa violeta margarita tulipan))
   @end example

   Después de evaluar la expresión, @c{rosa} aparecerá en el área echo.

   Claramente, un nombre más razonable para la función @c{car} sería
   @c{first} y esto es con frecuencia lo que se sugiere.

   @c{car} no elimina el primer ítem de la lista; solo se informa de lo que
   hay. Después de que @c{car} se haya aplicado a una lista, la lista es
   todavía la misma que era. En la jerga, @c{car} es ‘no-destructiva’. Esta
   funcionalidad deja de ser importante.

   El @Cc{cdr} de una lista es el resto de la lista, que es, la función
   @c{cdr} que devuelve la parte de la lista que sigue el primer ítem. De
   este modo, mientras el @Cc{car} de la lista @c{'(rosa violeta margarita
   tulipan)} es @c{rosa}, el resto de la lista, el valor devuelto por la
   función @c{cdr}, es @c{(violeta margarita tulipan)}.

   Se puede ver esto evaluando lo siguiente del modo usual:

   @example
     (cdr '(rosa violeta margarita tulipan))
   @end example

   Cuando se evalúa esto, @c{(violeta margarita tulipan)} aparecerá en el
   área echo.

   Al igual que @c{car}, @c{cdr} no elimina los elementos desde la
   lista––solo devuelve un informe de lo que el segundo y subsiguientes
   elementos son.

   En el ejemplo, la lista de flores se cita. Si no, el intérprete Lisp
   intentaría evaluar la lista llamando a @c{rosa} como una función. En este
   ejemplo, no queremos hacer esto.

   Claramente, un nombre más razonable para @c{cdr} sería @c{rest}.

   (Hay una lección aquí: cuando se nombran nuevas funciones, considere muy
   cuidadosamente lo que se está haciendo, ya que puede estar pegadas con los
   nombres largos que se esperan. La razón es que este documento perpetúa
   estos nombres que el código fuente de Emacs Lisp usa, y si no los usaba,
   se estaría un duro rato leyendo el código; pero, por favor, se debe
   intentar evitar usar estos términos por uno mismo. Las personas que vengan
   después se lo agradecerán.

   Cuando @c{car} y @c{cdr} se aplica a una lista hecha de símbolos, tal como
   la lista @c{(pino roble abeto arce)}, el elemento de la lista devuelta por
   la función @c{car} es el símbolo @c{pino} sin cualquier paréntesis
   alrededor. @c{pino} es el primer elemento en la lista. Sin embargo, el
   @Cc{cdr} de la lista es una lista por sí misma, @c{(roble abeto arce)},
   como se puede ver evaluando las siguientes expresiones en el modo usual:


   @example
     (car '(pino roble abeto arce))

     (cdr '(pino roble abeto arce))
   @end example

   Por otro lado, en una lista de listas, el primer elemento es en sí mismo
   una lista. @c{char} devuelve este primer elemento como una lista. Por
   ejemplo, la siguiente lista contiene tres sublistas, una lista de
   carnívoros, una lista de herbívoros y una lista de mamíferos:

   @example
     (car '((leon tigre leopardo)
            (gacela antilope cebra)
            (ballena delfin foca)))
   @end example

   En este ejemplo, el primer elemento de @Cc{car} de la lista es la lista de
   carnívoros, @c{(leon tigre leopardo)}, y el resto de la lista es
   @c{((gacela antilope cebra) (ballena delfin foca))}.

   @example
     (cdr '((leon tigre leopardo)
            (gacela antilope cebra)
            (ballena delfin)))
   @end example

   Es un valor decir de nuevo que @c{car} y @c{cdr} son no destructivos––esto
   es, no se modifican o cambian listas para las que ser aplicados. Esto es
   muy importante por cómo son usados.

   También, en el primer capítulo, en la discusión acerca de átomos, yo dije
   que en Lisp, “ciertos tipos de átomos, tales como un array, pueden
   separarse en partes; pero el mecanismo de hacer esto es diferente del
   mecanismo de separar una lista. Desde que Lisp se conoce, los átomos de
   una lista son indivisibles.”  (Véase Sección @l{Átomos Lisp}.) El @c{car}
   y el @c{cdr} son funciones que son usadas para dividir listas y son
   consideradas fundamentales para Lisp. Puesto que no pueden dividir o ganar
   acceso a las partes de un array, un array es considerado un átomo. De otro
   modo, la otra función fundamental, @c{cons}, se puede poner cerca o
   construir una lista, pero no un array. (Los arrays son manejados por
   funciones de array específicas. Véase Sección @l{Arrays, , Arrays, elisp,
   El Manual de Referencia de GNU Emacs Lisp}.)

** @c{cons}

   La función @c{cons} construye listas; eso es lo inverso de @c{car} y
   @c{cdr}. Por ejemplo, @c{cons} puede usarse para crear una lista de cuatro
   elementos desde los tres elementos de la lista, @c{(abeto roble arce)}:

   @example
     (cons 'pino '(abeto roble arce))
   @end example

   Después de evaluar esto, se verá lo siguiente:

   @example
     (pino abeto roble arce)
   @end example

   aparece en el área echo. @c{cons} causa la creación de una nueva lista en
   el que el elemento es seguido por los elementos de la lista original.

   Con frecuencia decimos que ‘@c{cons} pone un nuevo elemento al principio
   de una lista; adjunta o empuja el elemento dentro de la lista’, pero esta
   frase puede ser incorrecta, puesto que @c{cons} no cambia a una lista
   existente, pero crea una nueva.

   Como @c{car} y @c{cdr}, @c{cons} es no destructivo.

   @c{cons} debe tener una lista para adjuntar a@n{9} No se puede empezar
   desde absolutamente nada. Si se está construyendo una lista, se necesita
   proveer al menos una lista vacía al principio. Aquí hay una serie de
   expresiones @c{cons} que construyen una lista de flores. Si está leyendo
   esto en Info en GNU Emacs, se puede evaluar cada una de las expresiones en
   el camino usual; el valor es impreso en este texto después de @'{⇒}, que
   puede leer como ‘evalúas para’.

   @example
     (cons 'tulipan ())
          ⇒ (tulipan)

     (cons 'margarita '(tulipan))
          ⇒ (margarita tulipan)

     (cons 'violeta '(margarita tulipan))
          ⇒ (violeta margarita tulipan)

     (cons 'rosa '(violeta margarita tulipan))
          ⇒ (rosa violeta margarita tulipan)
   @end example

   En el primer ejemplo, la lista vacía se muestra como @c{()} y después se
   construye una lista de @c{tulipan} seguida por la lista vacía. Como se
   puede ver, la lista vacía no se muestra en la lista que fué
   construida. Todo lo que se ve es @c{(tulipan)}. La lista vacía no
   cuenta como un elemento de una lista porque no hay nada en una lista
   vacía. Generalmente hablando, una lista vacía es invisible.

   El segundo ejemplo, @c{(cons 'margarita '(tulipan))} construye una
   nueva lista de dos elemento poniendo @c{margarita} en frente de
   @c{tulipan}; y el tercer ejemplo construye una lista de tres elementos
   poniendo @c{violeta} en frente de @c{margarita} y @c{tulipan}.

*** Encuentra el tamaño de una lista: @c{length}

    Se pueden encontrar cuántos elementos hay en una lista usando la función
    Lisp @c{length}, como en los siguientes ejemplos:

    @example
      (length '(tulipan))
           ⇒ 1

      (length '(margarita tulipan))
           ⇒ 2

      (length (cons 'violeta '(margarita tulipan)))
           ⇒ 3
    @end example

    En el tercer ejemplo, la función @c{cons} es usada para construir una
    lista de tres elementos que entonces se pasa a la función @c{length} como
    su argumento.

    Se puede también usar @c{length} para contar el número de elementos en
    una lista vacía:

    @example
      (length ())
           ⇒ 0
    @end example

    Como se esperaría, el número de elementos en una lista vacía es cero.

    Un experimento interesante es encontrar qué ocurre si se intenta
    encontrar el tamaño de una no lista en todo; que es, si se intenta llamar
    a @c{length} sin darle un argumento, incluso una lista no vacía:

    @example
      (length )
    @end example

    Lo que se ve, si se evalúa esto, es el mensaje de error

    @example
      Lisp error: (wrong-number-of-arguments length 0)
    @end example

    Esto significa que la función recibe el número incorrecto de argumentos,
    cero, cuando se espera algún otro número de argumentos. En este caso, se
    espera un argumento, el argumento de una lista cuyo tamaño de la función
    se está midiendo. (Nótese que @e{una} lista es @e{un} argumento, incluso
    si la lista tiene muchos elementos dentro.)

    La parte del mensaje de error que dice @'{length} es el nombre de la
    función.

    @ignore
      @c{length} is still a subroutine, but you need C-h f to discover that.

      In an earlier version:
          This is written with a special notation, @'{#<subr},
          that indicates that the function @c{length} is one of the primitive
          functions written in C rather than in Emacs Lisp.  (@'{subr} is an
          abbreviation for ‘subroutine’.)  Véase Sección @l{What Is a Function, , What Is a
          Function?, elisp , The GNU Emacs Lisp Reference Manual}, for more
          about subroutines.
    @end ignore

** @c{nthcdr}

   La función @c{nthcdr} está asociada con la función @c{cdr}. Que lo que
   hace es tomar la @Cc{cdr} de una lista repetidamente.

   Si se toma el @Cc{cdr} de la lista @c{(pino roble abeto arce)}, será
   devuelta la lista @c{(roble abeto arce)}. Si se repite esto en lo que se
   devolvió, se devolverá lista lista @c{(abeto arce)}. (De acuerdo, se
   repite @Cc{cdr} en la lista original solo se dará @Cc{cdr} desde la
   función que no cambia la lista. Se necesita evaluar el @Cc{cdr} del
   @Cc{cdr} y así.) Si se contiúa esto, finalmente será devuelta una lista
   vacía, que en este caso, en vez de ser mostrada como @c{()} es mostrado
   como @c{nil}.

   Para revisar, aquí hay una serie de @Cc{cdr}s repetidos, el siguiente
   @'{⇒} muestra lo que se devuelve.

   @example
     (cdr '(pino roble abeto arce))
          ⇒(roble abeto arce)

     (cdr '(roble abeto arce))
          ⇒ (abeto arce)

     (cdr '(abeto arce))
          ⇒(arce)

     (cdr '(arce))
          ⇒ nil

     (cdr 'nil)
          ⇒ nil

     (cdr ())
          ⇒ nil
   @end example

   También se pueden hacer varios @Cc{cdr}s sin imprimir los valores así:

   @example
     (cdr (cdr '(pino roble abeto arce)))
          ⇒ (abeto arce)
   @end example

   En este ejemplo, el intérprete Lisp evalúa la lista propia dentro. La
   lista de dentro está entre comillas, así solo pasa la lista del @c{cdr}
   más interno. Este @c{cdr} pasa una lista hecho del segundo y subsiguientes
   elementos de la lista al @c{cdr} más externo, que produce una lista
   compuesta del tercer y subsiguientes elementos de la lista original. En
   este ejemplo, la función @c{cdr} se repite y devuelve una lista que
   consiste de la lista original sin sus primeros dos elementos.

   La función @c{nthcdr} hace lo mismo que repitiendo la llamada a
   @c{cdr}. En el siguiente ejemplo, el segundo argumento se pasa a la
   función @c{nthcdr}, a través con la lista, y el valor devuelto es la lista
   sin sus primeros dos ítems, que son exactamente los mismos dos @c{cdr} en
   la lista:

   @example
     (nthcdr 2 '(pino roble abeto arce))
          ⇒ (abeto arce)
   @end example

   Usando la lista original de cuatro elementos, se puede ver qué ocurre
   cuando varios argumentos numéricos son pasados a @c{nthcdr}, incluyendo 0,
   1, y 5:

   @example
     ;; @e{Deja la lista como estaba.}
     (nthcdr 0 '(pine fir oak maple))
          ⇒ (pino roble abeto arce)

     ;; @e{Devuelve una copia sin el primer elemento.}
     (nthcdr 1 '(pine fir oak maple))
          ⇒ (fir oak maple)

     ;; @e{Devuelve una copia de la lista sin tres elementos.}
     (nthcdr 3 '(pine fir oak maple))
          ⇒ (maple)

     ;; @e{Devuelve la lista faltando los cuatro elementos.}
     (nthcdr 4 '(pine fir oak maple))
          ⇒ nil

     ;; @e{Devuelve una copia sin los elementos.}
     (nthcdr 5 '(pine fir oak maple))
          ⇒ nil
   @end example

** @c{nth}

   La función @c{nthcdr} toma el @Cc{cdr} de una lista repetidamente. La
   función @c{nth} toma el @Cc{car} del resultado devuelto por
   @c{nthcdr}. Devuelve el elemento Nth de la lista.

   De este modo, si no fuera definido en C para velocidad, la definición de
   @c{nth} sería:

   @example
     (defun nth (n list)
       "Devuelve el elemento Nth de Lista.
     N cuenta desde cero. Si Lista no es larga, nil es devuelto".
       (car (nthcdr n list)))
   @end example

   (Originalmente, @c{nth} fué definido en Emacs Lisp en @f{subr.el}, pero su
   definición fué rehecha en C en los 1980s.)

   La función @c{nth} devuelve un elemento simple de una lista. Esto puede
   ser muy conveniente.

   Nótese que los elementos son numerados desde cero, no desde uno. Es decir,
   el primer elemento de una lista, su @Cc{car} es el elemento cero. Esto se
   llama contar en ‘base cero’ y con frecuencia las personas tienen la
   costumbre del que el primer elemento en una lista sea el número uno, eso
   es ‘basado en uno’.

   Por ejemplo:

   @example
     (nth 0 '("uno" "dos" "tres"))
         ⇒ "uno"

     (nth 1 '("uno" "dos" "tres"))
         ⇒ "dos"
   @end example

   Es valorable mencionar que @c{nth}, como @c{nthcdr} y @c{cdr}, no cambia
   la lista original––la función no es destructiva. En contraste con las
   funciones @c{setcar} y @c{setcdr}.

** @c{setcar}

   Como se podría adivinar desde sus nombres, las funciones @c{setcar} y
   @c{setcdr} asignan el @Cc{car} o la @Cc{cdr} de una lista a un nuevo
   valor. Ellos actualmente cambia la lista original, no como @c{car} y
   @c{cdr} que deja la lista original como estaba. Un camino para encontrar
   cómo esto funciona es experimentar. Se comenzará con la función
   @c{setcar}.

   Primero, podemos crear una lista y entonces asignar el valor de una
   variable a la lista usando la función @c{setq}. Aquí hay una lista de
   animales:

   @example
     (setq animales '(antilope jirafa leon tigre))
   @end example

   Si está leyendo esto en Info dentro de GNU Emacs, se puede evaluar esta
   expresión del modo usual, posicionando el cursor después de la expresión y
   escribiendo @k{C-x C-e}. Esto es una de las ventajas de tener el
   intérprete construido dentro del entorno de computación. Incidentalmente,
   cuando no hay nada en la línea después del paréntesis final, tal como un
   comentario, el punto puede estar en la siguiente línea. De este modo, si
   tu cursor está en la primera columna de la siguiente línea, no se necesita
   mover. En realidad, Emacs permite cualquier cantidad de espacio en blanco
   después del paréntesis final.)

   Cuando se evalúa la variable @c{animal}, vemos que está asociada a la
   lista @c{(antelope giraffer lion tiger)}:

   @example
     animales
          ⇒ (antilope jirafa leon tigre)
   @end example

   Por otro lado, la variable @c{animales} apunta a la lista @c{(antilope
   jirafa leon tigre)}.

   Lo siguiente, es evaluar la función @c{setcar} mientras le pasa dos
   argumentos, la variable @c{animales} y el símbolo citado @c{hipopotamo};
   esto se hace escribiendo la lista de tres elementos @c{(setcar animales
   'hipopotamo)} y entonces evaluando en el modo usual:

   @example
     (setcar animales 'hipopotamo)
   @end example

   Después de evaluar esta expresión, evalúa la variable @c{animales} de
   nuevo. Se puede ver que la lista de animales ha cambiado:

   @example
     animales
          ⇒ (hipopótamo jirafa leon tigre)
   @end example

   El primer elemento en la lista, @c{antilope} se reemplaza por
   @c{hipopotamo}.

   Así se puede ver que @c{setcar} no añadió un nuevo elemento a la lista
   como @c{cons} tendría; eso reemplazó @c{antílope} con @c{hipopótamo}; eso
   @e{cambió} la lista.

** @c{setcdr}

   La función @c{setcdr} es similar a la función @c{setcar}, excepto que la
   función reemplaza el segundo y subsiguientes elementos de una lista en vez
   del primer elemento.

   (Para ver cómo se cambia el último elemento de una lista, mira hacia
   delante a la @l{La función @c{kill-new}}, que usa las funciones @c{nthcdr}
   y @c{setcdr}.)

   Para ver cómo esto funciona, asigna el valor de la variable a una lista de
   animales domesticados evaluando la siguiente expresión:

   @example
     (setq animales-domesticos '(caballo vaca oveja cabra))
   @end example

   Si ahora se evalúa la lista, lo que se devuelve es @c{(caballo vaca oveja
   cabra)}:

   @example
     animales-domesticos
          ⇒ (caballo vaca oveja cabra)
   @end example

   Lo siguiente, evalúa @c{setcdr} con dos argumentos, el nombre de la
   variable que tiene una lista como su valor, y la lista para la que el
   @Cc{cdr} de la primera lista sea asignada;

   @example
     (setcdr animales-domesticos '(gato perro))
   @end example

   Si se evalúa esta expresión, la lista @c{(gato perro)} aparecerá en el
   área echo. Este es el valor devuelto por la función. El resultado en el
   que estamos interesados es el “efecto secundario”, que se puede ver evaluando
   la variable @c{domesticated-animals}:

   @example
     animales-domesticos
          ⇒ (caballo gato perro)
   @end example

   En realidad, la lista es cambiada desde @c{(caballo vaca oveja cabra)} a
   @c{(caballo gato perro)}. El @Cc{cdr} de la lista es cambiada desde
   @c{(vaca oveja cabra)} a @c{(gato perro)}.

** Ejercicio

   Construye una lista de cuatro pájaros evaluando varias expresiones con
   @c{cons}. Encuentra que ocurre cuando @c{cons} una lista dentro de
   sí. Reemplaza el primer elemento de la lista de cuatro pájaros con un
   pez. Reemplaza el resto de esta lista con una lista de otro pez.

* Cortando y almacenando texto

  Siempre y cuando se corte o pegue texto de un búffer con un comando ‘kill’
  en GNU Emacs, se almacenará dentro de una lista que se puede traer con un
  comando ‘yank’.

  (El uso de la palabra ‘kill’ @e{matar, cortar} en Emacs para procesos que
  específicamente @e{no} destruyen los valores de las entidades es un
  accidente histórico desafortunado. Una palabra mucho más apropiada debería
  ser ‘clip’ @e{cortar} puesto que es lo que los comandos de corte hacen;
  ellos cortan texto fuera de un búffer y lo ponen dentro del almacenamiento
  desde el que puede traerse. Con frecuencia ha sido tentada de reemplazar
  globalmente todas las ocurrencia de ‘kill’ @e{matar, cortar} en las fuentes
  de Emacs con ‘clip’ @e{cortar} y todas las ocurrencias de ‘killed’
  @e{cortado, muerto} con ‘clipped’ @e{cortado}.)

  Cuando el texto se corta de un búffer, es almacenado en una lista. Piezas
  sucesivas de texto se almacenan en la lista sucesivamente, así la lista
  podría verse así:

  @example
    ("una pieza de texto" "pieza previa")
  @end example

  La función @c{cons} puede usarse para crear una nueva lista desde una pieza
  de texto (un ‘átomo’, para usar la jerga) y una lista existente, como esta:

  @example
    (cons "otra pieza"
          '("una pieza de texto" "pieza previa"))
  @end example

  Si se evalúa esta expresión, una lista de tres elementos aparecerá en el
  área echo:

  @example
    ("otra pieza" "una pieza de texto" "pieza previa")
  @end example

  Con las funciones @c{car} y @c{nthcdr}, se puede recuperar siempre la pieza
  de texto que se quiere. Por ejemplo, en el siguiente código, @c{nthcdr 1 …}
  devuelve la lista con el primer ítem eliminado; y el @c{car} devuelve el
  primer elemento de este resto––el segundo elemento de la lista original:

  @example
    (car (nthcdr 1 '("otra pieza"
                     "una pieza de texto"
                     "pieza previa")))
         ⇒ "una pieza de texto"
  @end example

  Las funciones actuales en Emacs son más complejas que esto, de acuerdo. El
  código para cortar y recuperar texto tiene que ser escrito de modo que
  Emacs pueda ver qué elemento en la lista se quiere––el primer, segundo,
  tercer o cualquier otro. Además, cuando tiene el fin de la lista, Emacs
  daría el primer elemento de la lista, en lugar de nada.

  La lista que maneja las piezas de texto se llama @:{kill ring} (anillo de
  la muerte). Este capítulo lidera una descripción del anillo de la muerte y
  como eso se usa por la primera traza de cómo la función @c{zap-to-char}
  funciona. Esta función usa (o ‘llama’) a una función que invoca a otra
  función que manipula el anillo de la muerte. De este modo, antes de lograr
  las montañas, se escalan las colinas.

  Un capítulo subsiguiente describe cómo el texto que se corta desde el
  búffer se recupera. Véase Sección @l{Pegando, , Pegando Texto}.

** @c{zap-to-char}

   La función @c{zap-to-char} cambió poco entre GNU Emacs versión 19 y GNU
   Emacs versión 22. Sin embargo, @c{zap-to-char} llama a otra función,
   @c{kill-region}, que se reescribió más.

   La función @c{kill-region} en Emacs 19 es compleja, pero no usa código que
   es importante en este momento. Se obviará.

   La función @c{kill-region} en Emacs 22 es más de fácil leer que la misma
   función en Emacs 19 e introduce un concepto muy importante, que el error
   maneja. Nosotros pasearemos a través de la función.

   Pero primero, déjanos ver en la función interactive @c{zap-to-char}.

   La función @c{zap-to-char} elimina el texto en la región entre la
   localización del curso (por ej. punto) para incluir la siguiente
   ocurrencia de un caracter específico. El texto que @c{zap-to-char} borra
   es puesto en el kill ring @e{anillo de la muerte}; y puede ser recuperado
   desde el kill ring @e{anillo de la muerte} escribiendo @k{C-y}
   (@c{yank}). Si el comando dado es un argumento, eso borra texto a través
   de este número de ocurrencias. De este modo, si el cursor estuviera al
   principio de esta frase y el carácter fuera @'{s}, @'{De este modo} sería
   borrado. Si el argumento fueran dos, @'{De este modo, si el cursor} se
   borrase, y incluiría la @'{s} en el @'{cursor}.

   Si el carácter específico no encuentra @c{zap-to-char} dirá “Búsqueda
   fallida”, eso cuenta el carácter que se escribió, y no eliminó cualquier
   texto.

   En orden para determinar cuánto texto eliminar @c{zap-to-char} usa una
   función de búsqueda. Las búsquedas son usadas extensivamente en el código
   que manipula texto, y focalizará la atención en ellos tan bien como el
   comando de borrado.

   @ignore
     @c GNU Emacs version 19
     (defun zap-to-char (arg char)  ; version 19 implementation
       "Kill up to and including ARG'th occurrence of CHAR.
     Goes backward if ARG is negative; error if CHAR not found."
       (interactive "*p\ncZap to char: ")
       (kill-region (point)
                    (progn
                      (search-forward
                       (char-to-string char) nil nil arg)
                      (point))))
   @end ignore

   Aquí está el texto completo de la versión 22 de la función:

   @example
     (defun zap-to-char (arg char)
       "Corta e incluye ARG'th ocurrencia de CHAR
     En caso de ser ignorada si `case-fold-search' es no nulo en el
       búffer actual.
     Para ir atrás si ARG es negativo; error si CHAR no se encuentra."
       (interactive "p\ncZap to char: ")
       (if (char-table-p translation-table-for-input)
           (setq char (or (aref translation-table-for-input char) char)))
       (kill-region (point) (progn
                              (search-forward (char-to-string char)
                                              nil nil arg)
                              (point))))
   @end example

   La documentación es en línea. Se necesita conocer el significado de la
   jerga de la palabra ‘kill’.

*** La expresión @c{interactive}

    La expresión interactiva en el comando @c{zap-to-char} se ve así:

    @example
      (interactive "p\ncZap to char: ")
    @end example

    La parte con comillas, @c{"p\ncZap to char:@: "} @e{Cortar a caracter},
    especifica dos cosas diferentes. Primero, y más simple es el @'{p}. Este
    parte se separa desde la siguiente parte por una nueva línea, @'{\n}. El
    @'{p} significa que la parte del primero argumento a la función será
    pasando el valor de un ‘prefijo procesado’. El argumento prefijo es
    pasado escribiendo @k{C-u} y un número, o @k{M-} y un número. Si la
    función es llamada interactivamente sin un prefijo, el número que se pasa
    es 1.

    La segunda parte de @c{"p\ncZap a caracter:@: "} es @'{cZap a
    carácter:@:}. En esta parte, la tecla baja @'{c} indica que
    @c{interactive} espera una consola que el argumento será un caracter. La
    consola sigue el @'{c} y es la cadena @'{Zap a caracter:@: } (con un
    espacio después del punto y coma para hacerlo bien).

    Todo lo que se hace es preparar los argumentos para @c{zap-to-char} así
    están en el tipo correcto, y dan al usuario un prompt.

    En un búffer de solo lectura, la función @c{zap-to-char} copia el texto
    al anillo de la muerte, no se elimina. El área echo muestra un mensaje
    diciendo que el búffer es de solo lectura. También, la terminal avisa con
    un pitido.

*** El cuerpo de @c{zap-to-char}

    El cuerpo de la función @c{zap-to-char} contiene el código que mata (que
    se borra/corta) el texto en la región desde la posición actual del cursor
    e incluyendo el carácter especificado.

    La primera parte del código se ve como:

    @example
      (if (char-table-p translation-table-for-input)
          (setq char (or (aref translation-table-for-input char) char)))
      (kill-region (point) (progn
                             (search-forward (char-to-string char) nil nil arg)
                             (point)))
    @end example

    @c{char-table-p} es una función prescrita no vista. Eso determina si sus
    argumentos son una tabla de caracteres. Así, se asigna el carácter pasado
    a @c{zap-to-char} a uno de ellos, si este carácter existe, o al carácter
    en sí. (Esto llega a ser importante para ciertos caracteres en lenguajes
    no Europeos. La función @c{aref} extrae un elemento desde un array. Eso
    es una función específica de array que no está descrita en este
    documento. Véase Sección @l{Array, , Arrays, elisp, El Manual de
    Referencia de GNU Emacs Lisp}.)

    Lo que devuelve @c{(point)} es la posición actual del cursor.

    La siguiente parte del código es una expresión usando @c{progn}. El
    cuerpo del @c{progn} se basa en llamadas a @c{search-forward} y
    @c{point}.

    Es fácil comprender cómo @c{progn} funciona después de aprender acerca de
    @c{search-forward}, así se verá en @c{search-forward} y entonces en
    @c{progn}.

*** La función @c{search-forward}

    La función @c{search-forward} se usa para localizar el
    zapped-for-character en @c{zap-to-char}. Si la búsqueda es exitosa,
    @c{search-forward} deja el punto inmediatamente después del último
    carácter en la cadena objetivo. (En @c{zap-to-char}, la cadena objetivo
    es solo un carácter largo. @c{zap-to-char} usa la función
    @c{char-to-string} para asegurar que el ordenador trata este carácter
    como una cadena). Si la búsqueda es hacia atrás, @c{search-forward} deja
    el punto solo antes del primer carácter en el objetivo. También,
    @c{search-forward} devuelve @c{t} para verdad. (Moviendo el punto allí es
    un ‘efecto secundario’.)

    En @c{zap-to-char}, la función @c{search-forward} se ve así:

    @example
      (search-forward (char-to-string char) nil nil arg)
    @end example

    La función @c{search-forward} toma cuatro argumentos:

    1. El primer argumento es el objetivo, para el que es buscado. Esto debe
       ser una cadena, tal como @'{"z"}.

       Cuando eso ocurre, el argumento pasado a @c{zap-to-char} es un
       caracter simple. Debido a la forma en la que los ordenadores son
       construidos, el intérprete Lisp puede tratar un caracter simple siendo
       diferente desde una cadena de caracteres. Dentro del ordenador, un
       caracter simple tiene un formato electrónico en vez de una cadena de
       un caracter. (Un caracter simple puede con frecuencia ser grabado en
       el ordenador usando exactamente un byte; pero una cadena puede ser
       larga, y el ordenador necesita estar listo para esto.) Desde que la
       función @c{search-forward} busca una cadena, el caracter que la
       función @c{zap-to-char} recibe como argumento debe ser convertida
       dentro del ordenador de un formato a otro; de otro modo, la función
       @c{search-forward} fallará. La función @c{char-to-string} es usada
       para hacer esta conversión.

    2. El segundo argumento asocia la búsqueda; eso se especifica como una
       posición en el búffer. En este caso, la búsqueda puede ir al final del
       búffer, así no se asigna y el segundo argumento es @c{nil}.

    3. El tercer argumento cuenta la función que haría si la búsqueda
       cae––eso puede señalar un error (e imprimir un mensaje) o puede
       devolver @c{nil}. Un @c{nil} como tercer argumento hace que la función
       señale un error cuando la búsqueda falla.


    4. El cuarto argumento @c{search-forward} es el contaje repetido ---
       cuántas ocurrencias de la cadena para buscar. Este argumento es
       opcional y si la función es llamada sin un contaje repetido, este
       argumento pasa el valor 1. Si este argumento es negativo, la búsqueda
       va hacia atrás.


    En la forma de plantilla, una expresión @c{search-forward} se ve así:

    @example
      (search-forward "@V{cadena-a-buscar}"
                      @V{limite-de-busqueda}
                      @V{que-hacer-si-la-busqueda-falla}
                      @V{repetir-contaje})
    @end example

    Lo siguiente es echar un vistazo a @c{progn}.

*** La forma especial @c{progn}

    @c{progn} es una forma especial que causa que cada uno de sus argumentos
    puedan ser evaluados en secuencia y entonces devuelve el valor del
    último. Las expresiones precedentes son evaluadas solo por los efectos
    laterales que ellos desarrollan. Los valores producidos por ellos son
    descartados.

    La plantilla para una expresión @c{progn} es muy simple:

    @example
      (progn
        @V{body}…)
    @end example

    En @c{zap-to-char}, la expresión @c{progn} tiene que hacer dos cosas:
    poner el punto en la posición exacta; y devolver la posición del punto de
    modo que @c{kill-region} conoce cómo de lejos se copia.

    El primer argumento de @c{progn} es @c{search-forward}. Cuando
    @c{search-forward} encuentra la cadena, la función deja el punto
    inmediatamente después del último caracter en la cadena objetivo. (En
    este caso la cadena objetivo es solo un carácter largo.) Si la búsqueda
    es hacia atrás, @c{search-forward} deja el punto justo antes del primer
    carácter en el objetivo. El movimiento del punto es un efecto secundario.

    El segundo y último argumento de @c{progn} es la expresión
    @c{(point)}. Esta expresión devuelve el valor del punto, que en este caso
    será la localización para la que se ha movido por @c{search-forward}. (En
    la fuente, una línea que cuenta la función para ir al carácter previo, si
    se está yendo hacia delante, se comentó en 1999; yo no recuerdo si esta
    funcionalidad o no funcionalidad era siempre parte de las fuentes
    distribuidas.) El valor de @c{point} se devuelve por la expresión
    @c{progn} y se pasa a @c{kill-region} como el segundo argumento de
    @c{kill-region} .

*** Resumiendo @c{zap-to-char}

    Ahora que se ha visto cómo @c{search-forward} y @c{progn} trabajan, se
    puede ver cómo la función @c{zap-to-char} funciona como un todo.

    El primer argumento de @c{kill-region} es la posición del cursor cuando
    el comando @c{zap-to-char} da––el valor del punto en este momento. Con el
    @c{progn}, la búsqueda de la función mueve el punto a solo después del
    zapped-to-character y @c{point} devuelve el valor de localización. La
    función @c{kill-region} pone junto a estos dos valores de punto, el
    primero como el principio de la región y el segundo como el fin de la
    región, y borra la región.

    La forma especial @c{progn} se necesita porque el comando @c{kill-region}
    toma dos argumentos; y fallaría si @c{search-forward} y expresiones
    @c{point} fueran escritas en secuencia como dos argumentos
    adicionales. La expresión @c{progn} es un argumento simple para
    @c{kill-region} y devuelve un valor para que @c{kill-region} se necesite
    por su segundo argumento.

** @c{kill-region}

   La función @c{zap-to-char} usa la función @c{kill-region}. Esta función
   corta texto desde una región y copia este texto al kill ring @e{anillo de
   la muerte}, desde el que puede ser recuperado.

   @ignore
     GNU Emacs 22:

     (defun kill-region (beg end &optional yank-handler)
       "Kill (\"cut\") text between point and mark.
     This deletes the text from the buffer and saves it in the kill ring.
     The command \\[yank] can retrieve it from there.
     \(If you want to kill and then yank immediately, use \\[kill-ring-save].)

     If you want to append the killed region to the last killed text,
     use \\[append-next-kill] before \\[kill-region].

     If the buffer is read-only, Emacs will beep and refrain from deleting
     the text, but put the text in the kill ring anyway.  This means that
     you can use the killing commands to copy text from a read-only buffer.

     This is the primitive for programs to kill text (as opposed to deleting it).
     Supply two arguments, character positions indicating the stretch of text
      to be killed.
     Any command that calls this function is a \"kill command\".
     If the previous command was also a kill command,
     the text killed this time appends to the text killed last time
     to make one entry in the kill ring.

     In Lisp code, optional third arg YANK-HANDLER, if non-nil,
     specifies the yank-handler text property to be set on the killed
     text.  See ‘insert-for-yank’."
       ;; Pass point first, then mark, because the order matters
       ;; when calling kill-append.
       (interactive (list (point) (mark)))
       (unless (and beg end)
         (error "The mark is not set now, so there is no region"))
       (condition-case nil
           (let ((string (filter-buffer-substring beg end t)))
             (when string                        ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)
         ((buffer-read-only text-read-only)
          ;; The code above failed because the buffer, or some of the characters
          ;; in the region, are read-only.
          ;; We should beep, in case the user just isn't aware of this.
          ;; However, there's no harm in putting
          ;; the region's text in the kill ring, anyway.
          (copy-region-as-kill beg end)
          ;; Set this-command now, so it will be set even if we get an error.
          (setq this-command 'kill-region)
          ;; This should barf, if appropriate, and give us the correct error.
          (if kill-read-only-ok
              (progn (message "Read only text copied to kill ring") nil)
            ;; Signal an error if the buffer is read-only.
            (barf-if-buffer-read-only)
            ;; If the buffer isn't read-only, the text is.
            (signal 'text-read-only (list (current-buffer)))))))
   @end ignore

   Tanto la versión de Emacs 22 de esta función usa @c{condition-case} y
   @c{copy-region-as-kill}, ambas se explicarán. @c{condition-case} es una
   forma especial importante.

   En esencia, la función @c{kill-region} llama a @c{condition-case}, que
   toma tres argumentos. En esta función, el primer argumento no hace
   nada. El segundo argumento contiene el código hace el trabajo cuando todo
   va bien. El tercer argumento contiene el código que se llama en el evento
   de un error.

   Ahora se puede volver a través del código @c{condition-case} en un
   momento. Primero, se echa un vistazo a la definición de @c{kill-region},
   con comentarios añadidos:

   @example
     (defun kill-region (beg end)
       "Kill (\"corta\") texto entre punto y marca.
     Esto borra el texto desde el búffer y lo guarda en anillo de la
       muerte @e{kill ring}.
     El comando \\[yank] puede recuperarse desde allí. …
      "

       ;; • Desde materias de orden, pasa el punto primero.
       (interactive (list (point) (mark)))
       ;; • Y cuéntanos si no podemos cortar el texto.
       ;; `a menos que' sea un `if' sin una then-part.
       (unless (and beg end)
         (error "La marca no está asignada ahora, así que
       no hay región"))

       ;; • `condition-case' toma tres argumentos
       ;;    Si el primer argumento es nulo, como aquí
       ;;    la información acerca del error no está
       ;;    almacenada para ser usada por otra función
       (condition-case nil

           ;; • El segundo argumento a `condition-case' cuenta lo que el
           ;;    intérprete que hace cuando todo va bien.

           ;;    Empieza con una función ‘let’ que extrae la cadena
           ;;    y chequea si existe. Si es así (esto es lo
           ;;    que ‘when’ chequea), eso llama a una función ‘if’ que
           ;;    determina si el comando previo que era otra llamada
           ;;    si el comando previo fué otra llamada a ‘kill-region’;
           ;;    si lo era, entonces el siguiente texto se añade
           ;;    cuando se chequea), eso llama a una función ‘if’ que
           ;;    determina si el comando previo era otra llamada a
           ;;    ‘kill-region’; si era eso, entonces el nuevo texto es
           ;;    añadido al texto previo; si no, entonces una función
           ;;    diferente, ‘kill-new’ se llama.

           ;;    La función ‘kill-append’ concatena la nueva cadena y
           ;;    la vieja.  La función ‘kill-new’ inserta texto dentro de
           ;;    ítem en el kill ring @e{anillo de la muerte}.

           ;;    ‘when’ es un ‘if’ sin una parte else.  El segundo ‘when’
           ;;    de nuevo chequea si la cadena actual existe;
           ;;    por añadidura, eso chequea si el comando previo fuese
           ;;    otra llamada a ‘kill-region’. Si una u otra condición
           ;;    es verdadero, entonces eso configura el actual comando a
           ;;    ser ‘kill-region’.
           (let ((string (filter-buffer-substring beg end t)))
             (when string                    ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
                   ;;    @minus{} ‘yank-handler’ es un argumento opcional para
                   ;;    ‘kill-region’ que cuenta el ‘kill-append’ y funciones
                   ;;    ‘kill-new’ como tratan con propiedades añadidas
                   ;;    al texto, tal como ‘negrilla’ o ‘itálica’
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)

         ;;  • El tercer argumento a ‘condition-case’ cuenta el intérprete
         ;;  qué hacer con un error.
         ;;    El tercer argumento tiene una parte de condiciones y una
         ;;    parte del cuerpo.
         ;;    Si las condiciones se encuentra (en este caso,
         ;;             si el texto o búffer son de solo lectura)
         ;;    entonces el cuerpo es ejecutado.
         ;;    La primera parte del tercer es el siguiente:
         ((buffer-read-only text-read-only) ;; parte if
          ;; …  parte then-part
          (copy-region-as-kill beg end)
          ;;    Lo siguiente, también como parte de la then-part, asigna this-command, así
          ;;    será asignado en un error
          (setq this-command 'kill-region)
          ;;    Finalmente, en la then-part, envía un mensaje
          ;;    si se puede copiar el texto al anillo de la muerte
          ;;    @e{kill ring} sin señalar un error, pero no si no se puede.

          (if kill-read-only-ok
              (progn (message "Lee solo texto copiado para el kill ring") nil)
            (barf-if-buffer-read-only)
            ;; If the buffer isn't read-only, the text is.
            (signal 'text-read-only (list (current-buffer)))))
   @end example

   @ignore
     @c v 21
     @example
       (defun kill-region (beg end)
         "Corta entre punto y marca.
       El texto es borrado, pero guardado en el kill ring."
         (interactive "r")

         ;; 1. ‘condition-case’ tiene tres argumentos.
         ;;    Si el primer argumento es nil, como está aquí
         ;;    la información acerca de la señal de error no es
         ;;    almacenada para usarse por otra función.
         (condition-case nil

             ;; 2. El segundo argumento a ‘condition-case’
             ;;    cuenta al intéprete Lisp que hacer cuando todo va bien.

             ;;    La función ‘delete-and-extract-region’ normalmente hace
             ;;    el trabajo. Si el principio y final de la región son lo
             ;;    mismo, entonces la varible ‘string’ estará
             ;;    vacía, o nula
             (let ((string (delete-and-extract-region beg end)))

               ;; ‘cuando’ es una cláusula ‘if’ que no puede tomar ‘else-part’.
               ;; Emacs normalmente asigna el valor del ‘last-command’ al
               ;; comando previo.
               ;; ‘kill-append’ concatena la nueva cadena y la vieja.
               ;; ‘kill-new’ inserta texto dentro de un nuevo
               ;; ítem dentro de un nuevo í en
               ;; kill ring.
               (when string
                 (if (eq last-command 'kill-region)
                     ;; si verdadero, concatena la cadena
                     (kill-append string (< end beg))
                   (kill-new string)))
               (setq this-command 'kill-region))

           ;; 3. El tercer argumento para ‘condition-case’ cuenta el intérprete
           ;;    que hacer con un error.
           ;;    El tercer argumento tiene una parte de condiciones y una
           ;;    parte del cuerpo.
           ;;    Si las condiciones se encuentra (en este caso,
           ;;             si el texto o búffer son de solo lectura)
           ;;    entonces el cuerpo es ejecutado.
           ((buffer-read-only text-read-only) ;; esta el la parte if
            ;; entonces...
            (copy-region-as-kill beg end)
            (if kill-read-only-ok            ;; normalmente esta variable es nula
                (message "Lee el texto copiado al kill ring")
              ;; o sino, señala un error si el búffer es de solo lectura;
              (barf-if-buffer-read-only)
              ;; y, en cualquier caso, señala el texto de solo lectura.
              (signal 'text-read-only (list (current-buffer)))))))
     @end example
   @end ignore

*** @c{condition-case}

    Como se ha visto antes (@pxref{Creando errores, , Genera un Mensaje de
    Error}), cuando el intérprete Emacs Lisp tiene problemas evaluando una
    expresión, se provee de una ayuda; en jerga, se dice “signaling an error”
    @e{señalando un error}. Normalmente, el ordenador para el programa y te
    muestra un mensaje.

    Sin embargo, algunos programas garantizan acciones complicadas. Eso no
    pararía en un error. En la función @c{kill-region}, la mayoría parece un
    error que intentará cortar texto que es de solo lectura y no puede ser
    eliminado. Así la función @c{kill-region} contiene código para manejar
    esta circunstancia. Este código, hace que el cuerpo de la función
    @c{kill-region}, esté dentro de una forma especial @c{condition-case}.

    La plantilla para @c{condition-case} se parece a esto:

    @example
      (condition-case
        @V{var}
        @V{bodyform}
        @V{error-handler}…)
    @end example

    El segundo argumento, @V{bodyform} es sencillo. La forma especial
    @c{condition-case} causa que el intérprete Lisp evalúe el código en
    @V{bodyform}. Si ningún error ocurre, la forma especial devuelve el
    valor del código y produce efectos laterales, si hay.

    En resumen, la parte @V{bodyform} de una expresión @c{condition-case}
    determina qué ocurre cuando cualquier cosa funciona correctamente.

    Sin embargo, si un error ocurre, entre sus otras acciones, la función
    genera la señal de error que definirá uno o más errores de nombres de
    condición.

    Un manejador de errores es el tercer argumento para
    @c{condition-case}. Un manejador de errores tiene dos partes, un
    @V{condition-name} y un @V{body}. Si la parte @V{condition-name}
    tiene un manejador de errores encuentra un nombre de condición generado
    por un error, entonces la parte del @V{body} del manejador de errores
    se ejecuta.

    Como se esperaría, la parte @V{condition-name} de un manejador de
    errores puede ser así, un nombre de condición simple o una lista de
    nombres de condición.

    También, una expresión completa @c{condition-case} puede contener más de
    un manejador de errores. Cuando un error ocurre, el primer manejador
    aplicable se ejecuta.

    Finalmente, el primer argumento a la expresión @c{condition-case}, es el
    argumento @V{var}, que es algunas veces asignado a una variable que
    contiene información acerca del error. Sin embargo, si este argumento es
    nulo, como es el caso en @c{kill-region}, esta información se descarta.

    En breve, en la función @c{kill-region}, el código @c{condition-case}
    funciona así:

    @example
      @V{Si no hay errores}, @V{ejecuta solo este código}
          @V{pero}, @V{si hay errores}, @V{ejecuta este otro código}.
    @end example

    @ignore
      2006 Oct 24
      In Emacs 22,
      copy-region-as-kill is short, 12 lines, and uses
      filter-buffer-substring, which is longer, 39 lines
      and has delete-and-extract-region in it.
      delete-and-extract-region is written in C.

      see Initializing a Variable with @c{defvar}
      this is line 8054
      Initializing a Variable with @c{defvar} includes line 8350
    @end ignore

*** Macro Lisp

    La parte de la expresión @c{condition-case} que se evalúa en la
    expectativa de que todo va bien si tiene un @c{when}. El código usa
    @c{when} para determinar si la variable @c{string} (@e{cadena}) apunta al
    texto que existe.

    Una expresión @c{when} es simplemente una conveniencia de
    programadores. Eso es un @c{if} sin la posibilidad de una cláusula
    else. En tu mente, se puede reemplazar @c{when} con @c{if} y comprender
    de que va. Esto es lo que el intérprete Lisp hace.

    Técnicamente hablando, @c{when} es una macro Lisp. Una @:{macro} Lisp
    permite definir una nueva construcción de control y otras funcionalidades
    del lenguaje. Eso cuenta al intérprete cómo computar otra expresión Lisp
    que dejará de computar el valor. En este caso, la ‘otra expresión’ es una
    expresión @c{if}.

    La definición de función también tiene una macro @c{unless}; que acompaña
    a @c{when}. La macro @c{unless} es un @c{if} sin una cláusula then.

    Para más acerca de macros Lisp, ver Seccion "Macros" en @e(El Manual de
    Referencia de Emacs Lisp). El lenguaje de programación C también provee
    macros. Estos son diferentes, pero también útiles.

    @ignore
      We will briefly look at C macros in
      @l{Digression into C}.
    @end ignore

    Guardando la macro @c{when}, en la expresión @c{condition-case}, cuando
    la cadena tiene contenido, entonces otra expresión condicional se
    ejecuta. Esto es un @c{if} tanto con una then-part y como con una
    else-part.

    @example
      (if (eq last-command 'kill-region)
          (kill-append string (< end beg) yank-handler)
        (kill-new string nil yank-handler))
    @end example

    La parte then (then-part) se evalúa si el comando previo fué otra llamada
    para @c{kill-region}; si no, se evalúa la parte else (else-part)

    @c{yank-handler} es un argumento opcional para @c{kill-region} que cuenta
    cómo las funciones @c{kill-append} y @c{kill-new} se tratan con
    propiedades añadidas al texto, tal como ‘negrilla’ o ‘itálica’.

    @c{last-command} es una variable que viene con Emacs y que no se ha visto
    antes. Normalmente, siempre y cuando una función se ejecute, Emacs asigna
    el valor de @c{last-command} al comando previo.

    En este segmento de la definición, la expresión @c{if} chequea si el
    comando previo era @c{kill-region}. Si era eso,

    @example
      (kill-append string (< end beg) yank-handler)
    @end example

    Se concatena una copia del nuevo texto cortado al texto cortado
    previamente en el kill ring @e{anillo de la muerte}.

** @c{copy-region-as-kill}

   La función @c{copy-region-as-kill} copia una región de texto desde un
   búffer y (via @c{kill-append} o @c{kill-new}) lo guarda en el
   @c{kill-ring}.

   Si se llama a @c{copy-region-as-kill} inmediatamente después de un comando
   @c{kill-region}, Emacs inserta el texto nuevamente copiado al texto
   copiado previamente. Esto significa que si se pega el texto, se obtiene
   todo, tanto esto, como la operación previa. Por otro lado, si algún otro
   comando precede la @c{copy-region-as-kill}, la función copia el texto
   dentro de una entrada separada el kill ring @e{anillo de la muerte}.

   Aquí está el texto completo de la versión 22 de la función
   @c{copy-region-as-kill}:

   @example
     (defun copy-region-as-kill (beg end)
       "Guarda la región como si estuviera cortada, pero no la cortes.
     En el modo Marca de Tránsito @e{Transient Mark}, se desactiva la
       marca.
     Si ‘interprogram-cut-function’ es no nulo, también se guarda el
       texto para una sistema de ventanas de cortar y pegar."
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (filter-buffer-substring beg end) (< end beg))
         (kill-new (filter-buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)
   @end example

   De normal, esta función puede ser dividida dentro sus componentes:

   @example
     (defun copy-region-as-kill (@V{argument-list})
       "@V{documentation}…"
       (interactive "r")
       @V{body}…)
   @end example

   Los argumentos son @c{beg} y @c{end} y la función es interactiva con
   @c{"r"}, así los dos argumentos deben referirse al principio y al final de
   la región. Si ha estado leyendo a través de este documento desde el
   principio, comprendiendo estas partes de una función casi llegaría a ser
   rutina.

   La documentación es algo confusa a menos que se recuerde que la palabra
   ‘kill’ @e{matar, cortar} tiene un significado diferente de la usual. La
   ‘Marca Transitoria’ y @c{interprogram-cut-function} comenta explicar
   ciertos efectos laterales.

   Después de que se ha asignado una marca, un búffer siempre contiene una
   región. Si se desea se puede usar el modo Marca Transitoria para iluminar
   la región temporalmente. (Nadie quiere iluminar la región todo el rato,
   así el modo Marca Transitoria subrraya solo en el momento
   apropiado. Muchas personas desactivan el modo Marca Transitoria, así la
   región nunca se ilumina.)

   También, un sistema de ventanas permite copiar, cortar y pegar entre
   programas diferentes. En el sistema de X windows, por ejemplo, la función
   @c{interprogram-cut-function} es @c{x-select-text}, que funciona con el
   sistema de ventanas equivalente del kill ring de Emacs.

   El cuerpo de la función @c{copy-region-as-kill} empieza con una cláusula
   @c{if}. Lo que esta cláusula hace es distinguir entre dos situaciones
   diferentes: si este comando se ejecuta o no inmediatamente después de un
   comando previo @c{kill-region}. En el primer caso, la nueva región se
   concatena al texto copiado previamente. De otro modo, eso se inserta al
   principio del anillo de la muerte @e{kill ring} como una pieza separada de
   texto desde la pieza previa.

   Las dos líneas de la función previene la región desde la iluminación si el
   modo Transient Mark @e{Marca Transitoria} está activado.

   El cuerpo de @c{copy-region-as-kill} merece discusión en detalle.

*** El cuerpo de @c{copy-region-as-kill}

    La función @c{copy-region-as-kil} funciona de un modo parecido a la
    función @c{kill-region}. Ambas están escritas de un modo que dos o más
    textos cortados en una fila combinan su texto en una entrada simple. Si
    se pega el texto desde el anillo de la muerte @e{kill ring}, se tiene
    todo en una pieza. Más allá, los cortes de textos que se cortan hacia
    adelante desde la posición actual del cursor se añaden al fin del texto
    copiado previamente y comanda este texto copiado vaya hacia atrás al
    principio del texto copiado previamente. De este modo, las palabras en el
    texto están en el orden apropiado.

    Como @c{kill-region}, la función @c{copy-region-as-kill} hace uso de la
    variable @c{last-command} que deja traza del comando de Emacs previo.

    Normalmente, siempre y cuando una función se ejecuta, Emacs asigna el
    valor de @c{this-command} a la función que se ejecuta (que en este caso
    sería @c{copy-region-as-kill}). Al mismo tiempo, Emacs asigna el valor de
    @c{last-command} al valor previo de @c{this-command}.

    En la primera parte del cuerpo de la función @c{copy-region-as-kill}, una
    expresión @c{if} determina si el valor de @c{last-command} es
    @c{kill-region}. Si es así, la then-part de la expresión @c{if} se
    evalúa; eso usa la función @c{kill-append} para concatenar el texto
    copiado en esta llamada a la función con el texto ya en el primer
    elemento (el @Cc{car} del anillo de la muerte. Por otro lado, si el valor
    de @c{last-command} no es @c{kill-region}, entonces la función
    @c{copy-region-as-kill} adjunta un nuevo elemento al anillo de la muerte
    @e{kill ring} usando la función @c{kill-new}.

    La expresión @c{or} se ve así; usa @c{eq}:

    @example
        (if (eq last-command 'kill-region)
            ;; @e{parte then}
            (kill-append  (filter-buffer-substring beg end) (< end beg))
          ;; @e{parte else}
          (kill-new  (filter-buffer-substring beg end)))
    @end example

    (La función @c{filter-buffer-substring} devuelve una subcadena filtrada
    del búffer, cualquiera. Opcionalmente––los argumentos no están aquí, así
    nunca está hecho --- la función puede borrar el texto inicial o devolver
    el texto sin sus propiedades; esta función es un reemplazo para la vieja
    función @c{buffer-substring}, que viene antes que las propiedades del
    texto fuesen implementadas.)

    La función @c{eq} chequea si su primer argumento es el mismo objeto Lisp
    que su segundo argumento. La función @c{eq} es similar a la función
    @c{equal} en esto que es usado para chequear para igualdad, pero difiere
    en esto que determina si dos representaciones son actualmente el mismo
    objeto dentro del ordenador, pero con diferentes nombres. @c{equal}
    determina si la estructura y contenidos de dos expresiones son la misma.

    Si el comando previo era @c{kill-region}, entonces el intérprete Emacs
    Lisp llama a la función @c{kill-append}

**** La función @c{kill-append}

     La función @c{kill-new} se ve como así:

     @example
       (defun kill-append (string before-p &optional yank-handler)
         "Inserta STRING al fin del último corte en el anillo de la muerte @e{kill ring}.
       Si BEFORE-P es no nulo, inserta STRING.
       … "
         (let* ((cur (car kill-ring)))
           (kill-new (if before-p (concat string cur) (concat cur string))
                     (or (= (length cur) 0)
                         (equal yank-handler
                                (get-text-property 0 'yank-handler cur)))
                     yank-handler)))
     @end example

     @ignore
       was:
       (defun kill-append (string before-p)
         "Append STRING to the end of the latest kill in the kill ring.
       If BEFORE-P is non-nil, prepend STRING to the kill.
       If ‘interprogram-cut-function’ is set, pass the resulting kill to
       it."
         (kill-new (if before-p
                       (concat string (car kill-ring))
                     (concat (car kill-ring) string))
                   t))
     @end ignore

     La función @c{kill-append} es limpia. Usa la función @c{kill-new}, que
     discutiremos en más detalle en un momento.

     (También, la función provee un argumento opcional llamado
     @c{yank-handler}; cuando se invoque, este argumento cuenta a la función
     cómo tratar con la propiedades añadidas al texto, tales como ‘negrilla’
     o ‘itálicas’.)

     Eso tiene una función @c{let*} para asignar el valor del primer elemento
     del kill ring a @c{cur}. (No se sabe por qué la función no usa @c{let};
     solo un valor es asignado en la expresión. ¿Quizás esto es un error que
     no produce problemas?

     Considera el condicional que es uno de los dos argumentos para
     @c{kill-new}. Eso usa @c{concat} para concatenar el nuevo texto al
     @Cc{car} del anillo de la muerte @e{kill ring}. Si eso se concatena
     atrás o delante depende de los resultados de una expresión @c{if}:

     @example
       (if before-p                            ; @e{if-part}
           (concat string cur)                 ; @e{then-part}
         (concat cur string))                  ; @e{else-part}
     @end example

     Si la región cortada está antes que la región que se cortó en el último
     comando, entonces debería ser puesto antes que el material salvador en
     el anterior corte @e{kill}; y de manera contraria, si el texto cortado
     sigue lo que fué cortado, eso sería añadido después del texto previo. La
     expresión @c{if} depende del predicado @c{before-p} para decidir si el
     texto nuevamente salvado es puesto antes o después.

     El símbolo @c{before-p} es el nombre de uno de los argumentos a
     @c{kill-append}. Cuando la función @c{kill-append} se evalúa, se asocia
     al valor devuelto evaluando el argumento actual. En este caso, esta es
     la expresión @c{(< end beg)}. Esta expresión no determina directamente
     si el texto cortado en este comando se localiza antes o después del
     texto cortado del último comando; lo que hace es determinar si el valor
     de la variable @c{end} es menor que el valor de la variable @c{beg}. Si
     es así, significa que el usuario se encara al principio del
     búffer. También, el resultado de evaluar la expresión del
     predicado. @c{(< end beg)}, será verdadero y el texto se concatena antes
     del texto previo. Por otro lado, si el valor de la variable @c{end} es
     mayor que el valor del la variable @c{beg}, el texto será concatenado
     después del texto previo.

     Cuando el texto nuevamente guardado se concatena, entonces la cadena con
     el nuevo texto será concatenado antes del viejo texto:

     @example
       (concat string cur)
     @end example

     Pero si el texto será añadido, eso será concatenado después del viejo
     texto:

     @example
       (concat cur string))
     @end example

     Para comprender cómo funciona esto, primero se necesita revisar la
     función @c{concat}. La función @c{concat} enlaza junto o une dos cadenas
     de texto. El resultado es una cadena. Por ejemplo:

     @example
       (concat "abc" "def")
            ⇒ "abcdef"

       (concat "nuevo "
               (car '("primer elemento" "segundo elemento")))
            ⇒ "nuevo primer elemento"

       (concat (car
               '("primer elemento" "segundo elemento")) " modificado")
            ⇒ "primer elemento modificado"
     @end example

     Ahora puede tener sentido @c{kill-append}: eso modifica los contenidos
     del anillo de la muerte @e{kill ring}. El anillo de la muerte @e{kill
     ring} es una lista, en la que cada elemento es texto guardado. La
     función @c{kill-append} usa la función @c{kill-new} que usa la función
     @c{setcar}.

**** La función @c{kill-new}

     @ignore
       Optional third arguments YANK-HANDLER controls how the STRING is later
       inserted into a buffer; see ‘insert-for-yank’ for details.
       When a yank handler is specified, STRING must be non-empty (the yank
       handler, if non-nil, is stored as a ‘yank-handler’ text property on STRING).

       When the yank handler has a non-nil PARAM element, the original STRING
       argument is not used by ‘insert-for-yank’.  However, since Lisp code
       may access and use elements from the kill ring directly, the STRING
       argument should still be a \"useful\" string for such uses."
     @end ignore

     La función @c{kill-new} se ve de esta manera:

     @example
       (defun kill-new (string &optional replace yank-handler)
         "Crea STRING el último corte en el anillo de la muerte @e{kill
         ring}.
       Asigna ‘kill-ring-yank-pointer’ para apuntarlo.

       Si ‘interprogram-cut-function’ es no nulo, aplícalo a su
        STRING.
       Segundo argumento opcional REPLACE no-nulo significa que STRING
        reemplazará el frente del kill ring, en vez de ser a@~andido a la lista.
       …"
         (if (> (length string) 0)
             (if yank-handler
                 (put-text-property 0 (length string)
                                    'yank-handler yank-handler string))
           (if yank-handler
               (signal 'args-out-of-range
                       (list string "yank-handler specified for empty string"))))
         (if (fboundp 'menu-bar-update-yank-menu)
             (menu-bar-update-yank-menu string (and replace (car kill-ring))))
         (if (and replace kill-ring)
             (setcar kill-ring string)
           (push string kill-ring)
           (if (> (length kill-ring) kill-ring-max)
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end example

     @ignore
       was:
       (defun kill-new (string &optional replace)
         "Make STRING the latest kill in the kill ring.
       Set the kill-ring-yank pointer to point to it.
       If ‘interprogram-cut-function’ is non-nil, apply it to STRING.
       Optional second argument REPLACE non-nil means that STRING will replace
       the front of the kill ring, rather than being added to the list."
         (and (fboundp 'menu-bar-update-yank-menu)
              (menu-bar-update-yank-menu string (and replace (car kill-ring))))
         (if (and replace kill-ring)
             (setcar kill-ring string)
           (setq kill-ring (cons string kill-ring))
           (if (> (length kill-ring) kill-ring-max)
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end ignore

     (Vea que la función no es interactiva.)

     Normalmente, se mira a esta función en partes.

     La definición de la función tiene un argumento opcional
     @c{yank-handler}, que cuando se invoca cuenta la función de cómo tratar
     con propiedades añadidas al texto, tal como ‘negrilla’ o
     ‘itálica’. Nosotros evitaremos esto.

     La primer línea de la documentación tiene sentido:

     @example
       Crea la CADENA la última copia en el anillo de la muerte @e{kill
       ring}.
     @end example

     Permite saltarse el resto de la documentación por el momento.

     También, permite salir de la expresión inicial @c{if} y estas líneas de
     código involucrando @c{menu-bar-update-yank-menu}. Nosotros explicaremos
     debajo.

     Las líneas críticas son estas:

     @example
         (if (and replace kill-ring)
             ;; @e{entonces}
             (setcar kill-ring string)
           ;; @e{resto}
         (push string kill-ring)
           (setq kill-ring (cons string kill-ring))
           (if (> (length kill-ring) kill-ring-max)
               ;; @e{avoid overly long kill ring}
               (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
         (setq kill-ring-yank-pointer kill-ring)
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end example

     El test condicional es @c{(and replace kill-ring)}. Esto será verdad
     cuando dos condiciones se encuentran: el anillo de la muerte @e{kill
     ring} tiene alguna cosa dentro, y la variable @c{replace} es verdad.

     Cuando la función @c{kill-append} asigna @c{replace} para ser cierto y
     cuando el anillo de la muerte @e{kill ring} tiene al menos un ítem en
     eso, la expresión @c{setcar} es ejecutada.

     @example
       (setcar kill-ring string)
     @end example

     La función @c{setcar} actualemten cambia el primer elemento del anillo
     de la muerte (@c{kill-ring} lista al valor de @c{string}. Eso reemplaza
     el primer elemento.

     Por otro lado, si el kill ring está vacío, o reemplazar es falso, la
     else-part de la condición está ejecutado:

     @example
       (push string kill-ring)
     @end example

     @c{push} pone su primer argumento dentro del segundo. Es similar al
     viejo.

     @example
       (setq kill-ring (cons string kill-ring))
     @end example

     o el nuevo

     @example
       (add-to-list kill-ring string)
     @end example

     Cuando eso es falso, la expresión primero construye una nueva versión
     del anillo de la muerte @e{kill ring} añadiendo @c{string} al anillo de
     la muerte @e{kill ring} como un nuevo elemento (que es lo que @c{push}
     hace). Entonces ejecuta un segundo @c{if} cláusula. Este segundo @c{if}
     cláusula guarada el anillo de la muerte @e{kill ring} desde el creciente
     demasiado largo.

     Déjanos mirar estas dos expresiones en orden.

     La línea @c{push} de la parte else asigna el nuevo valor del kill ring
     @e{anillo de la muerte} a que resultados añaden la cadena siendo cortada
     al viejo anillo de la muerte @e{kill ring}

     Nosotros podemos ver cómo esto funciona con un ejemplo.

     Primero,

     @example
       (setq example-list '("aqui una clausula" "otra clausula"))
     @end example

     Después de evaluar esta expresión con @k{C-x C-e}, se puede evaluar
     @c{example-list} y mira lo que devuelve:

     @example
       example-list
            ⇒ ("aquí hay una claúsula" "otra claúsula")
     @end example

     Ahora, se puede añadir un nuevo elemento en esta lista evaluando la
     siguiente expresión: @findex push, @e{ejemplo}

     @example
       (push "una tercera cláusula" lista-de-ejemplo)
     @end example

     Cuando se evalúa @c{example-list}, se encuentra su valor es:

     @example
       example-list
            ⇒ ("una tercera claúsula" "aquí hay una
            claúsula" "otra claúsula")
     @end example

     De este modo, la tercera claúsula se añade a la lista con @c{push}.

     Ahora para la segunda parte de la claúsula @c{if}. Esta expresión deja
     el kill ring desde lo creciente demasiado largo. Eso se ve de la
     siguiente manera:

     @example
       (if (> (length kill-ring) kill-ring-max)
           (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
     @end example

     El código chequea si el tamaño del anillo de la muerte @e{kill ring} es
     más grande que el máximo tamaño permitido. Este es el valor de
     @c{kill-ring-max} (que es 60, por defecto). Si el tamaño del anillo de
     la muerte @e{kill ring} es demasiado largo, entonces este código asigna
     el último elemento del anillo de la muerte @e{kill ring} a @c{nil}. Eso
     hace esto usando dos funciones, @c{nthcdr} y @c{setcdr}.

     Nosotros vemos que @c{setcdr} temprano (@pxref{setcdr, ,
     @c{setcdr}}). Eso asigna el @Cc{cdr} de una lista, solo como @c{setcar}
     asigna el @Cc{car} de una lista. En este caso, sin embargo, @c{setcdr}
     no estará configurando el @Cc{cdr} del kill ring completo; la función
     @c{nthcdr} es usada para causarlo para asignar el @Cc{cdr} del siguiente
     al último elemento del kill ring --- esto significa que desde el
     @Cc{cdr} del siguiente al último elemnto del kill ring @e{anillo de la
     muerte}, eso asignará el último elemento del kill ring @e{anillo de la
     muerte}.

     La función @c{nthcdr} funciona repetidamente tomando el @Cc{cdr} de una
     lista––eso toma el @Cc{cdr} del @Cc{cdr} del @Cc{cdr} …. Eso hace esto
     @V{N} veces y devuelve los resultados. (Véase Sección @l{nthcdr, ,
     @c{nthcdr}}.)

     De este modo, si teniamos una lista de cuatro elemento que era
     supuestamente de tres elementos, se podría asignar el @Cc{cdr} del
     siguiente al último elemento a @c{nil}, y por eso se ordena la
     lista. (Si se asigna el último elemento a algún otro valor a @c{nil},
     que se podría hacer, entonces no se habría ordenado la lista. Véase
     Sección @l{setcdr, , @c{setcdr}}.)

     Se puede ver ordenando la evaluación de las siguientes tres expresiones
     en turno. Primero asigna el valor de @c{arboles} a @c{(arce encina pino
     abedul)} entonces asigna el @Cc{cdr} de su segundo @Cc{cdr} y entonces
     encuentra el valor de @c{arboles}.

     @example
       (setq arboles '(arce encina pino abedul))
            ⇒ (arce encina pino abedul)

       (setcdr (nthcdr 2 arboles) nil)
            ⇒ nil

       árboles
            ⇒ (arce encina pino)
     @end example

     (El valor devuelto por la expresión @c{setcdr} es @c{nil} desde que es
     que el @Cc{cdr} es asignado.)

     Para repetir, en @c{kill-new}, la función @c{nthcdr} toma el @Cc{cdr} un
     número de veces que es uno menos que el tamaño máximo permitido del
     anillo de la muerte @e{kill ring} y @c{setcdr} asigna el @Cc{cdr} de
     este elemento (que será el resto de los elementos en el anillo muerte)
     para @c{nil}. Esto previene el anillo de la muerte @e{kill ring} desde
     lo que crece demasiado largo.

     De la siguiente a la última expresión en la función @c{kill-new} es

     @example
       (setq kill-ring-yank-pointer kill-ring)
     @end example

     El @c{kill-ring-yank-pointer} es una variable global que es asignado
     para ser el @c{kill-ring}.

     Incluso aunque el @c{kill-ring-yank-pointer} es llamado un @'{puntero},
     eso es una variable solo como el anillo de la muerte @e{kill ring}. Sin
     embargo, el nombre que ha sido elegido para ayudar a humanos a
     comprender cómo la variable se usa.

     Ahora, para devolver rápido una expresión en el cuerpo de la función:

     @example
         (if (fboundp 'menu-bar-update-yank-menu)
              (menu-bar-update-yank-menu string (and replace (car kill-ring))))
     @end example

     Empieza con una expresión @c{if}

     En este caso, la expresión chequea primero si
     @c{menu-bar-update-yank-menu} existe como una función, y si así, se
     llama. La función @c{fboundp} devuelve cierto si el símbolo que se
     chequea tiene una definición de función que ‘no es vacía’. Si el símbolo
     de la definición de función fuera vacío, recibiría un mensaje de error,
     como se hizo cuando se crearon errores intencionalmente (@pxref{Creando
     errores, , Genera un Mensaje de Error}).

     La then-part contiene una expresión cuyo primer elemento es la función
     @c{and}.

     La forma especial @c{and} evalúa cada uno de sus argumentos hasta que uno
     de los argumentos devuelva un valor de @c{nil}, en cuyo caso la expresión
     @c{and} devuelve @c{nil}; sin embargo, si ninguno de los argumentos
     devuelve una valor de @c{nil}, el valor resultante desde la evaluación el
     último argumento es devuelto. (Desde que tal valor no es @c{nil}, eso es
     considerado cierto en Emacs Lisp.) En otras palabras, una expresión @c{and}
     devuelve un valor cierto solo si todos sus argumentos son
     verdaderos. (Véase Sección @l{Repaso-2<>Revisar el segundo búffer
     relacionado}.)

     La expresión determina si el segundo argumento
     @c{menu-bar-update-yank-menu} es verdadero o no.

     @ignore
       ;; If we're supposed to be extending an existing string, and that
       ;; string really is at the front of the menu, then update it in place.
     @end ignore

     @c{menu-bar-update-yank-menu} es una de la funciones que lo hace posible
     para usar el menu ‘Seleccionar y Pegar’ en el ítem Editar de una barra
     de menu; usando un ratón, se pueden mirar varias piezas de texto que se
     han guardado y se selecciona una pieza para pegar.

     La última expresión en la función @c{kill-new} añade las cadenas
     nuevamente copiadas a aquella facilidad que existe copiando y pegando
     entre diferentes programas ejecutando un sistema de ventanas. En el
     Sistema de Ventanas de X, por ejemplo, la función @c{x-select-text} toma
     la cadena y la almacena en memoria operada por X@. Se puede pegar la
     cadena en otro programa, tal como un Xterm.

     La expresión se ve como:

     @example
         (if interprogram-cut-function
             (funcall interprogram-cut-function string (not replace))))
     @end example

     Si @c{interprogram-cut-function} existe, entonces Emacs ejecuta
     @c{funcall}, que en vez de llamar a su primer argumento como una
     función, pasa los argumentos que permanecen en eso. (Incidentalmente,
     tan lejos como se puede ver, esta expresión @c{if} podría ser
     reemplazado por una expresión @c{and} similar a uno en la primera parte
     de la función.)

     Estamos yendo a discutir sistemas de ventanas y otros programas más allá
     pero meramente nota que este es un mecanismo que habilita GNU Emacs a
     trabajar fácilmente y bien con otros programas.

     Este código para emplazar texot en el anillo de la muerte @e{kill ring},
     concatenado con un elemento existente o como un nuevo elemento, nos
     lidera al código para traer texto que ha sido cortado del búffer––los
     comandos de corte. Sin embargo, antes de discutir los comandos de corte,
     es mejor aprender cómo las listas son implementadas en un
     ordenador. Esto dejará claro tales misterios como el uso del término
     ‘puntero’. Pero antes de esto, nos desviaremos a C.

     @ignore
       @c is this true in Emacs 22?   Does not seems to be

         (If the @c{(< end beg))} expression is true, @c{kill-append}
       prepends the string to the just previously clipped text.  For a
       detailed discussion, see @l{kill-append function, , The
       @c{kill-append} function}.)

       If you then yank back the text, i.e., ‘paste’ it, you get both pieces
       of text at once.  That way, if you delete two words in a row, and then
       yank them back, you get both words, in their proper order, with one
       yank.  (The @c{(< end beg))} expression makes sure the order is
       correct.)

       On the other hand, if the previous command is not @c{kill-region},
       then the @c{kill-new} function is called, which adds the text to
       the kill ring as the latest item, and sets the
       @c{kill-ring-yank-pointer} variable to point to it.
     @end ignore

     @ignore

       @c Evidently, changed for Emacs 22. The zap-to-char command does not
       @c use the delete-and-extract-region function

       2006 Oct 26, the Digression into C is now OK but should come after
       copy-region-as-kill and filter-buffer-substring

       2006 Oct 24
       In Emacs 22,
       copy-region-as-kill is short, 12 lines, and uses
       filter-buffer-substring, which is longer, 39 lines
       and has delete-and-extract-region in it.
       delete-and-extract-region is written in C.

       see Initializing a Variable with @c{defvar}
     @end ignore

** Disgresión dentro de C

   La función @c{copy-region-as-kill} (@pxref{copy-region-as-kill, ,
   @c{copy-region-as-kill}}) usa la función @c{filter-buffer-substring}, que
   en vez de eso usa la función @c{delete-and-extract-region}. Eso elimina
   los contenidos de una región y no se puede volverlos a tener.

   Al contrario que el otro código discutido aquí, la función
   @c{delete-and-extract-region} no está escrita en Emacs Lisp; eso está
   escrito en C y es una de las primitivas del sistema GNU Emacs. Puesto que
   es muy simple, se hará la disgresión brevemente desde el Lisp y se
   describe aquí.

   Como muchas de las otras primitivas Emacs, @c{delete-and-extract-region}
   se escribe como una instancia de una macro C, una macro es una plantilla
   para codificar. La macro completa se parece a esto:

   @example
     DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
            Sdelete_and_extract_region, 2, 2, 0,
            doc: /* Borra el texto entre START y END y lo devuelve.  */)
            (Lisp_Object start, Lisp_Object end)
     {
       validate_region (&start, &end);
       if (XINT (start) == XINT (end))
         return empty_unibyte_string;
       return del_range_1 (XINT (start), XINT (end), 1, 1);
     }
   @end example

   Sin ir dentro de los detalles de la macro que escribe el proceso, se hará
   un apunte de esta macro que empieza con la palabra @c{DEFUN}. La palabra
   @c{DEFUN} fué elegida puesto que el código sirve para el mismo propósito
   que @c{defun} hace en Lisp. (La macro C @c{DEFUN} definida en
   @f{emacs/src/lisp.h}.)

   El palabra @c{DEFUN} tiene siete partes dentro de los paréntesis:

   - La primera parte es el nombre dado a la función en Lisp,
     @c{delete-and-extract-region}.

   - La segunda parte es el nombre de la función en C,
     @c{Fdelete_and_extract_region}. Por convención, eso empieza con
     @'{F}. Puesto que C no usa guiones en nombres, los guiones bajos son
     usados a su vez.

   - La tercera parte es el nombre para la estructura constante C que
     registra información en esta función para uso interno. Es el nombre de
     la función en C pero empieza con una @'{S} en vez de una @'{F}.

   - Las partes cuarta y quinta especifican el número mínimo y máximo de
     argumentos que la función puede tener. Esta función demanda exactamente
     2 argumentos.

   - La sexta parte está cerca del argumento que sigue la declaración
     @c{interactive} en una función escrita en Lisp: una carta seguida,
     quizás, por una consola. La única diferencia con Lisp es que si la macro
     se llama sin argumentos. Entonces se escribe un @c{0} (que es una
     ‘cadena nula’), como en esta macro.

     Si se fueran a especificar argumentos, se emplazarían entre marcas de
     comillas. La macro C para @c{goto-char} incluye @c{\"NGoto char \"} en
     esta posición se indica que la función espera un prefijo plano, en este
     caso, una localización numérica en un búffer, y provee una consola.


   - La séptima parte es una cadena de documentación, solo como la única para
     una función escrita en Emacs Lisp. Esto es escrito como un comentario
     C. (Cuando se escribe Emacs, el programa @command{lib-src/make-docfile}
     extrae estos comentarios y los usa para crear la documentación “real”.)


   En una macro C, los parámetros son los siguientes, con una frase de este
   tipo de objeto se siguen por lo que podría ser llamado el ‘cuerpo’ de la
   macro. Para @c{delete-and-extract-region} el ‘cuerpo’ consiste de las
   siguientes cuatro líneas:

   @example
     validate_region (&start, &end);
     if (XINT (start) == XINT (end))
       return build_string ("");
     return del_range_1 (XINT (start), XINT (end), 1, 1);
   @end example

   La función @c{validate_region} chequea si los valores pasados como el
   principio y fin de la región son el tipo apropiado y son del mismo
   rango. Si las posiciones del principio y fin son las mismas, entonces se
   devuelve una cadena vacía.

   La función @c{del_range_1} actualmente borra el texto. Eso es una función
   compleja que no miraremos. Eso actualiza el búffer y hace otras cosas. Sin
   embargo, es el valorable mirar los dos argumentos pasados para
   @c{del_range}. Estos son @c{XINT (start)} y @c{XINT (end)}.

   Tan lejos como el lenguaje C es concebido, @c{start} y @c{end} son dos
   enteros que marcan el principio y el fin de la región para ser
   borrada@n{10}.

   En las primeras versiones de Emacs, estos dos números fueron 32 bits de
   longitud, pero el código está lentamente siendo generalizado para manejar
   otras longitudes. Tres de los bits disponibles son usados para especificar
   el tipo de información; los bits permanecen ser usados como ‘contenido’.

   @'{XINT} es una macro C que extrae los números relevantes desde la
   colección larga de bits; los otros tres bits se descartan.

   El comando en @c{delete-and-extract-region} se parece a esto:

   @example
     del_range_1 (XINT (start), XINT (end), 1, 1);
   @end example

   Esto borra la región entre la posición del principio, @c{start}, y la
   posición final, @c{end}.

   Desde el punto de vista de la persona que escribe Lisp, Emacs es muy
   simple; pero oculta en el fondo un gran trato de complejidad para hacer
   todo el trabajo.

** Inicializando una variable con @c{defvar}

   @ignore
     2006 Oct 24
     In Emacs 22,
     copy-region-as-kill is short, 12 lines, and uses
     filter-buffer-substring, which is longer, 39 lines
     and has delete-and-extract-region in it.
     delete-and-extract-region is written in C.

     see Initializing a Variable with @c{defvar}
   @end ignore

   La función @c{copy-region-as-kill} es escrita en Emacs Lisp. Dos funciones
   con eso, @c{kill-append} y @c{kill-new}, copiar una región en un búffer y
   guardarlo en una variable llamada el @c{kill-ring}. Esta sección describe
   cómo la variable @c{kill-ring} es creada e inicializada usando la forma
   especial @c{defvar}.

   (De nuevo se nota que el término @c{kill-ring} es un sin nombre. El texto
   que es cortado fuera del búffer puede ser traido; eso no es un corpus de
   anillo, pero un anillo de texto resucitable.)

   En Emacs Lisp, una variable tal como @c{kill-ring} es creada y dada por un
   valor inicial usando la forma especial @c{defvar}. El nombre viene de
   “definir variable”.

   La forma especial @c{defvar} es similar a @c{setq} en este se configura el
   valor de una variable. Eso no es @c{setq} en dos modos; primero solo
   configura el valor de la variable si la variable no tiene ya un valor. Si
   la variable ya tiene un valor, @c{defvar} no sobreescribe el valor
   existente. Segundo, @c{defvar} tiene una cadena de documentación.

   (Otra forma especial, @c{defcustom}, está diseñado para variables que la
   gente personaliza. Eso tiene más funcionalidades que @c{defvar}. (Véase
   Sección @l{Especificar variables usando @c{defcustom}}.)

   Se puede ver el actual valor de una variable, cualquier variable, usando
   la función @c{describe-variable}, que es normalmente invocado escribiendo
   @k{C-h v}. Si se escribe @k{C-h v} y @c{kill-ring} (seguido por @k{RET}),
   se verá que hay en tu anillo de la muerte actual @e{kill ring} al ser
   pulsado --- ¡esto puede ser bastante tranquilo! A la inversa, si no has
   estado haciendo nada esta sesión en Emacs, excepto leer este documento, se
   puede no tener nada dentro. También, se verá la documentación para
   @c{kill-ring}:

   @example
     Documentación:
     Lista de secuencias de texto muerto (guardado).
     Desde que el (kill ring) se supone que interactua bien con
     cut-and-paste facilita ofrecer por sistemas de ventanas,
     debería usar esta variable
     interactúa bin con ‘interprogram-cut-function’ y
     ‘interprogram-paste-function’. Las funciones ‘kill-new’,
     ‘kill-append’, y ‘current-kill’ se suponen para implementar esta
     interacción; se puede querer usarlo en vez de manipular en anillo de
     la muerte @e{kill ring} directamente.
   @end example

   El kill ring @e{anillo de la muerte} está definido por un @c{defvar} del
   siguiente modo:

   @example
     (defvar kill-ring nil
       "Lista de secuencia de textos cortados.
     …")
   @end example

   En esta definición de variable, la variable es dada un valor inicial de
   @c{nil}, que tiene sentido, desde que si no se ha guardado nada, no se
   quiere nada si se da un comando @c{yank}. La cadena de documentación es
   escrito solo como la cadena de documentación de un @c{defun}. Como con la
   cadena de documentación sería una frase completa, desde que algunos
   comandos, como @c{apropos}, imprime solo la primera línea de
   documentación. Las líneas de exito no serían indentadas; de otro modo se
   mira cuando se usa @k{C-h v} (@c{describe-variable}).

*** @c{defvar} y un asterisco

    En el pasado, Emacs usaba la forma especial @c{defvar} tanto para
    variables interna que no esperaría que un usuario cambie y para variables
    que espera un usuario cambie. Aunque se puede todavía usar @c{defvar}
    para variables personalizadas, por favor, usa @c{defcustom} en vez, desde
    que la forma especial provee una ruta dentro de los comando de
    Personalización. (Véase Sección @l{Especificar variables usando
    @c{defcustom}}.)

    Cuando se especifica una variable usando la forma especial @c{defvar}, se
    podría distinguir una variable que un usuario podría querer cambiar desde
    otros escribiendo, @'{*}, en la primera columna de su cadena de
    documentación. Por ejemplo:

    @example
      (defvar shell-command-default-error-buffer nil
        "*Nombre de buffer para ‘shell-command’ … salir del error.
      … ")
    @end example

    Tu podrías (y todavía puedes) usar el comando @c{set-variable} para
    cambiar el valor de @c{shell-command-default-error-buffer}
    temporalmente. Sin embargo, las opciones configuradas usando
    @c{set-variable} no están asignadas solo por la duración de tu sesión de
    edición. Los nuevos valores no están guardados entre sesiones. Cada vez
    que Emacs empieza, lee el valor original, a menos que tu cambia el valor
    con tu fichero @f{.emacs}, si configurándolo manualmente o usando
    @c{customize}. Véase Sección @l{Tu Fichero @f{.emacs}}.

    Para mí, el mayor uso del comando @c{set-variable} es sugerir variables
    que se podrían querer asignar en mi fichero @f{.emacs}. Ahora hay más de
    700 variables, demasiadas para recordarlas fácilmente. Afortunadamente,
    se puede presionar @k{TAB} después de llamar al comando @c{M-x
    set-variable} para ver la lista de variables. (Véase Sección "Examinando
    y Configurando Variables" en @e(El Manual de GNU Emacs).)

** Repaso

   Aquí hay un breve resumen de algunas funciones introducidas recientemente.

   - car ::
     cdr ::

     @c{car} devuelve el primer elemento de una lista; @c{cdr} devuelve el
     segundo y subsiguientes elementos de una lista.

     Por ejemplo:

     @example
       (car '(1 2 3 4 5 6 7))
            ⇒ 1
       (cdr '(1 2 3 4 5 6 7))
            ⇒ (2 3 4 5 6 7)
     @end example

   - cons ::

     @c{cons} construye una lista enlazando su primer argumento a su segundo
     argumento.

     Por ejemplo:

     @example
       (cons 1 '(2 3 4))
            ⇒ (1 2 3 4)
     @end example

   - funcall ::

     @c{funcall} evalúa su primer argumento como una función. Así pasa los
     argumentos que permanecen a su primer argumento.

   - nthcdr ::

     Devuelve el resultado de tomar @Cc{cdr} ‘n’ veces en una lista.  The
     @m(n^{th}) @c{cdr}. El ‘resto del resto’, como estaba

     Por ejemplo:

     @example
       (nthcdr 3 '(1 2 3 4 5 6 7))
            ⇒ (4 5 6 7)
     @end example

   - setcar ::
     setcdr ::

     @c{setcar} cambia el primer elemento de una lista; @c{setcdr} cambia el
     segundo y subsiguiente elementos de una lista.

     Por ejemplo:

     @example
       (setq triple '(1 2 3))

       (setcar triple '37)

       triple
            ⇒ (37 2 3)

       (setcdr triple '("foo" "bar"))

       triple
            ⇒ (37 "foo" "bar")
     @end example

   - progn ::

     Evalúa cada argumento en secuencia y entonces devuelve el valor del
     último.

     Por ejemplo:

     @example
       (progn 1 2 3 4)
            ⇒ 4
     @end example

   - save-restriction ::

     Graba siempre que encoger esté en efecto en el búffer, si cualquiera,
     restaura este encogimiento después de evaluar los argumentos.

   - search-forward ::

     Buscar una cadena, y si la cadena es encontrada, mueve el punto. Con una
     expresión regular, usa algo similar a @c{re-search-forward}. (Véase
     Sección @l{Búsquedas de Expresiones Regulares}, para una explicación de
     expresiones regulares patrones y búsquedas.)

     @c{search-forward} y @c{re-search-forward} tiene cuatro argumentos:

     1. La cadena o la expresión regular para buscar.

     2. Opcionalmente, el límite de la búsqueda.

     3. Opcionalmente, que haces si la búsqueda falla, devuelve @c{nil} o un
        mensaje de error.

     4. Opcionalmente, cuántas veces se puede repetir la búsqueda; si es
        negativa, la búsqueda va hacia atrás.



   - kill-region               ::
     delete-and-extract-region ::
     copy-region-as-kill       ::

     @c{kill-region} corta el texto entre punto y marca desde el búffer y
     almacena ese texto en el anillo de la muerte @e{kill ring}, así se puede
     obtener pegándolo.


     @c{copy-region-as-kill} copia el texto entre punto y marca dentro del
     anillo de la muerte @e{kill ring}, que se puede obtener pegándolo. La
     función no corta o borra el texto desde el búffer.


   @c{delete-and-extract-region} elimina el texto entre el punto y marca
   desde el búffer y a través. No se puede volver. Esto no es un comando
   interactivo.)

** Buscando ejercicios

   - Escribe una función interactiva que busca una cadena. Si la búsqueda
     encuentra la cadena, deja el punto después y muestra un mensaje que dice
     “¡Encontrado!”. (No use @c{search-forward} como nombre de esta función;
     si se hace, se sobreescribirá la versión existente @c{search-forward}
     que viene con Emacs. Use un nombre tal como @c{test-search} en vez de
     eso.

   - Escribe una función que imprime el tercer elemento del kill ring
     @e{anillo de la muerte} en el área echo, si cualquiera; si el kill ring
     @e{anillo de la muerte} no contiene un tercer elemento, imprime un
     mensaje apropiado.

* Cómo se implementan las listas

  En Lisp, los átomos se graban de manera simple, si la implementación no es
  sencilla en la práctica, no es, nada sencilla en la teoría. El átomo
  @'{rosa}, por ejemplo, se graba como las cuatro letras contiguas @'{r},
  @'{o}, @'{s}, @'{a}. Una lista, por otro lado, se guarda de manera
  diferente. El mecanismo es igualmente simple, pero toma un momento para
  tener usada la idea. Una lista se guarda usando una serie de pares de
  punteros. En las series, el primer puntero en cada par de puntos a un átomo
  o a otra lista, y el segundo puntero en cada par al siguiente par, o al
  símbolo @c{nil}, que marca el fin de la lista.

  Un puntero por sí mismo es poco simple a la dirección electrónica de la que
  está apuntada. Aquí, una lista se guarda como una serie de direcciones
  electrónicas.

  Por ejemplo, la lista @c{(rosa violeta tulipan)} tiene tres elementos,
  @'{rosa}, @'{violeta}, y @'{tulipan}. En el ordenador, la dirección
  electrónica de @'{rosa} se graba en un segmento de memoria del ordenador a
  través de la dirección que da la dirección electrónica de donde el átomo
  @'{violeta} está localizado; y esta dirección (la que cuenta donde
  @'{violeta} está se localiza) se guarda con una dirección que cuenta donde
  la dirección para el átomo @'{tulipan} se localiza.

  Esto parece más complicado de lo que es y es más fácil visto en un
  diagrama:

  @diagram
        ___ ___      ___ ___      ___ ___
       |___|___|--> |___|___|--> |___|___|--> nil
         |            |            |
         |            |            |
         ---> rosa    ---> violeta ---> tulipan
  @end diagram

  En el diagrama, cada caja representa una palabra de memoria del ordenador
  que maneja un objeto Lisp, normalmente en la forma de una dirección de
  memoria. Las cajas, por ej. las direcciones, están en pares. Cada flecha
  apunta a lo que la dirección es la dirección de, si un átomo u otro par de
  direcciones. La primera caja es la dirección electrónica de @'{rosa} y la
  flecha apunta a @'{rosa}; la segunda caja es la dirección del siguiente par
  de cajas, la primera parte de la que es la dirección de @'{violeta} y la
  segunda parte es la dirección del siguiente par. La última caja apunta al
  símbolo @c{nil}, que marca el fin de la lista.

  Cuando una variable es configurado a una lista con una función tal como
  @c{setq}, almacena la dirección de la primera caja en la variable. De este
  modo, la evaluación de la expresión es:

  @example
    (setq ramo '(rosa violeta tulipan))
  @end example

  crea una situación como esta:

  @diagram
    ramo
         |
         |     ___ ___      ___ ___      ___ ___
          --> |___|___|--> |___|___|--> |___|___|--> nil
                |            |            |
                |            |            |
                 --> rosa     --> violeta   --> tulipan
  @end diagram

  En este ejemplo, el símbolo @c{ramo} maneja la dirección del primer par de
  cajas.

  Esta misma lista puede ser ilustrada en un modo diferente de anotación de
  cajas como esta:

  @diagram
    ramo
     |
     |    --------------       ----------------       --------------------
     |   | car   | cdr  |     | car     | cdr  |     | car         | cdr  |
      -->| rosa  |   o------->| violeta |   o------->| tulipan  | nil  |
         |       |      |     |         |      |     |             |      |
          --------------       ----------------       --------------------
  @end diagram

  (Los símbolos consisten de más pares de direcciones, pero la estructura de
  un símbolo es hecha de direcciones. De manera profunda, el símbolo @c{ramo}
  consiste de un grupo de cajas-de-direcciones, una que es la dirección de la
  palabra impresa @'{ramo}, una segunda de la que es la dirección de una
  definición de función adjunta al símbolo, si cualquiera, un tercero del que
  es la dirección del primer par de cajas-de-direccion para la lista @c{(rosa
  violeta tulipan)}, y así. Aquí se está mostrando que la tercera caja de
  dirección del símbolo apunta al primer par de cajas-de-direccion para la
  lista.)

  Si un símbolo se asigna al @Cc{cdr} de una lista, la lista en sí no cambia;
  el símbolo simplemente tiene una dirección abajo de la lista. (En la jerga,
  @Cc{car} y @Cc{cdr} son ‘no destructivos’.) De este modo, se evalúa la
  siguiente expresión

  @example
    (setq flores (cdr ramo))
  @end example

  produce esto:

  @diagram
    ramo        flores
      |              |
      |     ___ ___  |     ___ ___      ___ ___
       --> |   |   |  --> |   |   |    |   |   |
           |___|___|----> |___|___|--> |___|___|--> nil
             |              |            |
             |              |            |
              --> rosa       --> violeta  --> tulipan
  @end diagram

  El valor de @c{flores} es @c{(violeta tulipan)}, esto es decir que el
  símbolo @c{flores} maneja la dirección del par address-boxes el primero que
  maneja la dirección de @c{violeta}, y el segundo que maneja la dirección de
  @c{tulipan}.

  Un par de cajas-de-direcciones se llama una @:{cons cell} o @:{par de
  puntos}. Véase Sección "la Célula Cons y los Tipos Lista" en @e(El Manual
  de Referencia de Emacs Lisp), y @"(Notación de Pares de Puntos) en @e(El
  Manual de Referencia de GNU Emacs Lisp), para más información acerca de
  células cons y pares de puntos.

  La función @c{cons} añade un nuevo par de direcciones al frente de una
  serie de direcciones como son mostradas debajo. Por ejemplo, evaluando la
  expresión

  @example
    (setq ramo (cons 'lila ramo))
  @end example

  produce:

  @diagram
    ramo                       flores
      |                             |
      |     ___ ___        ___ ___  |     ___ ___       ___ ___
       --> |   |   |      |   |   |  --> |   |   |     |   |   |
           |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
             |              |              |             |
             |              |              |             |
              --> lila      --> rosa       --> violeta    --> tulipan
  @end diagram

  Sin embargo, esto no cambia el valor del símbolo @c{flores}, así puedes ver
  evaluando lo siguiente,

  @example
    (eq (cdr (cdr ramo)) flores)
  @end example

  que devuelve @c{t} para verdad.

  Hasta que se resetea, @c{flores} todavía tiene el valor de @c{(violeta
  tulipan)}; que es, eso tiene la dirección de la celula cons cuya primera
  dirección es @c{violeta}. También, esto no altera cualquier célula
  prexistente cons; ellas está todavía allí.

  De este modo, en Lisp, tiene el @Cc{cdr} de una lista, se obtiene la
  dirección del siguiente cons en las serie; para tener el @Cc{car} de una
  lista, se obtiene la dirección del primer elemento de la lista; para
  @c{cons} un nuevo elemento en una lista, se añade una nueva célula cons al
  frente de la lista. ¡Esto es todo lo que hay así! ¡La estructura subyacente
  de Lisp es brillantemente simple!

  ¿Y qué hace la última dirección en una serie de células cons se refieren?
  Eso es la dirección de la lista vacía, de @c{nil}.

  En resumen, cuando una variable Lisp es asignada a un valor, eso provee con
  la dirección de la lista a la que la variable se refiere.

** Símbolos como una caja con cajones

   En una sección temprana, se sugería que se podría imaginar un símbolo
   siendo una caja con cajones. La definición de función se pone en un cajón,
   el valor en otro, y así. Lo que se pone en el cajón maneja el valor que
   puede cambiarse sin afectar a los contenidos del cajón manejando la
   definición de función, y viceversa.

   Actualmente, lo que está puesto en cada cajón es la dirección del valor o
   definición de función. Eso es como si se encontrara un viejo cajón en el
   ático, y en uno de sus cajones se encontrara un mapa dándote direcciones a
   donde está el tesoro escondido.

   (Además de su nombre, la definición del símbolo, y un valor de la
   variable, un símbolo tiene un ‘cajón’ para una @:{lista de propiedades}
   que puede ser usada para grabar otra información. Las listas de
   propiedades no se discuten aquí; ver @l{Listas de Propiedades, , Listas de
   Propiedades, elisp, El Manual de Referencia de Emacs Lisp}.)

   Aquí hay una representación visionaria:

   @diagram
                 Caja de Cajones            Contenidos de Cajones

                 __   o0O0o   __
               /                 \
              ---------------------
             |    direcciones al   |            [mapeo a]
             | nombre del simbolo  |            ramo
             |                     |
             +---------------------+
             |  direcciones a la   |
             |   definición del    |            [nunca]
             |    simbolo          |
             +---------------------+
             |    direcciones al   |            [mapeo a]
             |   valor de variable |            (rosa violeta tulipan)
             |                     |
             +---------------------+
             |    direcciones a la |
             |lista de propiedades |            [no descrito aquí]
             |                     |
             +---------------------+
             |/                   \|
   @end diagram

** Ejercicio

   Asignar @c{flores} a @c{violeta} y @c{tulipan}. Asigna dos flores más
   en esta lista y asigna esta nueva lista a @c{mas-flores}. Asigna el
   @Cc{car} de @c{flores} a un pez. ¿Qué lista contiene ahora @c{mas-flores}?

* Pegando texto

  Siempre y cuando se corta texto fuera de un búffer con un comando `kill’ en
  GNU Emacs, se puede traer con un comando ‘pegar’. El texto cortado del
  búffer es puesto en el anillo de la muerte y en los comandos pegar, se
  insertan los contenidos apropiados del kill ring detrás de un búffer (no
  necesariamente el búffer original).

  Un simple comando @k{C-y} (@c{yank}) inserta el primer ítem desde el anillo
  de la muerte @e{kill ring} dentro del actual búffer. Si el comando @k{C-y}
  es seguido inmediatamente para @k{M-y}, el primer elemento se reemplaza por
  el segundo elemento. Los sucesivos comandos @k{M-y} reemplazan el segundo
  elemento con el tercer, cuarto, o quinto elemento, y así. Cuando se llega
  al último elemento en el anillo de la muerte @e{kill ring}, se reemplaza
  por el primer elemento y el ciclo se repite. (De este modo, el kill ring se
  llama un ‘anillo’ en vez de solo una ‘lista’. Sin embargo, la estructura de
  de datos actual que maneja el texto es una lista. Véase Sección @l{Qué hace
  el anillo de la muerte, , Manejando el anillo de la muerte @e{kill ring}},
  para los detalles de cómo la lista es manejada como un anillo.)

** Resumen del anillo de la muerte

   El anillo de la muerte @e{kill ring} es una lista de cadenas
   textuales. Esto es lo que se ve:

   @example
     ("algún texto" "una pieza diferente pieza de texto"
     "todavía más texto")
   @end example

   Si estos fueran los contenidos de mi anillo de la muerte @e{kill ring} y
   yo presionara @k{C-y}, la cadena de caracteres diciendo @'{algún texto}
   sería insertado en este búffer donde mi cursor está localizado.

   El comando @c{yank} @e{pegar} es también usado para duplicar texto
   copiándolo. El texto copiado no es cortado desde el búffer, pero una copia
   de eso se pone en el anillo de la muerte @e{kill ring} y se inserta
   pegándolo.

   Tres funciones se usan para atraer texto desde el anillo de la muerte
   @e{kill ring}: @c{yank} (@e{pegar}), que normalmente se asocian a @k{C-y};
   @c{yank-pop}, que normalmente se asocia a @k{M-y}; y
   @c{rotate-yank-pointer}, que se usa por las otras dos funciones.

   Estas funciones se refieren al kill ring @e{anillo de la muerte} a través
   de una variable llamada el @c{kill-ring-yank-pointer}. En vez de eso, la
   inserción del código para ambos son las funciones @c{yank} y @c{yank-pop}:

   @example
     (insert (car kill-ring-yank-pointer))
   @end example

   (Bien, no más. En GNU Emacs 22, la función se ha reemplazado por
   @c{insert-for-yank} que llama a @c{insert-for-yank-1} repetitivamente para
   cada segmento @c{yank-handler}. En vez de eso, @c{insert-for-yank-1}
   destituye las propiedades de texto desde el texto insertado de acuerdo a
   @c{yank-excluded-properties}. De otro modo, eso es como
   @c{insert}. Nosotros lo pegamos con un @c{insert} plano puesto que sea
   fácil de comprender.)

   Para empezar a comprender cómo @c{yank} y @c{yank-pop} funcionan, primero
   es necesario mirar en la variable @c{kill-ring-yank-pointer}.

** La variable @c{kill-ring-yank-pointer}

   @c{kill-ring-yank-pointer} es una variable, solo como @c{kill-ring} es una
   variable. Eso apunta a alguna cosa siendo asignada al valor de lo que
   apunta, como cualquier otra variable Lisp.

   De este modo, si el valor del kill ring es:

   @example
     ("algún texto" "una pieza diferente pieza de texto"
     "todavía más texto")
   @end example

   y el @c{kill-ring-yank-pointer} apunta a la segunda cláusula, el valor de
   @c{kill-ring-yank-pointer} es:

   @example
     ("una pieza diferente de texto" "todavía más texto")
   @end example

   Como se explica en el capítulo previo (Véase Sección @l{Cómo se implementan
   las listas}), el ordenador no guarda dos copias diferentes del texto siendo
   apuntado por ambos el @c{kill-ring} (el @e{anillo de la muerte}) y el
   @c{kill-ring-yank-pointer} (el @e{puntero de pegar el anillo de la
   muerte}). Las palabras “una pieza diferente de texto” y “todavía más texto”
   no están duplicadas. En vez de eso, las dos variables Lisp apuntan a las
   mismas piezas de texto. Aquí hay un diagrama:

   @diagram
     kill-ring     kill-ring-yank-pointer
         |               |
         |      ___ ___  |     ___ ___      ___ ___
          ---> |   |   |  --> |   |   |    |   |   |
               |___|___|----> |___|___|--> |___|___|--> nil
                 |              |            |
                 |              |            |
                 |              |             --> "todavía más texto"
                 |              |
                 |               --> "una pieza diferente de texto"
                 |
                  --> "algo de texto"
   @end diagram

   Tanto la variable @c{kill-ring} y la variable @c{kill-ring-yank-pointer}
   son punteros. Pero el kill ring @e{anillo de la muerte} en sí es
   normalmente descrito como si fuera actualmente de lo que está
   compuesto. El @c{kill-ring} se refiere a lo que es la lista en vez de lo
   que apunta a la lista. Conversando, el @c{kill-ring-yank-pointer} se
   refiere a como se apunta a una lista.

   Estas dos maneras hablar acerca de la misma cosa suena confuso al
   principio pero tiene sentido para reflexionar. El kill ring @e{anillo de
   la muerte} es generalmente pensado como la estructura completa de datos
   que manejan la información de lo que se ha cortado reciéntemente de los
   búffers de Emacs. El @c{kill-ring-yank-pointer} en la otra mano, sirve
   para indicar --- que es, para ‘apuntar a’ --- esta parte del anillo de la
   muerte del que el primer elemento (el @Cc{car}) será insertado.

   @ignore
     In GNU Emacs 22, the @c{kill-new} function calls

     @c{(setq kill-ring-yank-pointer kill-ring)}

     (defun rotate-yank-pointer (arg)
       "Rotate the yanking point in the kill ring.
     With argument, rotate that many kills forward (or backward, if negative)."
       (interactive "p")
       (current-kill arg))

     (defun current-kill (n &optional do-not-move)
       "Rotate the yanking point by N places, and then return that kill.
     If N is zero, ‘interprogram-paste-function’ is set, and calling it
     returns a string, then that string is added to the front of the
     kill ring and returned as the latest kill.
     If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
     yanking point; just return the Nth kill forward."
       (let ((interprogram-paste (and (= n 0)
                                      interprogram-paste-function
                                      (funcall interprogram-paste-function))))
         (if interprogram-paste
             (progn
               ;; Disable the interprogram cut function when we add the new
               ;; text to the kill ring, so Emacs doesn't try to own the
               ;; selection, with identical text.
               (let ((interprogram-cut-function nil))
                 (kill-new interprogram-paste))
               interprogram-paste)
           (or kill-ring (error "Kill ring is empty"))
           (let ((ARGth-kill-element
                  (nthcdr (mod (- n (length kill-ring-yank-pointer))
                               (length kill-ring))
                          kill-ring)))
             (or do-not-move
                 (setq kill-ring-yank-pointer ARGth-kill-element))
             (car ARGth-kill-element)))))

   @end ignore

** Ejercicios con @c{yank} y @c{nthcdr}

   - Usando @k{C-h v} (@c{describe-variable}), mira en el valor de tu kill
     ring @e{anillo de la muerte}. Añade varios ítems a tu anillo de la
     muerte @e{kill ring}; mira en su valor de nuevo. Usando @k{M-y}
     (@c{yank-pop}, mueve todo el camino alrededor del kill ring @e{anillo de
     la muerte}. ¿Cuántos ítems estaban en tu kill ring @e{anillo de la
     muerte}? Encuentra el valor de @c{kill-ring-max}. ¿Estaba tu anillo de
     la muerte @e{kill ring} completo, o podrías haber guardado más bloques
     de texto dentro?

   - Usando @c{nthcrd} y @c{car}, construye una serie de expresiones para
     devolver, el primer, segundo, tercer y cuarto elemento de una lista.

* Bucles y recursión

  Emacs Lisp tiene dos caminos primarios para causar una expresión, o una
  serie de expresiones, para ser evaluado repetidamente: uno usa un bucle
  @c{while}, y el otro usa @:{recursión}.

  La repetición puede ser valorable. Por ejemplo, para mover hacia delante
  cuatro frases, tu solo necesitas escribir un programa que moverá hacia
  delante una frase y entonces repite el proceso cuatro veces. Ya que un
  ordenador no está aburrido o cansado, tal acción repetitiva no tiene los
  efectos de borrado por equivocación o exceso que pueden tener los humanos.

  La gente mayoritariamente escribe funciones de Emacs Lisp usando bucles
  @c{while}; pero se puede usar recursión, que provee un poderoso camino
  mental para resolver problemas@n{10}.

** @c{while}

   La forma especial @c{while} chequea si el valor devuelto para evaluar el
   primer argumento es verdadero o falso. Esto es parecido a lo que el
   intérprete Lisp hace con un @c{if}; el intérprete hace lo siguiente, sin
   embargo, es diferente.

   En una expresión @c{while}, si el valor devuelto por evaluar el primer
   argumento es falso, el intérprete Lisp descarta el resto de la expresión
   (el @:{cuerpo} de la expresión) y no la evalúa. Sin embargo, si el valor
   es cierto, el intérprete Lisp evalúa el cuerpo de la expresión y entonces
   de nuevo chequea si el primer argumento para @c{while} es cierto o
   falso. Si el valor devuelto de evaluar el primer argumento es cierto de
   nuevo, el intérprete Lisp evalúa el cuerpo de la expresión.

   La plantilla para una expresión @c{while} se ve así:

   @example
     (while @V{test-verdadero-o-falso}
       @V{cuerpo}…)
   @end example

   En el momento en el que el true-or-false-test de la expresión @c{while}
   devuelve un valor cierto cuando eso se evalúa, el cuerpo es repetidamente
   evaluado. Este proceso se llama bucle puesto que el intérprete Lisp repite
   la misma cosa una y otra vez, como un avión haciendo un loop. Cuando el
   resultado de evaluar el true-or-false-test es falso, el intérprete Lisp no
   evalúa el resto de la expresión @c{while} y ‘existe el bucle’.

   Claramente, si el valor devuelto evaluando el primer argumento para
   @c{while} es siempre cierto, el cuerpo siguiente será evaluado una y otra
   vez … y … para siempre. Recíprocamente, si el valor devuelto nunca es
   cierto, las expresiones en el cuerpo nunca serán evaluadas. La fortaleza
   de escribir un bucle @c{while} consiste de elegir un mecanismo tal que el
   true-or-false-test devuelva cierto solo el número de veces que requieren
   las subsiguientes expresiones para ser evaluadas, y entonces tener el test
   devuelto a falso.

   El valor devuelto evaluando @c{while} es el valor del
   true-or-false-test. Una consecuencia interesante de esto es que un bucle
   @c{while} que evalúa sin errores devolverá @c{nil} o falso sin dignidad de
   si eso ha girado 1 o 100 veces o ninguna. ¿Una expresión @c{while} que se
   evalúa de manera exitosa nunca devuelve un valor cierto! Lo que esto
   significa es que @c{while} es siempre evaluado por sus efectos laterales,
   que es decir, las consecuencias de evaluar las expresiones con el cuerpo
   del bucle @c{while}. Esto tiene sentido. Eso no es el mero acto del bucle
   que es deseado, pero las consecuencias de lo que ocurre cuando las
   expresiones en el bucle son repetidamente evaluadas.

*** Un bucle @c{while} y una lista

    Un camino común para controlar un bucle @c{while} es chequear si una
    lista tiene cualquier elemento. Si eso se hace, el bucle se repite; pero
    si no, la repetición se finaliza. Puesto que esto es una técnica
    importante, se creará un breve ejemplo para ilustrarlo.

    Un camino simple para chequear si una lista tiene elementos es evaluar la
    lista: si eso no tiene elementos, si es una lista vacía y devuelve la
    lista vacía, @c{()}, que es un sinónimo para @c{nil} o falso. Por otro
    lado, una lista con elementos devolverá estos elementos cuando eso se
    evalúa. Puesto que Emacs Lisp considera como cierto cualquier valor que
    no es @c{nil}, una lista que devuelve elementos chequeará cierto en un
    bucle @c{while}.

    Por ejemplo, se puede asignar la variable @c{empty-list} a @c{nil} para
    evaluar la siguiente expresión @c{setq}:

    @example
      (setq lista-vacia ())
    @end example

    Después de evaluar la expresión @c{setq}, se puede evaluar la variable
    @c{lista-vacia} es el camino normal, posicionando el cursor después del
    símbolo y escribiendo @k{C-x C-e}; @c{nil} aparecerá en tu área echo:

    @example
      lista-vacia
    @end example

    Por otro lado, si se asigna una variable para ser una lista con
    elementos, la lista aparecerá cuando se evalúe la variable, como se puede
    ver evaluando las siguientes dos expresiones:

    @example
      (setq animales '(gacela jirafa leon tigre))

      animales
    @end example

    De este modo, para un bucle @c{while} que chequea si hay cualquier ítem
    en la lista @c{animales}, la primera parte del bucle será escrito así:

    @example
      (while animales
             …
    @end example

    Cuando el @c{while} chequea su primer argumento, la variable @c{animales}
    se evalúa. Eso devuelve una lista. Mientras la lista tiene elementos, el
    @c{while} considera los resultados del test para ser verdadero; pero
    cuando la lista es vacía, eso considera los resultados del test para ser
    falso.

    Para prevenir que el bucle @c{while} se ejecute siempre, se necesita
    proporcionar algún mecanismo. Una técnica usada con frecuencia es tener
    una de las subsiguientes formas en la expresión @c{while} que asigna el
    valor de la lista para ser el @Cc{cdr} de la lista. Cada vez que la
    función @c{cdr} se evalúa, se va reduciendo, hasta que finalmente solo
    queda la lista vacía. En este punto, el test del bucle @c{while}
    devolverá falso, y los argumentos para el @c{while} no se evaluarán.

    Por ejemplo, la lista de animales asociada a la variable @c{animals} se
    puede asignar a ser el @Cc{cdr} de la lista original con la siguiente
    expresión:

    @example
      (setq animals (cdr animals))
    @end example

    Si se han evaluado las expresiones previas y entonces se evalúa esta
    expresión, se verá @c{(jirafa leon tigre)} que aparecerá en el área
    echo. Si se evalúa la expresi@'n de nuevo, @c{(leon tigre)} aparecerá en
    el área echo. Si se evalúa de nuevo, @c{(tigre)} y todavía de nuevo
    aparecerá la lista vacía y se mostrará como @c{nil}.

    Una plantilla para un bucle @c{while} usa la función @c{cdr}
    repetidamente para causar el true-or-false-test finalmente para chequear
    la veracidad y se parece a esto:

    @example
      (while @V{test-whether-list-is-empty}
        @V{body}…
        @V{set-list-to-cdr-of-list})
    @end example

    Este chequeo y uso de @c{cdr} puede ser puesto junto a una función que va
    a través de una lista e imprime cada elemento de la lista en una línea de
    sí misma.

*** Un ejemplo: @c{imprimir-elementos-de-la-lista}

    La función @c{imprimir-elementos-de-la-lista} ilustra un bucle @c{while}
    con una lista.

    La función requiere varias líneas por su salida. Si estás leyendo esto en
    una instancia reciente de GNU Emacs, se puede evaluar la siguiente
    expresión dentro de Info, de normal.

    Si se está usando una versión antigua de Emacs, es necesario copiar las
    expresiones necesarias para el búffer @f{*scratch*} y evaluarlas
    allí. Esto es porque el área echo tenía solo una línea en las versiones
    antiguas.

    Se pueden copiar las expresiones marcando el principio de la región con
    @k{C-@k{SPC}} (@c{set-mark-command}), moviendo el cursor al fin de la
    región y entonces copiando la región usando @k{M-w} (@c{kill-ring-save},
    que llama a @c{copy-region-as-kill} y entonces provee realimentación
    visual). En el búffer @f{*scratch*}, se pueden copiar las expresiones
    escribiendo @k{C-y} (@c{yank}).

    Después de haber copiado las expresiones al búffer @f{*scratch*}, se
    evalúa cada expresión en orden. Asegúrese de evaluar la última expresión,
    @c{(imprimir-elementos-de-la-lista animales)}, escribiendo @k{C-u C-x
    C-e}, que es, dando un argumento para @c{eval-last-sexp}. Esto causará el
    resultado de la evaluación para ser impreso en el búffer @f{*scratch*} en
    vez de siendo impreso en el área echo. (De otro modo se verá alguna cosa
    como esto en tu área echo: @c{^Jgacela^J^Jjirafa^J^Jleon^J^Jtigre^Jnulo},
    en cada @'{^J} se estructura una ‘nueva línea’.)

    En una instancia de GNU Emacs reciente, se pueden evaluar estas
    expresiones directamente en el búffer Info, y el área echo crecerá para
    mostrar los resultados.

    @example
      (setq animales '(gacela jirafa leon tigre))

      (defun imprimir-elementos-de-la-lista (list)
        "Imprime cada elemento de LIST en una línea."
        (while list
          (print (car list))
          (setq list (cdr list))))

      (imprimir-elementos-de-la-lista animales)
    @end example

    Cuando se evalúan las tres expresiones en secuencia, se verá esto:

    @example
      gacela

      jirafa

      leon

      tigre
      nil
    @end example

    Cada elemento de la lista se imprime en una línea en sí (que es lo que la
    función @c{print} hace) y entonces el valor devuelto por la función se
    imprime. Desde que la última expresión en la función es el bucle
    @c{while}, y desde que el bucle @c{while} siempre devuelve @c{nil}, un
    @c{nil} se imprime después del último elemento de la lista.

*** Un bucle con un contaje incremental

    Un bucle no es útil a menos que pare cuando debe. Bajo el control de un
    bucle con una lista, un camino común de parar un bucle es escribir el
    primer argumento como un test que devuelve falso cuando el número
    correcto de repeticiones es completo. Esto significa que el bucle debe
    tener un contador––una expresión que cuenta cuántas veces el bucle se
    repite a sí mismo.

    El test para un bucle con un contador de incremento puede ser una
    expresión tal como @c{(< contador numero-deseado)} que devuelve @c{t}
    para verdad si el valor de @c{contador} es menor que el
    @c{numero-deseado} de repeticiones y @c{nil} para falso si el valor de
    @c{contador} es igual a o es mayor que el @c{numero-deseado}. La
    expresión que incrementa el contador puede ser un simple @c{setq} tal
    como @c{(setq contador (1+ contador))}, donde @c{1+} es una función
    construida en Emacs Lisp que añade 1 a su argumento. (La expresión @c{(1+
    contador)} tiene el mismo resultado que @c{(+ contador 1)}, que es fácil
    de leer para un humano.)

    La plantilla para un bucle @c{while} controlado por un contador que se
    incrementa se parece a esto:

    @example
      @V{asignar-contador-al-valor-inicial}
      (while (< contador numero-deseado)         ; @e{true-or-false-test}
        @V{body}…
        (setq contador (1+ contador)))              ; @e{incremento}
    @end example

    Note que se necesita asignar el valor inicial de @c{contador};
    normalmente asignado a 1.

**** Ejemplo con contador incremental

     Supón que estás jugando en la playa y decides crear un triángulo de
     asteriscos, poniendo un asterisco en la primera fila, dos en la segunda
     fila, tres en la tercera fila y así:

     @example
                      *
                     * *
                    * * *
                   * * * *
     @end example

     (Hace 2500 años, Pitágoras y otras desarrollaron los principios de la
     teoría de números considerando preguntas como esta.)

     Supón que quieres saber cuántos asteriscos necesitarás crear para un
     triángulo con 7 filas

     Claramente, lo que necesitas hacer es añadir los números de 1 a 7. Hay
     dos caminos para hacer esto; se puede comenzar con los números más
     pequeños, uno, y añadir la lista en secuencia, 1, 2, 3, 4 y así; o
     empieza con el número más largo y añade la lista bajando: 7, 6, 5, 4 y
     así. Porque ambos mecanismos ilustran caminos comunes de escribir el
     bucle @c{while}, crearemos dos ejemplos, uno contando hacia arriba y el
     otro contando hacia abajo. En este primer ejemplo, empezaremos con 1 y
     añadimos 2, 3, 4 y así.

     Si se quiere sumar toda una lista de números, el camino más fácil para
     hacer eso es sumar todos los números a la vez. Sin embargo, si no se
     sabe cuántos números tendrá la lista, o si se requiere estar preparado
     para una lista muy larga, entonces se necesita diseñar la adición, esto
     es, repetir un proceso simple muchas veces en vez de hacer un proceso
     más complejo.

     Por ejemplo, en vez de añadir todos los asteriscos a la vez, lo que se
     puede hacer es añadir el número de asteriscos en la primera fila, 1,
     para el número en la segunda fila, 2, y entonces añadir el total de
     estas dos filas a la tercera fila, 3. Entonces se puede añadir el número
     en la cuarta fila, 4, al total de las primeras tres filas; y así.

     La característica crítica del proceso es que cada acción repetitiva sea
     simple. En este caso, en cada paso nosotros añadimos solo dos números,
     el número de asteriscos en la fila y el total ya encontrado. Este
     proceso de añadir dos números es repetido de nuevo y de nuevo hasta la
     última fila que ha sido añadida al total de todas las filas
     precedentes. En un bucle más complejo la acción repetitiva podría no ser
     tan simple, pero será tan simple como hacer todo a la vez.

**** Las partes de la definición de función

     El análisis precedente nos da los bonos de nuestra definición de
     función: primero, necesitaremos una variable que podemos llamar
     @c{total} que será el número total de asteriscos. Esto será el valor
     devuelto por la función.

     Segundo, sabemos que la función requerirá un argumento: este argumento
     será el número de filas en el triángulo. Eso puede llamarse
     @c{number-of-rows}.

     Finalmente, se necesita una variable para usarse como contador. Se
     podría llamar a esta variable @c{counter}, pero un nombre mejor es
     @c{row-number}. Debido a que lo que el contador hace en esta función es
     contar filas, y un programa debería escribirse para ser comprendido en
     la medida de lo posible.

     Cuando el intérprete Lisp primero empieza evaluando las expresiones de
     la función, el valor de @c{total} estaría asignado a cero, ya que no
     hemos añadido cualquier cosa a eso. Entonces la función añadiría el
     número de asteriscos en la primera fila al total, y entonces añade el
     número de asteriscos en la segunda al total, y entonces añade el número
     de asteriscos a la tercera fila al total, y así, hasta que no hay más
     filas a la izquierda para añadir.

     Ambos @c{total} y @c{row-number} se usan solo dentro de la función, así
     ellos pueden ser declarados como variables locales con @c{let} y valores
     iniciales dados. Claramente, el valor inicial para total sería 0. El
     valor inicial de @c{row-number} sería 1, desde que se comienza con la
     primera fila. Esto significa que la frase @c{let} se parece a esto:

     @example
         (let ((total 0)
               (row-number 1))
           @V{body}…)
     @end example

     Después de que las variables internas se declaran y se asignan a sus
     valores iniciales se podría empezar el bucle @c{while}. La expresión que
     sirve como el test devolvería un valor de @c{t} para la verdad tan
     grande como el @c{row-number} que es menor o igual al
     @c{number-of-rows}. (La expresión devuelve cierto solo si el número de
     fila es menor que el número de filas en el triángulo, la última fila
     nunca será añadida al total; aquí el número de fila tiene que ser menor
     o igual el número de filas.))

     Lisp provee la función @c{<=} que devuelve cierto si el valor de su
     primer argumento es menor o igual al valor de su segundo argumento y
     falso de otro modo. Así la expresión que el @c{while} evaluará como si
     su test se vería como esto:

     @example
       (<= row-number number-of-rows)
     @end example

     El número de asteriscos puede encontrarse repetidamente añadiendo el
     número de asteriscos en una fila al total ya encontrado. Puesto que el
     número de asteriscos en la fila es igual al número de la fila, el total
     puede encontrarse añadiendo el número de filas al total. (Claramente, en
     una situación más compleja, el número de asteriscos en la fila podría
     ser relacionada al número de la fila en un camino más complicado; si
     este fuera el caso, el número de fila sería reemplazado por la expresión
     apropiada.)

     @example
       (setq total (+ total row-number))
     @end example

     Lo que esto hace es asignar el nuevo valor de @c{total} a ser igual a la
     suma de añadiendo el número de asteriscos en la fila al total previo.

     Después de configurar el valor de @c{total}, las condiciones deben ser
     establecidas para la siguiente repetición del bucle, si hay alguna. Esto
     se hace incrementando el valor de la variable @c{row-number}, que sirve
     como un contador. Después que la variable @c{row-number} ha sido
     incrementada, el true-or-false-test al principio del bucle @c{while}
     chequea si su valor es todavía menor o igual al valor del
     @c{number-of-rows} y si eso es, añade el nuevo valor de la variable
     @c{row-number} al @c{total} de la repetición del bucle.

     La función construida en Emacs Lisp @c{1+} añade 1 a un número, así la
     variable @c{row-number} puede ser incrementado con esta expresión:

     @example
       (setq row-number (1+ row-number))
     @end example

**** Poniendo la definición de la función junta

     Nosotros hemos creado las partes para la definición de la función; ahora
     necesitamos ponerlas juntas.

     Primero, los contenidos de la expresión @c{while}:

     @example
       (while (<= row-number number-of-rows)   ; @e{true-or-false-test}
         (setq total (+ total row-number))
         (setq row-number (1+ row-number)))    ; @e{incremento}
     @end example

     Tener la expresión @c{let} de varlist, se acerca a completar el cuerpo
     de la definición de función. Sin embargo, eso requiere un elemento
     final, la necesidad para la que es alguna cosa pequeña.

     El toque final es emplazar la variable @c{total} en una línea por sí
     misma después de la expresión @c{while}. De otro modo, el valor devuelto
     por la función completa es el valor de la última expresión que es
     evaluada en el cuerpo del @c{let}, y este es el valor devuelto por el
     @c{while} que es siempre @c{nil}.

     Esto puede no ser evidente a primera vista. Eso casi se ve como si la
     expresión de incremento es la última expresión de la función
     completa. Pero esta expresión es parte del cuerpo del @c{while}; eso es
     el último elemento de la lista que empieza con el símbolo @c{while}. Más
     allá, el bucle @c{while} completo es una lista con el cuerpo del
     @c{let}.

     En línea (@e{outline}), la función se parece a esto:

     @example
       (defun @V{name-of-function} (@V{argument-list})
         "@V{documentation}…"
         (let (@V{varlist})
           (while (@V{true-or-false-test})
             @V{body-of-while}… )
           … ))                    ; @e{Necesita la expresión final aquí.}
     @end example

     El resultado de evaluar el @c{let} es que lo que está yendo para
     devolver el @c{defun} desde el @c{let} que no está embebido con
     cualquier lista que contiene, excepto para la @c{defun} como un
     todo. Sin embargo, si el @c{while} es el último elemento de la expresión
     @c{let}, la función siempre devolverá @c{nil}. ¡Esto no es lo que
     quiero! En vez de eso, lo que queremos es el valor de la variable
     @c{total}. Eso devuelve simplemente emplazando el símbolo como el último
     elemento de la lista empezando con @c{let}. Eso se evalúa después de los
     elementos precedentes de la lista evaluada, que significa que eso se
     evaluó después de haber sido asignado el valor correcto para el total.

     Eso puede ser fácil de ver imprimiendo la lista empezando con @c{let}
     todo en una línea. Este formato hace evidente que las expresiones
     @V{varlist} y @c{while} son el segundo el tercer elementos de la lista
     empezando con @c{let}, y el @c{total} es el último elemento:

     @example
       (let (@V{varlist}) (while (@V{true-or-false-test})
       @V{body-of-while}… ) total)
     @end example

     Poniendo cualquier cosa junta, la definición de función @c{triangle} se
     parece a esto:

     @example
       (defun triangle (number-of-rows)    ; @e{Versión con}
                                           ; @e{ contador de incremento.}
         "Añade el número de asteriscos en un triángulo.
       La primera fila tiene un asterisco, la segunda fila dos asteriscos,
       la tercera fila tres asteriscos, y así.
       El argumento es NUMBER-OF-ROWS."
         (let ((total 0)
               (row-number 1))
           (while (<= row-number number-of-rows)
             (setq total (+ total row-number))
             (setq row-number (1+ row-number)))
           total))
     @end example

     Después de haber instalado @c{triangle} para evaluar la función, se
     puede probar. Aquí hay dos ejemplos:

     @example
       (triangle 4)

       (triangle 7)
     @end example

     La suma del primero de cuatro números es 10 y la suma de los primeros
     siete números es 28.

*** Bucle que se decrementa

    Otro camino común para escribir un bucle @c{while} es escribir el test
    así que determina si un contador es mayor que cero. Así tan largo es el
    contador mayor que cero, el bucle se repite. Pero cuando el contador es
    igual o menor que cero, el bucle se para. Para este trabajo, el contador
    tiene que empezar mayor que cero y entonces se hace más pequeño y pequeño
    por una forma que es evaluada repetidamente.

    El test será una expresión tal como @c{(> counter 0)} que devuelve @c{t}
    @e{cierto} si el valor de @c{counter} es mayor que cero, y @c{nil}
    @e{falso} si el valor de @c{counter} es igual a o menor que cero. La
    expresión hace que el número menor y menor puede ser un simple @c{setq}
    tal como @c{(setq counter (1- counter)}, donde @c{1-} es una función
    construida en Emacs Lisp que sustrae 1 de su argumento.

    La plantilla para decrementar el bucle @c{while} se ve así:

    @example
      (while (> counter 0)                    ; @e{test-verdadero-o-falso}
        @V{body}…
        (setq counter (1- counter)))          ; @e{decremento}
    @end example

**** Ejemplo con el contador que se decrementa

     Para ilustrar un bucle con un contador de decremento, reescribirá la
     función @c{triangle} así como el contador se decrementa a cero.

     Esto es lo inverso de la versión temprana de la función. En este caso,
     para encontrar cuántos asteriscos son necesarios para crear un triángulo
     con 3 filas, añade el número de asteriscos en la tercera fila, 3, para
     el número en la fila precedente, 2, y entonces añade el total de estas
     dos filas a la fila que lo precede, 1.

     Más allá, para encontrar el número de asteriscos en un triángulo con 7
     filas, añade el número de asteriscos en la fila siete, 7, al número en
     la fila precedente, que es 6, y entonces añade el total de estas dos
     filas a la fila esta que lo precede, que es 5, y así. Como en el ejemplo
     previo, cada adición solo involucra la adición de dos números, el total
     de las filas ya se añadió y el número de asteriscos en la fila que está
     siendo añadida al total. Este proceso de añadir dos números se repite de
     nuevo y de nuevo hasta que no haya más asteriscos que añadir.

     Sabemos con cuántos asteriscos empezar: el número de asteriscos en la
     última fila es igual al número de filas. Si el triángulo tiene siete
     filas, el número de asteriscos en la última fila es 7. Más allá, sabemos
     cuántos asteriscos están en la fila precedente: eso es uno menos que el
     número en la fila.

**** Las partes de la definición de función

     Empezamos con tres variables: el número total de filas en el triángulo;
     el número de asteriscos en una fila; y el número total de asteriscos,
     que es lo que queremos calcular. Estas variables pueden llamarse
     @c{number-of-rows}, @c{number-of-pebbles-in-row}, y @c{total},
     respectivamente.

     Ambos @c{total} y @c{number-of-pebbles-in-row} se usan solo dentro de la
     función y se declaran con @c{let}. El valor inicial de @c{total} sería
     cero. Sin embargo, el valor inicial de @c{number-of-pebbles-in-row}
     sería igual al número de filas en el triángulo, desde la adición
     empezará con la fila más larga.

     Esto significa que el principio de la expresión @c{let} se verá así:

     @example
       (let ((total 0)
             (number-of-pebbles-in-row number-of-rows))
         @V{body}…)
     @end example

     El número total de asteriscos puede encontrarse repetidamente añadiendo
     el número de asteriscos en una fila para el total ya encontrado, que, se
     evalúa repetidamente en la siguiente expresión:

     @example
       (setq total (+ total number-of-pebbles-in-row))
     @end example

     Después el @c{number-of-pebbles-in-row} se añade al @c{total}, el
     @c{number-of-pebbles-in-row} sería decrementado por uno, desde que la
     siguiente vez el bucle repite, la fila precedente será añadida al total.

     El número de asteriscos en una fila precedente es uno menos que el
     número de asteriscos en una fila, así la función Emacs Lisp construida
     @c{1-} puede usarse para computar el número de asteriscos de la fila
     precedente. Esto puede ser hecho con la siguiente expresión:

     @example
       (setq number-of-pebbles-in-row
             (1- number-of-pebbles-in-row))
     @end example

     Finalmente, sabemos que el bucle @c{while} pararía creando repetidas
     adiciones cuando no hay asteriscos en una fila. Así el test para el
     bucle @c{while} es simple:

     @example
       (while (> number-of-pebbles-in-row 0)
     @end example

**** Poniendo la definición de la función junta

     Se pueden poner estas expresiones juntas para crear una definición de
     función que funcione. Sin embargo, al examinarlas, encontraremos que una
     de la variables locales ¡es innecesaria!

     La definición de función se ve como esto:

     @example
       ;;; @e{Primero la versión substractiva.}
       (defun triangle (number-of-rows)
         "Añade el número de asteriscos en un triángulo."
         (let ((total 0)
               (number-of-pebbles-in-row number-of-rows))
           (while (> number-of-pebbles-in-row 0)
             (setq total (+ total number-of-pebbles-in-row))
             (setq number-of-pebbles-in-row
                   (1- number-of-pebbles-in-row)))
           total))
     @end example

     Como se dijo, esta función funciona.

     Sin embargo, no se necesita @c{number-of-pebbles-in-row}.

     Cuando la función @c{triangle} se evalúa, el símbolo @c{number-of-rows}
     será asociado al número, dando un valor inicial. Este número puede ser
     cambiado en el cuerpo de la función si hubiera una variable local, sin
     miedo de que tal cambio se efectuará el valor de la variable fuera de la
     función. Esto es una característica muy útil de Lisp; eso significa que
     la variable @c{number-of-rows} puede ser usada en cualquier lugar en la
     función donde @c{number-of-pebbles-in-row} se usa.

     Aquí hay una segunda versión de la función escrita un poco más
     limpiamente:

     @example
       (defun triangle (number)                ; @e{Segunda versión.}
         "Devuelve la suma de números 1 a través de NUMBER inclusive."
         (let ((total 0))
           (while (> number 0)
             (setq total (+ total number))
             (setq number (1- number)))
           total))
     @end example

     En breve, un bucle @c{while} apropiadamente escrito consistirá de tres
     partes:

     1. Un test que devuelva falso después de que el bucle ha repetido por sí
        mismo el número de veces correcto.

     2. Una expresión de la evaluación de que devolverá el valor deseado
        después de ser repetidamente evaluado.

     3. Una expresión para cambiar el valor pasado al true-or-false-test así
        el test devuelve falso después de que el bucle se ha repetido por sí
        mismo el número de veces correcto.

** Ahorra tiempo: @c{dolist} y @c{dotimes}

   Además de @c{while}, tanto @c{dolist} como @c{dotimes} proveen un
   bucle. Algunas veces estos son rápidos para escribir el bucle equivalente
   @c{while}. Ambos son macros Lisp. (Véase Sección @"(Macros) en @e(El
   Manual de Referencia GNU Emacs Lisp).)

   @c{dolist} funciona como un bucle @c{while} con ‘@Cc{cdr}s que bajan la
   lista’: @c{dolist} automáticamente ordena la lista cada vez que la lista
   hace bucles––toma la @Cc{cdr} de la lista––y asocia el @Cc{car} de cada
   versión ordenada de la lista al primero de sus argumentos.

   @c{dotimes} repite el bucle un número específico de veces: tu especificas
   el número.

*** La macro @c{dolist}

    Supón, por ejemplo, que quieres invertir una lista, así que “primero”,
    “segundo”, “tercero” llega a ser “tercero”, “segundo”, “primero”.

    En la práctica, usarías la función @c{reverse}, como esta:

    @example
      (setq animales '(gacela jirafa leon tigre))

      (reverse animales)
    @end example

    Aquí se ve cómo se podría invertir la lista usando un bucle @c{while}:

    @example
      (setq animales '(gacela jirafa leon tigre))

      (defun reverse-list-with-while (list)
        "Usando while, invierte el orden de LIST."
        (let (value)  ; asegura que la lista comienza vacía
          (while list
            (setq value (cons (car list) value))
            (setq list (cdr list)))
          value))

      (reverse-list-with-while animales)
    @end example

    Y aquí se ve cómo podría usarse la macro @c{dolist}:

    @example
      (setq animales '(gacela jirafa leon tigre))

      (defun reverse-list-with-dolist (list)
        "Usando dolist, reverse, la orden de la LISTA."
        (let (value)  ; asegura que la lista empieza vacía
          (dolist (element list value)
            (setq value (cons element value)))))

      (reverse-list-with-dolist animals)
    @end example

    En Info, se puede localizar su cursor después de cerrar paréntesis de
    cada expresión y escribir @k{C-x C-e}; en cada caso, se vería

    @example
      (tigre leon jirafa gacela)
    @end example

    en el área echo.

    Para este ejemplo, la función @c{reverse} existente es obviamente la
    mejor. El bucle @c{while} es solo como nuestro primer ejemplo (vease
    Seccion @l{Un bucle @c{while} y una lista}). El @c{while} primero chequea
    si la lista tiene elementos; si es así, eso construye una nueva lista
    añadiendo el primer elemento de la lista a la lista existente (que en la
    primera iteración del bucle es @c{nil}). Puesto que el segundo elemento
    está asignado en frente del segundo elemento, la lista es inversa.

    En la expresión que usa el bucle @c{while}, la expresión @c{(setq list
    (cdr list))} ordena la lista, así el bucle @c{while} finalmente
    para. Además, se proporciona la expresión @c{cons} con un nuevo primer
    elemento creando una nueva lista y se ordena en cada repetición del
    bucle.

    La expresión @c{dolist} hace lo mismo que la expresión @c{while}, excepto
    que la macro @c{dolist} hace algo del trabajo que se tiene que hacer
    cuando se escribe una expresión @c{while}.

    Al igual que el bucle @c{while}, tenemos el bucle @c{dolist}. Lo que es
    diferente es que automáticamente ordena la lista cada vez que se
    repite––eso es ‘recorrer los @Cc{cdr}s de la lista’ en sí––y eso
    automáticamente asocia el @Cc{car} de cada versión ordenada de la lista
    al primero de sus argumentos.

    En el ejemplo, el @Cc{car} de cada versión ordenada de la lista se
    refiere a usar el símbolo @'{element}, la lista en sí se llama @'{list},
    y el valor devuelto se llama @'{value}. El resto de la expresión
    @c{dolist} es el cuerpo.

    La expresión @c{dolist} asocia el @Cc{car} de cada versión ordenada de la
    lista al @c{element} y entonces evalúa el cuerpo de la expresión y repite
    el bucle. El resultado es devuelto en @c{value}.

*** La macro @c{dotimes}

    La macro @c{dotimes} es similar a @c{dolist}, excepto que el bucle se
    repite un número específico de veces.

    El primer argumento @c{dotimes} se asigna a los números 0, 1, 2 y así
    vuelve al bucle, y el valor del tercer argumento se devuelve. Se necesita
    proveer el valor del segundo argumento, que es cuántas veces la macro
    hace el bucle.

    Por ejemplo, lo siguiente asocia los números de 0 en adelante, pero no
    incluyendo, el número 3 al primer argumento, @V{número}, y entonces
    construye una lista de los tres números. (El primer número es 0, el
    segundo número es 1, y el tercer número es 2; esto crea un total de tres
    números en todo, empezando con cero como el primer número.)

    @example
      (let (value)      ; de otro modo un valor es una variable vacía
        (dotimes (number 3 value)
          (setq value (cons number value))))

      ⇒ (2 1 0)
    @end example

    @c{dotimes} devuelve @c{value}, así el camino para usar @c{dotimes} es
    para operar en alguna expresión el número de veces @V{number} y
    entonces devolver el resultado, como una lista o un átomo.

    Aquí hay un ejemplo de una @c{defun} que usa @c{dotimes} para añadir el
    número de asteriscos en un triángulo.

    @example
      (defun triangle-using-dotimes (number-of-rows)
        "Usando dotimes, añade el número de asteriscos en un triángulo."
      (let ((total 0))  ; de otro modo un total es una variable vacía
        (dotimes (number number-of-rows total)
          (setq total (+ total (1+ number))))))

      (triangle-using-dotimes 4)
    @end example

** Recursión

   Una función recursiva contiene código que hace que el intérprete Lisp
   llame a un programa que ejecute el código en sí, pero con argumentos
   ligeramente diferentes. El código ejecuta exactamente lo mismo porque eso
   tiene el mismo nombre. Sin embargo, incluso aunque el programa tenga el
   mismo nombre, no es la misma entidad. Eso es diferente. En la jerga, se
   dice es una ‘instancia’ diferente.

   Finalmente, si el programa se escribe correctamente, los ‘argumentos
   ligeramente diferentes’ llegan a ser suficientemente diferentes puesto que
   los primeros argumentos de la instancia final se pararán.

*** Construyendo robots: Extendiendo la metáfora

    Algunas veces es útil pensar en un programa en ejecución como un robot
    que hace un trabajo. Haciendo su trabajo, una función recursiva llama a
    un segundo robot para que le ayude. El segundo robot es idéntico al
    primero en cada paso, excepto que el segundo robot ayuda al primero y se
    han pasado diferentes argumentos en vez del primero.

    En una función recursiva, el segundo robot puede llamar a un tercero; y
    el tercero puede llamar a un cuarto, y así. Cada una de estos es una
    entidad diferente; pero todos son clones.

    Desde que cada robot tiene instrucciones ligeramente diferentes --- los
    argumentos diferirán desde un robot al siguiente––el último robot
    conocería cuando pare.

    Permite expandir la metáfora en el que un programa de ordenador es un
    robot.

    Una definición de función provee impresiones para un robot. Cuando se
    instala una definición de función, que es, cuando se evalúa una forma
    especial @c{defun}, se instala el equipamiento para construir robots. Eso
    es como si tu estuvieras en una fábrica, configurando una línea de
    ensamblaje. Los robots con el mismo nombre son construidos de acuerdo a
    las mismas impresiones. Así ellos tienen, como estaban, el mismo ‘número
    de modelo’, pero un diferente ‘número de serie’.

    Nosotros con frecuencia decimos que una función recursiva ‘se llama así
    misma’. Esto significa que las instrucciones en una función recursiva
    causa que el intérprete de Lisp ejecute una función diferente que tiene
    el mismo nombre y hace el mismo trabajo que el primero, pero con
    diferentes argumentos.

    Es importante que los argumentos difieran desde una instancia a la
    siguiente; de otro modo, el proceso nunca parará.

*** Las partes de una definición recursiva

    Una función recursiva típicamente contiene una expresión condicional que
    tiene tres partes:

    1. Un true-or-false-test que determina si la función se llama de nuevo,
       aquí se llama el @:{do-again-test}.

    2. El nombre de la función. Cuando este nombre se llama, es una nueva
       instancia de la función––un nuevo robot, así––se crea y se dice qué
       hacer.


    3. Una expresión que devuelve un valor diferente cada vez que la función
       se llama, aquí llamada la @:{next-step-expression}. Consecuentemente,
       el argumento (o argumentos) pasados a la nueva instancia de la función
       serán diferentes puesto que se pasa a la instancia previa. Esto causa
       la expresión condicional, que el @:{do-again-test}, devuelva falso
       después del número correcto de repeticiones.


    Las funciones recursivas pueden ser más simples que cualquier otro tipo
    de funciones. De manera profunda, cuando la gente empieza a usarlas, con
    frecuencia se miran así misteriosamente de manera tan simple como
    incompresible. Como montar en bicicleta, leer una función recursiva es
    duro al principio, pero después es simple.

    Hay varios patrones recursivos diferentes. Un patrón muy simple se parece
    a:

    @example
      (defun @V{name-of-recursive-function} (@V{argument-list})
        "@V{documentation}…"
        (if @V{do-again-test}
          @V{body}…
          (@V{name-of-recursive-function}
               @V{next-step-expression})))
    @end example

    Cada vez que una función recursiva es evaluada, una nueva instancia se
    crea y se dice qué hacer. Los argumentos le dicen a la instancia qué
    hacer.

    Un argumento se empareja al valor de la next-step-expresion. Cada
    instancia se ejecuta con un valor diferente de la next-step-expression.

    El valor en la next-step-expression es usado en la do-again-test.

    El valor devuelto por la next-step-expression es pasada a las nuevas
    instancias de la función, que lo evalúa (o alguna transformación de eso)
    para determinar si continuar o parar. El next-step-expression está
    diseñado así que el do-again-test devuelve falso cuando la función no se
    repetiría mucho.

    El do-again-test es algunas veces llamado la @:{condición de parar},
    puesto que sirve para parar las repeticiones cuando se devuelve falso.

*** Recursión con una lista

    El ejemplo de un bucle @c{while} que imprimió los elementos de una lista
    de números puede ser escrito recursivamente. Aquí está el código,
    incluyendo una expresión para asignar el valor de la variable
    @c{animales} a una lista.

    Si está leyendo esto en el Info de Emacs, se puede evaluar esta expresión
    directamente en Info. De otro modo, se debe copiar el ejemplo al búffer
    @f{*scratch*} y evalúa cada expresión aquí. Usa @k{C-u C-x C-e} para
    evaluar la expresión @c{(print-elements-recursively animals)} así que los
    resultado se imprimen en el búffer; de otro modo el intérprete Lisp
    intentará presionar los resultados dentro de una línea del área echo.

    También, posiciona tu cursor inmediatamente después del último paréntesis
    que cierra la función @c{print-elements-recursively}, antes del
    comentario. De otro modo, el intérprete Lisp intentará evaluar el
    comentario.

    @example
      (setq animales '(gacela jirafa leon tigre))

      (defun print-elements-recursively (list)
        "Imprime cada elemento de la LISTA de la línea en
        sí. Usa recursión."
        (when list                            ; @e{do-again-test}
              (print (car list))              ; @e{body}
              (print-elements-recursively     ; @e{recursive call}
               (cdr list))))                  ; @e{next-step-expression}

      (print-elements-recursively animales)
    @end example

    La función @c{print-elements-recursively} primero chequea si hay
    cualquier contenido en la lista; si lo hay, la función imprime el primer
    elemento de la lista, el @Cc{car} de la lista. Entonces la función se
    ‘invoca en sí’, pero da a sí mismo como su argumento, no la lista
    completa, pero el segundo y subsiguientes elementos de la lista, el
    @Cc{cdr} de la lista.

    Pon otro camino, si la lista no está vacía, la función invoca otra
    instancia de código que es similar al código inicial, pero es un hilo
    diferente de ejecución, con diferentes argumentos a la primera instancia.

    Veamos una manera más, si la lista no está vacía, el primer robot
    ensambla un segundo robot que cuenta qué hacer; el segundo robot es un
    individuo diferente desde el principio, pero es el mismo modelo.

    Cuando la segunda evaluación ocurre, la expresión @c{when} se evalúa y si
    es verdad, se imprime el primer elemento de la lista que recibe como su
    argumento (que es el segundo elemento de la lista original). Entonces la
    función ‘llamarse a sí mismo’ con la @Cc{cdr} del @Cc{cdr} de la lista
    original.

    Note que aunque nosotros decimos que la función ‘se llama a sí misma’, lo
    que significa es que el intérprete Lisp ensambla e instruye una nueva
    instancia del programa. La nueva instancia es un clon del primero, pero
    es un individuo separado.

    Cada vez que la función ‘se invoca a sí misma’, se invoca a sí misma en
    una versión de la lista original. Eso crea una nueva instancia que
    funciona como una lista ordenada.

    Finalmente, la función se invoca a sí misma en una lista vacía. Eso crea
    una nueva instancia cuyo argumento es @c{nil}. La expresión condicional
    chequea el valor de @c{lista}. Desde el valor de @c{lista} a @c{nil}, la
    expresión @c{when} devuelve falso así la then-part no está evaluada. La
    función es como un todo que entonces devuelve @c{nil}.

    Cuando se evalúa la expresión @c{(print-elements-recursively animals)} en
    el búffer @f{*scratch*}, se verá este resultado:

    @example
      gacela

      jirafa

      leon

      tigre
      nil
    @end example

*** Recursión en lugar de un contador

    La función @c{triangle} describe en una sección previa si puede ser
    escrita recursivamente. Se ve así:

    @example
      (defun triangle-recursively (number)
        "Return the sum of the numbers 1 through NUMBER inclusive.
      Uses recursion."
        (if (= number 1)                    ; @e{do-again-test}
            1                               ; @e{then-part}
          (+ number                         ; @e{else-part}
             (triangle-recursively          ; @e{recursive call}
              (1- number)))))               ; @e{next-step-expression}

      (triangle-recursively 7)
    @end example

    Se puede instalar esta función evaluando y entonces se intenta evaluar
    @c{(triangle-recursively 7)}. (Recuerda poner tu cursor inmediatamente
    después de los últimos paréntesis de la definición de la función, antes
    del comentario.) La función se evalúa a 28.

    Para comprender cómo funciona la función, hay que considerar qué ocurre
    en varios casos cuando la función se le pasa 1, 2, 3, o 4 como el valor a
    su argumento.


    Primero, veamos qué ocurre si el valor del argumento es 1.

    La función tiene una expresión @c{if} después de la cadena de
    documentación. Esto chequea si el valor de @c{number} es igual a 1; si es
    así, Emacs evalúa la then-part de la expresión @c{if}, que devuelve el
    número 1 como el valor de la función. (Un triángulo con una fila tiene un
    asterisco dentro.)

    Supón, sin embargo, que el valor del argumento es 2. En este caso, Emacs
    evalúa la parte else de la expresión @c{if}.

    La parte else consiste de una adición, la llamada recursiva para
    @c{triangle-recursively} y una acción de decremento; y se ve así:

    @example
      (+ number (triangle-recursively (1- number)))
    @end example

    Cuando Emacs evalúa esta expresión, la expresión interna es evaluada
    primero; entonces las otras partes en secuencia. Aquí están los pasos en
    detalle:

    - Paso 1 Evalúa la expresión interna. ::

      La expresión interna es @c{(1- number)} así Emacs decrementa el valor
      de @c{number} desde 2 a 1.


    - Paso 2 Evalúa la función @c{triangle-recursively}.

      El intérprete Lisp crea una instancia individual de
      @c{triangle-recursively}. Eso no importa que esta función está
      contenida con sí misma. Emacs pasa el resultado Paso 1 como el
      argumento usado por esta instancia de la función
      @c{triangle-recursively}

      En este caso, Emacs evalúa @c{triangle-recursively} con un argumento
      de 1. Esto significa que esta evaluación de @c{triangle-recursively}
      devuelve 1.

    - Paso 3 Evalúa el valor de @c{number}. ::

      La variable @c{number} es el segundo elemento de la lista que empieza
      con @c{+}; su valor es 2.

    - Paso 4 Evalúa la expresión @c{+}. ::

      La expresión @c{+} recibe dos argumentos, el primero desde la
      evaluación de @c{number} (Paso 3) y el segundo desde la evaluación de
      @c{triangle-recursively} (Paso 2).

      El resultado de la adición es la suma de 2 + 1, y el número 3 es
      devuelto, que es correcto. Un triángulo con dos filas tiene tres
      asteriscos ahí.  @end table

**** Un argumento de 3 o 4

     Supón que @c{triangle-recursively} es llamado con un argumento de 3.

     - Paso 1 Evalúa la do-again-test. ::

       La expresión @c{if} se evalúa primero. Esto es el test do-again
       y devuelve falso, así la parte else de la expresión
       @c{if} es evaluada. (Note que en este ejemplo, el do-again-test
       causa la función para llamarse a sí misma cuando eso
       se chequea como falso, no cuando eso se chequea como verdadero.)

     - Paso 2 Evalúa la expresión propia de la parte else. ::

       La expresión propia de la parte que es evaluada, decrementa 3
       a 2. Esta la next-step-expression.

     - Paso 3 Evalúa la función @c{triangle-recursively}. ::

       El número 2 es pasado a la función @c{triangle-recursively}.

       Nosotros ya sabemos qué ocurre cuando Emacs evalúa
       @c{triangle-recursively} con un argumento de 2. Después de ir a
       través de la secuencia de acciones descritas temprano, eso devuelve
       un valor de 3. Así que es lo que ocurrirá
       aquí.

     - Paso 4 Evalúa la adición. ::


       3 será pasado como un argumento para la adición y será añadido
       al número con el que la función se llamó, que es 3.
       @end table


     El valor devuelto por la función como un todo será 6.

     Ahora que sabemos qué ocurrirá cuando @c{triangle-recursively} llama con
     un argumento 3, es evidente lo que ocurrirá si se llama con el argumento
     4:

     @blood
       En la llamada recursiva, la evaluación de

       @example
         (triangle-recursively (1- 4))
       @end example

       devuelve el valor de evaluar

       @example
         (triangle-recursively 3)
       @end example

       que es 6 este valor será añadido a 4 por la adición en la tercera
       línea.
     @end blood


     El valor devuelto por la función como un todo será 10.

     Cada vez que @c{triangle-recursively} se evalúa, se interpreta una
     versión de sí misma––una instancia diferente en sí––con un pequeño
     argumento, hasta que el argumento es suficientemente pequeño así que no
     se evalúa en sí.

     Note que este particular diseño para una función recursiva requiere que
     las operaciones sean diferidas.

     Antes de que @c{(triangle-recursively 7)} pueda calcular su respuesta,
     debe llamarse a @c{(triangle-recursively 6)}; y antes a
     @c{(triangle-recursively 5)}; y así. Esto es decir, que el cálculo de
     @c{(triangle-recursively 7)} a crear debe ser diferido hasta que
     @c{(triangle-recursively 6)} haga su cálculo; y @c{(triangle-recursively
     5)} lo complete; y así.

     Si cada una de estas instancias de @c{triangle-recursively} son pensadas
     como diferentes robots, el primer robot debe esperar por el segundo para
     completar su trabajo, que debe esperar hasta los terceros completos, y
     así.

     Hay un camino alrededor de este tipo de espera, que se discutirá en
     @l{Recursión sin diferir}.

*** Ejemplo de recursión usando @c{cond}

    La versión de @c{triangle-recursively} antes descrita se escribió con la
    forma especial @c{if}. Eso puede también ser escrita usando otra forma
    especial llamada @c{cond}. El nombre de la forma especial @c{cond} es una
    abreviación de la palabra @'{conditional}.

    Aunque la forma especial @c{cond} no se usa con frecuencia en las fuentes
    de Emacs como @c{if}, se usa con suficiente frecuencia para justificarse
    explicando.

    La plantilla para una expresión @c{cond} se parece a:

    @example
      (cond
       @V{body}…)
    @end example

    donde el @V{body} es una serie de listas.

    Escrito de manera más completa, la plantilla se parece a esto:

    @example
      (cond
       (@V{first-true-or-false-test} @V{first-consequent})
       (@V{second-true-or-false-test} @V{second-consequent})
       (@V{third-true-or-false-test} @V{third-consequent})
        …)
    @end example

    Cuando el intérprete Lisp evalúa la expresión @c{cond}, evalúa el primer
    elemento (el @Cc{car} o true-or-false-test) de la primera expresión en
    una serie de expresiones con el cuerpo del @c{cond}.

    Si el true-or-false-test devuelve @c{nil} el resto de esta expresión, el
    consecuente, se descarta y el true-or-false-test de la siguiente
    expresión se evalúa. Cuando una expresión encuentra un true-or-false-test
    cuyo valor no es @c{nil}, el consecuente de esta expresión se evalúa. El
    consecuente puede ser una o más expresiones. Si el consecuente consiste
    de más de una expresión, las expresiones son evaluadas en secuencia y el
    valor del último se devuelve. Si la expresión no tiene un consecuente, se
    devuelve el valor del true-or-false-test.

    Si ninguno del test true-or-false-tests es cierto, la expresión @c{cond}
    devuelve @c{nil}.

    Escrito usando @c{cond}, la función @c{triangle} se parece a esto:

    @example
      (defun triangle-using-cond (number)
        (cond ((<= number 0) 0)
              ((= number 1) 1)
              ((> number 1)
               (+ number (triangle-using-cond (1- number))))))
    @end example

    En este ejemplo, el @c{cond} devuelve 0 si el número es menor o igual a
    0, eso devuelve 1 si el número es 1 y eso evalúa @c{(+ number
    (triangle-using-cond (1- number)))} si el número es más grandes que 1.

*** Patrones recursivos

    Aquí hay tres patrones recursivos. Cada uno involucra una lista. La
    recursión no se necesita para involucrar listas, pero Lisp se diseña para
    listas y esto provee un sentido de sus capacidades primarias.

**** Patrón recursivo: @e{every}

     En el patrón recursivo @c{every}, se desarrolla una acción por cada
     elemento de una lista.

     El patrón básico es:

     - Si una lista es vacía, devuelve @c{nil}.

     - Si no, se va al principio de la lista (el @Cc{car} de la lista)
       actuando

       - a través de una llamada recursiva por la función en el resto (el
         @Cc{cdr}) de la lista,

       - y, opcionalmente, se combina el elemento sobre el que actúa, usando
         @c{cons}, con los resultados de actuar en el resto.


     Aquí está el ejemplo:

     @example
       (defun square-each (numbers-list)
         "El cuadrado de cada LISTA DE NUMEROS, recursivamente."
         (if (not numbers-list)                ; test-hazlo-de-nuevo
             nil
           (cons
            (* (car numbers-list) (car numbers-list))
            (square-each (cdr numbers-list))))) ; expresion-siguiente-paso

       (square-each '(1 2 3))
           ⇒ (1 4 9)
     @end example

     Si @c{numbers-list} está vacío, no hay que hacer nada. Pero si tiene
     contenido, se construye una lista combinando el cuadrado del primer
     número en la lista con el resultado de la llamada recursiva.

     (El ejemplo sigue el patrón exactamente: se devuelve @c{nil} si la lista
     de números es vacía. En la práctica, se escribiría el condicional, así
     se ejecuta la acción cuando la lista de números no es vacía.)

     La función @c{print-elements-recursively} (Vease Sección @l{Recursión
     con una Lista}) es otro ejemplo de un patrón @c{every}, excepto en este
     caso, en vez de traer los resultados juntos usando @c{cons}, se imprime
     cada elemento de salida.

     La función @c{print-elements-recursively} se parece a esto:

     @example
       (setq animales '(gacela jirafa leon tigre))

       (defun print-elements-recursively (list)
         "Imprime cada elemento de la LISTA de la línea en
         sí. Usa recursión."
         (when list                            ; @e{do-again-test}
               (print (car list))              ; @e{body}
               (print-elements-recursively     ; @e{recursive call}
                (cdr list))))                  ; @e{next-step-expression}

       (print-elements-recursively animales)
     @end example

     El patrón para @c{print-elements-recursively} es:

     - Cuando la lista está vacía, no hacer nada.

     - Pero cuando la lista tiene al menos un elemento,

       - actúa al principio de la lista (el @Cc{car} de la lista),

       - y crea una llamada recursiva en el resto (el @Cc{cdr} de la lista).

**** Patrón recursivo: @e{accumulate}

     Otro patrón recursivo es llamado el patrón @c{accumulate}. En el patrón
     recursivo @c{accumulate}, se realiza una acción en cada elemento de una
     lista y el resultado de esta acción se acumula con los resultados de
     desarrollar la acción en otros elementos.

     Esto es como ‘cada’ patrón usando @c{cons}, excepto que este @c{cons} no
     se esté usando, pero que algún otro combine.

     El patrón es:

     - Si una lista está vacía, devuelve cero o alguna otra constante.

     - Lo demás, actúa al principio de la lista (el @Cc{car} de la lista),

       - y combinar este elemento que actúa, usando @c{+} o alguna otra
         función de combinación, con


       - una llamada recursiva por la función en el resto (el @Cc{cdr}) de la
         lista.


     Aquí hay un ejemplo:

     @example
       (defun add-elements (numbers-list)
         "Añade los elementos de NUMBERS-LIST juntos."
         (if (not numbers-list)
             0
           (+ (car numbers-list) (add-elements (cdr numbers-list)))))

       (add-elements '(1 2 3 4))
           ⇒ 10
     @end example

     Véase Sección @l{Creando una lista de ficheros}, para un ejemplo del
     patrón acumulado.

**** Patrón recursivo: @e{keep}

     Un tercer patrón es llamado el patrón @c{keep}. En el patrón recursivo
     @c{keep}, se chequea cada elemento de una lista; se actúa en el elemento
     y los resultados se guardan solo si el elemento encuentra un criterio.

     De nuevo, esto se parece al patrón ‘every’, excepto que el elemento se
     descarta a menos que se encuentre un criterio.

     El patrón tiene tres partes:

     - Si una lista es vacía, devuelve @c{nil}.

     - Lo demás, si el principio de la lista (el @Cc{car} de la lista) pasa
       un test

       - actua en este elemento y lo combina, usando @c{cons} con

       - una llamada recursiva por la función en el resto (el @Cc{cdr} de la
         lista.

     - De otro modo, si el principio de la lista (el @Cc{car} de la lista)
       falla el test

       - para en este elemento,

       - y, recursivamente llama la función al resto (el @Cc{cdr}) de la
         lista.

     Aquí hay un ejemplo que usa @c{cond}:

     @example
       (defun manten-tres-letras (lista-palabras)
         "Guarda 3 palabras en WORD-LIST."
         (cond
          ;; Primero do-again-test: stop-condition
          ((not lista-palabras) nil)

          ;; Segundo do-again-test: cuando actuar
          ((eq 3 (length (symbol-name (car lista-palabras))))
           ;; combina el elemento que actúa con la llamada recursiva en la
           ;; lista ordenada
           (cons (car lista-palabras) (manten-tres-letras (cdr lista-palabras))))

          ;; Tercero do-again-test: cuando se descarte el elemento;
          ;; llama recursivamente a la lista ordenada con la next-step expression
          (t (manten-tres-letras (cdr lista-palabras)))))

       (manten-tres-letras '(uno dos tres cuatro cinco seis))
           ⇒ (uno dos)
     @end example

     Eso va sin decir que no se necesita usar @c{nil} como si el test para
     cuando para; y se puede, de acuerdo, combinar estos patrones.

*** Recursión sin diferir

    Permita considerar de nuevo qué ocurre con la función
    @c{triangle-recursively}. Nosotros encontraremos que los cálculos
    difieran hasta que todo pueda ser hecho.

    Aquí está la definición de función:

    @example
      (defun triangle-recursively (number)
        "Devuelve la suma de los números 1 a través de NUMBER inclusive
      Usa recursión."
        (if (= number 1)                    ; @e{do-again-test}
            1                               ; @e{then-part}
          (+ number                         ; @e{else-part}
             (triangle-recursively          ; @e{recursive call}
              (1- number)))))               ; @e{next-step-expression}
    @end example

    ¿Qué ocurre cuando se llama a esta función con un argumento de 7?

    La primera instancia de la función @c{triangle-recursively} añade el
    número 7 al valor devuelto por una segunda instancia de
    @c{triangle-recursively}, una instancia que ha pasado un argumento
    de 6. Así, el primer cálculo es:

    @example
      (+ 7 (triangle-recursively 6))
    @end example

    La primera instancia de @c{triangle-recursively} --- se puede querer
    pensar como un pequeño robot––no puede completar su trabajo. Eso debe
    manejar el cálculo para @c{(triangle-recursively 6)} a una segunda
    instancia del programa, a un segundo robot. Este segundo individuo es
    completamente diferente desde el primero; eso es, en la jerga, una
    ‘diferente instanciación’. O, poner otro camino, eso es un diferente
    robot. Eso es el mismo modelo como el primero; eso calcula números de
    triángulo recursivamente; pero eso tiene un número de serie diferente.

    ¿Y qué hace @c{(triangle-recursively 6)} devuelve? Eso devuelve el número
    6 añadido al valor devuelto para evaluar @c{triangle-recursively} con un
    argumento de 5. Usando la metáfora del robot, eso cuestiona todavía otro
    robot para ayudarle.

    Ahora el total es:

    @example
      (+ 7 6 (triangle-recursively 5))
    @end example

    ¿Y qué ocurre después?

    @example
      (+ 7 6 5 (triangle-recursively 4))
    @end example

    Cada vez que @c{triangle-recursively} es llamado, excepto por la última
    vez, eso crea otra instancia del programa––otro robot --- y pregunta para
    crear un cálculo.

    Finalmente, la adición completa es de la siguiente manera:

    @example
      (+ 7 6 5 4 3 2 1)
    @end example

    Este diseño para la función difiere el cálculo del primer paso hasta el
    segundo puede ser hecho, y difiere esto hasta que el tercero puede ser
    hecho, y así. Cada defermento significa el ordenador debe recordar que
    está siendo esperado dentro. Esto no es un problema cuando hay solo unos
    pocos pasos, como en este ejemplo. Pero eso puede ser un problema cuando
    hay más pasos.

*** No hay solución pospuesta

    La solución al problema de operaciones pospuestas es para escribir en una
    manera que no posponga operaciones@n{11}. Esto requiere escribir a un
    patrón diferente, con frecuencia uno que involucra escribiendo dos
    definiciones de función, una función de ‘inicialización’ y una función
    ‘ayuda’.

    La función ‘inicializacion’ configura el trabajo; la función ‘ayudante’
    hace el trabajo.

    Aquí hay dos definiciones para añadir números. Son así de simple, aunque
    se encuentre duro de comprender.

    @example
      (defun triangle-initialization (number)
        "Devuelve la suma de los números 1 a través de NUMBER inclusive.
      Este es el componente de ‘inicialización’ de una función dúo que
      usa recursión"
        (triangle-recursive-helper 0 0 number))
    @end example

    @example
      (defun triangle-recursive-helper (sum counter number)
        "Devuelve SUM, usando COUNTER, a través de NUMBER inclusive.
      Este es el componente ‘helper’ de unas dos funciones
      que usan recursión."
        (if (> counter number)
            sum
          (triangle-recursive-helper (+ sum counter)  ; @e{suma}
                                     (1+ counter)     ; @e{contador}
                                     number)))        ; @e{número}
    @end example

    Instalar ambas definiciones de función por evaluarlo, entonces llama a
    @c{triangle-initialization} con 2 filas:

    @example
      (triangle-initialization 2)
          ⇒ 3
    @end example

    La función ‘inicialización’ llama la primera instancia de la función
    ‘ayudante’ con tres argumentos: cero, cero, y un número que es el número
    de filas en el triángulo.

    Los primeros dos argumentos pasaron a la función ‘ayuda’ son valores de
    inicialización. Estos valores son cambiados cuando
    @c{triangle-recursive-helper} invocan nuevas instancias.@n{12}

    Permítase ver que ocurre cuando tenemos un triángulo que tiene una
    fila. (¡Este triángulo tendrá un asterisco dentro!)

    @c{triangle-initialization} llamará su ayudante con los argumentos @c{0 0
    1}. Esta función ejecutará el test condicional si @c{(> counter number)}:

    @example
      (> 0 1)
    @end example

    y encuentra que el resultado es falso, así invocará la else-part de la
    claúsula @c{if}:

    @example
          (triangle-recursive-helper
           (+ sum counter)  ; @e{sum más counter} ⇒ @e{sum}
           (1+ counter)     ; @e{incrementa counter} ⇒ @e{counter}
           number)          ; @e{number parece lo mismo}
    @end example

    que computará primero:

    @example
      (triangle-recursive-helper (+ 0 0)  ; @e{sum}
                                 (1+ 0)   ; @e{counter}
                                 1)       ; @e{number}
      que es:

      (triangle-recursive-helper 0 1 1)
    @end example

    De nuevo, @c{(> counter number)} será falso, así de nuevo, el intérprete
    Lisp evaluará @c{triangle-recursive-helper}, creando una nueva instancia
    con nuevos argumentos.

    Esta nueva instancia será;

    @example
          (triangle-recursive-helper
           (+ sum counter)  ; @e{suma más contador} ⇒ @e{sum}
           (1+ counter)     ; @e{incrementar contador} ⇒ @e{contador}
           number)          ; @e{número empieza lo mismo}

      que es:

      (triangle-recursive-helper 1 2 1)
    @end example

    En este caso, el test @c{(> counter number)} ¡será cierto!  Así la
    instancia devolverá el valor de la suma, que será 1, como se espera.

    Ahora, permite pasar @c{triangle-initialization} un argumento de 2, para
    encontrar cuántos asterisco hay en un triángulo con dos filas.

    Esta función llama @c{(triangle-recursive-helper 0 0 2)}.

    En fases, las instancias llamadas serán:

    @example
                                @e{suma contador número}
      (triangle-recursive-helper 0    1       2)

      (triangle-recursive-helper 1    2       2)

      (triangle-recursive-helper 3    3       2)
    @end example

    Cuando la última instancia se llama, el @c{(> counter number)} se chequea
    si será cierto, así la instancia devolverá el valor de @c{sum}, que
    será 3.

    Este tipo de patrón ayuda cuando estás escribiendo funciones que puede
    usar recursos en un ordenador.

** Ejercicio de bucles

   - Escribe una función similar a @c{triangle} en el que cada fila tiene un
     valor que es la raíz del número de la fila. Usa un bucle @c{while}.

   - Escribe una función similar para @c{triangle} que multiplique en vez de
     añadir los valores.

   - Reescribe estas dos funciones recursivamente. Reescribe estas funciones
     usando @c{cond}.

   - Escribe una función para el modo Texinfo que crea una entrada índice al
     principio de un párrafo para cada @'{@@dfn} con el párrafo. (En un
     fichero Texinfo, @'{@@dfn} marca una definición. El libro es escrito en
     Texinfo.)

     Muchas de las funciones necesitarán ser descritas en dos de los
     capítulos, @l{Cortando y almacenando texto} y @l{Pegando texto}. Si usas
     @c{forward-paragraph} para poner la entrada índice al principio del
     párrafo, tendrá que usar @k{C-h f} (@c{describe-function}) para
     encontrar cómo conseguir que el comando vaya hacia atrás.


   Para más información, ver “Indicando Definiciones, Comandos, etc.” en
   @e{Texinfo} el @e{Formato de Documentación de GNU}.

* Búsquedas de expresiones regulares

  Las búsquedas expresiones regulares son usadas extensivamente en GNU
  Emacs. Las dos funciones @c{forward-sentence} y @c{forward-paragraph},
  ilustran estas búsquedas bien. Usan expresiones regulares para encontrar
  donde mover el punto. La frase ‘expresión regular’ es con frecuencia
  escrita como ‘regexp’.

  Las búsquedas de expresiones regulares son descritas en Seccion @"{Búsqueda
  de Expresión Regular} en @e{El Manual de GNU Emacs}, tan bien como en
  Seccion @"{Expresiones Regulares} @e{El Manual de Referencia de GNU Emacs
  Lisp}. Escribiendo este capítulo, estoy presuponiendo que tiene al menos
  una familiaridad con esto. El mayor punto para recordar es que las
  expresiones regulares te permiten buscar patrones tan bien como para
  cadenas literales de caracteres. Por ejemplo, el código en
  @c{forward-sentence} busca para el patrón de posibles caracteres que
  podrían marcar el fin de una frase, y mueve el punto al otro lado.

  Antes de mirar en el código la función @c{forward-sentence}, es valorable
  considerar que el patrón que marca el fin de una frase debe estar. El
  patrón se discute en la siguiente sección; siguiendo que es una descripción
  de la expresión regular de búsqueda, @c{re-search-forward}. La función
  @c{forward-sentence} es descrito en la sección siguiente. Finalmente, la
  función @c{forward-paragraph} es descrito en la última sección de este
  capítulo. @c{forward-paragraph} es una función compleja que introduce
  varias funcionalidades.

** La expresión regular para @c{sentence-end}

   El símbolo @c{sentence-end} se asocia al patrón que marca el fin de una
   frase. ¿Cuál sería esta expresión regular?

   Claramente, una frase puede ser finalizada por un periodo, una marca de
   inicio de interrogación, o una marca de exclamación. Puesto que viene del
   inglés, solo las claúsulas que finalizan con uno de estos tres caracteres
   deberían ser consideradas al fin de una frase. Esto significa que el
   patrón incluiría el conjunto de caracteres:

   @example
     [.?!]
   @end example

   Sin embargo, no queremos que @c{forward-sentence} salte a un periodo, una
   marca de pregunta, o una marca de exclamación, porque tal carácter podría
   ser usado en el medio de una frase. Un periodo, por ejemplo, se usa
   después de abreviaciones. Así, otra información es necesaria.

   De acuerdo a la convención, escribe dos espacios después de cada frase,
   pero solo un espacio después de un periodo, una marca de pregunta, o una
   marca de exclamación seguida por dos espacios es un buen indicador de un
   fin de frase. Sin embargo, en un fichero, los dos espacios pueden ser un
   tabulador o el fin de una línea. Esto significa que la expresión regular
   incluiría estos tres ítems como alternativas.

   Este grupo de alternativas se parece a esto:

   @example
     \\($\\| \\|  \\)
            ^   ^^
           TAB  SPC
   @end example

   Aquí, @'{$} indica el fin de la línea, y yo he apuntado donde el tab y dos
   espacios están insertados en la expresión. Ambos están insertados poniendo
   los caracteres actuales dentro de la expresión.

   Dos barras invertidas, @'{\\}, se requiere antes de los paréntesis y
   barras verticales: la primera barra invertida cita la siguiente barra
   invertida en Emacs; y el segundo indica que el siguiente caracter, el
   paréntesis o la barra vertical, es especial.

   También, una frase puede ser seguida por uno o más retornos de carro, como
   este:

   @example
     [
     ]*
   @end example

   Como en los tabuladores y espacios, un retorno de carro se inserta dentro
   de una expresión regular insertándolo literalmente. El asterisco indica
   que el @k{RET} se repite cero o más veces.

   Pero una frase no consiste solo en un periodo, una marca de pregunta o una
   marca de exclamación seguida por espacios apropiados: una marca de cerrar
   comillas o cerrar un paréntesis de algún tipo puede preceder el
   espacio. En realidad más de una marca o paréntesis pueden preceder el
   espacio. Estas requieren una expresión que se parezca a:

   @example
     []\"')@}]*
   @end example

   En esta expresión, el primer @'{]} es el primer caracter en la expresión;
   el segundo caracter es @'{"}, que está precedido por un @'{\} para contar
   Emacs el @'{"} @e{no} es especial. Los últimos tres caracteres son @'{'},
   @'{)}, y @'{@}}.

   Todo esto sugiere que el patrón de la expresión regular para asociar el
   fin de una frase sería; y, profundamente, si se evalúa @c{sentence-end} y
   encuentra que se devuelve el valor siguiente:

   @example
     sentence-end
          ⇒ "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
     ]*"
   @end example

   (Bien, no en GNU Emacs 22; porque es un esfuerzo crear el proceso simple y
   manejar más símbolos y lenguajes. Cuando el valor de @c{sentence-end} es
   @c{nil}, entonces usa el valor definido por la función @c{sentence-end} es
   @c{nil}, entonces usa el valor definido por la función
   @c{sentence-end}. (Aquí se usa la diferencia entre un valor y una función
   en Emacs Lisp.) La función devuelve un valor construido desde las
   variables @c{sentence-end-base}, @c{sentence-end-double-space},
   @c{sentence-end-without-period}, y @c{sentence-end-without-space}. La
   variable crítica es @c{sentence-end-base}; su valor global es similar a
   uno descrito debajo pero también contiene marcas de cita
   adicionales. Estas tienen diferentes grados de curvas. La variable
   @c{sentence-end-without-period}, cuando es verdad, dice a Emacs que una
   frase puede finalizar sin un periodo tal como texto en Thai.)

   @ignore
     (Note that here the @k{TAB}, two spaces, and @k{RET} are shown literally
     in the pattern.)

     This regular expression can be deciphered as follows:

     - [.?!] ::

       La primera parte del patrón son los tres caracteres, un periodo, una
       pregunta marca y un marca de exclamación, con paréntesis cuadrados. El
       patrón empieza con uno un otro de estos caracteres.

     - []\"')@}]* ::

       La segunda parte del patrón es el grupo de cerrar paréntesis y marcas
       de cita, que pueden aparecer cero o más veces. Estos pueden seguir el
       periodo, marca de pregunta o marca de exclamación. En una expresión
       regular la barra, @'{\}, seguido por las dobes comillas, @'{"}, indica
       los casos de caracteres string-quote. Normalmente, las dobles comillas
       es el único caracter en esta clase. El asterisco, @'{*}, indica que
       los ítems en el grupo previo (el grupo alrededor por comillas
       cuadradas, @'{[]} puede ser repetido cero o más veces.

     - \\($\\|   \\|  \\) ::

       La tercera parte del patrón es uno u otro de: si el fin de una línea,
       o dos espacios en blanco, o un tabulador. Las barras invertidas dobles
       son usadas para prevenir a Emacs desde leer los paréntesis y barras
       verticales como parte del patrón de búsqueda; los paréntesis son
       usados para marcar el grupo y las barras verticales usadas para
       indicarse que los patrones de un lado de ellos son alternativas. El
       signo del dólar es usados para indicar el fin de una línea y ambos
       espacios y el tabulador son cada uno insertados como están para
       indicar lo que ellos son.

     - [@k{RET}]* ::

       Finalmente, la última parte del patrón indica que el fin de la línea o
       el espacio en blanco siguiendo el periodo, marca de pregunta o marca
       de exclamación, pero no necesita, el retorno de carro es insertado
       como un retorno de carro devuelve paréntesis cuadrados pero aquí eso
       muestra @k{RET}.
   @end ignore

** La función @c{re-search-forward}

   La función @c{re-search-forward} es similar a la función
   @c{search-forward}. (Véase Sección @l{La Función @c{search-forward}}.)

   @c{re-search-forward} busca una expresión regular. Si la búsqueda es
   exitosa, deja el punto inmediatamente después del último caracter en el
   objetivo. Si la búsqueda es hacia atrás, deja el punto antes del primer
   caracter en el objetivo. Se puede contar @c{re-search-forward} para
   devolver @c{t} a cierto. (Moviendo el punto es por ello un ‘efecto
   lateral’.)

   Como @c{search-forward}, la función @c{re-search-forward} toma cuatro
   argumentos:

   1. El primer argumento es la expresión regular que la función busca. La
      expresión regular será una cadena entre comillas.

   2. El segundo argumento opcional limita cómo la función busca; es un
      emparejamiento, que se especifica como una posición en el búffer.

   3. El tercer argumento opcional especifica cómo la función responde al
      fallo: @c{nil} como tercer argumento que causa la función para señalar
      un error (e imprime un mensaje) cuando la búsqueda falla; cualquier
      otro valor causa devolver @c{nil} si la búsqueda falla y @c{t} si la
      búsqueda tiene éxito.


   4. El cuarto argumento opcional es el contaje repetido. Un contaje
      negativo repetido causa @c{re-search-forward} para buscar hacia atrás.


   La plantilla para @c{re-search-forward} se parece a esto:

   @example
     (re-search-forward "@V{regular-expression}"
                     @V{limit-of-search}
                     @V{what-to-do-if-search-fails}
                     @V{repeat-count})
   @end example

   El segundo, tercer, y cuarto argumentos son opcionales. Sin embargo, si se
   quiere pasar un valor a uno o ambos de los últimos dos argumentos, se debe
   también pasar un valor a todos los argumentos precedentes. De otro modo,
   el intérprete Lisp errará a qué argumento estás pasando el valor.

   En la función @c{forward-sentence}, la expresión regular será el valor de
   la variable @c{sentence-end}. En forma simple, esto es:

   @example
     "[.?!][]\"')@}]*\\($\\|  \\|  \\)[
     ]*"
   @end example

   El límite de la búsqueda será el fin del párrafo (desde una frase no puede
   ir bajo un párrafo). Si la búsqueda falla, la función devuelve @c{nil}, y
   el contaje repite será provisto por el argumento para la función
   @c{forward-sentence}.

** La función @c{forward-sentence}

   El comando mueve el cursor hacia adelante una frase es una ilustración
   honesta de cómo usar búsquedas de expresiones regulares en Emacs Lisp. En
   realidad, la función parece más larga y más complicada de lo que es; esto
   es porque la función está diseñada para ir hacia atrás tan bien como hacia
   adelante; y, opcionalmente, a través de una frase. La función está
   normalmente asociada al comando @k{M-e}.

   Aquí está la código para @c{forward-sentence}:

   @example
     (defun forward-sentence (&optional arg)
       "Ve al siguiente ‘sentence-end’. Con el argumento, repite.
     Con el argumento negativo, mueve atrás repetidamente a ‘sentence-beginning’.
     La variable ‘sentence-end’ es una expresión regular que empareja el
     fin de frases. También, cada párrafo asociado termina las frases
     bien.
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point))
             (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            (if (and (re-search-backward sentence-end par-beg t)
                     (or (< (match-end 0) pos)
                         (re-search-backward sentence-end par-beg t)))
                (goto-char (match-end 0))
              (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            (if (re-search-forward sentence-end par-end t)
                (skip-chars-backward " \t\n")
              (goto-char par-end)))
           (setq arg (1- arg)))
         (constrain-to-field nil opoint t)))
   @end example

   @ignore
     GNU Emacs 21
     @example
       (defun forward-sentence (&optional arg)

        "Mueve hacia adelante a la siguiente sentence-end. Con el argumento,
         repetir.  Con el argumento negativo, mueve hacia atrás
         repetidamente a sentence-beginning. La frase que finalizan son
         identificadas por el valor de sentence-end tratada como expresión
         regular. También, cada párrafo límite termina las
         frases bien"
         (interactive "p")
         (or arg (setq arg 1))
         (while (< arg 0)
           (let ((par-beg
                  (save-excursion (start-of-paragraph-text) (point))))
             (if (re-search-backward
                  (concat sentence-end "[^ \t\n]") par-beg t)
                 (goto-char (1- (match-end 0)))
               (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end
                  (save-excursion (end-of-paragraph-text) (point))))
             (if (re-search-forward sentence-end par-end t)
                 (skip-chars-backward " \t\n")
               (goto-char par-end)))
           (setq arg (1- arg))))
     @end example
   @end ignore

   La función se ve larga a primera vista y es mejor mirar primero el
   esqueleto, y entonces su músculo. El camino para ver el esqueleto es mirar
   en las expresiones que empiezan las columnas más a la izquierda:

   @example
     (defun forward-sentence (&optional arg)
       "@V{documentation}…"
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point)) (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            @V{rest-of-body-of-while-loop-when-going-backwards}
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            @V{rest-of-body-of-while-loop-when-going-forwards}
         @V{handle-forms-and-equivalent}
   @end example

   ¡Esto parece bastante simple! La definición de la función consiste de
   documentación una expresión @c{interactive}, una expresión @c{or}, una
   expresión @c{let}, y bucles @c{while}.

   Permite mirar cada una de estas partes.

   Notamos que la documentación es profunda y comprensible.

   La función tiene una declaración @c{interactive "p"}. Esto signifca que el
   argumento prefijo, si cualquiera es pasado a la función como su
   argumento. (Esto será un número.) Si la función no pasa un argumento (eso
   es opcional) entonces el argumento @c{arg} será asociado a 1.

   Cuando @c{forward-sentence} se llama no interactivamente sin un argumento,
   @c{arg} está asignado @c{nil}. La expresión @c{or} maneja esto. Lo que
   hace es dejar el valor de @c{arg} como eso es, pero solo si @c{arg} está
   asignado a un valor; o eso asigna el valor de @c{arg} a 1, en el caso de
   @c{arg} está asignado a @c{nil}.

   Lo siguiente es un @c{let}. Que especifica los valores de dos variables
   locales @c{point} y @c{sentence-end}. El valor local de punto, desde antes
   de la búsqueda, es usada en la función @c{constrain-to-field} que maneja
   formularios y equivalentes. La variable @c{sentence-end} está asignada por
   la función @c{sentence-end}.

*** Los bucles @c{while}

    Sigue dos bucles @c{while}. El primer @c{while} tiene un
    true-or-false-test que chequea cierto si el argumento prefijo para
    @c{forward-sentence} es un número negativo. Esto es para volver hacia
    atrás. El cuerpo de este bucle es similar al cuerpo de la segunda
    cláusula @c{while}, pero eso no es exactamente el mismo. Se obviará este
    bucle @c{while} y concentra en el segundo bucle @c{while}.

    El segundo bucle @c{while} está moviendo el punto hacia adelante. Su
    esqueleto se parece a esto:

    @example
      (while (> arg 0)            ; @e{true-or-false-test}
        (let @V{varlist}
          (if (@V{true-or-false-test})
              @V{then-part}
            @V{else-part}
        (setq arg (1- arg))))     ; @c{while} @e{loop decrementer}
    @end example

    El bucle @c{while} es el tipo de decremento. (Véase Sección @l{Los bucles
    @c{while}}.) Eso tiene un true-or-false-test que chequea cierto tan largo
    con el contador (en este caso, la variable @c{arg}) es mayor que cero; y
    eso tiene un decremento que elimina 1 desde el valor del contador cada
    vez que el bucle se repite.

    Si ningún argumento prefijo es dado para @c{forward-sentece}, que es el
    camino más común es usado, este bucle @c{while} ejecutará una vez, desde
    que el valor de @c{arg} será 1.

    El cuerpo del cuerpo @c{while} consite de una expresión @c{let}, que crea
    y asocia una variable local, y tiene, su cuerpo, una expresión @c{if}.

    El cuerpo del bucle @c{while} se parece a esto:

    @example
      (let ((par-end
             (save-excursion (end-of-paragraph-text) (point))))
        (if (re-search-forward sentence-end par-end t)
            (skip-chars-backward " \t\n")
          (goto-char par-end)))
    @end example

    La expresión @c{let} crea y asocia la variable local @c{par-end}. Como se
    ve, esta variable local está diseñada para proporcionar una asociación o
    límite para la búsqueda de la expresión regular. Si la búsqueda falla
    para encontrar una frase apropiada finalizando en el párrafo, eso se
    parará logrando el fin del párrafo.

    Pero primero, permítenos examinar cómo @c{par-end} se asocia a la
    variable del fin del párrafo. Lo que ocurre es que el @c{let} asigna el
    valor de @c{par-end} al valor devuelto cuando el intérprete evalúa la
    expresión.

    @example
      (save-excursion (end-of-paragraph-text) (point))
    @end example

    En esta expresión, @c{(end-of-paragraph-text)} mueve el punto al fin del
    párrafo, @c{(point)} devuelve el valor del punto, y entonces
    @c{save-excursion} restaura el punto a su posición original. De este
    modo, el @c{let} asocia @c{par-end} al valor devuelto por la expresión
    @c{save-excursion}, que es la posición del fin del párrafo.  (La función
    @c{end-of-paragraph-text} usa @c{forward-paragraph}, que se discutirá
    pronto.)

    Emacs evalúa el cuerpo del @c{let}, que es una expresión @c{if} que se
    parece a esto:

    @example
      (if (re-search-forward sentence-end par-end t) ; @e{if-part}
          (skip-chars-backward " \t\n")              ; @e{then-part}
        (goto-char par-end)))                        ; @e{else-part}
    @end example

    El test @c{if} si su primer argumento es cierto y si así, evalúa su parte
    then; de otro modo, el intérprete Emacs Lisp evalúa la parte else. El
    true-or-false-test de la expresión @c{if} es la búsqueda de la expresión
    regular.

    Puede estar mal tener que mirar como el ‘trabajo real’ de la función
    @c{forward-sentence} es vista aquí, pero esto es un camino común de este
    tipo de operación traida en Lisp.

*** La búsqueda de expresiones regulares

    La función @c{re-search-forward} busca el fin de la frase, que es, para
    el patrón definido por la expresión regular @c{sentence-end}. Si el
    patrón es encontrado––si el fin de la frase se encuentra––entonces la
    función @c{re-search-forward} hace dos cosas:

    1. La función @c{re-search-forward} trae un efecto secundario, que es mover
       el punto al final de la ocurrencia encontrada.


    2. La función @c{re-search-forward} devuelve un valor de verdad. Esto es
       el valor recibido por el @c{if}, y significa que la búsqueda fué
       exitosa.


    El efecto secundario, el movimiento del punto se completa antes de la
    función @c{if} y es manejado por el valor devuelto por la exitosa
    conclusión de la búsqueda.

    Cuando la función @c{if} recibe el valor de verdad desde una llamada
    exitosa a @c{re-search-forward}, el @c{if} evalúa la parte then que es la
    expresión @c{(skip-chars-backward "\t\n")}. Esta expresión se mueve atrás
    a través de espacios en blanco, los tabuladores o retornos de carro hasta
    un caracter impreso es encontrado y entonces deja el punto correcto
    después del caracter impreso cerrado de la frase, que es normalmente un
    periodo.

    Por otro lado, si la función @c{re-search-forward} falla para encontrar
    un patrón marcando el fin de la frase, la función devuelve falso. Lo
    falso causa el @c{if} para evaluar su tercer argumento, que es
    @c{(goto-char par-end)}: eso mueve el punto al final del párrafo.

    (Y si el texto está en una forma o equivalente, y apunta a que no puede
    moverse completamente entonces la función @c{constrain-to-field} empieza
    a funcionar.)

    Las búsquedas de expresiones regulares son excepcionalmente útiles y el
    patrón ilustrado por @c{re-search-forward}, en el que la búsqueda es el
    test de una expresión @c{if}, es manejable. Se verá o escribirá código
    incorporando este patrón con frecuencia.

** @c{forward-paragraph}: una mina de oro de funciones

   @ignore
     @c in GNU Emacs 22
     (defun forward-paragraph (&optional arg)
       "Move forward to end of paragraph.
     With argument ARG, do it ARG times;
     a negative argument ARG = -N means move backward N paragraphs.

     A line which ‘paragraph-start’ matches either separates paragraphs
     \(if ‘paragraph-separate’ matches it also) or is the first line of a paragraph.
     A paragraph end is the beginning of a line which is not part of the paragraph
     to which the end of the previous line belongs, or the end of the buffer.
     Returns the count of paragraphs left to move."
       (interactive "p")
       (or arg (setq arg 1))
       (let* ((opoint (point))
              (fill-prefix-regexp
               (and fill-prefix (not (equal fill-prefix ""))
                    (not paragraph-ignore-fill-prefix)
                    (regexp-quote fill-prefix)))
              ;; Remove ^ from paragraph-start and paragraph-sep if they are there.
              ;; These regexps shouldn't be anchored, because we look for them
              ;; starting at the left-margin.  This allows paragraph commands to
              ;; work normally with indented text.
              ;; This hack will not find problem cases like "whatever\\|^something".
              (parstart (if (and (not (equal "" paragraph-start))
                                 (equal ?^ (aref paragraph-start 0)))
                            (substring paragraph-start 1)
                          paragraph-start))
              (parsep (if (and (not (equal "" paragraph-separate))
                               (equal ?^ (aref paragraph-separate 0)))
                          (substring paragraph-separate 1)
                        paragraph-separate))
              (parsep
               (if fill-prefix-regexp
                   (concat parsep "\\|"
                           fill-prefix-regexp "[ \t]*$")
                 parsep))
              ;; This is used for searching.
              (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
              start found-start)
         (while (and (< arg 0) (not (bobp)))
           (if (and (not (looking-at parsep))
                    (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
                    (looking-at parsep))
               (setq arg (1+ arg))
             (setq start (point))
             ;; Move back over paragraph-separating lines.
             (forward-char -1) (beginning-of-line)
             (while (and (not (bobp))
                         (progn (move-to-left-margin)
                                (looking-at parsep)))
               (forward-line -1))
             (if (bobp)
                 nil
               (setq arg (1+ arg))
               ;; Go to end of the previous (non-separating) line.
               (end-of-line)
               ;; Search back for line that starts or separates paragraphs.
               (if (if fill-prefix-regexp
                       ;; There is a fill prefix; it overrides parstart.
                       (let (multiple-lines)
                         (while (and (progn (beginning-of-line) (not (bobp)))
                                     (progn (move-to-left-margin)
                                            (not (looking-at parsep)))
                                     (looking-at fill-prefix-regexp))
                           (unless (= (point) start)
                             (setq multiple-lines t))
                           (forward-line -1))
                         (move-to-left-margin)
                         ;; This deleted code caused a long hanging-indent line
                         ;; not to be filled together with the following lines.
                         ;; ;; Don't move back over a line before the paragraph
                         ;; ;; which doesn't start with fill-prefix
                         ;; ;; unless that is the only line we've moved over.
                         ;; (and (not (looking-at fill-prefix-regexp))
                         ;;      multiple-lines
                         ;;      (forward-line 1))
                         (not (bobp)))
                     (while (and (re-search-backward sp-parstart nil 1)
                                 (setq found-start t)
                                 ;; Found a candidate, but need to check if it is a
                                 ;; REAL parstart.
                                 (progn (setq start (point))
                                        (move-to-left-margin)
                                        (not (looking-at parsep)))
                                 (not (and (looking-at parstart)
                                           (or (not use-hard-newlines)
                                               (bobp)
                                               (get-text-property
                                                (1- start) 'hard)))))
                       (setq found-start nil)
                       (goto-char start))
                     found-start)
                   ;; Found one.
                   (progn
                     ;; Move forward over paragraph separators.
                     ;; We know this cannot reach the place we started
                     ;; because we know we moved back over a non-separator.
                     (while (and (not (eobp))
                                 (progn (move-to-left-margin)
                                        (looking-at parsep)))
                       (forward-line 1))
                     ;; If line before paragraph is just margin, back up to there.
                     (end-of-line 0)
                     (if (> (current-column) (current-left-margin))
                         (forward-char 1)
                       (skip-chars-backward " \t")
                       (if (not (bolp))
                           (forward-line 1))))
                 ;; No starter or separator line => use buffer beg.
                 (goto-char (point-min))))))

         (while (and (> arg 0) (not (eobp)))
           ;; Move forward over separator lines...
           (while (and (not (eobp))
                       (progn (move-to-left-margin) (not (eobp)))
                       (looking-at parsep))
             (forward-line 1))
           (unless (eobp) (setq arg (1- arg)))
           ;; ... and one more line.
           (forward-line 1)
           (if fill-prefix-regexp
               ;; There is a fill prefix; it overrides parstart.
               (while (and (not (eobp))
                           (progn (move-to-left-margin) (not (eobp)))
                           (not (looking-at parsep))
                           (looking-at fill-prefix-regexp))
                 (forward-line 1))
             (while (and (re-search-forward sp-parstart nil 1)
                         (progn (setq start (match-beginning 0))
                                (goto-char start)
                                (not (eobp)))
                         (progn (move-to-left-margin)
                                (not (looking-at parsep)))
                         (or (not (looking-at parstart))
                             (and use-hard-newlines
                                  (not (get-text-property (1- start) 'hard)))))
               (forward-char 1))
             (if (< (point) (point-max))
                 (goto-char start))))
         (constrain-to-field nil opoint t)
         ;; Return the number of steps that could not be done.
         arg))
   @end ignore

   La función @c{forward-paragraph} mueve el punto al fin del párrafo. Eso
   está normalmente asociado a @k{M-@}} y hace uso de un número de funciones
   que son importantes en sí, incluyendo @c{let*}, @c{match-beginning}, y
   @c{looking-at}.

   La definición de función para @c{forward-paragraph} es considerablemente
   mayor que la definición de función para @c{forward-sentence} porque eso
   funciona como un párrafo, cada línea puede empezar con un prefijo de
   relleno @e{fill prefix}.

   Un prefijo de relleno @e{fill prefix} consiste en una cadena de caracteres
   que se repite al principio de cada línea. Por ejemplo, en código Lisp, es
   una convención para empezar cada línea de un comentario de párrafo largo
   con @'{;;; }. En modo Texto, cuatro espacios en blanco crean otro prefijo
   de relleno @e{fill prefix} común, creando un párrafo indentado. (Véase
   Sección @"{Fill Prefix} en @e(The GNU Emacs Manual) para más información
   acerca de prefijos de relleno @e{fill prefix}.)

   La existencia de un prefijo de relleno significa que además de ser capaz
   de encontrar el fin de un párrafo cuyas líneas empiezan más a la
   izquierda, la función @c{forward-paragraph} debe ser capaz de encontrar el
   fin de un párrafo cuando todas o muchas de las líneas en el búffer
   empiezan con el prefijo de relleno @e{fill prefix}.

   Más allá, es algunas veces práctico ignorar un prefijo de relleno @e{fill
   prefix} que existe, especialmente cuando las líneas en blanco separen
   párrafos. Esto es una complicación añadida.

   En vez de imprimir toda la función @c{forward-paragraph}, nosotros solo
   imprimiremos partes de la misma. ¡Lee sin preparación, la función puede
   estar para desanimar!

   En esquema, la función se parece a esto:

   @example
     (defun forward-paragraph (&optional arg)
       "@V{documentation}…"
       (interactive "p")
       (or arg (setq arg 1))
       (let*
           @V{varlist}
         (while (and (< arg 0) (not (bobp)))     ; @e{backward-moving-code}
           …
         (while (and (> arg 0) (not (eobp)))     ; @e{forward-moving-code}
           …
   @end example

   Las primeras partes de la función son rutinas: la función lista argumentos
   que consisten de un argumento opcional. La documentación sigue.

   La letra minúscula @'{p} en la declaración @c{interactive} significa que
   el argumento prefijo se procesa, si se pasa a la función. Eso será un
   número, y es el contaje repetido de cuántos párrafos se moverá.  La
   expresión @c{or} en la siguiente línea maneja el caso común cuando no hay
   argumentos que se pasan a la función, esto ocurre si la función se llama
   desde otro código en vez de interactivamente. Este caso se describe
   pronto. (Véase Sección @l{La función @c{forward-sentence}, La función
   @c{forward-sentence}}.) Ahora se logra el fin de la parte familiar de esta
   función.

*** La expresión @c{let*}

    La siguiente línea de la función @c{forward-paragraph} empieza una
    expresión @c{let*}. Esto es tan diferente como @c{let}. El símbolo es
    @c{let*} no @c{let}.

    La forma especial @c{let*} es como @c{let} excepto que Emacs asigna cada
    variable en secuencia, una después de otra, y las variables en la última
    parte de la varlist hacen uso de los valores para los que Emacs asignó
    variable al principio la varlist.

    @ignore
      ( refappend save-excursion, , code save-excursion in code append-to-buffer .)
    @end ignore

    (Seccion @l{La definición de @c{append-to-buffer}}.)

    En la expresión @c{let*} en esta función, Emacs asigna un total de siete
    variables: @c{opoint}, @c{fill-prefix-regexp}, @c{parstart}, @c{parsep},
    @c{sp-parstart}, @c{start}, y @c{found-start}.

    La variable @c{parsep} aparece dos veces, primero, para borrar instancias
    de @'{^}, y segundo, para manejar prefijos rellenos.

    La variable @c{opoint} es solo el valor de @c{point}. Como se puede
    adivinar, eso se usa en una expresión @c{constrain-to-field}, solo como
    en @c{forward-sentence}.

    La variable @c{fill-prefix-regexp} se asigna al valor devuelto para
    evaluar la siguiente lista:

    @example
      (and fill-prefix
           (not (equal fill-prefix ""))
           (not paragraph-ignore-fill-prefix)
           (regexp-quote fill-prefix))
    @end example

    Esta es una expresión cuyo primer elemento es la forma especial @c{and}.

    Como se aprendió antes la (Vease Sección @l{Función kill-new, , La
    función @c{kill-new}}), la forma especial @c{and} evalúa cada uno de sus
    argumentos hasta uno de los argumentos y devuelve un valor de @c{nil} en
    el que el caso de la expresión @c{and} devuelve @c{nil}; sin embargo, si
    ninguno de los argumentos devuelve un valor de @c{nil}, el valor
    resultante de evaluar el último argumento es devuelto. (Puesto que tal
    valor no es @c{nil}, eso es considerado verdad en Lisp.) En otras
    palabras, una expresión @c{and} devuelve un valor de verdad solo si todos
    sus argumentos son verdad.  @findex and

    En este caso, la variable @c{fill-prefix-regexp} está asociado a un valor
    no @c{nil} solo si el las siguientes cuatro expresiones producen un valor
    true (por ej., un no @c{nil}) cuando son evaluados; de otro modo,
    @c{fill-prefix-regexp} está asociado a @c{nil}.

    - fill-prefix ::

      Cuando esta variable se evalúa, el valor del prefijo de relleno @e{fill
      prefix}, si cualquiera, está devuelto. Si no hay prefijo relleno, la
      variable devuelve @c{nil}.

    - (not (equal fill-prefix "") ::

      Esta expresión chequea si un prefijo lleno es una cadena vacía, que es,
      una cadena sin caracteres en eso. Una cadena vacía no es útil un
      prefijo relleno @e{fill prefix}.

    - (not paragraph-ignore-fill-prefix) ::

      Esta expresión devuelve @c{nil} si la variable
      @c{paragraph-ignore-fill-prefix} ha sido cambiado siendo asignado un
      valor de verdad tal como @c{t}.

    - (regexp-quote fill-prefix) ::


      Este es el último argumento para la forma especial @c{and}. Si todos
      los argumentos de @c{and} son verdaderos, el valor resultante de
      evaluar esta expresión será devuelto por la expresión @c{and} y
      asociado a la variable @c{fill-prefix-regexp},


    El resultado de evaluar esta expresión @c{and} con éxito es que
    @c{fill-prefix-regexp} se asociará al valor de @c{fill-prefix} como fué
    modificado por la función @c{regexp-quote}. Lo que @c{regexp-quote} hace
    es leer una cadena y devolver la expresión regular que asociará
    exactamente la cadena y nada más. Esto significa que
    @c{fill-prefix-regexp} será asignada a un valor que asociará el prefijo
    si el prefijo existe. De otro modo, la variable será asignada a @c{nil}.

    Las dos variables locales siguientes en la expresión @c{let*} están
    diseñadas para eliminar instancias de @'{^} desde @c{parstart} y
    @c{parsep}, las variables locales indican que el párrafo empieza como
    separador de párrafo. La siguiente expresión asigna @c{parsep} de
    nuevo. Esto es manejar prefijos rellenos.

    Esta es la configuración que requiere la llamada de la definición
    @c{let*} en vez de @c{let}. El true-or-false-test para el @c{if} depende
    de si la variable @c{fill-prefix-regexp} evalúa a @c{nil} o algún otro
    valor.

    Si @c{fill-prefix-regexp} no tiene un valor, Emacs evalúa la parte else
    de la expresión @c{if} y asocia @c{parsep} a su valor local. (@c{parsep}
    es una expresión regular que asocia lo que los párrafos separan.)

    Pero si @c{fill-prefix-regexp} tiene un valor, Emacs evalúa la parte then
    de la expresión @c{if} y asocia @c{parsep} a una expresión regular que
    incluye el @c{fill-prefix-regexp} como parte del patrón.

    Específicamente, @c{parsep} está asignado al valor original del párrafo
    que separa la expresión regular concatenada con una expresión alternativa
    que consiste del @c{fill-prefix-regexp} seguido por espacios en blanco
    opcionales para el fin de la línea. El espacio en blanco está definido
    por @c{"[ \t]*$"}.) El @'{\\|} define esta porción del regexp como una
    alternativa a @c{parsep}.

    De acuerdo a un comentario en el código, la siguiente variable local,
    @c{sp-parstart}, se usa para buscar, y entonces los dos finales,
    @c{start} y @c{found-start}, se asignan a @c{nil}.

    Ahora tenemos dentro el cuerpo del @c{let*}. La primera parte del cuerpo
    del @c{let*} trata con el caso cuando la función es dada a un argumento
    negativo y consiguientemente moviéndose hacia atrás. Nosotros saldremos
    de esta sección yendo hacia atrás.

*** El bucle @c{while} hacia adelante

    La segunda parte del cuerpo del @c{let*} trata con el proceso hacia
    adelante. Eso es un bucle @c{while} que se repite si el valor de @c{arg}
    es mayor que cero. En el uso más común de la función el valor del
    argumento es 1, así el cuerpo del bucle @c{while} se evalúa exactamente
    una vez, y el cursor se mueve hacia adelante un párrafo.

    @ignore
      (while (and (> arg 0) (not (eobp)))

        ;; Move forward over separator lines...
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (looking-at parsep))
          (forward-line 1))
        (unless (eobp) (setq arg (1- arg)))
        ;; ... and one more line.
        (forward-line 1)

        (if fill-prefix-regexp
            ;; There is a fill prefix; it overrides parstart.
            (while (and (not (eobp))
                        (progn (move-to-left-margin) (not (eobp)))
                        (not (looking-at parsep))
                        (looking-at fill-prefix-regexp))
              (forward-line 1))

          (while (and (re-search-forward sp-parstart nil 1)
                      (progn (setq start (match-beginning 0))
                             (goto-char start)
                             (not (eobp)))
                      (progn (move-to-left-margin)
                             (not (looking-at parsep)))
                      (or (not (looking-at parstart))
                          (and use-hard-newlines
                               (not (get-text-property (1- start) 'hard)))))
            (forward-char 1))

          (if (< (point) (point-max))
              (goto-char start))))
    @end ignore

    Esta parte maneja tres situaciones: cuando el punto está entre párrafos,
    cuando hay un prefijo de relleno y cuando no hay prefijo de relleno
    @e{fill prefix}.

    El bucle @c{while} se parece a esto:

    @example
      ;; @e{yendo hacia adelante y no al fin del búffer}
      (while (and (> arg 0) (not (eobp)))

        ;; @e{entre párrafos}
        ;; Mueve hacia adelante a través de líneas de
        ;; separación...
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (looking-at parsep))
          (forward-line 1))
        ;;  @e{Esto decremento el bucle}
        (unless (eobp) (setq arg (1- arg)))
        ;; ... y una línea más
        (forward-line 1)

        (if fill-prefix-regexp
            ;; Hay un prefijo lleno; que sobreescribe parstart;
            ;; vamos adelante línea por línea
            (while (and (not (eobp))
                        (progn (move-to-left-margin) (not (eobp)))
                        (not (looking-at parsep))
                        (looking-at fill-prefix-regexp))
              (forward-line 1))

          ;; No hay prefijo;
          ;; vamos hacia adelante caracter por caracter
          (while (and (re-search-forward sp-parstart nil 1)
                      (progn (setq start (match-beginning 0))
                             (goto-char start)
                             (not (eobp)))
                      (progn (move-to-left-margin)
                             (not (looking-at parsep)))
                      (or (not (looking-at parstart))
                          (and use-hard-newlines
                               (not (get-text-property (1- start) 'hard)))))
            (forward-char 1))

          ;; y si no hay prefijo y si no estamos al final
          ;; ir a lo que fué encontrado en la búsqueda de expresiones regulares
          ;; para sp-parstart
          (if (< (point) (point-max))
              (goto-char start))))
    @end example

    Se puede ver que esto es un contador de decremento @c{while}, usando la
    expresión @c{(setq arg (1- arg))} como lo que se decrementa. Esta
    expresión no está lejos desde el @c{while}, pero está oculta en otra
    macro Lisp, una macro @c{unless}. A menos que estemos al final del
    búffer––esto es lo que la función @c{eobp} determina; eso es una
    abreviación de @'{Fin del Buffer P} --- nosotros decrementamos el valor
    de @c{arg} por uno.

    (Si estamos al fin del búffer, no podemos ir más hacia adelante y el
    siguiente bucle de la expresión @c{while} chequeará falso desde que el
    test es un @c{and} con @c{(not (eobp))}. La función @c{not} significa
    exactamente como se esperaba; eso es otro nombre de @c{null}, una función
    que devuelve cierto cuando su argumento es falso.)

    De manera interesante, el bucle cuenta que no se decrementa hasta que
    deje el espacio entre párrafos, a menos que vuelva al fin del búffer o
    pare viendo el valor local del separador del párrafo.

    El segundo @c{while} también tiene una expresión
    @c{(move-to-left-margin)}. La función es autoexplicativa. Eso está dentro
    de una expresión @c{progn} y no el último elemento de su cuerpo, así es
    solo invocado para su efecto secundario, que es mover el punto al margen
    izquierdo de la línea actual.

    La función @c{looking-at} es también auto-explicativa; eso devuelve
    cierto si el texto después del punto asocia la expresión regular dada
    como su argumento.

    El resto del cuerpo del bucle se ve compleja al principio, pero tiene
    sentido cuando se comprende.

    Primero considera que ocurre si hay un prefijo de relleno @e{fill
    prefix}:

    @example
      (if fill-prefix-regexp
          ;; Hay un prefijo lleno; que sobreescribe parstart;
          ;; vamos adelante línea por línea
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
    @end example

    Esta expresión mueve el punto hacia adelante línea por línea tan lejos
    como que las cuatro condiciones son ciertas:

    1. Punto no está al final del búffer.

    2. Podemos mover al margen izquierdo del texto y no estar al fin del
       búffer.

    3. El siguiente punto no separa párrafos.


    4. El patrón que sigue el punto es la expresión regular prefija rellena.


    La última condición puede ser un puzzle, hasta que se recuerde qué punto
    fué movido al principio de la línea temprana en la función
    @c{forward-paragraph}. Esto significa que si el texto tiene el prefijo
    relleno, la función @c{looking-at} se verá.

    Considera qué ocurre cuando no hay un prefijo lleno.

    @example
      (while (and (re-search-forward sp-parstart nil 1)
                  (progn (setq start (match-beginning 0))
                         (goto-char start)
                         (not (eobp)))
                  (progn (move-to-left-margin)
                         (not (looking-at parsep)))
                  (or (not (looking-at parstart))
                      (and use-hard-newlines
                           (not (get-text-property (1- start) 'hard)))))
        (forward-char 1))
    @end example

    El bucle @c{while} nos tiene buscando hacia adelante para
    @c{sp-parstart}, que es la combinación de posibles espacios en blanco con
    un valor local del comienzo de un párrafo o de un párrafo separador. (Las
    últimas dos son con una expresión empezando con @c{(?:)} así que no están
    referenciadas por la función @c{match-beginning}.)

    Las dos expresiones,

    @example
      (setq start (match-beginning 0))
      (goto-char start)
    @end example

    significa ir al comienzo del siguiente texto localizado por la expresión
    regular.

    La expresión @c{(match-beginning 0)} es nueva. Eso devuelve un número
    especificando la posición del comienzo del texto fuese asociado a la
    última búsqueda.

    La función @c{match-beginning} es usado aquí porque una característica de
    una búsqueda hacia adelante: una búsqueda hacia adelante, sin dignidad si
    eso es una búsqueda plana o una expresión regular, mueve el punto al fin
    del texto que es encontrado. En este caso, una búsqueda exitosa mueve el
    punto al fin del patrón para @c{sp-parstart}.

    Sin embargo, se quiere poner el punto al fin del actual párrafo, no en
    algún lugar más. En vez de eso, desde que la búsqueda posiblemente
    incluye el separador del párrafo, el punto puede finalizar al principio
    de lo siguiente a menos que se use una expresión que incluya
    @c{match-beginning}.

    Cuando un argumento de 0, @c{match-beginning} devuelve la posición que es
    el comienzo del texto asociado por la búsqueda más reciente. En este
    caso, la búsqueda más reciente parece @c{sp-parstart}. La expresión
    @c{(match-beginning 0)} devuelve la posición del comienzo de este patrón,
    en vez de la posición final de este patrón.

    (Incidentalmente, cuando se pasa un número positivo como un argumento, la
    función @c{match-beginning} devuelve la localización de punto en el que
    la expresión con paréntesis en la última búsqueda a menos que la
    expresión con paréntesis empiece con @c{\(?:}. No sé porque @c{\(?:}
    aparece aquí desde que el argumento es 0.)

    La última expresión cuando no hay prefijos es

    @example
      (if (< (point) (point-max))
          (goto-char start))))
    @end example

    Esto dice que si no hay prefijo lleno y no estamos al punto final que se
    movería al principio de lo que fué encontrado por la búsqueda de la
    expresión regular para @c{sp-parstart}.

    La definición completa para la función @c{forward-paragraph} no solo
    incluye código para avanzar, también código para retroceder.

    Si está leyendo esto dentro de GNU Emacs y quieres ver la función
    completa, se puede escribir @k{C-h f} (@c{describe-function}) y el nombre
    de la función. Esto da la documentación de función y el nombre de la
    librería conteniendo las fuentes de la función. Posiciona el punto a
    través del nombre de la librería y presionar la tecla RET; será tomado
    directamente a las fuentes. (¡Asegúrate de instalar las fuentes! ¡Sin
    eso, estarás como una persona que intenta conducir un coche con los ojos
    cerrados!)

** Crea tu propio fichero @f{TAGS}

   Bajo @k{C-h f} (@c{describe-function}), otro camino para ver la fuente de
   una función es escribir @k{M-.} (@c{find-tag}) y el nombre de la función
   se asigna para eso. Esto es un buen hábito para obtenerlo. El comando
   @k{M-.} (@c{find-tag}) toma directamente a las fuentes de una función,
   variable, o nodo. La función depende de tablas de etiquetas para saber
   donde ir.

   Si la función @c{find-tag} pregunta primero por el nombre de una tabla
   @f{TAGS}, dado el nombre de un fichero @f{TAGS} tal como
   @f{/usr/local/src/emacs/src/TAGS}. (La ruta exacta a tu fichero @f{TAGS}
   depende de cómo tu copia de Emacs fué instalada. Yo te cuento la
   localización que provee tanto mi C y mis fuentes de Emacs Lisp.)

   Se puede también crear tu propio fichero @f{TAGS} para los directorios que
   faltan.

   Con frecuencia se necesita construir e instalar etiquetas de tablas por
   uno mismo. Esas no son construidas automáticamente. Una tabla de etiquetas
   llama a un fichero @f{TAGS}; el nombre es letras mayúsculas.

   Se puede crear un fichero @f{TAGS} llamando el programa @c{etags} que
   viene como parte de la distribución Emacs. Normalmente, @c{etags} está
   compilado e instalado cuando Emacs se construye. (@c{etags} no es una
   función Lisp o una parte de Emacs; eso es un programa C.)

   Para crear el fichero @f{TAGS}, primero cambia el directorio en el que se
   quiere crear el fichero. En Emacs se puede hacer esto con el comando
   @k{M-x cd}, o visitando un fichero en el directorio, o listando el
   directorio @c{etags *.el} como el comando a ejecutar

   @example
     M-x compile RET etags *.el RET
   @end example

   crear un fichero de @f{TAGS} para Emacs Lisp.

   Por ejemplo, si se tiene un gran número de ficheros en el directorio
   @f{~/emacs}, como se hace––Yo tengo 137 @f{.el} dentro, de que se carguen
   12––se puede crear un fichero @f{TAGS} para los ficheros Emacs Lisp en
   este directorio.

   El programa @c{etags} toma en toda la consola usual ‘comodines’. Por
   ejemplo, si tienes dos directorios para el que quieres un fichero @f{TAGS}
   simple, escribe @c{etags *.el ../elisp/*.el}, donde @f{../elisp/} es el
   segundo directorio:

   @example
     M-x compile RET etags *.el ../elisp/*.el RET
   @end example

   Tipo

   @example
     M-x compile RET etags --help RET
   @end example

   para ver una lista de las opciones aceptadas por @c{etags} tan bien como
   una lista de lenguajes soportados.

   El programa @c{etags} maneja más de 20 lenguajes, incluyendo Emacs Lisp,
   Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java, LaTeX, Pascal,
   Perl, Postscript, Python, TeX, Texinfo, makefiles, y la mayoría de
   ensambladores. El programa no cambia para especificar el lenguaje; eso
   reconoce el lenguaje como una entrada de fichero de acuerdo a su nombre de
   fichero y contenidos.

   @f{etags} es muy útil cuando se escribe código por tí mismo y quiere
   referirse a funciones que ya se han escrito. Ahora ejecuta @c{etags} de
   nuevo en intervalos como se escriben nuevas funciones, así llegan a ser
   parte del fichero @f{TAGS}.

   Si piensa que un fichero @f{TAGS} apropiado que ya existe para lo que
   quieres, pero no conoces donde está, se puede usar el programa @c{locate}
   para intentar encontrarlo.

   Escribe @k{M-x locate @k{RET} TAGS @k{RET}} y Emacs listará para ti las
   rutas nombres completas de todos tus ficheros @f{TAGS}. En mi sistema,
   este comando lista 34 fichero @f{TAGS}.  Por otro lado, un sistema
   ‘vanilla plano’ que recientemente no contenía fichero @f{TAGS}.

   Si la tabla de etiquetas que se quiere ha sido creada, se puede usar el
   comando @c{M-x visit-tags-table} para especificarlo. De otro modo, se
   necesitará la tabla de etiquetas por tí mismo y entonces usar @c{M-x
   visit-tags-table}.

*** Construyendo Etiquetas en las fuentes Emacs

    Las fuentes GNU Emacs vienen con un @f{Makefile} que contiene un comando
    sofisticado @c{etags} que crea, recoge, y asocia tablas de etiquetas de
    todas las fuentes de Emacs y pone la información dentro de un fichero
    @f{TAGS} en el directorio @f{src/}. (El directorio @f{src/} está debajo
    del alto nivel de tu directorio Emacs.)

    Para construir este fichero @f{TAGS}, se puede ir al alto nivel de
    directorio de fuentes Emacs y ejecutar el comando de compilar @c{make
    tags}:

    @example
      M-x compile RET make tags RET
    @end example

    (El comando @c{make tags} trabaja bien con las fuentes de GNU Emacs, tan
    bien como con otros paquetes fuentes.)

    Para más información, mira @"{Tablas de Etiquetas} en @e(El Manual GNU
    Emacs).

** Repaso

   Aquí hay un breve resumen de algunas funciones introducidas recientemente.

   - while ::

     Repetidamente evalúa el cuerpo de la expresión tan larga como el primer
     elemento del cuerpo chequea cierto. Entonces devuelve @c{nil}. (La
     expresión es evaluado solo por sus efectos laterales.)

     Por ejemplo:

     @example
       (let ((foo 2))
         (while (> foo 0)
           (insert (format "foo is %d.\n" foo))
           (setq foo (1- foo))))

            ⇒      foo is 2.
                    foo is 1.
                    nil
     @end example

     (La función @c{insert} inserta sus argumentos en el punto; la función
     @c{format} devuelve una cadena formateada desde sus argumentos el camino
     @c{message} formatea sus argumentos; @c{\n} produce una nueva línea.)

   - re-search-forward ::

     Busca un patrón, y si el patrón se encuentra, mueve el punto al resto
     solo después de eso.

     Toma cuatro argumentos, como @c{search-forward}:

     1. Una expresión regular que especifica el patrón para
        buscarlo. (¡Recuerda por marcas de comillas alrededor de este
        argumento!)

     2. Opcionalmente, el límite de la búsqueda.

     3. Opcionalmente, que haces si la búsqueda falla, devuelve @c{nil} o un
        mensaje de error.

     4. Opcionalmente, cuántas veces se puede repetir la búsqueda; si es
        negativa, la búsqueda va hacia atrás.


   - let* ::

     Asocia algunas variables localmente a valores particulares, y entonces
     evalúa los argumentos que permanencen, devolviendo el valor del
     último. Mientras se asocian las variables locales, se usan los valores
     locales de variables asociadas pronto, si acaso.

     Por ejemplo:

     @example
       (let* ((foo 7)
             (bar (* 3 foo)))
         (message "`bar' is %d." bar))
            ⇒ `bar' is 21.
     @end example

   - match-beginning ::

     Devuelve la posición del principio del texto encontrado por la última
     búsqueda de la expresión regular.

   - looking-at ::

     Devuelve @c{t} para verdadero si el texto después del punto se asocia al
     argumento, que debería ser una expresión.

   - eobp ::

     Devuelve @c{t} para cierto si el punto está en el fin de la parte
     accesible de un búffer. El fin de la parte accesible es el fin del
     búffer no está encogido; eso es el fin de la parte encogida si el búffer
     está encogido.

** Ejercicios con @c{re-search-forward}

   - Escribe una función para buscar para una expresión que detecte dos o más
     líneas blancas en secuencia.

   - Escribe una función para buscar palabras duplicadas, tales como ‘el
     el’. Véase Sección @"{Sintaxis para Expresiones Regulares} en @e(El
     Manual de GNU Emacs), para información de cómo escribir un regexp (una
     expresión regular) para asociar una cadena que se compone de dos mitades
     idénticas. Se puede disponer de varios regexps; algunos son mejores que
     otros. La función que se usa es descrito en un apéndice, a lo largo de
     varios regexps. Véase Sección @l{the-the, , Función de Palabras
     Duplicadas @c{the-the}}.

* Contando: repetición y regexps

  La repetición y búsqueda de expresiones regulares son herramientas
  poderosas que con frecuencia se usan cuando se escribe código en Emacs
  Lisp. Este capítulo ilustra el uso de búsqueda de expresiones regulares a
  través de la construcción de comandos de contaje de palabras usando bucles
  @c{while} y recursión.

  La distribución de Emacs estándar contiene una función para contar el
  número de líneas en una región.

  Hay cierto tipo de pregunta escrita para contar palabras. De este modo, si
  se escribe un ensayo, puede limitarse a 800 palabras; si se escribe una
  novela, te puedes disciplinar a ti mismo a escribir 1000 palabras al
  día. Parece raro, pero durante mucho tiempo, a Emacs le faltó un comando
  para contar palabras. Quizás la gente usaba Emacs mayoritariamente para
  codificar o documentar cosas que no requieren contar palabras, o quizás se
  restringían al sistema operativo el comando de contar palabras, @c{wc}. De
  manera alternativa, la gente puede seguir la convención de las editoriales
  y computaban un contaje de palabras dividiendo el número de caracteres en
  un documento por cinco.

  Hay mucho caminos para implementar un comando para contar palabras. Aquí
  hay algunos ejemplos, que pueden desear compararse con el comando de Emacs
  estándar, @c{count-words-region}.

** La función @c{@v{COUNT-WORDS}}

   Un comando de contar palabras podría contar palabras en una línea,
   párrafo, región, o búffer. ¿Qué comando funcionaría? Se podría diseñar el
   comando para contar el número de palabras en un búffer completo. Sin
   embargo, la tradición Emacs anima a la flexibilidad––se puede querer
   contar palabras solo en una sección, en vez de en todo un búffer. Así,
   tiene más sentido diseñar el comando para contar el número de palabras en
   una región. Una vez tienes un comando @c{count-words-region}, se puede, si
   desea, contar palabras en un búffer completo marcándolo con @k{C-x h}
   (@c{mark-whole-buffer}).

   Claramente, contar palabras es un acto repetitivo: empezando desde el
   principio de la región, se cuenta la primera palabra, entonces la segunda
   palabra, entonces la tercera palabra, y así, hasta que logres el fin de la
   región. Esto significa que contar palabras se ajusta idealmente a
   recursión o a un bucle @c{while}.

   Primero, implementaremos el comando de contar palabras con un bucle
   @c{while}, entonces con la recursión. El comando, de acuerdo, será
   interactivo.

   La plantilla para una definición de función interactiva es, como siempre:

   @example
     (defun @V{name-of-function} (@V{argument-list})
       "@V{documentation}…"
       (@V{interactive-expression}…)
       @V{body}…)
   @end example

   Lo que necesitamos hacer es rellenar los slots.

   El nombre de la función sería auto-explicativo y similar al nombre del
   @c{count-lines-region} existente. Esto hace que el nombre sea fácil de
   recordar. @c{count-words-region} es una buena elección. Puesto que el
   nombre se usa ahora para el comando de Emacs estándar para contar
   palabras, nosotros nombraremos nuestra implementación como
   @c{@v{COUNT-WORDS}}.

   La función cuenta palabras con una región. Esto significa que el argumento
   lista debe contener símbolos que son asociados a las dos posiciones, el
   principio y fin de la región. Estas dos posiciones puede ser llamadas
   @'{beginning} y @'{end} respectivamente. La primera línea de la
   documentación sería una frase simple, desde que esto es todo lo que está
   impreso como documentación por un comando tal como @c{apropos}. La
   expresión interactiva será de la forma @'{(interactive "r")}, puesto que
   causará que Emacs pase al principio y fin de la región a la lista de
   argumentos de función. Todo esto es rutina.

   El cuerpo de la función necesita ser escrita para hacer tres tareas:
   primero, configurar condiciones bajo las que el bucle @c{while} pueda
   contar palabras, segundo, ejecutar el bucle @c{while}, y tercero, enviar
   un mensaje al usuario.

   Cuando un usuario llama a @c{@v{COUNT-WORDS}}, apunta a que puede estar al
   principio o fin de la región. Sin embargo, el proceso de conteo debe
   empezar al principio de la región. Esto significa que querremos poner el
   punto que hay si eso no está allí. Ejecutando @c{(goto-char beginning)}
   asegura esto. De acuerdo, querremos devolver el punto a su posición
   esperada cuando la función finalice su trabajo. Por esta razón, el cuerpo
   debe ser encerrado en una expresión @c{save-excursion}.

   La parte central del cuerpo de la función consiste en un bucle @c{while}
   en el que una expresión salta el punto hacia delante palabra por palabra,
   y otra expresión cuenta estos saltos. Si el test-verdadero-o-falso del
   bucle @c{while} es verdadero, el punto saltaría hacia adelante, y si es
   falso el punto estaría al fin de la región.

   Nosotros podríamos usar @c{(forward-word 1)} como la expresión para mover
   el punto hacia adelante palabra por palabra, pero eso es fácil de ver que
   Emacs identifica como una ‘palabra’ si se usa una búsqueda de expresión
   regular.

   Una expresión regular busca lo que encuentra el patrón que se está
   buscando deja el punto después del último carácter emparejado. Esto
   significa que una sucesión de palabras exitosas busquen que moverá el
   punto adelante palabra por palabra.

   Como materia práctica, se quiere que la expresión regular se busque para
   saltar a través de un espacio en blanco y puntúe entre palabras tan bien a
   través de las palabras en sí. Una expresión regexp que rechaza para saltar
   a través de espacios en blanco entre palabras ¡nunca saltaría más de una
   palabra!. Esto significa que el regexp incluiría el espacio en blanco y la
   puntuación sigue a una palabra cualquiera, como la palabra en sí. (Una
   palabra puede finalizar un búffer y no tiene cualquier espacio en blanco o
   puntuación, así esta parte del regexp debe ser opcional.)

   De este modo, queremos para el regexp es un patrón definiendo una o más
   palabras de caracteres que constituyen caracteres seguidos, opcionalmente,
   por uno o más caracteres que no son palabras constituyentes. La expresión
   regular para esto es:

   @example
     \w+\W*
   @end example

   La tabla de sintaxis del búffer determina qué caracteres son y no son
   palabras constituyentes. Para más información acerca de sintaxis, Vease
   Sección @"{Tablas de Sintaxis} @e(El Manual de Referencia de GNU Emacs
   Lisp).

   La expresión se parece a esto:

   @example
     (re-search-forward "\\w+\\W*")
   @end example

   (Note que las barras invertidas que preceden el @'{w} y @'{W}. Una barra
   invertida tiene significado especial al intérprete Emacs Lisp. Eso indica
   que el caracter siguiente es interpretado de manera diferente que la
   normal. Por ejemplo, los dos caracteres, @'{\n}, son una @'{nueva línea},
   en vez de una barra invertida seguida por @'{\n}. Dos barras invertidas en
   una fila para una ‘barra invertida no especial’, así Emacs Lisp interpreta
   el fin de mirar una barra invertida simple seguida por una letra. Así
   descubre la letra que es especial.)

   Se necesita un contador para contar cuántas palabras hay; esta variables
   debe primero ser asignado a 0 y entonces incrementados cada vez que Emacs
   va alrededor del bucle @c{while}. La expresión de incremento es simple:

   @example
     (setq count (1+ count))
   @end example

   Finalmente, se quiere contar al usuario cuántas palabras hay en la
   región. La función @c{message} presenta este tipo de información al
   usuario. El mensaje tiene que ser fraseado de manera que se lea
   apropiadamente sin cuidado de cuantas palabras hay en la región: no se
   quiere decir que “hay una palabra en la región”. El conflicto entre
   singular y plural no es gramatical. Se puede resolver este problema usando
   una expresión condicional que evalúa diferentes mensajes dependiendo en el
   número de palabras en la región. Hay tres posibilidades: no palabras en la
   región, una palabra en la región, y más de una palabra. Esto significa que
   la forma especial @c{cond} es apropiada.

   Todo esto lidera a la siguiente definición de función:

  @example
     ;;; @e{¡La Primera versión; tiene errores!}
     (defun count-words-region (beginning end)
       "Imprime el número de palabras en la región.
     Las palabras están definidas al menos una palabra
     constituida de caracteres seguido por al menos un
     caracter que no constituye palabra. La tabla de
     sintaxis del búffer determina qué caracteres hay."
       (interactive "r")
       (message "Contando palaras en la región ... ")

     ;;; @e{1. Configurar condiciones apropiadas.}
       (save-excursion
         (goto-char beginning)
         (let ((count 0))

     ;;; @e{2. Ejecutar el} @e{bucle} while.
           (while (< (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))

     ;;; @e{3. Enviar un mensaje al usuario.}
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message
                   "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   @end example

   Como se escribe, la función funciona, pero no en todas las circunstancias.

*** El error de espacio en blanco en @c{@v{COUNT-WORDS}}

    El comando @c{@v{COUNT-WORDS}} descrito en la sección precedente tiene
    dos errores, o incluso, un error con dos manifestaciones. Primero, si se
    marca una región conteniendo solo espacio en blanco en el medio de algún
    texto el comando ¡@c{@v{COUNT-WORDS}} cuenta que la región contiene una
    palabra!. Segundo, si se marca una región conteniendo solo espacios en
    blanco al final del búffer o la porción accesible de un búffer encogido,
    el comando muestra un mensaje de error que se parece a esto:

    @example
      Búsqueda fallida: "\\w+\\W*"
    @end example

    Si está leyendo esto en Info en GNU Emacs, se puede testear para estos
    errores por sí mismo.

    Primero, evalúa la función de la manera usual para instalarlo.

    @ignore
      Aquí hay una copia de la definición. Emplaza tu cursor
      después de cerrar los paréntesis y escribir @k{C-x C-e} para
      instalarlo.

      @example
        ;; @e{¡La Primera versión; tiene errores!}  (defun
        @v{COUNT-WORDS} (beginning end)
        "Imprime el número de palabras en la región.  Las palabras son
        definidas como al menos un caracter de palabra constituida seguida por
        al menos un caracter que no es una palabra constituyente. La tabla de
        sintaxis del búffer determina qué caracteres hay."

          (interactive "r")
          (message "Contando palabras en la región ... ")

        ;;; @e{1. Configurar condiciones apropiadas.}
          (save-excursion
            (goto-char beginning)
            (let ((count 0))

        ;;; @e{2. Ejecutar el} @e{bucle} while.
              (while (< (point) end)
                (re-search-forward "\\w+\\W*")
                (setq count (1+ count)))

        ;;; @e{3. Envía un mensaje al usuario.}
              (cond ((zerop count)
                     (message "La región no tiene palabras."))
                    ((= 1 count) (message "The región tiene 1 palabra."))
                    (t (message "La región tiene %d palabras." count))))))
      @end example
    @end ignore

    Si se desea, se puede también instalar este atajo para ser evaluado:

    @example
      (global-set-key "\C-c=" '@v{COUNT-WORDS})
    @end example

    Para conducir el primer test, asigna marca y punto al principio y fin de
    la siguiente línea y entonces escribe @k{C-c =} (o @k{M-x
    @v{COUNT-WORDS}} si no se ha asignado @k{C-c =}):

    @example
          uno   dos  tres
    @end example

    Emacs te contará, correctamente, que la región tiene tres palabras.

    Repite el test, pero marca el lugar al principio de la línea y emplaza el
    punto justo @e{antes} de la palabra @'{uno}. De nuevo escribe el comando
    @k{C-c =} (o @k{M-x @v{COUNT-WORDS}}). Emacs cuenta que la región no
    tiene palabras, puesto que eso está compuesto solo por espacios en blanco
    al principio de la línea. ¡Pero en vez de que Emacs cuente que la región
    tiene una palabra!

    Para el tercer test, copia la línea de ejemplo al fin del búffer
    @f{*scratch*} y entonces escribe varios espacios al fin de la
    línea. Posiciona la marca correcta después de la palabra @'{tres} y
    apunta al fin de la línea. (El fin de la línea será el fin del búffer.)
    Escribe @k{C-c =} (o @k{M-x @v{COUNT-WORDS}}) como se hizo antes. De
    nuevo, Emacs te contaría que la región no tiene palabras, puesto que eso
    está compuesto solo de los espacios en blanco al fin de la línea. En vez
    de eso, Emacs muestra un mensaje de error diciendo @'{Búsqueda fallida}.

    Los dos errores queman el mismo problema.

    Considere la primera manifestación del error, en el que el comando te
    cuenta que el espacio en blanco al principio de la línea contiene una
    palabra. Lo que ocurre es esto: El comando @c{M-x @v{COUNT-WORDS}} mueve
    el punto al principio de la región. El test @c{while} si el valor del
    punto es más pequeño de lo que el valor de @c{end}, que es. Por
    consiguiente, en la expresión regular se busca y encuentra la primera
    palabra. Eso deja el punto después de la palabra. @c{count} que se
    establece a uno. El bucle @c{while} repite; pero esta vez el valor del
    punto es más largo que el valor de @c{end}, el bucle sale; y la función
    muestra un mensaje diciendo el número de palabras en la región es uno. En
    breve, la expresión regular busca y encuentra la palabra incluso aunque
    eso esté fuera de la región marcada.

    En la segunda manifestación del error, la región es un espacio en blanco
    al fin del búffer. Emacs dice @'{Búsqueda fallida}. Lo que ocurre es que
    true-or-false-test en el bucle @c{while} chequea verdad, así la expresión
    de búsqueda es ejecutada. Pero desde que no hay más palabras en el
    buffer, la búsqueda falla.

    En ambas manifestaciones del error, la búsqueda extiende o intenta
    extenderse fuera de la región.

    La solución es limitar la búsqueda a la región––esto es una acción simple
    y limpia, pero como tu puedes tener que llegar a esperar, eso no es tan
    simple como se podría pensar.

    Como se ha visto, la función @c{re-search-forward} toma un patrón de
    búsqueda como su primer argumento. Pero además de este primer, argumento
    obligatorio, se aceptan tres argumentos opcionales. El segundo argumento
    opcional asocia la búsqueda. El tercer argumento opcional, si @c{t},
    causa la función a devolver @c{nil} en vez de la señal un error si la
    búsqueda falla. El cuarto argumento opcional es un contador repetido. (En
    Emacs, se puede ver una documentación de la función escribiendo @k{C-h
    f}, el nombre de la función, y entonces @k{RET}.)

    En la definición @c{@v{COUNT-WORDS}}, el valor del fin de la región es
    tomada por la variable @c{end} que es pasada como un argumento para la
    función. De este modo, se puede añadir @c{end} como un argumento para la
    búsqueda de la expresión de búsqueda:

    @example
      (re-search-forward "\\w+\\W*" fin)
    @end example

    Sin embargo, si se crea solo este cambio a la definición
    @c{@v{COUNT-WORDS}} y entonces se chequea la nueva versión de la
    definición en una extensión de espacio en blanco, se recibirá un mensaje
    de error diciendo @'{Búsqueda fallida}.

    Lo que ocurre es esto: la búsqueda se limita a la región, y falla como se
    espera porque no hay caracteres de palabras constituyentes en la
    región. Puesto que eso falla, se recibe un mensaje de error. Pero no
    queremos recibir un mensaje de error en este caso; se quiere recibir el
    mensaje que "La región no tiene palabras".

    La solución a este problema es proveer @c{re-search-forward} con un
    tercer argumento de @c{t}, que causa la función para devolver @c{nil} en
    vez la señalar un error si la búsqueda falla.

    Sin embargo, si se crea este cambio y se intenta, se verá el mensaje
    “Contando palabras en la región ...” y … se guardará viendo qué mensaje
    …, hasta que se escribe @k{C-g} (@c{keyboard-quit}).

    Aquí está lo que ocurre: la búsqueda está limitada a la región, como
    antes, y eso falla porque no hay caracteres no constituyentes de palabras
    en la región, como se espera. Por tanto, la expresión
    @c{re-search-forward} devuelve @c{nil}. Eso no hace nada más. En
    particular, no mueve el punto, que hace como un efecto secundario si se
    encuentra la búsqueda objetiva. Después la expresión
    @c{re-search-forward} devuelve @c{nil}, la siguiente expresión en el
    bucle @c{while} está evaluado. Esta expresión incrementa el
    contador. Entonces el bucle repite. El test true-or-false-test chequea
    cierto porque el valor del punto es todavía menor que el valor final,
    desde que la expresión @c{re-search-forward} no movería el punto. … y el
    ciclo repite …

    La definición @c{@v{COUNT-WORDS}} requiere todavía de otra modificación
    para causar el true-or-false-test del bucle @c{while} para chequear falso
    si la búsqueda falla. Pon otro camino, hay dos condiciones que deben ser
    satisfechas en el true-or-false-test antes que el contador de palabras
    variable se incremente: el punto debe todavía estar con la región y la
    expresi@'n de búsqueda debe haber encontrado una palabra para contar.

    Por ambas la primera condición y la segunda condición deben ser ciertas
    juntas, las dos expresiones, la región chequea y la expresión de
    búsqueda, puede estar unido con una forma especial @c{and} y embebido en
    el bucle @c{while} como el true-or-false-test, como esto:

    @example
      (and (< (point) end) (re-search-forward "\\w+\\W*" end t))
    @end example

    (Para información acerca de @c{and}, ver @"{La función @c{kill-new}}.)

    La expresión @c{re-search-forward} devuelve @c{t} si la búsqueda es
    exitosa y como efecto secundario se mueve el punto. Consiguientemente, como
    las palabras se encuentran, el punto es movido a través de la
    región. Cuando la búsqueda de la expresión falla para encontrar otra
    palabra, o cuando el punto logra el fin de la región, el test
    true-or-false-test es falso, el bucle @c{while} existe, y la función
    @c{@v{COUNT-WORDS}} muestra uno u otro de sus mensajes.

    Después de incorporar estos cambios finales, el @c{@v{COUNT-WORDS}}
    funciona sin errores (¡o al menos, sin los errores que yo haya
    encontrado!. Aquí está lo que parece:

    @example
      ;;; @e{Versión final:} @c{while}
      (defun @v{COUNT-WORDS} (beginning end)
        "Imprime número de palabras en la región."
        (interactive "r")
        (message "Contando palabras en la región ... ")

      ;;; @e{1. Configura condiciones apropiadas.}
        (save-excursion
          (let ((count 0))
            (goto-char beginning)

      ;;; @e{2. Ejecuta el} @e{bucle} while
            (while (and (< (point) end)
                        (re-search-forward "\\w+\\W*" end t))
              (setq count (1+ count)))

      ;;; @e{3. Enviar un mensaje al usuario.}
            (cond ((zerop count)
                   (message
                    "La región no tiene palabras."))
                  ((= 1 count)
                   (message
                    "La región tiene 1 palabra."))
                  (t
                   (message
                    "La región tiene %d palabras." count))))))
    @end example

** Cuenta palabras recursivamente

   Se puede escribir la función para contar palabras tanto de manera
   recursiva como con un bucle @c{while}. Permita ver cómo se hace.

   Primero, se necesita reconocer que la función @c{@v{COUNT-WORDS}} tiene
   tres trabajos: eso configura las condiciones apropiadas para contar lo que
   ocurre; eso cuenta las palabras en la región; y envía un mensaje al
   usuario contando cuántas palabras hay.

   Si se escribe una función recursiva simple para hacer cualquier cosa se
   recibirá un mensaje para cada llamada recursiva. Si la región contiene 13
   palabras, se recibirán trece mensajes, uno correcto después del otro. ¡No
   queremos esto!. En vez de eso, se deben escribir dos funciones para hacer
   el trabajo, una (la función recursiva) será usada dentro de la otra. Una
   función configurará las condiciones y muestra el mensaje; la otra
   devolverá el contador de palabras.

   Permítase comenzar con la función que causa el mensaje que se muestra. Se
   puede continuar por llamarse @c{@v{COUNT-WORDS}}.

   Esta es la función que el usuario llama. Será interactiva. En realidad,
   será similar a nuestras versiones previas de esta función, excepto que
   llamará @c{recursive-count-words} para determinar cuántas palabras hay en
   la región.

   Se puede construir una plantilla legible para esta función, basada en
   versiones previas:

   @example
     ;; @e{Versión Recursiva; usa la búsqueda de la expresión regular}
     (defun @v{COUNT-WORDS} (beginning end)
       "@V{documentation}…"
       (@V{interactive-expression}…)

     ;;; @e{1. Configura condiciones apropiadas.}
       (@V{explanatory message})
       (@V{set-up functions}…

     ;;; @e{2. Contar las palabras.}
         @V{recursive call}

     ;;; @e{3. Envía un mensaje al usuario.}
         @V{message providing word count}))
   @end example

   La definición parece sencilla, excepto que como el contador devuelve la
   llamada recursiva que debe ser pasada al mensaje mostrando el contaje de
   palabras. Un pequeño pensamiento sugiere que esto puede ser hecho haciendo
   uso de una expresión @c{let} al número de palabras en la región, como se
   devuelve por la llamada recursiva; y entonces la expresión @c{cond}, que
   usa la asociación, puede mostrar el valor al usuario.

   Con frecuencia, uno piensa que se puede asociar una expresión @c{let} como
   algo secundario al trabajo ‘primario’ de una función. Pero en este caso,
   se podría considerar el trabajo ‘primario’ de la función, contando
   palabras, esto es hecho con la expresión @c{let}.

   Usando @c{let}, la definición de función se parece a:

   @example
     (defun @v{COUNT-WORDS} (beginning end)
       "Imprime el número de palabras en la región."
       (interactive "r")

     ;;; @e{1. Configura condiciones apropiadas.}
       (message "Contando palabras en la región ... ")
       (save-excursion
         (goto-char beginning)

     ;;; @e{2. Contar las palabras.}
         (let ((count (recursive-count-words end)))

     ;;; @e{3. Enviar un mensaje al usuario.}
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message
                   "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   @end example

   Lo siguiente, que se necesita es escribir la función de contaje recursivo.

   Una función recursiva tiene al menos tres partes: el ‘do-again-test’, la
   ‘next-step-expression’, y la llamada recursiva.

   El do-again-test determina si la función será o no llamada de
   nuevo. Puesto que estamos contando palabras en una región y puede causar
   que una función se mueva el punto hacia delante por cada palabra, el
   do-again-test puede chequear si el punto está todavía con la región. El
   do-again-test encontraría el valor del punto y determina si el punto está
   antes, en, o después del valor del fin de la región. Se puede usar la
   función @c{point} para localizar el punto. Claramente, se debe pasar el
   valor del fin de la región a la función de contaje recursivo como un
   argumento.

   Además, el do-again-test también chequea si la búsqueda encuentra una
   palabra. Si no, la función no se llamaría de nuevo.

   La next-step-expression cambia un valor así que cuando la función
   recursiva se supone que debe parar de llamarse así misma, se para. Más
   precisamente, los cambios de next-step-expression cambia un valor así en
   el momento adecuado, el do-again-test para la función recursiva de la
   llamada en sí de nuevo. En este caso, la next-step-expression puede ser la
   expresión que mueve el punto hacia adelante, palabra por palabra.

   La tercera parte de una función recursiva es la llamada recursiva.

   En algún lugar, también, se necesita una parte que hace el ‘trabajo’ de la
   función, una parte que es el contaje. ¡Una parte vital!

   Pero ya, tenemos un guión de la función recursiva de contaje:

   @example
     (defun recursive-count-words (region-end)
       "@V{documentation}…"
        @V{do-again-test}
        @V{next-step-expression}
        @V{recursive call})
   @end example

   Ahora se necesita rellenar los slots. Permite comenzar con el caso más
   simple primero: si se apunta debajo del fin de la región, no puede haber
   palabras en la región, así la función devuelve cero. De otro modo, si la
   búsqueda falla no hay palabras para contar, así la función devolvería
   cero.

   Por otro lado, si se apunta con la región y la búsqueda tiene éxito, la
   función se llamaría de nuevo.

   De este modo, do-again-test se vería así:

   @example
     (and (< (point) region-end)
          (re-search-forward "\\w+\\W*" region-end t))
   @end example

   Note que la expresión de búsqueda es parte del do-again-test --- la
   función devuelve @c{t} si su búsqueda tiene éxito y @c{nil} si
   falla. (Véase Sección @l{Error de espacio en blanco, , El Error de Espacio
   en Blanco en @c{@v{COUNT-WORDS}}}), para una explicación de cómo
   @c{re-search-forward} funciona.)

   El do-again-test es el test true-or-false de una cláusula
   @c{if}. Claramente si el do-again-test tiene éxito, la then-part de la
   cláusula @c{if} llamaría a la función; pero si eso falla, la else-part
   devolvería cero desde que el punto está fuera de la región o la búsqueda
   falló porque no había palabras a encontrar.

   Pero antes de considerar la llamada recursiva, se necesita considerar la
   next-step-expression. ¿Qué es eso? De manera interesante, eso es la parte
   de la búsqueda del do-again-test.

   Además para devolver @c{t} o @c{nil} para el do-again-test,
   @c{re-search-forward} mueve el punto hacia adelante como un efecto secundario
   de una búsqueda exitosa. Esta es la acción que cambia el valor de punto
   así que la función recursiva para de llamarse a sí misma cuando el punto
   complete su movimiento a través de la región. Por consiguiente, la
   expresión @c{re-search-forward} es la next-step-expression.

   En esquema, entonces, el cuerpo de la función @c{recursive-count-words} se
   parece a esto:

   @example
     (if @V{do-again-test-and-next-step-combined}
         ;; @e{then}
         @V{recursive-call-returning-count}
       ;; @e{else}
       @V{return-zero})
   @end example

   ¿Cómo incorporar el mecanismo que cuenta?

   Si no estás acostumbrado a escribir funciones recursivas, una pregunta
   como esta puede ser un problema. Pero eso puede y sería enfocado
   sistemáticamente.

   Se sabe que el mecanismo de contaje sería asociado en algún lugar con la
   llamada recursiva. En vez de eso, desde que la next-step-expression mueve
   el punto hacia adelante por una palabra, y desde que una llamada recursiva
   es hecha para cada palabra, el mecanismo de contaje debe ser una expresión
   que añade uno al valor devuelto por una llamada para
   @c{recursive-count-words}

   Considera varias casos:

   - Si hay dos palabras en la región, la función devolverá un valor
     resultante de añadir uno al valor devuelto al contar la primera palabra,
     más el número devuelto al contar las palabras que permanecen en la
     región, que en este caso es una.

   - Si hay una palabra en la región, la función devolvería un valor
     resultante de añadir uno al valor devuelto cuando eso cuenta esta
     palabra más el número devuelto cuando eso cuenta las palabras que
     permanecen en la región, que en este caso es cero.


   - Si no hay palabras en la región, la función devolvería cero.


   Desde el esquema se puede ver que la parte else del @c{if} devuelve cero
   para el caso en el que no hay palabras. Esto significa que la parte then
   del @c{if} debe devolver un valor resultante de añadir uno al valor
   devuelto desde el contaje de las palabras que permanecen.

   La expresión se parece a esto, donde @c{1+} es una función que añade uno a
   su argumento.

   @example
     (1+ (recursive-count-words region-end))
   @end example

   La función completa @c{recursive-count-words} entonces se parecerá e esto:

   @example
     (defun recursive-count-words (region-end)
       "@V{documentation}…"

     ;;; @e{1. do-again-test}
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; @e{2. then-part: la llamada recursiva}
           (1+ (recursive-count-words region-end))

     ;;; @e{3. else-part}
         0))
   @end example

   Permíteme examinar cómo esto funciona:

   Si no hay palabras en la región, la parte else de la expresión @c{if} es
   evaluada y, por tanto, la función devuelve cero.

   Si hay una palabra en la región, el valor del punto es menor que el valor
   de @c{region-end} y la búsqueda tiene éxito. En este caso, el
   true-or-false-test de la expresión @c{if} chequea cierto, y la then-part
   de la expresión @c{if} es evaluada. La expresión de contaje se
   evalúa. Esta expresión devuelve un valor (que será el valor devuelto por
   la función completa) que es la suma de uno añadida al valor devuelto por
   una llamada recursiva.

   Mientras tanto, la next-step-expression ha causado el punto para saltar a
   través de la primera (y en este caso única) palabra en la región. Esto
   significa que cuando @c{(recursive-count-words region-end)} está evaluada
   una segunda vez, como un resultado de la llamada recursiva, el valor del
   punto será igual o mayor que el valor de la región final. Así esta vez,
   @c{recursive-count-words} devolverá cero. El cero será añadido a uno, y la
   evaluación original de @c{recursive-count-words} devolverá uno más cero
   (uno) que es la cantidad correcta.

   Claramente, si hay dos palabras en la región, la primera llamada a
   @c{recursive-count-words} devuelve uno que se añade al valor devuelto por
   el siguiente @c{recursive-count-words} en una región donde está la palabra
   que permanece––que es, eso añadir uno a uno, produciendo dos, que es la
   cantidad correcta.

   Similarmente, si hay tres palabras en la región, la primera llamada
   @c{recursive-count-words} devuelve uno añadido al valor devuelto llamado
   @c{recursive-count-words} en una región conteniendo las dos palabras que
   faltan––y así.

   Con documentación completa las dos funciones se parecen a esto:

   La función recursiva:

   @example
     (defun recursive-count-words (region-end)
       "Número de palabras entre punto y REGION-END."

     ;;; @e{1. do-again-test}
       (if (and (< (point) region-end)
                (re-search-forward "\\w+\\W*" region-end t))

     ;;; @e{2. then-part: la llamada recursiva}
           (1+ (recursive-count-words region-end))

     ;;; @e{3. else-part}
         0))
   @end example

   El envoltorio:

   @example
     ;;; @e{Versión Recursiva}
     (defun @v{COUNT-WORDS} (beginning end)
       "Imprime el número de palabras en la región.

     Las palabras son definidas como al menos una palabra constituyente
     seguida por al menos un caracter que es una palabra constituyente. La
     tabla de sintaxis del buffer determina qué caracter hay.
       (interactive "r")
       (message "Contando palabras en la región ... ")
       (save-excursion
         (goto-char beginning)
         (let ((count (recursive-count-words end)))
           (cond ((zerop count)
                  (message
                   "La región no tiene palabras."))
                 ((= 1 count)
                  (message "La región tiene 1 palabra."))
                 (t
                  (message
                   "La región tiene %d palabras." count))))))
   @end example

** Ejercicio: contando puntuación

   Usando un bucle @c{while}, escriba una función para contar el número de
   marcas de puntuación en una región––periodo, coma, punto y coma, dos
   puntos, exclamación, marca y marca de pregunta. Haga lo mismo usando
   recursión.

* Contando palabras en una @c{defun}

  El siguiente proyecto es contar el número de palabras en una definición de
  función. Claramente, esto se puede hacer usando alguna variante de
  @c{@v{COUNT-WORDS}}. Véase Sección @l{Contando palabras, , Contando
  palabras: repetición y regexps}. Si se está ahora yendo a contar las
  palabras en una definición, es suficientemente fácil marcar la definición
  con el comando @k{C-M-h} (@c{mark-defun}), y entonces se llama a
  @c{@v{COUNT-WORDS}}.

  Sin embargo, soy más ambicioso: Yo quiero contar las palabras y símbolos en
  cada definición en las fuentes de Emacs y entonces imprimir un grafo que
  muestre cuántas funciones hay de cada tamaño: cuántas contienen de 40 a 49
  palabras o símbolos, cuántas contienen de 50 a 59 palabras o símbolos, y
  así. Yo he sido con frecuencia curioso de cómo es una función típica, y
  esto se contará.

  Descrito en una frase, el proyecto desanima; pero dividido dentro de
  numerosos pequeños pasos, cada uno de los que podemos tomar en un momento,
  el proyecto llegar ser menos atemorizante. Permítenos considerar qué pasos
  deben ser:

  - Primero, escribe una función para contar las palabras en una
    definición. Esto incluye el problema de manejar símbolos tan bien como
    palabras.

  - Segundo, escribe una función para listar los números de palabras en cada
    función en un fichero. Esta función puede usar la función
    @c{count-words-in-defun}.

  - Tercero, escribe una función para listar los números de palabras en cada
    función en cada uno de varios ficheros. Esto encola automáticamente
    encontrando varios ficheros, cambiándolos, y contando las palabras en las
    definiciones con ellos.

  - Cuarto, escribe una función para convertir la lista de números que
    nosotros creamos en tres pasos para un formulario que se ajustará para
    imprimir un grafo.


  - Quinto, escribe una función para imprimir los resultados como un grafo.


  ¡Esto es un proyecto! Pero si tomamos cada paso lentamente, eso no será
  difícil.

** ¿Qué contar?

   Cuando nosotros primero empezamos pensando acerca del contaje de palabras
   en una definición de función, la primera pregunta es (o podría ser) ¿qué
   se va a contar?  Cuando se habla de ‘palabras’ con repecto a una
   definición de función Lisp, estamos actualmente hablando, en parte, de
   ‘símbolos’. Por ejemplo, la siguiente función @c{multiply-by-seven}
   contiene los cinco símbolos @c{defun}, @c{multipy-by-seven}, @c{number},
   @c{*}, y @c{7}. Además, en la cadena de documentación, contiene cuatro
   palabras @'{Multiplicar}, @'{NUMBER}, @'{por}, y @'{siete}. El símbolo
   @'{número} es repetido, así la definición contiene un total de diez
   palabras y símbolos.

   @example
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
   @end example

   Sin embargo, si se marca la definición @c{multiply-by-seven} con @k{C-M-h}
   (@c{mark-defun}), y entonces se llama a @c{@v{COUNT-WORDS}} dentro, se
   encontrará que @c{@v{COUNT-WORDS}} ¡reclama la definición tiene once
   palabras, no diez! ¡Alguna cosa está mal!

   El problema es doble: @c{@v{COUNT-WORDS}} no cuenta el @'{*} como una
   palabra, y eso cuenta el símbolo simple, @c{multiply-by-seven},
   conteniendo tres palabras. Las conexiones son tratadas como si fueran
   espacios entre palabras en vez de conectores entre palabras
   @'{multiply-by-seven} se cuenta como si fuese escrito
   @'{multiply-by-seven}.

   La causa de esta confusión es la expresión regular que busca la definición
   @c{@v{COUNT-WORDS}} que mueve el punto hacia delante palabra por
   palabra. En la versión canónica de @c{@v{COUNT-WORDS}}, el regexp es:

   @example
     "\\w+\\W*"
   @end example

   Esta expresión regular es un patrón definiendo una o más palabras
   constituyendo caracteres posiblemente seguidos por uno o más caracteres
   que no son palabras constituyentes. Esto significa que los ‘caracteres que
   constituyen palabras’ nos traen la cuestión de la sintaxis, que es el
   valor de una sección en sí.

** ¿Qué constituye una palabra o símbolo?

   Emacs trata diferentes caracteres perteneciendo a diferentes @:{categorías
   de sintaxis}. Por ejemplo, la expresión regular, @'{\\w+}, es un patrón
   especificando uno o más caracteres de @e{palabras constituyentes}. Los
   caracteres de palabras constituyentes son miembros de una categoría de
   sintaxis. Otras categoría de sintaxis incluye la clase de caracteres de
   puntuación, tales como el espacio en blanco o el caracter de
   tabulación. (Para más información, ver Seccion @"{La Tabla de Sintaxis} en
   @e(El Manual GNU Emacs), y Seccion @"{Tablas de Sintaxis) en @e(El Manual
   de Referencia GNU Emacs Lisp).)

   Las tablas de sintaxis especifican qué caracteres pertenecen a qué
   categorías. Normalmente un guión no está especificado como un ‘caracter
   constituido por una palabra’. En vez de eso, se especificó como estando en
   la ‘clase de caracteres que son parte de los nombres de símbolos, pero no
   las palabras.’  Esto significa que la función @c{@v{COUNT-WORDS}} se trata
   del mismo modo que trata un espacio en blanco entre palabras, que es el
   por qué @c{@v{COUNT-WORDS}} cuenta @'{multiply-by-seven} como tres
   palabras.

   Hay dos caminos para causar que Emacs cuente @'{multiply-by-seven} como un
   símbolo: modificar la tabla de sintaxis o modificar la expresión regular.

   Se podría redefinir un guión (@e{hyphen}) como un caracter que constituye
   una palabra modificando la tabla de sintaxis que Emacs guarda por cada
   modo. Esta acción serviría nuestro propósito, excepto que una conexión es
   meramente el caracter más común con símbolos que no son típicamente un
   caracter de palabra constituyente; hay otros, también.

   Alternativamente, se puede redefinir la expresión regular @e{regexp} usada
   en la definición @c{count-words} así como incluir símbolos. Este
   procedimiento tiene el mérito de la claridad, pero la tarea es un pequeño
   truco.

   La primera parte es suficientemente simple: el patrón debe asignarse “al
   menos un carácter que es una palabra o símbolo constituyente”. De este
   modo:

   @example
     "\\(\\w\\|\\s_\\)+"
   @end example

   El @'{\\(} es la primera parte del constructo que agrupa esto que incluye
   el @'{\\w} y el @'{\\s_} como alternativas, separadas por los @'{\\|}.  El
   @'{\\w} asocia cualquier caracter de palabra constituyente y el @'{\\s_}
   asocia cualquier caracter que es parte de un nombre de símbolo pero no una
   palabra de caracteres constituyente. El @'{+} sigue al grupo que indica
   que la palabra o símbolo constituyan caracteres que deben ser asociados al
   menos por uno.

   Sin embargo, la segunda parte de regexp es más difícil de diseñar. Lo que
   queremos es seguir la primera parte con “opcionalmente uno o más
   caracteres que no constituyen una palabra o símbolo”. Primero, se pensaba
   que se podría definir esto con lo siguiente:

   @example
     "\\(\\W\\|\\S_\\)*"
   @end example

   Las mayúsculas @'{W} y @'{S} asocian caracteres que @e{no} son
   constituyente de palabra o símbolo. Desafortunadamente, esta expresión
   asocia cualquier caracter que sea o no una palabra constituyente no un
   símbolo constituyente. ¡Esto asocia cualquier caracter!

   Entonces se notificó que cada palabra o símbolo en mi región test fué
   seguida por algún espacio (espacio en blanco, tabulador, o nueva
   línea). Así yo intenté emplazar un patrón para asociar uno o más espacios
   en blanco después del patrón para una o más palabras o símbolos
   constituyentes. Esto falló, también. Palabras y símbolos son con
   frecuencia separados por espacios en blanco, pero en el código actual los
   paréntesis pueden seguir símbolos y puntuación puede seguir las
   palabras. Así finalmente, se diseño un patrón en el que la palabra o
   símbolo constituyente es seguido opcionalmente por caracteres que no son
   espacios en blanco y entonces son seguidos opcionalmente por espacios en
   blanco.

   Aquí está la expresión regular completa:

   @example
     "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
   @end example

** La función @c{count-words-in-defun}

   Se ha visto que hay varios caminos para escribir una función
   @c{count-word-region}. Para escribir un @c{count-words-in-defun}, se
   necesita solamente adaptar una de estas versiones.

   La versión que usa un bucle @c{while} es fácil de comprender, así estoy
   yendo a adaptar esto. Porque @c{count-words-in-defun} será parte de un
   programa más complejo, eso no necesita ser interactivo y no necesita
   mostrar un mensaje pero solo devuelve el contaje. Estas consideraciones
   simplifican la definición un poco.

   Por otro lado, @c{count-words-in-defun} será usado con un buffer que
   contiene definiciones de función. Consiguientemente, es razonable
   preguntar que la función determina si se llamó cuando el punto está con
   una definición de función, y eso es, para devolver el contaje para esta
   definición. Esto añade complejidad a la definición, pero nos guarda desde
   la necesidad de pasar argumentos a la función.

   Estas consideraciones nos llevan a preparar la siguiente plantilla:

   @example
     (defun count-words-in-defun ()
       "@V{documentation}…"
       (@V{set up}…
          (@V{while loop}…)
        @V{return count})
   @end example

   Así, el trabajo es rellenar los slots.

   Primero, la configuración.

   Estamos presuponiendo que esta función será llamada con un búffer
   conteniendo definiciones de función. Apunta si será con una definición de
   función o no. Para que @c{count-words-in-defun} funcione, el punto debe
   moverse al principio de la definición, un contador debe empezar a cero, y
   el bucle contando debe parar cuando el punto logre el fin de la
   definición.

   La función @c{beginning-of-defun} busca atrás para un delimitador de
   apertura tal como @'{(} al principio de una línea, y mueve el punto a esta
   posición, o sino al límite de la búsqueda. En la práctica, esto significa
   que @c{beginning-of-defun} mueve el punto al principio de un cierre o
   definición de función precedente, o sino al principio del buffer.

   El bucle @c{while} requiere un contador para guardar la traza de las
   palabras o símbolos siendo contados. Una expresión @c{let} puede ser usado
   para crear una variable local para este propósito, y lo asocia a un valor
   inicial de cero.

   La función @c{end-of-defun} funciona como @c{beginning-of-defun} excepto
   que mueve el punto al fin de la definición. @c{end-of-defun} puede ser
   usado como parte de una expresión que determina la posición del fin de la
   definición.

   La configuración para @c{count-words-in-defun} toma forma rápidamente:
   primero movemos el punto al principio de la definición, entonces se crea
   una variable local para manejar el conteo, y finalmente, se graba la
   posición del fin de la definición así el bucle @c{while} conocerá cuando
   parar el bucle.

   El código se parece a esto:

   @example
     (beginning-of-defun)
     (let ((count 0)
           (end (save-excursion (end-of-defun) (point))))
   @end example

   El código es simple. La única ligera complicación es probablemente ir al
   @c{end}: eso está asociado a la posición del fin de la definición por una
   expresión @c{save-excursion} que devuelve el valor del punto después de
   @c{end-of-defun} temporalmente se mueve al fin de la definición.

   La segunda parte del @c{count-words-in-defun}, después de la
   configuración, es el bucle @c{while}.

   El bucle debe contener una expresión que mueva el punto hacia adelante
   palabra por palabra y símbolo por símbolo, y otra expresión que cuente los
   saltos. El test-verdadero-o-falso para el bucle @c{while} chequearía
   verdadero tan largo como el punto debería saltar hacia adelante, y falso
   si apunta al fin de la definición. Ya se ha redefinido la expresión
   regular para esto, así el bucle es sencillo:

   @example
     (while (and (< (point) end)
                 (re-search-forward
                  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t)
       (setq count (1+ count)))
   @end example

   La tercera parte de la definición devuelve el contaje de palabras y
   símbolos. Esta parte es la última expresión con el cuerpo de la expresión
   @c{let}, y puede ser, muy la variable local @c{count}, que cuando se
   evalúa devuelve el contaje.

   Puesto junto, la definición @c{count-words-in-defun} se ve así:

   @example
     (defun count-words-in-defun ()
       "Devuelve el número de palabras y símbolos en una defun."
       (beginning-of-defun)
       (let ((count 0)
             (end (save-excursion (end-of-defun) (point))))
         (while
             (and (< (point) end)
                  (re-search-forward
                   "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
                   end t))
           (setq count (1+ count)))
         count))
   @end example

   ¿Cómo se chequea esto? La función no es interactiva, pero es fácil poner
   un envoltorio alrededor de la función para hacerla interactiva; se puede
   usar casi el mismo código como la versión recursiva de
   @c{@v{COUNT-WORDS}}:

   @example
     ;;; @e{Versión Interactiva.}
     (defun count-words-defun ()
       "Número de palabras y símbolos en una definición
       de función."
       (interactive)
       (message
        "Contando palabras y símbolos en la definición de función ... ")
       (let ((count (count-words-in-defun)))
         (cond
          ((zerop count)
           (message
            "La definición NO tiene palabras o símbolos."))
          ((= 1 count)
           (message
            "La definición tiene 1 palabra o símbolo."))
          (t
           (message
            "La definición tiene %d palabras o símbolos." count)))))
   @end example

   Permite reutilizar @k{C-c =} como un atajo conveniente:

   @example
     (global-set-key "\C-c=" 'count-words-defun)
   @end example

   Ahora se puede intentar @c{count-words-defun}: instala ambas funciones
   @c{count-words-in-defun} y @c{count-words-defun}, y asigna el atajo, y
   entonces emplaza el cursor con la siguiente definición:

   @example
     (defun multiply-by-seven (number)
       "Multiplicar NUMBER por siete."
       (* 7 number))
          ⇒ 10
   @end example

   ¡Éxito! La definición tiene 10 palabras y símbolos.

   El siguiente problema es contar los números de palabras y símbolos en
   varias definiciones con un fichero simple.

** Contar varias @c{defuns} en un fichero

   Un fichero tal como @f{simple.el} puede tener un centenar o más
   definiciones de función dentro. Nuestro objetivo es recoger estadísticas
   en muchos ficheros, pero en un primer paso, nuestro objetivo inmediato es
   recoger estadísticas en un fichero.

   La información será una serie de números, cada número siendo el tamaño de
   una definición de función. Se pueden almacenar los números en una lista.

   Se sabe que se querrá incorporar la información considerando un fichero
   con información acerca de muchos otros ficheros; esto significa que la
   función para contar el tamaño de contaje con un fichero solo necesita
   devolver la lista de tamaños. Eso no necesita y no mostraría mensajes.

   Los comando de contar palabras contienen una expresión para saltar el
   punto hacia adelante palabra por palabra y otra expresión para contar los
   saltos. La función devuelve los tamaños de definiciones que pueden ser
   diseñadas para trabajar del mismo modo, con una expresión para saltar el
   punto hacia la definición por definición y otra expresión para construir
   el tamaño de la lista.

   Esta frase del problema hace elemental escribir la definición de
   función. Claramente, empezaremos el conteo al principio del fichero, así
   el primer comando será @c{(goto-char (point-min))}. Lo siguiente, es
   empezar el bucle @c{while}; y este true-or-false del bucle puede ser una
   búsqueda de expresión regular para la siguiente definición de función ---
   así en el momento que la búsqueda tiene éxito, el punto se mueve hacia
   adelante y entonces el cuerpo del bucle es evaluado. El cuerpo necesita
   una expresión que construye la lista de tamaños. @c{cons}, la lista de
   construcción del comando, puede ser usado para crear la lista. Esto es
   casi todo lo que hay.

   Aquí está este fragmento de código que se ve así:

   @example
     (goto-char (point-min))
     (while (re-search-forward "^(defun" nil t)
       (setq lengths-list
             (cons (count-words-in-defun) lengths-list)))
   @end example

   Dejamos fuera el mecanismo para encontrar el fichero que contiene las
   definiciones de función.

   En ejemplos previos, nosotros habíamos usado esto, el fichero Info, o
   cambiamos atrás y adelante a algún otro búffer, tal como el búffer
   @f{*scratch*}.

   Encontrar un fichero es un nuevo proceso que no tenemos todavía discutido.

** Encontrar un fichero

   Para encontrar un fichero en Emacs, se usa el comando @k{C-x C-f}
   (@c{find-file}). Este comando es casi, pero no bastante correcto para el
   problema de tamaños.

   Permita mirar el fuente para @c{find-file}:

   @example
     (defun find-file (filename)
       "Edita el fichero FILENAME.
     Cambia a un búffer visitando el fichero FILENAME,
     creando uno si no existe ya."
       (interactive "FFind file: ")
       (switch-to-buffer (find-file-noselect filename)))
   @end example

   (La versión más reciente de la definición de función @c{find-file} permite
   comodines especiales para visitar múltiples ficheros; que hacen la
   definición más compleja y no se discutirá aquí, ya que no es relevante. Se
   pueden ver sus fuentes usando @k{M-.} (@c{find-tag}) o @k{C-h f}
   (@c{describe-function}).)

   @ignore
     In Emacs 22
     (defun find-file (filename &optional wildcards)
       "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     Interactively, the default if you just type RET is the current directory,
     but the visited file name is available through the minibuffer history:
     type M-n to pull it into the minibuffer.

     Interactively, or if WILDCARDS is non-nil in a call from Lisp,
     expand wildcards (if any) and visit multiple files.  You can
     suppress wildcard expansion by setting ‘find-file-wildcards’ to nil.

     To visit a file without any kind of conversion and without
     automatically choosing a major mode, use \\[find-file-literally]."
       (interactive (find-file-read-args "Find file: " nil))
       (let ((value (find-file-noselect filename nil nil wildcards)))
         (if (listp value)
             (mapcar 'switch-to-buffer (nreverse value))
           (switch-to-buffer value))))
   @end ignore

   La definición que se está mostrando posee una documentación corta, pero
   completa y una especificación interactiva que muestra un nombre de fichero
   cuando se usa el comando interactivamente. El cuerpo de la definición
   contiene dos funciones, @c{find-file-noselect} y @c{switch-to-buffer}.

   De acuerdo a su documentación como muestra por @k{C-h f} (el comando
   @c{describe-function}), la función @c{find-file-noselect} lee el fichero
   nombrado dentro de un búffer y devuelve el búffer. (Su versión más
   reciente incluye un argumento comodín, también, así como otro para leer un
   fichero literalmente y otro que suprime mensajes de aviso. Estos
   argumentos opcionales son irrelevantes.)

   Sin embargo, la función @c{find-file-noselect} no selecciona el búffer en
   el que se pone el fichero. Emacs no cambia su atención (o la tuya si estás
   usando @c{find-file-noselect}) al búffer seleccionado. Esto es lo que
   @c{switch-to-buffer} hace: eso cambia el búffer al que se dirige la
   atención de Emacs; y eso cambia el búffer mostrado en la ventana al nuevo
   búffer. Se ha discutido el búffer cambiando a otro lugar. (Véase Sección
   @l{Cambiando búffers}.)

   En este proyecto de histograma, no se necesita mostrar cada fichero en la
   pantalla como el programa determina el tamaño de cada definición con
   eso. En vez de emplear @c{switch-to-buffer}, se puede trabajar con
   @c{set-buffer}, que redirige la atención del programa de ordenador para un
   búffer diferente pero no lo muestra en pantalla. Así en vez llamar a
   @c{find-file} para hacer el trabajo, debe escribir nuestra expresión.

   La tarea es fácil: usar @c{find-file-noselect} y @c{set-buffer}.

** @c{lengths-list-file} en detalle

   El núcleo de la función @c{lengths-list-file} es un bucle @c{while}
   conteniendo una función para mover el punto hacia delante ‘función a
   función’ y una función para contar el número de palabras y símbolos en
   cada función. Este núcleo debe ser rodeado por funciones que hacen otras
   tareas varias, incluyendo encontrar el fichero, y asegurando que el punto
   empieza al principio del fichero. La definición de la función se parece a:
   @findex lengths-list-file

   @example
     (defun lengths-list-file (filename)
       "Devuelve la lista de tamaños de definiciones con FILE.
     La lista devuelta es una lista de números.
     Cada número es el número de palabras o
     símbolos en una definición."
       (message "Trabajando en `%s' ... " filename)
       (save-excursion
         (let ((buffer (find-file-noselect filename))
               (lengths-list))
           (set-buffer buffer)
           (setq buffer-read-only t)
           (widen)
           (goto-char (point-min))
           (while (re-search-forward "^(defun" nil t)
             (setq lengths-list
                   (cons (count-words-in-defun) lengths-list)))
           (kill-buffer buffer)
           lengths-list)))
   @end example

   La función pasa un argumento, el nombre del fichero en el que se
   trabajará. Eso tiene cuatro líneas de documentación, pero sin
   especificación interactiva. Para evitar la preocupación de si se ha
   estropeado el programa o no, la primera línea del cuerpo es un mensaje de
   aviso.

   La siguiente línea contiene un @c{save-excursion} que devuelve a Emacs la
   atención al actual búffer cuando la función se completa. Esto es útil en
   caso de embeber esta función en otra función que presume que el punto
   restaura el búffer original.

   En la varlist de la expresión @c{let}, Emacs encuentra el fichero y ajusta
   la variable local @c{buffer} al búffer conteniendo el fichero. Al mismo
   tiempo, Emacs crea @c{lengths-list} como una variable local.

   Lo siguiente, Emacs cambia su atención al búffer.

   En la siguiente línea, Emacs crea el búffer de solo lectura. Idealmente,
   esta línea no es necesaria. Ninguna de las funciones para contar palabras
   y símbolos en una definición de función cambiaría el búffer. Debajo, el
   búffer no está yendo para ser guardado, incluso si eso fuese
   cambiado. Esta línea es enteramente la consecuencia grata, quizás excesiva
   precaución. La razón para la precaución es que esta función y esta se
   llama a trabajar en las fuentes para Emacs y eso es un inconveniente si
   están inadvertidamente modificadas. Eso va sin decir que no se realizó una
   necesidad para esta línea hasta que un experimento fué cambiado hacia un
   lado y empezó a modificar mis ficheros de fuentes Emacs …

   Lo siguiente llama a alargar el búffer si eso está encogido. Esta función
   es normalmente innecesaria––Emacs crea un búffer fresco si ninguno ya
   existe; pero si un búffer está visitando el fichero que ya existe que
   Emacs devuelve uno. En este caso, el búffer puede ser encogido y debe ser
   amplio. Si se quiere ser completamente ‘amigo del usuario’, se pondría en
   orden para guardar la restricción y la localización del punto, pero no.

   La expresión @c{(goto-char (point-min))} mueve el punto al principio del
   búffer.

   Entonces llega un bucle @c{while} en el que se devuelve el ‘trabajo’ de la
   función. En el bucle, Emacs determina el tamaño de cada definición y
   construye una lista de tamaños conteniendo la información.

   Emacs corta el búffer después de trabajar a través de eso. Esto es guardar
   espacio dentro de Emacs. Mi versión de GNU Emacs 19 contenía 300 ficheros
   fuente de interés; GNU Emacs 22 contiene a través de un millar de ficheros
   fuente. Otra función aplicará @c{lengths-list-file} a cada uno de los
   ficheros.

   Finalmente, la última expresión con la expresión @c{let} es la variable
   @c{lengths-list}; su valor es devuelto como el valor de la función
   completa.

   Se puede probar esta función instalándolo en el modo usual. Entonces
   posiciona tu cursor después de la siguiente expresión y escribe @k{C-x
   C-e} (@c{eval-last-sexp}).

   @example
     (lengths-list-file
      "/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el")
   @end example

   (Se puede necesitar cambiar la ruta del fichero; el único aquí es para GNU
   Emacs versión 22.1.1. Para cambiar la expresión, cópialo al búffer
   @f{*scratch*} y edítalo.

   (También, para ver el tamaño completo de la lista, en vez de una versión
   truncada se puede tener que evaluar lo siguiente:

   @example
     (custom-set-variables '(eval-expression-print-length nil))
   @end example

   (Véase Sección @l{Especificar Variables usando @c{defcustom}}. Entonces
   evalúa la expresión @c{lengths-list-file}.)

   La lista de tamaños para @f{debug.el} toma menos de un segundo para
   producirse esto en GNU Emacs 22:

   @example
     (83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
   @end example

   (Usando mi vieja máquina, la versión 19 lista tamaños para @f{debug.el}
   que en siete segundos para producen esto:

   @example
     (75 41 80 62 20 45 44 68 45 12 34 235)
   @end example

   (La versión nueva de @f{debug.el} contiene más defuns que la temprana; y
   mi nueva máquina es más rápida que la vieja.

   Nótese que el tamaño de la última definición en el fichero es el primero
   en la lista.

** Contar palabras en @c{defuns} en diferentes ficheros

   En la sección previa, se creaba una función que devuelve una lista de los
   tamaños de cada definición en un fichero. Ahora, se quiere definir una
   función para devolver una lista maestra de los tamaños de las definiciones
   en una lista de ficheros.

   Trabajar en cada elemento de una lista de ficheros es un acto repetitivo,
   así se puede usar un bucle @c{while} o recursión.

   El diseño usando un bucle @c{while} es rutina. El argumento que se pasaba
   a la función es una lista de ficheros. Como se vió pronto (Vease Sección
   @l{Ejemplo de bucle}), se puede escribir un bucle @c{while} de un modo que
   el cuerpo del bucle es evaluado si tal lista contiene elementos, pero sale
   del bucle si la lista está vacía. Para que este diseño funcione, el cuerpo
   del bucle debe contener una expresión que ordene la lista cada vez que el
   cuerpo es evaluado, de modo que finalmente la lista esté vacía. La técnica
   normal es asignar el valor de la lista para el valor del @Cc{cdr} de la
   lista cada vez que el cuerpo es evaluado.

   La plantilla se ve así:

   @example
     (while @V{test-whether-list-is-empty}
       @V{body}…
       @V{set-list-to-cdr-of-list})
   @end example

   También, recuérdanos que un bucle @c{while} devuelve @c{nil} (el resultado
   de evaluar el true-or-false-test), no el resultado de cualquier evaluación
   con su cuerpo. (Las evaluaciones con el cuerpo del bucle son hechas para
   sus efectos laterales.) Sin embargo, la expresión que asigna la lista de
   tamaños es parte del cuerpo––y que es el valor que queremos devuelto por
   la función como un todo. Para hacer esto cerramos el bucle @c{while} con
   una expresión @c{let}, y pone en orden que el último elemento de la
   expresión @c{let} contiene el valor de lista de tamaños. (Véase Sección
   @l{Ejemplo de Incremento, , El Ejemplo del Bucle con un Contador de
   Incremento}.)

   Estas consideraciones lideran directamente a la función en sí:

   @example
     ;;; @e{Usar bucle @c{while}.}
     (defun lengths-list-many-files (list-of-files)
       "Devuelve la lista de tamaños de funciones en LIST-OF-FILES."
       (let (lengths-list)

     ;;; @e{true-or-false-test}
         (while list-of-files
           (setq lengths-list
                 (append
                  lengths-list

     ;;; @e{Genera una lista de tamaños.}
                  (lengths-list-file
                   (expand-file-name (car list-of-files)))))

     ;;; @e{Crea una lista ordenada de ficheros.}
           (setq list-of-files (cdr list-of-files)))

     ;;; @e{Devuelve la lista final de valores de tamaños.}
         lengths-list))
   @end example

   @c{expand-file-name} es una función construida que convierte un nombre de
   fichero al absoluto, forma de nombre de ruta. La función emplea el nombre
   del directorio en el que la función se llama.

   De este modo, si @c{expand-file-name} es llamado en @c{debug.el} cuando
   Emacs está visitando el directorio
   @f{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/}

   @example
     debug.el
   @end example

   llega a ser

   @example
     /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
   @end example

   El único nuevo elemento de esta definición de función es la todavía no
   estudiada función @c{append}, que merece una corta sección en sí.

*** La función @c{append}

    La función @c{append} adjunta una lista a otra. De este modo,

    @example
      (append '(1 2 3 4) '(5 6 7 8))
    @end example

    produce la lista

    @example
      (1 2 3 4 5 6 7 8)
    @end example

    Esto es exactamente cómo queremos adjuntar dos listas de tamaños
    producidas por @c{lengths-list-file} a cualquier otra. Los resultados
    contrastan con @c{cons},

    @example
      (cons '(1 2 3 4) '(5 6 7 8))
    @end example

    que construye una nueva lista en el que el primer argumento para @c{cons}
    llega a ser el primer elemento de la nueva lista:

    @example
      ((1 2 3 4) 5 6 7 8)
    @end example

** Recursivamente cuenta palabras en diferentes ficheros

   Bajo un bucle @c{while}, se puede trabajar cada lista de ficheros con
   recursión. Una versión recursiva de @c{lengths-list-many-files} es corta y
   simple.

   La función recursiva tiene las partes normales: el ‘do-again-test’, la
   ‘next-step-expression’, y la llamada recursiva. El ‘do-again-test’
   determina si la función se llamaría, que hará si la @c{list-of-files}
   contiene los elementos que permanecen; la ‘next-step-expression’ resetea
   el @c{list-of-files} al @Cc{cdr} en sí, así finalmente la lista será
   vacía; y la llamada recursiva llama en sí a la lista ordenada. ¡La función
   completa está ordenada por esta descripción!

   @example
     (defun recursive-lengths-list-many-files (list-of-files)
       "Devuelve la lista de tamaños de cada defun en LIST-OF-FILES."
       (if list-of-files                     ; @e{do-again-test}
           (append
            (lengths-list-file
             (expand-file-name (car list-of-files)))
            (recursive-lengths-list-many-files
             (cdr list-of-files)))))
   @end example

   En una frase, la función devuelve de tamaños de la lista para la el
   primero de la @c{list-of-files} al resultado de llamarse así mismo al
   resto de @c{list-of-files}.

   Aquí hay un test @c{recursive-lengths-list-many-files}, a lo largo de los
   resultados de ejecutar @c{lengths-list-file} en cada uno de los ficheros
   individualmente.

   Instala @c{recursive-lengths-list-many-files} y @c{lengths-list-file}, si
   es necesario, y entonces evalúa las siguientes expresiones. Se puede
   necesitar cambiar las rutas de ficheros; aquí se trabaja cuando este
   fichero Info y las fuentes de Emacs están localizadas en sus lugares
   personales. Para cambiar las expresiones, cópialas al búffer
   @f{*scratch*}, edítalos y entonces evalúalos.

   Los resultados son mostrados después del @'{⇒}. (Estos resultados son para
   ficheros de Emacs versión 22.1.1; ficheros desde otras versiones de Emacs
   puede producir diferentes resultados.)

   @example
     (cd "/usr/local/share/emacs/22.1.1/")

     (lengths-list-file "./lisp/macros.el")
          ⇒ (283 263 480 90)

     (lengths-list-file "./lisp/mail/mailalias.el")
          ⇒ (38 32 29 95 178 180 321 218 324)

     (lengths-list-file "./lisp/makesum.el")
          ⇒ (85 181)

       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mail/mailalias.el"
          "./lisp/makesum.el"))
            ⇒ (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)
   @end example

   La función @c{recursive-lengths-list-many-files} produce la salida que
   queremos.

   El siguiente paso es preparar el dato en la lista para mostrarlo en un
   grafo.

** Preparar los datos para mostrarlos en un grafo

   La función @c{recursive-lengths-list-many-files} devuelve una lista de
   números. Cada número graba el tamaño de una definición de función. Lo que
   se necesita hacer ahora es transformar estos datos dentro de una lista de
   números ajustado para generar un grafo. La nueva lista contará cuántas
   definiciones de funciones contienen menos de 10 palabras y símbolos,
   cuantas contienen entre 10 y 19 palabras y símbolos, cuántas contienen
   entre 20 y 29 palabras y símbolos, y así.

   En breve, se necesita ir a través el tamaño de la lista producida por la
   función @c{recursive-lengths-list-many-files} y contar el número de defuns
   con cada rango de tamaños, y produce una lista de esto de números.

   Basado en lo que hemos hecho antes, se prevee que no sería difícil
   escribir una función que ‘@Cc{cdr}s’ bajo la lista de tamaños, parece que
   cada elemento, determina que rango de tamaños está dentro, e incrementa un
   contador para este rango.

   Sin embargo, antes de empezar a escribir tal función, nosotros
   consideraríamos las ventajas de ordenar los tamaños de la lista primero,
   así los números son ordenados desde el más pequeño al más largo. Primero,
   ordenando se hará fácil contar los números en cada rango, desde dos
   números adyacentes será el mismo rango del tamaño en rangos
   adyacentes. Segundo, inspeccionando una lista ordenada, se puede descubrir
   el número mayor y menor, y esto significa determinar el rango de tamaño
   mayor y menor que necesitará.

*** Ordenando listas

    Emacs contiene una función para listas ordenadas, llamadas (como se
    podría adivinar) @c{sort}. La función @c{sort} toma dos argumentos, la
    lista es ordenada, y un predicado que determina si la primera de dos
    elementos de lista es “menor” que la segunda.

    Como se vió antes (Vease Sección @"{Usando el Tipo Incorrecto de Objeto
    como un Argumento}), un predicado es una función que determina si alguna
    propiedad es verdadera o falsa. La función @c{sort} reordenará una lista
    de acuerdo a lo que la propiedad del predicado usa; esto significa que
    @c{sort} puede ser usado para ordenar listas no numéricas por un criterio
    no numérico --- eso puede, por ejemplo, alfabetizar una lista.

    La función @c{<} se usa cuando se ordena una lista numérica. Por ejemplo,

    @example
      (sort '(4 8 21 17 33 7 21 7) '<)
    @end example

    produce esto:

    @example
      (4 7 7 8 17 21 21 33)
    @end example

    (Note que en este ejemplo, ambos argumentos se citan así que los símbolos
    no se evalúan antes de ser pasados por @c{sort} como argumentos.)

    Ordenando la lista devuelta por la función
    @c{recursive-lengths-list-many-files} es honesta; eso usa la funci@'n
    @c{<}:

    @ignore
      2006 Oct 29
      In GNU Emacs 22,  eval
      (progn
        (cd "/usr/local/share/emacs/22.0.50/")
        (sort
         (recursive-lengths-list-many-files
          '("./lisp/macros.el"
            "./lisp/mail/mailalias.el"
            "./lisp/makesum.el"))
         '<))

    @end ignore

    @example
      (sort
       (recursive-lengths-list-many-files
        '("./lisp/macros.el"
          "./lisp/mailalias.el"
          "./lisp/makesum.el"))
       '<)
    @end example

    que produce:

    @example
      (29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)
    @end example

    (Note que en este ejemplo, el primer argumento para @c{sort} no está
    citado, desde que la expresión debe ser evaluado así como producir la
    lista que es pasada para @c{sort}.)

*** Creando una lista de ficheros

    La función @c{recursive-lengths-list-many-files} requiere una lista de
    fichero como argumento. Para nuestros ejemplos de test, se construyeron
    tal como una lista a mano; pero el directorio fuente de Emacs Lisp es
    demasiado grande para hacer esto. Así, se escribirá una función para
    hacer el trabajo. En esta función, se usa tanto un bucle @c{while} como
    una llamada recursiva.

    En viejas versiones de GNU Emacs no hizo falta tener que escribir esta
    función, puesto que todos los ficheros @'{.el} en un directorio. En vez
    de eso, se puede ser capaz de usar la función @c{directory-files}, que
    lista los nombres de fichero que hay en un directorio simple.

    Sin embargo, las versiones reciente Emacs emplazan ficheros de Emacs Lisp
    en subdirectorios del directorio de alto nivel @f{lisp}. Esto facilita la
    navegación. Por ejemplo, todos los ficheros de correo relacionados que
    están en el subdirectorio llamado @f{mail}. Pero al mismo tiempo, esta
    facilidad fuerza a crear un fichero listando la función que desciende
    dentro de los subdirectorios.

    Se puede crear esta función, llamada @c{files-en-below-directory}, usando
    funciones familiares tales como @c{car}, @c{nthcdr}, y @c{substring} en
    conjunción con una función existente llamada
    @c{directory-files-and-attributes}. Esta última función no solo listas de
    ficheros en un directorio, incluyendo los nombres de subdirectorios, pero
    también sus atributos.

    Para empezar nuestro objetivo: crear una función que nos permita
    alimentas ficheros a @c{recursive-lengths-list-many-files} como una lista
    que se parece a esto (pero con más elementos):

    @example
      ("./lisp/macros.el"
       "./lisp/mail/rmail.el"
       "./lisp/makesum.el")
    @end example

    La función @c{directory-files-and-attributes} devuelve una lista de
    listas. Cada una de las listas con la lista principal consiste de 13
    elementos. El primer elemento es una cadena que contiene el nombre del
    fichero––que, en GNU/Linux, puede ser un ‘directorio fichero’, que dice,
    un fichero con los atributos especiales de un directorio. El segundo
    elemento de la lista es @c{t} para un directorio, es una cadena para el
    enlace simbólico (la cadena es el nombre enlazado), o @c{nil}.

    Por ejemplo, el primer fichero @'{.el} en el directorio es
    @f{abbrev.el}. Su nombre es
    @f{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} y no es un directorio o
    un enlace simbólico.

    Esto es cómo @c{directory-files-and-attributes} lista este fichero y sus
    atributos:

    @example
      ("abbrev.el"
      nil
      1
      1000
      100
      (20615 27034 579989 697000)
      (17905 55681 0 0)
      (20615 26327 734791 805000)
      13188
      "-rw-r--r--"
      nil
      2971624
      773)
    @end example

    Por otro lado, @f{mail/} es un directorio con el directorio @f{lisp/}. El
    principio del listado se parece a esto:

    @example
      ("mail"
      t
      …
      )
    @end example

    (Para aprender acerca de los diferentes atributos, mira en la
    documentación de @c{file-attributes}. Tenga en mente que la función
    @c{file-attributes} no lista el nombre del fichero, así su primer
    elemento es @c{directory-files-and-attributes} que es el segundo
    elemento.)

    Se querrán nuestras nuevas funciones, @c{files-in-below-directory}, para
    listar los fichero @'{.el} en el directorio eso es contado para chequear,
    y en los directorios bajo este directorio.

    Esto nos da una sugestión de como construir @c{files-in-below-directory}:
    con un directorio, la función añadir los nombres de ficheros @'{.el} a
    una lista; y si, con un directorio, la función viene con un
    subdirectorio, iría dentro de este subdirectorio y repite sus acciones.

    Sin embargo, nosotros notaríamos que cada directorio contiene un nombre
    que se refiere a sí mismo, llamado @f{.}, (“dot”) y un nombre que se
    refiere a su directorio padre, llamado @f{..} (“doble punto”). (En @f{/},
    el directorio raíz, @f{..} se refiere así mismo, desde que @f{/} no tiene
    padre.) Claramente, no que se quiere nuestra función
    @c{files-in-below-directory} para introducir estos directorio, desde que
    ellos siempre nos lideran, directamente o indirectamente, al directorio
    actual.

    Consecuentemente, nuestra función @c{files-in-below-directory} debe hacer
    varias tareas:

    - Chequee para ver si se está mirando en un nombre de fichero que
      finaliza en @'{.el} y si es así, se añade el nombre a una lista.

    - Chequee para ver si está mirando en un nombre de fichero que es el
      nombre de un directorio; y si es así,

      - Chequee para ver si está mirando en @f{.} o @f{..}; y si es así sal.


      - O además, ve dentro de este directorio y repite el proceso.


    Se permite escribir una definición de función para hacer estas tareas. Se
    usará un bucle @c{while} para mover de un nombre de fichero a otro con un
    directorio chequeando lo que necesita ser hecho; y se usa una llamada
    recursiva para repetir las acciones en cada subdirectorio. El patrón
    recursivo es ‘acumular’ (Vease Sección @l{Patrón recursivo:
    @e{accumulate}}) usando @c{append} para combinar.

    @ignore
      (directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
      (shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

      (directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
      (shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
    @end ignore

    Aquí está la función:

    @example
      (defun files-in-below-directory (directory)
        "Lista los ficheros .el en DIRECTORIO y en sus subdirectorios."
        ;; Aunque la función será usada no interactivamente,
        ;; será fácil chequear si lo hacemos interactivo.
        ;; El directorio tendrá un nombre tal como
        ;;  "/usr/local/share/emacs/22.1.1/lisp/"
        (interactive "DNombre del Directorio: ")
        (let (el-files-list
              (current-directory-list
               (directory-files-and-attributes directory t)))
          ;; mientras estamos en el directorio actual
          (while current-directory-list
            (cond
             ;; chequee para ver si el nombre del fichero finaliza en ‘.el’
             ;; y si es así, añade su nombre a una lista.
             ((equal ".el" (substring (car (car current-directory-list)) -3))
              (setq el-files-list
                    (cons (car (car current-directory-list)) el-files-list)))
             ;; chequee si el nombre del fichero es un directorio
             ((eq t (car (cdr (car current-directory-list))))
              ;; decide si salir o hacer recursión
              (if
                  (equal "."
                         (substring (car (car current-directory-list)) -1))
                  ;; entonces no hagas nada puesto que el nombre del fichero es
                  ;; el actual directorio o padre, "." o ".."
                  ()
                ;; else desciende dentro del directorio y repite el proceso
                (setq el-files-list
                      (append
                       (files-in-below-directory
                        (car (car current-directory-list)))
                       el-files-list)))))
            ;; mueve al siguiente fichero en la lista; esto también
            ;; ordena la lista así mientras el bucle
            ;; eventualmente llega a un fin
            (setq current-directory-list (cdr current-directory-list)))
          ;; devuelve los ficheros
          el-files-list))
    @end example

    Las funciones @c{files-in-below-directory} @c{directory-files} toma un
    argumento, el nombre de un directorio.

    De este modo, en mi sistema,

    @example
      (length
       (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
    @end example

    se cuenta que dentro y debajo de mi directorio de fuentes Lisp hay 1031
    ficheros @'{.el}

    @c{files-in-below-directory} devuelve una lista en orden alfabético
    inverso. Una expresión para ordenar la lista en orden que parece como
    este:

    @example
      (sort
       (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
       'string-lessp)
    @end example

    @ignore
      (defun test ()
        "Test how long it takes to find lengths of all sorted elisp defuns."
        (insert "\n" (current-time-string) "\n")
        (sit-for 0)
        (sort
         (recursive-lengths-list-many-files
          (files-in-below-directory "/usr/local/src/emacs/lisp/"))
         '<)
        (insert (format "%s" (current-time-string))))
    @end ignore

*** Contando definiciones de función

    Nuestro objetivo inmediato es generar una lista que cuenta, cuantas
    definiciones de funciones contienen menos de 10 palabras y símbolos,
    cuantas contienen entre 10 y 19 palabras y símbolos, cuantas contienen
    entre 20 y 29 palabras y símbolos, y así.

    Con una lista ordenada de números, es fácil: se cuentan cuantos elementos
    de la lista son más pequeños de 10, entonces, se devuelven los números
    contados, se cuenta cuantos son más pequeños de 20, entonces se devuelven
    los números contados, después se cuentan los que son más pequeños de 30,
    y así. Cada uno de los números, 10, 20, 30, 40, y como, es más grande que
    el tope de este rango. Se puede llamar a la lista de tales números, la
    lista @c{top-of-ranges}.

    Si se desea, se podría generar esta lista automáticamente, pero es más
    simple escribir una lista manualmente. Aquí está: @vindex top-of-ranges

    @example
      (defvar top-of-ranges
       '(10  20  30  40  50
         60  70  80  90 100
        110 120 130 140 150
        160 170 180 190 200
        210 220 230 240 250
        260 270 280 290 300)
       "Listar especificando rangos para ‘defuns-per-range’.")
    @end example

    Para cambiar los rangos, se edita esta lista.

    Lo siguiente, que se necesita es escribir la función que crea la lista
    del número de definiciones con cada rango. Claramente, esta función debe
    tomar el @c{sorted-lengths} y las listas @c{top-of-ranges} listas como
    argumentos.

    La función @c{defuns-per-range} debe hacer dos cosas una y otra vez: eso
    debe contar el número de definiciones con un rango específico por el
    actual valor top-of-range; y eso debe dividir al siguiente gran valor en
    la lista @c{top-of-ranges} después de contar el número de definiciones en
    el rango actual. Desde que cada una de estas acciones es repetitiva, se
    puede usar los bucles @c{while} para el trabajo. Un bucle cuenta el
    número de definiciones en el rango definido por el valor actual
    top-of-range, y el otro bucle selecciona cada uno de los valores
    top-of-range en turno.

    Varias entradas de la lista @c{sorted-lengths} se cuentan para cada
    rango; esto significa que el bucle para la lista @c{sorted-lengths} será
    dentro del bucle para la lista @c{top-of-ranges}, como un pequeño adorno
    dentro de un gran adorno.

    El bucle interno cuenta el número de definiciones con el rango. Eso es un
    simple contaje del tipo en el que se ha visto antes. (Véase Sección @l{Un
    bucle con un contaje incremental}). El test true-or-false del bucle
    chequea si el valor desde la lista @c{sorted-lengths} es más pequeña que
    el actual valor de lo alto del rango. Si es así, la función incrementa el
    contador y se chequea el siguiente valor desde la lista
    @c{sorted-lengths}.

    El bucle interno se parece a esto:

    @example
      (while @V{length-element-smaller-than-top-of-range}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
    @end example

    El bucle de fuera debe empezar con el valor más bajo de la lista
    @c{top-of-ranges}, y entonces se asigna a cada uno de los valores
    superiores exitosos a su vez. Esto puede ser hecho con un bucle como
    este:

    @example
      (while top-of-ranges
        @V{body-of-loop}…
        (setq top-of-ranges (cdr top-of-ranges)))
    @end example

    Se ponen juntos, los dos bucles como este:

    @example
      (while top-of-ranges

        ;; @e{Contar el número de elementos con el actual rango.}
        (while @V{length-element-smaller-than-top-of-range}
          (setq number-within-range (1+ number-within-range))
          (setq sorted-lengths (cdr sorted-lengths)))

        ;; @e{Mover al siguiente rango.}
        (setq top-of-ranges (cdr top-of-ranges)))
    @end example

    Además, en cada circuito del bucle exterior, Emacs grabaría el número de
    definiciones con este rango (el valor de @c{number-within-range}) en una
    lista. Se puede usar @c{cons} para este propósito. (Véase Sección
    @l{@c{cons}}.)

    La función @c{cons} trabaja bien, excepto que la lista que se construye
    contendrá el número de definiciones para el alto rango y su principio el
    número de definiciones para el más bajo rango a su fin. Esto es porque
    @c{cons} adjunta nuevos elementos de la lista al principio de la lista, y
    desde los dos bucles que hacen cálculos a través de la lista de tamaños
    desde lo bajo finaliza primero, el @c{defuns-per-range-list} finalizará
    el primer número más largo. Pero lo que se quiere es imprimir nuestro
    grafo con pequeños valores primero y el más grande después. La solución
    es invertir el orden del @c{defuns-per-range-list}. Nosotros podemos
    hacer esto usando la función @c{nreverse}, que invierte el orden de una
    lista.  @findex nreverse

    Por ejemplo,

    @example
      (nreverse '(1 2 3 4))
    @end example

    produce:

    @example
      (4 3 2 1)
    @end example

    Note que la función @c{nreverse} es “destructiva”––que es, cambiar la
    lista a la que se aplica; esto contrasta con las funciones @c{car} y
    @c{cdr}, que no son destructivas. En este caso, no se quiere que el
    original @c{defuns-per-range-list}, de manera que no hay materia que se
    destruya. (La función @c{reverse} provee un copia inversa de una lista,
    dejando la lista original como es.)  @findex reverse

    Pon todo junto, el @c{defuns-per-range} se parece a esto:

    @example
      (defun defuns-per-range (sorted-lengths top-of-ranges)
        "funciones de SORTED-LENGTHS en cada rango TOP-OF-RANGES."
        (let ((top-of-range (car top-of-ranges))
              (number-within-range 0)
              defuns-per-range-list)

          ;; @e{Bucle Exterior.}
          (while top-of-ranges

            ;; @e{Bucle Interno.}
            (while (and
                    ;; @e{Necesita el número para el test numérico.}
                    (car sorted-lengths)
                    (< (car sorted-lengths) top-of-range))

              ;; @e{Contar número de definiciones con el rango actual.}
              (setq number-within-range (1+ number-within-range))
              (setq sorted-lengths (cdr sorted-lengths)))

            ;; @e{Sal del bucle interno pero permanece con el bucle externo.}

            (setq defuns-per-range-list
                  (cons number-within-range defuns-per-range-list))
            (setq number-within-range 0)      ; @e{Resetear el contaje a cero.}

            ;; @e{Mover al siguiente rango.}
            (setq top-of-ranges (cdr top-of-ranges))
            ;; @e{Especifica el siguiente mejor rango de valores.}
            (setq top-of-range (car top-of-ranges)))

          ;; @e{Salir del bucle externo y contar el número de defuns más
          ;; largas que}
          ;; @e{el valor más largo del valor top-of-range.}
          (setq defuns-per-range-list
                (cons
                 (length sorted-lengths)
                 defuns-per-range-list))

          ;; @e{Devuelve una lista del número de definiciones con cada rango,}
          ;; @e{ del más pequeño al más largo.}
          (nreverse defuns-per-range-list)))
    @end example

    La función es simple excepto para una pequeña funcionalidad. El test
    verdadero-o-falso para el bucle interno se parece a esto:

    @example
      (and (car sorted-lengths)
           (< (car sorted-lengths) top-of-range))
    @end example

    en vez de algo como esto:

    @example
      (< (car sorted-lengths) top-of-range)
    @end example

    El propósito del test es determinar si el primer ítem en la lista
    @c{sorted-lengths} es menor que el valor de lo mejor del rango.

    La versión simple del test trabaja bien a menos que la lista
    @c{sorted-lengths} tiene un valor @c{nil}. En este caso, la expresión
    @c{(car sorted-lengths)} devuelve @c{nil}. La función @c{<} no se puede
    compara un número a @c{nil}, que es una lista vacía, así Emacs señala un
    error y para la función desde el intento de continuar la ejecución.

    La lista @c{sorted-lengths} siempre llega a ser @c{nil} cuando el
    contador logra el fin de la lista. Esto significa que cualquier intento
    de usar la función @c{defuns-per-range} con la versión simple del test
    fallará.

    Se resuelve el problema usando @c{(car sorted-lengths)} en conjunción con
    la expresión @c{and}. La expresión @c{(car sorted-lengths)} devuelve un
    valor no @c{nil} tan largo como la lista que tiene al menos un número con
    eso, pero devuelve @c{nil} si la lista está vacía. La expresión @c{and}
    primero evalúa el @c{(car sorted-lengths)}, y si eso es @c{nil}, devuelve
    falso @e{sin} evaluar la expresión @c{<} y devuelve este valor como el
    valor de la expresión @c{and}.

    Este camino, evita un error.  (Para información acerca de @c{and}, ver
    @l{La función @c{kill-new}}

    Aquí hay un pequeño test de la función @c{defuns-per-range}. Primero,
    evalúa la expresión que ajusta (una resumida) lista @c{top-of-ranges} a
    la lista de valores, entonces evalúa la expresión para ajustar la lista
    @c{sorted-lengths}, y entonces evalúa la función @c{defuns-per-range}.

    @example
      ;; @e{(La lista ordenada que usará después.)}
      (setq top-of-ranges
       '(110 120 130 140 150
         160 170 180 190 200))

      (setq sorted-lengths
            '(85 86 110 116 122 129 154 176 179 200 265 300 300))

      (defuns-per-range sorted-lengths top-of-ranges)
    @end example

    La lista devuelta se parece a esto:

    @example
      (2 2 2 0 0 1 0 2 0 0 4)
    @end example

    Dentro, hay dos elementos de la lista @c{sorted-lengths} menores de 110,
    dos elementos entre 110 y 119, dos elementos entre 120 y 129 y así. Hay
    cuatro elementos con un valor de 200 o superior.

* Leyendo un grafo

  Nuestro objetivo es construir un grafo mostrando los números de
  definiciones de función de varios tamaños en las fuentes de Emacs lisp.

  Como una materia práctica, si se estuviese creando un grafo, probablemente
  usarías un programa tal como @c{gnuplot} para hacer el
  trabajo. (@c{gnuplot} está bien integrado dentro de GNU Emacs.) En este
  caso, sin embargo, creamos uno desde cero, y en el proceso lo reconstruimos
  nosotros mismos con algo de lo que se aprende antes y así poder aprender
  más.

  En este capítulo, primero se escribe un grafo simple imprimiendo la
  función. Esta primera definición será un @:{prototipo}, una función escrita
  rápidamente nos permite reconocer este territorio de crear un grafo. Se
  descubren dragones, o resulta que son mitos. Después de olisquear el
  terreno, nos sentiremos más confidentes y mejoraremos la función para
  etiquetar las coordenadas automáticamente.

  Puesto que Emacs está diseñado para ser flexible y trabajar con todo tipo
  de terminales, incluyendo los terminales de caracteres, el grafo necesitará
  ser hecho desde símbolos de ‘escritura’. Un asterisco hará; como nosotros
  mejoramos la función de impresión del grafo, se puede crear la elección del
  símbolo como una opción de usuario.

  Se puede llamar a esta función @c{graph-body-print}; se tomará un
  @c{numbers-list} como su único argumento. En esta fase, no se etiquetará el
  grafo, pero se imprime su cuerpo.

  La función @c{graph-body-print} inserta una columna vertical de asteriscos
  para cada elemento en la lista @c{numbers-list}. La altura de cada línea
  está determinada por el valor de este elemento de la @c{numbers-list}.

  Insertar columnas es un acto repetitivo; que significa que esta función
  debe ser escrita con un bucle @c{while} o recursivamente.

  Nuestro primer reto es descubrir como imprimir una columna de
  asteriscos. Normalmente, en Emacs, se imprimen caracteres dentro de una
  pantalla horizontalmente, línea a línea, escribiendo. Se tienen dos rutas
  que se pueden seguir: escribir nuestra función column-insertion o descubrir
  si una que exista en Emacs.

  Para ver si hay uno en Emacs, se puede usar el comando @k{M-x
  apropos}. Este comando es como el comando @k{C-h a} (@c{command-apropos}),
  excepto que último encuentra solo estas funciones que son comandos. El
  comando @k{M-x apropos} lista todos los símbolos que se asocian a una
  expresión regular, incluyendo funciones que no son interactivas.  @findex
  apropos

  Lo que se quiere buscar es algún comando que imprima o inserte
  columnas. Muy probablemente, el nombre de la función contendrá la palabra
  ‘print’ o la palabra ‘insert’ o la palabra ‘column’. Por esta razón,
  podemos simplemente escribir @k{M-x apropos RET print \|insert\|column RET}
  y se ve el resultado. En mi sistema, este comando toma todavía algún
  tiempo, y entonces se produce una lista de 79 funciones y variables. Ahora
  no se tarda mucho y se produce una lista de 211 funciones y
  variables. Escaneando la lista, la única función que se ve como si se
  pudiera hacer el trabajo que es @c{insert-rectangle}.

  En realidad, esta es la función que queremos; su documentación dice:

  @example
    insert-rectangle:
    Insertar texto de RECTANGLE con la esquina izquierda a punto
    La primera línea de RECTANGLE es insertada al punto
    su segunda línea es insertada a un punto verticalmente
    bajo el punto, etc.
    El RECTANGLE debería ser una lista de cadenas.
    Después de este comando, la marca está en la esquina izquierda
    superior y el punto en la esquina derecha inferior.
  @end example

  Se puede ejecutar un test rápido, para asegurar que hace lo que se espera
  de eso.

  Aquí está el resultado de emplazar el cursor después de la expresión
  @c{insert-rectangle} y escribiendo @k{C-u C-x C-e} (@c{eval-last-sexp}). La
  función inserta las cadenas @'{"primero"}, @'{"segundo"}, y @'{"tercero"}
  en el punto. También la función devuelve @c{nil}.

  @example
    (insert-rectangle '("primero" "segundo" "tercer"))primero
                                                  segundo
                                                  terceronil
  @end example

  De acuerdo, no se inserta el texto de la expresión @c{insert-rectangle} en
  sí dentro del búffer en el que se marca el grafo, pero se llamará la
  función de nuestro programa. Nosotros, sin embargo, tenemos que asegurar
  que el punto está en el búffer en el lugar donde la función
  @c{insert-rectangle} insertará la columna de cadenas.

  Si se está leyendo esto en Info, se puede ver como este trabajo cambia a
  otro búffer, tal como el búffer @f{*scratch*}, emplazando el punto a algún
  lugar en el búffer, se escribe @k{M::}, después se escribe la expresión
  @c{insert-rectangle} dentro del minibúffer en la consola, y entonces se
  escribe @k{RET}. Esto causa que Emacs evalúe la expresión en el minibúffer,
  pero usa como el valor del punto la posición del punto en el búffer
  @f{*scratch*}. (@k{M::} es el atajo para @c{eval-expression}. @c{nil}
  tampoco aparece en el búffer @f{*scratch*} desde que la expresión se evalúa
  en el minibúffer.)

  Se encuentra cuando hacer esto hasta el punto que finaliza al fin de la
  última línea insertada––es decir, esta función mueve el punto como un
  efecto secundario. Si se iba a repetir el comando, con el punto en esta
  posición, la siguiente inserción sería debajo y a la derecha de la
  inserción previa. ¡Nosotros no queremos esto!. Si se está yendo a crear un
  gráfico de barras, las columnas necesitan estar debajo unas de otras.

  Así se descubre que cada ciclo del bucle @c{while} de column-inserting debe
  reposicionar el punto al lugar que queremos, y este lugar estará arriba, no
  abajo, de la columna. Más allá, se recuerda que cuando se imprime un grafo,
  no esperan todas las columnas para estar a la misma altura. Esto significa
  que el alto de cada columna puede estar a una altura diferente desde una
  previa. Nosotros simplemente reposicionamos el punto a la misma línea cada
  vez, pero movido cubriendo a la derecha––o quizás se puede …

  Estamos planeando crear las columnas de la barra gráfica sin asteriscos. El
  número de asteriscos en la columna es el número específico por el elemento
  actual del @c{numbers-list}. Necesitamos construir una lista de asteriscos
  del tamaño derecho para cada llamada a @c{insert-rectangle}. Si esta lista
  consiste únicamente del número requerido de asteriscos, entonces tendremos
  la posición de punto el número correcto de líneas bajo la base del gráfico
  para imprimirse correctamente. Esto podría ser difícil.

  Alternativamente, si podemos figurarnos algún camino para pasar
  @c{insert-rectangle} del mismo tamaño cada vez, entonces podemos posicionar
  el punto en la misma línea cada vez, pero se mueve a través de una columna
  a la derecha por cada nueva columna. Si hacemos esto, sin embargo, alguna
  de las entradas en la lista pasaba a @c{insert-rectangle} y deben ser
  espacios en blanco en vez de asteriscos. Por ejemplo, si la altura máxima
  del grafo es 5, pero la altura de la columna es 3, entonces
  @c{insert-rectangle} requiere un argumento que se parezca a esto:

  @example
    (" " " " "*" "*" "*")
  @end example

  Esta última propuesta no es tan difícil, de hecho se puede determinar la
  altura de la columna. Hay dos caminos para nosotros especificar la altura
  de la columna: se puede arbitrariamente situar lo que será, lo que
  funcionaría bien para gráficas de esta altura; o podemos buscar a través de
  la lista de números y usar la altura máxima de la lista como la altura
  máxima del grafo. Si la última operación fuera difícil, entonces el
  procedimiento formal sería fácil, pero hay una función construida en Emacs
  para determinar el máximo de sus argumentos. Se puede usar esta función. La
  función se llamaba @c{max} y eso devuelve el mayor de sus argumentos, que
  deben ser números. De este modo, por ejemplo,

  @example
    (max  3 4 6 5 7 3)
  @end example

  devuelve 7. (Una función correspondiente llamada @c{min} devuelve lo más
  pequeño de todos sus argumentos.)  @findex max @findex min

  Sin embargo, no podemos simplemente llama a @c{max} en el @c{numbers-list};
  la función @c{max} espera números como sus argumentos, no una lista de
  números. De este modo, la siguiente expresión,

  @example
    (max  '(3 4 6 5 7 3))
  @end example

  produce el siguiente mensaje error;

  @example
    Mal tipo de argumento: number-or-marker-p, (3 4 6 5 7 3)
  @end example

  Se necesita una función que pasa una lista de argumentos a una
  función. Esta función es @c{apply}. Esta función ‘aplica’ su primer
  argumento (una función) para los argumentos que permanecen, el último puede
  ser una lista.

  Por ejemplo,

  @example
    (apply 'max 3 4 7 3 '(4 8 5))
  @end example

  devuelve 8

  (Incidentalmente, yo no sabría cómo aprender acerca de esta función sin un
  libro tal como este. Eso es posible descubrir otras funciones, como
  @c{search-forward} o @c{insert-rectangle}, adivinando una parte de sus
  nombres y entonces usando @c{apropos}. Incluso aunque su base metafórica es
  clara––‘apply’ su primer argumento al resto––dudo que un novicio vendría
  con esta palabra particular usando @c{apropos} u otra ayuda. De acuerdo,
  podría ser incorrecto; después de todo, la función fué primero llamada por
  alguien quien lo había inventado.

  El segundo y subsiguientes argumentos para @c{apply} son opcionales, así se
  puede usar @c{apply} para llamar a una función y pasan los elementos de una
  lista, como este, que también devuelve 8:

  @example
    (apply 'max '(4 8 5))
  @end example

  Este camino tardío usará @c{apply}. La función
  @c{recursive-lengths-list-many-files} devuelve una lista de números que se
  puede aplicar a @c{max} (se podría también aplicar @e{(hacer apply)} a la
  lista de números ordenados; eso no importa si la lista está o no).

  Aquí, la operación para encontrar el tamaño máximo del grafo es este:

  @example
    (setq max-graph-height (apply 'max numbers-list))
  @end example

  Ahora se puede devolver la pregunta de como crear una lista de cadenas para
  una columna del grafo. Cuenta la máxima altura del grafo y el número de
  asteriscos que aparecerían en la columna, la función devolverá una lista de
  cadenas para el comando a insertar @c{insert-rectangle}.

  Cada columna se realiza con asteriscos o espacios en blanco. Puesto que la
  función pasa el valor del alto de la columna y el número de asteriscos en
  el columna, el número de espacios en blanco puede ser encontrado
  sustrayendo el número de asteriscos desde lo alto de la columna. Dado el
  número de espacios en blanco y el número de asteriscos, dos bucles
  @c{while} puede ser usado para construir la lista:

  @example
    ;;; @e{Primera versión.}
    (defun column-of-graph (max-graph-height actual-height)
      "Devuelve la lista de cadenas que una columna de un grafo."
      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))

        ;; @e{Llenar asteriscos.}
        (while (> actual-height 0)
          (setq insert-list (cons "*" insert-list))
          (setq actual-height (1- actual-height)))

        ;; @e{Rellena espacios en blanco.}
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons " " insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))

        ;; @e{Devuelve la lista completa.}
        insert-list))
  @end example

  Si se instala esta función y entonces evalúa la siguiente expresión se verá
  que devuelve la lista como se desea:

  @example
    (column-of-graph 5 3)
  @end example

  devuelve

  @example
    (" " " " "*" "*" "*")
  @end example

  Como está escrito, @c{column-of-graph} contiene una grieta mayor: los
  símbolos usados para el espacio en blanco para las entradas marcadas en la
  columna son ‘codificadas duras’ como un espacio y un asterisco. Esto está
  bien para un prototipo, pero tu, u otro usuario, puede desear usar otros
  símbolos. Por ejemplo, chequeando la función grafo, tu quieres usar un
  periodo en vez del espacio, asegura el punto que está siendo reposicionando
  apropiadamente cada vez que la función @c{insert-rectangle} se llama; o se
  podría querer sustituir un signo @'{+} u otro símbolo para el asterisco. Se
  podría incluso querer hacer un graph-column que es más que un ancho de
  columna. El programa debería ser más flexible. El camino para hacer esto es
  reemplazar el espacio en blanco y el asterisco con dos variables que se
  puede llamar @c{graph-blank} y @c{graph-symbol} y define estas variables
  separadamente.

  También la documentación no está escrita. Estas consideraciones nos llevan
  también a la segunda versión de la función:

  @example
    (defvar graph-symbol "*"
      "Cadena usada como símbolo en grafo, normalmente un asterisco.")

    (defvar graph-blank " "
      "La cadena como un espacio en blanco en grafo, normalmente un
      espacio en blanco.
    graph-blank debe ser el mismo número de columnas amplio como graph-symbol.")
  @end example

  (Para una explicación de @c{defvar}, ver @l{Inicializando una Variable con
  @c{defvar}}.)

  @example
    ;;; @e{Segunda versión.}
    (defun column-of-graph (max-graph-height actual-height)
      "Devuelve cadenas MAX-GRAPH-HEIGHT; ACTUAL-HEIGHT son
      símbolos de grafos.

    Los graph-symbols son entradas contiguo al fin de la lista.
    La lista será insertado como una columna de un grafo.
    Las cadenas son tanto graph-blank o graph-symbol.

      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))

        ;; @e{Rellenar en @c{graph-symbols}.}
        (while (> actual-height 0)
          (setq insert-list (cons graph-symbol insert-list))
          (setq actual-height (1- actual-height)))

        ;; @e{Rellenar en @c{graph-blanks}.}
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons graph-blank insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))

        ;; @e{Devuelve la lista completa.}
        insert-list))
  @end example

  Si se desea, podríamos reescribir @c{column-of-graph} una tercera vez para
  proporcionar opcionalmente un gráfico de líneas, como gráfico de
  barras. Esto no sería duro de hacer. Un camino para pensar en un grafo de
  líneas es que no es más que un grafo de barras en el que la parte de cada
  barra que está debajo del alto es blanco. Para construir una columna para
  gráfico de líneas, la función primero construyen una lista de espacios en
  blanco que es una más ordenada que el valor, entonces usa @c{cons} para
  adjuntar un símbolo gráfico a la lista; entonces eso usa @c{cons} de nuevo
  para adjuntar el ‘alto de espacios en blanco’ a la lista.

  Es fácil ver como escribir tal función, pero puesto que no se necesita eso,
  no se hará. Pero el trabajo podría ser hecho, y si eso se hiciera, se haría
  con @c{column-of-graph}. Incluso más importante, no se valora nada más que
  pocos cambios que tendrían que ser hechos de cualquier otra manera. La
  mejora, que se desea hacer, es simple.

  Ahora, finalmente, volvemos a nuestra primera función de grafo
  impresa. Esto imprime el cuerpo de un grafo, no las etiquetas para los ejes
  horizontal y vertical, así se puede llamar este @c{graph-body-print}.

** La función @c{graph-body-print}

   Después de nuestra preparación en la sección precedente, la función
   @c{graph-body-print} es simple. La función imprimirá la columna después de
   la columna de asteriscos y espacios en blanco, usando los elementos de la
   lista de números para especificar el número de asteriscos en cada
   columna. Esto es un acto repetitivo, que significa que se puede usar un
   bucle @c{while} que decrementa o una función recursiva para el trabajo. En
   esta sección, se escribirá la definición usando un bucle @c{while}.

   La función @c{column-of-graph} requiere el alto del grafo como un
   argumento, así se asigna y guarda esto como una variable local.

   Esto lidera a la siguiente plantilla para el bucle @c{while} versión de
   esta función:

   @example
     (defun graph-body-print (numbers-list)
       "@V{documentation}…"
       (let ((height  …
              …))

         (while numbers-list
           @V{insert-columns-and-reposition-point}
           (setq numbers-list (cdr numbers-list)))))
   @end example

   Necesitamos rellenar los slots de la plantilla.

   Claramente, se puede usar la expresión @c{(apply 'max numbers-list)} para
   determinar el alto del grafo.

   El bucle @c{while} iterará a través de @c{numbers-list} un elemento a la
   vez. Como eso está ordenado por la expresión @c{(setq numbers-list (cdr
   numbers-list))}, el @Cc{car} de cada instancia de la lista es el valor del
   argumento para @c{column-of-graph}.

   En cada ciclo del bucle @c{while}, la función @c{insert-rectangle} inserta
   la lista devuelta por @c{column-of-graph}. Desde que la función
   @c{insert-rectangle}, se necesita guardar la localización de punto al
   tiempo que el rectángulo se inserta, mueve atrás a esta posición después
   de que el rectángulo es insertado, y entonces se mueve horizontalmente al
   siguiente lugar desde el que @c{insert-rectangle} se llama.

   Si las columnas se insertan en un carácter amplio, será si los espacios en
   blanco y asteriscos se usan, el comando de reposición es simple
   @c{(forward-char 1)}; sin embargo, el ancho de una columna puede ser más
   grande que uno. Esto significa que el comando de reposicionamiento sería
   escrito @c{(forward-char symbol-width)}. El mejor lugar para asociar la
   variable @c{symbol-width} al valor del width de la columna grafo está en
   la varlist de la expresión @c{let}.

   Estas consideraciones lideran a la siguiente definición de función:

   @example
     (defun graph-body-print (numbers-list)
       "Imprime un gráfico de barras de la NUMBERS-LIST.
     La numbers-list consiste en los valores del eje Y."

       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)

         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; @e{Dibuja la columna del grafo por columna.}
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; @e{Emplaza el punto para etiquetas de ejes X.}
         (forward-line height)
         (insert "\n")
     ))
   @end example

   La expresión inesperada en esta función es la expresión @c{(sit-for 0)} en
   el bucle @c{while}. Esta expresión hace que el grafo imprima la operación
   más interesante para vigilar lo que sería de otro modo. La expresión causa
   que Emacs pare (sit-for 0) para un momento cero y entonces redibuje la
   pantalla. Puesto aquí, eso causa que Emacs redibuje la pantalla columna
   por columna. Sin eso, Emacs no redibujaría la pantalla hasta que la
   función exista.

   Se puede chequear @c{graph-body-print} con una pequeña lista de números.

   1. Instala @c{graph-symbol}, @c{graph-blank}, @c{column-of-graph}, que
      están en @l{Leyendo un grafo}, and @c{graph-body-print}.

   2. Copia la siguiente expresión:

      @example
        (graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
      @end example

   3. Cambia al búffer @f{*scratch*} y emplaza el cursor donde quiere que el
      grafo empiece.

   4. Escribe @k{M::} (@c{eval-expression}).

   5. Pega la expresión @c{graph-body-print} dentro del minibúffer con
      @k{C-y} (@c{yank}).


   6. Presiona @k{RET} para evaluar la expresión @c{graph-body-print} @end
      enumerate


   Emacs imprimirá un grafo como este:

   @example
             *
         *   **
         *  ****
        *** ****
       ********* *
      ************
     *************
   @end example

** La función @c{recursive-graph-body-print}

   La función @c{graph-body-print} puede también ser escrito
   recursivamente. La solución recursiva es dividida dentro de dos partes:
   una fuera ‘wrapper’ @e{envoltorio} que usa una expresión @c{let} para
   determinar los valores varias variables que solo necesitan ser encontradas
   una vez, tal como la máxima altura del grafo, y una función dentro que es
   llamada recursivamente para imprimir el grafo.

   El ‘envoltorio’ no es complicado:

   @example
     (defun recursive-graph-body-print (numbers-list)
       "Imprime un gráfico de barras del NUMBERS-LIST.
     El numbers-list consiste en los valores del eje Y."
       (let ((height (apply 'max numbers-list))
             (symbol-width (length graph-blank))
             from-position)
         (recursive-graph-body-print-internal
          numbers-list
          height
          symbol-width)))
   @end example

   La función recursiva es un poco más difícil. Eso tiene cuatro partes: el
   ‘do-again-test’, el código impreso, la llamada recursiva, y la
   ‘next-step-expression’. El ‘do-again-test’ es una expresión @c{when}
   determina si la @c{numbers-list} contiene cualquier elemento que
   permanece; si hace eso, la función imprime una columna del grafo usando el
   código impreso y se llama así mismo de nuevo. La función se llama así
   misma de nuevo de acuerdo al valor producido por la ‘next-step-expression’
   que causa para llamar a actuar en una versión ordenada de la
   @c{numbers-list}.

   @example
     (defun recursive-graph-body-print-internal
       (numbers-list height symbol-width)
       "Imprime un gráfico de barras.
     Usado con la función recursive-graph-body-print."

       (when numbers-list
             (setq from-position (point))
             (insert-rectangle
              (column-of-graph height (car numbers-list)))
             (goto-char from-position)
             (forward-char symbol-width)
             (sit-for 0)     ; @e{Dibuja un gráfico columna por columna.}
             (recursive-graph-body-print-internal
              (cdr numbers-list) height symbol-width)))
   @end example

   Después de la siguiente instalación, esta expresión puede ser chequeada;
   aquí hay un ejemplo:

   @example
     (recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
   @end example

   Aquí está lo que @c{recursive-graph-body-print} produce:

   @example
         *
        **   *
       ****  *
       **** ***
     * *********
     ************
     *************
   @end example

   Cada una de estas dos funciones, @c{graph-body-print} o
   @c{recursive-graph-body-print}, crea el cuerpo de un grafo.

** Necesidad para ejes impresos

   Un grafo necesita ejes impresos, así se puede orientar a tí mismo. Para un
   proyecto do-once, eso puede ser razonable dibujar los ejes a mano usando
   el modo de emacs Picture, pero un grafo dibuja la función que puede ser
   usada más de una vez.

   Por esta razón, se han escrito mejoras a la función básica
   @c{print-graph-body} que automáticamente imprime etiquetas para los ejes
   horizontal y vertical. Puesto que la etiqueta de imprimir funciones no
   contiene mucho material nuevo, se ha emplazado su descripción en un
   apéndice Véase Sección @l{Un Grafo con Ejes Etiquetados}.

** Ejercicio

   Escribe una versión de línea de grafo de la funciones de impresión del
   grafo.

* Tu fichero @f{.emacs}

  “No te tiene que gustar Emacs para lo que te gusta”––esto que parece una
  frase paradójica es el secreto de GNU Emacs. En realidad, Emacs es una
  herramienta genérica. La mayoría de la gente que usa Emacs, lo personaliza
  para ajustarlo a sus necesidades.

  GNU Emacs está mayoritariamente escrito en Emacs Lisp; esto significa que
  escribiendo expresiones en Emacs Lisp se puede modificar o extender Emacs.

  Hay quien aprecia la configuración por defecto de Emacs. Después de todo,
  Emacs empieza en modo C cuando se edita un fichero C, empieza en modo
  Fortran cuando se edita un fichero Fortran, y empieza en modo Fundamental
  cuando se edita un fichero no adornado. Esto tiene sentido, si no sabes
  quien está yendo a usar Emacs. ¿Quién sabe lo que una persona espera hacer
  con un fichero no adornado? El modo fundamental es el modo correcto por
  defecto para tal fichero, tal como el modo C es lo correcto para editar
  código C. (Suficientes lenguajes de programación tienen sintaxis que
  permiten compartir funcionalidades, tal como el modo C es ahora
  proporcionado por el modo CC, la ‘Colección C’.)

  Pero cuando se conoce quien está yendo a usar Emacs––tu, tu mismo––entonces
  eso tiene sentido para personalizar Emacs.

  Por ejemplo, yo raramente quiero el modo Fundamental cuando edito un
  fichero de otro modo no distinguido; yo quiero el modo Texto. Esto es por
  lo que yo personalizo Emacs: así eso se ajusta a mí.

  Se puede personalizar y extender Emacs escribiendo o adaptando un fichero
  @f{~/.emacs}. Esto es un fichero de inicialización personal; sus
  contenidos, escritos en Emacs Lisp, cuentan a Emacs qué hacer.@n{13}

  Un fichero @f{~/.emacs} contiene código Emacs Lisp. Se puede escribir este
  código por uno mismo; o se puede usar la funcionalidad @c{customize} para
  escribir el código para ti. Se puede combinar tus propias expresiones y
  expresiones auto-escritas personalizadas en tu fichero @f{.emacs}.

  (Yo prefiero por mí mismo escribir mis propias expresiones, excepto para
  estas, fuentes particularmente, que se encuentran fáciles de manipular
  usando el comando @c{customize}. Yo combino los dos métodos.)

  La mayoría de este capítulo es acerca de escribir expresiones por uno
  mismo. Eso describe un fichero @f{.emacs} simple; para más información,
  mira @"{El Fichero de Inicio} en @e(El Manual GNU Emacs), y la Seccion
  @"{El Fichero de Inicio} en @e(El Manual de Referencia GNU Emacs Lisp).

** Fichero de inicialización site-wide

   Además de tu fichero de inicialización personal, Emacs automáticamente
   carga varios ficheros de inicialización amplios, si existen. Tienen la
   misma forma que tu fichero @f{.emacs}, pero se cargan por cualquiera.

   Dos ficheros de incialización, @f{site-load.el} y @f{site-init.el}, están
   cargados dentro de Emacs y volcados @e{dumped} sin una versión dumped de
   Emacs se creó, como es más común. (Las copias dumped de Emacs cargan más
   rápidamente. Sin embargo, puesto que un fichero se carga y compila, un
   cambio no llega a ser un cambio en Emacs a menos que se cargue por uno
   mismo o se recompile Emacs. Véase Sección @"(Construyendo Emacs) en @e(El
   Manual de Referencia de GNU Emacs Lisp), y el fichero @f{INSTALL})

   Los otros tres ficheros de inicialización se cargan automáticamente cada
   vez que se inicia Emacs, si existen. Son @f{site-start.el}, que se carga
   @e{antes} que tu fichero @f{.emacs}, y @f{default.el}, y el tipo de
   fichero terminal, que se cargan @e{después} de tu fichero @f{.emacs}.

   Las configuraciones y definiciones en tu fichero @f{.emacs}
   sobreescribirán las configuraciones en conflicto y definiciones en un
   fichero @f{site-start.el}, si eso existe; pero las configuraciones y
   definiciones en un @f{default.el} o el tipo de fichero terminal
   sobreescribirá estos en tu fichero @f{.emacs}. (Se pueden prevenir
   interferencias desde un tipo de fichero terminal configurando
   @c{term-file-prefix} para @c{nil}. Véase Sección @l{Una extensión simple:
   @c{line-to-top-of-window}}.)

   El fichero @f{INSTALL} que viene en la distribución contiene descripciones
   de los fichero @f{site-init.el} y @f{site-load.el}.

   Los ficheros @f{loadup.el}, @f{startup.el}, y @f{loaddefs.el} controlan la
   carga. Estos ficheros están en el directorio @f{lisp} de la distribución
   Emacs y tiene valor de uso.

   El fichero @f{loaddefs.el} contiene buenas sugerencias como las que poner
   dentro de tu propio fichero @f{.emacs}, o dentro de un fichero de
   inicialización amplio.

** Especificar variables usando @c{defcustom}

   Se pueden especificar variables usando @c{defcustom} así que la gente
   pueda usar la funcionalidad de Emacs @c{customize} para asignar sus
   valores. (No se puede usar @c{customize} para escribir definiciones de
   función; pero se pueden escribir @c{defuns} en tu fichero @f{.emacs}. En
   vez de eso, se puede escribir cualquier expresión Lisp en tu fichero
   @f{.emacs}).

   La funcionalidad @c{customize} depende de la forma especial
   @c{defcustom}. Aunque se puede usar @c{defvar} o @c{setq} para las
   variables que los usuarios asignan, la forma especial @c{defcustom} está
   diseñada para el trabajo.

   Se puede usar tu conocimiento de @c{defvar} para escribir los primeros
   tres argumentos para @c{defcustom}. El primer argumento para @c{defcustom}
   es el nombre de la variable. El segundo argumento es el valor inicial de
   la variable, cualquiera; y este valor es asignado solo si el valor no ha
   sido ya asignado. El tercer argumento es la documentación.

   El cuarto y subsiguientes argumentos para @c{defcustom} especifican los
   tipos y opciones; estos no son funcionales en @c{defvar}. (Estos
   argumentos son opcionales.)

   Cada uno de estos argumentos consiste de una palabra seguido de una
   palabra por un valor. Cada palabra clave empieza con los dos puntos @'{:}.

   Por ejemplo, la variable de opciones personalizable @c{text-mode-hook} se
   parece a esto:

   @example
     (defcustom text-mode-hook nil
       "El hook normal se ejecuta cuando se introduce en modo texto y
       muchos modos relacionados."
       :type 'hook
       :options '(turn-on-auto-fill flyspell-mode)
       :group 'data)
   @end example

   El nombre de la variable es @c{text-mode-hook}; no tiene valor por
   defecto; y su cadena de documentación cuenta lo que hace.

   La palabra clave @c{:type} le cuenta a Emacs el tipo de datos para los que
   @c{text-mode-hook} sería asignado y como muestra el valor en un búffer de
   Personalización.

   La palabra clave @c{:options} especifica una lista sugerida de valores
   para la variable. Normalmente, @c{:options} se asocia a un gancho
   (@e{hook}. La lista es solo una sugerencia; esa no es exclusiva; una
   persona quien asigna la variable puede asignarse a otros valores; la lista
   mostrada siguiendo la palabra clave @c{:options} se pretende ofrecer
   elecciones convenientes a un usuario.

   Finalmente, la palabra clave @c{:group} cuenta el comando de
   Personalización de Emacs en el que el grupo de la variable está
   localizado. Esto cuenta dónde encontralo.

   La función @c{defcustom} reconoce más de una docena de palabras
   clave. Para más información, mire @"{Escribiendo las Definiciones de
   Personalización} en @e(El Manual de Referencia GNU Emacs Lisp).

   Considere @c{text-mode-hook} como un ejemplo.

   Hay dos caminos para personalizar esta variable. Se puede usar el comando
   de personalización o escribir las expresiones apropiadas por uno mismo.

   Usando el comando de personalización, se puede escribir:

   @example
     M-x customize
   @end example

   y encuentre que el grupo para editar ficheros de datos se llama
   ‘datos’. Introduzca este grupo. El Hook @e{Disparador} es el primer
   miembro. Se puede hacer click en sus opciones varias, tal como
   @c{turn-on-auto-fill}, para asignar los valores. Después de hacer click en
   el botón.

   @example
     Guárdalo para Futuras Sesiones
   @end example

   Emacs escribirá una expresión en tu fichero @f{.emacs}. Se parecerá a
   esto:

   @example
     (custom-set-variables
       ;; custom-set-variables fué añadido por Custom.
       ;; Si se edita a mano, tu podrías liarte,
       ;; así que ten cuidado.
       ;; Tu fichero init contendría solo esta instancia.
       ;; Si hay más de uno, ellos no quieren trabajar.
      '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
   @end example

   (La función @c{text-mode-hook-identify} cuenta
   @c{toggle-text-mode-auto-fill} que buffers hay en modo Texto.  Eso viene
   automáticamente)

   La función @c{custom-set-variables} funciona de alguna manera diferente
   más de un @c{setq}. Mientras yo nunca he aprendido las diferencias, yo
   modifico las expresiones @c{custom-set-variable} en mi fichero @f{.emacs}
   a mano: yo creo los cambios en los que aparecen a mi para ser una manera
   razonable y no tener problemas. Otros prefieren usar el comando de
   Personalización y permitir a Emacs hacer el trabajo para ellos.

   Otra función @c{custom-set-…} es @c{custom-set-faces}. Esta función asigna
   varios tipos de fuentes. A través del tiempo, yo he asignado un
   considerable número de tipos. Algo de tiempo, yo las reseteo usando
   @c{customize}; otras veces, simplemente edito la expresión
   @c{custom-set-faces} en mi fichero @f{.emacs} en sí.

   El segundo modo de personalizar tu @c{text-mode-hook} es asignarte a tí
   mismo en tu fichero @f{.emacs} usando código que no tiene nada que hacer
   con las funciones @c{custom-set-…}.

   Cuando se hace esto, y después usa @c{customize}, se verá un mensaje que
   dice:

   @example
     CHANGED fuera de Personalizar; operando dentro aquí
     puede ser no confiable.
   @end example

   Este mensaje es solo un aviso. Si se puede cliquear en el botón a

   @example
     Guárdalo para Futuras Sesiones
   @end example

   Emacs escribirá una expresión @c{custom-set-…} cerca del fin de tu fichero
   @f{.emacs} que será evaluado después de que tu expresión sea escrita a
   mano. Por esta razón, se sobreescribirá tu expresión escrita a
   mano. Ningún daño será hecho. Cuando se haga esto, sin embargo, ten
   cuidado para recordar que expresión está activa; si olvidas, puedes
   confundirte por tí mismo.

   Tan largo como se recuerda donde los valores son configurados, no habrá
   problemas. En cualquier eventos, los valores son siempre configurados en
   tu fichero de inicialización, que es normalmente llamado @f{.emacs}.

   Yo mismo hago un @c{customize} para cualquier cosa. Mayoritariamente,
   escribo expresiones por mí mismo.

   Incidentalmente, para ser una definición concerniente más completa:
   @c{defsubst} define una función inline. La sintaxis es solo como esta de
   @c{defun}. @c{defconst} define un símbolo como una constante. El intento
   es que ningún programa o usuario cambiarían un valor asignado por
   @c{defconst}. (Se puede cambiar; el valor asignado es una variable; pero
   por favor no lo haga.)

** Empieza por un fichero @f{.emacs}

   Cuando se abre Emacs, se carga tu fichero @f{.emacs} a menos que se cuente
   que no se especifique @'{-q} en la línea de comandos. (El comando @c{emacs
   -q} tu da un Emacs plano, fuera.)

   Un fichero @f{.emacs} contiene expresiones Lisp. Con frecuencia, no hay
   más expresiones para configura valores; algunas veces esas son
   definiciones de funciones.

   Véase Sección @l{El Fichero de Inicio @f{~/.emacs} en @e(El Manual GNU
   Emacs), para una corta descripción de fichero de inicialización.

   Este capítulo cubre algo del mismo suelo, pero es un paseo entre extractos
   desde un completo, largamente usado fichero @f{.emacs}––por mí.

   La primera parte del fichero consiste en comentario: me recuerdo a mí
   mismo. Por ahora, yo recuerdo estas cosas, pero cuando empecé, no.

   @example
     ;;;; fichero .emacs de Bob
     ; Robert J. Chassell
     ; 26 de Septiembre de 1985
   @end example

   ¡Mira en esta fecha! Yo empecé este fichero hace mucho tiempo. Yo he
   estado añadiendo cosas desde siempre.

   @example
     ; Cada sección en este fichero es introducido por una
     ; línea empezando con cuatro puntos y comas y cada
     ; entrada es introducida por una línea empezando con
     ; tres puntos y comas.
   @end example

   Esto describe las convenciones usuales para comentarios en Emacs
   Lisp. Cada cosa en una línea que sigue un punto y coma es un
   comentario. Dos, tres, y cuatro puntos y coma son usados como subsección y
   marcas de sección. (Véase Sección @"{Comentarios} en @e(El Manual de
   Referencia GNU Emacs Lisp), para más comentarios.)

   @example
     ;;;; La Tecla de Ayuda
     ; Control-h es la tecla de ayuda;
     ; después escribiendo control-h, escribe una letra a
     ; indica el asunto acerca del que quieres ayuda.
     ; Para una explicación de la facilidad de ayuda,
     ; escribe control-h dos veces en una fila.
   @end example

   Solo recuerda: escribe @k{C-h} dos veces para ayudar.

   @example
     ; Para informarse acerca de cualquier modo, escribe control-h m
     ; mientras esté en este modo. Por ejemplo, para encontrar
     ; acerca del modo correo, introduce el modo correo y entonces
     ; escribe control-h m.
   @end example

   ‘Modo ayuda’, como yo llamo a esto, es muy útil. Usualmente, se cuenta
   todo lo que se necesita saber.

   De acuerdo, no se necesitan incluir comentarios y ficheros como estos
   @f{.emacs}. Yo los incluí en el mío porque se olvida el Modo ayuda o las
   convenciones para comentarios––pero era capaz de recordar ver aquí
   recordármelo a mí mismo.

** Modo texto y auto relleno

   Ahora regresa a la parte que ‘vuelve’ al modo Texto y modo Auto Relleno.

   @example
     ;;; Modo texto modo Auto Fill
     ;; Las siguiente dos líneas puestas en Emacs dentro de
     ;; modo Texto y en el modo Auto Fill, son para escritores que
     ;; quieren empezar a escribir prosa en vez de código.
     (setq-default major-mode 'text-mode)
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   @end example

   ¡Aquí está la primera parte de este fichero @f{.emacs} que hace alguna
   cosa bajo recuerdo de un humano olvidado!

   La primera de las dos líneas entre paréntesis cuentan a Emacs a cambiar al
   modo Texto que se encuentra un fichero, @e{a menos que} el fichero iría
   dentro de algún otro modo, tal como el modo C.

   Cuando Emacs lee un fichero, eso parece la extensión al nombre del
   fichero. (La extensión es la parte que viene después de un @'{.}.) Si el
   fichero finaliza con una extensión @'{.c} o @'{.h} entonces Emacs cambia
   al modo C. También, Emacs parece al principio una línea no blanca del
   fichero; si la línea dice @'{-*- C -*-}, Emacs cambia al modo C. Emacs
   posee una lista de extensiones y especificaciones que usa
   automáticamente. Además, Emacs se ve cerca de la última página por buffer,
   “lista variables locales”.

   Mira las secciones “Cómo los Modos Mayores son Elegidos” y “Variables
   Locales en Fichero” en @e{El Manual GNU Emacs}.

   Ahora, regresa al fichero @f{.emacs}.

   Aquí está la línea de nuevo; ¿cómo funciona?

   @example
     (setq major-mode 'text-mode)
   @end example

   Esta línea es un resumen, pero completa la expresión Emacs Lisp.

   Ya estamos familiarizados con @c{setq}. Eso asigna la siguiente variable,
   @c{major-mode}, al subsiguiente valor, que es @c{text-mode}. La marca de
   cita simple antes de @c{text-mode} cuenta a Emacs como tratar directamente
   con el símbolo, no con cualquier cosa que pudiera existir. Véase Sección
   @l{Configurando el Valor de una Variable}, por un recuerdo de como
   @c{setq} funciona. El principal punto es que no hay diferencia entre el
   procedimiento que se usa para asignar un valor en su fichero @f{.emacs} y
   el procedimiento que se usa en cualquier lugar más en Emacs.

   Aquí está la siguiente línea:

   @example
     (add-hook 'text-mode-hook 'turn-on-auto-fill)
   @end example

   En esta línea, el comando @c{add-hook} añade @c{turn-on-auto-fill} para la
   variable.

   ¡@c{turn-on-auto-fill} es el nombre de un programa, que se adivina!,
   cambia al modo Auto Fill.

   Cada vez que Emacs cambia al modo texto, Emacs ejecuta el comando ‘hooked’
   dentro de modo Texto. Así que cada vez que Emacs cambia al modo Texto,
   Emacs también cambia al modo de autoajuste.

   En breve, la primera línea causa a Emacs a entrar en modo Texto cuando se
   edite un fichero, a menos que la extensión del nombre del fichero, una
   línea no en blanco, variables locales para contar a Emacs de otro modo.

   El modo texto entre otras acciones, asigna la tabla de sintaxis para
   trabajar adecuadamente a escritores. En modo texto, Emacs considera un
   apóstrofe como parte de una palabra como una letra; pero Emacs no
   considera un período o un espacio como parte de una palabra. De este modo,
   @k{M-f} se mueve hacia tí a través de @'{eso}. Por otro lado, en modo C,
   @k{M-f} para solo después del @'{t} de @'{eso}.

   La segunda línea causa que Emacs active el modo Auto Fill cuando cambia al
   modo Texto. En modo Auto Fill, Emacs automáticamente rompe una línea que
   es demasiado amplio y trae la parte excesivamente amplia de la línea de
   debajo a la siguiente línea. Emacs rompe líneas entre palabras con ellas.

   Cuando el modo Auto Fill está desactivado, las líneas continúan a la
   derecha como se escriben. Dependiendo de como configuras el valor de
   @c{truncate-lines}, las palabras que se escribe si desaparecen al lado
   derecho de la pantalla, o lo demás son mostradas, en un modo feo e
   ilegible, como una línea de continuación en la pantalla.

   Además, en esta parte de mi fichero @f{.emacs}, yo cuento a Emacs el
   ajuste de comandos para insertar dos espacios después de dos puntos:

   @example
     (setq colon-double-space t)
   @end example

** Alias de correo

   Aquí hay un @c{setq} que ‘activa’ el alias de correo, para más ocasiones.

   @example
     ;;; Modo Correo
     ; Para entrar en el modo correo, escribe ‘C-x m’
     ; Para introducir RMAIL (para leer el correo),
     ; escribe ‘M-x rmail’
     (setq mail-aliases t)
   @end example

   Este comando @c{setq} asigna el valor de la variable @c{mail-aliases} al
   @c{t}. Desde que @c{t} significa cierto, la línea dice, en efecto, “Sí uso
   alias de correo.”

   Los alias de correo son nombres cortos convenientes para largas
   direcciones de correo o para listas de direcciones de correo. El fichero
   donde guardar tus ‘aliases’ es @f{~/.mailrc}. Se escribe un alias como
   este:

   @example
     alias geo george@@foobar.wiz.edu
   @end example

   Cuando se escribe un mensaje a Jorge, la dirección a @'{geo}; el correo
   automáticamente expandirá @'{geo} a la dirección completa.

** Indentar modo de tabulaciones

   Por defecto, Emacs inserta tabulaciones en lugar en múltiples espacios
   cuando se formatea una región. (Por ejemplo, se podrían indentar muchas
   líneas de texto todo a la vez con el comando @c{indent-region}.) Los
   tabuladores se ven bien en un terminal o con impresión ordinaria, pero
   ellos producen mala salida de indentación cuando se usa T@_(E)X o Texinfo
   puesto que T@_(E)X ignora tabuladores.

   Lo siguiente desactiva el modo de Indentar Tabulaciones:

   @example
     ;;; Prevenir Tabulaciones Extrañas
     (setq-default indent-tabs-mode nil)
   @end example

   Note que esta línea usa @c{setq-default} en vez de el comando @c{setq} que
   hemos visto antes. El comando @c{setq-default} asigna valores solo en
   búffers que no tienen sus propios valores locales para la variable.

   Ver secciones “Tabuladores versus Espacios” y “Variables Locales en
   Ficheros” en @e{El Manual de GNU Emacs}.

** Atajos de teclado

   Ahora para algunos atajos personales:

   @example
     ;;; Compara ventanas
     (global-set-key "\C-cw" 'compare-windows)
   @end example

   @c{compare-windows} es un comando excelente que compara el texto en tu
   ventana actual con texto de la siguiente ventana. Eso hace la comparación
   empezando al punto en cada ventana, moviendo a través del texto en cada
   ventana tan lejos como ellos asocian. Yo uso este comando todo el tiempo.

   Esto también muestra como configurar una tecla globalmente, para todo los
   modos

   El comando es @c{global-set-key}. Es seguido por el atajo. En un fichero
   @f{.emacs}, el atajo es escrito como se ve: @c{\C-c} que se asocia a
   ‘control-c’, que significa ‘presionar la tecla de control y la tecla @k{c}
   al mismo tiempo’. La @c{w} significa ‘presionar la tecla @k{w}’. El atajo
   es rodeado por dobles comillas. En la documentación, se escribiría esto
   como @k{C-c w}. (Si estuviera asociando una tecla @k{META}, tal como
   @k{M-c}, en vez de una tecla de @k{CTRL}, se escribiría @c{\M-c} en su
   fichero @f{.emacs}. Véase Sección @"{Reasociando Teclas en Su Fichero
   Init} en @e(El Manual de GNU Emacs), para más detalles.)

   El comando invocado por las teclas es @c{compare-windows}. Note que
   @c{compare-windows} es precedido por una comilla simple; de otro modo,
   Emacs primero intentaría evaluar el símbolo para determinar su valor.

   Estas tres cosas, las marcas de dobles comillas, la barra invertida antes
   de la @'{C}, y la marca de comilla simple son partes necesarias de atajos
   de teclado que tiendo a olvidar. Afortunadamente, he llegado a recordar
   que miraría mi fichero @f{.emacs} existente, y lo adaptaría a lo que hay.

   Como para el atajo en sí: @k{C-c w}, combina la tecla prefija, @k{C-c},
   con un caracter simple, en este caso, @k{w}. Este conjunto de teclas,
   @k{C-c} seguido por un caracter simple, es estrictamente reservado para un
   uso propio individual. (Esto se llama teclas ‘propias’, puesto que estas
   son para su propio uso). Siempre sería capaz de crear tal atajo para el
   uso propio sin pisar fuerte en algún atajo más. Si siempre se escribe una
   extensión a Emacs, por favor, evite tomar cualquiera de estas teclas para
   uso público. Se cree que una tecla como @k{C-c C-w} en vez de eso. De otra
   manera, ejecutará sin sus ‘propias’ teclas.

   Aquí hay otro atajo, con un comentario:

   @example
     ;;; Atajo para ‘occur’
     ; Yo uso mucho occur, así permite asignarlo a una tecla:
     (global-set-key "\C-co" 'occur)
   @end example

   El comando @c{occur} muestra todas las líneas en el buffer actual que
   contiene un emparejamiento para una expresión regular. Asociar las líneas
   que se muestran en un búffer llamado @f{*Occur*}. Este buffer sirve como
   un menu para saltar a ocurrencias.

   Aquí se muestra como desasignar una tecla, así no funciona:

   @example
     ;;; Desasociar ‘C-x f’
     (global-unset-key "\C-xf")
   @end example

   Hay una razón para esta no asociación: Yo encontré inadvertidamente
   escrito @k{C-x f} cuando significó escribir @k{C-x C-f}. En vez de
   encontrar un fichero, como se pretende, accidentalmente asigna el ancho
   para el fichero lleno, casi siempre a un tamaño que no quería. Puesto que
   duramente se reseteó mi ancho por defecto, yo simplemente disocié la
   tecla.

   Lo siguiente reasocia una tecla existente:

   @example
     ;;; Reasocia ‘C-x C-b’ al ‘buffer-menu’
     (global-set-key "\C-x\C-b" 'buffer-menu)
   @end example

   Por defecto, @k{C-x C-b} ejecute el comando @c{list-buffers}. Este comando
   lista sus buffers en @e{otra} ventana. Desde que casi siempre se quiere
   hacer alguna cosa en esta ventana, se prefiere el comando @c{buffer-menu},
   que no solo lista los buffers, pero mueve el punto dentro de esta ventana.

** Mapas de teclado

   Emacs usa @:{keymaps} para grabar qué teclas llaman a qué comandos. Cuando
   se use @c{global-set-key} para asignar los atajos de teclados a un simple
   comando en todo @c{current-global-map}.

   Modos específicos, tales como modo C o modo Texto, tiene sus propios mapas
   de teclado; mapas de teclado de modo específico sobreescribe el mapa
   global que es compartido por todos los buffers.

   La función @c{global-set-key} asocia, o reasocia, el mapa de teclado
   global. Por ejemplo, las siguientes asociaciones la tecla @k{C-x C-b} a la
   función @c{buffer-menu}:

   @example
     (global-set-key "\C-x\C-b" 'buffer-menu)
   @end example

   Mapas de teclado específico de modo son asociados usando la función
   @c{define-key}, que toma un mapa de teclado específico como un argumento,
   tan bien como la tecla y el comando. Por ejemplo, mi fichero @f{.emacs}
   contiene la siguiente expresión asociada al comando
   @c{texinfo-insert-@@group} comando a @k{C-c C-c g}:

   @example
     (define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
   @end example

   La función @c{texinfo-insert-@@group} en sí es una pequeña extensión del
   modo Texinfo que inserta @'{@@group} dentro de un fichero Texinfo. Se usa
   este comando todo el tiempo y se prefieren escribir los tres atajos @k{C-c
   C-c g} en vez de los seis atajos @k{@@ g r o u p}. (@'{@@group} y su
   asociación @'{@@end group} son comandos que guarda todo el texto cerrado
   junto a una página; muchos ejemplos multi-línea en este libro están
   rodeados por @'{@@group … @@end group}.)

   Aquí está la definición de función @c{texinfo-insert-@@group}:

   @example
     (defun texinfo-insert-@@group ()
       "Inserta la cadena @@group en un búffer Texinfo."
       (interactive)
       (beginning-of-line)
       (insert "@@group\n"))
   @end example

   (De acuerdo, podría haber usado el modo Abbrev para dejar de escribir, en
   vez de escribir una función para insertar una palabra; pero prefiero
   atajos de teclado consitentes con otro modo Texinfo para atajos de
   teclado.)

   Verá numerosas expresiones @c{define-key} en @f{loaddefs.el} tan bien como
   en varios modos de librerías, tal como @f{cc-mode.el} y @f{lisp-mode.el}.

   Véase Sección @"{Personalizando Atajos de Teclado} en @e(El Manual GNU
   Emacs), y @"{Mapas de Teclado} en @e(El Manual de Referencia GNU Emacs
   Lisp), para más información acerca de mapas de teclado.

** Cargando ficheros

   Muchas personas en la comunidad de GNU Emacs han escrito extensiones a
   Emacs. Hace tiempo, que estas extensiones son con frecuencia incluidas en
   las nuevas entregas @e{releases}. Por ejemplo, los paquetes Calendario y
   Diario son ahora parte del estándar GNU Emacs, como es Calc.

   Se puede usar un comando @c{load} para evaluar un fichero completo que
   significa instalar todas las funciones y variables en el fichero
   Emacs. Por ejemplo:

   @example
     (load "~/emacs/slowsplit")
   @end example

   Esto evalúa, por ej.@: carga, el fichero @f{slowsplit.el} o si eso existe,
   lo más rápido, el fichero compilado @f{slowsplit.elc} desde el
   subdirectorio @f{emacs} del directorio home. El fichero contiene la
   función @c{split-window-quietly}, que John Robinson escribió en 1989.

   La función @c{split-window-quietly} divide una ventana con el mínimo de
   redisplay. Yo lo instalé en 1989 porque trabajó bien con los terminales de
   1200 baudios que entonces estaba usando. Ahora, ocasionalmente vengo a
   través de una conexión lenta, pero continúa usando la función porque me
   gusta el camino que deja arriba del búffer en el bajo de las nuevas
   ventanas y arriba en la ventana superior.

   Para reemplazar el atajo de teclado por defecto
   @c{split-window-vertically}, se debe también desasignar esta tecla y
   asociar las teclas a @c{split-window-quietly}, como este:

   @example
     (global-unset-key "\C-x2")
     (global-set-key "\C-x2" 'split-window-quietly)
   @end example

   Si se cargan muchas extensiones, como yo hago, entonces en vez de
   especificar la posición exacta del fichero, como se muestra arriba, se
   puede especificar que directorio como parte del @c{load-path} de
   Emacs. Entonces, cuando Emacs carga un fichero, buscará que directorio tan
   bien como su lista por defecto de directorios. (La lista por defecto es
   especificada en @f{paths.h} cuando Emacs se construye.)

   El comando siguiente añade tu directorio @f{~/emacs} a la ruta existente:

   @example
     ;;; Ruta Emacs
     (setq load-path (cons "~/emacs" load-path))
   @end example

   Incidentalmente, @c{load-library} es un interfaz interactivo a la función
   @c{load}. La función se parece a esto:

   @example
     (defun load-library (library)
       "Carga la librería llamada LIBRARY.
     Esto es una interfaz a la función ‘load’."
       (interactive
        (list (completing-read "Carga la librería: "
                               (apply-partially 'locate-file-completion-table
                                                load-path
                                                (get-load-suffixes)))))
       (load library))
   @end example

   El nombre de la función, @c{load-libray}, viene desde el uso de ‘library’
   como un sinónimo para ‘file’. La fuente para el comando @c{load-library}
   está en la librería @f{files.el}.

   Otro comando interactivo que hace un trabajo ligeramente diferente es
   @c{load-file}. Véase Sección @"{Librerías de Código Lisp para Emacs} en
   @e(El Manual GNU Emacs), para información en la distinción entre
   @c{load-library} y este comando.

** Autoloading

   En vez de instalar una función cargando el fichero que lo contiene, o
   evaluando la definición de función, se puede hacer la función disponible
   pero actualmente no se instala hasta la primera vez llamada. Este proceso
   se llama @:{autocarga} (@e{autoloading}).

   Cuando se ejecuta una función de autocarga, Emacs automáticamente evalúa
   el fichero que contiene la definición, y entonces llama a la función.

   Emacs empieza rápido con funciones de autocarga, puesto que sus librerías
   no se cargan bien; pero si necesita esperar un momento cuando su primer
   uso tal como una función, mientras que el fichero que lo contiene se
   evalúa.

   Raramente las funciones usadas son frecuentemente autocargadas. La
   librería @f{loaddefs.el} coniene cientos de funciones autocargadas, desde
   @c{bookmark-set} a @c{wordstar-mode}. Si se usa una función ‘rara’
   frecuentemente, se debería cargar este fichero de función con una
   expresión de @c{load} en tu fichero @f{.emacs}.

   En mi fichero @f{.emacs}, se cargan 14 librerías que contienen funciones
   que de otro modo serían autocargadas. (Actualmente, eso habría sido mejor
   para incluir estos ficheros en mi Emacs ‘volcado’, pero se olvida. Véase
   Sección @"{Construyendo Emacs} en @e(El Manual de Referencia GNU Emacs
   Lisp), y el fichero @f{INSTALL} para más acerca de volcados.)

   Se puede también querer incluir expresiones autocargadas en tu fichero
   @f{.emacs}. @c{autoload} es una función construida que toma cinco
   argumento, los tres finales de los que son opcionales. El primer argumento
   es el nombre de la función para ser autocargada. El segundo es el nombre
   del fichero para ser cargado. El tercer argumento es documentación para la
   función, y el cuarto cuenta si la función puede ser llamada
   interactivmente. El quinto argumento cuenta que tipo de
   objeto––@c{autoload} puede manejar un mapa de teclado o macro tan bien
   como una función (por defecto es una función).

   Aquí hay un ejemplo típico:

   @example
     (autoload 'html-helper-mode
       "html-helper-mode" "Editar documentos HTML" t)
   @end example

   (@c{html-helper-mode} es una vieja alternativa a @c{html-mode}, que es una
   parte estándar de la distribución.)

   Esta expresión autocarga la función @c{html-helper-mode}. Esto se toma
   desde el fichero @f{html-helper-mode-el} (o desde la versión compilada
   @f{html-helper-mode.elc}, si eso existe). El fichero debe ser localizado
   en un directorio específico por @c{load-path}. La documentación dice que
   esto es un modo para ayudar a editar documentos escritos en Lenguaje de
   Marcas de Hiper Texto. Se puede llamar este modo interactivamente
   escribiendo @k{M-x html-helper-mode}. (Se necesitan duplicar las funciones
   regulares de documentación en la expresión de autocarga porque la función
   regular no está todavía cargada, así su documentación no está disponible.)

   Véase Sección @"{Autocarga} en @e(El Manual de Referencia de GNU Emacs
   Lisp), para más información.

** Una extensión simple: @c{line-to-top-of-window}

   Aquí hay una simple extensión a Emacs que mueve el punto de línea arriba
   de la ventana. Yo uso esto todo el tiempo, para hacer fácil de leer el
   texto.

   Se puede poner el siguiente código dentro de un fichero separado y entonce
   cargarlo desde tu fichero @f{.emacs}, o se puede incluir con tu fichero
   @f{.emacs}.

   Aquí está la definición

   @example
     ;;; Línea a lo alto de la ventana;
     ;;; reemplaza tres secuencias de atajos de teclado  C-u 0 C-l
     (defun line-to-top-of-window ()
       "Mueve la línea que apunta a lo alto de la ventana."
       (interactive)
       (recenter 0))
   @end example

   Ahora el atajo.

   En estos días, las teclas de función así como los eventos del ratón y
   caracteres no @Cc{ascii} son escritos con corchetes, sin marcas de
   citas. (En Emacs versión 18 y anteriores, se tenía que escribir diferentes
   teclas de función asignadas por cada diferente creación del terminal.)

   Se puede asociar @c{line-to-top-of-window} a la tecla de función @k{F6}
   así:

   @example
     (global-set-key [f6] 'line-to-top-of-window)
   @end example

   Para más información, mira @"{Reasociando Teclas en tu fichero init} en
   @e{El Manual GNU Emacs}.

   Si ejecutas dos versiones de GNU Emacs, tal como las versiones 22 y 23, y
   usas un fichero @f{.emacs}, se puede seleccionar qué código evalúa el
   siguiente condicional:

   @example
     (cond
      ((= 22 emacs-major-version)
       ;; evalúa la version 22
       ( … ))
      ((= 23 emacs-major-version)
       ;; evalúa la version 23
       ( … )))
   @end example

   Por ejemplo, en versiones más recientes se ocultan los cursores por
   defecto. Si se odia tal ocultación se escribe lo siguiente en mi fichero
   @f{.emacs}@n{14}:

   @example
     (when (>= emacs-major-version 21)
       (blink-cursor-mode 0)
       ;; Inserta la nueva línea cuando se presiona ‘C-n’ (next-line)
       ;; al fin del búffer
       (setq next-line-add-newlines t)
       ;; Cambia la imagen viendo
       (auto-image-file-mode t)
       ;; Activa la barra de menu (esta barra tiene texto)
       ;; (Usa un argumento numérico para activarlo)
       (menu-bar-mode 1)
        ;; Desactiva la barra de herramientas (esta barra tiene iconos)
        ;; (Usa argumentos numéricos para activarlo)
        (tool-bar-mode nil)
       ;; Desactiva el modo tooltip para la tool bar
       ;; (Este modo causa explicaciones de iconos al pop up)
       ;; (Usa el argumento numérico para activarlo)
       (tooltip-mode nil)
       ;; Si los tooltips activados, crea consejos aparecen en el prompt
       (setq tooltip-delay 0.1)  ; por defecto es de 0.7 segundos
        )
   @end example

** Colores X11

   Se pueden especificar colores cuando se usa Emacs con el Sistema de
   Ventanas X del MIT.

   Si disgustan los colores por defecto y especifica unos propios.

   Aquí están las expresiones en un fichero @f{.emacs} que establecen los
   valores:

   @example
     ;; Asigna el color del cursor
     (set-cursor-color "white")

     ;; Asigna el color del ratón
     (set-mouse-color "white")

     ;; Asigna foreground y background
     (set-foreground-color "white")
     (set-background-color "darkblue")

     ;;; Asigna colores para isearch y drag
     (set-face-foreground 'highlight "white")
     (set-face-background 'highlight "blue")

     (set-face-foreground 'region "cyan")
     (set-face-background 'region "blue")

     (set-face-foreground 'secondary-selection "skyblue")
     (set-face-background 'secondary-selection "darkblue")

     ;; Asigna colores al calendario
     (setq calendar-load-hook
           '(lambda ()
              (set-face-foreground 'diary-face   "skyblue")
              (set-face-background 'holiday-face "slate blue")
              (set-face-foreground 'holiday-face "white")))
   @end example

   Las varias sombras de azul disparan mi ojo y me preveen de ver la ventana
   desplegada.

   Alternativamente, se podrían haber configurado mis especificaciones en
   varios ficheros inicialización de X. Por ejemplo, se podría asignar el
   foreground, background, cursor y puntero (por ej., ratón) colores en mi
   fichero @f{~/.Xresources} como esto:

   @example
     Emacs*foreground:   white
     Emacs*background:   darkblue
     Emacs*cursorColor:  white
     Emacs*pointerColor: white
   @end example

   En cualquier evento que no es parte de Emacs, se asigna el color raíz de
   mi ventana X en mi fichero @f{~/.xinitrc}, como este@n{15}

   @example
     xsetroot -solid Navy -fg white &
   @end example

** Configuraciones misceláneas para un fichero @f{.emacs}

   Aquí hay unas pocas configuraciones misceláneas:


   - Asigna la forma y color del ratón del cursor:

     @example
       ; Formas de Cursor están definidas en
       ; ‘/usr/include/X11/cursorfont.h’;
       ; por ejemplo, el cursor ‘objetivo’ es número 128;
       ; el cursor ‘top_left_arrow’ es el número 132.

       (let ((mpointer (x-get-resource "*mpointer"
                                       "*emacs*mpointer")))
         ;; Si no se ha asignado tu puntero de ratón
         ;; entonces asignalo, de otro modo, déjalo así:
         (if (eq mpointer nil)
             (setq mpointer "132")) ; top_left_arrow
         (setq x-pointer-shape (string-to-int mpointer))
         (set-mouse-color "white"))
     @end example

   - O se pueden asignar los valores de una variedad de funcionalidades en
     una alist, como esta:

     @example
       (setq-default
        default-frame-alist
        '((cursor-color . "white")
          (mouse-color . "white")
          (foreground-color . "white")
          (background-color . "DodgerBlue4")
          ;; (cursor-type . bar)
          (cursor-type . box)
          (tool-bar-lines . 0)
          (menu-bar-lines . 1)
          (width . 80)
          (height . 58)
          (font .
                "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
          ))
     @end example

   - Convierte @k{@k{CTRL}-h} dentro @k{DEL} y @k{DEL} dentro de
     @k{@k{CTRL}-h}.@* (Algunos viejos teclados lo necesitan, aunque yo no he
     visto el problema recientemente.)

     @example
       ;; Traducir ‘C-h’ a <DEL>.
       ; (keyboard-translate ?\C-h ?\C-?)

       ;; Traducir <DEL> a ‘C-h’.
       (keyboard-translate ?\C-? ?\C-h)
     @end example

   - ¡Desactiva un cursor oculto!

     @example
       (if (fboundp 'blink-cursor-mode)
           (blink-cursor-mode -1))
     @end example

     o empieza GNU Emacs con el comando @c{emacs -nbc}.

   - Cuando se usa ‘grep’

     - @'{-i} :: Ignore distinciones de letras@*

     - @'{-n} :: El prefijo de cada línea de la salida con el número de
       líneas@*

     - @'{-H} :: Imprime el nombre de fichero para cada cadena encontrada.@*

     - @'{-e} :: Protege patrones empezando con un caracter de guión, @'{-}

       @example
         (setq grep-command "grep -i -nH -e ")
       @end example

     @ignore
       @c Evidently, no longer needed in GNU Emacs 22

       item Automatically uncompress compressed files when visiting them

       example
         (load "uncompress")
       end example
     @end ignore

   - Encuentra un búffer existente, incluso si eso tiene un nombre diferente ::

     Esto evita problemas con enlaces simbólicos.

     @example
       (setq find-file-existing-other-name t)
     @end example

   - Configura tu entorno de lenguaje y el método de entrada por defecto

     @example
       (set-language-environment "latin-1")
       ;; Recuerda que se puede habilitar o deshabilitar el texto de lenguaje
       ;; multilingüe con el comando @c{toggle-input-method'} (@k{C-\})
       (setq default-input-method "latin-1-prefix")
     @end example

     Si se quiere escribir con el caracter Chino ‘GB’, asigna esto:

     @example
       (set-language-environment "Chinese-GB")
       (setq default-input-method "chinese-tonepy")
     @end example

*** Arreglando Atajos de Teclados

    Algunos sistemas asocian teclas de maneras no agradables. Algunas veces,
    por ejemplo, la tecla @k{CTRL} en un modo perverso en vez de la lejanía a
    la izquierda de la fila.

    Normalmente, cuando las personas arreglan estos atajos de teclado, no se
    cambia su fichero @f{~/.emacs}. En vez de eso, se asocian las teclas
    apropiadas en sus consolas con los comandos @c{loadkeys} o
    @c{install-keymap} en su script de inicio y entonces incluyen comandos
    @c{xmodmap} en su fichero @f{.xinitrc} o @f{.Xsession} para X Windows.

    Para un script de inicio:

    @example
      loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

      or

      install-keymap emacs2
    @end example

    Para un fichero @f{.xinitrc} o un fichero @f{.Xsession} cuando la tecla
    @k{Caps Lock} es que tan lejos de la fila del home:

    @example
      # Asocia la tecla etiquetada ‘Caps Lock’ a ‘Control’
      # (Tal como un interfaz de usuario roto sugiere que el teclado hecho
      # piensa que los ordenadores son máquinas de escribir desde 1885.)

      xmodmap -e "clear Lock"
      xmodmap -e "add Control = Caps_Lock"
    @end example

    En un @f{.xinitrc} o @f{.Xsession}, para convertir una tecla @k{ALT} a
    una tecla @k{META}:

    @example
      # Algunos teclados mal diseñados tienen una tecla etiquetada ALT y no Meta
      xmodmap -e "keysym Alt_L = Meta_L Alt_L"
    @end example

** Una línea modificada

   Finalmente, una funcionalidad que realmente me gusta: un mode line
   modificado.

   Cuando se trabaja a través de una red, se olvida que máquina se está
   usando. También, se tiende a perder la traza de donde se está, y a qué
   línea se apunta.

   Así se resetea mi mode line para que se parezca a esto:

   @example
     ::-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
   @end example

   Estoy visitando un fichero llamado @f{foo.texi}, en mi máquina
   @f{rattlesnake} en mi búffer @f{/home/bob}. Yo estoy en la línea 1, en
   modo Texinfo, y estoy arriba del búffer.

   Mi fichero @f{.emacs} tiene una sección que se parece a esto:

   @example
     ;; Asigna un Mode Line que nos cuente que máquina, que directorio,
     ;; y que línea estoy on, más la información de client.
     (setq-default mode-line-format
      (quote
       (#("-" 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        mode-line-mule-info
        mode-line-modified
        mode-line-frame-identification
        "    "
        mode-line-buffer-identification
        "    "
        (:eval (substring
                (system-name) 0 (string-match "\\..+" (system-name))))
        ":"
        default-directory
        #(" " 0 1
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (line-number-mode " Line %l ")
        global-mode-string
        #("   %[(" 0 6
          (help-echo
           "mouse-1: select window, mouse-2: delete others ..."))
        (:eval (mode-line-mode-name))
        mode-line-process
        minor-mode-alist
        #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
        ")%] "
        (-3 . "%P")
        ;;   "-%-"
        )))
   @end example

   Aquí, se redefine el mode line por defecto. La mayoría de las partes son
   desde el original; pero yo creo unos pocos cambios. Yo asigno el formato
   de mode line @e{default} así como permitir varios modos, tales como Info,
   para sobreescribirlo.

   Muchos elementos en la lista son auto-explicativos: @c{mode-line-modified}
   es una variable que cuenta si el búffer ha sido modificado, @c{mode-name}
   cuenta el nombre del modo, y así. Sin embargo, el formato parece
   complicado porque las dos funcionalidades no han sido discutidas.


   La nueva cadena de formato tiene una sintaxis especial:

   @example
     #("-" 0 1 (help-echo "mouse-1: select window, ..."))
   @end example

   El @c{#(} empieza una lista. El primer elemento de la lista es la cadena
   en sí, solo un @'{-}. El segundo y tercer elemento especifica el rango a
   través del cuarto elemento aplicado. Un rango empieza @e{después} un
   carácter, así un cero significa el rango que empieza solo después del
   primer caracter; un 1 significa que el rango finaliza solo después del
   primer caracter. El tercer elemento es la propiedad para el rango. Eso
   consiste en una lista de propiedades, un nombre de propiedad, en este
   caso, @'{help-echo}, seguido por un valor, en este caso, una cadena. El
   segundo, tercer y cuarto elemento de este nuevo formato de cadena puede
   ser repetido.

   Véase Sección @"{Propiedades de Texto} en @e{El Manual de Referencia de
   GNU Emacs Lisp}, y ver @"{Formato Mode Line} en @e{El Manual de Referencia
   de GNU Emacs Lisp}, para más información.

   @c{mode-line-buffer-identification} muestra el nombre del buffer. Eso es
   una lista empezando por @c{(#("%12b" 0 4 …}. El @c{#(} empieza la lista.

   El @'{"%12b"} muestra el nombre del actual búffer, usando la función
   @c{buffer-name} con la que estamos familiarizados; el ‘12’ especifica el
   número máximo de caracteres que serán mostrados. Cuando un nombre tiene
   pocos caracteres, el espacio en blanco se añade para rellenar este
   número. (Los nombres del búffer puede y con frecuencia serán más largos de
   12 caracteres; esta longitud funciona bien en la típica ventana de 80
   columnas de ancho.)

   @c{:eval} dice evaluar la siguiente forma y usa el resultado como una
   cadena para mostrarse. En este caso, la expresión muestra el primer
   componente del sistema completo. El fin del primer componente es un @'{.}
   (‘periodo’), así se usa la función @c{string-match} para contar el tamaño
   del primer componente. La subcadena desde el caracter cero a este tamaño
   del primer componente. La subcadena desde el caracter cero a este tamaño
   es el nombre de la máquina.

   Esta es la expresión:

   @example
     (:eval (substring
             (system-name) 0 (string-match "\\..+" (system-name))))
   @end example

   @'{%[} y @'{%]} causa un par de corchetes que aparezcan por cada edición
   nivel de edición recursiva editando el nivel. @'{%n} dice ‘Encoger’ cuando
   esto puede hacerse. @'{%P} te cuenta el porcentaje del búffer que está
   debajo de la ventana, o ‘arriba’, ‘abajo’, o ‘todo’. (Una minúscula @'{p}
   cuenta el porcentaje bajo el alto de la ventana.) @'{%-} inserta
   suficientes guiones para rellenar la línea.

   Recuerda, “No tiene que gustarte Emacs para que le gustes”––Emacs puede
   tener diferentes colores, diferentes comandos, y diferentes teclas que un
   Emacs por defecto.

   Por otro lado, si se quiere traer un plano ‘fuera de la caja’ Emacs, sin
   personalización, escribe:

   @example
     emacs -q
   @end example

   Esto inicializará un Emacs que @e{no} cargue tu @f{~/.emacs} fichero de
   inicialización. Uno plano, el que trae Emacs por defecto. Nada más.

* Depurando

  GNU Emacs tiene dos depuradores, @c{debug} y @c{edebug}. El primero es
  construido dentro de las tripas de Emacs y está siempre contigo; el segundo
  requiere que exista una función antes de que se pueda usar.

  Ambos depuradores son descritos extensivamente en Seccion @"{Depurando} en
  @e{El Manual de Referencia GNU Emacs Lisp}. En este capítulo, se explicará
  un breve ejemplo de esto.

** @c{depurar}

   Supón que se ha escrito una definición de función que se pretende devolver
   la suma de los números 1 a través de un número dado. (Esta es la función
   @c{triangle} discutida pronto. Véase Sección @l{Ejemplo de Decremento, ,
   Ejemplo con Contador de Decremento}, para una discusión.)

   Sin embargo, tu definición de función tiene un error. Se ha malescrito
   @'{1=} por @'{1-}. Aquí está la definición rota:

   @example
     (defun triangle-bugged (number)
       "Devuelve suma de números 1 a través de NUMBER inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (setq number (1= number)))      ; @e{Error aquí.}
         total))
   @end example

   Si se está leyendo esto en Info, se puede evaluar esta definición en el
   modo normal. Se verá que @c{triangle-bugged} aparece en el área echo.

   Ahora evalúa la función @c{triangle-bugged} con un argumento de 4:

   @example
     (triangle-bugged 4)
   @end example

   En un GNU Emacs reciente, se creará e introducirá un búffer
   @f{*Backtrace*} que dice:

   @example
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
       (1= number)
       (setq number (1= number))
       (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
       (let ((total 0)) (while (> number 0) (setq total ...)
         (setq number ...)) total)
       triangle-bugged(4)
       eval((triangle-bugged 4))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end example

   (Se ha reformateado este ejemplo ligeramente; el depurador no contiene
   muchas líneas. Así, se puede salir del depurador escribiendo @k{q} en el
   buffer @f{*Backtrace*}.)

   En la práctica, debido a un error tan simple como este, la línea de ‘error
   Lisp’ explica lo que se necesita saber para corregir la definición. La
   función @c{1=} está ‘vacía’.

   @ignore
     In GNU Emacs 20 and before, you will see:

     @example
       La definición de la función está vacío:@: 1=
     @end example

     which has the same meaning as the @f{*Backtrace*} buffer line in
     version 21.
   @end ignore

   Sin embargo, si no se conoce con bastante certeza lo que está pasando, se
   puede leer la traza completa.

   En este caso, se necesita ejecutar una versión reciente de GNU Emacs, que
   automáticamente empieza el depurador que pone en el búffer
   @f{*Backtrace*}; o además, se necesita para empezar el depurador
   manualmente como se describe debajo.

   Lee el búffer @f{*Backtrace*} de abajo a arriba; eso cuenta lo que le hizo
   a Emacs tener un error. Emacs hace una llamada interactiva a @k{C-x C-e}
   (@c{eval-last-sexp}), que lleva a la evaluación de la expresión
   @c{triangle-bugged}. Cada línea de debajo cuenta lo que el intérprete Lisp
   evaluó.

   La tercera línea desde lo alto del búffer es

   @example
     (setq number (1= number))
   @end example

   Emacs intentó evaluar esta expresión; para hacerlo así, se intentó evaluar
   la expresión interna para ser mostrada en la segunda línea desde arriba:

   @example
     (1= number)
   @end example

   Aquí es donde el error ocurre; como se dice en la línea de arriba:

   @example
     Debugger entered--Lisp error: (void-function 1=)
   @end example

   Se puede corregir el error, reevalúa la definición de función, y entonces
   se puede testear de nuevo.

** @c{debug-on-entry}

   Un GNU Emacs actual abre el depurador automáticamente cuando la función
   tiene un error.

   @ignore
     GNU Emacs version 20 and before did not; it simply
     presented you with an error message.  You had to start the debugger
     manually.
   @end ignore

   Incidentalmente, se puede empezar el depurador manualmente para todas las
   versiones de Emacs; la ventaja es que el depurador se ejecuta incluso si
   no se tiene un error en su código. Algunas veces, ¡su código estará libre
   de errores!

   Se puede introducir el depurador cuando se llama a la función llamando
   @c{debug-on-entry}.

   Tipo:

   @example
     M-x debug-on-entry RET triangle-bugged RET
   @end example

   Ahora, evalúa lo siguiente:

   @example
     (triangle-bugged 5)
   @end example

   Todas las versiones de Emacs crearán un búffer @f{*Backtrace*} y cuenta tu
   que eso es el principio para evaluar la función @c{triangle-bugged}:

   @example
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--entering a function:
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end example

   En el búffer @f{*Backtrace*}, escribe @k{d}. Emacs evaluará la primera
   expresión en @c{triangle-bugged}; el búffer se parece a esto:

   @example
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end example

   Ahora, escribe @k{d} de nuevo, ocho veces, lentamente. Cada vez que se
   escribe @k{d} Emacs evaluará otra expresión en la definición de función.

   Eventualmente, el búffer se parece a esto:

   @example
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--beginning evaluation of function call form:
     * (setq number (1= number))
     * (while (> number 0) (setq total (+ total number))
             (setq number (1= number)))
     * (let ((total 0)) (while (> number 0) (setq total ...)
             (setq number ...)) total)
     * triangle-bugged(5)
       eval((triangle-bugged 5))
       eval-last-sexp-1(nil)
       eval-last-sexp(nil)
       call-interactively(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
   @end example

   Finalmente, después se escribe @k{d} dos veces más, Emacs logrará el error
   y las dos líneas superiores del buffer @f{*Backtrace*} se ve así:

   @example
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function 1=)
     * (1= number)
     …
     ---------- Buffer: *Backtrace* ----------
   @end example

   Escribiendo @k{d}, sería capaz de pasear a través de la función.

   Se puede salir de un buffer @f{*Backtrace*} escribiendo @k{q}; esto se
   sale de la traza, pero no cancela @c{debug-on-entry}.

   Para cancelar el efecto de @c{debug-on-entry}, llama a
   @c{cancel-debug-on-entry} y el nombre de la función, como esto:

   @example
     M-x cancel-debug-on-entry RET triangle-bugged RET
   @end example

   (Si está leyendo esto en Info, cancela @c{debug-on-entry} ahora.)

** @c{debug-on-quit} y @c{(debug)}

   Adición a la configuración @c{debug-on-error} o llamando
   @c{debug-on-entry}, hay otros dos caminos para empezar @c{debug}.

   Se puede empezar @c{debug} siempre y cuando se escribe @k{C-g}
   (@c{keyboard-quit}) se configura la variable @c{debug-on-quit} para
   @c{t}. Esto es útil para depurar bucles infinitos.

   O, se puede insertar un línea que dice @c{(debug)} dentro de tu código
   donde se quiere que el depurador empiece, así:

   @example
     (defun triangle-bugged (number)
       "Devuelve suma de números 1 a través de NUMERO inclusive."
       (let ((total 0))
         (while (> number 0)
           (setq total (+ total number))
           (debug)                         ; @e{Empieza el depurador.}
           (setq number (1= number)))      ; @e{Error aquí.}
         total))
   @end example

   La función @c{debug} se describe en detalle en @"{El Depurador Lisp} en
   @e{El Manual de Referencia GNU Emacs Lisp}.

** El depurador de nivel de fuentes @c{edebug}

   Edebug es un depurador a nivel de fuentes Edebug que normalmente muestra
   las fuentes del código que se está depurando, con una flecha a la
   izquierda que muestra que línea se está actualmente ejecutando.

   Se puede pasear a través de la ejecución de una función, línea a línea, o
   ejecutarse rápidamente hasta lograr un @:{punto de ruptura} donde la
   ejecución pare.

   Edebug se describe en Seccion @"{edebug} en @e{El Manual de Referencia de
   GNU Emacs Lisp}.

   Aquí hay una función con errores para @c{triangle-recursively}. Véase
   Sección @l{Recursión en lugar de un contador}, para una revisión de eso.

   @example
     (defun triangle-recursively-bugged (number)
       "Devuelve la suma of números 1 a través de NUMBER inclusive.
     Usa recursión."
       (if (= number 1)
           1
         (+ number
            (triangle-recursively-bugged
             (1= number)))))               ; @e{Error aquí.}
   @end example

   Normalmente, se instalaría esta definición posicionando su cursor después
   de la función cerrando paréntesis y escribiendo @k{C-x C-e}
   (@c{eval-last-sexp}) o lo demás posicionando tu cursor con la definición y
   escribiendo @k{C-M-x} (@c{eval-defun}). (Por defecto, el comando
   @c{eval-defun} funciona solo en modo Emacs Lisp o en el modo de
   interacción de Lisp.)

   Sin embargo, para preparar esta definición de función para Edebug, se debe
   primero @:{instrumentar} el código usando un comando diferente. Se puede
   hacer esto posicionando el cursor dentro o después de la definición y
   escribiendo

   @example
     M-x edebug-defun RET
   @end example

   Esto causará que Emacs cargue Edebug automáticamente si eso no está ya
   cargado y, apropiadamente prepara la función.

   Después de preparar la función, emplaza tu cursor después de la siguiente
   expresión y escribe @k{C-x C-e} (@c{eval-last-sexp}):

   @example
     (triangle-recursively-bugged 3)
   @end example

   Se vuelve a las fuentes de @c{triangle-recursively-bugged} y el cursor se
   posiciona al principio del @c{if} de la línea de la función. También, se
   verá una flecha en la mano izquierda al lado de esta línea donde la
   función se está ejecutando. (En los siguientes ejemplos, se muestra la
   flecha con @'{=>}; en un sistema de ventanas, se puede ver la flecha como
   un triángulo sólido en el ‘borde’ de la ventana.)

   @example
     =>★(if (= number 1)
   @end example

   En el ejemplo, la posición del punto es mostrado con una estrella,
   @'{★} (en Info, eso es mostrado como @'{-!-}).

   Si ahora se presiona @k{SPC}, el punto se moverá a la siguiente expresión
   para ejecutarse; la línea se parece a esto:

   @example
     =>(if ★(= number 1)
   @end example

   Como se continua presionando @k{SPC}, el puntero se moverá desde la
   expresión a la expresión. Al mismo tiempo, siempre y cuando una expresión
   devuelva un valor, este valor será mostrado en el área echo. Por ejemplo,
   después de mover el punto pasado @c{number}, se verá lo siguiente:

   @example
     Resultado: 3 (#o3, #x3, ?\C-c)
   @end example

   Esto significa el valor de @c{number} es 3, que son tres octales, tres
   hexadecimales, y @Cc{ascii} ‘control-c’ (la tercera letra del alfabeto, en
   caso de que se necesite conocer esta información).

   Uno puede continuar moviéndose a través del código hasta que logre la
   línea con el error. Antes de la evaluación, esta línea se parece a esto:

   @example
     =>        ★(1= number)))))               ; @e{Error aquí.}
   @end example

   Cuando se presiona @k{SPC} una vez de nuevo, se producirá un mensaje de
   error que dice:

   @example
     La definición de la función está vacío:@: 1=
   @end example

   Este es el error.

   Presiona @k{q} para salir de Edebug.

   Para eliminar la instrumentación desde una definición de función,
   simplemente se reevalúa con un comando que no lo instrumente. Por ejemplo,
   se podría posicionar su cursor después de la definición cerrando
   paréntesis y escribiendo @k{C-x C-e}.

   Edebug hace un gran trato antes de entrar en una función. Se puede dirigir
   así mismo, parando solo en un error o en puntos específicos, se puede
   causar para mostrar los valores cambiantes de varias expresiones; se puede
   encontrar cuantas veces una función se llama, y más.

   Edebug se describe en @"{edebug} en @e{El Manual de Referencia de GNU
   Emacs Lisp}.

** Ejercicios de depuración

   - Instale la función @c{@v{COUNT-WORDS}} y provoque que se introduzca el
     depurador construido cuando se llame. Ejecute el comando en una región
     conteniendo dos palabras. Se necesitará presionar @k{d} un número
     remarcable de veces. En el sistema, es un ‘hook’ llamado después que el
     comando se finaliza. (Para información sobre hooks, mira Seccion
     @"{Resumen del Comando Bucle} en @e{El Manual de Referencia GNU Emacs
     Lisp}.)

   - Copie @c{@v{COUNT-WORDS}} dentro del búffer @f{*scratch*}, instrumente
     la función para Edebug, y navegue a través de su ejecución. La función
     no necesita tener un error, aunque se puede introducir uno si se
     desea. Si a la función le falta un error, el paseo se completa sin
     problemas.

   - Mientras se ejecuta Edebug, escriba @k{?} para ver una lista de todos
     los comandos Edebug. (El @c{global-edebug-prefix} normalmente es @k{C-x
     X}, por ej@: @k{@k{CTRL}-x} seguido por una tecla mayúscula @k{X}; use
     este prefijo para comandos hechos fuera del búffer de depuración
     Edebug.)

   - En el búffer de depuración Edebug, usa el comando @k{p}
     (@c{edebug-bounce-point}) para ver si @c{@v{COUNT-WORDS}} está
     funcionando.

   - Mueve el punto a algún sitio debajo de la función y entonces escribe el
     comando @k{h} (@c{edebug-goto-here}) para saltar a esta localización.

   - Usa el comando @k{t} (@c{edebug-trace-mode}) para causar que Edebug
     pasee a través de la función en sí; usa una letra mayúscula @k{T} para
     @c{edebug-Trace-fast-mode}.

   - Asigna un punto de ruptura, entonces ejecuta Edebug en modo Traza hasta
     que se logre el punto de parada.

* Conclusión

  Ahora se ha llegado al fin de esta Introducción. Se ha aprendido lo
  suficiente acerca de programación en Emacs Lisp para asignar valores, para
  escribir ficheros @f{.emacs} para tí mismo y tus amigos, y escribir
  personalizaciones simples y extensiones a Emacs.

  Este es un lugar para parar. O, si se desea, se puede ir adelante, y
  aprender más por uno mismo.

  Se han aprendido algunas bases de programación. Pero solo algunas. Todavía
  hay muchas cosas que son fáciles de usar que no se han tocado.

  Otra idea para seguir es leer las fuentes de Emacs o @ifnotinfo @e{El
  Manual de Referencia de GNU Emacs}.  @end ifnotinfo @ifinfo @l{Arriba, , El
  Manual de Referencia de GNU Emacs Lisp, El Manual de Referencia de GNU
  Emacs Lisp}.  @end ifinfo

  Las fuentes de Emacs Lisp son una aventura. Cuando se leen las fuentes
  vienen a través de una función o expresión que nos es familiar, se necesita
  imaginar o encontrar qué se hace.

  Ir al Manual de Referencia. Eso está a través del completo, limpio y fácil
  de leer descripción de Emacs Lisp. Está escrito no solo para expertos, pero
  sí para gente que conoce lo que usted conoce. (El @e{Manual de Referencia}
  viene con la distribución de GNU Emacs. Como esta introducción, viene como
  un fichero fuente Texinfo, así se puede leer on-line como un libro
  impreso.)

  Ir a otra ayuda on-line que sea parte de GNU Emacs: la documentación
  on-line para todas las funciones y variables, y @c{find-tag}, el programa
  que va a las fuentes.

  Aquí hay un ejemplo de cómo explorar las fuentes. Porque su nombre,
  @f{simple.el} es el fichero que se vió primero, hace tiempo. Como eso
  ocurre alguna de las funciones en @f{simple.el} son complicadas, o al menos
  parece complicado a primera vista. La función @c{open-line}, por ejemplo,
  parece complicada.

  Se puede querer pasear a través de esta función lentamente, como nosotros
  hicimos la función @c{forward-sentence}. (Véase Sección @l{La función
  @c{forward-sentence}}.) O se puede querer salir de esta función y mirar en
  otra, tal como @c{split-line}. No se necesita leer todas las funciones. De
  acuerdo a @c{count-words-in-defun}, la función @c{split-line} contiene 102
  palabras y símbolos.

  Incluso aunque sean pocas, @c{split-line} contiene expresiones que no se
  han estudiado: @c{skip-chars-forward}, @c{indent-to}, @c{current-column} y
  @c{insert-and-inherit}.

  Considera la función @c{skip-chars-forward}. (Eso es parte de la definición
  de función para @c{back-to-indentation}, que muestra la @l(Repaso: Cómo
  escribir definiciones de funciones<>Repaso).)

  En GNU Emacs, se puede encontrar más acerca de @c{skip-chars-forward}
  escribiendo @k{C-h f} (@c{describe-function}) y el nombre de la
  función. Esto te da la documentación de función.

  Se puede ser capaz de adivinar que se hace por una función bien llamada tal
  como @c{indent-to}; o se puede buscar, también. Incidentalmente, la función
  @c{describe-function} en sí está en @f{help.el}; esta es una de estas
  largas, pero descifrables funciones. ¡Se puede buscar @c{describe-function}
  usando el comando @k{C-h f}!

  En esta instancia, desde el código es Lisp, el búffer @f{*Help*} contiene
  el nombre de la librería conteniendo las fuentes de la función. Se puede
  poner el punto a través del nombre de la librería y presiona la tecla RET,
  que está en esta situación está asociado a @c{help-follow}, y se toma
  directamente de las fuentes, en el mismo camino que @k{M-.} (@c{find-tag}).

  La definición para @c{describe-function} ilustra como personalizar las
  expresiones @c{interactive} sin usar los códigos de caracter estándar y eso
  muestra como crear un búffer temporal.

  (La función @c{indent-to} es escrita en C en vez de Emacs Lisp; eso es una
  función ‘construida’. @c{help-follow} toma su fuente como @c{find-tag},
  cuando se configura apropiadamente.)

  Se puede mirar en las fuentes de la función usando @c{find-tag}, que está
  asociado a @k{M-.}. Finalmente, se puede encontrar que el Manual de
  Referencia tiene que decir visitando el manual en Info, y escribiendo @k{i}
  (@c{Info-index}) y el nombre de la función, o buscando la función en el
  índice a una copia impresa del manual.

  Similarmente, se puede encontrar que significa por @c{insert-and-inherit}.

  Otros ficheros fuente interesantes incluyen @f{paragraphs.el},
  @f{loaddefs.el} y @f{loadup.el}. El fichero @f{paragraphs.el} incluye
  ordenar, funciones fácilmente comprendidas tan bien como las largas. El
  fichero @f{loaddefs.el} contiene muchos autoloads estándar y muchos mapas
  de teclado. Nunca se ha buscado en todo; solo en las partes. @f{loadup.el}
  es el fichero que carga las partes estándar de Emacs; eso cuenta un gran
  trato acerca de cómo Emacs está construido. (Véase Sección @"{Construyendo
  Emacs} en @e{El Manual de Referencia GNU Emacs Lisp}, para más acerca de
  construcción.)

  Como dije, se han aprendido algunas cosas; sin embargo, y de manera muy
  importante, se han tocado fuertes aspectos de la programación; no se ha
  dicho nada acerca de como ordenar la información, excepto para usar la
  función predefinida @c{sort}; no se ha dicho nada acerca de cómo almacenar
  la información, excepto para usar variables y listas; no se ha dicho nada
  acerca de como escribir programas que escriben programas. Esto son asuntos
  para otro tipo diferente de libro, un diferente tipo de aprendizaje.

  Lo que se ha hecho es aprender lo suficiente para hacer mucho trabajo
  práctico con GNU Emacs. Lo que se ha hecho es comenzar. Este es el fin del
  principio de una gran amistad.

** Apéndice A La función @c{the-the}

   Algunas veces cuando se se escribe texto, se duplican palabras––como con
   “se se” cerca del principio de esta frase. Se encuentra que lo más
   frecuente, es duplicar “el”; aquí, se llama a la función para detectar las
   palabras duplicadas, @c{the-the}.

   Como primer paso, se podrían usar las siguientes expresiones regulares
   para buscar duplicados:

   @example
     \\(\\w+[ \t\n]+\\)\\1
   @end example

   Este regexp asocia uno o más caracteres que constituyen palabras seguidas
   por uno o más espacios, tabuladores, o nuevas líneas. Sin embargo, eso no
   detecta palabras duplicadas en diferentes líneas, desde la finalización de
   la primera palabra, el fin de la línea, es diferente desde el fin de la
   segunda palabra, un espacio. (Para más información acerca de expresiones
   regulares, mira el Capitulo 12 @l{Búsquedas de Expresiones Regulares}, tan
   bien como la Seccion @"{Sintaxis de Expresiones Regulares} en @e{El Manual
   de GNU Emacs}, y la Seccion @"{Expresiones Regulares} en @e{El Manual de
   Referencia GNU Emacs Lisp}.)

   Se podrían intentar buscar caracteres duplicados pero no si el patrón
   detecta dobles tales como las dos ocurrencias de ‘th’ en ‘with the’.

   Otro posible regexp busca caracteres constituyentes de palabras seguidos
   por caracteres de no palabras constituyentes, reduplicadas. Aquí, @'{\\w+}
   asocia a una o más caracteres de palabras constituyente y @'{\\W*} asocia
   cero o más caracteres que no constituyen palabras.

   @example
     \\(\\(\\w+\\)\\W*\\)\\1
   @end example

   De nuevo, no útil.

   Aquí está el patrón que uso. No es perfecto, pero suficientemente
   bueno. @'{\\b} asocia la cadena vacía provista al principio o fin de una
   palabra; @'{[^@@ \n\t]+} asocia una o más ocurrencias de qué caracteres
   que @e{no} son un @@-signo, espacio, nueva línea, o tabulador.

   @example
     \\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
   @end example

   Uno puede escribir expresiones más complicadas, pero esta expresión es
   suficientemente buena así.

   Aquí está la función @c{the-the}, como se incluye en mi fichero
   @f{.emacs}, a lo largo de un atajo global manejable:

   @example
     (defun the-the ()
       "Busca hacia adelante para una palabra duplicada."
       (interactive)
       (message "Buscando palabras duplicadas ...")
       (push-mark)
       ;; Este regexp no es perfecto
       ;; pero es limpiamente bueno a pesar de todo:
       (if (re-search-forward
            "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
           (message "Palabra encontrada duplicada.")
         (message "Fin de búffer")))

     ;; Asocia ‘the-the’ a  C-c \
     (global-set-key "\C-c\\" 'the-the)
   @end example

   Aquí está el test del texto:

   @example
     uno dos tres cuatro cinco
     cinco seis siete
   @end example

   Se pueden sustituir las otras expresiones regulares mostradas debajo en la
   definición de función y se prueba cada una de ellas en esta lista.

** Apéndice B Manejando el anillo de la muerte

   El anillo de la muerte es una lista que es transformada dentro de un
   anillo que trabaja con la función @c{current-kill}. Los comandos @c{yank}
   y @c{yank-pop} usan la función @c{current-kill}.

   Este apéndice describe la función @c{current-kill} y los comandos @c{yank}
   y @c{yank-pop}, pero primero, considere los trabajo del kill ring.

   El anillo de la muerte @e{kill ring} tiene el tamaño máximo de sesenta
   elementos; hacer una explicación con este número máximo quedaría demasiado
   larga. En vez de eso, pensemos qué ocurre si se asígna a cuatro. Por
   favor, evalúe lo siguiente:

   @example
     (setq old-kill-ring-max kill-ring-max)
     (setq kill-ring-max 4)
   @end example

   Entonces, por favor, copie cada línea del siguiente ejemplo indentado
   dentro del anillo de la muerte @e{kill ring}. Se puede cortar cada línea
   con @k{C-k} o marcarla y copiarla con @k{M-w}.

   (En un búffer de solo lectura, tal como el búffer @f{*info*}, el comando
   kill, @k{C-k} (@c{kill-line}), no eliminará el texto, solamente lo mueve
   al anillo de la muerte @e{kill ring}. Sin embargo, el ordenador puede
   avisar con un beep. Alternativamente, para silenciar, se puede copiar la
   región de cada línea con el comando @k{M-w} (@c{kill-ring-save}). Se debe
   marcar cada línea de este comando para tener éxito, pero no importa si al
   final se posiciona en el punto o la marca).

   Por favor, invoque las llamadas en orden, de modo que los cinco elementos
   rellenen el anillo de la muerte @e{kill ring}.

   @example
     primero algo de texto
     segunda pieza de texto
     tercera línea
     cuarta línea de texto
     quinto bit de texto
   @end example

   Entonces encuentra el valor de @c{kill-ring} evaluando

   @example
     kill-ring
   @end example

   Eso es:

   @example
     ("quinto bit de texto" "cuarta línea de texto"
     "tercera línea" "segunda pieza de texto")
   @end example

   El primer elemento, @'{primero algo de texto}, fué borrado.

   Para devolver el viejo valor para el tamaño del kill ring, evalúe:

   @example
     (setq kill-ring-max old-kill-ring-max)
   @end example

*** La función @c{current-kill}

    La función @c{current-kill} cambia el elemento en el anillo de la muerte
    @e{kill ring} para el que el @c{kill-ring-yank-pointer} apunta. (También,
    la función @c{kill-new} asigna @c{kill-ring-yank-pointer} para apuntar al
    último elemento del anillo de la muerte @e{kill ring}. La función
    @c{kill-new} se usa directamente o indirectamente por @c{kill-append},
    @c{copy-region-as-kill}, @c{kill-ring-save}, @c{kill-line}, y
    @c{kill-region}.)

    La función @c{current-kill} es usada por @c{yank} y por
    @c{yank-pop}. Aquí está el código para @c{current-kill}:

    @example
      (defun current-kill (n &optional do-not-move)
      "Rota el punto de pegue por N lugares, y entonces devuelve lo cortado.
      Si N es cero, ‘interprogram-paste-function’ se asigna, y si se llama
      devuelve una cadena, entonces esta cadena se añade al frente del
      anillo de la muerte @e{kill ring} y devuelve el último corte.
      Si el argumento opcional DO-NOT-MOVE es no nulo, entonces no muevas el
      punto de pegue; solo devuelve el Nth corte hacia adelante.
         (let ((interprogram-paste (and (= n 0)
                                        interprogram-paste-function
                                        (funcall interprogram-paste-function)))))
          (if interprogram-paste
              (progn
                ;; Deshabilita el programa de la función de corte cuando se
                ;; añade el nuevo texto al anillo de la muerte @e{kill ring},
                ;; así Emacs no intenta poseer la selección
                ;; con idéntico texto.
                (let ((interprogram-cut-function nil))
                  (kill-new interprogram-paste))
                interprogram-paste)
            (or kill-ring (error "Kill ring is empty"))
            (let ((ARGth-kill-element
                   (nthcdr (mod (- n (length kill-ring-yank-pointer))
                                (length kill-ring))
                           kill-ring)))
              (or do-not-move
                  (setq kill-ring-yank-pointer ARGth-kill-element))
              (car ARGth-kill-element)))))
    @end example

    Recuerde también que la función @c{kill-new} asigna
    @c{kill-ring-yank-pointer} al último elemento del anillo de la muerte
    @e{kill ring}, que significa que todas las funciones lo llaman y asigna
    el valor de manera indirecta: @c{kill-append}, @c{copy-region-as-kill},
    @c{kill-ring-save}, @c{kill-line} y @c{kill-region}.

    Aquí está la línea en @c{kill-new}, que se explica en la @l{La función
    @c{kill-new}}.

    @example
      (setq kill-ring-yank-pointer kill-ring)
    @end example

    La función @c{current-kill} parece compleja, pero usual, eso puede ser
    comprendido tomándolo aparte pieza por pieza. Primero míralo en la forma
    esquelética:

    @example
      (defun current-kill (n &optional do-not-move)
        "Rota el punto a pegar por N lugares, y entonces devuelve el texto cortado."
        (let @V{varlist}
          @V{body}…)
    @end example

    Esta función tiene dos argumentos, uno es opcional. Hay una cadena de
    documentación. @e{No} es una función interactiva.

    El cuerpo de la definición de función es una expresión @c{let}, que por
    sí misma tiene tanto un cuerpo como una @V{varlist}.

    La expresión @c{let} declara una variable que será solo usable con las
    asociaciones de esta función. Esta variable se llama
    @c{interprogram-paste} y se copia a otro programa. No se copia con esta
    instancia de GNU Emacs. La mayoría de los sistemas de ventanas proveen
    una facilidad para pegar el interprograma. Tristemente, esta facilidad
    normalmente provee solo el último elemento. La mayoría de los sistemas de
    ventanas no han adoptado un anillo de muchas posibilidades, incluso
    aunque Emacs haya provisto esto durante décadas.

    La expresión @c{if} tiene dos partes, una si existe
    @c{interprogram-paste} y otra si no.

    Permítenos considerar el ‘si no’ o la parte else de la función
    @c{current-kill}. (La parte then usa la función @c{kill-new}, que ya
    hemos descrito. Véase Sección @l{La función @c{kill-new}.})

    @example
      (or kill-ring (error "El Kill ring está vacío"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element))
    @end example

    El código primero chequea si el kill ring @e{anillo de la muerte} tiene
    contenido; de otro modo señala un error.

    Note que la expresión @c{or} es muy similar para testear el tamaño con un
    @c{if}:

    @example
      (if (zerop (length kill-ring))          ; @e{parte-si}
          (error "Anillo de la muerte vacío"))       ; @e{parte-entonces}
        ;; No hay parte-resto
    @end example

    Si no hay nada en el kill ring @e{anillo de la muerte}, su tamaño debe
    ser cero y un mensaje de error se envía al usuario: @'{El kill ring está
    vacío}. La función @c{current-kill} usa una expresión @c{or} que es
    simple. Pero una expresión @c{if} recuerda lo que lleva.

    Esta expresión @c{if} usa la función @c{zerop} que devuelve cierto si el
    valor que se chequea es cero. Cuando @c{zerop} chequea cierto, la parte
    then del @c{if} se evalúa. La parte then es una lista empezando con la
    función @c{error}, que es una función que es similar a la función
    @c{message} (Vease Sección @l{message, , La Función @c{message}}) que
    imprime un mensaje de una línea en el área echo. Sin embargo, además de
    imprimir un mensaje, @c{error} también evalúa la función que está
    embebida. Esto significa que el resto de la función no será evaluada si
    el tamaño del anillo de la muerte @e{kill ring} es cero.

    Entonces la función @c{current-kill} selecciona el elemento a
    devolver. La selección depende del número de lugares que @c{current-kill}
    rota y donde @c{kill-ring-yank-pointer} apunta.

    Lo siguiente, si el argumento @c{do-not-move} opcional es verdadero o el
    actual valor de @c{kill-ring-yank-pointer} se establece al punto de la
    lista. Finalmente, otra expresión devuelve el primer elemento de la lista
    incluso si el argumento @c{do-not-move} es verdadero.

    En mi opinión, es ligeramente erróneo, al menos para humanos, usar el
    término ‘error’ como el nombre de la función @c{error}. Un término mejor
    sería ‘cancelar’. Estrictamente hablando, de acuerdo, no se puede
    apuntar, mucho menos rotar un puntero a una lista que no tiene tamaño,
    así desde el punto de vista del ordenador, la palabra ‘error’ es
    correcta. Pero un humano espera intentar algo, si solo si se encuentra el
    anillo de la muerte @e{kill ring} esté lleno o vacío. Esto es un acto de
    exploración.

    Desde el punto de vista humano, el acto de exploración y descubrimiento
    no es necesariamente un error, y por esta razón no sería etiquetado como
    tal, incluso las vocales de un ordenador. Como tal, el código en Emacs
    implica que un humano que está actuando virtuosamente, explorando su
    entorno, está teniendo un error. Esto está mal. Incluso aunque el
    ordenador tome los mismos pasos como cuando hay ‘error’, un término tal
    como ‘cancelar’ tendría una clara connotación.

    Entre otras acciones, la else-part de la expresión @c{if} asigna el valor
    de @c{kill-ring-yank-pointer} a @c{ARGth-kill-element} cuando el kill
    ring @e{anillo de la muerte} tiene alguna cosa dentro y el valor de
    @c{do-not-move} es @c{nil}.

    El código se parece a esto:

    @example
      (nthcdr (mod (- n (length kill-ring-yank-pointer))
                   (length kill-ring))
              kill-ring)))
    @end example

    Esto necesita algún examen. A menos que no se suponga mover el puntero, la
    función @c{current-kill} cambia donde @c{kill-ring-yank-pointer}
    apunta. Esto es lo que la expresión @c{(setq kill-ring-yank-pointer
    ARGth-kill-element)} hace. También, claramente, @c{ARGth-kill-element}
    está siendo asignado para ser igual a algún @Cc{cdr} del anillo de la
    muerte @e{kill ring}, usando la función @c{nthcdr} que está descrita en
    una sección temprana. (Véase Sección @l{copy-region-as-kill}.)  ¿Cómo se
    hace?

    Como se ha visto antes (Vease Sección @l{nthcdr}), la función @c{nthcdr}
    funciona repetidamente tomando el @Cc{cdr} de una lista––eso toma el
    @Cc{cdr}, del @Cc{cdr}, del @Cc{cdr}, …

    Las siguientes dos expresiones producen el mismo resultado:

    @example
      (setq kill-ring-yank-pointer (cdr kill-ring))

      (setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
    @end example

    Sin embargo, la expresión @c{nthcdr} es más complicada. Usa la función
    @c{mod} para determinar que @Cc{cdr} para seleccionar.

    (Se recordará buscar funciones propias primero, en vez de esto, tendremos
    que ir dentro del @c{mod}.)

    La función @c{mod} devuelve el valor de su primer argumento módulo el
    segundo; que es decir, eso devuelve el resto después de dividir el primer
    argumento por el segundo. El valor devuelto tiene el mismo signo que el
    segundo argumento.

    De este modo,

    @example
      (mod 12 4)
        ⇒ 0  ;; @e{porque no hay resto}
      (mod 13 4)
        ⇒ 1
    @end example

    En este caso, el primer argumento es con frecuencia pequeño que el
    segundo. Que está bien.

    @example
      (mod 0 4)
        ⇒ 0
      (mod 1 4)
        ⇒ 1
    @end example

    Se puede adivinar lo que la función @c{-} hace. Eso es como @c{+} pero
    sustrae en vez de añadir; la función @c{-} sustrae su segundo argumento
    desde el primero. También, ya se sabe que la función @c{length} hace
    (Vease Sección @l{Encuentra el tamaño de una lista: @c{length}}). Eso
    devuelve el tamaño de una lista.

    Y @c{n} es el nombre del argumento requerido a la función
    @c{current-kill}.

    Así cuando el primer argumento a @c{nthcdr} es cero, la expresión
    @c{nthcdr} devuelve la lista entera, como se puede ver evaluando lo
    siguiente:

    @example
      ;; kill-ring-yank-pointer @e{and} kill-ring @e{tener un tamaño de cuatro}
      ;; @e{and} (mod (- 0 4) 4) ⇒ 0
      (nthcdr (mod (- 0 4) 4)
              '("cuarta línea de texto"
                "tercera línea"
                "segunda pieza de texto"
                "primero algo de texto"))
    @end example

    Cuando el primer argumento a la función @c{current-kill} es uno, la
    expresión @c{nthcdr} devuelve la lista sin su primer elemento.

    @example
      (nthcdr (mod (- 1 4) 4)
              '("cuarta línea de texto"
                "tercera línea"
                "segunda pieza de texto"
                "primero algo de texto"))
    @end example

    Incidentalmente, tanto @c{kill-ring} y @c{kill-ring-yank-pointer} son
    @:{variables globales}. Esto significa que cualquier expresión en Emacs
    Lisp puede acceder a ellas. Ellas no son como las variables locales
    asignadas por @c{let} o como los símbolos en una lista de argumentos. Las
    variables locales pueden solo ser accedidas con el @c{let} que los define
    o la función que los especifica en una lista de argumentos (y con
    expresiones llamadas por ellos).

    @ignore
      @c texi2dvi fails when the name of the section is within ifnottex ...
      (Véase Sección @l{Prevent confusion, , @c{let} Prevents Confusion}, and
      @l{defun, , The @c{defun} Special Form}.)
    @end ignore

*** @c{pegar}

    Después de aprender acerca de @c{current-kill}, el código para la función
    @c{yank} es casi fácil.

    La función @c{yank} no usa la variable @c{kill-ring-yank-pointer}
    directamente. Eso llama a @c{insert-for-yank} que llama a @c{current-kill}
    que asigna la variable @c{kill-ring-yank-pointer}.

    El código se parece a esto:

    @example
      (defun yank (&optional arg)
        "Reinserta (\"pega\") el último logro del texto cortado.
      Más precisamente, reinserta el texto cortado más recientemente.
      Pon el punto al final, y asigna la marca al principio.
      Solo con \\[universal-argument] como argumento, lo mismo pero pon el
      punto al principio (y la marca al final). Con el argumento N, reinserta
      el N más recientemente cortado.
      Cuando este comando inserta texto cortado dentro del búffer, eso
      honra a ‘yank-excluded-properties’ y ‘yank-handler’ como se describe
      la cadena de documentación para ‘insert-for-yank-1’, que se ve.
      Ver también el comando \\[yank-pop]."
        (interactive "*P")
        (setq yank-window-start (window-start))
        ;; Si no tenemos todo el camino a través, crea last-command que
        ;; indique esto para el siguiente comando.
        (setq this-command t)
        (push-mark (point))
        (insert-for-yank (current-kill (cond
                                        ((listp arg) 0)
                                        ((eq arg '-) -2)
                                        (t (1- arg)))))
        (if (consp arg)
            ;; Esto es como like exchange-point-and-mark,
            ;;     pero no activa la marca.
            ;; Es limpio evitar la activación, incluso aunque el comando
            ;; loop would desactivaría la marca porque se
            ;; insertara el texto.
            (goto-char (prog1 (mark t)
                         (set-marker (mark-marker) (point) (current-buffer)))))
        ;; Si tenemos todo el camino, haz que this-command lo indique.
        (if (eq this-command t)
            (setq this-command 'yank))
        nil)
    @end example

    La expresión clave es @c{insert-for-yank}, que inserta la cadena devuelta
    por @c{current-kill}, pero elimina algo de propiedades de texto desde eso.

    Sin embargo, antes de tener esta expresión, la función asigna el valor de
    @c{yank-window-start} a la posición devuelta por la expresión
    @c{(window-start)}, la posición que muestra lo que actualmente empieza. La
    función @c{yank} también asigna @c{this-command} y empuja la marca.

    Después de pegar el elemento apropiado, si el argumento opcional es un
    @Cc{cons} en vez de un número o nada, se pone el punto al principio del
    texto pegado y se marca al final.

    (La función @c{prog1} es como @c{progn} pero devuelve el valor de su
    primer argumento en vez del valor de su último argumento. Su primer
    argumento fuerza devolver la marca del búffer como un entero. Se puede ver
    la documentación para estas funciones emplazando el punto a través de
    ellas en este búffer y entonces escribiendo @k{C-h f}
    (@c{describe-function}) seguido por un @k{RET}; por defecto es la
    función.)

    La última parte de la función cuenta que hacer cuando eso sucede.

*** @c{yank-pop}

    Después de comprender @c{yank} y @c{current-kill}, se conoce como enfocar
    la función @c{yank-pop}. Dejando fuera la documentación para guardar el
    espacio, se parece a esto:

    @example
      (defun yank-pop (&optional arg)
        "…"
        (interactive "*p")
        (if (not (eq last-command 'yank))
            (error "El comando previo no fué un corte"))
        (setq this-command 'yank)
        (unless arg (setq arg 1))
        (let ((inhibit-read-only t)
              (before (< (point) (mark t))))
          (if before
              (funcall (or yank-undo-function 'delete-region) (point) (mark t))
            (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
          (setq yank-undo-function nil)
          (set-marker (mark-marker) (point) (current-buffer))
          (insert-for-yank (current-kill arg))
          ;; Asigna la ventana a volver donde estaba el comando yank,
          ;; si es posible
          (set-window-start (selected-window) yank-window-start t)
          (if before
              ;; Esto es como exchange-point-and-mark,
              ;; pero no activa la marca.
              ;; Es limpio evitar la activación, incluso aunque el comando
              ;; desactivase la marca porque se insertara el texto.
              (goto-char (prog1 (mark t)
                           (set-marker (mark-marker)
                                       (point)
                                       (current-buffer))))))
        nil)
    @end example

    La función es interactive con una pequeña @'{p} así el argumento prefijo
    es procesado y pasado a la función. El comando puede solo ser usado
    después del yank previo; de otro modo un mensaje de error se envía. Este
    chequeo usa la variable @c{last-command} que se asigna por @c{yank} y
    discutida de algún modo. (Véase Sección @l{copy-region-as-kill}.)

    La cláusula @c{let} asigna la variable @c{before} a cierto o falso
    dependiendo de si el punto está antes o después de la marca y entonce la
    región entre punto y marca se borra. Esta es la región que fué insertada
    por el yank previo y eso es este texto que será reemplazado.

    @c{funcall} llama a su primer argumento como una función, pasando los
    argumentos que permanecen. El primer argumento es el que la expresión
    @c{or} devuelve. Los dos argumentos que permanecen son las posiciones de
    punto y marca asignadas por el comando @c{yank} precedente.

    Hay más, pero esta es la parte más dura.

*** El fichero @f{ring.el}

    De manera interesante, GNU Emacs posee un fichero llamado @f{ring.el} que
    provee muchas de las funcionalidades que ahora se discuten. Pero las
    funciones tales como @c{kill-ring-yank-pointer} no usan esta librería,
    posiblemente porque fueron escritas pronto.

** Apéndice C @t(Un grafo con ejes etiquetados)

   Los ejes impresos ayudan a comprender un grafo. Para crear escalas. En un
   capítulo anterior (Vease Sección @l{Leyendo un grafo, , Leyendo un
   grafo}), se escribió el código para imprimir el cuerpo de un grafo. Aquí
   se escribe el código para imprimir y etiquetar ejes horizontales y
   verticales, a lo largo del cuerpo en sí.

   Puesto que las inserciones rellenan un búffer a la derecha y debajo del
   punto, el nuevo grafo imprime la función que primero imprimiría el eje
   vertical Y, después el cuerpo del grafo, y finalmente el eje horizontal
   X. Esta secuencia nos da los contenidos de la función:

   1. Configura código.

   2. Imprime el eje Y.

   3. Imprime el cuerpo del grafo.


   4. Imprime el eje X.


   Aquí hay un ejemplo de como se ve un grafo finalizado:

   @example
     0 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
   @end example

   En este grafo, en ambos ejes vertical y horizontal se etiquetan con
   números. Sin embargo, en algunos grafos, el eje horizontal es tiempo y
   estaría mejor etiquetarlo con meses, así:

   @example
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
       Enero Junio Enero
   @end example

   Dentro, con un pequeño pensamiento, se puede fácilmente venir con una
   variedad de esquemas de etiquetado verticales y horizontales. Nuestra
   tarea podría llegar a ser complicada. Pero las complicaciones generan
   confusión. En vez de permitir esto, es mejor elegir un simple esquema de
   etiquetado para nuestro primer esfuerzo, y modificarlo o reemplazarlo
   después.

   Estas consideraciones sugieren el siguiente outline para la función
   @c{print-graph}:

   @example
     (defun print-graph (numbers-list)
       "@V{documentation}…"
       (let ((height  …
             …))
         (print-Y-axis height … )
         (graph-body-print numbers-list)
         (print-X-axis … )))
   @end example

   Nosotros podemos trabajar en cada parte de la definición de función
   @c{print-graph}.

*** La varlist @c{print-graph}

    Para escribir la función @c{print-graph}, la primera tarea es escribir la
    varlist en la expresión @c{let}. (Nosotros dejaremos por ahora cualquier
    pensamiento acerca de hacer la función interactive o acerca de los
    contenidos de su cadena de documentación.)

    La varlist asignaría varios valores. Claramente, la etiqueta superior del
    eje vertical debe ser al menos la altura del grafo, que significa que
    debe obtener esta información aquí. Note que la función
    @c{print-graph-body} también requiere esta información. No hay razón para
    calcular la altura del grafo en dos lugares diferentes, así cambiaría
    @c{print-graph-body} desde el camino que definimos pronto para tomar
    ventaja del cálculo.

    De manera similar, tanto la función para imprimir la etiqueta del eje X y
    la función @c{print-graph-body} se necesita aprender el valor del ancho
    de cada símbolo. Se puede desarrollar el cálculo aquí y cambiar la
    definición para @c{print-graph-body} desde el camino que se definió en el
    capítulo previo.

    El tamaño de la etiqueta para el eje horizontal debe ser al menos tan
    largo como el grafo. Sin embargo, esta información es usada solo en la
    función que imprime el eje horizontal, así no necesita calcularse aquí.

    Estos pensamientos nos llevan directamente a la siguiente forma para la
    varlist en el @c{let} para @c{print-graph}:

    @example
      (let ((height (apply 'max numbers-list)) ; @e{Primera versión.}
            (symbol-width (length graph-blank)))
    @end example

    Como se verá, esta expresión no es bastante correcta.

*** La función @c{print-Y-axis}

    El trabajo de la función @c{print-Y-axis} es imprimir una etiqueta para el
    eje vertical que se parece a esto:

    @example
          10 -




           5 -



           1 -
    @end example

    La función se pasaría a lo alto del grafo, y así construyen e insertan los
    números y marcas apropiados.

    Es suficientemente fácil ver en la figura que la etiqueta del eje Y pero
    se puede decir en palabras, y entonces escribir una definición de función
    para hacer el trabajo es otra materia. No es bastante verdad decir que se
    quiere un número y un tic cada cinco líneas: solo hay tres líneas entre el
    @'{1} y el @'{5} (líneas 2, 3 y 4), pero cuatro líneas entre el @'{5} y el
    @'{10} (líneas 6, 7, 8 y 9). Es mejor decir que se quiere un número y un
    tic en la quinta línea desde abajo a cada línea que es un múltiplo de
    cinco.

    La siguiente cuestión es a que altura se etiquetaría. Supón que la máxima
    altura de la columna mayor del grafo es siete. La etiqueta superior en el
    eje Y sería @'{5 -}, ¿y el grafo se pegaría debajo de la etiqueta?, ¿o la
    etiqueta superior sería @'{7 -}, y marcar la vertical del grafo? ¿o sería
    la etiqueta superior @c{10 -}, que es múltiplo de cinco, y es superior al
    valor más alto del grafo?

    La última forma es preferida. La mayoría de los grafos son rectángulos
    cuyos lados son un número integral de pasos a lo largo––5, 10, 15, y así
    para un paso a distancia de cinco. Pero tan pronto se decide usar un paso
    alto para el eje vertical, se descubre que la expresión simple en la
    varlist para la altura de la computación es errónea. La expresión es
    @c{(apply 'max numbers-list)}. Esto devuelve la altura precisa, no la
    altura máxima más de lo que es necesario para redondear el múltiplo de
    cinco. Una expresión más compleja es requerida.

    Como es normal en casos como este, un problema complejo llega a ser simple
    si está dividido en varios problemas pequeños.

    Primero, considere el caso cuando el valor superior del grafo es un
    múltiplo integral de cinco––cuando eso es 5, 10, 15, o algún múltiplo de
    cinco. Se puede usar este valor como la altura del eje Y.

    Un camino simple y limpio para determinar si un número es múltiplo de
    cinco se divide por cinco y mira si la división devuelve resto. Si no hay
    resto, el número es un múltiplo de cinco. De este modo, siete dividido
    tiene un resto de dos, y siete no es un entero múltiplo de cinco. Dicho de
    otra manera, recordando la escuela, cinco entre siete es uno y me llevo
    dos. Sin embargo, diez entre dos, no tiene resto: diez es un múltiplo
    entero de cinco.

**** Viaje lateral: Calcula un resto

     En Lisp, la función para calcular un resto es @c{%}. La función devuelve
     el resto de su primer argumento dividido por su segundo argumento. Como
     ocurre, @c{%} es una función en Emacs Lisp que no se puede implementar
     usando @c{apropos}: no se puede encontrar nada si se escribe @k{M-x
     apropos @k{RET} resto @k{RET}}. El único camino para aprender la
     existencia de @c{%} es leer acerca de eso en un libro tal como este o en
     las fuentes de Emacs Lisp.

     Se puede probar la función @c{%} evaluando las siguientes dos
     expresiones:

     @example
       (% 7 5)

       (% 10 5)
     @end example

     La primera expresión devuelve 2 y la segunda expresión devuelve 0.

     Para chequear si el valor devuelto es cero o algún otro número, se puede
     usar la función @c{zerop}. Esta función devuelve @c{t} si su argumento
     debe ser un número, es cero.

     @example
       (zerop (% 7 5))
            ⇒ nil

       (zerop (% 10 5))
            ⇒ t
     @end example

     De este modo, la siguiente expresión devolverá @c{t} si la altura del
     grafo es divisible por cinco:

     @example
       (zerop (% height 5))
     @end example

     (El valor de @c{height}, de acuerdo, puede ser encontrado desde
     @c{(apply 'max numbers-list)}.)

     Por otro lado, si el valor de @c{height} no es un múltiplo de cinco,
     nosotros queremos resetear el valor al siguiente múltiplo de cinco. Esta
     es la aritmética sencilla usando funciones con las que ya se está
     familiarizado. Primero, se divide el valor de @c{height} por cinco para
     determinar cuantas veces cinco va dentro del número. De este modo, cinco
     va dentro doce veces. Si se añade uno a este cociente y se multiplica
     por cinco, obtendremos el valor del siguiente múltiplo de cinco que es
     más largo que el mayor. Cinco va dentro de doce dos veces. Añade uno a
     dos, y multiplica por cinco; el resultado es quince, que es el siguiente
     múltiplo de cinco que es mayor de doce. La expresión Lisp para esto es:

     @example
       (* (1+ (/ height 5)) 5)
     @end example

     Por ejemplo, si se evalúa lo siguiente, el resultado es 15:

     @example
       (* (1+ (/ 12 5)) 5)
     @end example

     Todo a través de esta discusión, se ha estado usando ‘cinco’ como el
     valor para las etiquetas espaciadas en el eje Y; pero se puede querer
     usar algún otro valor. Generalmente, reemplazaría ‘cinco’ con una
     variable a la que poder asignar un valor. El mejor nombre que puedo
     pensar para esta variable es @c{Y-axis-label-spacing}.

     Usando este término, y una expresión @c{if}, se produce lo siguiente:

     @example
       (if (zerop (% height Y-axis-label-spacing))
           height
         ;; @e{else}
         (* (1+ (/ height Y-axis-label-spacing))
            Y-axis-label-spacing))
     @end example

     Esta expresión devuelve el valor de @c{height} en sí si la altura es
     incluso un múltiplo del valor del @c{Y-axis-label-spacing} o lo demás
     computa y devuelve un valor de @c{height} que es igual al siguiente
     múltiplo mayor del valor del @c{Y-axis-label-spacing}.

     Se puede ahora incluir esta expresión en la expresión @c{let} de la
     función @c{print-graph} (después de la primera configuración del valor
     de @c{Y-axis-label-spacing}): @vindex Y-axis-label-spacing

     @example
       (defvar Y-axis-label-spacing 5
         "Número de líneas desde una etiqueta del eje Y al siguiente.")

       …
       (let* ((height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; @e{else}
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (symbol-width (length graph-blank))))
       …
     @end example

     (Note que el uso de la función @c{let*}: el valor inicial de la altura
     es calculada una vez por la expresión @c{(apply 'max numbers-list)} y
     entonces el valor resultado de @c{height} es usado para computar su
     valor final. Véase Sección @l{La expresión @c{let*}}, para más acerca de
     @c{let*}.)

**** Construye un elemento del eje Y

     Cuando se imprime el eje vertical, se quieren insertar cadenas tales
     como @'{5 -} y @'{10 - } cada cinco líneas. Más allá, se quieren los
     números agitados para alinear, así pocos números deben ser acuñados con
     espacios de guía. Si alguna de las cadenas usan dos dígitos, las cadenas
     con un simple dígito deben incluir una guía en blanco antes del número.

     Para figurarse el tamaño del número, se usa la función @c{length}. Pero
     la función @c{length} funciona solo con una cadena, no con un
     número. Así el número tiene que ser convertido desde un número a una
     cadena. Esto se hace con la función @c{number-to-string}. Por ejemplo,

     @example
       (length (number-to-string 35))
            ⇒ 2

       (length (number-to-string 100))
            ⇒ 3
     @end example

     (@c{number-to-string} se llama @c{int-to-string}; se verá este nombre
     alternativo en varias fuentes.)

     Además, en cada etiqueta, cada número es seguido por una cadena tal como
     @'{ - }, que llamará al marcador @c{Y-axis-tic}. Esta variable está
     definida con @c{defvar}:

     @example
       (defvar Y-axis-tic " - "
          "La Cadena que sigue el número en una etiqueta del eje Y.")
     @end example

     El tamaño de la etiqueta Y es la suma del tamaño del eje Y y el tamaño
     del número del alto del grafo.

     @example
       (length (concat (number-to-string height) Y-axis-tic)))
     @end example

     Este valor será calculado por la función @c{print-graph} en su varlist
     como @c{full-Y-label-width} y se pasa dentro. (Note que no se pensaba en
     incluir esto en el varlist cuando se propuso.)

     Para crear un eje vertical completo, una marca de tic es concatenada con
     un número; y los dos juntos pueden ser precedidos por uno o más espacios
     dependiendo de cómo de largo es el número. La etiqueta consiste de tres
     partes: los espacios que se lideran (opcional), el número, y la marca
     tic. La función se pasa al valor del número para la fila específica, y
     el valor del ancho de la línea de arriba, que es calculada (solo una
     vez) por @c{print-graph}.

     @example
       (defun Y-axis-element (number full-Y-label-width)
         "Construye una etiqueta NUMERADA
       Un elemento numerado se parece a esto ‘ 5 - ’,
       y está tan acuñado como se necesita así todo se
       alinea con el elemento para el número mayor."
         (let* ((leading-spaces
                (- full-Y-label-width
                   (length
                    (concat (number-to-string number)
                            Y-axis-tic)))))
           (concat
            (make-string leading-spaces ? )
            (number-to-string number)
            Y-axis-tic)))
     @end example

     La función @c{Y-axis-element} concatena junto los espacios que se
     lideran si cualquiera; el número, como una cadena; y la marca tic.

     Para imaginarnos cuantos espacios guía la etiqueta necesita, la función
     sustrae el tamaño de la etiqueta––el tamaño del número más el tamaño de
     la marca tic––desde el ancho de la etiqueta deseada.

     Los espacios en blanco se insertan usando la función
     @c{make-string}. Esta función tiene dos argumentos: lo primero cuenta
     como de larga será a cadena y el segundo es un símbolo para el caracter
     a insertar, en un formato espcial. El formato es una marca de pregunta
     seguida por un espacio en blanco, como este, @'{?}. Véase Sección
     @"{Tipo de Caracter} en @e{El Manual de Referencia Emacs Lisp}, para una
     descripción de la sintaxis para caracteres. (De acuerdo, se podría
     querer reemplazar el espacio en blanco por algún otro caracter …. Tu
     sabes qué hacer.)

     La función @c{number-to-string} es usada en la expresión de
     concatenación, para convertir el número a una cadena que es concatenada
     con los espacios que se lideran y la marca de tic.

**** Crea un eje de la columna Y

     Las funciones precedentes proporcionan todas las herramientas necesarias
     para construir una función que genera una lista de cadenas enumeradas y
     en blanco para inserta como la etiqueta para el eje vertical:

     @example
       (defun Y-axis-column (height width-of-label)
         "Construye la lista de ejes Y etiquetadas y cadenas en blanco.
       Para height @e{la altura} de la línea de debajo y width-of-label."
         (let (Y-axis)
           (while (> height 1)
             (if (zerop (% height Y-axis-label-spacing))
                 ;; @e{Insertar etiqueta.}
                 (setq Y-axis
                       (cons
                        (Y-axis-element height width-of-label)
                        Y-axis))
               ;; @e{Else, insertar blancos.}
               (setq Y-axis
                     (cons
                      (make-string width-of-label ? )
                      Y-axis)))
             (setq height (1- height)))
           ;; @e{Insertar la línea base.}
           (setq Y-axis
                 (cons (Y-axis-element 1 width-of-label) Y-axis))
           (nreverse Y-axis)))
     @end example

     En esta función, nosotros empezamos con el valor de @c{height} y
     repetitivamente sustrae uno desde su valor. Después de cada sustración,
     se chequea para ver si el valor es una integral múltiple del
     @c{Y-axis-label-spacing}. Si eso es, se construye una etiqueta numerada
     usando la función @c{Y-axis-element}; si no, se construye una etiqueta
     blanca usando la función @c{make-string}. La línea base consiste del
     número uno seguido por una marca tic.

**** La versión no demasiado final de @c{print-Y-axis}

     La lista construida por la función @c{Y-axis-column} está pasada a la
     función @c{print-Y-axis}, que inserta la lista como una columna.

     @example
       (defun print-Y-axis (height full-Y-label-width)
         "Inserta el eje Y usando HEIGHT y FULL-Y-LABEL-WIDTH.
       La altura debe ser la máxima altura del grafo.
       El ancho completo es el ancho del mayor elemento de la
       etiqueta"
       ;; El valor del alto y full-Y-label-width
       ;; son pasadas por ‘print-graph’.
         (let ((start (point)))
           (insert-rectangle
            (Y-axis-column height full-Y-label-width))
           ;; @e{Posiciona el punto listo para inserta el grafo.}
           (goto-char start)
           ;; @e{Mueve el punto hacia adelante por valor de} full-Y-label-width
           (forward-char full-Y-label-width)))
     @end example

     El @c{print-Y-axis} usa la función @c{insert-rectangle} para inserta el
     eje Y creado por la función @c{Y-axis-column}. Además, eso emplaza el
     punto en la posición correcta para imprimir el cuerpo del grafo.

     Se puede chequear @c{print-Y-axis}:

     - Instalar

       @example
         Y-axis-label-spacing
         Y-axis-tic
         Y-axis-element
         Y-axis-column
         print-Y-axis
       @end example

     - Copia la siguiente expresión:

       @example
         (print-Y-axis 12 5)
       @end example

     - Cambia al búffer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M::} (@c{eval-expression}).

     - Pega la expresión @c{graph-body-print} dentro del minibúffer con
       @k{C-y} (@c{yank}).


     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá etiquetas verticalmente, el primero siendo @'{10 -
     }. (La función @c{print-graph} pasará el valor de
     @c{height-of-top-line}, que en este caso finalizará en 15, por esto lo
     que se obtiene podría aparecer como un error.)

*** La función @c{print-X-axis}

    Las etiquetas del eje X son como las etiquetas del eje Y, excepto que los
    ticks son un línea debajo de los números. Las etiquetas se parece como
    esto:

    @example
      |   |    |    |
      1   5   10   15
    @end example

    El primer tic está bajo la primera columna del grafo y está precedido por
    varios espacios en blanco. Estos espacios proporcionan la habitación en
    filas de debajo para las etiquetas del eje Y. El segundo, tercer, cuarto,
    y subsiguientes ticks son todos espaciados igualmente, de acuerdo al valor
    de @c{X-axis-label-spacing}.

    La segunda fila del eje X consiste de números, precedidos por varios
    espacios en blanco y también separado de acuerdo al valor de la variable
    @c{X-axis-label-spacing}.

    El valor de la variable @c{X-axis-label-spacing} sería medido en unidades
    de @c{symbol-width}, puesto que se puede querer cambiar el ancho de los
    símbolos que estás usando para imprimir el cuerpo del grafo sin cambiar
    los caminos del grafo que está etiquetado.

    La función @c{print-X-axis} está construida más o menos del mismo modo
    como que la función @c{print-Y-axis} excepto que tiene dos líneas: la
    línea de marcas tic y los números. Nosotros escribiremos una función
    separado a imprimir cada línea y entonces combinarlo con la función
    @c{print-X-axis}.

    Esto es un proceso de tres pasos:

    1. Escribe una función para imprimir el eje X marca tic,
       @c{print-X-axis-tic-line}.

    2. Escribe una función imprime los números X,
       @c{print-X-axis-numbered-line}.

    3. Escribe una función para imprimir ambas líneas, la función
       @c{print-X-axis}, usando @c{print-X-axis-tic-line} y
       @c{print-X-axis-numbered-line}.

**** Eje X marca tic

     La primera función imprimiría las marcas de tic del eje X. Se deben
     especificar las marcas en sí y su espacio:

     @example
       (defvar X-axis-label-spacing
         (if (boundp 'graph-blank)
             (* 5 (length graph-blank)) 5)
         "Números de unidades desde un eje X al siguiente.")
     @end example

     (Note que el valor de @c{graph-blank} est'a asignado por otro
     @c{defvar}. El predicado @c{boundp} chequea si ya ha sido asignado;
     @c{boundp} devuelve @c{nil} si no lo tiene. Si @c{graph-blank} fuera
     disociado y no usara esta construcción condicional, en un GNU Emacs
     reciente, se introduciría el depurador y mirará un mensaje de error
     diciendo @'{Debugger entered--Lisp error: (void-variable graph-blank)}

     Aquí está el @c{defvar} para @c{X-axis-tic-symbol}:

     @example
       (defvar X-axis-tic-symbol "|"
         "Cadena para insertar para apuntar a una columna en el eje X.")
     @end example

     El objetivo es crear una línea que se parece a esto:

     @example
       |   |    |    |
     @end example

     El primer tic es indentado así que está bajo la primera columna, que es
     indentado para proveer espacio para las etiquetas del eje Y.

     Un elemento tic consiste en espacios en blanco que se extienden desde un
     tic al siguiente más un símbolo tic. El número de espacios en blanco se
     determinan por el ancho del símbolo tic y el @c{X-axis-label-spacing}.

     El código se parece a esto:

     @example
       ;;; X-axis-tic-element
       …
       (concat
        (make-string
         ;; @e{Crea una cadena de blancos.}
         (-  (* symbol-width X-axis-label-spacing)
             (length X-axis-tic-symbol))
         ? )
        ;; @e{Concatena blancos con símbolos.}
        X-axis-tic-symbol)
       …
     @end example

     Lo siguiente, determina cuantos espacios en blanco son necesarios para
     indentar la primera marca tic a la primera del grafo. Esto usa el valor
     de @c{full-Y-label-width} pasaba por la función @c{print-graph}.

     El código para crear @c{X-axis-leading-spaces} se parece a esto:

     @example
       ;; X-axis-leading-spaces
       …
       (make-string full-Y-label-width ? )
       …
     @end example

     También necesita determinar el tamaño del eje horizontal, que es el
     tamaño de la lista de números, y el número de ticks en el eje
     horizontal:

     @example
       ;; X-length
       …
       (length numbers-list)

       ;; tic-width
       …
       (* symbol-width X-axis-label-spacing)

       ;; number-of-X-ticks
       (if (zerop (% (X-length tic-width)))
           (/ (X-length tic-width))
         (1+ (/ (X-length tic-width))))
     @end example

     Todo esto lidera directamente a la función para imprimir el eje X:

     @findex print-X-axis-tic-line
     @example
       (defun print-X-axis-tic-line
         (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
         "Imprime ticks para el eje X."
           (insert X-axis-leading-spaces)
           (insert X-axis-tic-symbol)  ; @e{En la primera columna.}
           ;; @e{Inserta el segundo tic en el lugar adecuado.}
           (insert (concat
                    (make-string
                     (-  (* symbol-width X-axis-label-spacing)
                         ;; @e{Inserta el espacio en blanco al segundo símbolo tic.}
                         (* 2 (length X-axis-tic-symbol)))
                     ? )
                    X-axis-tic-symbol))
           ;; @e{Inserta los ticks que permanecen.}
           (while (> number-of-X-tics 1)
             (insert X-axis-tic-element)
             (setq number-of-X-tics (1- number-of-X-tics))))
     @end example

     La línea de números es igualmente simple:

     Primero, creamos un elemento numerado con espacios en blanco antes de
     cada número:

     @example
       (defun X-axis-element (number)
         "Construye un elemento del eje X numerado."
         (let ((leading-spaces
                (-  (* symbol-width X-axis-label-spacing)
                    (length (number-to-string number)))))
           (concat (make-string leading-spaces ? )
                   (number-to-string number))))
     @end example

     Lo siguiente, se crea la función para imprimir la línea numerada,
     empezando con el número “1” para la primera columna:

     @example
       (defun print-X-axis-numbered-line
         (number-of-X-tics X-axis-leading-spaces)
         "Imprime la líneas de números del eje X"
         (let ((number X-axis-label-spacing))
           (insert X-axis-leading-spaces)
           (insert "1")
           (insert (concat
                    (make-string
                     ;; @e{Inserta espacios en blanco al siguiente número.}
                     (-  (* symbol-width X-axis-label-spacing) 2)
                     ? )
                    (number-to-string number)))
           ;; @e{Insertar números.}
           (setq number (+ number X-axis-label-spacing))
           (while (> number-of-X-tics 1)
             (insert (X-axis-element number))
             (setq number (+ number X-axis-label-spacing))
             (setq number-of-X-tics (1- number-of-X-tics)))))
     @end example

     Finalmente, se necesita escribir lo que @c{print-X-axis} que usa
     @c{print-X-axis-tic-line} y @c{print-X-axis-numbered-line}.

     La función debe determinar los valores locales de las variables usadas
     por @c{print-X-axis-tic-line} y @c{print-X-axis-numbered-line}, y
     entonces eso debe llamarlas. También, debe imprimir el retorno de carro
     que separe las dos líneas.

     La función consiste de una varlist que especifica cinco variables
     locales, y llama cada una de las dos líneas imprimiendo funciones:

     @example
       (defun print-X-axis (numbers-list)
         "Imprime el eje X etique al tamaño de NUMBERS-LIST."
         (let* ((leading-spaces
                 (make-string full-Y-label-width ? ))
              ;; symbol-width @e{se provee por} graph-body-print
              (tic-width (* symbol-width X-axis-label-spacing))
              (X-length (length numbers-list))
              (X-tic
               (concat
                (make-string
                 ;; @e{Crea una cadena de espacios en blanco.}
                 (-  (* symbol-width X-axis-label-spacing)
                     (length X-axis-tic-symbol))
                 ? )
                ;; @e{Concatena espacio en blanco con símbolos
                tic.}
                X-axis-tic-symbol))
              (tic-number
               (if (zerop (% X-length tic-width))
                   (/ X-length tic-width)
                 (1+ (/ X-length tic-width)))))
           (print-X-axis-tic-line tic-number leading-spaces X-tic)
           (insert "\n")
           (print-X-axis-numbered-line tic-number leading-spaces)))
     @end example

     Se puede testear @c{print-X-axis}:

     - Instale @c{X-axis-tic-symbol}, @c{X-axis-label-spacing},
       @c{print-X-axis-tic-line}, tanto como @c{X-axis-element},
       @c{print-X-axis-numbered-line}, y @c{print-X-axis}.

     - Copia la siguiente expresión:

       @example
         (progn
          (let ((full-Y-label-width 5)
                (symbol-width 1))
            (print-X-axis
             '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
       @end example

     - Cambia al búffer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M::} (@c{eval-expression}).

     - Pegue la expresión de test dentro del minibuffer con @k{C-y}
       (@c{yank}).


     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá el eje horizontal así

     @example
       |   |    |    |    |
       1   5   10   15   20
     @end example

** Imprimiendo el grafo completo

   Ahora estamos listos para imprimir el grafo completo.

   La función para imprimir el grafo con las etiquetas apropiadas sigue el
   esquema que creamos antes (Vease Sección @l{Un Grafo con Ejes
   Etiquetados}), pero con adiciones.

   Aquí está el esquema:

   @example
     (defun print-graph (numbers-list)
       "@V{documentation}…"
       (let ((height  …
             …))
         (print-Y-axis height … )
         (graph-body-print numbers-list)
         (print-X-axis … )))
   @end example

   La versión final es diferente desde que se planea en dos caminos: primero,
   contiene los valores adicionales calculadas una vez que en la varlist;
   segundo, eso trae una opción para específicar las etiquetas se incrementa
   la fila. Esta última funcionalidad cambia a ser esencial; de otro modo, un
   grafo puede tener más filas que ajustarse en una muestra o en una hoja de
   papel.

   Esta nueva funcionalidad requiere un cambio a la función
   @c{Y-axis-column}, para añadir @c{vertical-step} para eso. Esta función es
   parece a esto:

   @example
     ;;; @e{Versión Final.}
     (defun Y-axis-column
       (height width-of-label &optional vertical-step)
       "Construye una lista de etiquetas para el eje Y.
     HEIGHT es la máxima altura del grafo.
     WIDTH-OF-LABEL es el máximo ancho de la etiqueta.
     VERTICAL-STEP, una opción, es un entero positivo
     que especifica cuanto una etiqueta de eje Y incrementa
     cada línea. Por ejemplo, un paso de 5
     significa que cada línea es cinco unidades
     del grafo."
       (let (Y-axis
             (number-per-line (or vertical-step 1)))
         (while (> height 1)
           (if (zerop (% height Y-axis-label-spacing))
               ;; @e{Inserta etiqueta.}
               (setq Y-axis
                     (cons
                      (Y-axis-element
                       (* height number-per-line)
                       width-of-label)
                      Y-axis))
             ;; @e{Else, inserta espacios en blanco.}
             (setq Y-axis
                   (cons
                    (make-string width-of-label ? )
                    Y-axis)))
           (setq height (1- height)))
         ;; @e{Inserta línea base.}
         (setq Y-axis (cons (Y-axis-element
                             (or vertical-step 1)
                             width-of-label)
                            Y-axis))
         (nreverse Y-axis)))
   @end example

   Los valores para la máxima altura del grafo y el ancho de un símbolo se
   computan por @c{print-graph} es su expresión @c{let}; así
   @c{graph-body-print} debe ser cambiado para aceptarlos.

   @example
     ;;; @e{Versión Final.}
     (defun graph-body-print (numbers-list height symbol-width)
       "Imprime una gráfica de barras del NUMBERS-LIST.
     El numbers-list consiste en los valores del eje Y.
     HEIGHT es la máxisma altura del grafo.
     SYMBOL-WIDTH es el número de cada columna."
       (let (from-position)
         (while numbers-list
           (setq from-position (point))
           (insert-rectangle
            (column-of-graph height (car numbers-list)))
           (goto-char from-position)
           (forward-char symbol-width)
           ;; @e{Dibuja el grafo columna por columna.}
           (sit-for 0)
           (setq numbers-list (cdr numbers-list)))
         ;; @e{Posiciona el punto para las etiquetas del eje X.}
         (forward-line height)
         (insert "\n")))
   @end example

   Finalmente, el código para la función @c{print-graph}:

   @example
     ;;; @e{Versión Final.}
     (defun print-graph
       (numbers-list &optional vertical-step)
       "El gráfico de barras etiquetadas del NUMBERS-LIST.
     El numbers-list consiste en los valores de eje Y.

     Opcionalmente, VERTICAL-STEP, un entero positivo, especifica cuanto el
     eje Y incrementa cada línea. Por ejemplo, un paso de 5
     significa que cada fila es de cinco unidades.
       (let* ((symbol-width (length graph-blank))
              ;; @c{height} @e{en ambos es el número más largo}
              ;; @e{y el número con la mayoría de los digitos.}
              (height (apply 'max numbers-list))
              (height-of-top-line
               (if (zerop (% height Y-axis-label-spacing))
                   height
                 ;; @e{else}
                 (* (1+ (/ height Y-axis-label-spacing))
                    Y-axis-label-spacing)))
              (vertical-step (or vertical-step 1))
              (full-Y-label-width
               (length
                (concat
                 (number-to-string
                  (* height-of-top-line vertical-step))
                 Y-axis-tic))))

         (print-Y-axis
          height-of-top-line full-Y-label-width vertical-step)
         (graph-body-print
          numbers-list height-of-top-line symbol-width)
         (print-X-axis numbers-list)))
   @end example

**** Testeando @c{print-graph}

     Se puede chequear la función @c{print-graph} con una lista ordenada de
     números:

     - Instala las versiones finales de @c{Y-axis-column},
       @c{graph-body-print}, y @c{print-graph} (además del resto del código.)

     - Copia la siguiente expresión:

       @example
         (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
       @end example

     - Cambia al búffer @f{*scratch*} y emplaza el cursor donde se quiere el
       eje etiquetado para empezar.

     - Escribe @k{M::} (@c{eval-expression}).

     - Pegue la expresión de test dentro del minibuffer con @k{C-y}
       (@c{yank}).


     - Presiona @k{RET} para evaluar la expresión


     Emacs imprimirá un grafo que se parece a:

     @example
       10 -


                *
               **   *
        5 -   ****  *
              **** ***
            * *********
            ************
        1 - *************

            |   |    |    |
            1   5   10   15
     @end example

     Por otro lado, si se pasa a @c{print-graph} un @c{vertical-step} valor
     de 2, evaluando esta expresión:

     @example
       (print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
     @end example

     El grafo se parece a esto:

     @example
       20 -


                *
               **   *
       10 -   ****  *
              **** ***
            * *********
            ************
        2 - *************

            |   |    |    |
            1   5   10   15
     @end example

     (Una pregunta: ¿es el ‘2’ debajo del eje vertical un error o una
     funcionalidad? Si se piensa que es un error, y sería un ‘1’, (o incluso
     un ‘0’), se pueden modificar las fuentes.)

**** Creando gráficas de números de palabras y símbolos

     Ahora para el gráfico para el que todo este código fué escrito: un
     gráfico que muestra cuantas definiciones de función contienen unas pocas
     10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y
     símbolos, cuantos contienen entre 20 y 29 palabras y símbolos, y así.

     Esto es un proceso de múltiples pasos. Primero asegúrate que has cargado
     todo el requisito del código.

     Eso es una buena idea para eliminar el valor de @c{top-of-ranges} en
     caso de que has asignado a algún valor diferente. Se puede evaluar lo
     siguiente:

     @example
       (setq top-of-ranges
        '(10  20  30  40  50
          60  70  80  90 100
         110 120 130 140 150
         160 170 180 190 200
         210 220 230 240 250
         260 270 280 290 300)
     @end example

     Lo siguiente crea una lista del número de palabras y símbolos en cada
     rango.

     Evalúa lo siguiente:

     @example
       (setq list-for-graph
              (defuns-per-range
                (sort
                 (recursive-lengths-list-many-files
                  (directory-files "/usr/local/emacs/lisp"
                                   t ".+el$"))
                 '<)
                top-of-ranges))
     @end example

     En mi vieja máquina, esto lleva como una hora. Se parece a 303 ficheros
     Lisp en mi copia de Emacs version 19.23. Después de toda esta
     computación, el @c{list-for-graph} tenía este valor:

     @example
       (537 1027 955 785 594 483 349 292 224 199 166 120 116 99
       90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
     @end example

     Esto significa que mi copia de Emacs tiene 537 definiciones de funciones
     con poco menos de 10 palabras o símbolos en sí, 1027 definiciones de
     función con 10 a 19 palabras o símbolos dentro, 955 definiciones de
     función con 20 a 29 palabras o símbolos dentro, y así.

     Claramente, solo buscando esta lista se puede ver que la mayoría de
     definiciones de función contienen de diez a treinta palabras y símbolos.

     Ahora para imprimir. Nosotros @e{no} queremos imprimir un grafo que es
     de 1030 líneas de alto …. En vez de eso, imprimiría un grafo que es
     mejor que venticinco líneas de alto. Un grafo cuya altura puede ser
     mostrada en casi cualquier monitor, y fácilmente impreso en una hoja de
     papel.

     Esto significa que cada valor en @c{list-for-graph} debe ser reducido a
     un quinceavo de su valor presente.

     Aquí hay una corta función para hacer esto, usando dos funciones que no
     se han visto todavía, @c{mapcar} y @c{lambda}.

     @example
       (defun one-fiftieth (full-range)
         "Devuelve la lista, con el cincuenteavo de cada elemento."
        (mapcar '(lambda (arg) (/ arg 50)) full-range))
     @end example

**** Una expresión @c{lambda}: Anonimicidad útil

     @c{lambda} es el símbolo para una función anónima, una función sin un
     nombre. Cada vez que se use una función anónima, se necesita incluir su
     cuerpo completo.

     De este modo,

     @example
       (lambda (arg) (/ arg 50))
     @end example

     es una definición de función que dice ‘devuelve el valor resultante de
     dividir cualquier cosa que es pasada como @c{arg} por 50’.

     Pronto, por ejemplo, se tenía una función @c{multiply-by-seven}; se
     multiplica su argumento por 7. Esta función es similar, excepto que
     divide su argumento por 50; y, no tiene nombre. El equivalente anónimo
     de @c{multiply-by-seven} es:

     @example
       (lambda (number) (* 7 number))
     @end example

     (Véase Sección @l{La forma especial @c{defun}}.)

     Si queremos multiplicar 3 por 7, podemos escribir:

     @diagram
       (multiply-by-seven 3)
        \_______________/ ^
                |         |
             función  argumento
     @end diagram

     Esta expresión devuelve 21.

     De manera similar, se puede escribir:

     @diagram
       ((lambda (number) (* 7 number)) 3)
        \____________________________/ ^
                      |                |
             función anónima     argumento
     @end diagram

     Si queremos dividir 100 por 50, se puede escribir:

     @diagram
       ((lambda (arg) (/ arg 50)) 100)
        \______________________/  \_/
                    |              |
            función anónima   argumento
     @end diagram

     Esta expresión devuelve 2. El 100 es pasado para la función, que divide
     este número por 50.

     Véase Sección @"{Expresiones Lambda} en @e{El Manual de Referencia GNU
     Emacs Lisp}, para más acerca de @c{lambda}. Lisp y expresiones Lambda se
     derivan del Cálculo Lambda.

*** La función @c{mapcar}

    @c{mapcar} es una función que llama a su primer argumento con cada
    elemento de su segundo argumento. El segundo argumento debe ser una
    secuencia.

    La parte @'{map} del nombre viene de la frase matemática, ‘mapeando a
    través de un dominio’, significa hace apply a una función a cada uno de
    los elementos en un dominio. La frase matemática está basada en la
    metáfora de un superviviente paseando, un paso en un momento, a través de
    un área él está mapeando. Y @'{car}, de acuerdo, viene desde la noción
    Lisp del primero de una lista.

    Por ejemplo,

    @example
      (mapcar '1+ '(2 4 6))
           ⇒ (3 5 7)
    @end example

    La función @c{1+} añade uno a su argumento, es ejecutada en @e{each} de
    la lista, y una nueva lista es devuelta.

    En contraste con esto @c{apply}, se aplica su primer argumento a todo lo
    que permanece. (Véase Sección @l{Leyendo un grafo}, para una explicación
    de @c{apply}.)

    En la definición de @c{one-fiftieth}, el primer argumento es la función
    anónima:

    @example
      (lambda (arg) (/ arg 50))
    @end example

    y el segundo argumento es @c{full-range}, que será asociado para
    @c{list-for-graph}.

    La expresión completa se parece a esto:

    @example
      (mapcar (lambda (arg) (/ arg 50)) full-range))
    @end example

    Véase Sección @"{Mapeando Funciones} en @e{El Manual de Referencia de GNU
    Emacs Lisp}, para más acerca de @c{mapcar}.

    Usando la función @c{one-fiftieth}, se puede generar una lista en el que
    cada elemento es un cincuenteavo del tamaño del correspondiente elemento
    en @c{list-for-graph}.

    @example
      (setq fiftieth-list-for-graph
            (one-fiftieth list-for-graph))
    @end example

    La lista resultante se parece a esto:

    @example
      (10 20 19 15 11 9 6 5 4 3 3 2 2
      1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
    @end example

    Así, ¡ya estamos casi listos para imprimir!  (También se notifica la
    pérdida de información: muchos de los rangos superiores son 0, esto
    significa que menos de 50 funciones tenían muchas palabras o
    símbolos––pero no necesariamente significando que niguna tenía muchas
    palabras o símbolos.)

**** Otro error … más insidioso

     ¡Se dijo ‘casi listo para imprimir’! De acuerdo, hay un error en la
     función @c{print-graph} …. Esta tiene una opción @c{vertical-step}, pero
     no una opción @c{horizontal-step}. La escala @c{top-of-range} va desde
     10 a 300 por decenas. Pero la función @c{print-graph} imprimirá solo uno
     por uno.

     Esto es un ejemplo clásico de lo que algunos consideramos el tipo más
     insidioso de error, el error de omisión. Este no es el tipo de error que
     se puede encontrar estudiando el código, para eso no es el código; es
     una funcionalidad omitida. Tus mejores acciones son probar tu programa
     pronto y con frecuencia; e intentar poner en orden, tanto como se pueda,
     escribir código que sea fácil de comprender y fácil de cambiar. Intenta
     ser consciente, siempre y cuando se pueda, esto es siempre que tengas
     que escribir, @e{será} reescrito, si no pronto, eventualmente. Un máximo
     duro de seguir.

     Esta es la función @c{print-X-axis-numbered-line} que necesita el
     trabajo; y entonces el @c{print-X-axis} y la función @c{print-graph}
     necesita ser adaptada. No se necesita mucho para ser hecho; hay uno
     simpático: los números podrían alinearse con marcas de tic. Esto toma un
     pequeño pensamiento.

     Aquí está el @c{print-X-axis-numbered-line} corregido:

     @example
       (defun print-X-axis-numbered-line
         (number-of-X-tics X-axis-leading-spaces
          &optional horizontal-step)
         "Imprime la líneas de números X-axis"
         (let ((number X-axis-label-spacing)
               (horizontal-step (or horizontal-step 1)))
           (insert X-axis-leading-spaces)
           ;; @e{Elimina espacios extra de guía.}
           (delete-char
            (- (1-
                (length (number-to-string horizontal-step)))))
           (insert (concat
                    (make-string
                     ;; @e{Inserta espacio en blanco.}
                     (-  (* symbol-width
                            X-axis-label-spacing)
                         (1-
                          (length
                           (number-to-string horizontal-step)))
                         2)
                     ? )
                    (number-to-string
                     (* number horizontal-step))))
           ;; @e{Insertar los números que permanecen.}
           (setq number (+ number X-axis-label-spacing))
           (while (> number-of-X-tics 1)
             (insert (X-axis-element
                      (* number horizontal-step)))
             (setq number (+ number X-axis-label-spacing))
             (setq number-of-X-tics (1- number-of-X-tics)))))
     @end example

     Si se está leyendo esto en Info, se pueden ver las nuevas versiones
     @c{print-X-axis} y @c{print-graph} y los evaluarlas. Si se está leyendo
     esto en un libro impreso, se pueden ver las líneas cambiadas aquí (el
     texto completo es mucho para imprimir).

     @example
       (defun print-X-axis (numbers-list horizontal-step)
         …
           (print-X-axis-numbered-line
            tic-number leading-spaces horizontal-step))
       (defun print-graph
         (numbers-list
          &optional vertical-step horizontal-step)
         …
           (print-X-axis numbers-list horizontal-step))
     @end example

**** El gráfico impreso

     Cuando esté hecho e instalado, se puede llamar al comando
     @c{print-graph} como esto:

     @example
       (print-graph fiftieth-list-for-graph 50 10)
     @end example

     Aquí está el gráfico:

     @example
       1000 -  *
               **
               **
               **
               **
        750 -  ***
               ***
               ***
               ***
               ****
        500 - *****
              ******
              ******
              ******
              *******
        250 - ********
              *********                     *
              ***********                   *
              *************                 *
         50 - ***************** *           *
              |   |    |    |    |    |    |    |
             10  50  100  150  200  250  300  350
     @end example


     El grupo largo de funciones contienen de 10 a 19 palabras y símbolos.

** Apéndice D Software Libre y Manuales Libres
   @ @b{por Richard M. Stallman}

   La mayor deficiencia en sistemas operativos libres no está en el
   software––es la falta de buenos manuales libres que se puedan incluir en
   estos sistemas. Muchos de nuestros programas más importantes no vienen con
   manuales completos. La documentación es una parte esencial de cualquier
   paquete de software; cuando un paquete de software libre no viene con un
   manual libre, es una brecha mayor. Nosotros tenemos muchas brechas hoy.

   Érase una vez, hace muchos años, se piensa que aprendería Perl. Se tiene
   una copia de un manual libre, pero se encontró difícil de leer. Cuando
   pregunto a los usuarios de Perl acerca de alternativas, me contaron que
   serían mejor los manuales introductorios––pero estos no eran libres.

   ¿Por qué era esto? Los autores de los buenos manuales los habían escrito
   para O'Reilly Associates, que los publicaron con términos restrictivos––no
   copiando, no modificando, los ficheros fuentes están disponibles––que los
   excluyen desde la comunidad de software libre.

   No era la primera vez que esto ocurría, y (para nuestra comunidad es una
   gran pérdida) eso está lejos desde el último. Las editoriales de manuales
   privativos han logrado que muchos autores restrinjan sus manuales desde
   entonces. Muchas veces se ha oido que un usuario de GNU hábil me cuente
   que un manual que está escribiendo, con el que él espera ayudar al
   proyecto GNU––y entonces tenía mis esperanzas frustradas, como se ha
   procedió a explicar que él tenía que haber firmado un contrato con una
   editorial que restringiría eso, así que no puede usarlo.

   Debido a que escribir buen inglés es una habilidad rara entre
   programadores, se pueden perder manuales por este motivo.

   La documentación, como el software, es una cuestión de libertad, no de
   precio. El problema con estos manuales no eran que O'Reilly Associates
   impusiera un precio por las copias impresas––que en sí estaban bien. La
   Free Software Foundation @e{Fundación por el Software Libre}
   @l{http://shop.fsf.org, vende copias impresas} de
   @l{http://www.gnu.org/doc/doc.html, manuales libres de GNU}, también. Pero
   los manuales de GNU están disponibles en forma de código fuente, mientras
   que estos manuales están disponibles solo en papel. Los manuales de GNU
   vienen con permiso para copiar y modificar; los manuales de Perl no. Estas
   restricciones son un problema.

   El criterio para un manual libre es parecido al del software libre: es una
   cuestión de dar a todos los usuarios ciertas libertades. La redistribución
   (incluyendo redistribución comercial) debe ser permitida, así el manual
   puede acompañar cada copia del programa, en líne o en papel. El permiso
   para modificar es crucial también.

   Como regla general, no se cree que sea esencial para la gente tener
   permisos para modificar todas las partes de artículos y libro. Las
   cuestiones para escritos no son necesariamente las mismas como estas para
   el software. Por ejemplo, no se sabe si se está obligado a dar permisos
   para modificar artículos como este, que describen nuestras acciones y
   nuestras vistas.

   Pero hay una razón particular de por qué la libertad de modificar es
   crucial para la documentación de software libre. Cuando las personas
   ejercita su derecho a modificar el software, y añadir o cambiar sus
   funcionalidades, si son consciente ellos cambiarán el manual también––así
   se puede proveer documentación usable y cuidada con el programa
   modificado. Un manual que prohibe a los programadores ser consciente y
   finalizar el trabajo, o más precisamente requiere escribir un nuevo manual
   desde cero si ellos cambian el programa, no se ajusta a las necesidades de
   nuestra comunidad.

   Mientras una serie de prohibiciones en la modificación es inaceptable,
   algunos tipos de límites en el método de modificar no tiene tanto
   problema. Por ejemplo, los requisitos para preservar la noticia de autores
   del copyright, los términos de distribución, o la lista de autores, estén
   ok. Eso es también no da problemas para requerir versiones modificadas
   para incluir notificar que fueron modificadas, incluso tienen secciones
   enteras que puede no ser eliminadas o cambiadas, tan largo como estas
   secciones tratan con asuntos no técnicos. (Algunos manuales de GNU los
   tienen).

   Estos tipos de restricciones no son un problema porque, como materia
   práctica, no para al programador consciente desde la adaptación del manual
   para ajustar el programa modificado. En otras palabras, no se bloquea la
   comunidad del software libre haciendo el uso completo del manual.

   Sin embargo, debe ser posible modificar todo el contenido técnico del
   manual, y entonces se distribuye el resultado en todos los medios usuales,
   a través de todos los canales usuales; de otro modo, las restricciones
   bloquean la comunidad, el manual no es libre, y así no se necesita otro
   manual.

   Desafortunadamente, con frecuencia es duro encontrar a alguien a escribir
   otro manual cuando un manual privativo. El obstáculo es que muchos usuario
   piensan que un manual privativo es suficientemente bueno––así ellos no ven
   la necesidad de escribir un manual libre. Ellos no ven que el sistema
   operativo tiene un gazapo que necesita se rellenado.

   ¿Por qué los usuarios piensan que los manuales privativos son
   suficientemente buenos? Algunos no han considerado la cuestión. Espero que
   este artículo hará alguna cosa para cambiar esto.

   Otros usuarios considera manuales privativos aceptables para la misma
   razón así muchas personas software privativo aceptable: ellos judgan en
   términos puramente prácticos, no usando la liberta como un criterio. Estas
   personas son tituladas a sus opiniones, pero desde que estas opciones
   crezcan desde valores que no incluyen libertad, ellas no están guiadas por
   esto quienes valoran la libertad.

   Por favor, populariza esta cuestión. Se continúa a perder manuales para
   publicación privativa. Si se populariza que los manuales privativos no son
   suficientes, quizás la siguiente persona que quiere ayudar a GNU
   escribiendo documentación realizará, antes de que sea demasiado tarde, lo
   que él debe que todo sea libre.

   Se puede también animar editoriales comerciales a vender manuales libres o
   con copyleft en vez de uno privativo. Un camino que se puede ayudar esto
   chequea los términos de la distribución de un manual antes de que se
   compre, y preferimos manuales copyleft a los no copyleft.

   Note: La Fundación para el Software Libre mantiene una página en su sitio
   Web que liste libros libres disponibles desde otras editoriales:@*
   @l{http://www.gnu.org/doc/other-free-books.html}

* Appendix E GNU Free Documentation License

  @center
    Version 1.3, 3 November 2008
  @end center

  Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
  <http://fsf.org/>

  Everyone is permitted to copy and distribute verbatim copies of this
  license document, but changing it is not allowed.

** 0. PREAMBLE

   The purpose of this License is to make a manual, textbook, or other
   functional and useful document "free" in the sense of freedom: to assure
   everyone the effective freedom to copy and redistribute it, with or
   without modifying it, either commercially or noncommercially.
   Secondarily, this License preserves for the author and publisher a way to
   get credit for their work, while not being considered responsible for
   modifications made by others.

   This License is a kind of "copyleft", which means that derivative works of
   the document must themselves be free in the same sense.  It complements
   the GNU General Public License, which is a copyleft license designed for
   free software.

   We have designed this License in order to use it for manuals for free
   software, because free software needs free documentation: a free program
   should come with manuals providing the same freedoms that the software
   does.  But this License is not limited to software manuals; it can be used
   for any textual work, regardless of subject matter or whether it is
   published as a printed book.  We recommend this License principally for
   works whose purpose is instruction or reference.

** 1. APPLICABILITY AND DEFINITIONS

   This License applies to any manual or other work, in any medium, that
   contains a notice placed by the copyright holder saying it can be
   distributed under the terms of this License.  Such a notice grants a
   world-wide, royalty-free license, unlimited in duration, to use that work
   under the conditions stated herein.  The "Document", below, refers to any
   such manual or work.  Any member of the public is a licensee, and is
   addressed as "you".  You accept the license if you copy, modify or
   distribute the work in a way requiring permission under copyright law.

   A "Modified Version" of the Document means any work containing the
   Document or a portion of it, either copied verbatim, or with modifications
   and/or translated into another language.

   A "Secondary Section" is a named appendix or a front-matter section of the
   Document that deals exclusively with the relationship of the publishers or
   authors of the Document to the Document's overall subject (or to related
   matters) and contains nothing that could fall directly within that overall
   subject.  (Thus, if the Document is in part a textbook of mathematics, a
   Secondary Section may not explain any mathematics.)  The relationship
   could be a matter of historical connection with the subject or with
   related matters, or of legal, commercial, philosophical, ethical or
   political position regarding them.

   The "Invariant Sections" are certain Secondary Sections whose titles are
   designated, as being those of Invariant Sections, in the notice that says
   that the Document is released under this License.  If a section does not
   fit the above definition of Secondary then it is not allowed to be
   designated as Invariant.  The Document may contain zero Invariant
   Sections.  If the Document does not identify any Invariant Sections then
   there are none.

   The "Cover Texts" are certain short passages of text that are listed, as
   Front-Cover Texts or Back-Cover Texts, in the notice that says that the
   Document is released under this License.  A Front-Cover Text may be at
   most 5 words, and a Back-Cover Text may be at most 25 words.

   A "Transparent" copy of the Document means a machine-readable copy,
   represented in a format whose specification is available to the general
   public, that is suitable for revising the document straightforwardly with
   generic text editors or (for images composed of pixels) generic paint
   programs or (for drawings) some widely available drawing editor, and that
   is suitable for input to text formatters or for automatic translation to a
   variety of formats suitable for input to text formatters.  A copy made in
   an otherwise Transparent file format whose markup, or absence of markup,
   has been arranged to thwart or discourage subsequent modification by
   readers is not Transparent.  An image format is not Transparent if used
   for any substantial amount of text.  A copy that is not "Transparent" is
   called "Opaque".

   Examples of suitable formats for Transparent copies include plain ASCII
   without markup, Texinfo input format, LaTeX input format, SGML or XML
   using a publicly available DTD, and standard-conforming simple HTML,
   PostScript or PDF designed for human modification.  Examples of
   transparent image formats include PNG, XCF and JPG.  Opaque formats
   include proprietary formats that can be read and edited only by
   proprietary word processors, SGML or XML for which the DTD and/or
   processing tools are not generally available, and the machine-generated
   HTML, PostScript or PDF produced by some word processors for output
   purposes only.

   The "Title Page" means, for a printed book, the title page itself, plus
   such following pages as are needed to hold, legibly, the material this
   License requires to appear in the title page.  For works in formats which
   do not have any title page as such, "Title Page" means the text near the
   most prominent appearance of the work's title, preceding the beginning of
   the body of the text.

   The "publisher" means any person or entity that distributes copies of the
   Document to the public.

   A section "Entitled XYZ" means a named subunit of the Document whose title
   either is precisely XYZ or contains XYZ in parentheses following text that
   translates XYZ in another language.  (Here XYZ stands for a specific
   section name mentioned below, such as "Acknowledgements", "Dedications",
   "Endorsements", or "History".)  To "Preserve the Title" of such a section
   when you modify the Document means that it remains a section "Entitled
   XYZ" according to this definition.

   The Document may include Warranty Disclaimers next to the notice which
   states that this License applies to the Document.  These Warranty
   Disclaimers are considered to be included by reference in this License,
   but only as regards disclaiming warranties: any other implication that
   these Warranty Disclaimers may have is void and has no effect on the
   meaning of this License.

** 2. VERBATIM COPYING

   You may copy and distribute the Document in any medium, either
   commercially or noncommercially, provided that this License, the copyright
   notices, and the license notice saying this License applies to the
   Document are reproduced in all copies, and that you add no other
   conditions whatsoever to those of this License.  You may not use technical
   measures to obstruct or control the reading or further copying of the
   copies you make or distribute.  However, you may accept compensation in
   exchange for copies.  If you distribute a large enough number of copies
   you must also follow the conditions in section 3.

   You may also lend copies, under the same conditions stated above, and you
   may publicly display copies.

** 3. COPYING IN QUANTITY

   If you publish printed copies (or copies in media that commonly have
   printed covers) of the Document, numbering more than 100, and the
   Document's license notice requires Cover Texts, you must enclose the
   copies in covers that carry, clearly and legibly, all these Cover Texts:
   Front-Cover Texts on the front cover, and Back-Cover Texts on the back
   cover.  Both covers must also clearly and legibly identify you as the
   publisher of these copies.  The front cover must present the full title
   with all words of the title equally prominent and visible.  You may add
   other material on the covers in addition.  Copying with changes limited to
   the covers, as long as they preserve the title of the Document and satisfy
   these conditions, can be treated as verbatim copying in other respects.

   If the required texts for either cover are too voluminous to fit legibly,
   you should put the first ones listed (as many as fit reasonably) on the
   actual cover, and continue the rest onto adjacent pages.

   If you publish or distribute Opaque copies of the Document numbering more
   than 100, you must either include a machine-readable Transparent copy
   along with each Opaque copy, or state in or with each Opaque copy a
   computer-network location from which the general network-using public has
   access to download using public-standard network protocols a complete
   Transparent copy of the Document, free of added material.  If you use the
   latter option, you must take reasonably prudent steps, when you begin
   distribution of Opaque copies in quantity, to ensure that this Transparent
   copy will remain thus accessible at the stated location until at least one
   year after the last time you distribute an Opaque copy (directly or
   through your agents or retailers) of that edition to the public.

   It is requested, but not required, that you contact the authors of the
   Document well before redistributing any large number of copies, to give
   them a chance to provide you with an updated version of the Document.

** 4. MODIFICATIONS

   You may copy and distribute a Modified Version of the Document under the
   conditions of sections 2 and 3 above, provided that you release the
   Modified Version under precisely this License, with the Modified Version
   filling the role of the Document, thus licensing distribution and
   modification of the Modified Version to whoever possesses a copy of it.
   In addition, you must do these things in the Modified Version:

   A. Use in the Title Page (and on the covers, if any) a title distinct from
      that of the Document, and from those of previous versions (which
      should, if there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if the
      original publisher of that version gives permission.

   B. List on the Title Page, as authors, one or more persons or entities
      responsible for authorship of the modifications in the Modified
      Version, together with at least five of the principal authors of the
      Document (all of its principal authors, if it has fewer than five),
      unless they release you from this requirement.

   C. State on the Title page the name of the publisher of the Modified
      Version, as the publisher.

   D. Preserve all the copyright notices of the Document.

   E. Add an appropriate copyright notice for your modifications adjacent to
      the other copyright notices.

   F. Include, immediately after the copyright notices, a license notice
      giving the public permission to use the Modified Version under the
      terms of this License, in the form shown in the Addendum below.

   G. Preserve in that license notice the full lists of Invariant Sections
      and required Cover Texts given in the Document's license notice.

   H. Include an unaltered copy of this License.

   I. Preserve the section Entitled "History", Preserve its Title, and add to
      it an item stating at least the title, year, new authors, and publisher
      of the Modified Version as given on the Title Page.  If there is no
      section Entitled "History" in the Document, create one stating the
      title, year, authors, and publisher of the Document as given on its
      Title Page, then add an item describing the Modified Version as stated
      in the previous sentence.

   J. Preserve the network location, if any, given in the Document for public
      access to a Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was based on.
      These may be placed in the "History" section.  You may omit a network
      location for a work that was published at least four years before the
      Document itself, or if the original publisher of the version it refers
      to gives permission.

   K. For any section Entitled "Acknowledgements" or "Dedications", Preserve
      the Title of the section, and preserve in the section all the substance
      and tone of each of the contributor acknowledgements and/or dedications
      given therein.

   L. Preserve all the Invariant Sections of the Document, unaltered in their
      text and in their titles.  Section numbers or the equivalent are not
      considered part of the section titles.

   M. Delete any section Entitled "Endorsements".  Such a section may not be
      included in the Modified Version.

   N. Do not retitle any existing section to be Entitled "Endorsements" or to
      conflict in title with any Invariant Section.

   O. Preserve any Warranty Disclaimers.


   If the Modified Version includes new front-matter sections or appendices
   that qualify as Secondary Sections and contain no material copied from the
   Document, you may at your option designate some or all of these sections
   as invariant.  To do this, add their titles to the list of Invariant
   Sections in the Modified Version's license notice.  These titles must be
   distinct from any other section titles.

   You may add a section Entitled "Endorsements", provided it contains
   nothing but endorsements of your Modified Version by various parties--for
   example, statements of peer review or that the text has been approved by
   an organization as the authoritative definition of a standard.

   You may add a passage of up to five words as a Front-Cover Text, and a
   passage of up to 25 words as a Back-Cover Text, to the end of the list of
   Cover Texts in the Modified Version.  Only one passage of Front-Cover Text
   and one of Back-Cover Text may be added by (or through arrangements made
   by) any one entity.  If the Document already includes a cover text for the
   same cover, previously added by you or by arrangement made by the same
   entity you are acting on behalf of, you may not add another; but you may
   replace the old one, on explicit permission from the previous publisher
   that added the old one.

   The author(s) and publisher(s) of the Document do not by this License give
   permission to use their names for publicity for or to assert or imply
   endorsement of any Modified Version.

** 5. COMBINING DOCUMENTS

   You may combine the Document with other documents released under this
   License, under the terms defined in section 4 above for modified versions,
   provided that you include in the combination all of the Invariant Sections
   of all of the original documents, unmodified, and list them all as
   Invariant Sections of your combined work in its license notice, and that
   you preserve all their Warranty Disclaimers.

   The combined work need only contain one copy of this License, and multiple
   identical Invariant Sections may be replaced with a single copy.  If there
   are multiple Invariant Sections with the same name but different contents,
   make the title of each such section unique by adding at the end of it, in
   parentheses, the name of the original author or publisher of that section
   if known, or else a unique number.  Make the same adjustment to the
   section titles in the list of Invariant Sections in the license notice of
   the combined work.

   In the combination, you must combine any sections Entitled "History" in
   the various original documents, forming one section Entitled "History";
   likewise combine any sections Entitled "Acknowledgements", and any
   sections Entitled "Dedications".  You must delete all sections Entitled
   "Endorsements".

** 6. COLLECTIONS OF DOCUMENTS

   You may make a collection consisting of the Document and other documents
   released under this License, and replace the individual copies of this
   License in the various documents with a single copy that is included in
   the collection, provided that you follow the rules of this License for
   verbatim copying of each of the documents in all other respects.

   You may extract a single document from such a collection, and distribute
   it individually under this License, provided you insert a copy of this
   License into the extracted document, and follow this License in all other
   respects regarding verbatim copying of that document.

** 7. AGGREGATION WITH INDEPENDENT WORKS

   A compilation of the Document or its derivatives with other separate and
   independent documents or works, in or on a volume of a storage or
   distribution medium, is called an "aggregate" if the copyright resulting
   from the compilation is not used to limit the legal rights of the
   compilation's users beyond what the individual works permit.  When the
   Document is included in an aggregate, this License does not apply to the
   other works in the aggregate which are not themselves derivative works of
   the Document.

   If the Cover Text requirement of section 3 is applicable to these copies
   of the Document, then if the Document is less than one half of the entire
   aggregate, the Document's Cover Texts may be placed on covers that bracket
   the Document within the aggregate, or the electronic equivalent of covers
   if the Document is in electronic form.  Otherwise they must appear on
   printed covers that bracket the whole aggregate.

** 8. TRANSLATION

   Translation is considered a kind of modification, so you may distribute
   translations of the Document under the terms of section 4.  Replacing
   Invariant Sections with translations requires special permission from
   their copyright holders, but you may include translations of some or all
   Invariant Sections in addition to the original versions of these Invariant
   Sections.  You may include a translation of this License, and all the
   license notices in the Document, and any Warranty Disclaimers, provided
   that you also include the original English version of this License and the
   original versions of those notices and disclaimers.  In case of a
   disagreement between the translation and the original version of this
   License or a notice or disclaimer, the original version will prevail.

   If a section in the Document is Entitled "Acknowledgements",
   "Dedications", or "History", the requirement (section 4) to Preserve its
   Title (section 1) will typically require changing the actual title.

** 9. TERMINATION

   You may not copy, modify, sublicense, or distribute the Document except as
   expressly provided under this License.  Any attempt otherwise to copy,
   modify, sublicense, or distribute it is void, and will automatically
   terminate your rights under this License.

   However, if you cease all violation of this License, then your license
   from a particular copyright holder is reinstated (a) provisionally, unless
   and until the copyright holder explicitly and finally terminates your
   license, and (b) permanently, if the copyright holder fails to notify you
   of the violation by some reasonable means prior to 60 days after the
   cessation.

   Moreover, your license from a particular copyright holder is reinstated
   permanently if the copyright holder notifies you of the violation by some
   reasonable means, this is the first time you have received notice of
   violation of this License (for any work) from that copyright holder, and
   you cure the violation prior to 30 days after your receipt of the notice.

   Termination of your rights under this section does not terminate the
   licenses of parties who have received copies or rights from you under this
   License.  If your rights have been terminated and not permanently
   reinstated, receipt of a copy of some or all of the same material does not
   give you any rights to use it.

** 10. FUTURE REVISIONS OF THIS LICENSE

   The Free Software Foundation may publish new, revised versions of the GNU
   Free Documentation License from time to time.  Such new versions will be
   similar in spirit to the present version, but may differ in detail to
   address new problems or concerns.  See http://www.gnu.org/copyleft/.

   Each version of the License is given a distinguishing version number.  If
   the Document specifies that a particular numbered version of this License
   "or any later version" applies to it, you have the option of following the
   terms and conditions either of that specified version or of any later
   version that has been published (not as a draft) by the Free Software
   Foundation.  If the Document does not specify a version number of this
   License, you may choose any version ever published (not as a draft) by the
   Free Software Foundation.  If the Document specifies that a proxy can
   decide which future versions of this License can be used, that proxy's
   public statement of acceptance of a version permanently authorizes you to
   choose that version for the Document.

** 11. RELICENSING

   "Massive Multiauthor Collaboration Site" (or "MMC Site") means any World
   Wide Web server that publishes copyrightable works and also provides
   prominent facilities for anybody to edit those works.  A public wiki that
   anybody can edit is an example of such a server.  A "Massive Multiauthor
   Collaboration" (or "MMC") contained in the site means any set of
   copyrightable works thus published on the MMC site.

   "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0 license
   published by Creative Commons Corporation, a not-for-profit corporation
   with a principal place of business in San Francisco, California, as well
   as future copyleft versions of that license published by that same
   organization.

   "Incorporate" means to publish or republish a Document, in whole or in
   part, as part of another Document.

   An MMC is "eligible for relicensing" if it is licensed under this License,
   and if all works that were first published under this License somewhere
   other than this MMC, and subsequently incorporated in whole or in part
   into the MMC, (1) had no cover texts or invariant sections, and (2) were
   thus incorporated prior to November 1, 2008.

   The operator of an MMC Site may republish an MMC contained in the site
   under CC-BY-SA on the same site at any time before August 1, 2009,
   provided the MMC is eligible for relicensing.

* ADDENDUM: How to use this License for your documents

  To use this License in a document you have written, include a copy of the
  License in the document and put the following copyright and license notices
  just after the title page:

  @pre
    Copyright (c)  YEAR  YOUR NAME.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
  @end pre

  If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
  replace the "with...Texts." line with this:

  @pre
    with the Invariant Sections being LIST THEIR TITLES, with the
    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
  @end pre

  If you have Invariant Sections without Cover Texts, or some other
  combination of the three, merge those two alternatives to suit the
  situation.

  If your document contains nontrivial examples of program code, we recommend
  releasing these examples in parallel under your choice of free software
  license, such as the GNU General Public License, to permit their use in
  free software.

** Acerca del Autor

   Robert J. Chassell ha trabajado con GNU Emacs desde 1985. Él
   escribe, edita y enseña Emacs y Emacs Lisp, y habla alrededor del
   mundo acerca de la libertad del software. Chassell es Director
   fundador y Tesorero de la Fundación por el Software Libre (FSF). Él
   se graduó la Universidad de Cambridge, en Inglaterra. Él tiene un
   interés contínuo en historia económica y social y vuela su
   propio aeroplano

* footnotes

  - @N{1} :: El apóstrofo o comilla es una abreviación para la función
    @c{quote}; no necesitas pensar acerca de funciones ahora; las funciones
    se definen en la Seccion @l{Generar un mensaje de error}.

  - @N{2} :: Es curioso trazar la ruta por la cual la palabra ‘argumento’
    llego a tener dos significados distintos, uno en matemáticas y otro en el
    inglés cotidiano. De acuerdo al @e{Oxford English Dictionary}, la palabra
    deriva del Latín para @'{dejar claro, probar}; por lo tanto, paso a
    significar, por un hilo de derivación, ‘la evidencia ofrecida como
    prueba’, es decir ‘la informacion que se ofrece’, que conduce a su
    significado en Lisp. Pero en el otro hilo de derivación, paso a
    significar ‘para afirmar de una manera lo que otros pueden afirmar en
    contra’, lo que llevó a la disputa del significado de la palabra. (Nóte
    aquí que la palabra Inglésa tiene dos definiciones distintas al mismo
    tiempo. En contraste, en Emacs Lisp, un símbolo no puede tener dos
    definiciones de funcion diferentes al mismo tiempo.)

  - @N{3} :: @c{(quote hola)} es una expansión de la abreviatura @c{'hola}.

  - @N{4} :: En realidad, puede utilizar @c{%s} para imprimir un número. Es
    no específico. @c{%d} imprime solo la parte de un número a la izquierda
    del punto decimal, excluyendo cualquier cosa que no sea un número.

  - @N{5} :: En realidad, por defecto, si el búffer desde el que has
    cambiado es visible por tí en otra ventana, @c{other-buffer} elegirá el
    búffer más reciente que no puedas ver; esta es una sutileza que a menudo
    olvido.

  - @N{6} -: O mejor, para evitar escribir, probablemente solo necesite
    pulsar @k{RET} si @f{*scratch*} es el buffer por defecto, de ser
    diferente, solo escriba parte del nombre, por ejemplo @c{*sc}, luego
    presione la tecla @k{TAB} para hacer que se expanda el nombre completo, y
    finalmente pulsa @k{RET}.

  - @N{7} -: Recuerda, esta expresión te desplaza al buffer diferente más
    reciente que no puedas ver. Si realmente quieres ir al ultimo búffer
    seleccionado, incluso si es visible, es necesario evaluar la siguiente
    expresión más compleja:

    @src elisp
      (switch-to-buffer (other-buffer (current-buffer) t))
    @end src

    En este caso, el primer argumento de @c{other-buffer} le dice a que
    búffer saltar––el actual––y el segundo argumento le indica a
    @c{other-buffer} que esta BIEN cambiar a un búffer visible. La utilidad
    de @c{switch-to-buffer} es llevarte a una ventana invisible ya que
    probablemente usarias @k{C-x o} (@c{other-window}) para ir a otro búffer
    visible.

  - @N{8} :: De acuerdo con Jared Diamond en @e{Guns, Germs, and Steel}, “…
    las cebras se vuelven increiblemente peligrosas a medida que envejecen”
    pero la demanda aquí es que no llegan a ser fieras como un tigre. (1997,
    W. W. Norton and Co., ISBN 0-393-03894-2, pagina 171)

  - @N{9} :: Actualmente, se puede @c{cons} un elemento para un átomo para
    producir a para punteado. Los pares punteados no se discuten aquí; ver
    Seccion "Notación de Para Punteado" en @e(El Manual de Referencia de GNU
    Emacs Lisp).

  - @N{10} :: Más precisamente, y requiriendo conocimiento más experto para
    comprender, los dos enteros son del tipo ‘Lisp_Object’, que puede también
    ser una unión C en vez de un tipo de entero.

  - @N{11} :: Se pueden escribir funciones recursivas para ser frugal o
    basura mental o recursos de ordenador; como eso ocurre, los métodos que
    la gente encuentra fáciles––son frugales de ‘recursos mentales’––algunas
    veces usan recursos de ordenador considerables. Emacs fué diseñado para
    ejecutarse en máquinas que ahora se consideran limitadas y sus
    configuraciones por defecto son conservadoras. Se puede querer
    incrementar los valores de @c{max-specdl-size} y
    @c{max-lisp-eval-depth}. En mi fichero @f{.emacs}, yo los asigno a 15 o
    30 veces su valor por defecto.

  - @N{12} :: La frase @:{cola recursiva} es usado para describir tal
    proceso, uno que usa ‘espacio constante’.

  - @N{13} :: La jerga es medianamente confusa: @c{triangle-recursive-helper}
    usa un proceso que es iterativo en un procedimiento que es recursivo. El
    proceso se llama iterativo porque el ordenador necesita solo grabar los
    tres valores, @c{suma}, @c{contador}, y @c{número}: el procedimiento es
    recursivo porque la función ‘llama a sí mismo’. Por otro lado, ambos el
    proceso y el procedimiento usado por @c{triangle-recursively} son
    llamados recursivos. La palabra ‘recursivo’ tiene diferentes significados
    en los dos contextos.

  - @N{14} :: Tu puedes también añadir @f{.el} para @f{~/.emacs} y llama a un
    fichero @f{~/.emacs}. En el pasado, fué prohibido escribir los atajos de
    teclado extra que el nombre @f{~/.emacs.el} requiere, pero ahora
    puedes. El nuevo formato es consistente con las conveniciones de nombre
    del fichero Emacs Lisp; el viejo formato guarda la escritura.

  - @N{15} :: Cuando se empiezan las instancias de Emacs que no cargan mi
    fichero @f{.emacs} o cualquier fichero, también se puede deshabilitar la
    ocultación:

    @example
      emacs -q --no-site-file -eval
      '(blink-cursor-mode nil)' @exdent O ahora, usando un conjunto más
      sofisticado de opciones, emacs -Q - D
    @end example

  - @N{16} :: también se ejecutan gestores de ventanas más modernos, tales
    como Enlightenment, Gnome, o KDE; en estos casos, con frecuencia se
    especifica una imagen en vez de un color plano.
