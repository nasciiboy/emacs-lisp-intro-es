<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Una introducción a la programación en Emacs Lisp</title>
<meta name="subtitle" content="Revisada la tercera edición" />
<meta name="author" content="Robert J. Chassell" />
<link rel="stylesheet" type="text/css" href="worg-data/worg.css" />
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
</head>
<body>
<div id="toc">
<p>index</p>
<div id="toc-contents">
<span class="toc" ><a class="h2" href="#Prefacio" >Prefacio</a></span>
<span class="toc" ><a class="h3" href="#Leyendo-este-texto" >Leyendo este texto</a></span>
<span class="toc" ><a class="h3" href="#Para-quien-está-esto-escrito" >Para quien está esto escrito</a></span>
<span class="toc" ><a class="h3" href="#Historia-de-Lisp" >Historia de Lisp</a></span>
<span class="toc" ><a class="h3" href="#Una-nota-para-principiantes" >Una nota para principiantes</a></span>
<span class="toc" ><a class="h3" href="#Se-agradece" >Se agradece</a></span>
<span class="toc" ><a class="h2" href="#Procesamiento-de-listas" >Procesamiento de listas</a></span>
<span class="toc" ><a class="h3" href="#Listas-Lisp" >Listas Lisp</a></span>
<span class="toc" ><a class="h4" href="#Átomos-Lisp" >Átomos Lisp</a></span>
<span class="toc" ><a class="h4" href="#Espacios-en-blanco-en-listas" >Espacios en blanco en listas</a></span>
<span class="toc" ><a class="h4" href="#GNU-Emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</a></span>
<span class="toc" ><a class="h3" href="#Ejecutar-un-programa" >Ejecutar un programa</a></span>
<span class="toc" ><a class="h3" href="#Generar-un-mensaje-de-error" >Generar un mensaje de error</a></span>
<span class="toc" ><a class="h3" href="#Nombres-de-símbolos-y-definiciones-de-funciones" >Nombres de símbolos y definiciones de funciones</a></span>
<span class="toc" ><a class="h3" href="#El-intérprete-Lisp" >El intérprete Lisp</a></span>
<span class="toc" ><a class="h4" href="#Compilación-de-bytes" >Compilación de bytes</a></span>
<span class="toc" ><a class="h3" href="#Evaluación" >Evaluación</a></span>
<span class="toc" ><a class="h4" href="#Evaluación-de-listas-internas" >Evaluación de listas internas</a></span>
<span class="toc" ><a class="h3" href="#Variables" >Variables</a></span>
<span class="toc" ><a class="h4" href="#Mensaje-de-error-de-un-símbolo-sin-una-función" >Mensaje de error de un símbolo sin una función</a></span>
<span class="toc" ><a class="h4" href="#Mensaje-de-error-de-un-símbolo-sin-un-valor" >Mensaje de error de un símbolo sin un valor</a></span>
<span class="toc" ><a class="h3" href="#Argumentos" >Argumentos</a></span>
<span class="toc" ><a class="h4" href="#Tipos-de-dato-de-los-argumentos" >Tipos de dato de los argumentos</a></span>
<span class="toc" ><a class="h4" href="#Un-argumento-como-el-valor-de-una-variable-o-lista" >Un argumento como el valor de una variable o lista</a></span>
<span class="toc" ><a class="h4" href="#Número-variable-de-argumentos" >Número variable de argumentos</a></span>
<span class="toc" ><a class="h4" href="#Usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a></span>
<span class="toc" ><a class="h4" href="#La-función-message" >La función <code>message</code></a></span>
<span class="toc" ><a class="h3" href="#Configurando-el-valor-de-una-variable" >Configurando el valor de una variable</a></span>
<span class="toc" ><a class="h4" href="#Usando-set" >Usando <code>set</code></a></span>
<span class="toc" ><a class="h4" href="#Usando-setq" >Usando <code>setq</code></a></span>
<span class="toc" ><a class="h4" href="#Contando" >Contando</a></span>
<span class="toc" ><a class="h3" href="#Resumen" >Resumen</a></span>
<span class="toc" ><a class="h3" href="#Ejercicios" >Ejercicios</a></span>
<span class="toc" ><a class="h2" href="#Practicando-evaluación" >Practicando evaluación</a></span>
<span class="toc" ><a class="h3" href="#Nombres-de-búffer" >Nombres de búffer</a></span>
<span class="toc" ><a class="h3" href="#Obtención-de-Búffers" >Obtención de Búffers</a></span>
<span class="toc" ><a class="h3" href="#Cambiando-búffers" >Cambiando búffers</a></span>
<span class="toc" ><a class="h3" href="#Tamaño-del-búffer-y-la-ubicación-del-punto" >Tamaño del búffer y la ubicación del punto</a></span>
<span class="toc" ><a class="h3" href="#Ejercicio" >Ejercicio</a></span>
<span class="toc" ><a class="h2" href="#Cómo-escribir-definiciones-de-funciones" >Cómo escribir definiciones de funciones</a></span>
<span class="toc" ><a class="h3" href="#La-forma-especial-defun" >La forma especial <code>defun</code></a></span>
<span class="toc" ><a class="h3" href="#Instalar-una-definición-de-función" >Instalar una definición de función</a></span>
<span class="toc" ><a class="h4" href="#Cambiar-una-definición-de-función" >Cambiar una definición de función</a></span>
<span class="toc" ><a class="h3" href="#Crear-una-función-interactiva" >Crear una función interactiva</a></span>
<span class="toc" ><a class="h4" href="#multiplicar-por-siente-interactivo" ><code>multiplicar-por-siente</code> interactivo</a></span>
<span class="toc" ><a class="h3" href="#Diferentes-opciones-para-interactive" >Diferentes opciones para <code>interactive</code></a></span>
<span class="toc" ><a class="h3" href="#Instalar-código-permanentemente" >Instalar código permanentemente</a></span>
<span class="toc" ><a class="h3" href="#let" ><code>let</code></a></span>
<span class="toc" ><a class="h4" href="#Partes-de-una-expresión-let" >Partes de una expresión <code>let</code></a></span>
<span class="toc" ><a class="h4" href="#Ejemplo-de-Expresión-let" >Ejemplo de Expresión <code>let</code></a></span>
<span class="toc" ><a class="h4" href="#Variables-sin-inicializar-en-un-sentencia-let" >Variables sin inicializar en un sentencia <code>let</code></a></span>
<span class="toc" ><a class="h3" href="#La-forma-especial-if" >La forma especial <code>if</code></a></span>
<span class="toc" ><a class="h4" href="#La-función-tipo-de-animal-en-detalle" >La función <code>tipo-de-animal</code> en detalle</a></span>
<span class="toc" ><a class="h3" href="#Expresiones-if–then–else" >Expresiones if–then–else</a></span>
<span class="toc" ><a class="h3" href="#Verdad-y-Falsedad-en-Emacs-Lisp" >Verdad y Falsedad en Emacs Lisp</a></span>
<span class="toc" ><a class="h3" href="#save-excursion" ><code>save-excursion</code></a></span>
<span class="toc" ><a class="h4" href="#Plantilla-para-una-Expresión-save-excursion" >Plantilla para una Expresión <code>save-excursion</code></a></span>
<span class="toc" ><a class="h3" href="#Repaso" ><span id="Repaso: Cómo escribir definiciones de funciones" >Repaso</span></a></span>
<span class="toc" ><a class="h3" href="#Ejercicios" >Ejercicios</a></span>
<span class="toc" ><a class="h2" href="#Algunas-funcienes-relacionadas-al-buffer" >Algunas funcienes relacionadas al buffer</a></span>
<span class="toc" ><a class="h3" href="#Encontrar-Más-información" >Encontrar Más información</a></span>
<span class="toc" ><a class="h3" href="#Una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></a></span>
<span class="toc" ><a class="h3" href="#La-definición-de-mark-whole-buffer" >La definición de <code>mark-whole-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#Cuerpo-de-mark-whole-buffer" >Cuerpo de <code>mark-whole-buffer</code></a></span>
<span class="toc" ><a class="h3" href="#La-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#La-expresión-interactiva-append-to-buffer" >La expresión interactiva <code>append-to-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#El-cuerpo-de-append-to-buffer" >El cuerpo de <code>append-to-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></a></span>
<span class="toc" ><a class="h3" href="#Repaso" >Repaso</a></span>
<span class="toc" ><a class="h3" href="#Ejercicios" >Ejercicios</a></span>
<span class="toc" ><a class="h2" href="#Algunas-Funciones-Más-Complejas" >Algunas Funciones Más Complejas</a></span>
<span class="toc" ><a class="h3" href="#La-definición-de-copy-to-buffer" >La definición de <code>copy-to-buffer</code></a></span>
<span class="toc" ><a class="h3" href="#La-definición-de-insert-buffer" >La definición de <code>insert-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#La-expresión-interactiva-en-insert-buffer" >La expresión interactiva en <code>insert-buffer</code></a></span>
<span class="toc" ><a class="h5" href="#Un-búffer-de-solo-lectura" >Un búffer de solo lectura</a></span>
<span class="toc" ><a class="h5" href="#b-en-una-expresión-interactiva" ><samp>b</samp> en una expresión interactiva</a></span>
<span class="toc" ><a class="h4" href="#El-cuerpo-de-la-función-insert-buffer" >El cuerpo de la función <code>insert-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#insert-buffer-con-un-if-en-lugar-de-un-or" ><code>insert-buffer</code> con un <code>if</code> en lugar de un <code>or</code></a></span>
<span class="toc" ><a class="h4" href="#El-or-en-el-cuerpo" >El <code>or</code> en el cuerpo</a></span>
<span class="toc" ><a class="h4" href="#La-expresión-let-en-insert-buffer" >La expresión <code>let</code> en <code>insert-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#Nuevo-cuerpo-para-insert-buffer" >Nuevo cuerpo para <code>insert-buffer</code></a></span>
<span class="toc" ><a class="h3" href="#Definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></a></span>
<span class="toc" ><a class="h4" href="#Argumentos-opcionales" >Argumentos opcionales</a></span>
<span class="toc" ><a class="h4" href="#beginning-of-buffer-con-un-argumento" ><code>beginning-of-buffer</code> con un argumento</a></span>
<span class="toc" ><a class="h5" href="#Qué-ocurre-en-un-búffer-de-gran-tamaño" >Qué ocurre en un búffer de gran tamaño</a></span>
<span class="toc" ><a class="h5" href="#Qué-ocurre-en-un-búffer-pequeño" >Qué ocurre en un búffer pequeño</a></span>
<span class="toc" ><a class="h4" href="#Funcion-beginning-of-buffer-Completa" >Funcion <code>beginning-of-buffer</code> Completa</a></span>
<span class="toc" ><a class="h3" href="#Repaso" ><span id="Repaso-2" >Repaso</span></a></span>
<span class="toc" ><a class="h3" href="#Ejercicio-de-argumento-opcional" >Ejercicio de argumento <code>opcional</code></a></span>
<span class="toc" ><a class="h2" href="#Reducir-y-Extender" >Reducir y Extender</a></span>
<span class="toc" ><a class="h3" href="#La-forma-especial-save-restriction" >La forma especial <code>save-restriction</code></a></span>
<span class="toc" ><a class="h3" href="#what-line" ><code>what-line</code></a></span>
<span class="toc" ><a class="h3" href="#Ejercicio-de-Reduccion" >Ejercicio de Reduccion</a></span>
<span class="toc" ><a class="h2" href="#car,-cdr,-cons:-Funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</a></span>
<span class="toc" ><a class="h3" href="#car-y-cdr" ><code>car</code> y <code>cdr</code></a></span>
<span class="toc" ><a class="h3" href="#cons" ><code>cons</code></a></span>
<span class="toc" ><a class="h4" href="#Encuentra-la-longitud-de-una-lista:-length" >Encuentra la longitud de una lista: <code>length</code></a></span>
<span class="toc" ><a class="h3" href="#nthcdr" ><code>nthcdr</code></a></span>
<span class="toc" ><a class="h3" href="#nth" ><code>nth</code></a></span>
<span class="toc" ><a class="h3" href="#setcar" ><code>setcar</code></a></span>
<span class="toc" ><a class="h3" href="#setcdr" ><code>setcdr</code></a></span>
<span class="toc" ><a class="h3" href="#Ejercicio" >Ejercicio</a></span>
<span class="toc" ><a class="h2" href="#Corte-y-Almacenamiento-de-Texto" >Corte y Almacenamiento de Texto</a></span>
<span class="toc" ><a class="h3" href="#zap-to-char" ><code>zap-to-char</code></a></span>
<span class="toc" ><a class="h4" href="#La-expresión-interactive" >La expresión <code>interactive</code></a></span>
<span class="toc" ><a class="h4" href="#El-cuerpo-de-zap-to-char" >El cuerpo de <code>zap-to-char</code></a></span>
<span class="toc" ><a class="h4" href="#La-función-search-forward" >La función <code>search-forward</code></a></span>
<span class="toc" ><a class="h4" href="#La-forma-especial-progn" >La forma especial <code>progn</code></a></span>
<span class="toc" ><a class="h4" href="#Resumiendo-zap-to-char" >Resumiendo <code>zap-to-char</code></a></span>
<span class="toc" ><a class="h3" href="#kill-region" ><code>kill-region</code></a></span>
<span class="toc" ><a class="h4" href="#condition-case" ><code>condition-case</code></a></span>
<span class="toc" ><a class="h4" href="#Macro-Lisp" >Macro Lisp</a></span>
<span class="toc" ><a class="h3" href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a></span>
<span class="toc" ><a class="h4" href="#El-cuerpo-de-copy-region-as-kill" >El cuerpo de <code>copy-region-as-kill</code></a></span>
<span class="toc" ><a class="h5" href="#La-función-kill-append" >La función <code>kill-append</code></a></span>
<span class="toc" ><a class="h5" href="#La-función-kill-new" >La función <code>kill-new</code></a></span>
<span class="toc" ><a class="h3" href="#Disgresión-dentro-de-C" >Disgresión dentro de C</a></span>
<span class="toc" ><a class="h3" href="#Inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></a></span>
<span class="toc" ><a class="h4" href="#defvar-y-un-asterisco" ><code>defvar</code> y un asterisco</a></span>
<span class="toc" ><a class="h3" href="#Repaso" >Repaso</a></span>
<span class="toc" ><a class="h3" href="#Buscando-ejercicios" >Buscando ejercicios</a></span>
<span class="toc" ><a class="h2" href="#Cómo-se-implementan-las-listas" >Cómo se implementan las listas</a></span>
<span class="toc" ><a class="h3" href="#Símbolos-como-una-caja-con-cajones" >Símbolos como una caja con cajones</a></span>
<span class="toc" ><a class="h3" href="#Ejercicio" >Ejercicio</a></span>
<span class="toc" ><a class="h2" href="#Pegando-texto" >Pegando texto</a></span>
<span class="toc" ><a class="h3" href="#Resumen-del-anillo-de-la-muerte" >Resumen del anillo de la muerte</a></span>
<span class="toc" ><a class="h3" href="#La-variable-kill-ring-yank-pointer" >La variable <code>kill-ring-yank-pointer</code></a></span>
<span class="toc" ><a class="h3" href="#Ejercicios-con-yank-y-nthcdr" >Ejercicios con <code>yank</code> y <code>nthcdr</code></a></span>
<span class="toc" ><a class="h2" href="#Bucles-y-recursión" >Bucles y recursión</a></span>
<span class="toc" ><a class="h3" href="#while" ><code>while</code></a></span>
<span class="toc" ><a class="h4" href="#Un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a></span>
<span class="toc" ><a class="h4" href="#Un-ejemplo:-imprimir-elementos-de-la-lista" >Un ejemplo: <code>imprimir-elementos-de-la-lista</code></a></span>
<span class="toc" ><a class="h4" href="#Un-bucle-con-un-contaje-incremental" >Un bucle con un contaje incremental</a></span>
<span class="toc" ><a class="h5" href="#Ejemplo-con-contador-incremental" >Ejemplo con contador incremental</a></span>
<span class="toc" ><a class="h5" href="#Las-partes-de-la-definición-de-función" >Las partes de la definición de función</a></span>
<span class="toc" ><a class="h5" href="#Poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</a></span>
<span class="toc" ><a class="h4" href="#Bucle-que-se-decrementa" >Bucle que se decrementa</a></span>
<span class="toc" ><a class="h5" href="#Ejemplo-con-el-contador-que-se-decrementa" >Ejemplo con el contador que se decrementa</a></span>
<span class="toc" ><a class="h5" href="#Las-partes-de-la-definición-de-función" >Las partes de la definición de función</a></span>
<span class="toc" ><a class="h5" href="#Poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</a></span>
<span class="toc" ><a class="h3" href="#Ahorra-tiempo:-dolist-y-dotimes" >Ahorra tiempo: <code>dolist</code> y <code>dotimes</code></a></span>
<span class="toc" ><a class="h4" href="#La-macro-dolist" >La macro <code>dolist</code></a></span>
<span class="toc" ><a class="h4" href="#La-macro-dotimes" >La macro <code>dotimes</code></a></span>
<span class="toc" ><a class="h3" href="#Recursión" >Recursión</a></span>
<span class="toc" ><a class="h4" href="#Construyendo-robots:-Extendiendo-la-metáfora" >Construyendo robots: Extendiendo la metáfora</a></span>
<span class="toc" ><a class="h4" href="#Las-partes-de-una-definición-recursiva" >Las partes de una definición recursiva</a></span>
<span class="toc" ><a class="h4" href="#Recursión-con-una-lista" >Recursión con una lista</a></span>
<span class="toc" ><a class="h4" href="#Recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</a></span>
<span class="toc" ><a class="h5" href="#Un-argumento-de-3-o-4" >Un argumento de 3 o 4</a></span>
<span class="toc" ><a class="h4" href="#Ejemplo-de-recursión-usando-cond" >Ejemplo de recursión usando <code>cond</code></a></span>
<span class="toc" ><a class="h4" href="#Patrones-recursivos" >Patrones recursivos</a></span>
<span class="toc" ><a class="h5" href="#Patrón-recursivo:-every" >Patrón recursivo: <em>every</em></a></span>
<span class="toc" ><a class="h5" href="#Patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></a></span>
<span class="toc" ><a class="h5" href="#Patrón-recursivo:-keep" >Patrón recursivo: <em>keep</em></a></span>
<span class="toc" ><a class="h4" href="#Recursión-sin-diferir" >Recursión sin diferir</a></span>
<span class="toc" ><a class="h4" href="#No-hay-solución-pospuesta" >No hay solución pospuesta</a></span>
<span class="toc" ><a class="h3" href="#Ejercicio-de-bucles" >Ejercicio de bucles</a></span>
<span class="toc" ><a class="h2" href="#Búsquedas-de-expresiones-regulares" >Búsquedas de expresiones regulares</a></span>
<span class="toc" ><a class="h3" href="#La-expresión-regular-para-sentence-end" >La expresión regular para <code>sentence-end</code></a></span>
<span class="toc" ><a class="h3" href="#La-función-re-search-forward" >La función <code>re-search-forward</code></a></span>
<span class="toc" ><a class="h3" href="#La-función-forward-sentence" >La función <code>forward-sentence</code></a></span>
<span class="toc" ><a class="h4" href="#Los-bucles-while" >Los bucles <code>while</code></a></span>
<span class="toc" ><a class="h4" href="#La-búsqueda-de-expresiones-regulares" >La búsqueda de expresiones regulares</a></span>
<span class="toc" ><a class="h3" href="#forward-paragraph:-una-mina-de-oro-de-funciones" ><code>forward-paragraph</code>: una mina de oro de funciones</a></span>
<span class="toc" ><a class="h4" href="#La-expresión-let*" >La expresión <code>let*</code></a></span>
<span class="toc" ><a class="h4" href="#El-bucle-while-hacia-adelante" >El bucle <code>while</code> hacia adelante</a></span>
<span class="toc" ><a class="h3" href="#Crea-tu-propio-fichero-TAGS" >Crea tu propio fichero <span class="file" >TAGS</span></a></span>
<span class="toc" ><a class="h4" href="#Construyendo-Etiquetas-en-las-fuentes-Emacs" >Construyendo Etiquetas en las fuentes Emacs</a></span>
<span class="toc" ><a class="h3" href="#Repaso" >Repaso</a></span>
<span class="toc" ><a class="h3" href="#Ejercicios-con-re-search-forward" >Ejercicios con <code>re-search-forward</code></a></span>
<span class="toc" ><a class="h2" href="#Contando:-repetición-y-regexps" >Contando: repetición y regexps</a></span>
<span class="toc" ><a class="h3" href="#La-función-COUNT-WORDS" >La función <code><code class="verbatim" >COUNT-WORDS</code></code></a></span>
<span class="toc" ><a class="h4" href="#El-error-de-espacio-en-blanco-en-COUNT-WORDS" >El error de espacio en blanco en <code><code class="verbatim" >COUNT-WORDS</code></code></a></span>
<span class="toc" ><a class="h3" href="#Cuenta-palabras-recursivamente" >Cuenta palabras recursivamente</a></span>
<span class="toc" ><a class="h3" href="#Ejercicio:-contando-puntuación" >Ejercicio: contando puntuación</a></span>
<span class="toc" ><a class="h2" href="#Contando-palabras-en-una-defun" >Contando palabras en una <code>defun</code></a></span>
<span class="toc" ><a class="h3" href="#¿Qué-contar?" >¿Qué contar?</a></span>
<span class="toc" ><a class="h3" href="#¿Qué-constituye-una-palabra-o-símbolo?" >¿Qué constituye una palabra o símbolo?</a></span>
<span class="toc" ><a class="h3" href="#La-función-count-words-in-defun" >La función <code>count-words-in-defun</code></a></span>
<span class="toc" ><a class="h3" href="#Contar-varias-defuns-en-un-fichero" >Contar varias <code>defuns</code> en un fichero</a></span>
<span class="toc" ><a class="h3" href="#Encontrar-un-fichero" >Encontrar un fichero</a></span>
<span class="toc" ><a class="h3" href="#lengths-list-file-en-detalle" ><code>lengths-list-file</code> en detalle</a></span>
<span class="toc" ><a class="h3" href="#Contar-palabras-en-defuns-en-diferentes-ficheros" >Contar palabras en <code>defuns</code> en diferentes ficheros</a></span>
<span class="toc" ><a class="h4" href="#La-función-append" >La función <code>append</code></a></span>
<span class="toc" ><a class="h3" href="#Recursivamente-cuenta-palabras-en-diferentes-ficheros" >Recursivamente cuenta palabras en diferentes ficheros</a></span>
<span class="toc" ><a class="h3" href="#Preparar-los-datos-para-mostrarlos-en-un-grafo" >Preparar los datos para mostrarlos en un grafo</a></span>
<span class="toc" ><a class="h4" href="#Ordenando-listas" >Ordenando listas</a></span>
<span class="toc" ><a class="h4" href="#Creando-una-lista-de-ficheros" >Creando una lista de ficheros</a></span>
<span class="toc" ><a class="h4" href="#Contando-definiciones-de-función" >Contando definiciones de función</a></span>
<span class="toc" ><a class="h2" href="#Leyendo-un-grafo" >Leyendo un grafo</a></span>
<span class="toc" ><a class="h3" href="#La-función-graph-body-print" >La función <code>graph-body-print</code></a></span>
<span class="toc" ><a class="h3" href="#La-función-recursive-graph-body-print" >La función <code>recursive-graph-body-print</code></a></span>
<span class="toc" ><a class="h3" href="#Necesidad-para-ejes-impresos" >Necesidad para ejes impresos</a></span>
<span class="toc" ><a class="h3" href="#Ejercicio" >Ejercicio</a></span>
<span class="toc" ><a class="h2" href="#Tu-fichero-.emacs" >Tu fichero <span class="file" >.emacs</span></a></span>
<span class="toc" ><a class="h3" href="#Fichero-de-inicialización-site-wide" >Fichero de inicialización site-wide</a></span>
<span class="toc" ><a class="h3" href="#Especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a></span>
<span class="toc" ><a class="h3" href="#Empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></a></span>
<span class="toc" ><a class="h3" href="#Modo-texto-y-auto-relleno" >Modo texto y auto relleno</a></span>
<span class="toc" ><a class="h3" href="#Alias-de-correo" >Alias de correo</a></span>
<span class="toc" ><a class="h3" href="#Indentar-modo-de-tabulaciones" >Indentar modo de tabulaciones</a></span>
<span class="toc" ><a class="h3" href="#Atajos-de-teclado" >Atajos de teclado</a></span>
<span class="toc" ><a class="h3" href="#Mapas-de-teclado" >Mapas de teclado</a></span>
<span class="toc" ><a class="h3" href="#Cargando-ficheros" >Cargando ficheros</a></span>
<span class="toc" ><a class="h3" href="#Autoloading" >Autoloading</a></span>
<span class="toc" ><a class="h3" href="#Una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></a></span>
<span class="toc" ><a class="h3" href="#Colores-X11" >Colores X11</a></span>
<span class="toc" ><a class="h3" href="#Configuraciones-misceláneas-para-un-fichero-.emacs" >Configuraciones misceláneas para un fichero <span class="file" >.emacs</span></a></span>
<span class="toc" ><a class="h4" href="#Arreglando-Atajos-de-Teclados" >Arreglando Atajos de Teclados</a></span>
<span class="toc" ><a class="h3" href="#Una-línea-modificada" >Una línea modificada</a></span>
<span class="toc" ><a class="h2" href="#Depurando" >Depurando</a></span>
<span class="toc" ><a class="h3" href="#depurar" ><code>depurar</code></a></span>
<span class="toc" ><a class="h3" href="#debug-on-entry" ><code>debug-on-entry</code></a></span>
<span class="toc" ><a class="h3" href="#debug-on-quit-y-(debug)" ><code>debug-on-quit</code> y <code>(debug)</code></a></span>
<span class="toc" ><a class="h3" href="#El-depurador-de-nivel-de-fuentes-edebug" >El depurador de nivel de fuentes <code>edebug</code></a></span>
<span class="toc" ><a class="h3" href="#Ejercicios-de-depuración" >Ejercicios de depuración</a></span>
<span class="toc" ><a class="h2" href="#Conclusión" >Conclusión</a></span>
<span class="toc" ><a class="h3" href="#Apéndice-A-La-función-the-the" >Apéndice A La función <code>the-the</code></a></span>
<span class="toc" ><a class="h3" href="#Apéndice-B-Manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</a></span>
<span class="toc" ><a class="h4" href="#La-función-current-kill" >La función <code>current-kill</code></a></span>
<span class="toc" ><a class="h4" href="#pegar" ><code>pegar</code></a></span>
<span class="toc" ><a class="h4" href="#yank-pop" ><code>yank-pop</code></a></span>
<span class="toc" ><a class="h4" href="#El-fichero-ring.el" >El fichero <span class="file" >ring.el</span></a></span>
<span class="toc" ><a class="h3" href="#Apéndice-C-Un-grafo-con-ejes-etiquetados" >Apéndice C <span id="Un grafo con ejes etiquetados" >Un grafo con ejes etiquetados</span></a></span>
<span class="toc" ><a class="h4" href="#La-varlist-print-graph" >La varlist <code>print-graph</code></a></span>
<span class="toc" ><a class="h4" href="#La-función-print-Y-axis" >La función <code>print-Y-axis</code></a></span>
<span class="toc" ><a class="h5" href="#Viaje-lateral:-Calcula-un-resto" >Viaje lateral: Calcula un resto</a></span>
<span class="toc" ><a class="h5" href="#Construye-un-elemento-del-eje-Y" >Construye un elemento del eje Y</a></span>
<span class="toc" ><a class="h5" href="#Crea-un-eje-de-la-columna-Y" >Crea un eje de la columna Y</a></span>
<span class="toc" ><a class="h5" href="#La-versión-no-demasiado-final-de-print-Y-axis" >La versión no demasiado final de <code>print-Y-axis</code></a></span>
<span class="toc" ><a class="h4" href="#La-función-print-X-axis" >La función <code>print-X-axis</code></a></span>
<span class="toc" ><a class="h5" href="#Eje-X-marca-tic" >Eje X marca tic</a></span>
<span class="toc" ><a class="h3" href="#Imprimiendo-el-grafo-completo" >Imprimiendo el grafo completo</a></span>
<span class="toc" ><a class="h5" href="#Testeando-print-graph" >Testeando <code>print-graph</code></a></span>
<span class="toc" ><a class="h5" href="#Creando-gráficas-de-números-de-palabras-y-símbolos" >Creando gráficas de números de palabras y símbolos</a></span>
<span class="toc" ><a class="h5" href="#Una-expresión-lambda:-Anonimicidad-útil" >Una expresión <code>lambda</code>: Anonimicidad útil</a></span>
<span class="toc" ><a class="h4" href="#La-función-mapcar" >La función <code>mapcar</code></a></span>
<span class="toc" ><a class="h5" href="#Otro-error-…-más-insidioso" >Otro error … más insidioso</a></span>
<span class="toc" ><a class="h5" href="#El-gráfico-impreso" >El gráfico impreso</a></span>
<span class="toc" ><a class="h3" href="#Apéndice-D-Software-Libre-y-Manuales-Libres" >Apéndice D Software Libre y Manuales Libres</a></span>
<span class="toc" ><a class="h2" href="#Appendix-E-GNU-Free-Documentation-License" >Appendix E GNU Free Documentation License</a></span>
<span class="toc" ><a class="h3" href="#0.-PREAMBLE" >0. PREAMBLE</a></span>
<span class="toc" ><a class="h3" href="#1.-APPLICABILITY-AND-DEFINITIONS" >1. APPLICABILITY AND DEFINITIONS</a></span>
<span class="toc" ><a class="h3" href="#2.-VERBATIM-COPYING" >2. VERBATIM COPYING</a></span>
<span class="toc" ><a class="h3" href="#3.-COPYING-IN-QUANTITY" >3. COPYING IN QUANTITY</a></span>
<span class="toc" ><a class="h3" href="#4.-MODIFICATIONS" >4. MODIFICATIONS</a></span>
<span class="toc" ><a class="h3" href="#5.-COMBINING-DOCUMENTS" >5. COMBINING DOCUMENTS</a></span>
<span class="toc" ><a class="h3" href="#6.-COLLECTIONS-OF-DOCUMENTS" >6. COLLECTIONS OF DOCUMENTS</a></span>
<span class="toc" ><a class="h3" href="#7.-AGGREGATION-WITH-INDEPENDENT-WORKS" >7. AGGREGATION WITH INDEPENDENT WORKS</a></span>
<span class="toc" ><a class="h3" href="#8.-TRANSLATION" >8. TRANSLATION</a></span>
<span class="toc" ><a class="h3" href="#9.-TERMINATION" >9. TERMINATION</a></span>
<span class="toc" ><a class="h3" href="#10.-FUTURE-REVISIONS-OF-THIS-LICENSE" >10. FUTURE REVISIONS OF THIS LICENSE</a></span>
<span class="toc" ><a class="h3" href="#11.-RELICENSING" >11. RELICENSING</a></span>
<span class="toc" ><a class="h2" href="#ADDENDUM:-How-to-use-this-License-for-your-documents" >ADDENDUM: How to use this License for your documents</a></span>
<span class="toc" ><a class="h3" href="#Acerca-del-Autor" >Acerca del Autor</a></span>
<span class="toc" ><a class="h2" href="#footnotes" >footnotes</a></span>
</div>
</div>
<h1>Una introducción a la programación en Emacs Lisp</h1>
<p>Esto es una <em>Introducción a la Programación en Emacs Lisp</em>, para personas que no son programadoras.</p>
<p>Traducido desde la edición <code class="verbatim" >edition-number</code>.</p>
<p>Copyright ® 2015 Libremanuals.</p>
<p>Publicado por:</p>
<p>Libremanuals, <a href="http://www.libremanuals.net/" >http://www.libremanuals.net/</a></p>
<p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; there being no Invariant Section, with the Front-Cover Texts being “A GNU Manual”, and with the Back-Cover Texts as in (a) below.  A copy of the license is included in the section entitled “GNU Free Documentation License”.</p>
<p>(a) The FSF's Back-Cover Text is: “You have the freedom to copy and modify this GNU manual.  Buying copies from the FSF supports it in developing GNU and promoting software freedom.”</p>
<h2 id="Prefacio" >Prefacio</h2>
<div class="hBody-2" >
<p>La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje de programación llamado Emacs Lisp. El código escrito en este lenguaje de programación es el software––el conjunto de instrucciones––que cuenta al ordenador qué hacer cuando tu le das comandos. Emacs está diseñado de forma que se puede escribir nuevo código en Emacs Lisp y fácilmente instalarlo como una extensión al editor.</p>
<p>(GNU Emacs se define muchas veces como un “editor extensible”, pero hace mucho más que proporcionar capacidad de edición. Es mejor referirse a Emacs como un “entorno de computación extensible”. Sin embargo, esta frase es un poco pretenciosa. Es más fácil referirse a Emacs simplemente como un editor. De hecho, cada cosa que se hace en Emacs––encontrar la fecha Maya y fases de la luna, simplificar polinomios, depurar código, administrar ficheros, leer cartas, escribir libros––todas estas actividades son maneras de editar en un sentido amplio de la palabra.)</p>
<p>Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un lenguaje de programación completo. Se puede usar Emacs Lisp del mismo modo que con cualquier otro lenguaje de programación.</p>
<p>Quizás se quiere comprender la programación; quizás se quiere extender Emacs; o quizás se quiere llegar a ser un programador. Esta introducción a Emacs Lisp está diseñada para ayudar a empezar en todo esto: para guiarse en el aprendizaje de los fundamentos de programación, y de manera más importante, para enseñar como uno mismo puede ir más allá.</p>
</div>
<h3 id="Leyendo-este-texto" >Leyendo este texto</h3>
<div class="hBody-3" >
<p>A través de este libro, se verán pequeños programas de ejemplo que se pueden ejecutar dentro de Emacs. Si se lee este documento en Info dentro de GNU Emacs, se pueden ejecutar los programas tal y como aparecen. (Esto es fácil de hacer y se explica cuando los ejemplos se presentan). Alternativamente, se puede leer esta introducción como un libro impreso mientras se está sentando con un ordenador ejecutando Emacs. (Esto es lo que me gusta hacer; me gustan los libros impresos.) Si no se está ejecutando Emacs, todavía se puede leer este libro, pero en este caso, lo mejor es tratarlo como una novela, o como una guía de viaje a un país aún no visitado: interesante, pero no es lo mismo que estar allí.</p>
<p>Gran parte de esta introducción se dedica a paseos guiados de código usado en GNU Emacs. Estos paseos están diseñados para dos propósitos: primero, familiarizarse con código real que funciona (código que se usa cada día); y, segundo, familiarizarse con cómo funciona Emacs. Es interesante ver cómo se implementa un entorno completamente operativo. También, espero que se adquiera el hábito de navegar a través del código fuente. Se puede aprender mucho comparando código de otros con el propio, ganando nuevas ideas. Tener GNU Emacs es como tener la cueva del dragón de los tesoros.</p>
<p>Además de aprender acerca de Emacs como editor y Emacs Lisp como lenguaje de programación, los ejemplos y visitas guiadas le darán una oportunidad para familiarizarse con Emacs como un entorno de programación Lisp. GNU Emacs soporta programación y provee herramientas que llegarán a usarse cómodamente, como <kbd>M-.</kbd> (la clave que invoca el comando <code>find-tag</code>). También aprendera sobre búffers y otros objetos que forman parte del entorno. Aprender estas funcionalidades de Emacs es como aprender nuevas rutas alrededor de tu hogar.</p>
<p>Finalmente, espero poder transmitir algunas habilidades para utilizar Emacs para aprender aspectos de programación que no se conocen. Con frecuencia se puede usar Emacs para ayudarte a entender un rompecabezas o para encontrar la manera de hacer algo nuevo. Este auto-descubrimiento no es solo un placer, también es una ventaja.</p>
</div>
<h3 id="Para-quien-está-esto-escrito" >Para quien está esto escrito</h3>
<div class="hBody-3" >
<p>Este texto está escrito como una introducción elemental para personas que no son programadoras. Quien ya programa, puede no estar satisfecho con este libro. La razón es que un programador puede tener que convertirse en experto leyendo manuales de referencia y este texto no está organizado como un manual de referencia.</p>
<p>Un programador experto que revisó este texto me dijo:</p>
<blockquote>
<p>Prefiero aprender desde manuales de referencia. Yo “me sumerjo” en cada párrafo y “subo a por aire” entre párrafos.</p>
<p>Cuando llego al fin de un párrafo, asumo que este asunto está hecho, finalizado, que conozco cada cosa que necesito (con la posible excepción del caso en el que el siguiente párrafo empiece hablando acerca de eso mismo en más detalle). Yo espero que un manual de referencia bien escrito no tendrá un montón de redundancia, y tendrá excelentes punteros a (un) lugar donde está la información que quiero.</p>
</blockquote>
<p>¡Esta introducción no está escrita para esta persona!</p>
<p>Primero, intento decir cada cosa al menos tres veces: primero, introducirlo; segundo, mostrarlo en contexto; y tercero, mostrarlo en un contexto diferente, o revisarlo.</p>
<p>Segundo, yo no siempre pongo toda la información acerca de un asunto en un mismo lugar, ni mucho menos en un párrafo. Desde mi punto de vista, se necesita una carga bastante fuerte en el lector. En vez de eso intento explicar solo lo que se necesita saber en el momento. (Algunas veces incluyo una pequeña información extra, para que no haya sorpresas más tarde cuando la información adicional se presente formalmente.)</p>
<p>Cuando uno lee este texto, no espera aprender todo la primera vez. Frecuentemente, solo necesita hacer un `reconocimiento' con alguno de los elementos mencionados. Mi esperanza es haber estructurado el texto y dar suficientes indicios que dejarán alerta de lo que es importante y concentrarse en ellos.</p>
<p>Es necesario “sumergirse” en algunos párrafos; no hay otro modo de leerlos. Pero yo he intentado guardar el número de tales párrafos. Este libro pretende ser como una colina asequible, en vez de una montaña abrumadora.</p>
<p>Esta introducción de <em>Programación en Emacs Lisp</em> viene acompañada de un documento complementario.  <q>El Manual de Referencia de GNU Emacs Lisp</q>. El manual de referencia tiene más detalles que esta introducción. En el manual de referencia, toda la información sobre un asunto está concentrada en un lugar. Se debe cambiar si es como el programador citado arriba. Y, por supuesto, después de haber leido esta <em>Introducción</em>, será muy útil consultar el <em>Manual de Referencia</em> al escribir programas propios.</p>
</div>
<h3 id="Historia-de-Lisp" >Historia de Lisp</h3>
<div class="hBody-3" >
<p>Lisp fué originariamente desarrollado en los 50 en el Instituto Tecnológico de Massachusetts para investigar en inteligencia artificial. El gran poder del lenguaje Lisp lo hace superior para otros propósitos también, tal como escribir comandos de edición y entornos integrados.</p>
<p>GNU Emacs Lisp está fuertemente inspirado en Maclisp, que está escrito en el MIT en los sesenta. Está en cierto modo inspirado en Common Lisp, que llega a ser un estándar en los 80. Sin embargo, Emacs Lisp es mucho más simple que Common Lisp. (La distribución estándar de Emacs contiene un fichero de extensiones opcional, <span class="file" >cl.el</span>, que añade muchas funcionalidades a Emacs Lisp.)</p>
</div>
<h3 id="Una-nota-para-principiantes" >Una nota para principiantes</h3>
<div class="hBody-3" >
<p>Aunque no se conozca GNU Emacs, este documento puede resultar útil. Sin embargo, es mejor aprender Emacs, al menos aprender a moverse alrededor de la pantalla del ordenador. Uno puede aprender de manera autodidacta cómo usar Emacs con el tutorial on-line. Para usarlo, se debe escribir <kbd>C-h t</kbd>. (Esto significa que se presione la tecla <kbd>CTRL</kbd> y la <kbd>h</kbd> al mismo tiempo, y después se presiona <kbd>t</kbd>).</p>
<p>Con frecuencia, también aludo a uno de los comandos de Emacs estándar listando las teclas que se presionan para invocar el comando y, luego dar el nombre del comando entre paréntesis, asi: <kbd>M-C-\</kbd> (<code>indent-region</code>). Esto significa invocar el comando <code>indent-region</code> presionando <kbd>M-C-\</kbd>. (Si lo desea, puede cambiar las teclas que son presionadas para invocar el comando; esto se llama <dfn>rebinding</dfn>. Véase Sección <a href="#Mapas-de-teclado" >Mapas de teclado</a>.)  La abreviación <kbd>M-C-\</kbd> significa que se presiona la tecla <kbd>META</kbd>, <kbd>CTRL</kbd>, y <kbd>\</kbd> todo al mismo tiempo. (En muchos teclados modernos la tecla <kbd>META</kbd> es etiquetada con <kbd>ALT</kbd>.) Algunas veces una combinación como esta se llama <em>keychord</em>, puesto que es similar a tocar un acorde en un piano. Si el teclado no tiene una tecla <kbd>META</kbd>, en su lugar se usa la tecla <kbd>ESC</kbd> como prefijo. En este caso <kbd>M-C-\</kbd> significa que se presiona y libera <kbd>ESC</kbd> y luego presiona la tecla <kbd>CTRL</kbd> y la tecla <kbd>\</kbd> al mismo tiempo. Pero normalmente <kbd>M-C-\</kbd> significa presionar la tecla <kbd>CTRL</kbd> junto a la tecla que está etiquetada <kbd>ALT</kbd> y, al mismo tiempo, presionar la tecla <kbd>\</kbd>.</p>
<p>Además de pulsar una sola combinación de teclas, se puede prefijar lo que se escribe con <kbd>C-u</kbd>, que es llamado el ‘argumento universal’. El atajo <kbd>C-u</kbd> pasa a ser un argumento para el comando subsiguiente. De este modo, para indentar una región de texto plano a 6 espacios, se marca la región, y entonces se presiona <kbd>C-u 6 M-C-\</kbd>. (Si no se especifica un número, Emacs pasa el número 4 al comando o de otra manera ejecuta el comando de manera diferente). Véase Sección <a href="info:emacs#Arguments" >Argumentos Numéricos</a> en <em>El Manual de GNU Emacs</em>.</p>
<p>Si se está leyendo esto en Info usando GNU Emacs, se puede avanzar a través de este documento completo solo presionando la barra de espacio, <kbd>SPC</kbd>. (Para aprender acerca de Info, presiona <kbd>C-h i</kbd> y luego selecciona Info.)</p>
<p>Una nota en terminología: cuando uso la palabra Lisp sola, con frecuencia me estoy refiriendo a los dialectos de Lisp en general, pero cuando hablo de Emacs Lisp, me estoy refiriendo a GNU Emacs Lisp en particular.</p>
</div>
<h3 id="Se-agradece" >Se agradece</h3>
<div class="hBody-3" >
<p>Estoy agradecido a todas las personas que me ayudaron con este libro. Especialmente agradecido a Jim Blandy, Noah Friedman, Jim Kingdon, Roland McGrath, Frank Ritter, Randy Smith, Richard M. Stallman, y Melissa Weisshaus. Gracias también a Philip Johnson y David Stampe por su ánimo paciente. Mis errores son míos.</p>
<p>Robert J. Chassell <a href="mailto:bob@gnu.org" >mailto:bob@gnu.org</a></p>
</div>
<h2 id="Procesamiento-de-listas" >Procesamiento de listas</h2>
<div class="hBody-2" >
<p>Para el ojo inexperto, Lisp es un lenguaje de programación extraño. En código Lisp hay paréntesis por todas partes. Algunas personas incluso reclaman que el nombre signfica ‘Lots of Isolated Silly Parentheses’ (‘Montones de Paréntesis Aislados Estúpidos’). Pero la protesta no tiene fundamento. Lisp es para procesamiento de listas, y el lenguaje de programación maneja <em>listas</em> (y listas de listas) poniéndolas entre paréntesis. Los paréntesis marcan los límites de la lista. Algunas veces una lista va precedida por un apóstrofe simple o una marca de cita, <samp>'</samp><span class="note" ><sup><a href="#1" >1</a></sup></span> Las listas son el fundamento de Lisp.</p>
</div>
<h3 id="Listas-Lisp" >Listas Lisp</h3>
<div class="hBody-3" >
<p>En Lisp, una lista como esta: <code>'(rosa violeta margarita tulipan)</code>. Esta lista es precedida por una comilla. Bien, podría estar escrita de la siguiende manera, que se parece mas al tipo de lista con la que se está familiarizado:</p>
<div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span>
  <span class="nv">violeta</span>
  <span class="nv">margarita</span>
  <span class="nv">tulipan</span><span class="p">)</span>
</pre></div>
<p>Los elementos de esta lista son los nombres de 4 flores diferentes, separados por espacios en blanco y rodeados de paréntesis, como flores en un campo con un muro de piedras alrededor de ellas.</p>
<p>Las listas pueden también tener números dentro, como en esta lista: <code>(+ 2 2)</code>. Esta lista tiene un signo más, <samp>+</samp>, seguido por dos <samp>2</samp>, cada uno separado por espacios en blanco.</p>
<p>En Lisp, tanto datos como programas están representados de la misma manera; es decir, son a la vez listas de palabras, números, u otras listas, separadas por espacios en blanco y rodeadas de paréntesis. (Puesto que un programa son datos, un programa puede fácilmente servir datos a otros programas; esta es una funcionalidad muy poderosa de Lisp.) (Incidentalmente, estas dos marcas de paréntesis <em>no</em> son listas Lisp, porque contienen <samp>;</samp> y <samp>.</samp> como marcas de puntuación.)</p>
<p>Aquí hay otra lista, esta vez con una lista dentro:</p>
<div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">tiene</span> <span class="p">(</span><span class="nv">una</span> <span class="nv">lista</span> <span class="nv">dentro</span> <span class="nv">de</span> <span class="nv">ella</span><span class="p">))</span>
</pre></div>
<p>Los componentes de esta lista son las palabras <samp>esta</samp>, <samp>lista</samp>, <samp>tiene</samp>, y la lista <samp>(una lista dentro de ella)</samp>. La lista interior se construye con las palabras <samp>una</samp>, <samp>lista</samp>, <samp>dentro</samp>, <samp>de</samp>, <samp>ella</samp>.</p>
</div>
<h4 id="Átomos-Lisp" >Átomos Lisp</h4>
<div class="hBody-4" >
<p>En Lisp, lo que hemos estado llamando palabras son en realidad <dfn>átomos</dfn>. Este término viene del significado historico de la palabra átomo, que significa ‘indivisible’. En lo que a Lisp concierne, las palabras que hemos estado usando en las listas no pueden ser divididas en pequeñas partes, sin perder su significado dentro del programa; lo mismo ocurre con números y símbolos de un caracterer como <samp>+</samp>. Por otro lado, a diferencia de un átomo, una lista puede ser dividida en pequeñas partes. Ver <a href="#car,-cdr,-cons:-Funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</a>.</p>
<p>En una lista, los átomos se separan unos de otros por espacios en blanco. Pueden ir pegados a un paréntesis.</p>
<p>Técnicamente hablando, una lista en Lisp consiste de paréntesis alrededor de átomos separados por espacios en blanco o alrededor de otras lista o alrededor de ambos átomos u otras listas. Una lista puede tener solo un átomo o no tener absolutamente nada en ella.  Una lista con nada dentro se ve así: <code>()</code>, y se llama <dfn>lista vacía</dfn>. A diferencia de cualquier otra cosa, una lista vacía es tanto un átomo, como una lista al mismo tiempo.</p>
<p>La representación impresa de átomos y listas se llaman <dfn>expresiones simbólicas</dfn> o, más concisamente, <dfn>s-expresiones</dfn>.  La palabra <dfn>expresión</dfn> por sí misma puede referir o bien a la representación impresa, o al átomo o a la lista como se maneja internamente en el ordenador. Con frecuencia, las personas usan el término <dfn>expresión</dfn> indiscriminadamente. (También, en muchos textos, la palabra <dfn>forma</dfn> se usa como un sinónimo para la expresión.)</p>
<p>Por cierto, los átomos que componen nuestro universo fueron nombrados asi cuando se pensaba que eran indivisibles; pero se ha encontrado que los átomos fisicos no son indivisibles. Las partes pueden dividir un átomo o puede fisionarse en 2 partes de igual tamaño. Los átomos físicos se nombraron prematuramente, antes de que su verdadera naturaleza fuese encontrada. En Lisp, ciertos tipos de átomos, como un array, pueden ser separados en partes; pero el mecanismo de hacer esto es diferente de el mecanismo para dividir una lista. En lo que se refiere a operaciones de lista, los átomos de una lista son indivisibles.</p>
<p>Como en español, el significado de las letras que componen un átomo Lisp difiere del significado de las letras compuestas como una palabra. Por ejemplo, la expresión <samp>ay</samp>, es completamente diferente de las dos palabras <samp>a</samp>, e <samp>y</samp>.</p>
<p>Hay muchos tipos de átomos en la naturaleza, pero solo unos pocos en Lisp: por ejemplo, <dfn>números</dfn>, tales como 37, 511, o 1729, y <dfn>símbolos</dfn>, tales como <samp>+</samp>, <samp>foo</samp>, o <samp>forward-line</samp>. Las palabras que hemos listado en los ejemplos anteriores son todos símbolos. En una conversacion cotidiana de Lisp, la palabra “átomo” no se usa con frecuencia, porque los programadores normalmente intentan ser más específicos acerca de que tipo de átomo están tratando. La programación Lisp es sobre todo de símbolos (y algunas veces números) con listas. (De ese modo, tres palabras rodeadas de paréntesis son una apropiada lista en Lisp, ya que consiste de átomos, que en este caso son símbolos, separados por espacios en blanco y cerrados por paréntesis, sin ninguna puntuacion no Lisp.)</p>
<p>Texto entre comillas––incluso frases o párrafos––son también un átomo. Aquí hay un ejemplo:</p>
<div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">incluye</span> <span class="s">&quot;texto entre comillas.&quot;</span><span class="p">)</span>
</pre></div>
<p>En Lisp, todo el texto citado incluyendo la marca de puntuación y los espacios en blanco son un solo átomo. Este tipo de átomo es llamado <dfn>string</dfn> (por ‘cadena de caracteres’) y es el tipo de cosa que es usada para mensajes que un ordenador puede imprimir para que un humano lea. Las cadenas son un tipo de átomo diferente a los números, o símbolos y se usan de manera diferente.</p>
</div>
<h4 id="Espacios-en-blanco-en-listas" >Espacios en blanco en listas</h4>
<div class="hBody-4" >
<p>La cantidad de espacios en blanco en una lista no importa. Desde el punto de vista del lenguaje Lisp,</p>
<div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span>
   <span class="nv">parece</span> <span class="nv">esto</span><span class="p">)</span>
</pre></div>
<p>es exactamente lo mismo que esto:</p>
<div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">parece</span> <span class="nv">esto</span><span class="p">)</span>
</pre></div>
<p>Ambos ejemplos muestran que en Lisp es la misma lista, la lista hecha de los símbolos <samp>esta</samp>, <samp>lista</samp>, <samp>parece</samp>, y <samp>esto</samp> en este orden.</p>
<p>Los espacios en blanco adicionales y los saltos de línea están diseñados para crear una lista más legible por humanos. Cuando Lisp lee la expresión, asimila los espacios en blanco extra (pero necesita tener al menos un espacio entre átomos en orden para contarlos aparte.)</p>
<p>Aunque parezca raro, los ejemplos que hemos visto cubren casi todo lo que aparece en las listas Lisp. Cualquier otra lista en Lisp se ve más o menos igual a uno de estos ejemplos, excepto que la lista puede ser más larga y más compleja. En resumen, una lista está entre paréntesis, una cadena está entre comillas, un símbolo parece como una palabra, y un número parece un número. (Para ciertas situaciones, corchetes, puntos y otros caracteres especiales pueden ser usados; sin embargo; iremos bastante lejos sin ellos.)</p>
</div>
<h4 id="GNU-Emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</h4>
<div class="hBody-4" >
<p>Cuando se escribe una expresión Lisp en GNU Emacs usando bien el modo de Interacción Lisp o el modo Emacs Lisp, están disponibles varios comandos para formatear la expresión Lisp, de modo que sea fácil de leer. Por ejemplo, presionando la tecla <kbd>TAB</kbd> automáticamente se indenta la línea donde se encuetra el cursor a la cantidad correcta. Un comando para indentar apropiadamente el código en una región está asociado a <kbd>M-C-\</kbd>. La indentación está diseñada de modo que se pueda ver qué elementos percecen a cada lista––los elementos de una sublista están más indentados que los elementos de una lista cerrada.</p>
<p>Además, cuando se escribe un paréntesis de cierre, Emacs momentáneamente salta el cursor atrás para hacer el matching (emparejamiento) con el paréntesis de apertura, para ver cuál es. Esto es muy útil, ya que cada lista que se escribe en Lisp debe tener sus paréntesis emparejados con sus paréntesis de apertura. (Ver Seccion <a href="info:emacs#Major-Modes" >Modos Mayores</a> en <em>El Manual de GNU Emacs</em>, para más información acerca de modos de Emacs.)</p>
</div>
<h3 id="Ejecutar-un-programa" >Ejecutar un programa</h3>
<div class="hBody-3" >
<p>Una lista en Lisp––cualquier lista––es un programa listo para ser ejecutado. Si lo ejecutas (lo que la jerga Lisp llama <dfn>evaluar</dfn>), el ordenador hará una de tres cosas: nada excepto devolverte la lista misma; enviar un mensaje de error; o, tomar el primer símbolo en la lista como un comando para hacer alguna cosa. (¡Normalmente, es lo último de estas tres cosas de lo que realmente se quiere!).</p>
<p>El apóstrofe, <code>'</code>, que se pone enfrente de algunos ejemplos de lista en secciones anteriores se llama <dfn>quote</dfn>; (citar); cuando precede a una lista, se informa a Lisp no hacer nada con la lista, mas que tomala tal como está escrita. Pero si no hay una cita precediendo la lista, el primer ítem de la lista es especial: es un comando para que el ordenador obedezca. (En Lisp, estos comandos son llamados <em>funciones</em>.) A continuación se muestra la lista no citada <code>(+ 2 2)</code>, por lo que Lisp comprende que <code>+</code> es una instrucción para hacer alguna cosa con el resto de la lista: suma los números que siguen.</p>
<p>Si estás leyendo esto dentro de GNU Emacs, aquí está como puedes evaluar una lista: coloca tu cursor justo después del paréntesis derecho de la siguiente lista y presiona <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
<p>Verás que el número <code>4</code> aparece en el área echo. (En la jerga, lo que acabas de hacer es “evaluar la lista.” El área echo es la línea en la parte inferior de la pantalla que muestra o hace “echo” del texto.) Ahora intenta la misma cosa con una lista citada: posiciona el cursor justo después de la siguiente lista y presiona <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="nv">esto</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nv">citada</span><span class="p">)</span>
</pre></div>
<p>Verás aparecer <code>(esto es una lista citada)</code> en el área echo.</p>
<p>En ambos casos, lo que estás haciendo es dar un comando al programa dentro de GNU Emacs llamado <dfn>intérprete Lisp</dfn>––dando al intérprete un comando para evaluar la expresión. El nombre del intérprete Lisp viene de la palabra para la tarea hecha por un humano que viene con el significado de una expresión––quien lo “interpreta”.</p>
<p>También se puede evaluar un átomo que no es parte de una lista––uno que no está rodeado por paréntesis; de nuevo, el intérprete Lisp traduce desde la expresión humanamente legible al lenguaje del ordenador. Pero antes de discutir esto (ver Seccion <a href="#Variables" >Variables</a>), vamos a discutir lo que el intérprete de Lisp hace cuando tu creas el error.</p>
</div>
<h3 id="Generar-un-mensaje-de-error" >Generar un mensaje de error</h3>
<div class="hBody-3" >
<p>No se preocupe si genera un mensaje de error de manera accidental, ahora daremos un comando al intérprete de Lisp que genara un mensaje de error. Esta es una accion inofensiva; y de hecho, a menudo se intenta generar mensajes de error de manera intencional. Una vez se comprende la jerga, los mensajes de error pueden ser informativos. En vez de ser llamados mensajes de “error”, deberían ser llamados mensajes de “ayuda”. Son como letreros para un viajero en un país extraño; descifrarlos puede ser duro, pero una vez comprendidos, pueden señalar el camino.</p>
<p>El mensaje de error es generado por un depurador de codigo incorporado dentro de GNU Emacs. Así se ‘entra al depurador’. Se puede salir del depurador pulsando <code>q</code>.</p>
<p>Lo que se hace es evaluar una lista que no está citada y no tiene un comando con significado como su primer elemento. Aquí hay una lista casi exactamente igual a la que acabamos de usar, pero sin la cita al inicio. Coloque el cursor a la derecha donde esta finaliza y presione <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">esto</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nf">sin</span> <span class="nv">cita</span><span class="p">)</span>
</pre></div>
<p>Se abrirá una ventana <span class="file" >*Backtrace*</span> y se verá lo siguiente:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function esto)
  (esto es una lista sin cita)
  eval((esto es una lista sin cita) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>Su cursor estará en esta ventana (puede tener que esperar unos pocos segundos antes de que sea visible). Para salir del depurador y de su ventana, presione:</p>
<pre><code class="example">q</code></pre>
<p>Por favor, ahora pulsa @kbd{q}, asi se comprueba que se puede salir del depurador. A continuacion, presione {C-x C-e} una vez mas para re-entrar.</p>
<p>Sobre la base de lo que ya sabemos, casi podemos leer este mensaje de error.</p>
<p>Leer el búffer <span class="file" >*Backtrace*</span> de abajo hacia arriba; informa lo que Emacs ha hecho. Cuando se presiona <kbd>C-x C-e</kbd>, se hace una llamada interactiva a el comando <code>eval-last-sexp</code>. <code>eval</code> es una abreviatura para ‘evaluar’ y <code>sexp</code> es una abreviatura para ‘expresión simbólica’.  El comando significa ‘evalúa la última expresión simbólica’, que es la expresión justo antes de tu cursor.</p>
<p>Cada linea anterior a esta cuenta lo que el intérprete Lisp evaluo después. La acción más reciente está en la parte superior. El búffer es llamado <span class="file" >*Backtrace*</span> ya que permite realizar un seguimiento de Emacs hacia atrás.</p>
<p>En la parte superior del búffer <span class="file" >*Backtrace*</span>, verá la línea:</p>
<pre><code class="example">Debugger entered--Lisp error: (void-function esto)</code></pre>
<p>El intérprete Lisp intentó evaluar el primer átomo de la lista, la palabra <samp>esto</samp>. Esta es la acción que generó el mensaje de error <samp>void-function esto</samp>.</p>
<p>El mensaje contiene las palabras <samp>void-function</samp> y <samp>esto</samp>.</p>
<p>La palabra <samp>function</samp> fué mencionada antes. Es una palabra muy importante. Para nuestros propósitos, podemos definirla diciendo que una <dfn>función</dfn> (<em>function</em>) es un conjunto de instrucciones para decirle al ordenador que haga alguna cosa.</p>
<p>Ahora podemos empezar a comprender el mensaje de error: <samp>void-function esto</samp>. La función (que es, la palabra <samp>esto</samp>) no tiene la definición de ningun conjunto de instrucciones que el ordenador pueda realizar.</p>
<p>La palabra ligeramente extraña, <samp>void-function</samp>, está diseñada para cubrir la forma en que Emacs Lisp lo implementa, que es cuando un símbolo no tiene una definición de función atribuido, el sitio que contiene la instruccion esta ‘vacio’ (<samp>void</samp>).</p>
<p>Por otro lado, ya que fuimos capaces de sumar 2 más 2 de manera exitosa, evaluando <code>(+ 2 2)</code>, se puede inferir que el símbolo <code>+</code> debe tener un conjunto de instrucciones que el ordenador ejecuta y estas instrucciones deben sumar los números despues del <code>+</code>.</p>
<p>Es posible evitar que Emacs entre en el depurador en casos como este. No se explicará cómo hacer esto aquí, pero se mencionará un resultado asi, porque se puede encontrar una situación similar si hay un error en algún código de Emacs que este usando. En tales casos, verá solo una línea del mensaje de error; aparecer en el área echo con el siguente aspecto:</p>
<pre><code class="example">Symbol's function definition is void:@: esto</code></pre>
<p>El mensaje aparece tan pronto se presiona una tecla, aunque sólo sea para mover el cursor.</p>
<p>Conocemos el significado de la palabra <samp>Symbol</samp>. Se refiere al primer átomo de la lista, la palabra <samp>este</samp>. La palabra <samp>function</samp> se refiere a las instrucciones que dicen al ordenador que hacer. (Técnicamente, el símbolo indica al ordenador donde encontrar las instrucciones, pero esta es una complicación que podemos ignorar por el momento.)</p>
<p>El mensaje de error puede ser comprendido: <samp>La definición del símbolo está vacía: este</samp>. El símbolo (que es, la palabra <samp>este</samp>) carece de instrucciones que el ordenador realize.</p>
</div>
<h3 id="Nombres-de-símbolos-y-definiciones-de-funciones" >Nombres de símbolos y definiciones de funciones</h3>
<div class="hBody-3" >
<p>Se puede articular otra característica de Lisp basada en lo que se discutió hace tiempo––una característica importante: un símbolo, como <code>+</code>, no es en sí mismo el conjunto de instrucciones que el ordenador realiza. En su lugar, el símbolo es usado, quizás temporalmente, como una manera de localizar la definición o conjunto de instrucciones. Lo que vemos es el nombre con el cual se pueden encontrar las instrucciones. Los nombres de las personas funcionan de la misma manera. Por ejemplo puede referirse a mi como <samp>Bob</samp>; sin embargo, no soy las letras <samp>B</samp>, <samp>o</samp>, <samp>b</samp> pero soy, o fuí, conscientemente asociado con una forma de vida particular. El nombre no soy yo, pero puede ser usado para referirme.</p>
<p>En Lisp, un conjunto de instrucciones puede ligarse a varios nombres. Por ejemplo, las instrucciones de ordenador para sumar números pueden ligarse al símbolo <code>más</code> asi como a el símbolo <code>+</code> (y se encuentran en algunos dialectos de Lisp). Entre humanos, puede referirse a <samp>Robert</samp> tan bien como <samp>Bob</samp> y con otras palabras también.</p>
<p>Por otra parte, un símbolo puede estar ligado solo con una función a la vez. De lo contrario, el ordenador estaría confundido acerca de qué definición usar. Si este fuera el caso, solo una persona en el mundo podría llamarse <samp>Bob</samp>. Sin embargo, la definición de función a la que el nombre hace referencia puede cambiarse fácilmente. (Ver Sección <a href="#Instalar-una-Definición-de-Función" >Instalar una Definición de Función</a>.)</p>
<p>Ya que Emacs Lisp es extenso, se acostumbra nombrar los símbolos de manera que pueda establecerse a que parte de Emacs pertenece la función. En consecuencia, todos los nombres de funciones relacionadas con Texinfo empiezan con <samp>texinfo-</samp> y aquellas relacionadas con la lectura de correo empiezan con <samp>rmail-</samp>.</p>
</div>
<h3 id="El-intérprete-Lisp" >El intérprete Lisp</h3>
<div class="hBody-3" >
<p>Basado en lo que se ha visto, ahora podemos empezar a entender lo que hace el intéprete de Lisp cuando mandamos a evaluar una lista. Primero, examina si hay un símbolo cita antes de la lista; si lo hay, el intérprete nos da la lista. Por otro lado, si no hay cita, el intéprete mira si el primer elemento en la lista tiene una definición de función. Si no, el intérprete imprime un mensaje de error.</p>
<p>Así es como Lisp trabaja. Simple. Hay complicaciones añadidas que veremos en un minuto, pero estos son los fundamentos. Claro está, para escribir programas Lisp, se necesita conocer como escribir definiciones de función y vincularlas a nombres, y como hacer esto sin confundirnos a nosotros mismos o al ordenador.</p>
<p>Ahora, una primera complicación. Además de las listas, el intérprete Lisp puede evaluar un símbolo no citado que no tiene paréntesis en torno a el. El intérprete Lisp intentará determinar el valor del símbolo como una <dfn>variable</dfn>.  Esta situación es descrita en el apartado de las variables. (Ver <a href="#Variables" >Variables</a>.)</p>
<p>La segunda complicación ocurre debido a que algunas funciones son inusuales y no funcionan de la manera habitual. Estas son llamadas <dfn>formas especiales</dfn>. Son usadas para trabajos especiales, como definir una función, y no son muchas de ellas. En los siguientes capítulos, se presentaran varias de las formas especiales más importantes.</p>
<p>La tercera y final complicación es la siguiente: si la función que el intérprete Lisp está buscando no es una forma especial, y si es parte de una lista, el intérprete Lisp mira si la lista tiene una lista dentro de ella. Si hay una lista dentro, el intérprete Lisp primero descubre qué hacer con la lista interior, y luego trabaja en la lista exterior. Si aún hay otra lista embebida dentro de la lista interna, trabaja en esta primero, y así. Siempre se trabaja en la lista m@'as interna primero. El interprete trabaja en la lista más interana primero, para evaluar el resultado de esta lista. El resultado puede ser usado por la expresión entre paréntesis.</p>
<p>Por lo demas, el intérprete trabaja de izquierda a derecha, desde una expresión a la siguiente.</p>
</div>
<h4 id="Compilación-de-bytes" >Compilación de bytes</h4>
<div class="hBody-4" >
<p>Otro aspecto de interpretación: el intérprete Lisp es capaz de interpretar dos tipos de entidad: código humanamente legible, en el que nos centraremos exclusivamente, y código especialmente procesado, llamado <dfn>byte compilado</dfn>, que no es humanamente legible. El código máquina compilado se ejecuta más rápido que el código humanamente legible.</p>
<p>Tu puedes transformar código legible por humanos en código compilado ejecutando uno de los comandos de compilació como <code>byte-compile-file</code>. El código compilado es normalmente almacenado en un fichero que finaliza con una extensión <span class="file" >.elc</span> en vez de una extensión <span class="file" >.el</span>. Verás ambos tipos de ficheros en el directorio <span class="file" >emacs/lisp</span>; los ficheros para leer estos tinen la extensión <span class="file" >.el</span>.</p>
<p>Como una cuestión práctica, para hacer la mayoría de las cosas como personalizar o extender Emacs, no necesitas compilar codigo; y no comentare el asunto aquí. Ver Seccion <a href="info:emacs#Byte-Compilation" >Código Compilado) en <em>El Manual de Referencia de GNU Emacs</em>, para una completa descripción de la compilacion de código.</a></p>
</div>
<h3 id="Evaluación" >Evaluación</h3>
<div class="hBody-3" >
<p>Cuando el intérprete Lisp trabaja en una expresión, el término para la actividad es llamada <dfn>evaluación</dfn>. Decimos que el intérprete ‘evalúa la expresión’. Yo he usado este término varias veces antes. La palabra proviene dee su uso en el lenguaje cotidiano, ‘para determinar el valor o la cantidad de; para estimar’ de acuerdo a <em>Webster's New Collegiate Dictionary</em>.</p>
<p>Después de evaluar una expresión, el intérprete Lisp normalmente <dfn>devuelve</dfn> el valor que el ordenador produce al llevar a cabo las instrucciones encontradas en la definición de la función, o quizás dará esta función y producirá un mensaje de error. (El intérprete puede también quedarse colgado, por así decirlo, a una función diferente o puede intentar repetir continuamente lo que está haciendo para siempre y siempre en lo que se llama un ‘bucle infinito’. Estas acciones son menos comunes; y pueden ignorarse). Más frecuentemente, el intérprete devuelve un valor.</p>
<p>Al mismo tiempo que el intérprete devuelve un valor, puede también realizar cualquier otra cosa, como mover un cursor o copiar un fichero; este otro tipo de acción es llamado <dfn>efecto secundario</dfn>.  Acciones que los humanos creen que son importantes tales como imprimir resultados, con frecuencia son, “efectos secundarios” del intérprete Lisp. La jerga puede sonar peculiar, pero resulta que es bastante fácil aprender a utilizar los efectos secundarios.</p>
<p>En resumen, evaluar una expresión simbólica normalmente causa que el intérprete devuelva un valor y tal vez llevar a cabo un efecto secundario; o al menos produce un error.</p>
</div>
<h4 id="Evaluación-de-listas-internas" >Evaluación de listas internas</h4>
<div class="hBody-4" >
<p>Si la evaluación se aplica a una lista que está dentro de una lista, la lista externa puede usar el valor devuelto por la primera evaluación como información cuando la lista externa es evaluada. Esto explica por qué las expresiones internas son evaluadas primero: los valores devueltos son usados por las expresiones externas.</p>
<p>Nosotros podemos investigar este proceso evaluando otro ejemplo adicional. Coloca tu cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre><code class="example">(+ 2 (+ 3 3))</code></pre>
<p>El número 8 aparecerá en el área echo.</p>
<p>Lo que ocurre es que el intérprete Lisp primero evalúa la expresión interna, <code>(+ 3 3)</code>, para que el valor 6 se devuelva; a continuación evalúa la expresión externa como si fuera escrita <code>(+ 2 6)</code>, que devuelve el valor 8. Puesto que no hay más expresiones entre parentesis a evaluar el intérprete imprime este valor en el área echo.</p>
<p>Ahora es fácil comprender el nombre del comandos invocado por el atajo <kbd>C-x C-e</kbd>: el nombre es <code>eval-last-sexp</code>. Las letras <code>sexp</code> son una abreviatura para ‘expresión simbólica’, y <code>eval</code> es una abreviatura para ‘evaluar’. El comando significa ‘evaluar la última expresión simbólica’.</p>
<p>Como un experimento, puedes intentar evaluar la expresión poniendo el cursor al principio de la siguiente línea inmediatamente después de la expresión, o dentro de la expresión.</p>
<p>Aquí hay otra copia de la expresión:</p>
<pre><code class="example">(+ 2 (+ 3 3))</code></pre>
<p>Si se coloca el cursor al principio de la línea en blanco que sigue inmediatamente a la expresión y presionas <kbd>C-x C-e</kbd>, aún se obtendrá el valor 8 impreso en el área echo. Ahora coloca el cursor dentro de la expresión. Si lo coloca justo después del penúltimo paréntesis (dara la impresión de situarse sobre el último paréntesis), ¡obtendrá un 6 impreso en el área echo! Esto es porque el comando evalúa la expresión <code>(+ 3 3)</code>.</p>
<p>Ahora coloque el cursor inmediatamente después de un número.  Presiona <kbd>C-x C-e</kbd> y obtendra el número en sí. En Lisp, si evalúas un número, obtienes el número en sí––así es cómo los números difieren de los símbolos. Si se evalúa una lista que inicia con un símbolo como <code>+</code>, tendrás un valor devuelto que es el resultado del ordenador tras ejecutar las instrucciones que aparecen en la definición de la función ligada a ese nombre. Si un símbolo por sí mismo es evaluado, algo diferente sucede, como veremos en la siguiente sección.</p>
</div>
<h3 id="Variables" >Variables</h3>
<div class="hBody-3" >
<p>En Emacs Lisp, un símbolo puede estar ligado a un valor como a una definición de función. Las dos son diferentes. La definición de función es un conjunto de instrucciones que el ordenador ejecuta. Por otro lado, un valor, es algo, como un número o un nombre, que puede variar (es por ello, que tal símbolo es llamado variable). El valor de un símbolo puede ser cualquier expresión en Lisp, por ejemplo un símbolo, número, lista, o cadena. Un símbolo que tiene un valor es con frecuencia llamado una <dfn>variable</dfn>.</p>
<p>Un símbolo puede tener ambos, una definición de función y un valor adjunto al mismo tiempo. O puede tener solo uno u otro. Los dos son independientes.  Esto es algo similar a la forma en que el nombre Cambridge puede referirse a la ciudad en Massachusetts y tener alguna información ligada al nombre, por ejemplo, un “gran centro de programación”.</p>
<p>Otra forma de pensar en esto es imaginar un símbolo como un mueble con cajones. La definición de función se pone en un cajón, el valor en otro, y asi sucesivamente. Lo que se pone en el cajón que contiene el valor puede ser cambiado sin afectar los contenidos del cajón que almacena la definición de función, y viceversa.</p>
<p>La variable <code>fill-column</code> ilustra un símbolo con un valor adjunto: en cada buffer de GNU Emacs, este símbolo se establece a algún valor, normalmente 72 o 70, pero algunas veces a algún otro valor. Para encontrar el valor de este símbolo, evalúalo por sí mismo. Si está leyendo esto dentro de GNU Emacs, puedes hacer esto poniendo el cursor después del símbolo y pulsar <kbd>C-x C-e</kbd>:</p>
<pre><code class="example">fill-column</code></pre>
<p>Después de presionar <kbd>C-x C-e</kbd>, Emacs imprimió el número 72 en mi área echo. Este es el valor que he establecido para <code>fill-column</code> mientras escribo esto. Puede ser diferente en tu búffer. Observe que el valor devuelto como una variable es impreso exactamente de la misma forma que el valor devuelto por una función tras ejecutar sus instrucciones.  Desde el punto de vista del intérprete Lisp, un valor devuelto es un valor devuelto. Que tipo tipo de expresión sea, deja de importar una vez que el valor se conoce.</p>
<p>Un símbolo puede tener cualquier valor ligado a él o, siendo tecnicos, se puede <dfn>bind</dfn> (enlazar) la variable a un valor: a un número, por ejemplo 72; a una cadena, <code>&quot;como esta&quot;</code>; a una lista, como <code>(abeto pino roble)</code>; podemos incluso asociar una variable a una definición de función.</p>
<p>Un símbolo puede vincularse a un valor de varias maneras. Ver Sección <a href="#Configurando-el-valor-de-una-variable" >Configurando el valor de una variable</a>, para obtener información sobre una manera de hacer esto.</p>
</div>
<h4 id="Mensaje-de-error-de-un-símbolo-sin-una-función" >Mensaje de error de un símbolo sin una función</h4>
<div class="hBody-4" >
<p>Cuando evaluamos <code>fill-column</code> para encontrar su valor como una variable, no se ponen paréntesis alrededor de la palabra. Esto se debe a que no pretendemos usarlo como un nombre de función.</p>
<p>Si <code>fill-column</code> fuese el primer o único elemento de una lista, el intérprete Lisp intentaría encontrar la definición de función adjunta. Pero <code>fill-column</code> no tiene una definición de función. Trata de evaluar esto:</p>
<pre><code class="example">(fill-column)</code></pre>
<p>Se creará un buffer <span class="file" >*Backtrace*</span> que dice:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>(Recuerda, para salir del depurador y hacer que la ventana del depurador desaparezca, presiona <kbd>q</kbd> en el buffer <span class="file" >*Backtrace*</span>.)</p>
</div>
<h4 id="Mensaje-de-error-de-un-símbolo-sin-un-valor" >Mensaje de error de un símbolo sin un valor</h4>
<div class="hBody-4" >
<p>Si intenta evaluar un símbolo que no tiene un valor asociado, recibirá un mensaje de error. Esto se puede ver experimentando con nuestra suma 2 más 2. En la siguiente expresión, pon el cursor justo después del <code>+</code>, antes del primer número 2, presiona <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
<p>En GNU Emacs 24, se creará un buffer <span class="file" >*Backtrace*</span> que dice:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+ nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>(De nuevo, se puede salir del depurador pulsando <kbd>q</kbd> en el búffer <span class="file" >*Backtrace*</span>.)</p>
<p>Esta traza inversa es diferente del primer mensaje de error que vimos, que decia, <samp>Debugger entered--Lisp error: (void-function esto)</samp>. En este caso, la función no tiene una valor como una variable; mientras en el otro mensaje de error, la función (la palabra ‘esto’) no tuvo una definición.</p>
<p>En este experimento con el <code>+</code>, lo que hicimos fué hacer que el intérprete Lisp evalúe el <code>+</code> y busque el valor de la variable en lugar de la definición de la función. Hicimos esto colocando el cursor justo después del símbolo en lugar de ponerlo al final de los parentesis que cierran la lista como hicimos antes. Como consecuencia, el intérprete Lisp evaluó la s-expresión anterior, que en este caso fué el <code>+</code> en sí.</p>
<p>Ya que <code>+</code> no tiene un valor asociado, solo la definición de función, el mensaje de error informa que el valor del símbolo como una variable estaba vacío.</p>
</div>
<h3 id="Argumentos" >Argumentos</h3>
<div class="hBody-3" >
<p>Para ver cómo la información se pasa a las funciones, veamos de nuevo nuestro viejo recurso, la suma de dos más dos. En Lisp, esto se escribe como sigue:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
<p>Si se evalúa esta expresión, el número 4 aparecerá en tu área echo. Lo que el intérprete de Lisp hace es sumar los números despues del <code>+</code>.</p>
<p>Los números sumados por <code>+</code> son llamados <dfn>argumentos</dfn> de la función <code>+</code>. Estos números son la información que se da o <dfn>pasa</dfn> a la función.</p>
<p>La palabra ‘argumento’ proviene de la forma en que se utiliza en las matemáticas y no se refiere a una disputa entre 2 personas, En su lugar, se refiere a la información entregada a la función, en este caso, al <code>+</code>. En Lisp, los argumentos de una función son los átomos o listas que siguen a la función. Los valores devueltos por la evaluación de estos átomos o listas son pasados a la función. Funciones diferentes requieren diferentes números de argumentos; algunas funciones no requieren ninguno en absoluto.<span class="note" ><sup><a href="#2" >2</a></sup></span></p>
</div>
<h4 id="Tipos-de-dato-de-los-argumentos" >Tipos de dato de los argumentos</h4>
<div class="hBody-4" >
<p>El tipo de dato que debe ser pasado a una función dependen de que tipo de información se utiliza. Los argumentos de una función como <code>+</code> deben tener valores númericos, ya que <code>+</code> suma números. Otras funciones utilizan diferentes tipos de datos para sus argumentos.</p>
<p>Por ejemplo, la función <code>concat</code> concatena o une dos o más cadenas de texto para producir una cadena. Los argumentos son cadenas. Concatenar las cadenas de caracteres <code>abc</code>, <code>def</code> produce una cadena <code>abcdef</code>. Esto puede ser visto evaluando lo siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">concat</span> <span class="s">&quot;abc&quot;</span> <span class="s">&quot;def&quot;</span><span class="p">)</span>
</pre></div>
<p>El valor producido por la evaluación de esta expresión es <code>&quot;abcdef&quot;</code>.</p>
<p>Una función como <code>substring</code> utiliza ambos una cadena y numeros como argumentos. La función devuelve una parte de la cadena, una subcadena del primer argumento. Esta función toma tres argumentos. Su primer argumento es la cadena de caracteres, el segundo y tercer argumento son números que indican el principio y el fin de la subcadena. Los números son un conteo del número de caracteres (incluyendo espacios y puntuaciones) desde el principio de la cadena.</p>
<p>Por ejemplo, si evalúa lo siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">substring</span> <span class="s">&quot;El rápido zorro marrón saltó.&quot;</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
<p>Verá <code>&quot;zorro&quot;</code> aparecer en el área echo. Los argumentos son la cadena y los dos números.</p>
<p>Tenga en cuenta que la cadena pasada a <code>substring</code> es un solo átomo a pesar de estar compuesto de varias palabras separadas por espacios. Lisp considera que cualquier cosa entre dos marcas de cita es parte de la cadena, incluyendo los espacios. Se puede pensar en la función <code>substring</code> como una tipo de ‘acelerador de particulas’ ya que toma un átomo de otro modo indivisible y extrae una parte. Sin embargo, <code>substring</code> solo es capaz de extraer una subcadena de un argumento que es una cadena, no de otro tipo de átomo por ejemplo un número o símbolo.</p>
</div>
<h4 id="Un-argumento-como-el-valor-de-una-variable-o-lista" >Un argumento como el valor de una variable o lista</h4>
<div class="hBody-4" >
<p>Un argumento puede ser un símbolo que devuelve un valor al ser evaluado. Por ejemplo, evaluar el símbolo <code>fill-column</code> en si, devuelve un número. Este número se puede utilizar en una suma.</p>
<p>Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="nv">fill-column</span><span class="p">)</span>
</pre></div>
<p>El valor será dos mas el número que se obtiene al evaluar solamente <code>fill-column</code>. En mí caso, es 74, porque mi valor de <code>fill-column</code> es 72.</p>
<p>Como acabamos de ver, un argumento puede ser un símbolo que devuelve un valor cuando se evalúa. Además, un argumento puede ser una lista que devuelve un valor cuando se evalúa. Por ejemplo, en la siguiente expresión, los argumentos de la función <code>concat</code> son las cadenas <code>&quot;Los&quot;</code> y <code>&quot; zorros rojos.&quot;</code> y la lista <code>(number-to-string (+ 2 fill-column))</code>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">concat</span> <span class="s">&quot;Los &quot;</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="nv">fill-column</span><span class="p">))</span> <span class="s">&quot; zorros rojos.&quot;</span><span class="p">)</span>
</pre></div>
<p>Si se evalúa esta expresión––y si, como con mi Emacs, <code>fill-column</code> se evalúa a 72––aparecerá <code>&quot;Los 74 zorros rojos.&quot;</code> en el área echo. (Tenga en cuenta que deben poner espacios después de la palabra <samp>Los</samp> y antes de la palabra <samp>rojos</samp> que aparecerán en la cadena final. La función <code>number-to-string</code> convierte el entero que devuelve la función suma a una cadena. <code>number-to-string</code> también se conoce como <code>int-to-string</code>.)</p>
</div>
<h4 id="Número-variable-de-argumentos" >Número variable de argumentos</h4>
<div class="hBody-4" >
<p>Algunas funciones, como <code>concat</code>, <code>+</code>, o <code>*</code>, toman cualquier número de argumentos. (El <code>*</code> es el símbolo para la multiplicacion.) Esto puede verse evaluando cada una de las siguientes expresiones de la forma habitual. Lo que verás en el área echo se imprime en este texto después de <samp>⇒</samp>, que se puede leer como ‘evaluar a’.</p>
<p>En el primer conjunto, las funciones no tienen argumentos:</p>
<pre><code class="example">(+)       ⇒ 0

(*)       ⇒ 1</code></pre>
<p>En este conjunto, las funciones tienen un argumento cada una:</p>
<pre><code class="example">(+ 3)     ⇒ 3

(* 3)     ⇒ 3</code></pre>
<p>En este conjunto, las funciones tienen tres argumentos cada una:</p>
<pre><code class="example">(+ 3 4 5) ⇒ 12

(* 3 4 5) ⇒ 60</code></pre>
</div>
<h4 id="Usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</h4>
<div class="hBody-4" >
<p>Cuando a una función se le pasa un argumento del tipo incorrecto, el interpréte Lisp produce un mensaje de error. Por ejemplo, la función <code>+</code> espera que los valores de sus argumentos sean números. Como un experimento podemos pasar el símbolo citado <code>hola</code> en lugar de un número. Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="ss">&#39;hola</span><span class="p">)</span>
</pre></div>
<p>Al hacer esto se generará un mensaje de error. Lo qué ha ocurrido es que <code>+</code> ha intentado sumar el 2 al valor devuelto por <code>'hola</code>, pero el valor devuelto por <code>'hola</code> es el símbolo <code>hola</code>, no un número. Solo los números se pueden sumar. Por tanto <code>+</code> no pudo llevar a cabo su suma.</p>
<p>Se creará e ingresara a un búffer <span class="file" >*Backtrace*</span> que dice:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p hola)
  +(2 hola)
  eval((+ 2 (quote hola)) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>Como de costumbre, el mensaje de error intenta ser útil y tiene sentido después de aprender cómo leerlo.<span class="note" ><sup><a href="#3" >3</a></sup></span></p>
<p>La primera parte del mensaje de error es sencilla; dice <samp>wrong type argument</samp> (tipo de argumento incorrecto). A continueción viene la misteriosa palabra tecnica <samp>number-or-marker-p</samp>. Esta palabra está intentando decirte qué tipo de argumento espera <code>+</code>.</p>
<p>El símbolo <code>number-or-marker-p</code> dice que el intérprete Lisp está intentando determinar si la información presentada (el valor del argumento) es un número o una marca (un objeto especial que representa una posición de buffer). Lo que hace es probar si se le estan dando numeros a sumar a <code>+</code>. También chequea si el argumento es algo llamado marcador, que es una caracteristica específica de Emacs Lisp. (En Emacs, las ubicaciones en un búffer se registran como marcadores. Cuando se establece la marca con el comando <kbd>C-@</kbd> o <kbd>C-SPC</kbd>, su posición se guarda como un marcador. La marca puede ser considerada como un número––el número de caracteres es la ubicacion desde el comienzo del búffer.)  En Emacs Lisp, <code>+</code> se puede utilizar para sumar el valor numérico de los marcadores como números.</p>
<p>La <samp>p</samp> en <code>number-or-marker-p</code> es la encarnación de una práctica iniciada en los primeros días de la programación Lisp. La <samp>p</samp> significa ‘predicado’. En la jerga usada por los primeros investigadores de Lisp, un predicado se refiere a una función para determinar si alguna propiedad es verdadera o falsa. Entonces la <samp>p</samp> nos dice que <code>number-or-marker-p</code> es el nombre de una función que determina si el argumento dado es un número o una marca. Otros símbolos Lisp que finalizan en <samp>p</samp> incluyen <code>zerop</code>, una función que comprueba si su argumento tienen el valor de cero, y <code>listp</code>, una función que comprueba si su argumento es una lista.</p>
<p>Finalmente, la última parte del mensaje de error es el símbolo <code>hola</code>. Este es el valor del argumento dado a <code>+</code>. Si a la suma se le hubiese pasado el tipo correcto de objeto, el valor habría sido un número, como 37, en lugar de un símbolo como <code>hola</code>. Pero entonces no habrías obtenido el mensaje de error.</p>
</div>
<h4 id="La-función-message" >La función <code>message</code></h4>
<div class="hBody-4" >
<p>Al igual que <code>+</code>, la función <code>message</code> toma un número variable de argumentos. Se utiliza para enviar mensajes al usuario y es tan útil que vamos a describirla.</p>
<p>Se imprime un mensaje en el área echo. Por ejemplo, puede imprimir un mensaje en su área echo evaluando la siguiente lista:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;¡Este mensaje aparece en el área echo!&quot;</span><span class="p">)</span>
</pre></div>
<p>Toda la cadena entre comillas dobles es un unico argumento y se imprime <i>en su totalidad</i>. (Note que en este ejemplo, el mensaje en sí aparece en el área echo entre comillas dobles; esto se debe a que ves el valor devuelto por la función <code>message</code>. En la mayoría de programas que escribiras, el texto será impreso en el área echo como un efecto secundario de <code>message</code>, sin las comillas. Ver Sección <a href="#Un-multiply-by-seven-interactivo" >Un <code>multiply-by-seven</code> interactivo</a> en detalle, para un ejemplo de esto.)</p>
<p>Sin embargo, si hay un <samp>%s</samp> en la cadena de caracteres citada, la función <code>message</code> no imprime el <samp>%s</samp> como tal, pero mira el siguente argumento a continuacion de la cadena. Se evalúa el segundo argumento e imprime el valor en la ubicación de la cadena donde está el <samp>%s</samp>.</p>
<p>Puede ver esto colocando el cursor después de la siguiente expresión y presionar <kbd>C-x C-e</kbd>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;El nombre de este búffer es: %s.&quot;</span> <span class="p">(</span><span class="nf">buffer-name</span><span class="p">))</span>
</pre></div>
<p>En Info, <code>&quot;El nombre de este búffer es: *info*.&quot;</code> aparecerá en el área echo. La función <code>buffer-name</code> devuelve el nombre del búffer como una cadena, que la función <code>message</code> inserta en lugar de <code>%s</code>.</p>
<p>Para imprimir un valor como un entero, utiliza <samp>%d</samp> de la misma forma que <samp>%s</samp>. Por ejemplo, para imprimir un mensaje en el área echo que indique el valor de <code>fill-column</code>, evalúa lo siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;El valor de fill-column es %d.&quot;</span> <span class="nv">fill-column</span><span class="p">)</span>
</pre></div>
<p>En mi sistema, cuando evalúo esta lista, <code>&quot;El valor de fill-column es 72&quot;</code> aparece en mi área echo<span class="note" ><sup><a href="#4" >4</a></sup></span>.</p>
<p>Si hay más de un <samp>%s</samp> en la cadena citada, el valor del primer argumento después de la cadena citada se imprime en la posición del primer <samp>%s</samp> y el valor del segundo argumento se imprime en la posición del segundo <samp>%s</samp>, y así sucesivamente.</p>
<p>Por ejemplo, si se evalúa lo siguiente,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;¡Hay %d %s en la oficina!&quot;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">fill-column</span> <span class="mi">14</span><span class="p">)</span> <span class="s">&quot;elefantes rosas&quot;</span><span class="p">)</span>
</pre></div>
<p>Un mensaje un poco caprichoso aparecerán en el área echo. En mi sistema dice <code>&quot;¿Hay 58 elefantes rosas en la oficina!&quot;</code></p>
<p>Se evalúa la expresión <code>(- fill-column 14)</code> y el número resultante se inserta en lugar del <samp>%d</samp>; y la cadena entre comillas dobles, <code>&quot;elefantes rosas&quot;</code>, se trata como un solo argumento y se inserta en lugar del <samp>%s</samp>. (Es decir, una cadena entre comillas dobles se evalúa así misma, como un número.)</p>
<p>Por último, aquí está un ejemplo algo complejo que no solo ilustra el cálculo de un número, también muestra como se puede usar una expresión dentro de una expresión para generar el texto que sustituira el <samp>%s</samp>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Él vió %d %s&quot;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">fill-column</span> <span class="mi">36</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">concat</span> <span class="s">&quot;rojos &quot;</span>
                 <span class="p">(</span><span class="nf">substring</span>
                  <span class="s">&quot;Los rápidos zorros marrones saltaron.&quot;</span> <span class="mi">12</span> <span class="mi">18</span><span class="p">)</span>
                 <span class="s">&quot; saltando.&quot;</span><span class="p">))</span>
</pre></div>
<p>En este ejemplo, <code>message</code> tiene tres argumentos: la cadena, <code>&quot;Él vió %d %s&quot;</code>, la expresión, <code>(- fill-column 32)</code>, y la expresion a partir de la función <code>concat</code>. El valor resultante de la evaluación de <code>(- fill-column 32)</code> se inserta en lugar del <samp>%d</samp>; y el valor devuelto por la expresión que inicia con <code>concat</code> se inserta en lugar del <samp>%s</samp>.</p>
<p>Cuando <code>fill-column</code> es 70 y se evalúa la expresión, aparecera el mensaje <code>&quot;Él vió 38 rojos zorros saltando.&quot;</code> en tu área echo.</p>
</div>
<h3 id="Configurando-el-valor-de-una-variable" >Configurando el valor de una variable</h3>
<div class="hBody-3" >
<p>Hay varias formas de asignar un valor a una variable. Una de ellas es utilizar la función <code>set</code> o la función <code>setq</code>.  Otra forma es utilizar <code>let</code> (vease Seccion <a href="#let" ><code>let</code></a>). (La jerga para este proceso es <dfn>bind</dfn> (ligar) una variable a un valor.)</p>
<p>Las siguientes secciones no solo describen cómo operan <code>set</code> y <code>setq</code>, también ilustran como se pasan los argumentos.</p>
</div>
<h4 id="Usando-set" >Usando <code>set</code></h4>
<div class="hBody-4" >
<p>Para establecer el valor del símbolo <code>flores</code> a la lista <code>'(rosa violeta margarita tulipan)</code>, evalúa la siguiente expresión colocando el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">set</span> <span class="ss">&#39;flores</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</pre></div>
<p>La lista <code>(rosa violeta margarita tulipan)</code> aparecerá en el área echo. Esto es <em>devuelto</em> por la función <code>set</code>. Como efecto secundario, el símbolo <code>flores</code> esta ligado a la lista; es decir, el símbolo <code>flores</code>, puede verse como una variable, que entrega la lista como su valor. (Por cierto, este proceso, ilustra como un efecto secundario al intérprete Lisp, estableciendo el valor, puede ser el principal efecto en el que los humanos estamos interesados. Esto se debe a que cada función Lisp debe devolver un valor si no obtiene un error, pero solo tendrá un efecto secundario si está diseñado para tener uno.)</p>
<p>Después de evaluar la expresión <code>set</code>, se puede evaluar el símbolo <code>flores</code> y ha de devolver el valor que acaba de establecer. Aquí está el símbolo. Coloca el cursor al final de este y presiona <kbd>C-x C-e</kbd>.</p>
<div class="highlight"><pre><span></span><span class="nv">flores</span>
</pre></div>
<p>Al evalúar <code>flores</code>, aparece la lista <code>(rosa violeta margarita tulipan)</code> en el área echo.</p>
<p>Por cierto, si se evalúa <code>'flores</code>, la variable con una cita frente a ella, lo que verá en el área echo es el símbolo en sí mismo: <code>flores</code>. Aquí está el símbolo citado, para que pueda probar esto:</p>
<div class="highlight"><pre><span></span><span class="ss">&#39;flores</span>
</pre></div>
<p>También tenga en cuenta, que cuando se utiliza <code>set</code>, es necesario citar ambos argumentos de <code>set</code>, a menos que los quiera evaluar. Puesto que no queremos evaluar, ni la variable <code>flores</code>, ni la lista <code>(rosa violeta margarita tulipan)</code>, ambos se citan. (Cuando se utiliza <code>set</code> sin citar su primer argumento, el primer argumento se evalúa antes de realizar cualquier otra cosa. Si hizo esto y <code>flores</code> no tenía ya un valor, otendria un mensaje de error con el <samp>Valor de símbolo como variable vacío</samp>; por otro lado, si <code>flores</code> regreso un valor después de ser evaluado, <code>set</code> intentaría establecer el valor que fue devuelto. Hay situaciones donde esto es justo lo que la función a de hacer, pero estas situaciones son poco frecuentes.)</p>
</div>
<h4 id="Usando-setq" >Usando <code>setq</code></h4>
<div class="hBody-4" >
<p>Como una cuestión práctica, casi siempre se cita el primer argumento de <code>set</code>. La combinación de <code>set</code> y un primer argumento citado es tan común que tiene nombre propio: la forma especial <code>setq</code>. Esta forma especial es igual a <code>set</code> excepto que el primer argumento es citado automáticamente, por lo que no necesita escribir la marca de cita. También, para mayor comodidad, <code>setq</code> permite asignar varias variables diferentes a diferentes valores, todo en una expresión.</p>
<p>Para establecer el valor de la variable <code>carnívoros</code> a la lista <code>'(leon tigre leopardo)</code> usando <code>setq</code>, se utiliza la siguiente expresión:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">carnivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">))</span>
</pre></div>
<p>Esto es exactamente igual que usar <code>set</code> excepto que el primer argumento se cita automáticamente por <code>setq</code>. (La <samp>q</samp> en <code>setq</code> significa <code>quote</code>.)</p>
<p>Con <code>set</code>, la expresión que se vería es:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">set</span> <span class="ss">&#39;carnivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">))</span>
</pre></div>
<p>Además, <code>setq</code> se puede utilizar para asignar diferentes valores a diferentes variables. El primer argumento se une a al valor del segundo argumento, el tercer argumento se une a al valor del cuarto argumento, y así sucesivamente. Por ejemplo, podría utilizar lo siguiente para asignar una lista de árboles al símbolo <code>arboles</code> y una lista de herbívoros al símbolo <code>herbivoros</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">arboles</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
      <span class="nv">herbivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">))</span>
</pre></div>
<p>(La expresión podría también haber estado en una sola línea, pero podría no caber en una página; y a los humanos les resulta más fácil leer listas con un formato agradable.)</p>
<p>Aunque he estado usando el término ‘asignar’, hay otra forma de pensar respecto a el funcionamiento de <code>set</code> y <code>setq</code>; y consiste en decir que <code>set</code> y <code>setq</code> crean un símbolo que <em>apunta</em> a la lista. Esta ultima forma de pensar es muy común y en los proximos capítulos deberiamos encontrar al menos un símbolo con un ‘puntero’ como parte de su nombre. El nombre es elegido porque el símbolo tiene un valor, específicamente una lista, unida a el; o, expresado de otra manera, el símbolo se ajusta para “apuntar” a la lista.</p>
</div>
<h4 id="Contando" >Contando</h4>
<div class="hBody-4" >
<p>He aquí un ejemplo que muestra cómo utilizar <code>setq</code> en un contador. Es posible usar esto para contar cuantas veces una parte de un programa se repite. En primer lugar establesca una variable a cero; a continuación suma uno al número cada vez que el programa se repita. Para ello, se necesita una variable que sirva como un contador, y dos expresiones: una expresión <code>setq</code> inicial que asigna la variable contador a cero; y una segunda expresión <code>setq</code> que incrementa el contador cada vez se evalua.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">contador</span> <span class="mi">0</span><span class="p">)</span>                <span class="c1">; Llamemos a esto el inicializador.</span>

<span class="p">(</span><span class="k">setq</span> <span class="nv">contador</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">contador</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">; Este es el incremento.</span>

<span class="nv">contador</span>                         <span class="c1">; Este es el contador.</span>
</pre></div>
<p>(El texto que sigue al <samp>;</samp> son los comentarios. Véase Sección <a href="#Cambiar-una-definición-de-función" >Cambiar una definición de función</a>.)</p>
<p>Si evalúas la primera de estas expresiones, el inicializador, <code>(setq contador 0)</code>, y luego evalúas la tercera expresión, <code>contador</code>, el número <code>0</code> aparecerá en el área echo. Si a continuación se evalúa la segunda expresión, el incremento, <code>(setq contador (+ contador 1))</code>, el contador tendrá el valor 1. Así que si evalúas de nuevo <code>contador</code>, el número <code>1</code> aparecerá en el área echo. Cada vez que se evalúa la segunda expresión, el valor del contador será incrementado.</p>
<p>Al evalúar el incremento, <code>(setq contador (+ contador 1))</code>, el intérprete Lisp evalúa en primer lugar la lista interna; esto es la suma. Con el fín de evaluar esta lista, se debe evaluar la variable <code>contador</code> y el número <code>1</code>. Cuando evalúa la variable <code>contador</code>, se recibe su valor actual. Se pasa este valor y el número <code>1</code> a <code>+</code> que los suma. La suma se devuelve como el valor de la list interior y pasa a <code>setq</code> que establece la variable <code>contador</code> a este nuevo valor. Por lo tanto, el valor de la variable <code>contador</code>, cambia.</p>
</div>
<h3 id="Resumen" >Resumen</h3>
<div class="hBody-3" >
<p>Aprender Lisp es como subir una colina en la que la primera parte es la mas empinada. Ahora has subido la parte más difícil; lo que queda se vuelve más fácil a medida que avanzas hacia adelante.</p>
<p>En resumen,</p>
<ul>
<li><p>Los programas Lisp se componen de expresiones, que son listas o átomos individuales.</p>
</li>
<li><p>La listas se componen de cero o más átomos o listas internas, separadas por espacios en blanco y rodeadas por paréntesis. Una lista puede estar vacía.</p>
</li>
<li><p>Los átomos son símbolos de varios caracteres, como <code>forward-paragraph</code>, símbolos de un solo caracter como <code>+</code>, cadenas de caracteres entre comillas dobles, o números.</p>
</li>
<li><p>Un número se evalúa a sí mismo.</p>
</li>
<li><p>Una cadena entre comillas dobles también se evalúa a sí misma.</p>
</li>
<li><p>Cuando se evalúa un símbolo a sí mismo, se devuelve su valor.</p>
</li>
<li><p>Cuando se evalúa una lista, el intérprete Lisp mira el primer símbolo en la lista y luego la definición de función asociada a ese símbolo. A continuación, las instrucciones en la definición de función se llevan a cabo.</p>
</li>
<li><p>Una marca de cita, <code>'</code>, le indica al intérprete Lisp que devuelva la siguiente expresión como esta escrita, y no la evalúa como lo haria si la cita no estuviera alli.</p>
</li>
<li><p>Los argumentos son la información que se pasa a una función. Los argumentos de una función se calculan evaluando el resto de los elementos de la lista de los que la función es el primer elemento.</p>
</li>
<li><p>Una función siempre devuelve un valor cuando se evalúa (a menos que obtenga un error); además, también se puede llevar a cabo algun tipo de acción llamado “efecto secundario”. En muchos casos, el propósito principal de una función es crear un efecto secundario.</p>
</li>
</ul>
</div>
<h3 id="Ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<p>Unos ejercicios sencillos:</p>
<ul>
<li><p>Generar un mensaje de error evaluando un símbolo apropiado que no está entre paréntesis.</p>
</li>
<li><p>Generar un mensaje de error evaluando un símbolo apropiado que está entre paréntesis.</p>
</li>
<li><p>Crear un contador que se incrementa en dos en lugar de uno.</p>
</li>
<li><p>Escribe una expresión que imprima un mensaje en el área eco cuando se evalua.</p>
</li>
</ul>
</div>
<h2 id="Practicando-evaluación" >Practicando evaluación</h2>
<div class="hBody-2" >
<p>Antes de aprender como escribir una definición de función en Emacs Lisp, es útil gastar un poco de tiempo evaluando diversas expresiones que ya han sido escritas. Estas expresiones serán listas con funciones como su primer (y con frecuencia único) elemento. Dado que algunas de las funciones asociadas con búffers son a la vez simples e interesantes, vamos a iniciar con estas. En esta sección, vamos a evaluar algunas de este tipo. En otra sección, estudiaremos el código de varias otras funciones relacionadas con búffers, para ver la forma cómo fueron escritas.</p>
<p><i>Siempre que proporciona un comando de edición</i> a Emacs Lisp, como el comando para mover el cursor o para desplazarse por la pantalla, <i>se está evaluando una expresión,</i> de la cual el primer elemento es una función. <i>Así es cómo funciona Emacs</i>.</p>
<p>Al presionar las teclas, se provoca una evaluacion de parte del intérprete Lisp que devuelve resultados. Incluso escribir texto plano implica evalúar una función Emacs Lisp, en este caso, se utiliza <code>self-insert-command</code>, que simplemente inserta el caracter escrito.  Las funciones que se evalúan presionando atajos de teclado se llaman funciones <dfn>interactive</dfn>, o <dfn>comandos</dfn>; como crear una función interactive será ilustrado en el capítulo sobre cómo escribir definiciones de funciones. Ver <a href="#Crear-una-Función-Interactiva" >Crear una Función Interactiva</a>.</p>
<p>Además de presionar comandos de teclado, hemos visto una segunda manera de evaluar una expresión: colocar el cursor después de una lista y presionar <kbd>C-x C-e</kbd>. Esto es lo que se hará en el resto de esta sección. Hay otras maneras de evaluar una expresión; que serán descritas cuando llegemos a ellas.</p>
<p>Ademas de utilizarce para prácticar la evaluación, las funciones mostradas en las siguientes secciones son importantes por derecho propio. Un estudio de estas funciones deja claro la distinción entre búffers y ficheros, cómo cambiar a un búffer, y como determinar una ubicación dentro de ella.</p>
</div>
<h3 id="Nombres-de-búffer" >Nombres de búffer</h3>
<div class="hBody-3" >
<p>Las dos funciones, <code>buffer-name</code> y <code>buffer-file-name</code>, muestran la diferencia entre un fichero y un búffer. Cuando se evalúa la siguiente expresión, <code>(buffer-name)</code>, el nombre del buffer aparece en el area eco. Al evaluar <code>(buffer-file-name)</code>, el nombre del fichero al que se relaciona el búffer aparece en el área echo. Por lo general, el nombre devuelto por <code>(buffer-name)</code> es el mismo que el nombre del fichero al que hace referencia, y el nombre devuelto por <code>(buffer-file-name)</code> es la ruta completa del fichero.</p>
<p>Un fichero y un búffer son dos entidades diferentes. Un fichero es la información grabada de manera permanente en el ordenador (a menos que se elimine). Un búffer, por otro lado, es la información dentro de Emacs que desaparecerá al final de la sesión de edición (o cuando matas el búffer). Por lo general, un búffer contiene información que se ha copiado desde un fichero; decimos que el búffer está <dfn>visitando</dfn> este fichero. Esta copia es la que se trabaja y modifica. Los cambios al búffer no cambian el fichero, hasta ser guardados. Al guardar el búffer, el búffer se copia en el fichero y por lo tanto se guarda de forma permanente.</p>
<p>Si está leyendo esto dentro de GNU Emacs dentro de Info, puede evaluar cada una de las siguientes expresiones colocando el cursor después de estas y pulsando <kbd>C-x C-e</kbd>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">buffer-name</span><span class="p">)</span>

<span class="p">(</span><span class="nf">buffer-file-name</span><span class="p">)</span>
</pre></div>
<p>Cuando hago esto en Info, el valor devuelto para la evaluación de <code>(buffer-name)</code> es <span class="file" >&quot;*info*&quot;</span>, y el valor devuelto por evaluar <code>(buffer-file-name)</code> es <span class="file" >nil</span>.</p>
<p>Por otro lado, mientras escribo este documento, el valor devuelto por la evaluación de <code>(buffer-name)</code> es <span class="file" >&quot;introduction.texinfo&quot;</span>, y el valor devuelto por la evaluación de <code>(buffer-file-name)</code> es <span class="file" >&quot;/gnu/work/intro/introduction.texinfo&quot;</span>.</p>
<p>El primero es el nombre del búffer y el segundo es el nombre del fichero. En Info, el nombre del búffer es <span class="file" >&quot;*info*&quot;</span>. Info no apunta a ningún fichero, por lo que el resultado de evaluar <code>(buffer-file-name)</code>] es <span class="file" >nil</span>. El símbolo <code>nil</code> proviene del latin, significa ‘nada’; en este caso, significa que el búffer no está asociado con ningun fichero. (En Lisp, <code>nil</code> también se utiliza con el significado de ‘falso’ y es sinómino para lista vacía, <code>()</code>.)</p>
<p>Al escribir esto, el nombre de mi búffer es <span class="file" >&quot;introduction.texinfo&quot;</span>. El nombre del fichero al que apunta es <span class="file" >&quot;/gnu/work/intro/introduction.texinfo&quot;</span>.</p>
<p>(En las expresiones, los paréntesis le indican al intérprete Lisp tratar a <code>buffer-name</code> y <code>buffer-file-name</code> como funciones; sin los paréntesis, el intérprete intentaría evaluar los símbolos como variables. Véase la Sección <a href="#Variables" >Variables</a>.)</p>
<p>A pesar de la distinción entre ficheros y búffers, con frecuencia encontrara personas referirse a un fichero cuando quieren un búffer y vice-versa. De hecho, la mayoría de la gente dice, “Estoy editando un fichero,” en lugar de decir, “Estoy editando un búffer que pronto voy a guardar en un fichero.” Esto casi siempre queda claro a partir del contexto de lo que la gente dice. No obstante, Al tratar con programas de ordenador, es importante mantener la distinción en mente, ya que el ordenador no tan inteligente como una persona.</p>
<p>Por cierto, la palabra ‘búffer’, viene del significado de la palabra como un cojín que amortigua la fuerza de una colisión. En los primeros ordenadores, un búffer amortiguaba la interacción entre los ficheros y la unidad central de procesamiento de la computadora. Los tambores o cintas que contenian un fichero y la unidad de procesamiento eran piezas de equipamiento muy diferentes entre si, trabajando a sus propias velocidades, por rachas. El búffer hizo posible que ambos trabajaran juntos de manera efectiva. Con el tiempo, el búffer pasó de ser un intermediario, a un lugar de almacenamiento temporalmente, donde se realiza el trabajo. Esta transformación se parace bastante a la de un pequeño puerto que se convierte en una gran ciudad: una vez fué el lugar donde la carga era depositada temporalmente antes de ser cargada en los barcos; despues se convirtio en un centro comercial y cultural por derecho propio.</p>
<p>No todos los búffers están asociados con ficheros. Por ejemplo, el búffer <span class="file" >*scratch*</span> no visita ningun fichero. Del mismo modo, un búffer <span class="file" >*Help*</span> no está asociado a ningun fichero.</p>
<p>En los viejos tiempos, cuando se carecia de un fichero <span class="file" >~/.emacs</span> y se iniciava una sesión Emacs escribiendo unicamente el comando <code>emacs</code>, sin nombrar ningun fichero, Emacs iniciaba con el búffer <span class="file" >*scratch*</span> visible. Hoy en día, vera una pantalla de vienvenida. Puede seguir uno de los comandos sugeridos en dicha pantalla, visitar un fichero, o presionar la barra espaciadora para llegar al búffer <span class="file" >*scratch*</span>.</p>
<p>Si cambia al búffer <span class="file" >*scratch*</span>, escriba <code>(buffer-name)</code>, coloque el cursor al final de la expresión, y presione <kbd>C-x C-e</kbd> para evaluar la expresión. El nombre <code>*scratch*</code> será devuelto y aparecerá en el área echo. <code>*scratch*</code> es el nombre del búffer. Al escribir y evaluar <code>(buffer-file-name)</code> en el búffer <span class="file" >*scratch*</span>, aparecerá <code>nil</code> en el área echo, igual que cuando evalúa <code>(buffer-file-name)</code> en Info.</p>
<p>Por cierto, si se encuentra en el búffer <span class="file" >*scratch*</span> y quiere que el valor devuelto por una expresión aparesca en el búffer en sí y no en el área echo, presione <kbd>C-u C-x C-e</kbd> en lugar de <kbd>C-x C-e</kbd>. Esto causa que el valor devuelto aparezca después de la expresión. El búffer se verá así:</p>
<pre><code class="example">(buffer-name)&quot;*scratch*&quot;</code></pre>
<p>No se puede hacer esto en Info ya que Info es de solo lectura y no se permitirá cambiar el contenido del búffer. Pero puedes hacer esto en cualquier búffer que se pueda editar; y cuando se escribe código o documentación (como este libro), esta función es muy útil.</p>
</div>
<h3 id="Obtención-de-Búffers" >Obtención de Búffers</h3>
<div class="hBody-3" >
<p>La función <code>buffer-name</code> devuelve el <em>nombre</em> del búffer; para obtener el búffer <em>en sí</em>, se necesita una función diferente: la función <code>current-buffer</code>. Si utiliza esta función en el código, lo que se obtiene es el búffer en sí.</p>
<p>Un nombre y el objeto o entidad a la que se refiere el nombre son diferentes entre si. Tu no eres tu nombre, eres una persona a la que se refieren los demas por tu nombre. Si pides hablar con Jorge y alguien te entrega una tarjeta con las letras <samp>J</samp>, <samp>o</samp>, <samp>r</samp>, <samp>g</samp>, y <samp>e</samp> estritas, podrias divertirte, pero no estarías satisfecho. No quieres hablar con el nombre, sino con la persona a la que se refiere el nombre. Un búffer es similar: el nombre del búffer scratch es <span class="file" >*scratch*</span>, pero el nombre no es el búffer. Para obtener un búffer en sí, es necesario utilizar una función como <code>current-buffer</code>.</p>
<p>Sin embargo, hay una ligera complicación: si evalúas <code>current-buffer</code> en una expresión por sí sola, como haremos aquí, lo que se ve es una representación impresa del nombre del búffer sin los contenidos del búffer. Emacs funciona de esta forma por dos razones: el búffer puede contener miles de líneas––demasiado largo para ser mostrado convenientemente; y, otro búffer puede tener el mismo contenido pero un nombre diferente, y es importante distinguir entre ellos.</p>
<p>Aquí hay una expresión conteniendo la función:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span>
</pre></div>
<pre class="code" ><code class=""></code></pre>
<p>Si evalúa esta expresión en Info de la manera habitual, aparecerá <span class="file" >#&lt;buffer *info*&gt;</span> en el área echo. El formato especial indica que el búffer en sí está siendo devuelto, en lugar de solo su nombre.</p>
<p>Por cierto, si bien puedes escribir un número o símbolo en un programa, no se puede hacer esto con la representación impresa del búffer: la única manera de optener un búffer en sí mismo es con una función tal como <code>current-buffer</code>.</p>
<p>Un función relacionada es <code>other-buffer</code>. Esta devuelve el último buffer seleccionado distinto al que te encuentras actualmente, no una representación impresa de su nombre. Si recientemente has ido y vuelto del búffer <span class="file" >*scratch*</span>, <code>other-buffer</code> devolverá este búffer.</p>
<p>Se puede ver esto evaluando la expresión:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">other-buffer</span><span class="p">)</span>
</pre></div>
<p>Verás que <span class="file" >#&lt;buffer *scratch*&gt;</span> aparece en el área echo, o el nombre de cualquier otro búffer cambiado anteriormente a partir del más reciente{5}</p>
</div>
<h3 id="Cambiando-búffers" >Cambiando búffers</h3>
<div class="hBody-3" >
<p>La función <code>other-buffer</code> realmente proporciona un búffer cuando se utiliza como argumento de una función que requiera uno. Podemos ver esto usando <code>other-buffer</code> y <code>switch-to-buffer</code> para cambiar a un búffer diferente.</p>
<p>Pero primero, una breve introducción a la función <code>switch-to-buffer</code>. Cuando cambia de ida y vuelta de Info al búffer <span class="file" >*scratch*</span> para evaluar <code>(buffer-name)</code>, normalmente se presiona <kbd>C-x b</kbd> y luego se pasa <span class="file" >*scratch*</span><span class="note" ><sup><a href="#6" >6</a></sup></span> en el minibuffer cuando se le solicita el nombre del buffer al que quiere cambiar. El atajo, <kbd>C-x b</kbd>, hace que el intérprete Lisp evalúe la función interactiva <code>switch-to-buffer</code>. Como hemos dicho anteriormente, así es como funciona Emacs: diferentes atajos de teclado llaman o ejecutan diferentes funciones. Por ejemplo, <kbd>C-f</kbd> llama a <code>forward-char</code>, <kbd>M-e</kbd> llama a <code>forward-sentence</code>, etcétera.</p>
<p>Al escribir <code>switch-to-buffer</code> en una expresión, y darle un búffer al que cambiar, podemos cambiar de búffer tal y como hace <kbd>C-x b</kbd>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nf">other-buffer</span><span class="p">))</span>
</pre></div>
<p>El símbolo <code>switch-to-buffer</code> es el primer elemento de la lista, por lo que el intérprete Lisp lo tratará como una función y llevara a cabo las instrucciones adjuntas al mismo. Pero antes de hacer esto, el intérprete observara que <code>other-buffer</code> está dentro de paréntesis y trabajara en este símbolo primero. <code>other-buffer</code> es el primer (y en este caso, el único) elemento de esta lista, por lo que el intérprete llama o ejecuta la función. Esto devuelve un búffer distinto al actual. A continuación, el intérprete ejecuta <code>switch-to-buffer</code>, pasando, como argumento, el búffer devuelto, que es al que Emacs cambia. Si estás leyendo esto en Info, prueba esto ahora. Evalúa la expresión. (Para regresar, presiona <kbd>C-x b RET</kbd>.)<span class="note" ><sup><a href="#7" >7</a></sup></span></p>
<p>En los ejemplos de las secciones siguentes, veras con más frecuencia la función <code>set-buffer</code> que <code>switch-to-buffer</code>. Esto es debido a la diferencia entre programas de ordenador y seres humanos: los humanos tienen ojos y esperan ver el búffer en el que están trabajando en la terminal de su ordenador. Esto es tan evidente, que se sobreentiende. Sin embargo, los programas no tienen ojos. Cuando un programa de ordenador trabaja en un búffer, el búffer no necesita ser visible en la pantalla.</p>
<p><code>switch-to-buffer</code> está diseñado para los seres humanos y hace dos cosas diferentes: cambia el búffer a el que Emacs dirige la atención; y cambia el búffer mostrado en la ventana al nuevo búffer. <code>set-buffer</code>, por otro lado, solo hace una cosa: cambia la atención del programa del ordenador a un búffer diferente. El búffer en la pantalla permanece sin cambios (por supuesto, normalmente no pasa nada hasta que el comando termina de ejecutarse).</p>
<p>Además, acabamos introduciendo otro termino tecnico, la palabra <dfn>llamada</dfn>. Cuando se evalúa una lista en la que el primer símbolo es una función, estás llamando a esa función. El uso del término viene de la noción de la función como una entidad que puede algo hacer por ti cuando la ‘llamas’––al igual que un fontanero es una entidad que puede arreglar una fuga si lo llamas.</p>
</div>
<h3 id="Tamaño-del-búffer-y-la-ubicación-del-punto" >Tamaño del búffer y la ubicación del punto</h3>
<div class="hBody-3" >
<p>Por último, vamos a ver varias funciones bastante simples, <code>buffer-size</code>, <code>point</code>, <code>point-min</code>, y <code>point-max</code>. Estas entregan información sobre el tamaño de un búffer y la ubicación del punto dentro de este.</p>
<p>La función <code>buffer-size</code> te dice el tamaño del búffer actual; es decir, la función devuelve un conteo del número de caracteres en el buffer.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">buffer-size</span><span class="p">)</span>
</pre></div>
<p>Puedes evaluar esto de la forma habitual, coloca el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>.</p>
<p>En Emacs, la posición actual del cursor se denomina <dfn>punto</dfn>. La expresión <code>(point)</code> devuelve un número que informa donde esta situado el cursor como un conteo del número de caracteres desde el principio del búffer hasta el punto.</p>
<p>Puedes ver el conteo de caracteres del punto para este búffer evaluando la siguiente expresión de la forma habitual:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">point</span><span class="p">)</span>
</pre></div>
<p>Mientras escribo esto, el valor de <code>point</code> es 65724. La función <code>point</code> se utiliza con frecuencia en algunos de los ejemplos mas adelante en este libro.</p>
<p>El valor del punto depende, por supuesto, de su ubicacion dentro del búffer. Si evaluas el punto en este lugar, el número será mayor:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">point</span><span class="p">)</span>
</pre></div>
<p>Para mí, el valor del punto en esta posición es 66043, lo que significa que hay 319 caracteres (incluyendo espacios) entre las dos expresiones. (Sin duda, verá números diferentes, puesto que habré editado esto desde el primer punto evaluado.)</p>
<p>La función <code>point-min</code> es similar a <code>point</code>, pero devuelve el valor mínimo permisible del punto en el búffer actual. Este es el numero 1 a menos que <dfn>narrowing</dfn> esté en vigor. (Narrowing, <em>Reduccion</em> es un mecanismo mediarte el cual puedes restringirte a ti mismo, o un programa, a operar solo en un parte de un búffer. Ver Sección <a href="#Reducir-y-Extender" >Reducir y Extender</a>.)  Del mismo modo, la función <code>point-max</code> devuelve el valor máximo permisible del punto en el búffer actual.</p>
</div>
<h3 id="Ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Busca un fichero en el que trabarjar y avanza hasta la mitad. Encuentra el nombre de búffer, el nombre del fichero, su tamaño, y la posición en el fichero.</p>
</div>
<h2 id="Cómo-escribir-definiciones-de-funciones" >Cómo escribir definiciones de funciones</h2>
<div class="hBody-2" >
<p>Cuando el intérprete Lisp evalúa una lista, mira si el primer símbolo en la lista tiene una definición ligada a este; o, dicho de otro modo, si el símbolo apunta a una definición de función. Si lo hace, el ordenador lleva a cabo las instrucciones que aparecen en la definición. Un símbolo que tiene una definición de función se llamada, simplemente, una función (aunque hablando con propiedad, la definición es la función y el símbolo se refiere a ella.)</p>
<p>Todas las funciones se defininen en términos de otras funciones, a excepción de algunas <dfn>primitivas</dfn> que estan escritas en el lenguaje de programación C. Cuando escribas definiciones de funciones, debes escribirlas en Emacs Lisp y utilizar otras funciones como bloques de construcción. Algunas de las funciones a utilizar estaran a su vez escritas en Emacs Lisp (quizás por tí) y algunas serán primitivas escritas en C. Las funciones primitivas se usan exactamente igual que las escritas en Emacs Lisp y se comportan de igual forma. Están escritas en C para que podamos ejecutar facilmente GNU Emacs en cualquier ordenador que tenga la potencia suficiente y pueda ejecutar C.</p>
<p>Permíteme volver a enfatizar esto: cuando se escribe código en Emacs Lisp, no se distinge entre el uso de funciones escritas en C y el uso de funciones escritas en Emacs Lisp. La diferencia es irrevelante. Mencioné la distinción solo porque es interesante conocerla. De hecho, a menos de que investigues, no sabras si una función previamente escrita esta en Emacs Lisp o en C.</p>
</div>
<h3 id="La-forma-especial-defun" >La forma especial <code>defun</code></h3>
<div class="hBody-3" >
<p>En Lisp, un símbolo como <code>mark-whole-buffer</code> tiene código unido a el que le dice al ordenador que hacer cuando se invoca la función. Este código se denomina la <dfn>definición de función</dfn> y se crea mediante la evaluación de una expresión Lisp que comienza con el símbolo <code>defun</code> (que es una abreviatura para <em>define function</em> (definir función)). Porque <code>defun</code> no evalúa sus argumentos en la forma habitual, esto se llama <dfn>forma especial</dfn>.</p>
<p>En las siguientes secciones, vamos a ver las definiciones de función partiendo del código fuente de Emacs, por ejemplo <code>mark-whole-buffer</code>. En esta sección, describiremos una definición de función sencilla para que puedas ver su aspecto. Esta definición de función usa aritmética porque es un ejemplo simple. A algunas personas les disgustan los ejemplos usando aritmética; sin embargo, si usted es tal persona, no se desespere. Casi ningun codigo a estudiar en el resto de esta introducción implica aritmética o matemáticas. Los ejemplos involucran principalmente texto en una forma u otra.</p>
<p>Una definición de función tiene un máximo de cinco partes despues de la palabra <code>defun</code>:</p>
<ol>
<li><p>El nombre del símbolo al que la definición de función debe vincularse.</p>
</li>
<li><p>Una lista de los argumentos que se pasan a la función. Si no hay argumentos que pasar a la función, tendremos una lista vacía, <code>()</code>.</p>
</li>
<li><p>Documentación describiendo la función. (Técnicamente opcional, pero fuertemente recomendada.)</p>
</li>
<li><p>Opcionalmente, una expresión para hacer que la función interactive pueda usarse presionando <kbd>M-x</kbd> seguido del nombre de la función; o pulsando una tecla o atajo de teclado.</p>
</li>
<li><p>El código que indica a el ordenador qué hacer: el <dfn>cuerpo</dfn> de la definición de función.</p>
</li>
</ol>
<p>Es útil pensar en las cinco partes de una definición de función siendo organizadas como una plantilla, con slots para cada parte:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funci</span><span class="err">ó</span><span class="nv">n</span> <span class="p">(</span><span class="nv">argumentos</span><span class="err">…</span><span class="p">)</span>
  <span class="s">&quot;documentación-opcional…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="nv">argument-passing-info</span><span class="p">)</span>     <span class="c1">; opcional</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>A modo de ejemplo, aquí está el código de una función que multiplica su argumento por 7. (Este ejemplo no es interactivo. Ver Sección <a href="#Crear-una-Función-Interactiva" >Crear una Función Interactiva</a>, para esta información.)</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siente</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&quot;Multiplica NUMERO por siete.&quot;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</pre></div>
<p>Esta definición comienza con un paréntesis y el símbolo <code>defun</code> seguido por el nombre de la función.</p>
<p>El nombre de la función es seguido por una lista que contiene los argumentos que se pasan a la función. Esta lista se llama <dfn>lista de argumentos</dfn>. En este ejemplo, la lista solo tiene un elemento, el símbolo <code>numero</code>. Cuando se utiliza la función, el símbolo sera asociado al valor que se utiliza como argumento de la función</p>
<p>En lugar de elegir la palabra <code>numero</code> para el nombre del argumento, podría haber escogido cualquier otro nombre. Por ejemplo, la palabra <code>multiplicando</code>. Escogi la palabra ‘numero’ porque indica qué tipo de valor se pretende para este espacio; pero podría haber elegido ‘multiplicando’ para indicar el papel que jugara el valor en el funcionamiento de la función. Podría haberlo llamado <code>foogle</code>, pero habría sido una mala elección, ya que no comunicaria a los humanos qué significa. La elección del nombre es responsabilidad del programador y debe elegirse para hacer que el significado de la función sea claro.</p>
<p>De hecho, puedes elegir cualquier nombre que desees para un símbolo en una lista de argumentos, incluso el nombre de un símbolo usado en alguna otra función: el nombre que utilices en una lista de argumentos esta privado para esta definición particular. En esta definición, el nombre hace referenecia a una entidad diferente a cualquiera que utilice el mismo nombre fuera de la definición de función. Supón que tu familia te apoda ‘Enano’; cuando tus familiares digan ‘Enano’, queren hacer referencia a ti. Pero fuera de tu familia, en una película, por ejemplo, el nombre ‘Enano’ se refiere a alguien más. Debido a que el nombre en una lista de argumentos es privado para la definición de la función, se puede cambiar el valor de un símbolo dentro del cuerpo de una función sin cambiar su valor fuera de la función. El efecto es similar al producido por la expresión <code>let</code>. (Ver sección <a href="#let" ><code>let</code></a>.)</p>
<p>La lista de argumentos es seguida por la cadena de documentación que describe la función. Esto es lo ves cuando presionas <kbd>C-h f</kbd> y escribes el nombre de una función. Por cierto, cuando escribas una cadena de documentación como esta, debes confeccionar la primera linea como una sentencia completa ya que algunos comandos, como <code>apropos</code>, imprimen solo la primera línea de una cadena de documentación de varias líneas. Ademas, no debes indentar la segunda línea de la cadena de documentación, si tienes una, porque se ve extraño al utilizar <kbd>C-h f</kbd> (<code>describe-function</code>). La cadena de documentación es opcional, pero es tan útil, que deberías incluirla en casi cualquier función que escribas.</p>
<p>La tercera línea del ejemplo consiste en el cuerpo de la definición de función. (La mayoría de las definiciones de funcion, claro esta, son más extensas que esta.) En esta función, el cuerpo es la lista, <code>(* 7 numero)</code>, que indica multiplicar el valor de <code>numero</code> por 7. (En Emacs Lisp, <code>*</code> es la función para la multiplicación, al igual que <code>+</code> es la función de la adición.</p>
<p>Cuando se utiliza la función <code>multiplicar-por-siente</code>, el argumento <code>numero</code> se evalúa al número que desees usar. He aquí un ejemplo que muestra como utilizar <code>multiplicar-por-siete</code>; pero ¡no intentes evaluar esto primero!.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">multiplicar-por-siente</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>El símbolo <code>numero</code>, especificado en la definición de función en la siguiente sección, se da o “une a” el valor 3 en el actual uso de la función. Note que aunque <code>numero</code> estaba dentro de paréntesis en la definición de función, el argumento pasado a la función <code>multiplicar-por-siente</code> no está entre paréntesis. Los paréntesis se escriben en la definición de función para que el ordenador pueda averiguar donde termina la lista de argumentos e inicia el resto de la definición de función.</p>
<p>Si evalúas este ejemplo, es probable que obtengas un mensaje de error. (¡adelante, intentalo!) Esto se debe a que hemos escrito la definición de función, pero aún no se ha comunicado al ordenador sobre la definición––no hemos instalado (o ‘cargado’) la definición de función en Emacs. Instalar una función es el proceso de comunicar al intérprete Lisp la definición de la función. La instalación se describe en la siguiente sección.</p>
</div>
<h3 id="Instalar-una-definición-de-función" >Instalar una definición de función</h3>
<div class="hBody-3" >
<p>Si estás leyendo esto dentro en Emacs, puedes probar la función <code>multiply-by-seven</code> evaluando en primer lugar la definición de función y luego evaluar <code>(multiplicar-por-siente 3)</code>. Hay una copia de la definición a continuación. Coloca el cursor después del último paréntesis de la definición de función y presiona <kbd>C-x C-e</kbd>. Al hacer esto, <code>multiplicar-por-siente</code> aparecerá en el área echo. (Lo que significa es que cuando una se evalua una definición de función, el valor devuelto es el nombre de la función definida.) Al mismo tiempo, esta acción instala la definición de función.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siente</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&quot;Multiplica NUMERO por siete.&quot;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</pre></div>
<p>Al evaluar este <code>defun</code>, estas instanlado <code>multiplicar-por-siente</code> en Emacs. La función ahora es una parte de Emacs tan importante como <code>forward-word</code> o cualquier otra función de edición que utilices. (<code>multiplicar-por-siente</code> seguira instalado hasta que salgas de Emacs. Para volver a cargar el código automáticamente cada vez que Emacs inicie, revisa la sección <a href="#Instalar-Código-Permanentemente" >Instalar Código Permanentemente</a>.)</p>
<p>Puedes ver el efecto de instalar <code>multiplicar-por-siente</code> evaluando el siguiente ejemplo. Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>. El número 21 aparacerá en el área echo.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">multiplicar-por-siente</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
<p>Si lo deseas, puedes leer la documentación de la función presiona <kbd>C-h f</kbd> (<code>describe-function</code>) y luego escribe el nombre de la función, <code>multiplicar-por-siente</code>. Al hacer esto, una ventana <span class="file" >*Help*</span> aparecerá en tu pantalla diciendo:</p>
<pre><code class="example">multiplicar-por-siente is a Lisp function.
(multiplicar-por-siente NUMERO)

Multiplica NUMERO por siete.</code></pre>
<p>(Para volver a una sola ventana en la pantalla, presiona <kbd>C-x 1</kbd>.)</p>
</div>
<h4 id="Cambiar-una-definición-de-función" >Cambiar una definición de función</h4>
<div class="hBody-4" >
<p>Si deseas modificar el código de <code>multiplicar-por-siente</code>, simplemente reescríbelo. Para instalar la nueva versión en lugar de la vieja, evalúa la nueva definición de la función. Esta, es la forma de modificar el código en Emacs. Es muy simple,</p>
<p>A modo de ejemplo, puedes cambiar la función <code>multiplicar-por-siente</code> para sumar el número a sí mismo siete veces en lugar de multiplicar el número por siete. Esto produce el mismo resultado, pero por una ruta diferente. Al mismo tiempo, añadiremos un comentario al codigo; un comentario es texto que el intérprete Lisp ignora, pero un lector humano puede encontrarlo útil o esclarecedor. El comentario es que esta es la “segunda versión”.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siente</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Segunda versión.</span>
  <span class="s">&quot;Multiplica NUMERO por siete.&quot;</span>
  <span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span><span class="p">))</span>
</pre></div>
<p>El comentario sigue a un punto y coma, <samp>;</samp>. En Lisp cualquier cosa en una línea despues de un punto y coma es un comentario. El fin de la línea es el fin del comentario. Para extender un comentario por dos o más líneas, inicia cada línea con un punto y coma.</p>
<p>Véa las Secciónes <a href="#Empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></a> y <a href="info:emacs#Comments" >Comentarios</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más informacion sobre los comentarios.</p>
<p>Puedes instalar esta versión de <code>multiplicar-por-siente</code> evaluándo esta de la misma forma en que evaluaste la primer función: coloca el cursor después del último paréntesis y presiona <kbd>C-x C-e</kbd>.</p>
<p>En resumen, esta es la forma en que puedes escribir código en Emacs Lisp: escribes una función; la instalas; la pruebas; luego haces correcciones y mejoras e instálalas de nuevo.</p>
</div>
<h3 id="Crear-una-función-interactiva" >Crear una función interactiva</h3>
<div class="hBody-3" >
<p>Haces a una función interactiva colocando una lista que inicia con la clase especial <code>interactive</code> inmediatamente después de la documentación. Un usuario puede invocar una función interactiva con <kbd>M-x</kbd> y seguido del nombre de la función; o con un atajo de teclado ligado a esta, por ejemplo, pulsa <kbd>C-n</kbd> para <code>next-line</code> o <kbd>C-x h</kbd> para <code>mark-whole-buffer</code>.</p>
<p>Cusionamente, cuando llamas a una función interactiva interactivamente, el valor devuelto no se muestra automáticamente en el área echo. Esto se debe a que a menudo se llama a una función interactiva por sus efectos secundarios, tales como avanzar hacia hacia adelante por palabra o línea, y no por el valor devuelto. Si el valor devuelto se mostrara en el área echo cada vez que se presiona una tecla, seria una gran distraccion.</p>
<p>Tanto el uso de la clase especial <code>interactive</code> y una forma de mostrar un valor en el área echo pueden ilustrarse creando una versión interactiva de <code>multiplicar-por-siente</code>.</p>
<p>Aquí está el código:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siente</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Versión Interactiva.</span>
  <span class="s">&quot;Multiplica NUMERO por siete.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;p&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;El resultado es %d&quot;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">)))</span>
</pre></div>
<p>Para instalar este código coloca el cursor después del ultimo parentesis y presiona <kbd>C-x C-e</kbd>. El nombre de la función aparecerá en el área echo. Despues, puedes utilizar este código al presionar <kbd>C-u</kbd> segudo de un número, luego <kbd>M-x multiplicar-por-siente</kbd> y finalmente <kbd>RET</kbd>. La frase <samp>El resultado es …</samp> seguida por el producto aparecerá en el área echo.</p>
<p>Hablando en terminos mas generales, puedes invocar una función como ésta de dos maneras:</p>
<ol>
<li><p>Al escribir un argumento prefijo que contiene el número a pasar, y a continuación presionar <kbd>M-x</kbd> y escribir el nombre de la función, como ocurre con <kbd>C-u 3 M-x forward-sentence</kbd>; o,</p>
</li>
<li><p>Al escribir cualquier tecla o atajo de teclado ligado a la función a tratar, como ocurre con <kbd>C-u 3 M-e</kbd>.</p>
</li>
</ol>
<p>Ambos ejemplos operan de forma identica moviendo el punto hacia adelante tres frases. (Si <code>multiply-by-seven</code> no estuviese ligado a una tecla, no podria ser usado como ejemplo de enlace a tecla.</p>
<p>(Véase Sección <a href="#Atajos-de-teclado" >Atajos de teclado</a>, para aprender como vincular un comando a una tecla.)</p>
<p>Un argumento prefijo se pasa a una función interactiva pulsando la tecla <kbd>META</kbd> seguida de un número, por ejemplo, <kbd>M-3 M-e</kbd>, o con <kbd>C-u</kbd> y luego un número, por ejemplo, <kbd>C-u 3 M-e</kbd> (si presionas <kbd>C-u</kbd> sin ningun número, el valor por defecto es 4).</p>
</div>
<h4 id="multiplicar-por-siente-interactivo" ><code>multiplicar-por-siente</code> interactivo</h4>
<div class="hBody-4" >
<p>Veamos la clase especial <code>interactive</code> y despues la función <code>message</code> en la versión interactiva de <code>multiplicar-por-siente</code>.  Recordaras que la definición de función tiene el siguente aspecto:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siente</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Versión Interactiva.</span>
  <span class="s">&quot;Multiplica NUMERO por siete.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;p&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;El resultado es %d&quot;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">)))</span>
</pre></div>
<p>En esta función, la expresión, <code>(interactive &quot;p&quot;)</code>, es una lista de dos elementos. La <code>&quot;p&quot;</code> le indica a Emacs que debe pasar el argumento prefijo a la función y utilizar este valor para el argumento de la función.</p>
<p>El argumento debe ser un número. Esto significa que el símbolo <code>numero</code> estara asociado a un número en la línea:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;El resultado es %d&quot;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</pre></div>
<p>Por ejemplo, si tu argumento prefijo es 5, el intérprete Lisp evaluará la línea como si fuera:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;El resultado es %d&quot;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
<p>(Si estás leyendo esto en GNU Emacs, puedes evaluar esta expresión por ti mismo.) Primero, el intérprete evaluará la lista interna, que es <code>(* 7 5)</code>. Esto devuelve un valor de 35. A continuación, se evaluará la lista externa, pasando los valores del segundo y posteriores elementos de la lista a la función <code>message</code>.</p>
<p>Como hemos visto, <code>message</code> es una función Emacs Lisp especialmente diseñada para enviar un mensaje de una línea al usuario. (Véase Sección <a href="#La-función-message" >La función <code>message</code></a>) En resumen, la función <code>message</code> imprime su primer argumento en el área echo tal cual, exceptuando las apariciones de <samp>%d</samp>, o <samp>%s</samp> (y varias otras secuencias de control que no hemos mencionado).  Cuando aparece una secuencia de control, la función observa el segundo o posteriores argumentos e imprime el valor del argumento en la ubicación donde se encuartra la secuencia de control.</p>
<p>En la función interactiva <code>multiplicar-por-siente</code>, la cadena de control es <samp>%d</samp>, que requiere un número, y el valor devuelto por la evaluación de <code>(* 7 5)</code> es el número 35. Por consiguiente, el número 35 se imprime en lugar de <samp>%d</samp> y el mensaje es <samp>El resultado es 35</samp>.</p>
<p>(Observa que cuando llamas a la función <code>multiplicar-por-siente</code>, el mensaje se imprime sin comillas, pero cuando llamas a <code>message</code>, el texto se imprime entre comillas. Esto se debe a que el valor devuelto por <code>message</code> aparece en el área echo cuando evalúas una expresión cuyo primer elemento es <code>message</code>; pero si se integra en una función, <code>message</code> imprime el texto como un efecto secundario sin comillas.)</p>
</div>
<h3 id="Diferentes-opciones-para-interactive" >Diferentes opciones para <code>interactive</code></h3>
<div class="hBody-3" >
<p>En el ejemplo, <code>multiplicar-por-siente</code> utiliza <code>&quot;p&quot;</code> como el argumento para <code>interactive</code>. Este argumento indica a Emacs que interprete cualquer cosa que escriba despues de <kbd>C-u</kbd> o del comando <kbd>META</kbd> como un numero que sera el argumento a pasar a la funcion. Emacs tiene más de veinte caracteres predefinidos para usar con <code>interactive</code>. En casi todos los casos, una de estas opciones te permitira pasar la información adecuada interactivamente a una función. (Véase Sección <a href="info:emacs#Interactive" >Code Characters for <code>interactive</code></a> en <em>El Manual de Referencia GNU Emacs Lisp</em>).</p>
<p>Considera la función <code>zap-to-char</code>. Su expresión interactiva es</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;p\ncZap to char: &quot;</span><span class="p">)</span>
</pre></div>
<p>La primer parte del argumento de <code>interactive</code> es <samp>p</samp>, con el que ya estás familiarizado. Este argumento le indica a Emacs intepretar un ‘prefijo’, como un número que se pasa a la función. Puedes especificar un prefijo presionando <kbd>C-u</kbd> seguido por un número o igualmente con <kbd>META</kbd> seguido por un número. El prefijo es un número de caracteres especifico.  De este modo, si el prefijo es tres y el caracter es establecido es <samp>x</samp>, entonces se borrará todo el texto incluido el tercer <samp>x</samp> siguiente. Si no se establece un prefijo, entonces borras todo el texto incluido el cuarto carácter establecido, pero no más.</p>
<p>La <samp>c</samp> indica a la función el nombre del carácter que va a eliminar.</p>
<p>Más formalmente, una función con dos o más argumentos puede tener información que pasa a cada argumento añadiendo partes en la cadena que viene despues de <code>interactive</code>. Cuando haces esto, la información se pasa a cada argumento en el mismo orden que se especifica en la lista <code>interactive</code>. En la cadena, cada parte está separada de la siguente parte por un <samp>\n</samp>, que significa nueva línea. Por ejemplo, a <samp>p</samp> puede continuar un <samp>\n</samp> y un <samp>cZap to char:@:}. Esto hace que Emacs pase el valor del argumento prefijo (si lo hay) y el carácter.</samp></p>
<p>En este caso, la definición de función se parace a la siguiente, donde <code>arg</code> y <code>char</code> son los símbolos que <code>interactive</code> vincula el argumento prefijo y el caracter especificado:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">arg</span> <span class="nv">char</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;p\ncZap to char: &quot;</span><span class="p">)</span>
  <span class="nv">cuerpo-de-funcion</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>(El espacio después del punto y coma en el prompt hace que se vea mejor. Véase Sección <a href="#La-Definición-de-copy-to-buffer" >La Definición de <code>copy-to-buffer</code></a>, para un ejemplo.)</p>
<p>Cuando una función no toma argumentos, <code>interactive</code> no requiere ninguno. Una función asi contiene inicamente la expresión <code>(interactive)</code>. La función <code>mark-whole-buffer</code> es asi.</p>
<p>Alternativamente, si los códigos de letras especiales no son adecuardos para tu aplicación, puedes pasar tus propios propios argumentos a <code>interactive</code> como una lista.</p>
<p>Ver <a href="#La-Definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>, para un ejemplo. Ver Sección <a href="info:emacs#Using-Interactive" >Usando <code>interactive</code></a> en <em>El Manual de GNU Emacs Lisp</em>, para una explicación más completa acerca de esta técnica.</p>
</div>
<h3 id="Instalar-código-permanentemente" >Instalar código permanentemente</h3>
<div class="hBody-3" >
<p>Cuando instalas una definición de función evaluada por ti, permanecera instalada hasta que salgas de Emacs. La proxima vez que se inicies una nueva sesión de Emacs, la función no sera instalada a menos que evalúes de nuevo la definición.</p>
<p>En algún momento, podrias necesitar que el código se instale automáticamente cada vez que inicies una nueva sesión de Emacs. Hay varias formas de hacer esto:</p>
<ul>
<li><p>Si tienes código solo para tu uso, puedes poner el código de la definición de función en el fichero de inicialización <span class="file" >.emacs</span>. Cuando se inicia Emacs, el fichero <span class="file" >.emacs</span> se evalúa automática y se instalan todas sus definiciones de función. Vér Sección <a href="#Tu-Fichero-.emacs" >Tu Fichero <span class="file" >.emacs</span></a>.</p>
</li>
<li><p>Como Alternativa, puedes poner las definiciones de función en uno o más ficheros y usar la función <code>load</code> para hacer que Emacs evalue y con ello instale cada una de las funciones en los ficheros. Véase Sección <a href="#Cargando-ficheros" >Cargando ficheros</a>.</p>
</li>
<li><p>En Tercer lugar, si tienes código que todo tu sitio va a utilizar, es normal ponerlo en un fichero llamado <span class="file" >site-init.el</span> que se carga cuando se construye Emacs. Esto hace que el código este disponible a cualquiera que use tu máquina. (Mira el fichero <span class="file" >INSTALL</span> que forma parte de la distribución Emacs.)</p>
</li>
</ul>
<p>Finalmente, si tienes código que cualquier usuario de Emacs puede querer, puedes publicarlo en una red de ordenadores o enviar una copia a la Free Software Foundation. (Al hacer esto, por favor licencia el código y su documentación bajo una licencia que permita a otras personas ejecutar, copiar, estudiar, modificar, y redistribuir el código y te protege de quien tome tu trabajo.) Si envias una copia de tu código a la Free Software Foundation, y lo proteges apropiadamente de ti mismo y otros, puede ser incluido en la siguiente version de Emacs. En gran parte, esta es la forma como ha crecido Emacs a través de los años, por donaciones.</p>
</div>
<h3 id="let" ><code>let</code></h3>
<div class="hBody-3" >
<p>La expresión <code>let</code> es una forma especial en Lisp que tendras que utilizar en la mayoría de las definiciones de función.</p>
<p><code>let</code> se utiliza para unir o enlazar un símbolo a un valor de tal manera que el intérprete no confunda la variable con otra variable del mismo nombre que no forma parte de la función.</p>
<p>Para entender por qué la forma especial <code>let</code> es necesaria, considera la situación donde eres dueño de una casa que generalmente vinculas con ‘la casa’, como en la frase, “La casa necesita pintura”. Si visitas a un amigo y tu anfitrion hace referencia a ‘la casa’, es probable que se refiera a <em>su</em> casa, no a la tuya, es decir, es una casa distinta.</p>
<p>Si tu amigo se refiere a su casa y tu crees que el se esta refiriendo a tu casa, puedes tener cierta confusión. Lo mismo podría suceder en Lisp si una variable que se utiliza dentro de una función tiene el mismo nombre que una variable usada dentro de otra función, y las dos no tienen la intencion de referirse al mismo valor. La forma especial <code>let</code> previene este tipo de confusión.</p>
<p>La forma especial <code>let</code> evita confusiones. <code>let</code> crea un nombre para una <dfn>variable local</dfn> que eclipsa cualquier uso del mismo nombre fuera de la expresión <code>let</code>. Esto es como entender que siempre que tu anfitrion se refiera a ‘la casa’, significa su casa, no la tuya. (Los símbolos usados en las listas de argumentos funcionan de la misma manera. Véase Sección <a href="#La-Forma-Especial-defun" >La Forma Especial <code>defun</code></a>.)</p>
<p>Las variable locales creadas por una expresión <code>let</code> conservan su valor <em>solo</em> dentro de la expresión <code>let</code> misma (y dentro de expresiones llamadas dentro de la expresión <code>let</code>); las variables locales no tiene efecto fuera de la expresión <code>let</code>.</p>
<p>Otra forma de persar respecto a <code>let</code> es que es como un <code>setq</code> que es temporal y local. Los valores establecidos por <code>let</code> son automáticamente deshechos cuando termina el <code>let</code>. La configuración solo afecta a las expresiones que se encuentran dentro de los limites de la expresión <code>let</code>. En jerga informatica, diríamos “la union de un simbolo es visible solo en las funciones llamadas en la forma <code>let</code>; en Emacs Lisp, el alcance es dinámico, no léxico.”</p>
<p><code>let</code> puede crear más de una variable a la vez. Ademas, <code>let</code> da a cada variable que crea un valor inicial, ya sea un valor especificado por tí, o <code>nil</code>. (En la jerga, eso se llama ‘unir la variable al valor’.) Después que <code>let</code> ha creado y unido las variables, ejecuta el código en el cuerpo del <code>let</code> y devuelve el valor de la última expresión en el cuerpo, como el valor de toda la expresión <code>let</code>. (‘Ejecutar’ es un término tecnico que significa evaluar una lista; proviene del significando de la palabra ‘llevar a la practica’ (<em>Diccionario de Inglés de Oxford</em>). Dado que evalúas una expresión para realizar una acción, ‘ejecutar’ ha evolucionado como un sinónimo para ‘evaluar’.)</p>
</div>
<h4 id="Partes-de-una-expresión-let" >Partes de una expresión <code>let</code></h4>
<div class="hBody-4" >
<p>Una expresión <code>let</code> es una lista de tres partes. La primer parte es el símbolo <code>let</code>. La segunda parte es una lista, denominada <dfn>varlist</dfn> (lista de variables), cada uno de cuyos elementos es un símbolo por sí mismo o una lista de dos elementos, el primer elemento es un símbolo. La tercera parte de la expresión <code>let</code> es el cuerpo del <code>let</code>. El cuerpo normalmente consiste de una o más listas.</p>
<p>Una plantilla para una expresión <code>let</code> tiene el siguente aspecto:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="nv">varlist</span> <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>Los símbolos de la lista de varibles (<code>varlist</code>) son las variables que dan los valores iniciales para la forma especial <code>let</code>. Los símbolos por si solos reciven el valor inicial de <code>nil</code>; y cada símbolo que es el primer elemento de una lista de dos elementos es unido al valor devuelto cuando el interprete Lisp evalúa el segundo elemento.</p>
<p>De este modo, una varlist como: <code>(thread (needles 3))</code>. En este caso, dentro una expresión <code>let</code>, Emacs une el símbolo <code>thread</code> a un valor inicial de <code>nil</code>, y une el símbolo <code>needles</code> a un valor inicial de 3.</p>
<p>Cuando escribes una expresión <code>let</code>, lo que haces es poner las expresiones apropiadas en los huecos de la plantilla de expresión <code>let</code>.</p>
<p>Si la varlist está compuesta de listas de 2 elementos, como suele ser el caso, la plantilla de la expresión <code>let</code> es la sigiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
</div>
<h4 id="Ejemplo-de-Expresión-let" >Ejemplo de Expresión <code>let</code></h4>
<div class="hBody-4" >
<p>La siguiente expresión crea y da valores iniciales a las dos variables <code>cebra</code> y <code>tigre</code>. El cuerpo de la expresión <code>let</code> es una lista que llama a la función <code>message</code>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">cebra</span> <span class="ss">&#39;rayas</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">tigre</span> <span class="ss">&#39;fiero</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Un tipo de animal tiene %s y otro es %s.&quot;</span>
           <span class="nv">cebra</span> <span class="nv">tigre</span><span class="p">))</span>
</pre></div>
<p>Aquí, la varlist es <code>((cebra 'rayas) (tigre 'fiero))</code>.</p>
<p>Las dos variables son <code>cebra</code> y <code>tigre</code>. Cada variable es el primer elemento de una lista de dos elementos y cada valor es el segundo elemento de su lista de dos elementos. En la varlist, Emacs une la variable <code>cebra</code> al valor <code>rayas</code><span class="note" ><sup><a href="#8" >8</a></sup></span>, y une la variable <code>tigre</code> al valor <code>fiero</code>. En este ejemplo, ambos valores son símbolos precedidos por una cita. Los valores podrían muy bien haber sido otra lista o una cadena. El cuerpo de <code>let</code> sigue después de la lista que contiene las variables. En este ejemplo, el cuerpo es una lista que usa la función <code>message</code> para imprimir una cadena en el área echo.</p>
<p>Puedes evaluar el ejemplo de la forma habitual, coloca el cursor después del último paréntesis y presiona <kbd>C-x C-e</kbd>. Al hacer esto, aparecerá lo siguiente en el área echo:</p>
<div class="highlight"><pre><span></span><span class="s">&quot;Un tipo de animal tiene rayas y otro es fiero.&quot;</span>
</pre></div>
<p>Como hemos visto antes, la función <code>message</code> imprime su primer argumento, excepto por <samp>%s</samp>. En este ejemplo, el valor de la variable <code>cebra</code> se imprime en la ubicacion del primer <samp>%s</samp> y el valor de la variable <code>tigre</code> se imprime en la ubicacion del segundo <samp>%s</samp>.</p>
</div>
<h4 id="Variables-sin-inicializar-en-un-sentencia-let" >Variables sin inicializar en un sentencia <code>let</code></h4>
<div class="hBody-4" >
<p>Si no se une a las variables en una sentencia <code>let</code> con valores iniciales específicos, automáticamente seran unidos a un valor inicial de <code>nil</code>, como en la siguiente expresión:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">abedul</span> <span class="mi">3</span><span class="p">)</span>
      <span class="nv">pino</span>
      <span class="nv">abeto</span>
      <span class="p">(</span><span class="nv">roble</span> <span class="ss">&#39;algunos</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&quot;Aquí están %d variables con %s, %s, y el valor %s.&quot;</span>
   <span class="nv">abedul</span> <span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span><span class="p">))</span>
</pre></div>
<p>Aquí, la varlist es <code>((abedul 3) pino abeto (roble 'algunos))</code>.</p>
<p>Si evalúas esta expresión de la forma habitual, aparecerá lo siguiente en el área echo:</p>
<pre><code class="example">&quot;Aquí están 3 variables con nil, nil, y el valor algunos.&quot;</code></pre>
<p>En este ejemplo, Emacs une el símbolo <code>abedul</code> al número 3, une los símbolos <code>pino</code> y <code>abeto</code> a <code>nil</code>, y une el símbolo <code>roble</code> al valor <code>algunos</code>.</p>
<p>Observe que en la primera parte de <code>let</code>, las variables <code>pino</code> y <code>abeto</code> son unicamente átomos que no están rodeados por paréntesis; esto se debe a que estan siendo unidos a <code>nil</code>, la lista vacía. Pero <code>roble</code> su une a <code>algunos</code> por esto es parte de la lista <code>(roble 'algunos)</code>. De manera similar, <code>abedul</code> se une al número 3 en una lista con este número. (Ya que un número se evalúa a sí mismo, el número no necesita ser citado. Ademas, el número se imprime en el mensaje utilizando un <samp>%d</samp> en lugar de un <samp>%s</samp>.) Las cuatro variables como un grupo son puestas dentro de una lista para delimitarla de el cuerpo de <code>let</code>.</p>
</div>
<h3 id="La-forma-especial-if" >La forma especial <code>if</code></h3>
<div class="hBody-3" >
<p>Además de <code>let</code> y <code>defun</code>, esta la forma especial condicional <code>if</code>. Esta forma se utiliza para indicar al computador que tome decisiones. Puedes escribir definiciones de función sin necesidad de utilizar <code>if</code>, pero se usa con bastante frecuencia, y es lo suficientemente importante como para incluirse aquí. Se utiliza, por ejemplo, en el código de la función <code>beginning-of-buffer</code>.</p>
<p>La idea básica detras de <code>if</code>, es que “<em>if</em> (si) una prueba es verdad <em>then</em> (entonces) se evalua la expresión”. Si la prueba no es verdad, la expresión no se evalua. Por ejemplo, podría tomar una decisión como, “si es cálido y soleado, entonces ir a la playa!”</p>
<p>Al escribir una expresión <code>if</code> en Lisp no se utiliza la palabra ‘then’; la prueba y la acción son los elementos segundo y tercero de la lista cuyo primer elemento es <code>if</code>. No obstante, la parte de la prueba en una expresión <code>if</code> a menudo se llamada <dfn>if-part</dfn> (parte-si) y el segundo argumento a menudo se llamada <dfn>then-part</dfn> (parte-entonces).</p>
<p>Ademas, cuando se escribe una expresión <code>if</code>, la prueba-verdadero-o-falso normalmente se escribe en la misma línea que el símbolo <code>if</code>, pero la acción a llevar a cabo si la prueba es verdadera, “then-part” (<em>parte-entonces</em>), se escribe en la segunda y suguientes líneas. Esto hace que la expresión <code>if</code> sea mas fácil de leer.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-el-test-es-cierto</span><span class="p">)</span>
</pre></div>
<p>La prueba-verdadero-o-falso es una expresión que evalua el intérprete Lisp.</p>
<p>Aquí hay un ejemplo que puedes evaluar. La prueba consiste en si el número 5 es mayor que el número 4. Ya que es asi, se imprime el mensaje <samp>¡5 es mayor que 4!</samp>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>                           <span class="c1">; parte-si</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;¡5 es mayor que 4!&quot;</span><span class="p">))</span>   <span class="c1">; parte-entonces</span>
</pre></div>
<p>(La función <code>&gt;</code> comprueba si su primer argumento es mayor que su segundo argumento y devuelve verdadero si lo es.)</p>
<p>Por supuesto, en un caso real, la prueba en una expresión <code>if</code> no será siempre la misma, como en la expresión <code>(&gt; 5 4)</code>. En su lugar, al menos una de las variables utilizadas en la prueba estara unida a un valor de antemano desconocido. (Si el valor se conoce de antemano, ¡no necesitamos realizar la prueba!)</p>
<p>Por ejemplo, el valor puede estar unido a un argumento de una definición de función. En la siguiente definición de función, el tipo de animal es un valor que se pasa a la función. Si el valor unido a <code>caracteristica</code> es <code>fiero</code>, entonces se imprime el mensaje, <samp>¡Es un tigre!</samp>; de otro modo, se devolvera <code>nil</code>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&quot;Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.</span>
<span class="s">     Si la CARACTERISTICA es el símbolo ‘fiero’,</span>
<span class="s">     entonces advierte que es un tigre.&quot;</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;¡Es un tigre!&quot;</span><span class="p">)))</span>
</pre></div>
<p>Si estás leyendo esto dentro de GNU Emacs, puedes evaluar la definición de función de la forma habitual para instalarlo en Emacs, y luego puedes evaluar las dos expresiones siguientes para ver los resultados:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;fiero</span><span class="p">)</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;cebra</span><span class="p">)</span>
</pre></div>
<p>Al evaluar <code>(tipo-de-animal 'fiero)</code>, veras el siguiente mensaje impreso en el área eco: <code>&quot;¡Es un tigre!&quot;</code>; y cuando se evalúa <code>(tipo-de-animal 'cebra)</code> verás <code>nil</code> impreso en el área echo.</p>
</div>
<h4 id="La-función-tipo-de-animal-en-detalle" >La función <code>tipo-de-animal</code> en detalle</h4>
<div class="hBody-4" >
<p>Veamos la función <code>tipo-de-animal</code> en detalle.</p>
<p>La definición de función <code>tipo-de-animal</code> se escribio llenando los espacios de dos plantillas, la primera para la definición de función como un todo, y la segunda para una expresión <code>if</code>.</p>
<p>La plantilla para cada función no interactiva es:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>Las partes de la función que encajan con esta plantilla se ven asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&quot;Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.</span>
<span class="s">     Si la CARACTERISTICA es el símbolo ‘fiero’,</span>
<span class="s">     entonces advierte que es un tigre.&quot;</span>
  <span class="p">(</span><span class="nv">cuerpo:</span> <span class="nv">la</span> <span class="nv">expresion</span> <span class="k">if</span><span class="p">))</span>
</pre></div>
<p>El nombre de función es <code>tipo-de-animal</code>; se pasa al valor de un argumento. A la lista de argumentos le sigue una cadena de documentación multi-línea. La cadena de documentación se incluiye en el ejemplo porque es un buen hábito escribir la cadena de documentación para cada definición de función. El cuerpo de la definición de función consiste en la expresión <code>if</code>.</p>
<p>La plantilla para una expresión <code>if</code> se ve así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-la-prueba-devuelve-verdadero</span><span class="p">)</span>
</pre></div>
<p>En la función <code>tipo-de-animal</code>, el código para <code>if</code> se ve así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;¡Es un tigre!&quot;</span><span class="p">)))</span>
</pre></div>
<p>Aquí, está la expresión prueba-verdadero-o-falso</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
</pre></div>
<p>En Lisp, <code>equal</code> es una función que determina si su primer argumento es igual a su segundo argumento. El segundo argumento es el símbolo citado <code>'fiero</code> y el primer argumento es el valor del símbolo <code>característico</code>––en otras palabras, el argumento pasado a esta función.</p>
<p>En la primer prueba de <code>tipo-de-animal</code>, el argumento <code>fiero</code> se pasa a <code>tipo-de-animal</code>. Ya que <code>fiero</code> es igual a <code>fiero</code>, la expresión, <code>(equal caracteristica 'fiero)</code>, devuelve el valor verdadero. Cuando esto sucede, <code>if</code> evalúa el segundo argumento o la parte-entonces del <code>if</code>: <code>(message &quot;¡Es un tigre!&quot;)</code>.</p>
<p>Por otro lado, en la segunda prueba de <code>tipo-de-animal</code>, se pasa el argumento <code>cebra</code> a <code>tipo-de-animal</code>. <code>cebra</code> no es igual a <code>fiero</code>, por lo que la parte-entonces no se evalua y se devuelve <code>nil</code> por la expresión <code>if</code>).</p>
</div>
<h3 id="Expresiones-if–then–else" >Expresiones if–then–else</h3>
<div class="hBody-3" >
<p>Una expresión <code>if</code> puede tener un tercer argumento opcional, llamado <dfn>else-part</dfn> (parte-de-otro-modo), en caso de que la prueba-verdadero-o-falso devuelva falso. Cuando esto sucede, el segundo argumento o then-part de la expresión <code>if</code> global <em>no</em> se evalúa, pero el tercer argumento o parte-de-otro-modo <em>se</em> evalúa. Podría pensar en esto como la alternativa del día nublado para la decisión “si es cálido y soleado, entonces ir a la playa!, de otro modo leer un libro!”</p>
<p>La palabra “else” (de otro modo) no se escribe en el código Lisp; la parte-de-otro-modo de una expresión <code>if</code> viene después de la parte-entonces. En Lisp, la parte-de-otro-modo suele escribirse al inicio de una nueva linea y se indenta menos que la parte-entonces:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-la-prueba-devuelve-verdadero</span>
  <span class="nv">accion-a-realizar-si-la-prueba-devuelve-falso</span><span class="p">)</span>
</pre></div>
<p>Por ejemplo, la siguiente expresión <code>if</code> imprime el mensaje <samp>¡4 no es mayor que 5!</samp> al evaluarse en la forma habitual:</p>
<pre><code class="example">(if (&gt; 4 5)                                   ; parte-if
    (message &quot;¡4 falsamente es mayor que 5!&quot;) ; parte-then
  (message &quot;¡4 no es mayor que 5!&quot;))          ; parte-else</code></pre>
<p>Tenga en cuenta que los diferentes niveles de indentación hacen fácil distinguir la parte-entonces de la parte-de-otro-modo. (GNU Emacs tiene varios comandos que indentan automáticamente expresiones <code>if</code> de forma apropiada. Véase Sección <a href="#GNU-Emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</a>.)</p>
<p>Podemos ampliar la función <code>tipo-de-animal</code> para incluir una parte-else simplemente incorporando una parte adicional para la expresión <code>if</code>.</p>
<p>Puedes ver las consecuencias de hacer esto si evalúas para instalar la siguiente versión de la definición de función <code>tipo-de-animal</code> y luego evaluas las dos expresiones suguientes que pasan diferentes argumentos a la función.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&quot;Imprime el mensaje en el área echo dependiendo de CARACTERISTICA.</span>
<span class="s">     Si la CARACTERISTICA es el símbolo ‘fiero’,</span>
<span class="s">     entonces advierte que es un tigre.</span>
<span class="s">     de otro modo decir que no es fiero&quot;</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;¡Es un tigre!&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;!No es feroz!&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;cebra</span><span class="p">)</span>
</pre></div>
<p>&lt; example..</p>
<p>Al evalar <code>(tipo-de-animal 'fiero)</code>, verás el siguiente mensaje en el área echo: <code>&quot;¡Es un tigre!&quot;</code>; pero cuando evalues <code>(tipo-de-animal 'cebra)</code>, verás <code>&quot;¡No es feroz!&quot;</code>.</p>
<p>(Por supuesto, si <code>característica</code> fuera <code>muy feroz</code>, se imprimiria el mensaje <code>&quot;¡No es feroz!&quot;</code>; ¡y sería un error!  Cuando escribas código, necesitas tener en cuenta la posibilidad de que algun argumento como este será puesto a prueba por <code>if</code> y acorde a ello escribir tu programa.</p>
</div>
<h3 id="Verdad-y-Falsedad-en-Emacs-Lisp" >Verdad y Falsedad en Emacs Lisp</h3>
<div class="hBody-3" >
<p>Hay un aspecto importante para la prueba verdadero en una expresión <code>if</code>. Hasta ahora, hemos hablado de ‘verdadero’ y ‘falso’ como valores de predicados como si fueran nuevos tipos de objetos Emacs Lisp. De hecho, solo nuestro viejo amigo <code>nil</code> es ‘falso’. Cualquier otra cosa––cualquiera en absoluto––es ‘verdadero’.</p>
<p>La expresión que prueba si es verdadero se interpreta como (<dfn>true</dfn>) (verdadero) si el resultado de la evaluacion es no <code>nil</code>. En otras palabras, el resultado de la prueba se considera verdadero si el valor devuelto es un número como 47, una cadena como <code>&quot;hola&quot;</code>, o un símbolo (distinto a <code>nil</code>) como <code>flores</code>, o una lista (siempre y cuando no este vacía) o incluso ¡un búffer!</p>
<p>Antes de ilustrar una prueba para verdadero, necesitamos una explicación de <code>nil</code>.</p>
<p>En Emacs Lisp, el símbolo <code>nil</code> tiene dos significados. En primer lugar, significa que la lista está vacía. En segundo lugar, significa falso y es el valor devuelto cuando una prueba-verdadero-o-falso obtiene falso. <code>nil</code> puede escribirse como una lista vacia, <code>()</code>, o como <code>nil</code>. En lo referente al interprete Lisp <code>()</code> y <code>nil</code> son lo mismo. Los humanos, sin embargo, tienden a usar <code>nil</code> para falso y <code>()</code> para lista vacía.</p>
<p>En Emacs Lisp, cualquier valor que no sea <code>nil</code>––no es una lista vacía––es considerado verdadero. Esto significa que si una evaluación devuelve algo que no es una lista vacía, una expresión <code>if</code> pondra a prueba verdadero. Por ejemplo, si un número se coloca en el lugar de la prueba, será evaluado y devolverá su valor, ya que eso es lo que hacen los números cuando se evalúan. En este condicional, la expresión <code>if</code> devuelve verdadero. La expresión prueba falso solo cuando <code>nil</code>, o una lista vacía, son devueltas al evaluar la expresión.</p>
<p>Puedes ver esto evaluando las dos expresiones en los siguientes ejemplos.</p>
<p>En el primer ejemplo, el número 4 se evalua como la prueba en la expresión <code>if</code> y devuelve el numero en si; en consecuencia, se evalua y devuelve la then-part de la expresión: aparece <samp>verdadero</samp> en el área echo. En el segundo ejemplo, <code>nil</code> indica falso; en consecuencia, se evalua y devuelve la else-part de la expresión: aparece <samp>falso</samp> en el área echo.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="mi">4</span>
    <span class="ss">&#39;verdadero</span>
  <span class="ss">&#39;falso</span><span class="p">)</span>

<span class="p">(</span><span class="k">if</span> <span class="no">nil</span>
    <span class="ss">&#39;verdadero</span>
  <span class="ss">&#39;falso</span><span class="p">)</span>
</pre></div>
<p>Por cierto, si algún otro valor de utilidad no está disponible para una prueba que devuelve verdadero, entonces el intérprete Lisp devolvera el símbolo <code>t</code> para verdadero. Por ejemplo, la expresión <code>(&gt; 5 4)</code> devuelve <code>t</code> cuando se evalúa, como puedes comprobar al evaluarlo:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
<p>Por otra parte, esta función devuelve <code>nil</code> si la prueba es falso.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<h3 id="save-excursion" ><code>save-excursion</code></h3>
<div class="hBody-3" >
<p>La función <code>save-excursion</code> es la cuarta y última forma especial vamos a discutir en este capítulo.</p>
<p>En los programas Emacs Lisp utilizados para edición, la función <code>save-excursion</code> es muy común. Guarda la posición del punto y la marca, ejecuta el cuerpo de la función, y luego restaura el punto y marca a sus posiciones previas si sus posiciones fueron cambiadas. Su objetivo principal es impedir que el usuario sea sorprendido y perturbado por el movimiento inesperado del punto o la marca.</p>
<p>Antes de hablar de <code>save-excursion</code>, puede ser útil examinar primero que son el punto y la marca en GNU Emacs. <dfn>Punto</dfn> es la posición actual del cursor. Donde sea que se encuentre el cursor, estara el punto. De forma más precisa, en los terminales donde aparece el cursor sobre un carácter, el punto está inmediatamente antes del carácter. En Emacs Lisp, el punto es un numero entero. El primer carácter en un búffer es el número uno, el segundo es el número dos, y así sucesivamente. La función <code>point</code> devuelve la posición actual del cursor como un número. Cada búffer tiene su propio valor para el punto.</p>
<p>La <dfn>marca</dfn> es otra posición en el búffer; su valor se puede establecer con un comando como <kbd>C-SPC</kbd> (<code>set-mark-command</code>). Si una marca se ha establecido, puede utilizar el comando <kbd>C-x C-x</kbd> (<code>exchange-point-and-mark</code>) para hacer que el cursor salte a la marca y establecer la marca en la posición previa del punto. Además, si se establece otra marca, la posición le da marca anterior se guarda en el historico de marcas, puede guardar muchas posiciones de las marcas de esta forma. Se puede saltar el cursor a una marca guardada presionando <kbd>C-u C-SPC</kbd> una o más veces.</p>
<p>La parte del búffer entre el punto y la marca se llamada <dfn>la región</dfn>. Numerosos comandos trabajan en la región, incluyendo <code>center-region</code>, <code>count-lines-region</code>, <code>kill-region</code> y <code>print-region</code>.</p>
<p>La forma especial <code>save-excursion</code> guarda las posiciones del punto y la marca y restaura estas posiciones después que el interprete Lisp evalua el código dentro del cuerpo de la forma especial. De este modo, si el punto se encontraba al inicio de un trozo de texto y algún código movido el punto al final del búffer, <code>save-excursion</code> pondria el punto de nuevo donde estaba antes, luego que las expresiones en el cuerpo de la funcion fueran evaluadas.</p>
<p>En Emacs, con frecuencia una función mueve el punto como parte de su funcionamiento interno a pesar de que un usuario no espere esto. Por ejemplo, <code>count-lines-region</code> mueve el punto. Para evitar que el usuario sea molestado por los saltos que sol a la vez inesperados e (desde el punto de vista del usuario) innecesarios, <code>save-excursion</code> se utiliza a menudo para mantener el punto y la marca en la posición esperada por el usuario. El uso de <code>save-excursion</code> es bueno para mantener el orden.</p>
<p>Para asegurarse que la casa se mantiene limpia, <code>save-excursion</code> restaura los valores del punto y la marca incluso si algo va mal en el código dentro de ella (o, para ser más preciso y usar el lenguaje tecnico apropiado, “en caso de salida anormal”). Esta funcionalidad es muy útil.</p>
<p>Además de registrar los valores del punto y marca, <code>save-excursion</code> no pierde de vista el buffer actual, y lo restaura, también. Esto significa que puedes escribir código que cambie el buffer y <code>save-excursion</code> debe volver al buffer original. Asi es como se utiliza <code>save-excursion</code> en <code>append-to-buffer</code>. (Véase Sección <a href="#La-Definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>.)</p>
</div>
<h4 id="Plantilla-para-una-Expresión-save-excursion" >Plantilla para una Expresión <code>save-excursion</code></h4>
<div class="hBody-4" >
<p>La plantilla de código usando <code>save-excursion</code> es simple:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>El cuerpo de la función es una o más expresiones que serán evaluadas de forma secuencial por el intérprete Lisp. Si hay más de una expresión en el cuerpo, el valor de la última será devuelto como el valor de la función <code>save-excursion</code>. Las otras expresiones en el cuerpo solo se evaluan por sus efectos secundarios; y <code>save-excursion</code> en sí solo se utiliza por su efecto secundario (que es restaurar las posiciones del punto y la marca).</p>
<p>La siguiente plantilla explica <code>save-excursion</code>, con más detalle:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
  <span class="nv">primera-expresion-en-el-cuerpo</span>
  <span class="nv">segunda-expresion-en-el-cuerpo</span>
  <span class="nv">tercera-expresion-en-el-cuerpo</span>
   <span class="err">…</span>
  <span class="nv">ultima-expresion-en-el-cuerpo</span><span class="p">)</span>
</pre></div>
<p>Una expresión, por supuesto, puede ser un símbolo por sí mismo o una lista.</p>
<p>En el código Emacs Lisp, una expresión <code>save-excursion</code> a menudo ocurre dentro del cuerpo de una expresión <code>let</code>. Se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="nv">varlist</span>
  <span class="p">(</span><span class="k">save-excursion</span>
    <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</pre></div>
</div>
<h3 id="Repaso" ><span id="Repaso: Cómo escribir definiciones de funciones" >Repaso</span></h3>
<div class="hBody-3" >
<p>En los últimos capítulos se han introducido un buen número de funciones y formas especiales. A continuacion se describen brevemente, junto con algunas funciones similares que aun no han sido mencionadas.</p>
<dl>
<dt><p>eval-last-sexp</p>
</dt>
<dd><p>Evalúar la última expresión simbólica antes de la posición actual del punto. El valor se imprime en el área echo a menos que la función se invoque con un argumento; en este caso, la salida se imprime en el búffer actual. Este comando está normalmente esta asociado a <kbd>C-x C-e</kbd>.</p>
</dd>
<dt><p>defun</p>
</dt>
<dd><p>Definir la función. Esta forma especial tiene hasta cinco partes: el nombre una plantilla para los argumentos que se pasan a la función, la documentacion, una declaración interactiva opcional, y el cuerpo de la definición.</p>
<p>Por ejemplo, en las primeras versiones de Emacs, la definición de función era como sigue. (Eso es ligeramente más complejo ahora que se busca el primer caracter que no es espacio en lugar del primer caracter visible.)</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">volver-a-la-indentacion</span> <span class="p">()</span>
  <span class="s">&quot;Mueve el punto al primer caracter visible de la linea.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">beginning-of-line</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">skip-chars-forward</span> <span class="s">&quot; \t&quot;</span><span class="p">))</span>
</pre></div>
</dd>
<dt><p>interactive</p>
</dt>
<dd><p>Anuncia al intérprete que la función se puede usar de forma interactiva. Esta forma especial puede ser seguida por una cadena con una o más partes que pasan la información a los argumentos de la función, de forma secuencial. Estas partes pueden también decir al intérprete que solicite información. Las Partes de la cadena estan separadas por saltos de linea, <samp>\n</samp>.</p>
<p>Los codigos de caractere comúnes son:</p>
<dl>
<dt><p>b</p>
</dt>
<dd><p>El nombre de un búffer existente.</p>
</dd>
<dt><p>f</p>
</dt>
<dd><p>El nombre de un fichero existente</p>
</dd>
<dt><p>p</p>
</dt>
<dd><p>El argumento prefijo numérico. (Tenga en cuenta que esta ‘p’ es minúscula.)</p>
</dd>
<dt><p>r</p>
</dt>
<dd><p>Punto y marca, como dos argumentos numéricos, el más pequeño primero. Este es el unico codigo de una letra que especifica dos argumentos sucesivos en vez de uno.</p>
</dd>
</dl>
<p>Véase Sección <a href="info:elips#Interactive-Codes" >Codigo de caracteres para <samp>interactive</samp></a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para obtener una lista completa de los codigos de caracteres.</p>
</dd>
<dt><p>let</p>
</dt>
<dd><p>Declarar que una lista de variables para utilizarla dentro del cuerpo de <code>let</code> y darle a cada una un valor inicial, ya sea <code>nil</code> o un valor específico; luego evaluar el resto de las expresiones en el cuerpo del <code>let</code> y devolver el valor de la última expresion. Dentro del cuerpo del <code>let</code>, el intérprete Lisp no ve los valores de variables con el mismos nombre fuera de <code>let</code>.</p>
<p>Por ejemplo,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">foo</span> <span class="p">(</span><span class="nf">buffer-name</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">bar</span> <span class="p">(</span><span class="nf">buffer-size</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&quot;Este buffer es %s y tiene %d caracteres.&quot;</span>
   <span class="nv">foo</span> <span class="nv">bar</span><span class="p">))</span>
</pre></div>
</dd>
<dt><p>save-excursion</p>
</dt>
<dd><p>Registra los valores de punto y marca y el búffer actual antes de evaluar el cuerpo de esta forma especial. Restaura los valores de punto y marca y el búffer luego de esto.</p>
<p>Por ejemplo,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Estamos %d caracteres dentro de este buffer.&quot;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span>
            <span class="p">(</span><span class="k">save-excursion</span>
              <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</pre></div>
</dd>
<dt><p>if</p>
</dt>
<dd><p>Evalúa el primer argumento a la función; si es verdadero, evalúa el segundo argumento; de otra forma evalúa el tercer argumento, si hay uno.</p>
<p>La forma especial <code>if</code> se llamada <dfn>condicional</dfn>. Hay otros condicionales en Emacs Lisp, pero <code>if</code> es quizás el más comúnmente usado.</p>
<p>Por ejemplo,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">=</span> <span class="mi">24</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Esta es la version 24 de Emacs&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Esta no es la version 24 de Emacs&quot;</span><span class="p">))</span>
</pre></div>
</dd>
<dt><p>&lt;</p>
</dt>
<dd><ul class="dialog" >
<li><p>::</p>
</li>
</ul>
<p>&lt;= :: &gt;= ::</p>
<p>La función <code>&lt;</code> prueba si su primer argumento es menor que su segundo argumento. Una función correspondiente, <code>&gt;</code>, prueba si el primer argumento es mayor que el segundo. Del mismo modo, <code>&lt;=</code> prueba si el primer argumento es menor o igual al segundo y <code>&gt;=</code> prueba si el primer argumento es mayor o igual al segundo. En todos los casos, ambos argumentos deben ser números o marcadores (los marcadores indican posiciones en búffers).</p>
</dd>
<dt><p>=</p>
</dt>
<dd><p>La función <code>=</code> prueba si dos argumentos, ambos números o marcadores, son iguales.</p>
</dd>
<dt><p>equal</p>
</dt>
<dd><p>eq    ::</p>
<p>Prueba si dos objetos son el mismo. <code>equal</code> utiliza un signicado de la palabra ‘mismo’ y <code>eq</code> utiliza otro: <code>equal</code> devuelve verdadero si los dos objetos tienen una estructura y contenidos similares, por ejemplo, dos copias del mismo libro. Por otro lado, <code>eq</code>, devuelve verdadero si ambos argumentos son realmente el mismo objeto.</p>
</dd>
<dt><p>string&lt;</p>
</dt>
<dd><p>string-lessp :: string=      :: string-equal ::</p>
<p>La función <code>string-lessp</code> prueba si su primer argumento menor que el segundo. Un nombre alternativo mas corto para la misma función (un <code>defalias</code>) es <code>string&lt;</code>.</p>
<p>Los argumentos para <code>string-lessp</code> deben ser cadenas o símbolos; la ordenación es lexicográfica, por lo que mayusculas o minusculas son significativas. Los nombres impresos de símbolos se utilizan en lugar de los propias símbolos.</p>
<p>Una cadena vacía, <samp>&quot;&quot;</samp>, una cadena sin caracteres en ella, es más pequeña que cualquier cadena de caracteres.</p>
<p><code>string-equal</code> proporciona la prueba correpondiente para la igualdad. Su nombre corto alternativo es <code>string=</code>. No hay funciones de prueba que correspondan a <code>&gt;</code>, <code>&gt;=</code> o <code>&lt;=</code>.</p>
</dd>
<dt><p>message</p>
</dt>
<dd><p>Imprime un mensaje en el área echo. El primer argumento es una cadena que puede contener, <samp>%s</samp>, <samp>%d</samp>, o <samp>%c</samp> para imprimir el valor de los argumentos que siguen a la la cadena. El argumento utilizado por <samp>%s</samp> debe ser una cadena o un simbolo, el argumeto utilizado por <samp>%d</samp> debe ser un número. El argumento usado por <samp>%c</samp> debe ser un codigo númerico <em>ASCII</em>; se imprimira como el caracter con este código <em>ASCII</em>. (Otras se han mencionado otras secuencias <code>%-</code>).</p>
</dd>
<dt><p>setq</p>
</dt>
<dd><p>set  ::</p>
<p>La función <code>setq</code> asigna el valor de su primer argumento al valor del segundo argumento. El primer argumento es citado automáticamente por <code>setq</code>. No hace lo mismo para pares sucesisvos de argumentos. Otra función, <code>set</code>, toma solo dos argumentos y evalúa ambos antes de asignar el valor devuelto por su primer argumento al valor devuelto por el segundo argumento.</p>
</dd>
<dt><p>buffer-name</p>
</dt>
<dd><p>Sin un argumento, devuelve el nombre del búffer, como una cadena.</p>
</dd>
<dt><p>buffer-file-name</p>
</dt>
<dd><p>Sin un argumento, devuelve el nombre del fichero del búffer que se esta visitando.</p>
</dd>
<dt><p>current-buffer</p>
</dt>
<dd><p>Devuelve el búffer en el que Emacs se encuentra activo; Puede que no sea el búffer que es visible en la pantalla.</p>
</dd>
<dt><p>other-buffer</p>
</dt>
<dd><p>Devuelve el ultimo búffer seleccionado (que no sea el buffer pasado a <code>other-buffer</code> como un argumento y que no sea el búffer actual).</p>
</dd>
<dt><p>switch-to-buffer</p>
</dt>
<dd><p>Selecciona un búffer de Emacs para activarlo y mostralo en la ventana actual para que los usuarios puedan verlo. Normalmente ligado a <kbd>C-x b</kbd>.</p>
</dd>
<dt><p>set-buffer</p>
</dt>
<dd><p>Cambiar la atención de Emacs a un búffer en el que se ejecutaran programas. No altera lo que la ventana está mostrando.</p>
</dd>
<dt><p>buffer-size</p>
</dt>
<dd><p>Devuelve el número de caracteres en el búffer actual.</p>
</dd>
<dt><p>point</p>
</dt>
<dd><p>Devuelve el valor de la posicion actual del cursor, como un entero contando el número de caracteres desde el inicio del búffer.</p>
</dd>
<dt><p>point-min</p>
</dt>
<dd><p>Devuelve el valor mínimo permisible del punto en el búffer actual. Esto es 1, a menos que narrowing esté activo</p>
</dd>
<dt><p>point-max</p>
</dt>
<dd><p>Devuelve el valor del máximo permisible del punto en el búffer actual. Esto es el fin del búffer, a menos que narrowing este activo.</p>
</dd>
</dl>
</div>
<h3 id="Ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<ul>
<li><p>Escribe una función no interactiva que diplique el valor de su argumento, un número. Luego haz la función interactiva.</p>
</li>
<li><p>Escribe una función que compruebe si el valor actual de <code>fill-column</code> es mayor que el argumento pasado a la función, y si es así, imprime un mensaje apropiado.</p>
</li>
</ul>
</div>
<h2 id="Algunas-funcienes-relacionadas-al-buffer" >Algunas funcienes relacionadas al buffer</h2>
<div class="hBody-2" >
<p>En este capítulo estudiamos en detalle varias de las funciones usadas en GNU Emacs. Esto se llama un “walk-through” (visita o demostracion de un area o tarea). Estas funciones se utilizan como ejemplos de código Lisp, pero no son ejemplos imaginarios; con excepción del primero, con la definición de función simplificada, estas funciones muestran el código real usado en GNU Emacs. Se puede aprender mucho de estas definiciones. Las funciones descritas aquí están todas relacionadas a búffers. Mas tarde, estudiaremos otras funciones.</p>
</div>
<h3 id="Encontrar-Más-información" >Encontrar Más información</h3>
<div class="hBody-3" >
<p>En este recorrido, describire cada nueva función, algunas veces en detalle y algunas veces brevemente. Si estás interesado, puedes obtener la documentación completa de cualquier función de Emacs Lisp en cualquier momento presiona <kbd>C-h f</kbd> y luego escribe el nombre de la función (y luego <kbd>RET</kbd>). Del mismo modo, se puede obtener la documentación completa de una variable con <kbd>C-h v</kbd>, luego el nombre de la variable (y despues <kbd>RET</kbd>).</p>
<p>Ademas, <code>describe-function</code> te dira la ubicacion de la definición de la función.</p>
<p>Coloca el punto dentro del nombre del fichero que contiene la función y presiona la tecla <kbd>RET</kbd>. En este caso, <kbd>RET</kbd> significa <code>push-button</code> en lugar de ‘return’ o ‘enter’. Emacs te llevara directamente a la definición de la función.</p>
<p>De manera más general, si quieres ver una función en su fichero fuente original, puedes utilizar la función <code>find-tag</code> para saltar a la misma. <code>find-tag</code> trabaja con una amplia variedad de lenguajes, no solo Lisp, y C, y tambien funciona con texto que no codigo de programacion. Por ejemplo, <code>find-tag</code> saltará a los distintos nodos del codigo fuente de este documento. La función <code>find-tag</code> depende de ‘tablas de etiquetas’ que registran las ubicaciones de las funciones, variables, y otros elementos a los que <code>find-tag</code> salta.</p>
<p>Para usar el comando <code>find-tag</code>, presiona <kbd>M-.</kbd> (es decir, presiona la tecla punto mientras presionas la tecla <kbd>META</kbd>, o presiona <kbd>ESC</kbd> y luego la tecla punto), a continuacion, en es prompt, escribe el nombre de la función para ver su código fuente, por ejemplo <code>mark-whole-buffer</code>, y luego pulsa <kbd>RET</kbd>. Emacs cambiará de búffer y mostrará el código fuente de la función en la pantalla. Para regresar a tu búffer actual, presiona <kbd>C-x b RET</kbd>. (En algunos teclados, la tecla <kbd>META</kbd> se etiqueta como <kbd>ALT</kbd>.)</p>
<p>Dependiendo de la configuracion de los valores iniciales por defecto de tu copia de Emacs, puede ser necesario especificar la posición de tu ‘tabla de tags’, que es un fichero llamado <span class="file" >TAGS</span>. Por ejemplo, si estás interesado en el codigo fuente de Emacs, la tabla de tags, si ya ha sido creada, estará en un subdirectorio del directorio <span class="file" >/usr/local/share/emacs</span>; de este modo se usaría el comando <code>M-x visit-tags-table</code> y se especifica una ruta como <span class="file" >/usr/local/share/emacs/24.1.1/lisp/TAGS</span>. Si la tabla de etiquetas no ha sido creada, tendrás que crearla por tí mismo. Estara en un fichero como <span class="file" >/usr/local/src/emacs/src/TAGS</span>.</p>
<p>Para crear un fichero <span class="file" >TAGS</span> en un directorio específico, cambia a ese directorio en Emacs mediante el comando <kbd>M-x cd</kbd>, o lista el directorio con <kbd>C-x d</kbd> (<code>dired</code>). A continuacion ejecuta el comando de compilacion, con <code>etags *.el</code> como comando a ejecutar:</p>
<pre><code class="example">M-x compile RET etags *.el RET</code></pre>
<p>Para más información, ver <a href="#Crea-tu-propio-fichero-TAGS" >Crea tu propio fichero <span class="file" >TAGS</span></a>.</p>
<p>Después de te familiarices con Emacs Lisp, te encontrarás con frecuencia utilizando <code>find-tag</code> como metodo de navegar atraves del código fuente; y crearás tus propias tablas <span class="file" >TAGS</span>.</p>
<p>Por cierto, los ficheros que contienen código Lisp son llamados convencionalmente <dfn>librerías</dfn>. La metáfora se deriva que una librería especializada, tal como una librería de leyes o una librería de ingeniería, en lugar de una librería general. Cada librería, o fichero, contiene funciones que se relacionan con un tema o actividad determinado, por ejemplo <span class="file" >abbrev.el</span> para el manejo de abreviaturas y otros atajos, y <span class="file" >help.el</span> para ayuda on-line. (Algunas veces varias librerías proporcionan código para una sola actividad, como los distintos ficheros <span class="file" >rmail…</span>  que proporcionan para leer correo electrónico.) En <em>El Manual de GNU Emacs</em>, verás varias frases como “El comando <kbd>C-h p</kbd> te permite buscar las librerias estándar de Emacs Lisp por la palabra clave del tema.</p>
</div>
<h3 id="Una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></h3>
<div class="hBody-3" >
<p>El comando <code>beginning-of-buffer</code> es una buena función para empezar, ya que es probable que estes familiarizado con ella y es fácil de entender. Usado como un comando interactivo, <code>beginning-of-buffer</code> mueve el cursor al inicio del búffer, dejando la marca en la posición anterior. Esta generalmente unido a <kbd>M-&lt;</kbd>.</p>
<p>En esta sección, vamos a hablar de une versión reducida de la función que muestra como se utiliza con mayor frecuencia. Esta función reducida funciona como esta escrita, pero no contiene código para una opcion compleja. En otra sección, describiremos la función entera. (Véase Sección <a href="#Definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></a>.</p>
<p>Antes de mirar el código, vamos a considerar lo que la definición de función tiene que contener: debe incluir una expresión que haga la función interactiva por lo que se puede llamar escribiendo <kbd>M-x beginning-of-buffer</kbd> o pulsando uno atajos como <kbd>M-&lt;</kbd>; debe incluir código para dejar una marca en la posición original del búffer; y debe incluir código para mover el cursor al inicio del búffer.</p>
<p>Aquí está el texto completo la versión reducida de la función:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">simplified-beginning-of-buffer</span> <span class="p">()</span>
  <span class="s">&quot;Mover el punto al inicio del buffer;</span>
<span class="s">dejar marca en la posicion anterior.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
</pre></div>
<p>Al igual que todas las definiciones de función, esta definición tiene cinco partes siguiendo la forma especial <code>defun</code>:</p>
<ol>
<li><p>El nombre: en este ejemplo, <code>simplified-beginning-of-buffer</code>.</p>
</li>
<li><p>Una lista de los argumentos: en este ejemplo, una lista vacía, <code>()</code>,</p>
</li>
<li><p>La cadena de documentación.</p>
</li>
<li><p>La expresión interactiva.</p>
</li>
<li><p>El cuerpo.</p>
</li>
</ol>
<p>En esta definición de función, la lista de argumentos está vacía; esto significa que esta función no requiere ningun argumento. (Cuando nos fijamos en la definición de la función completa, veremos que se puede pasar un argumento opcional.)</p>
<p>La expresión interactiva le informa a Emacs que se pretende utilizar la función de forma interactiva. En este ejemplo, <code>interactive</code> no tiene un argumento porque <code>simplified-beginning-of-buffer</code> no requiere uno.</p>
<p>El cuerpo de la función consiste de dos líneas:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
</pre></div>
<p>La primera de estas líneas es la expresión, <code>(push-mark)</code>. Cuando el interprete Lisp evalua esta expresión, se establece una marca en la posición actual del cursor, donde sea que este. La posición de esta marca se guarda en el anillo de marcas.</p>
<p>La siguiente línea es <code>(goto-char (point-min))</code>. Esta expresión hace saltar el cursor hasta el punto mínimo en el búffer, es decir, al inicio del búffer (o al inicio de la porción accesible del búffer si narrowed esta activo. Véase Sección <a href="#Reducir-y-Extender" >Reducir y Extender</a>.)</p>
<p>El comando <code>push-mark</code> establece una marca en el sitio donde se encontraba el cursor antes de transladarse al inicio del búffer por la expresión <code>(goto-char (point-min))</code>. En consecuencia, puedes, si quieres, volver a donde estabas originalmente presionando <kbd>C-x C-x</kbd>.</p>
<p>¡Esto es todo lo que hay en la definición de función!</p>
<p>Cuando leas código como este y te encuentres con una función desconocida, como <code>goto-char</code>, puedes averiguar que es lo que hace mediante el comando <code>describe-function</code>. Para usar este comando, presiona <kbd>C-h f</kbd> y luego escribe el nombre de la función y presiona <kbd>RET</kbd>. El comando <code>describe-function</code> imprimirá la cadena de documentacion de la función en una ventana <span class="file" >*Help*</span>. Por ejemplo, la documentación de <code>goto-char</code> es:</p>
<pre><code class="example">Establece el punto a POSICION, un numero o marcador.
El inicio del buffer es la posicion (point-min), el final es (point-max).</code></pre>
<p>El argumento de la función es la posición deseada.</p>
<p>(En el caso de <code>describe-function</code> el prompt te facilita el símbolo debajo o anterior al cursor, lo que te puede evitar escribir el nombre de la funcion al colocar el cursor a la justo sobre o después de la función y luego presionar <kbd>C-h f RET</kbd>.)</p>
<p>La definición de la función <code>end-of-buffer</code> se escribe de la misma forma que la definición <code>beginnig-of-buffer</code> excepto que el cuerpo de la función contiene la expresión <code>(goto-char (point-max))</code> en lugar de <code>(goto-char (point-min))</code></p>
</div>
<h3 id="La-definición-de-mark-whole-buffer" >La definición de <code>mark-whole-buffer</code></h3>
<div class="hBody-3" >
<p>La función <code>mark-whole-buffer</code> no es mas difícil de entender que la función <code>simplified-beginning-of-buffer</code>. En este caso, sin embargo, vamos a ver la función completa, no una versión reducida.</p>
<p>La función <code>mark-whole-buffer</code> no se utiliza tan comúnmente como la función <code>beginning-of-buffer</code>, pero no es menos útil: marca un búffer completo como una región colocando el punto al inicio y una marca al fin del búffer. Generalmente se une a <kbd>C-x h</kbd>.</p>
<p>En GNU Emacs 22, el código de la función completa se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">mark-whole-buffer</span> <span class="p">()</span>
  <span class="s">&quot;Coloca el punto al inicio y marca el fin del buffer.</span>
<span class="s">Probablemente no deberias utilizar esta funcion en programas Lisp;</span>
<span class="s">Por lo general es un error para una funcion Lisp utilizar cualquier subrutino</span>
<span class="s">que utiliza o establece la marca.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
</pre></div>
<p>Al igual que todas las demas funciones, la función <code>mark-whole-buffer</code> se ajusta dentro de la plantilla de una definición de funcion. La plantilla luce asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="nv">expresion-interactiva</span><span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>Aquí el cómo funciona la función: el nombre de la función es <code>mark-whole-buffer</code>; es seguido por una lista de argumentos vacía, <samp>()</samp>, que significa que la función no requiere argumentos. La documentación viene a continuacion.</p>
<p>La siguiente línea es una expresión <code>(interactive)</code> que indica a Emacs que la función se utilizara de forma interactiva. Estos detalles son similares a la función <code>simplified-beginning-of-buffer</code> descrita en la sección anterior</p>
</div>
<h4 id="Cuerpo-de-mark-whole-buffer" >Cuerpo de <code>mark-whole-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>mark-whole-buffer</code> consiste en tres líneas de código:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
<span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
</pre></div>
<p>La primera de estas líneas es la expresión, <code>(push-mark (point))</code>.</p>
<p>Esta línea hace exactamente el mismo trabajo que la primera línea del cuerpo de la función <code>simplified-beginning-of-buffer</code>, en la que solo se escribe <code>(push-mark)</code>. En ambos casos, el intérprete Lisp coloca una marca en la posición actual del cursor.</p>
<p>No sé por qué en la expresión <code>mark-whole-buffer</code> se escribe <code>(push-mark (point))</code> y en la expresión <code>beginning-of-buffer</code> se escribe <code>(push-mark)</code>. Quizás quien escribió el código no conocia que los argumentos de <code>push-mark</code> son opcionales y que si no se pasa un argumento a <code>push-mark</code>, la función establece automáticamente la marca en la posicion del punto por defecto. O quizás la expresión fué escrita paralelamente a la estructura de la siguiente línea. En cualquier caso, la línea proboca que Emacs determine la posición del punto y coloque una marca allí.</p>
<p>En versiones anteriores de GNU Emacs, la siguiente línea de <code>mark-whole-buffer</code> era <code>(push-mark (point-max))</code>. Esta expresión establece una marca en el punto del búffer que tiene el número más alto. Este será el final del búffer (o, si el búffer tiene actio narrowing, el final de la porción accesible del búffer. Véase Sección <a href="#Reducir-y-Extender" >Reducir y Extender</a>, para más informacon sobre norrowing). Después de colocar esta marca, la marca anterior, la establecida en el punto, ya no esta configurada, pero Emacs recuerda su posición, al igual que recuerda todas las demas marcas recientes. Esto significa que se puedes, si lo deseas, volver a esta posición presionando <kbd>C-u C-SPC</kbd> dos veces.</p>
<p>En GNU Emacs 22, <code>(point-max)</code> es ligeramente más complicado. La línea es</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
</pre></div>
<p>La expresión funciona casi igual que antes. Se establece una marca en la posicion con la numeracion mas alta posible en el búffer. Sin embargo, en esta versión, <code>push-mark</code> tiene dos argumentos adicionales. El segundo argumento de <code>push-mark</code> es <code>nil</code>. Esto indica a la función que debe <em>mostrar</em> un mensaje que dice ‘Mark set’ cuando se coloca la marca. El tercer argumento es <code>t</code>. Esto indica a <code>push-mark</code> que active la marca cuando el modo Transient Mark está activo. Transient Mark mode resalta la región activa. Con frecuencia esta desactivado.</p>
<p>Finalmente, la última línea de la función es <code>(goto-char (point-min))</code>. Esta escrito exactamente de la misma forma como está escrito <code>beginning-of-buffer</code>. La expresión mueve el cursor al punto mínimo en el búffer, es decir, al inicio del búfferr (o al inicio de la porción accesible del búffer). Como resultado de esto, punto se coloca al inicio del búffer y la marca se encuentra al final del búffer. Por tanto, todo el búffer es la región.</p>
</div>
<h3 id="La-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></h3>
<div class="hBody-3" >
<p>El comando <code>append-to-buffer</code> es más complejo que el comando <code>mark-whole-buffer</code>. Lo que hace es copiar la región (es decir, la parte del búffer entre el punto y la marca) del buffer actual a un búffer específico.</p>
<p>El comando <code>append-to-buffer</code> utiliza la función <code>insert-buffer-substring</code> para copiar la región. <code>insert-buffer-substring</code> se describe por su nombre: toma una cadena de caracteres de una parte de un búffer, una “subcadena”, y la inserta en otro búffer.</p>
<p>La mayor parte de <code>append-to-buffer</code> corresponde a establecer la condiciones para que <code>insert-buffer-substring</code> funcione: el código debe especificar tanto el búffer al que ira el texto, la ventana fuente y destino, y la región que será copiada.</p>
<p>Aquí está el texto completo de la función:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&quot;Agregar a un buffer especifico el texto de la region.</span>
<span class="s">Este se inserta en ese buffer antes de su punto.</span>

<span class="s">Cuando se llama desde un programa, se pasan tres argumentes:</span>
<span class="s">BUFFER (o nombre del buffer), START y END.</span>
<span class="s">START y END especifican la porcion del buffer actual a copiar.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span>
   <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">read-buffer</span> <span class="s">&quot;Agregar al buffer: &quot;</span> <span class="p">(</span><span class="nf">other-buffer</span>
                                            <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">region-beginning</span><span class="p">)</span> <span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">save-excursion</span>
      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">append-to</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">windows</span> <span class="p">(</span><span class="nv">get-buffer-window-list</span> <span class="nv">append-to</span> <span class="no">t</span> <span class="no">t</span><span class="p">))</span>
             <span class="nf">point</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">append-to</span><span class="p">)</span>
        <span class="p">(</span><span class="k">setq</span> <span class="nf">point</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">window</span> <span class="nv">windows</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">window-point</span> <span class="nv">window</span><span class="p">)</span> <span class="nf">point</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">set-window-point</span> <span class="nv">window</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))))))</span>
</pre></div>
<p>Se puede entender la función si se mira como una serie de plantillas rellenas.</p>
<p>La plantilla exterior es para la definición de función. Esta función, se ve como esto (con varios espacios ocupados):</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>La primer línea de la función incluye su nombre y tres argumentos. Los argumentos son el <code>búffer</code> al cual copiar el texto, <code>start</code> y <code>end</code> que son el inicio y el fin de la región del buffer actual desde donde se va a copiar.</p>
<p>La siguiente parte de la función es la documentación, que es clara y completa. Como es convencional, los tres argumentos estan escritos en mayúsculas para que los noces con facilidad. Aun mejor, se describen en el mismo orden que en la lista de argumentos.</p>
<p>Observe que la documentación distingue entre un búffer y su nombre. (La función puede manejar cualquiera.)</p>
</div>
<h4 id="La-expresión-interactiva-append-to-buffer" >La expresión interactiva <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>Ya que la función <code>append-to-buffer</code> se puede utilizar de forma interactiva, la función debe tener una expresión <code>interactive</code>. (Para una analisis de <code>interactive</code>, ve la seccion <a href="#Crear-una-función-interactiva" >Crear una función interactiva</a>.)  La expresión se lee de la siguiente manera:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">interactive</span>
 <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">read-buffer</span>
        <span class="s">&quot;Agregar al buffer: &quot;</span>
        <span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">region-beginning</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
</pre></div>
<p>Esta expresión no tiene letras para representar partes, como se describio anteriormente. En su lugar, inicia una lista con estas partes:</p>
<p>La primer parte de la lista es una expresión para leer el nombre de un búffer y devolverlo como una cadena. Es decir <code>read-buffer</code>. La función requiere una prompt como primer argumento, <samp>&quot;Agregar al buffer: &quot;</samp>. El segundo argumento le indica al comando que valor proporcionar si no se especifica nada.</p>
<p>En este caso este segundo argumento es una expresión que contiene la función <code>other-buffer</code>, una excepción, y una <samp>t</samp>, para representar verdadero.</p>
<p>El primer argumento de <code>other-buffer</code>, la excepción, es otra función, <code>current-buffer</code>. Esto no va a ser devuelto. El segundo argumento es el símbolo de verdadero, <code>t</code>. Que le dice a <code>other-buffer</code> que puede mostrar búffers visibles (excepto en este caso, no se mostrará el búffer actual, lo cual tiene sentido).</p>
<p>La expresión se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</pre></div>
<p>El segundo y tercer argumento de la expresión <code>list</code> son <code>(region-beginning)</code> y <code>(region-end)</code>. Estas dos funciones especifican el inicio y el final del texto que se añade</p>
<p>Originalmente, el comando utilizaba las letras <samp>B</samp> y <samp>r</samp>. Toda la expresión <code>interactive</code> se veia así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;BAppend to buffer:@: \nr&quot;</span><span class="p">)</span>
</pre></div>
<p>Pero cuando se hacia esto, el valor por defecto del búffer de cambió era invisible. Esto no era lo buscado.</p>
<p>(El prompt se separo del segundo argumento con una línea nueva, <samp>\n</samp>. Seguido por un <samp>r</samp> que le indica a Emacs unir los dos argumentos que siguen al símbolo <code>buffer</code> en la lista de argumentos de la función (es decir, <code>start</code> y <code>end</code>) a los valores del punto y marca. Este argumento funcionaba bien.)</p>
</div>
<h4 id="El-cuerpo-de-append-to-buffer" >El cuerpo de <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>append-to-buffer</code> inicia con <code>let</code>.</p>
<p>Como hemos visto antes (ver Seccion <a href="#(let)" >(let)</a>), el propósito de una expresión <code>let</code> es crear y dar valores iniciales a una o más variable que solo serán utilizadas dentro del cuerpo del <code>let</code>. Esto significa que esa variable no se debe confundir con cualquier variable del mismo nombre fuera de la expresión <code>let</code>.</p>
<p>Podemos ver como la expresión <code>let</code> encaja en la función como un todo mostrando una plantilla de <code>append-to-buffer</code> con la expresión <code>let</code> en resumen:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="err">…</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">))</span>
        <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>La expresión <code>let</code> tiene tres elementos:</p>
<ol>
<li><p>El símbolo <code>let</code>;</p>
</li>
<li><p>Una varlist que contiene, en este caso, una unica lista de dos elementos, <code>(variable valor)</code>;</p>
</li>
<li><p>El cuerpo de la expresión <code>let</code>.</p>
</li>
</ol>
<p>En la función <code>append-to-buffer</code>, la varlist es la siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))</span>
</pre></div>
<p>En esta parte de la expresión <code>let</code>, la unica variable, <code>oldbuf</code> se une al valor devuelto por la expresión <code>(current-buffer)</code>. La variable, <code>oldbuf</code>, se utiliza para guardar un registro del búffer en el que estás trabajando y desde donde se copiara.</p>
<p>El elemento o elementos de una varlist esta rodeado por un conjunto de paréntesis por lo que el intérprete Lisp puede distinguir la varlist del cuerpo del <code>let</code>. Como consecuencia, la lista de dos elementos dentro de la varlist está rodeada por un conjunto circunscrito de paréntesis. La línea tiene este aspecto:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="err">…</span> <span class="p">)</span>
</pre></div>
<p>Los dos paréntesis antes de <code>oldbuf</code> podrían sorprenderte si no fuera porque el primer paréntesis marca el límite de la varlist y el segundo paréntesis marca el inicio de la lista de dos elementos, <code>(oldbuf (current-buffer))</code>.</p>
</div>
<h4 id="save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la expresión <code>let</code> dentro de <code>append-to-buffer</code> consiste de una expresión <code>save-excursion</code>.</p>
<p>La función <code>save-excursion</code> guarda las posiciones de punto y marca, y restaura estas posiciones después de que las expresiones en el cuerpo de <code>save-excursion</code> completan su ejecución. Además, <code>save-excursion</code> no pierde de vista el búffer original, y lo restaura. Asi es como se utizia <code>save-excursion</code> en <code>append-to-buffer</code>.</p>
<p>Por cierto, vale la pena señalar que una función Lisp normalmente se formatea de modo que todo lo que se encierre en un conjunto de multiples lineas se indente más a la derecha que el primer símbolo. En esta definición de función, <code>let</code> se indenta más que <code>defun</code>, y <code>save-excursion</code> se indenta más que <code>let</code>, asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="err">…</span>
  <span class="err">…</span>
  <span class="err">…</span>
  <span class="p">(</span><span class="k">let</span><span class="err">…</span>
    <span class="p">(</span><span class="k">save-excursion</span>
      <span class="err">…</span>
</pre></div>
<p>Esta convención de formato hace que sea fácil de ver que líneas en el cuerpo de <code>save-excursion</code> son encerradas por los parentesis asociados con <code>save-excurion</code>, de igual forma el mismo <code>save-excursion</code> esta encerrado por los paréntesis asociados con <code>let</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">save-excursion</span>
    <span class="err">…</span>
    <span class="p">(</span><span class="nf">set-buffer</span> <span class="err">…</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
    <span class="err">…</span><span class="p">))</span>
</pre></div>
<p>El uso de la función <code>save-excursion</code> puede ser visto como el proceso de llenar espacios de una plantilla:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
  <span class="nv">primer-expresion-en-el-cuerpo</span>
  <span class="nv">segunda-expresion-en-el-cuerpo</span>
   <span class="err">…</span>
  <span class="nv">ultima-expresion-en-el-cuerpo</span><span class="p">)</span>
</pre></div>
<p>En esta función, el cuerpo de <code>save-excursion</code> contiene solo una expresión, la expresión <code>let*</code>. Ya conoces la función <code>let</code>. La función <code>let*</code> es diferente. Posee un <samp>*</samp> en su nombre. Esto le permite a Emacs colocar cada variable de su varlist en secuencia, una después de otra.</p>
<p>Su caracteristica fundamental es que las siguientes variables en la varlist puedan hacer uso de los valores establecidos por Emacs anteriomente en la varlist. Véase Sección <a href="#La-expresión-let*" >La expresión <code>let*</code></a>.</p>
<p>Vamos a omitir funciones como <code>let*</code> y nos centraremos en dos: la función <code>set-buffer</code> y la función <code>insert-buffer-substring</code>.</p>
<p>En los viejos tiempos, la expresión <code>set-buffer</code> era simplemente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">set-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">))</span>
</pre></div>
<p>pero ahora es</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">append-to</span><span class="p">)</span>
</pre></div>
<p><code>append-to</code> esta unido al <code>(get-buffer-create-buffer)</code> anterior en la expresión <code>let*</code>. Esta union extra no sería necesaria excepto que <code>append-to</code> se utiliza despues en la varlist como un argumento para <code>get-buffer-window-list</code>.</p>
<p>La definición de la función <code>append-to-buffer</code> inserta texto desde el búffer en el que estás actualmente al buffer que se indique. Sucede que <code>insert-buffer-substring</code> copia texto desde otro búffer al búffer actual, todo lo contrario––es por ello que la definición <code>append-to-buffer</code> inicia con un <code>let</code> que une el símbolo local <code>oldbuf</code> al valor devuelto por <code>current-buffer</code>.</p>
<p>La expresión <code>insert-buffer-substring</code> es la siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
</pre></div>
<p>La función <code>insert-buffer-substring</code> copia una cadena <em>desde</em> el búffer especificado como su primer argumento e inserta la cadena dentro del búffer actual. En este caso, el argumento de <code>insert-buffer-substring</code> es el valor de la variable creada y vinculada por el <code>let</code>, es decir, el valor de <code>oldbuf</code>, que era el búffer actual cuando diste el comando <code>append-to-buffer</code>.</p>
<p>Después de que <code>insert-buffer-substring</code> ha hecho su trabajo, <code>save-excursion</code> restaurará la acción al búffer original y <code>append-to-buffer</code> habrá hecho su trabajo.</p>
<p>Escrito en forma de esquema, los funcionamientos del cuerpo se ven asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">unir-oldbuf-al-valor-del-buffer-actual</span><span class="p">)</span>
  <span class="p">(</span><span class="k">save-excursion</span>                       <span class="c1">; guarda un registro del buffer.</span>
    <span class="nv">cambio-de-buffer</span>
    <span class="nv">ensertar-substring-desde-oldbuf-a-buffer</span><span class="p">)</span>

  <span class="nv">regresar-al-buffer-original-al-terminar</span>
<span class="nv">dejar-que-el-siginificado-local-de-oldbuf-desaparacesca-al-terminar</span>
</pre></div>
<p>En resumen, <code>append-to-buffer</code> funciona como sigue: se guarda el valor del búffer actual en la variable llamada <code>oldbuf</code>. Se obtiene el nuevo búffer (creando uno si es necesario) y cambia la atención de Emacs a este. Usando el valor de <code>oldbuf</code>, inserta la región del texto desde el búffer antiguo dentro del nuevo búffer; y luego se usando <code>save-excursion</code>, regresas a tu búffer original.</p>
<p>Al observar <code>append-to-buffer</code>, se ha explorado una función bastante compleja. Muestra como usar <code>let</code> y <code>save-excursion</code>, y como cambiar y volver desde otro buffer. Muchas definiciones de función usan <code>let</code>, <code>save-excursion</code>, y <code>set-buffer</code> de esta manera.</p>
</div>
<h3 id="Repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí está un breve resumen de las diferentes funciones descritas en este capítulo.</p>
<dl>
<dt><p>describe-function</p>
</dt>
<dd></dd>
<dt><p>describe-variable</p>
</dt>
<dd><p>Imprime la documentación de una función o variable. Convencionalmente unidas a <kbd>C-h f</kbd> y <kbd>C-h v</kbd>.</p>
</dd>
<dt><p>find-tag</p>
</dt>
<dd><p>Encuentra el fichero que contiene la codigo de una función o variable y cambia a dicho buffer, colocando el punto al inicio del elemento. Convencionalmente unido a <kbd>M-.</kbd> (esto es un punto luego de la tecla <kbd>META</kbd>).</p>
</dd>
<dt><p>save-excursion</p>
</dt>
<dd><p>Guarda la posicion de punto y marca y restaura sus valores tras evaluar los argumentos de <code>save-excursion</code>. Ademas, recuerda el buffer actual y regresa a el.</p>
</dd>
<dt><p>push-mark</p>
</dt>
<dd><p>Asigna la marca a una posicion y guarda el valor de la marca previa en el anillo de marcas. La marca es una ubicacion en el búffer que mantendra su posición relativa, incluso si se añade o borra texto del búffer.</p>
</dd>
<dt><p>goto-char</p>
</dt>
<dd><p>Establece el punto a la ubicacion especificada por el valor del argumento, que puede ser un número, una marca, o una expresión que devuelve el número de una posición, como <code>(point-min)</code>.</p>
</dd>
<dt><p>insert-buffer-substring</p>
</dt>
<dd><p>Copia una región de texto desde un búffer que se pasa a la función como un argumento e inserta la región dentro del búffer actual.</p>
</dd>
<dt><p>mark-whole-buffer</p>
</dt>
<dd><p>Marca el búffer completo como una región. Normalmente unido a <kbd>C-x h</kbd>.</p>
</dd>
<dt><p>set-buffer</p>
</dt>
<dd><p>Cambia la atención de Emacs a otro búffer, pero no se muestra el cambio en la ventana. Se utiliza cuando un programa y no humano trabaja en un búffer distinto.</p>
</dd>
<dt><p>get-buffer-create</p>
</dt>
<dd><p>get-buffer        ::</p>
<p>Busca el búffer nombrado o crea uno si el búffer con ese nombre no existe. La función <code>get-buffer</code> devuelve <code>nil</code> si el nombre del búffer no existe.</p>
</dd>
</dl>
</div>
<h3 id="Ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<ul>
<li><p>Escribe tu propia definición de la función <code>simplified-end-of-buffer</code>; luego pruebala para ver si funciona.</p>
</li>
<li><p>Utiliza <code>if</code> y <code>get-buffer</code> para escribir una función que imprima un mensaje que te diga si un buffer existe.</p>
</li>
<li><p>Utilizando <code>find-tag</code>, busca el codigo para la función <code>copy-to-buffer</code></p>
</li>
</ul>
</div>
<h2 id="Algunas-Funciones-Más-Complejas" >Algunas Funciones Más Complejas</h2>
<div class="hBody-2" >
<p>En este capítulo, nos basamos en lo que hemos aprendido en los capítulos anteriores examinando funciones más complejas. La función <code>copy-to-buffer</code> ilustra el uso de dos expresiones <code>save-excursion</code> en una definición, mientras que la función <code>insert-buffer</code> ilustra el uso de un asterisco en una expresión <code>interactive</code>, el uso de <code>or</code>, y la importante distinción entre un nombre y el objeto al que el nombre hace referencia.</p>
</div>
<h3 id="La-definición-de-copy-to-buffer" >La definición de <code>copy-to-buffer</code></h3>
<div class="hBody-3" >
<p>Después de comprender cómo trabaja <code>append-to-buffer</code>, es fácil entender <code>copy-to-buffer</code>. Esta función copia texto dentro de un búffer, pero en lugar de agregarlo al segundo búffer, se sustituye todo el texto anterior en el segundo búffer.</p>
<p>El cuerpo de <code>copy-to-buffer</code> tiene este aspecto,</p>
<div class="highlight"><pre><span></span><span class="err">…</span>
<span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;BCopy to buffer: \nr&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">with-current-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">erase-buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="k">save-excursion</span>
      <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)))))</span>
</pre></div>
<p>La función <code>copy-to-buffer</code> tiene una expresión <code>interactive</code> mas sencilla que <code>append-to-buffer</code>.</p>
<p>Despues la definición dice:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">with-current-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">)</span> <span class="err">…</span>
</pre></div>
<p>En primer lugar, mira en la expresión más interna; que se evalua primero. Esta expresión inicia con <code>get-buffer-create buffer</code>. La función le indica a la computadora que utilice el búffer con el nombre específicado como aquel al que quieres copiar, o si tal búffer no existe, créarlo. Luego, la función <code>with-current-buffer</code> evalúa su cuerpo con este búffer temporal actual.</p>
<p>(Esto demuestra otra forma de cambiar la atención de la computadora pero no por parte del usuario. La función <code>append-to-buffer</code> muestro como hacer lo mismo con <code>save-excursion</code> y <code>set-buffer</code>. <code>with-current-buffer</code> es un nuevo mecanismo, posiblemente mas sencillo.)</p>
<p>La función <code>barf-if-buffer-read-only</code> envía un mensaje de error diciendo que el búffer es de solo lectura si no se puede modificar.</p>
<p>La siguiente línea tiene la función <code>erase-buffer</code> como su único contenido. Este función borra el búffer.</p>
<p>Finalmente, las últimas dos líneas contienen la expresión <code>save-excursion</code> con <code>insert-buffer-substring</code> como su cuerpo. La expresión <code>insert-buffer-substring</code> copia el texto desde el búffer en el que te encuentras (no has visto que el computador cambie su atención, por lo que no sabes que ese búffer ahora se llama <code>oldbuf</code>).</p>
<p>Por cierto, esto es lo que se entiende por ‘reemplazo’. Para reemplazar el texto Emacs borra el texto anterior y luego inserta el texto nuevo.</p>
<p>A grandes rasgos, el cuerpo de <code>copy-to-buffer</code> se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">@V{bind-}@c{oldbuf}@V{-to-value-of-}@c{current-buffer}</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">@V{with-the-buffer-you-are-copying-to}</span>
      <span class="p">(</span><span class="nv">@V{but-do-not-erase-or-copy-to-a-read-only-buffer}</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">erase-buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="k">save-excursion</span>
        <span class="nv">@V{insert-substring-from-}@c{oldbuf}@V{-into-buffer}</span><span class="p">)))</span>
</pre></div>
</div>
<h3 id="La-definición-de-insert-buffer" >La definición de <code>insert-buffer</code></h3>
<div class="hBody-3" >
<p><code>insert-buffer</code> es otra función relacionada con búffers. Este comando copia otro búffer <em>dentro</em> del búffer actual. Es lo contrario a <code>append-to-buffer</code> o <code>copy-to-buffer</code>, dado que copia una región de texto <em>desde</em> el búffer actual a otro búffer.</p>
<p>Aquí examinamos en el código original. El código fue simplificado en 2003 y es mas dificil de comprender.</p>
<p>(Véase Sección <a href="#Nuevo-Cuerpo-para-insert-buffer" >Nuevo Cuerpo para <code>insert-buffer</code></a>, para ver una discusión del nuevo cuerpo.)</p>
<p>Además, este código ilustra el uso de <code>interactive</code> con un búffer que podría ser <dfn>read-only</dfn> (de solo lectura) y la importante distinción entre el nombre de un objeto y el objeto al que realmente hace referencia.</p>
<p>Aquí está el código anterior:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&quot;Inserta despues del punto el contenido de BUFFER.</span>
<span class="s">Coloca la marca despues del texto insertado.</span>
<span class="s">BUFFER puede ser un buffer un el nombre de un buffer.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;*bInsert buffer:@: &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="k">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">newmark</span><span class="p">)</span>
    <span class="p">(</span><span class="k">save-excursion</span>
      <span class="p">(</span><span class="k">save-excursion</span>
        <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
        <span class="p">(</span><span class="k">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
      <span class="p">(</span><span class="k">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">push-mark</span> <span class="nv">newmark</span><span class="p">)))</span>
</pre></div>
<p>Al igual que con otras definiciones de función, se puede usar una plantilla para ver un esquema de la función:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;*bInsert buffer:@: &quot;</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
</div>
<h4 id="La-expresión-interactiva-en-insert-buffer" >La expresión interactiva en <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>En <code>insert-buffer</code>, el argumetno de la declaración <code>interactive</code> tiene dos partes, un asterisco, <samp>*</samp>, y <samp>bInsert buffer:@: </samp>.</p>
</div>
<h5 id="Un-búffer-de-solo-lectura" >Un búffer de solo lectura</h5>
<div class="hBody-5" >
<p>El asterisco se utliza cuando el búffer actual es un búffer de solo lectura––un búffer que no puede ser modificado. Si <code>insert-buffer</code> se llama cuando el búffer actual es de solo lectura, se imprime un mensaje en el area echo a este efecto y el terminal puede emitir un beep o parpadear; no se te permitira insertar nada en el búffer actual. El asterisco no tiene que ser seguido por un salto de linea para separarlo del siguiente argumento.</p>
</div>
<h5 id="b-en-una-expresión-interactiva" ><samp>b</samp> en una expresión interactiva</h5>
<div class="hBody-5" >
<p>El siguiente argumento de la expresión interactiva inicia con una letra <samp>b</samp> minúscula. (Esta es diferente del código para <code>append-to-buffer</code>, que utiliza una <samp>B</samp> mayúscula. Véase Sección <a href="#La-Definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>.) La <samp>b</samp> minúscula le indica al intérprete Lisp que el argumento de <code>insert-buffer</code> debe ser un buffer existente o su nombre. (La opcion <samp>B</samp> mayúscula prevee la posibilidad que no exista el búffer.)  Emacs te pedira el nombre del búffer, ofreciendo un búffer por defecto, con el autocompletado de nombre habilitado. Si el búffer no existe, recibiras un mensaje que dice “No concuerda”; tu terminal tambien puede emitir un beep.</p>
<p>El código nuevo y simplificado genera una lista <code>interactive</code>. Este utiliza las funciones <code>barf-if-buffer-read-only</code> y <code>read-buffer</code> con las que ya estamos familiarizados y la forma especial <code>progn</code> con la que no. (Se describe mas adelaste).</p>
</div>
<h4 id="El-cuerpo-de-la-función-insert-buffer" >El cuerpo de la función <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>insert-buffer</code> tiene dos partes principales: una expresión <code>or</code> y una expresión <code>let</code>. El propósito de la expresión <code>or</code> es asegurar que el argumento <code>buffer</code> esta unido a un búffer y no es solo el nombre de un búffer. El cuerpo de la expresión <code>let</code> contiene el código que copia el otra búffer dentro del búffer actual.</p>
<p>A grades rasgos, las dos expresiones encajan en la función <code>insert-buffer</code> de esta manera:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;*bInsert buffer:@: &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or</span> <span class="err">…</span>
      <span class="err">…</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">varlist</span><span class="p">)</span>
      <span class="nv">cuerpo-de-let</span><span class="err">…</span> <span class="p">)</span>
</pre></div>
<p>Para entender como la expresión <code>or</code> asegura que el argumento <code>buffer</code> esta unido a un buffer y no al nombre de un búffer, primero es necesario entender la función <code>or</code>.</p>
<p>Antes de hacer esto, permíteme reescribir esta parte de la función utilizando <code>if</code> de esta manera puedes ver como se hace de una manera que será familiar.</p>
</div>
<h4 id="insert-buffer-con-un-if-en-lugar-de-un-or" ><code>insert-buffer</code> con un <code>if</code> en lugar de un <code>or</code></h4>
<div class="hBody-4" >
<p>El trabajo a realizar es asegurarse de que el valor de <code>buffer</code> es un búffer en sí y no el nombre de un búffer. Si el valor es el nombre, entonces debe optenerse el búffer en sí.</p>
<p>Puedes imaginarte a tí mismo en una conferencia donde un acomodador está observando una lista con tu nombre en ella y mirándote: el acomodador sabe “asociar” tu nombre, pero no a tí; pero cuando el acomodador te encuentra y te toma el brazo, el acomodador llega a “asociarte” a tí.</p>
<p>En Lisp, se podría describir esta situación así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">tomando-al-invitado</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">encontrar-y-tomar-del-brazo-al-invitado</span><span class="p">))</span>
</pre></div>
<p>Queremos hacer lo mismo con un búffer––si no tenemos el búffer en sí, queremos conseguirlo.</p>
<p>Usando un predicado llamado <code>bufferp</code> que nos informa si tenemos un búffer (en lugar de su nombre), podemos escribir el código de esta manera:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">))</span>              <span class="c1">; parte-if</span>
    <span class="p">(</span><span class="k">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>  <span class="c1">; parte-then</span>
</pre></div>
<p>Aquí, la prueba verdadero-o-falso de la expresión <code>if</code> es <code>(not (bufferp buffer))</code>; y la parte <em>then</em> es la expresión <code>(setq buffer (get-buffer buffer))</code>.</p>
<p>En la prueba, la función <code>bufferp</code> devuelve cierto si su argumento es un búffer––sino falso si el argumento es el nombre del búffer. (El último carácter del nombre de la función <code>bufferp</code> es el carácter <samp>p</samp>; como vimos anteriormente, tal uso de <samp>p</samp> es una convención que indica que la función es un predicado, que es un término que significa que la función determinará si alguna propiedad es verdadera o falsa. Véase Sección <a href="#Usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a>.)</p>
<p>La función <code>not</code> precede la expresión <code>(bufferp buffer)</code>, así la prueba verdadero-o-falso es la siguente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">))</span>
</pre></div>
<p><code>not</code> es una función que devuelve verdadero si su argumento es falso y falso si su argumento es verdadero. Por lo que si <code>(bufferp buffer)</code> devuelve cierto, la expresión <code>not</code> devuelve falso y vice-versa: lo que es “no cierto” es falso y lo que es “no falso” es verdadero.</p>
<p>Usando esta prueba, la expresión <code>if</code> funciona como sigue: cuando el valor de la variable <code>buffer</code> está en realidad en un búffer en lugar de su nombre, la prueba verdadero-o-falso devuelve falso y la expresión <code>if</code> no evalúa la parte then. Esto está bien, ya que no tenemos que hacer nada para la variable <code>buffer</code> si realmente es un búffer.</p>
<p>Por otro lado, cuando el valor de <code>buffer</code> no es un buffer en sí, pero si el nombre de un buffer, la prueba verdadero-o-falso devuelve verdadero y se evalua la parte then de la expresión. En este caso, la parte then es <code>(setq buffer (get-buffer buffer))</code>. Esta expresión utiliza la función <code>get-buffer</code> para devolver un buffer en sí, dado su nombre. Luego <code>setq</code> asigna la variable <code>buffer</code> reemplazando su valor anterior (que era el nombre del buffer).</p>
</div>
<h4 id="El-or-en-el-cuerpo" >El <code>or</code> en el cuerpo</h4>
<div class="hBody-4" >
<p>El propósito de la expresión <code>or</code> en la función <code>insert-buffer</code> es asegurar que el argumento <code>buffer</code> está asociado a un búffer y no solo al nombre de un búffer. La sección previa muestra como se podría haber hecho el trabajo usando una expresión <code>if</code>. Sin embargo, la función <code>insert-buffer</code> realmente utiliza <code>or</code>. Para entender esto, es necesario entender funciona como <code>or</code>.</p>
<p>Una función <code>or</code> puede tener cualquier número de argumentos. Esta evalúa un argumento a la ves y devuelve el valor del primero de sus argumentos que no es <code>nil</code>. Ademas, y esta es una caracteristica crucial de <code>or</code>, es no evalúa los argumentos posteriores después de regresar el primer valor no-<code>nil</code>.</p>
<p>La expresión <code>or</code> luce asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="k">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>
</pre></div>
<p>El primer argumento de <code>or</code> es la expresión <code>(bufferp buffer)</code>. Esta expresión devuelve verdadero (un valor no-<code>nil</code>) si el búffer es realmente un búffer, y no solo el nombre de un búffer. En la expresión <code>or</code>, si este es el caso, la expresión <code>or</code> devuelve este valor verdadero y no evalúa la siguiente expresión––y esto es bueno para nosotros, ya que no queremos hacer nada al valor de <code>buffer</code> si realmente es un búffer.</p>
<p>Por otro lado, si el valor de <code>(bufferp buffer)</code> es <code>nil</code>, si el valor de <code>buffer</code> es el nombre de un buffer, el intérprete Lisp evalúa el siguiente elemento de la expresión. Esta es la expresión <code>(setq buffer (get-buffer buffer))</code>. Esta expresión devuelve un valor no-<code>nil</code>, que es el valor para el que asigna la variable <code>buffer</code>––y este valor es un búffer en sí, no el nombre de un búffer.</p>
<p>El resultado de todo esto es que el símbolo <code>buffer</code> siempre es unido a un búffer en sí en vez de al nombre de un búffer. Todo esto es necesario debido a que la función <code>set-buffer</code> en la línea siguiente solo funciona con un buffer en sí, no con el nombre de un búffer.</p>
<p>Incidentalmente, usando <code>or</code>, la situación con el acomodador se escribiria así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nv">holding-on-to-guest</span><span class="p">)</span> <span class="p">(</span><span class="nv">find-and-take-arm-of-guest</span><span class="p">))</span>
</pre></div>
</div>
<h4 id="La-expresión-let-en-insert-buffer" >La expresión <code>let</code> en <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>Después de asegurarse que la variable <code>buffer</code> se refiere a un buffer en sí y no solo al nombre de un buffer, la función <code>insert-buffer</code> continúa con una expresión <code>let</code>. Esta especifica tres variables locales, <code>start</code>, <code>end</code> y <code>newmark</code> y las une al valor inicial <code>nil</code>. Estas variables se utilizan dentro del resto de <code>let</code> y oculta temporalmente cualquier otra ocurrencia de variables con el mismo nombre en Emacs hasta el fin de <code>let</code>.</p>
<p>El cuerpo de <code>let</code> contiene dos expresiones <code>save-excursion</code>. Primero, miremos la expresión <code>save-excursion</code> al interior en detalle. La expresión se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
  <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
  <span class="p">(</span><span class="k">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
</pre></div>
<p>La expresión <code>(set-buffer buffer)</code> cambia la atención de Emacs de el búffer actual a el que contene el texto a copiar. En ese búffer las variables <code>start</code> y <code>end</code> se asignadan al inicio y al fin del búffer, usando los comandos <code>point-min</code> y <code>point-max</code>. Tenga en cuenta que tenemos aquí un ejemplo de cómo <code>setq</code> es capaz de asignar dos variables en la misma expresión. El primer argumento de <code>setq</code> se establece al valor del segundo, y su tercer argumento se establece al valor del cuarto.</p>
<p>Después el cuerpo del <code>save-excursion</code> interno es evaluado, <code>save-excursion</code> restaura el búffer original, pero <code>start</code> y <code>end</code> retienen los valores del inicio y fin del búffer del que se copia el texto.</p>
<p>La expresión exterior <code>save-excursion</code> luce asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
  <span class="p">(</span><span class="nv">inner-save-excursion-expression</span>
     <span class="p">(</span><span class="nv">go-to-new-buffer-and-set-start-and-end</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="k">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</pre></div>
<p>La función <code>insert-buffer-substring</code> copia el texto <em>dento</em> del búffer actual <em>desde</em> la región indicada por <code>start</code> y <code>end</code> en el <code>búffer</code>. Dado que la totalidad del segundo búffer se encuentra entre <code>start</code> y <code>end</code>, se copia todo dentro del búffer que estás editando. A continuacion, el valor de punto, que será al fin del texto insertado, se registra en la variable <code>newmark</code>.</p>
<p>Después evaluar el cuerpo del <code>save-excursion</code> externo, el punto y la marca se vuelven a colocar en su posicion original.</p>
<p>Sin embargo, es conveniente localizar una marca al fin del texto recien insertado y localizar el punto a su comienzo. La variable <code>newmark</code> registra el fin del texto insertado. En la última línea de la expresión <code>let</code>, la expresión <code>(push-mark newmark)</code> asigna una marca a esta posición. (La posición anterior de la marca aun es accesible; está grabada en el anillo de marcas y puede volver a ella con <kbd>C-u C-SPC</kbd>.)  Mientras tanto, el punto está localizado al principio del texto insertado, que es donde estaba antes de llamar a la función de insercion, posición que fue guardada por la primer <code>save-excursion</code>.</p>
<p>La expresión <code>let</code> completa se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">newmark</span><span class="p">)</span>
  <span class="p">(</span><span class="k">save-excursion</span>
    <span class="p">(</span><span class="k">save-excursion</span>
      <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="k">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
    <span class="p">(</span><span class="k">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="nv">newmark</span><span class="p">))</span>
</pre></div>
<p>Al igual que la función <code>append-to-buffer</code>, la función <code>insert-buffer</code> utiliza <code>let</code>, <code>save-excursion</code> y <code>set-buffer</code>. Además, la función ilustra una forma de utilizar <code>or</code>. Todas estas funciones son bloques de construccion que vamos a encontrar y utilizar una y otra vez.</p>
</div>
<h4 id="Nuevo-cuerpo-para-insert-buffer" >Nuevo cuerpo para <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo en la versión 22 de GNU Emacs es más confuso que en el original.</p>
<p>Se compone de dos expresiones</p>
<div class="highlight"><pre><span></span>  <span class="p">(</span><span class="nv">push-mark</span>
   <span class="p">(</span><span class="k">save-excursion</span>
     <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>

   <span class="no">nil</span>
</pre></div>
<p>excepto, y esto es lo que confunde a los principiantes, un trabajo muy importante se realiza al interior de la expresión <code>push-mark</code>.</p>
<p>La función <code>get-buffer</code> devuelve un búffer con el nombre proporcionado. Notaras que la función <em>no</em> se llama <code>get-buffer-create</code>; esta no crea un búffer si uno no existe ya. El búffer devuelto por <code>get-buffer</code>, un búffer existente, se pasa a <code>insert-buffer-substring</code>, que inserta todo el búffer (ya que no se especifica ninguna cosa más).</p>
<p>La posición donde se inserta el buffer se registra por <code>push-mark</code>. Despues la función devuelve <code>nil</code>, el valor de su último comando. Dicho de otra manera, la función <code>insert-buffer</code> existe solo para producir un efecto secundario, insertar otro buffer, no para devolver ningun valor.</p>
</div>
<h3 id="Definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></h3>
<div class="hBody-3" >
<p>La estructura básica de la función <code>beginning-of-buffer</code> ya ha sido discutida. (Véase Sección <a href="#Una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></a>). Esta sección describe la parte compleja de la definición.</p>
<p>Como se ha descrito anteriormente, cuando se invoca <code>beginning-of-buffer</code> sin argumento, mueve el cursor al inicio del búffer (en realidad, al inicio de la porción accesible del búffer), dejando la marca en la posición anterior. Sin embargo, cuando el comando se invoca con un número entre uno y diez, la función considera el número sera una fracción del tamaño del búffer, medido en decenas, y Emacs mueve el cursor a dicha fracción del reccorrido desde el inicio del búffer. Por lo tanto, puedes llamar a esta función con el comando de teclado <kbd>M-&lt;</kbd>, que moverá el cursor al principio del búffer, o con un comando de teclado como <kbd>C-u 7 M-&lt;</kbd> que moverá el cursor a un 70% del recorrido a través del búffer. Si se utiliza un número mayor a diez como argumento, se movera al final del búffer.</p>
<p>La función <code>beginning-of-buffer</code> puede llamarse con o sin argumentos. El uso del argumento es opcional.</p>
</div>
<h4 id="Argumentos-opcionales" >Argumentos opcionales</h4>
<div class="hBody-4" >
<p>A menos que se diga lo contrario, Lisp espera que una función con un argumento en su definición de función se llame con un valor para este argumento. Si esto no ocurre, se obtiene un error y un mensaje que dice <samp>Wrong number of arguments</samp> (<cite>Número de argumentos erróneo</cite>).</p>
<p>Sin embargo, los argumentos opcionales son una caracteristica de Lisp: se utiliza una <dfn>palabra clave</dfn> en concreto para comunicar al intérprete Lisp que un argumento es opcional. La palabra clave es <code>&amp;optional</code>. (El <samp>&amp;</samp> al frente de <samp>optional</samp> es parte de la palabra clave.) En una definición de función, si un argumento va despues de la palabra clave <code>&amp;optional</code>, no necesita pasar ningún valor para este argumento al llamar a la función.</p>
<p>Por lo tanto la primera línea de la definición de función de <code>beginning-of-buffer</code> tiene este aspecto :</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
</pre></div>
<p>En resumen, toda la función se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;P&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nv">es-el-argumento-de-una-cons-cell</span> <span class="nv">argumento</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and</span> <span class="nv">ambos-transient-mark-mode-y-mark-active-son-verdadero</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">push-mark</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">determina-el-tamano-y-lo-establece</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span>
    <span class="p">(</span><span class="nv">si-hay-un-argumento</span>
        <span class="nv">averigua-donde-ir</span>
      <span class="nv">de-otro-modo-va-a</span>
      <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
   <span class="nv">do-nicety</span>
</pre></div>
<p>La función es similar a la función <code>simplified-beginning-of-buffer</code> excepto que la expresión <code>interactive</code> tiene <code>&quot;P&quot;</code> como argumento y la función <code>goto-char</code> es seguida por una expresión <code>if-then-else</code> que calcula donde poner el cursor si hay un argumento que no es un cons cell.</p>
<p>(Puesto que no explico un cons cell en muchos capítulos, por favor, considera ignorar la función <code>consp</code>. Ve la seccion <a href="#Cómo-se-implementan-las-listas" >Cómo se implementan las listas</a>, y la Seccion <a href="info:elisp#Cons-Cell-Type" >&quot;Cons Cell y Tipos de Listas&quot;</a> en <em>El Manual de Referencia GNU Emacs Lisp</em>).</p>
<p>La <code>&quot;P&quot;</code> en la expresión <code>interactive</code> le indica a Emacs cómo pasar un argumento prefijo, si es que hay uno, a la función en forma plana. Un argumento prefijo se crea presionando la tecla <kbd>META</kbd> seguida por un número, o pulsando <kbd>C-u</kbd> y luego un número. (Si no escribes un número, <kbd>C-u</kbd> por defecto es un cons cell con un 4. Una <code>&quot;p&quot;</code> minúscula en la expresión <code>interactive</code> hace que la función convierta un argumento prefijo a un número.)</p>
<p>La prueba verdadero-o-falso de la expresión <code>if</code> parace compleja, pero no lo es: se comprueba si <code>argumento</code> tiene un valor que no es <code>nil</code> y si es un cons cell. (Esto es lo que hace <code>consp</code>; comprueba si su argumento es un cons cell.) Si <code>argumento</code> tiene un valor distinto a <code>nil</code> (y no es un cons cell.), que será el caso si <code>beginning-of-buffer</code> se llama con un argumento numerico, la prueba verdadero-o-falso devolverá verdadero y se evaluara la parte <code>then</code> de la expresión <code>if</code>. Por otro lado, si <code>beginning-of-bufer</code> no se llama con un argumento, el valor de <code>argumento</code> será <code>nil</code> y se evaluara la parte <code>else</code> de la expresión <code>if</code>. La parte <code>else</code> es un simple <code>point-min</code>, y cuando este es el resultado, toda la expresión <code>goto-char</code> es <code>(goto-char (point-min))</code>, que es cómo vimos la función <code>beginning-of-buffer</code> en su forma simplificada.</p>
</div>
<h4 id="beginning-of-buffer-con-un-argumento" ><code>beginning-of-buffer</code> con un argumento</h4>
<div class="hBody-4" >
<p>Cuando se llama a <code>beginning-of-buffer</code> con un argumento, se evalua una expresión que calcula el valor a pasa a <code>goto-char</code>. A primera vista esta expresion es bastante compleja. Incluye una expresión <code>if</code> y mucha aritmética. Se ve así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">buffer-size</span><span class="p">)</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="c1">;; Evita el desbordamiento en buffers de gran tamaño!</span>
                          <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">/</span>
   <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span>
      <span class="p">(</span><span class="nf">*</span>
       <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span> <span class="mi">10</span><span class="p">)))</span>
</pre></div>
<p>Como otras expresiones que paracen complejas, la expresión condicional dentro de <code>beginning-of-buffer</code> se puede desenredar viendola como partes de una plantilla, en este caso, la plantilla para una expresión if-then-else. En forma esquelética, la expresión se ve así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">si</span> <span class="p">(</span><span class="nv">buffer-es-grande</span>
    <span class="nv">divide-el-tama</span><span class="err">ñ</span><span class="nv">o-del-buffer-por-10-y-multiplicalo-por-arg</span>
  <span class="nv">de-otra-forma-utiliza-el-calculo-alternativo</span>
</pre></div>
<p>La prueba verdadero-o-falso de la expresión <code>if</code> interna comprueba el tamaño del buffer. La razón de esto es que la vieja versión de Emacs 18 utilizaba números no son más grandes que 8 millones mas o menos y el programador temía que Emacs pudiera intentar usar numeros demasiado largos si el búffer fuese extenso. El término ‘desbordamiento’, que se menciona en el comentario, significa que los números son mas grandes. Las versiones más recientes de Emacs utilizan números largos, pero este código no ha sido tocado, solo porque la gente ahora mira búffers que son mucho, mucho mas grandes de lo que nunca fueron.</p>
<p>Hay dos casos: si el búffer es grande, o si no lo es.</p>
</div>
<h5 id="Qué-ocurre-en-un-búffer-de-gran-tamaño" >Qué ocurre en un búffer de gran tamaño</h5>
<div class="hBody-5" >
<p>En <code>beginning-of-buffer</code>, la expresión <code>if</code> interna prueba si el tamaño del búffer es mayor a 10000 caracteres. Para hacer esto, se utiliza la función <code>&gt;</code> y el calculo de <code>size</code> que viene desde la expresión let.</p>
<p>En los viejos tiempos, se utilizo la función <code>buffer-size</code>. No solo se llamaba en repetidas ocaciones, se daba el tamaño completo del búffer, no la parte accesible. El calculo tiene mucho más sentido cuando se maneja solo la parte accesible. (Véase Sección <a href="#Reducir-y-Extender" >Reducir y Extender</a>, para más información concentra la atención en una parte ‘accesible’.)</p>
<p>La linea se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">size</span> <span class="mi">10000</span><span class="p">)</span>
</pre></div>
<p>Cuando el búffer es grande, se evalua la parte <code>then</code> de la expresión <code>if</code>. Esto se lee así (después de darle un formato facil de leer):</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">*</span>
  <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
<p>Esta expresión es una multiplicación, con dos argumentos para la función <code>*</code>.</p>
<p>El primer argumento es <code>(prefix-numeric-value arg)</code>. Cuando se usa <code>&quot;P&quot;</code> como argumento para <code>interactive</code>, el valor dado a la función como argumento es un “argumento prefijo en bruto”, y no un número. (Es un número en una lista). Para realizar el calculo, se necesita una conversión, y <code>prefix-numeric-value</code> hace el trabajo.</p>
<p>El segundo argumento es <code>(/ size 10)</code>. Esta expresión divide el valor numérico por diez––el valor numérico del tamaño de la porción accesible del búffer. Esto produce un número que indica cuántos caracteres constituyen una decena parte del tamaño del búffer. (En Lisp, <code>/</code> se utiliza para la división, igual que <code>*</code> se utiliza para la multiplicación.)</p>
<p>En la expresión de multiplicación en su conjunto, esta cantidad se multiplica por el valor del argumento prefijo––la multiplicación es la siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">*</span> <span class="nv">valor-numerico-del-argumento-prefijo-arg</span>
   <span class="nv">numero-de-caracteres-en-una-decima-parte-de-la-porcion-accesible-del-buffer</span><span class="p">)</span>
</pre></div>
<p>Por ejemplo, si el argumento prefijo es <samp>7</samp>, el valor de una decima parte será multiplicado por 7 para dar una posición al 70% del trayecto.</p>
<p>El resultado de todo esto es que si la porción accesible del búffer es grande, la expresión <code>goto-char</code> es la siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">)))</span>
</pre></div>
<p>Esto coloca el cursor donde lo queremos.</p>
</div>
<h5 id="Qué-ocurre-en-un-búffer-pequeño" >Qué ocurre en un búffer pequeño</h5>
<div class="hBody-5" >
<p>Si el búffer contiene menos de 10000 caracteres, se lleva a cabo un calculo ligeramente diferente. Podrías pensar que esto no es necesario, ya que el primer calculo podría hacer el trabajo. Sin embargo, en un búffer pequeño, el primer método puede no colocar el cursor exactamente en la línea deseada; el segundo método hace un mejor trabajo.</p>
<p>El código tiene este aspecto:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
<p>Para averiguar que ocure en este código debemos descubrier como se anidan las funciones entre paréntesis. Es mas fácil de leer si se reformatea cada expresión, indentando la expresión que contiene:</p>
<div class="highlight"><pre><span></span>  <span class="p">(</span><span class="nf">/</span>
   <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span>
      <span class="p">(</span><span class="nf">*</span>
       <span class="nv">size</span>
       <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
   <span class="mi">10</span><span class="p">))</span>
</pre></div>
<p>Observando los paréntesis, vemos que la operación mas profunda es <code>(prefix-numeric-value arg)</code>, que convierte el argumento prefijo en bruto a un número. En la siguiente expresión, este número se multiplica por el tamaño de la porción accesible del búffer:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">))</span>
</pre></div>
<p>Esta multiplicación crea un número que puede ser mayor al tamaño del buffer––siete veces mayor si el argumento es 7, por ejemplo. Luego se suma diez a éste numero y finalmente el número es dividido por 10 para proporcionar un valor que es un carácter más grande que la posición de porcentaje en el búffer.</p>
<p>El número que resulta de todo esto se pasa a <code>goto-char</code> y el cursor se mueve a este punto.</p>
</div>
<h4 id="Funcion-beginning-of-buffer-Completa" >Funcion <code>beginning-of-buffer</code> Completa</h4>
<div class="hBody-4" >
<p>Aquí está el texto completo de la función <code>beginning-of-buffer</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&quot;Move point to the beginning of the buffer;</span>
<span class="s">leave mark at previous position.</span>
<span class="s">With \\[universal-argument] prefix,</span>
<span class="s">do not set mark at previous position.</span>
<span class="s">With numeric arg N,</span>
<span class="s">put point N/10 of the way from the beginning.</span>

<span class="s">If the buffer is narrowed,</span>
<span class="s">this command uses the beginning and size</span>
<span class="s">of the accessible part of the buffer.</span>

<span class="s">Don&#39;t use this command in Lisp programs!</span>
<span class="s">\(goto-char (point-min)) is faster</span>
<span class="s">and avoids clobbering the mark.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;P&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)</span>
      <span class="p">(</span><span class="k">and</span> <span class="nv">transient-mark-mode</span> <span class="nv">mark-active</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">push-mark</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">size</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="k">and</span> <span class="nv">arg</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)))</span>
                   <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span>
                      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">size</span> <span class="mi">10000</span><span class="p">)</span>
                          <span class="c1">;; Avoid overflow for large buffer sizes!</span>
                          <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
                        <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
                           <span class="mi">10</span><span class="p">)))</span>
                 <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
<p>Excepto por dos pequeños puntos, la discusión anterior muestra cómo funciona esta función. El primer punto se refiere a un detalle en la cadena de documentación, y el segundo concierne a la última línea de la función.</p>
<p>En la cadena de documentación, se hace referencia a una expresión:</p>
<pre><code class="example">\\[universal-argument]</code></pre>
<p>Se usa Un <samp>\\</samp> antes del primer corchete de esta expresión. Este <samp>\\</samp> le indica al intérprete Lisp sustituir cualquier clave qué se encuentre dentro de <samp>[…]</samp> por su convinacion de teclado actual. En el caso de <code>universal-argument</code>, suele ser <kbd>C-u</kbd>, pero podría ser distinta. (Véase Sección <a href="info:elisp#Documentation-Tips" >Consejos para Cadenas de Documentación</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.)</p>
<p>Finalmente, la última línea del comando <code>beginning-of-buffer</code> indica mover el punto al inicio de la siguiente línea si el comando se invoca con un argumento:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
<p>Esto pone el cursor al inicio de la primera línea a continuacion de la posicion inidicada en decenas en el búffer. Esto significa que el cursor siempre se localiza <em>al menos</em> las decenas solicitadas del recorrido del búffer, esta es una sutiliza, quizás, no necesaria, pero que, de no ocurri, seguro generaria quejas.</p>
<p>Por otro lado, esto significa que si se especifica el comando con <kbd>C-u</kbd>, sin un número, que es decir, si el ‘argumento prefijo en bruto’ simplemente es un cons cell, entonces el comando te coloca al inicio de la segunda línea … no sé si se pretende esto o si nadie ha tratado el código para evitar que esto suceda.</p>
</div>
<h3 id="Repaso" ><span id="Repaso-2" >Repaso</span></h3>
<div class="hBody-3" >
<p>Aquí esta un breve resumen de algunos de lo temas cubiertos en este capítulo.</p>
<dl>
<dt><p>or</p>
</dt>
<dd><p>Evalúa cada argumento en secuencia, y devuelve el valor del primer argumento que no es <code>nil</code>, si ninguno devuelve un valor que no sea <code>nil</code>, devuelve <code>nil</code>. En resumen, devuelve el primer valor verdadero de los argumento; devuelve un valor verdadero si uno <em>o</em> cualquiera de los otros es verdadero.</p>
</dd>
<dt><p>and</p>
</dt>
<dd><p>Evalúa cada argumento en secuencia, y si alguno es <code>nil</code>, devuelve <code>nil</code>; si ninguno es <code>nil</code>, devuelve el valor del último argumento. En resumen, devuelve un valor verdadero solo si todos los argumentos son verdaderos; devuelve un valor verdadero si uno <em>y</em> cada uno de los otros son verdadero.</p>
</dd>
<dt><p>&amp;optional</p>
</dt>
<dd><p>Una palabra clave utilizada para indicar que un argumento en una definición de función es opcional; esto significa que la función se puede evaluar sin el argumento, si se desea.</p>
</dd>
<dt><p>prefix-numeric-value</p>
</dt>
<dd><p>Convierte el ‘argumento prefijo en bruto’ producido por <code>(interactive &quot;P&quot;)</code> en un valor numérico.</p>
</dd>
<dt><p>forward-line</p>
</dt>
<dd><p>Mueve el punto hacia delante al principio de la siguiente línea, o si el argumento es mayor a uno, hacia delante varias líneas. Si no se puede mover tan lejos hacia delante como se supone, <code>forward-line</code> va hacia adelante tan lejos como pueda y luego devuelve un recuento del número de líneas adicionales que no pudo moverse.</p>
</dd>
<dt><p>erase-buffer</p>
</dt>
<dd><p>Elimina todo el contenido del búffer actual.</p>
</dd>
<dt><p>bufferp</p>
</dt>
<dd><p>Devuelve <code>t</code> si su argumento es un búffer; de otro modo devuelve <code>nil</code>.</p>
</dd>
</dl>
</div>
<h3 id="Ejercicio-de-argumento-opcional" >Ejercicio de argumento <code>opcional</code></h3>
<div class="hBody-3" >
<p>Escribe una función interactiva con un argumento opcional que pruebe si su argumento, un número, es mayor que o igual a, o de lo contrario, menor que el valor de <code>fill-column</code>, y te lo indique, en un mensaje. Sin embargo, si no pasas un argumento a la función, utiliza 56 como valor por defecto.</p>
</div>
<h2 id="Reducir-y-Extender" >Reducir y Extender</h2>
<div class="hBody-2" >
<p>La Reduccion es una funcionalidad de Emacs que hace posible que puedas focalizarte en una parte específica de un búffer, y trabajar sin el cambio accidental a otras partes. La reduccion normalmente se deshabilita puesto que puede confundir a los principiantes.</p>
<p>Con la reduccion, el resto del búffer se hace invisible, como si no estuviera alli. Esto es una ventaja si, por ejemplo, se quiere reemplazar una palabra en una parte del búffer pero no en otra: limitas la parte que deseas y el reemplazo se lleva a cabo solo en esa sección, no en el resto del búffer. Las búsquedas solo funcionarán con la región reducida, no fuera de ella, de esta forma si estás reparando una parte de un documento, puedes mantener fuera la parte que no necesitas reparar solo reduciendo la region que deseas. (La tecla asociada a <code>narrow-to-region</code> es <kbd>C-x n n</kbd>.)</p>
<p>Sin embargo, la reduccion hace invisible el resto del búffer, esto puede asustar a quien invoca inadvertidamente la reduccion y piensa que ha eliminado una parte de su fichero. Por otra parte, el comando <code>undo</code> (usualmente unido a <kbd>C-x u</kbd>) no apaga (ni debe hacerlo) la reduccion, por lo que las personas pueden llegar a desesperarse si no saben que pueden devolver el resto del buffer visible cor el comando <code>widen</code> que es <kbd>C-x n w</kbd>.)</p>
<p>La Reduccion es igual de util para el intérprete Lisp como para un humano. Con frecuencia, una función Emacs Lisp está diseñada para trabajar solo en parte de un búffer; o por el contrario, una función Emacs Lisp necesita trabajar en todo un búffer que ha sido reducido. La función <code>what-line</code>, por ejemplo, ilimina la reduccion de un búffer, si este tiene alguna reduccion y al terminar su trabajo, restaura la reduccion. Por otro lado, la función <code>count-lines</code> utiliza la reduccion para restringirse a sí misma solo a la porción del búffer en la que se está interesado y luego restaura la situación anterior.</p>
</div>
<h3 id="La-forma-especial-save-restriction" >La forma especial <code>save-restriction</code></h3>
<div class="hBody-3" >
<p>En Emacs Lisp, se puede utilizar la forma especial <code>save-restriction</code> para realizar un seguimiento de cualquier reduccion en efecto. Cuando el intérprete Lisp se encuentra con <code>save-restriction</code>, se ejecuta el código en el cuerpo de la expresión <code>save-restriction</code>, y luego deshace cualquier cambio en la reduccion que el código proboco. Si, por ejemplo, el búffer es reducido y el código que sigue al comando <code>save-restriction</code> se deshace de la reduccion, <code>save-restriction</code> devuelve el búffer a su región reducida. En el comando <code>what-line</code>, cualquier reduccion del búffer es deshecha por el comando <code>widen</code> inmediatamente despues del comando <code>save-restriction</code>. Se restaura cualquier reduccion original justo antes de finalizar la función.</p>
<p>La plantilla para una expresión <code>save-restriction</code> es simple:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-restriction</span>
  <span class="nv">cuerpo</span><span class="err">…</span> <span class="p">)</span>
</pre></div>
<p>El cuerpo de <code>save-restriction</code> es una o más expresiones que son evaluadas de forma secuencial por el intérprete Lisp.</p>
<p>Finalmente, un punto a tener en cuenta: cuando se utiliza <code>save-excursion</code> y <code>save-restriction</code> a la vez, una detras de la otra, debes utilizar <code>save-excursion</code> primero. Si lo escribes en el orden inverso, es posible que no registre la reduccion en el búffer a la que emacs debe cambiar Emacs despues de llamar a <code>save-excursion</code>. Por la tanto, cuando escribas a la vez <code>save-excursion</code> y <code>save-restriction</code> debe ser así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-excursion</span>
  <span class="p">(</span><span class="k">save-restriction</span>
    <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</pre></div>
<p>En otras circunstancias, cuando no se escriban a la vez, las formas especiales <code>save-excursion</code> y <code>save-restriction</code> deben escribirse en el orden adecuado para la función.</p>
<p>Por ejemplo,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">save-restriction</span>
  <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
  <span class="p">(</span><span class="k">save-excursion</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</pre></div>
</div>
<h3 id="what-line" ><code>what-line</code></h3>
<div class="hBody-3" >
<p>El comando <code>what-line</code> informa el número de la línea en la que el cursor esta colocado. La función ilustra el uso de los comandos <code>save-restriction</code> y <code>save-excursion</code>. Aquí está el texto original de la función:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">what-line</span> <span class="p">()</span>
  <span class="s">&quot;Print the current line number (in the buffer) of point.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="k">save-restriction</span>
    <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
    <span class="p">(</span><span class="k">save-excursion</span>
      <span class="p">(</span><span class="nf">beginning-of-line</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Line %d&quot;</span>
               <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))))))</span>
</pre></div>
<p>(En versiones recientes de GNU Emacs, la función <code>what-line</code> se ha ampliado para informarte el numero de linea en un búffer reducido, asi como el número de línea en un búffer amplio. La versión reciente es más compleja que la versión que se muestra aqui. Si te sientes aventurero, puede que quieras verla despues de averiguar como funciona esta version. Probablemente necesites utilizar <kbd>C-h f</kbd> (<code>describe-function</code>). La nueva versión utiliza un condicional para determinar si se ha reducido el búffer.</p>
<p>(También, utiliza <code>line-number-at-pos</code>, que entre otras expresiones simples, como <code>(goto-char (point-min))</code>, mueve el punto al inicio de la línea actual con <code>(forward-line 0)</code> en lugar de <code>beginning-of-line</code>.)</p>
<p>La función <code>what-line</code> que se muestra aqui tiene una línea de documentación y es interactiva, como era de esperar. Las dos líneas siguientes utilizan las funciones <code>save-restriction</code> y <code>widen</code>.</p>
<p>La forma especial <code>save-restriction</code> observa cualquier reduccion activa, en el buffer actual y restaura la reduccion despues de evaluar el código de su cuerpo.</p>
<p>La forma especial <code>save-restriction</code> es seguida por <code>widen</code>. Esta función deshace cualquier reduccion que pudo haber tenido el búffer actual cuando se llama a <code>what-line</code>. (La reduccion que esta alli es la reduccion que <code>save-restriction</code> recuerda.) Esta ampliación hace posible que los comandos para el conteo de lineas cuenten desde el inicio del búffer. De lo contrario, se habría limitado a contar dentro de la región accesible. Cualquier reduccion original se restaura justo antes de completar la funcion por la forma especial <code>save-restriction</code>.</p>
<p>La llamada a <code>widen</code> va seguida por <code>save-excursion</code>, que guarda la posición del cursor (es decir, el punto) y la marca, y los restaura después despues de que el código en el cuerpo de <code>save-excursion</code> utiliza la función <code>beginning-of-line</code> para mover el punto.</p>
<p>(Ten en cuenta que la expresión <code>(widen)</code> ocurre entre las formas especiales <code>save-restriction</code> y <code>save-excursion</code>. Cuando escribas las dos expresiones <code>save-…</code> consecutivamente, escribe <code>save-excursion</code> primero.)</p>
<p>Las dos últimas líneas de la función <code>what-line</code> son funciones para contar el número de líneas en el búffer y luego imprimirlo el número en el área echo.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Line %d&quot;</span>
         <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))))))</span>
</pre></div>
<p>La función <code>message</code> imprime un mensaje de una línea en la parte inferior de la pantalla de Emacs. El primer argumento va dentro de marcas de cita y se imprime como una cadena de caracteres. Sin embargo, puede contener una expresión <samp>%d</samp> para imprimir el siguiente argumento. <samp>%d</samp> imprime el argumento como un decimal, por lo que el mensaje dirá algo como <samp>Línea 243</samp>.</p>
<p>El número que se imprime en lugar del <samp>%d</samp> se calcula por la última línea de la función:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</pre></div>
<p>Lo que hace esto es contar las líneas desde la primer posición del búffer indicada por el <code>1</code>, hasta <code>(point)</code>, y luego sumar uno a este número. (La función <code>1+</code> suma uno a su argumento.) Se suma uno porque la línea 2 tiene solo una línea antes de ella, y <code>count-lines</code> cuenta solo las líneas <em>antes</em> de la línea actual.</p>
<p>Después que <code>count-lines</code> termina su trabajo, y se imprime el mensaje en el área echo, la función <code>save-excursion</code> restaura el punto y marca a sus posiciones originales; y <code>save-restriction</code> restaura la reduccion original, si la hay.</p>
</div>
<h3 id="Ejercicio-de-Reduccion" >Ejercicio de Reduccion</h3>
<div class="hBody-3" >
<p>Escribe una función que muestre los primeros 60 caracteres del búffer actual, incluso si has reducido el búffer despues mitad de modo que la primera línea es inaccesible. Restaura el punto, marca y la reduccion. Para este ejercicio, necesitas utilizar todo un popurri de funciones, incluyendo <code>save-restriction</code>, <code>widen</code>, <code>goto-char</code>, <code>point-min</code>, <code>message</code>, y <code>buffer-substring</code>.</p>
<p>(<code>buffer-substring</code> es una función que no aun no se menciona, tendrás que investigarla por tu cuenta; o quizás tengas que utilizar <code>buffer-substring-no-properties</code> o <code>filter-buffer-substring</code> …, u otras funciones. Las propiedades de texto son una funcionalidad que no sera discutida aquí.  Véase Sección <a href="info:elisp#Text-Properties" >Propiedades de Texto</a> en <em>El Manual de Referencia de Emacs Lisp</em>.)</p>
<p>Además, ¿realmente se necesita <code>goto-char</code> o <code>point-min</code>?  ¿O se puede escribir la función sin ellas?</p>
</div>
<h2 id="car,-cdr,-cons:-Funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</h2>
<div class="hBody-2" >
<p>En Lisp, <code>car</code>, <code>cdr</code>, y <code>cons</code> son funciones fundamentales. La función <code>cons</code> se utiliza para construir listas, y las funciones <code>car</code> y <code>cdr</code> se utilizan para desarmarlas.</p>
<p>En el paseo a través de la función <code>copy-region-as-kill</code>, veremos <code>cons</code>, asi como dos variantes de <code>cdr</code>, llamadas <code>setcdr</code> y <code>nthcdr</code>. (Véase Sección <a href="#copy-region-as-kill" >copy-region-as-kill</a>.)</p>
<p>El nombre de la función <code>cons</code> no es irazonable: es una abreviatura de la palabra ‘construir’. Por otro lado, el origen de los nombres <code>car</code> y <code>cdr</code>, es esoterico: <code>car</code> es un acrónimo de la frase ‘Contents of the Address part of the Register’ (Contenidos de las Direcciónes parte del Registro); y <code>cdr</code> (pronunciado ‘could-er’) es un acrónimo de la frase ‘Contents of the Decrement part of the Register’ (Contenidos de la parte de Decremento del Registro). Estas frases se refieren a piezas específicas de hardware inicial del computador en el que el Lisp fué desarrollado. Ademas de ser obsoletas, las frases han sido completamente irrelevantes por más de 25 años a cualquiera que piense sobre Lisp. No obstante, aunque algunos pocos académicos valientes han empezado a utilizar nombres más razonables para estas funciones, los viejos términos aun continuan en uso. En particular, porque los términos se utilizan en el código fuente Emacs Lisp, los usaremos en esta introducción.</p>
</div>
<h3 id="car-y-cdr" ><code>car</code> y <code>cdr</code></h3>
<div class="hBody-3" >
<p>El <code>car</code> de una lista es sensillamente, el primer elemento de la lista. De este modo, el <code>car</code> de la lista <code>(rosa violeta margarita tulipan)</code> es <code>rosa</code>.</p>
<p>Si estás leyendo esto en GNU Emacs, puedes comprobarlo evaluando lo siguiente:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</pre></div>
<p>Después de evaluar la expresión, aparecerá <code>rosa</code> en el área echo.</p>
<p>Claramente, un nombre más razonable para la función <code>car</code> sería <code>first</code> y esto es con frecuencia lo que se sugiere.</p>
<p><code>car</code> no elimina el primer elemento de la lista; solo informa de que es. Después de aplicar <code>car</code> a una lista, la lista sigue siendo la misma que era. En la jerga, <code>car</code> es ‘no-destructiva’. Esta caracteristica resulta ser importante.</p>
<p>El <code>cdr</code> de una lista es el resto de la lista, es decir, la función <code>cdr</code> devuelve la parte de la lista despues del primer elemento. Por lo tanto, mientras que el <code>car</code> de la lista <code>'(rosa violeta margarita tulipan)</code> es <code>rosa</code>, el resto de la lista, el valor devuelto por la función <code>cdr</code>, es <code>(violeta margarita tulipan)</code>.</p>
<p>Puedes ver esto evaluando lo siguiente del modo habitual:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</pre></div>
<p>Al evaluar esto, aparece <code>(violeta margarita tulipan)</code> en el área echo.</p>
<p>Al igual que <code>car</code>, <code>cdr</code> no elimina los elementos de la lista––simplemente devuelve un informe del segundo y los subsiguientes elementos presentes.</p>
<p>A propositio, en el ejemplo, se cita la lista de flores. De otra forma, el intérprete Lisp intentaría evaluar la lista llamando a <code>rosa</code> como una función. En este ejemplo, no queremos hacer esto.</p>
<p>Claramente, un nombre más razonable para <code>cdr</code> sería <code>rest</code>.</p>
<p>(Hay una lección aquí: Cuando des nombre a nuevas funciones, considera muy cuidadosamente lo que estes haciendo, ya que puedes adherirte a los nombres mas tiempo del esperado. La razón por la que este documento perpetúa estos nombres se debe a que el código fuente de Emacs Lisp usa, y de no usarlos, tendrias dificultados para leer el codigo; por favor, intenta evitar usar estos términos por tu cuenta. Las personas que vengan después te lo agradecerán.</p>
<p>Cuando se aplican <code>car</code> y <code>cdr</code> a una lista compuesta por símbolos, como la lista <code>(pino abeto roble arce)</code>, el elemento de la lista devuelto por la función <code>car</code> es el símbolo <code>pino</code> sin ningun paréntesis alrededor. <code>pino</code> es el primer elemento en la lista. Sin embargo, el <code>cdr</code> de la lista es una lista por en si, <code>(abeto roble arce)</code>, como puedes observar al evaluar las siguientes expresiones:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</pre></div>
<p>Por otro lado, en una lista de listas, el primer elemento es en sí mismo una lista. <code>car</code> devuelve este primer elemento como una lista. Por ejemplo, la siguiente lista contiene tres sub-listas, una lista de carnívoros, una lista de herbívoros y una lista de mamíferos:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ballena</span> <span class="nv">delfin</span> <span class="nv">foca</span><span class="p">)))</span>
</pre></div>
<p>En este ejemplo, el primer elemento de <code>car</code> de la lista es la lista de carnívoros, <code>(leon tigre leopardo)</code>, y el resto de la lista es <code>((gacela antilope cebra) (ballena delfin foca))</code>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ballena</span> <span class="nv">delfin</span><span class="p">)))</span>
</pre></div>
<p>vale la pena decir nuevamente que <code>car</code> y <code>cdr</code> son no destructivos––es dicir, no se modifican o cambian listas a las que se aplican. Esto es muy importante por cómo se utilizan.</p>
<p>En el primer capítulo, en la discusión sobre los átomos, dije que en Lisp, “ciertos tipos de átomos, como un arreglo, pueden separarse en partes; pero el mecanismo de hacer esto es diferente del mecanismo de separar una lista. En lo referente a Lisp, los átomos de una lista son indivisibles.” (Véase Sección <a href="#Átomos-Lisp" >Átomos Lisp</a>.) Las funciones <code>car</code> y <code>cdr</code> se utilizan para dividir listas y se consideran fundamentales en Lisp. Ya que no se puede dividir o tener acceso a las partes de un arreglo, un arreglo se considera un átomo. Por otro lado, la otra función fundamental, <code>cons</code>, se puede armar o construir una lista, pero no un arreglo. (Los arreglos se manejan por funciones especificas para arreglos. Véase Sección <a href="info:elisp#Arrays,-Arreglos" >info:elisp#Arrays, Arreglos</a> en el <em>El Manual de Referencia de GNU Emacs Lisp</em>.)</p>
</div>
<h3 id="cons" ><code>cons</code></h3>
<div class="hBody-3" >
<p>La función <code>cons</code> construye listas; que es lo opuesto a <code>car</code> y <code>cdr</code>. Por ejemplo, <code>cons</code> se puede utilizar para hacer una lista de cuatro elementos de la lista de tres elementos, <code>(abeto roble arce)</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;pino</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</pre></div>
<p>Después de evaluar esto, veras aparecer</p>
<pre><code class="example">(pino abeto roble arce)</code></pre>
<p>en el área echo. <code>cons</code> causa la creación de una nueva lista en la que el elemento es seguido por los elementos de la lista original.</p>
<p>Con frecuencia decimos que ‘<code>cons</code> coloca un nuevo elemento al principio de una lista; que agrega o empuja el elemento en la lista’, pero esta frase puede ser engañosa, ya que <code>cons</code> no modifica una lista existente, sino que crea una nueva.</p>
<p>Al igual que <code>car</code> y <code>cdr</code>, <code>cons</code> es no destructivo.</p>
<p><code>cons</code> debe tener una lista a unir.a<span class="note" ><sup><a href="#9" >9</a></sup></span> No puedes iniciar de la nada absoluta. Si estás construyendo una lista, es necesario proporcionar al menos una lista vacía al inicio. Aquí hay una serie de expresiones <code>cons</code> que construyen una lista de flores. Si está leyendo esto en GNU Emacs, puedes evaluar cada una de las expresiones; en este texto el valor se imprime después de <samp>⇒</samp>, que se puede leer como ‘evalúas a’.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;tulipan</span> <span class="p">())</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">tulipan</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;margarita</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">tulipan</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;violeta</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;rosa</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">)</span>
</pre></div>
<p>En el primer ejemplo, la lista vacía se muestra como <code>()</code> y se construye una lista de <code>tulipan</code> seguida por la lista vacía. Como puedes ver, la lista vacía no se muestra en la lista que fué construida. Todo lo que se ve es <code>(tulipan)</code>. La lista vacía no cuenta como un elemento de una lista porque no hay nada en una lista vacía. En terminos generales, una lista vacía es invisible.</p>
<p>El segundo ejemplo, <code>(cons 'margarita '(tulipan))</code> construye una nueva lista de dos elemento poniendo <code>margarita</code> delante de <code>tulipan</code>; y el tercer ejemplo construye una lista de tres elementos poniendo <code>violeta</code> delante de <code>margarita</code> y <code>tulipan</code>.</p>
</div>
<h4 id="Encuentra-la-longitud-de-una-lista:-length" >Encuentra la longitud de una lista: <code>length</code></h4>
<div class="hBody-4" >
<p>Pueden averiguar cuántos elementos hay en una lista utilizando la función Lisp <code>length</code>, como en los siguientes ejemplos:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">tulipan</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">1</span>

<span class="p">(</span><span class="nf">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">2</span>

<span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;violeta</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">)))</span>
     <span class="err">⇒</span> <span class="mi">3</span>
</pre></div>
<p>En el tercer ejemplo, la función <code>cons</code> se utiliza para construir una lista de tres elementos que se pasa como argumento a la función <code>length</code>.</p>
<p>También podemos utilizar <code>length</code> para contar el número de elementos en una lista vacía:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">length</span> <span class="p">())</span>
     <span class="err">⇒</span> <span class="mi">0</span>
</pre></div>
<p>Como era de esperar, el número de elementos en una lista vacía es cero.</p>
<p>Un experimento interesante es averiguar qué ocurre si se intenta encontrar la longitud de ninguna lista en absoluto; es decir, si se intenta llamar a <code>length</code> sin darle un argumento, ni siquiera una lista vacía:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">length</span> <span class="p">)</span>
</pre></div>
<p>La que ves, si evalúas esto, es el mensaje de error</p>
<pre><code class="example">Lisp error: (wrong-number-of-arguments length 0)</code></pre>
<p>Esto significa que la función recibe un número incorrecto de argumentos, cero, cuando se espera algún otro número de argumentos. En este caso, se espera un argumento, el argumento es una lista cuya longitud esta midiendo la función. (Ten en cuenta que <em>una</em> lista es <em>un</em> argumento, incluso si la lista tiene muchos elementos en su interior.)</p>
<p>La parte del mensaje de error que dice <samp>length</samp> es el nombre de la función.</p>
</div>
<h3 id="nthcdr" ><code>nthcdr</code></h3>
<div class="hBody-3" >
<p>La función <code>nthcdr</code> se asocia con la función <code>cdr</code>. Lo que hace es tomar la <code>cdr</code> de una lista repetidamente.</p>
<p>Si tomas el <code>cdr</code> de la lista <code>(pino abeto roble arce)</code>, te devuelve la lista <code>(abeto roble arce)</code>. Si repites esto al retorno, devolverá la lista <code>(roble arce)</code>. (Por supuesto, repetir <code>cdr</code> en la lista original solo dará el <code>cdr</code> original, ya que la función no cambia la lista. Necesitas evaluar el <code>cdr</code> del <code>cdr</code> y así sucesivamente.) Si esto contiúa, finalmente se devuelve una lista vacía, que en este caso, en vez de mostrarse como <code>()</code> se muestra como <code>nil</code>.</p>
<p>Para comprovarlo, aquí hay una serie de <code>cdr</code>s repetidos, el texto a despues de <samp>⇒</samp> muestra lo que se devuelve.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span><span class="p">(</span><span class="nv">arce</span><span class="p">)</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">nil</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="ss">&#39;nil</span><span class="p">)</span>
     <span class="err">⇒</span> <span class="no">nil</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="p">())</span>
     <span class="err">⇒</span> <span class="no">nil</span>
</pre></div>
<p>También puedes hacer varios <code>cdr</code>s sin imprimir los valores intermedios, de esta forma:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
</pre></div>
<p>En este ejemplo, el intérprete Lisp evalúa la lista mas interna primero. La lista mas interna está entre comillas, por lo que solo pasa la lista tal cual al <code>cdr</code> interno. Este <code>cdr</code> pasa una lista formada por el segundo y subsiguientes elementos de la lista al <code>cdr</code> externo, que produce una lista compuesta del tercer y subsiguientes elementos de la lista original. En este ejemplo, la función <code>cdr</code> se repite y devuelve una lista que consiste en la lista original sin sus primeros dos elementos.</p>
<p>La función <code>nthcdr</code> hace lo mismo que repetir la llamada a <code>cdr</code>. En el siguiente ejemplo, el argumento 2 se pasa a la función <code>nthcdr</code>, junto con la lista, y el valor devuelto es la lista sin sus dos primeros elementos, que es exactamente los mismos que repetir dos veces <code>cdr</code> en la lista:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
</pre></div>
<p>Utilizando la lista original de cuatro elementos, podemos ver qué ocurre cuando se pasan varios argumentos numéricos a <code>nthcdr</code>, incluyendo 0, 1, y 5:</p>
<div class="highlight"><pre><span></span><span class="c1">;; Leave the list as it was.</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>

<span class="c1">;; Return a copy without the first element.</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>

<span class="c1">;; Return a copy of the list without three elements.</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">arce</span><span class="p">)</span>

<span class="c1">;; Return a copy lacking all four elements.</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">4</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">nil</span>

<span class="c1">;; Return a copy lacking all elements.</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">5</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">nil</span>
</pre></div>
</div>
<h3 id="nth" ><code>nth</code></h3>
<div class="hBody-3" >
<p>La función <code>nthcdr</code> toma el <code>cdr</code> de una lista repetidamente. La función <code>nth</code> toma el <code>car</code> del resultado devuelto por <code>nthcdr</code>. Devuelve el enesimo elemento de la lista.</p>
<p>Por lo tanto, si <code>nth</code> no fuera definido en C por velocidad, su definición sería:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nf">nth</span> <span class="p">(</span><span class="nv">n</span> <span class="nf">list</span><span class="p">)</span>
  <span class="s">&quot;Devuelve el eNesimo elemento de la lista.</span>
<span class="s">N cuenta apartir de cero.  si LIST no es tan largo, devuelve nil.&quot;</span>
  <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="nv">n</span> <span class="nf">list</span><span class="p">)))</span>
</pre></div>
<p>(Originalmente, <code>nth</code> se definio en Emacs Lisp dentro de <span class="file" >subr.el</span>, pero su definición fué rehecha en C en los 1980s.)</p>
<p>La función <code>nth</code> devuelve un solo elemento de una lista. Esto puede ser muy conveniente.</p>
<p>Toma en cuenta que los elementos estan numerados apartir del cero, no de uno. Es decir, el primer elemento de una lista, su <code>car</code> es el elemento cero. Esto se llama contar en ‘base a cero’ y con frecuencia molesta a las personas acostumbradas a que el primer elemento en una lista sea el número uno, que es ‘basado en uno’.</p>
<p>Por ejemplo:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">nth</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;uno&quot;</span> <span class="s">&quot;dos&quot;</span> <span class="s">&quot;tres&quot;</span><span class="p">))</span>
    <span class="err">⇒</span> <span class="s">&quot;uno&quot;</span>

<span class="p">(</span><span class="nf">nth</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;uno&quot;</span> <span class="s">&quot;dos&quot;</span> <span class="s">&quot;tres&quot;</span><span class="p">))</span>
    <span class="err">⇒</span> <span class="s">&quot;dos&quot;</span>
</pre></div>
<p>Vale la pena mencionar que <code>nth</code>, al igual que <code>nthcdr</code> y <code>cdr</code>, no modifica la lista original––la función es no destructiva. En contraste con las funciones <code>setcar</code> y <code>setcdr</code>.</p>
</div>
<h3 id="setcar" ><code>setcar</code></h3>
<div class="hBody-3" >
<p>Como podrías adivinar desde sus nombres, las funciones <code>setcar</code> y <code>setcdr</code> asignan el <code>car</code> o el <code>cdr</code> de una lista a un nuevo valor. Ambos cambian realmente la lista original, a diferencia de <code>car</code> y <code>cdr</code> que dejan la lista original como estaba. Una forma de averiguar cómo funcionan es experimentar. Vamos a empezar con la función <code>setcar</code>.</p>
<p>Primero, podemos crear una lista y luego asignar el valor de una variable a la lista, usando la función <code>setq</code>. Aquí hay una lista de animales:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">antilope</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>
</pre></div>
<p>Si estás leyendo esto dentro de GNU Emacs, puedes evaluar esta expresión de la forma habitual, coloca el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>. (Estoy haciendo esto aqui mismo, mientras lo escribo. Esta es una de las ventajas de tener el intérprete construido dentro del entorno de computacion. Por cierto, cuando no hay nada en la línea después del paréntesis final, como un comentario, el punto puede estar en la siguiente línea. De este modo, si tu cursor está en la primera columna de la siguiente línea, no es necesario moverlo. En realidad, Emacs permite cualquier cantidad de espacios en blanco después del paréntesis final.)</p>
<p>Cuando evaluamos la variable <code>animales</code>, vemos que está unida a la lista <code>(antilope jirafa leon tigre)</code>:</p>
<div class="highlight"><pre><span></span><span class="nv">animales</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">antilope</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">)</span>
</pre></div>
<p>Dicho de otro modo, la variable <code>animales</code> apunta a la lista <code>(antilope jirafa leon tigre)</code>.</p>
<p>A continuacion, evalua la función <code>setcar</code> mientras le pasas dos argumentos, la variable <code>animales</code> y el símbolo citado <code>hipopotamo</code>; esto se hace escribiendo la lista de tres elementos <code>(setcar animales 'hipopotamo)</code> y entonces evaluando de la forma habitual:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">setcar</span> <span class="nv">animales</span> <span class="ss">&#39;hipopotamo</span><span class="p">)</span>
</pre></div>
<p>Después de evaluar esta expresión, evalúa la variable <code>animales</code> de nuevo. Veras que la lista de animales ha cambiado:</p>
<div class="highlight"><pre><span></span><span class="nv">animales</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">hipop</span><span class="err">ó</span><span class="nv">tamo</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">)</span>
</pre></div>
<p>El primer elemento de la lista, <code>antilope</code> se reemplaza por <code>hipopotamo</code>.</p>
<p>Así podemos ver que <code>setcar</code> no agrega un nuevo elemento a la lista como haria <code>cons</code>; Se reemplaza <code>antílope</code> con <code>hipopótamo</code>; esto <em>cambia</em> la lista.</p>
</div>
<h3 id="setcdr" ><code>setcdr</code></h3>
<div class="hBody-3" >
<p>La función <code>setcdr</code> es similar a la función <code>setcar</code>, excepto que la función reemplaza todos los elementos despues del primero en lugar del primer elemento.</p>
<p>(Para ver cómo cambiar el último elemento de una lista, mira directamente en la Seccion <a href="#La-función-kill-new" >La función <code>kill-new</code></a>, que utiliza las funciones <code>nthcdr</code> y <code>setcdr</code>.)</p>
<p>Para ver cómo funciona esto, asigna el valor de la variable a una lista de animales domesticados evaluando la siguiente expresión:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">setq</span> <span class="nv">animales-domesticos</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">caballo</span> <span class="nv">vaca</span> <span class="nv">oveja</span> <span class="nv">cabra</span><span class="p">))</span>
</pre></div>
<p>Si evalúas la lista, debe devolverte la lista <code>(caballo vaca oveja cabra)</code>:</p>
<div class="highlight"><pre><span></span><span class="nv">animales-domesticos</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">caballo</span> <span class="nv">vaca</span> <span class="nv">oveja</span> <span class="nv">cabra</span><span class="p">)</span>
</pre></div>
<p>Luego, evalúa <code>setcdr</code> con dos argumentos, el nombre de la variable que tiene una lista como su valor, y la lista a la que se establecera el <code>cdr</code> de la primera lista;</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">setcdr</span> <span class="nv">animales-domesticos</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gato</span> <span class="nv">perro</span><span class="p">))</span>
</pre></div>
<p>Si evalúas esta expresión, la lista <code>(gato perro)</code> aparecerá en el área echo. Este es el valor devuelto por la función. El resultado que nos interesa es el “efecto secundario”, que se puede mediante la evaluacion de la variable <code>animales-domesticos</code>:</p>
<div class="highlight"><pre><span></span><span class="nv">animales-domesticos</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="nv">caballo</span> <span class="nv">gato</span> <span class="nv">perro</span><span class="p">)</span>
</pre></div>
<p>En efecto, la lista cambia de <code>(caballo vaca oveja cabra)</code> a <code>(caballo gato perro)</code>. El <code>cdr</code> de la lista cambia de <code>(vaca oveja cabra)</code> a <code>(gato perro)</code>.</p>
</div>
<h3 id="Ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Construye una lista de cuatro pájaros evaluando varias expresiones con <code>cons</code>. Descubre que ocurre cuando aplicas <code>cons</code> a una lista sobre si misma. Reemplaza el primer elemento de la lista de cuatro pájaros con un pez. Reemplaza el resto de esta lista con una lista de otro pez.</p>
</div>
<h2 id="Corte-y-Almacenamiento-de-Texto" >Corte y Almacenamiento de Texto</h2>
<div class="hBody-2" >
<p>Siempre cortas o guardar texto de un búffer con un comando ‘kill’ en GNU Emacs, se almacena en una lista y lo puedes traer de vuelta con un comando ‘yank’.</p>
<p>(El uso de la palabra ‘kill’ (destruir) en Emacs para procesos que específicamente <em>no</em> destruyen los valores de las entidades es un accidente histórico desafortunado. Una palabra mucho más apropiada seria ‘clip’ (cortar) ya que eso es lo que hacen los comandos <code>kill</code>; cortan el texto fuera de un búffer y lo ponen en almacenamiento, donde puede traerse de vuelta. Con frecuencia me he visto tentado a sustituir globalmente todas las apariciones de ‘kill’ en el codigo de Emacs con ‘clip’ y todas las apariciones de ‘killed’ (destruido) con ‘clipped’ (cortado).)</p>
<p>Cuando el texto se corta de un búffer, se almacena en una lista. Piezas sucesivas de texto se almacenan en la lista sucesivamente, por lo que la lista podría verse así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="s">&quot;una pieza de texto&quot;</span> <span class="s">&quot;pieza anterior&quot;</span><span class="p">)</span>
</pre></div>
<p>La función <code>cons</code> se puede utilizar para crear una nueva lista a partir de una pieza de texto (un ‘átomo’, para usar la jerga) y una lista existente, asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">cons</span> <span class="s">&quot;otra pieza&quot;</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;una pieza de texto&quot;</span> <span class="s">&quot;pieza anterior&quot;</span><span class="p">))</span>
</pre></div>
<p>Si evaluas esta expresión, aparecera una lista de tres elementos en el área echo:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="s">&quot;otra pieza&quot;</span> <span class="s">&quot;una pieza de texto&quot;</span> <span class="s">&quot;pieza anterior&quot;</span><span class="p">)</span>
</pre></div>
<p>Puedes recuperar cualquier pieza de texto que desees, con las funciones <code>car</code> y <code>nthcdr</code>. Por ejemplo, en el siguiente código, <code>nthcdr 1 …</code> devuelve la lista con el primer elemento eliminado; y <code>car</code> devuelve el primer elemento de ese resto––el segundo elemento de la lista original:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;otra pieza&quot;</span>
                 <span class="s">&quot;una pieza de texto&quot;</span>
                 <span class="s">&quot;pieza anterior&quot;</span><span class="p">)))</span>
     <span class="err">⇒</span> <span class="s">&quot;una pieza de texto&quot;</span>
</pre></div>
<p>Por supuesto, las funciones reales en Emacs son más complejas que esto. El código para el corte y recuperarcion de texto tiene que ser escrito de modo que Emacs pueda determinar qué elemento en la lista se quiere––el primero, segundo, tercero o cualquier otro. Además, cuando se llega al final de la lista, Emacs deberia darte el primer elemento de la lista, en lugar de nada en absoluto.</p>
<p>La lista que contiene las piezas de texto se llama <dfn>kill ring</dfn> (anillo de la muerte). En este capítulo se hace una descripción del anillo de la muerte y como se utiliza para un primer rastreo como funciona la función <code>zap-to-char</code>. Esta función utiliza (o ‘llama’) a una función que invoca a otra función que manipula el anillo de la muerte. Por la tanto, antes de llegar a las montañas, debemos escalar las colinas.</p>
<p>En un capítulo posterior se describe cómo se recupera el texto que se corta de un buffer. Ver  Sección <a href="#Pegando-texto" >Pegando texto</a>.</p>
</div>
<h3 id="zap-to-char" ><code>zap-to-char</code></h3>
<div class="hBody-3" >
<p>La función <code>zap-to-char</code> apenas ha variado entre GNU Emacs versión 19 y GNU Emacs versión 22. Sin embargo, <code>zap-to-char</code> llama a otra función, <code>kill-region</code>, que disfruto de una rescritura importante.</p>
<p>La función <code>kill-region</code> en Emacs 19 es compleja, pero no utiliza código que sea importante en este momento. Lo saltaremos.</p>
<p>La función <code>kill-region</code> en Emacs 22 es más de fácil leer que la misma función en Emacs 19 e introduce un concepto muy importante, el manejo de errores. Caminaremos a través de la función.</p>
<p>Pero primero, veamos la función interactiva <code>zap-to-char</code>.</p>
<p>La función <code>zap-to-char</code> elimina el texto en la región entre la ubicacion del cursor (es decir. del punto) hasta e incluyendo la siguiente ocurrencia de un caracter específicado. El texto que <code>zap-to-char</code> elimina se pone en el anillo de la muerte; y puede ser recuperarse escribiendo <kbd>C-y</kbd> (<code>yank</code>). Si el comando recive un argumento, elimina el texto a través de este número de ocurrencias. Por lo tanto, si el cursor estuviera al inicio de esta frase y el carácter fuera <samp>s</samp>, se eliminaria <samp>Por la tanto, </samp>. Si el argumento fueran dos, se eliminaria <samp>Por lo tanto, si el curs</samp>, hasta e incluiendo la <samp>s</samp> en <samp>cursor</samp>.</p>
<p>Si no se encuentra el carácter específicado <code>zap-to-char</code> dirá “Búsqueda fallida”, te indicaria el caracter que escribiste, y no eliminaria ningun texto.</p>
<p>Para determinar la cantidad de texto a eliminar <code>zap-to-char</code> utiliza una función de búsqueda. Las búsquedas se utilizan ampliamente en el código que manipula el texto, y vamos a centrar la atención en ellos, asi como en el comando de eliminacion.</p>
<p>Aquí está el texto completo de la función en la versión 22:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">zap-to-char</span> <span class="p">(</span><span class="nv">arg</span> <span class="nv">char</span><span class="p">)</span>
  <span class="s">&quot;Corta e incluye la aparicion de la enesima (ARG) ocurrencia del caracter CHAR.</span>
<span class="s">Se ignora entre mayusculas y minusculas si ‘case-fold-search’ es no-nil en</span>
<span class="s">el buffer actual.</span>
<span class="s">Retrocede si ARG es negativo; error si no se encuentra CHAR.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;p\ncZap to char: &quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">char-table-p</span> <span class="nv">translation-table-for-input</span><span class="p">)</span>
      <span class="p">(</span><span class="k">setq</span> <span class="nv">char</span> <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">aref</span> <span class="nv">translation-table-for-input</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">char</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="k">progn</span>
                         <span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span>
                                         <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</pre></div>
<p>La linea de documentacion esta traducida al español. En la version original no se utiliza la palabra ‘Corta’ en su lugar se utiliza ‘kill’.</p>
</div>
<h4 id="La-expresión-interactive" >La expresión <code>interactive</code></h4>
<div class="hBody-4" >
<p>La expresión interactiva en el comando <code>zap-to-char</code> es esta:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;p\ncZap to char: &quot;</span><span class="p">)</span>
</pre></div>
<p>La parte entre comillas, <code>&quot;p\ncZap to char: &quot;</code> (Cortar a caracter), especifica dos cosas diferentes. Lo mas sencillo y que aparece primero es la <samp>p</samp>. Esta parte se separa de la siguiente parte por una línea nueva, <samp>\n</samp>. La <samp>p</samp> significa que el primer argumento de la función será pasando el valor de un ‘prefijo procesado’. El argumento prefijo se pasa Presionando <kbd>C-u</kbd> y un número, o <kbd>M-</kbd> y un número. Si la función se llamada interactivamente sin un prefijo, se pasa 1 a este argumento.</p>
<p>La segunda parte de <code>&quot;p\ncZap to char: &quot;</code> es <samp>cZap to char:</samp>. En esta parte, la <samp>c</samp> minuscula indica que <code>interactive</code> espera un prompt y que el argumento será un caracter. El prompt va despues de <samp>c</samp> y es la cadena <samp>Zap to char: </samp> (con un espacio después de los dos puntos para verse bien).</p>
<p>Todo lo que esto hace es preparar los argumentos de <code>zap-to-char</code> para que sean del tipo correcto, y darle al usuario un prompt.</p>
<p>En un búffer de solo lectura, la función <code>zap-to-char</code> copia el texto al anillo de la muerte, pero no lo elimina. El área echo muestra un mensaje diciendo que el búffer es de solo lectura. Ademas, el terminal puede emitir un pitido o parpadeo.</p>
</div>
<h4 id="El-cuerpo-de-zap-to-char" >El cuerpo de <code>zap-to-char</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>zap-to-char</code> contiene el código que mata (es decir, elimina) el texto en la región desde la posición actual del cursor hasta e incluyendo el carácter especificado.</p>
<p>La primera parte del código se ve asi:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">char-table-p</span> <span class="nv">translation-table-for-input</span><span class="p">)</span>
    <span class="p">(</span><span class="k">setq</span> <span class="nv">char</span> <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">aref</span> <span class="nv">translation-table-for-input</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">char</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="k">progn</span>
                       <span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
                       <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</pre></div>
<p><code>char-table-p</code> es una función que aun no hemos. Determina si su argumento es una tabla de caracteres. Si lo es, establece el caracter pasado a <code>zap-to-char</code> a uno de ellos, si ese carácter existe, o al carácter en sí. (Esto es importante para ciertos caracteres en lenguajes no Europeos. La función <code>aref</code> extrae un elemento desde un arreglo. Esta funcion es específica para arreglos y no sera descrita en este documento. Véase Sección <a href="info:elisp#Array" >Arreglos</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.)</p>
<p><code>(point)</code> es la posición actual del cursor.</p>
<p>La siguiente parte del código es una expresión utilizando <code>progn</code>. El cuerpo del <code>progn</code> consiste en llamadas a <code>search-forward</code> y <code>point</code>.</p>
<p>Es fácil comprender cómo funciona <code>progn</code> después de aprender sobre <code>search-forward</code>, asi que veremos <code>search-forward</code> y luego <code>progn</code>.</p>
</div>
<h4 id="La-función-search-forward" >La función <code>search-forward</code></h4>
<div class="hBody-4" >
<p>La función <code>search-forward</code> se utiliza para localizar el caracter a borrar en <code>zap-to-char</code>. Si la búsqueda es exitosa, <code>search-forward</code> deja el punto inmediatamente después del último carácter en la cadena objetivo. (En <code>zap-to-char</code>, la cadena objetivo es solo un carácter largo. <code>zap-to-char</code> usa la función <code>char-to-string</code> para asegurar que el computador trata este carácter como una cadena). Si la búsqueda es hacia atrás, <code>search-forward</code> deja el punto justo antes del primer carácter en el objetivo. Ademas, <code>search-forward</code> devuelve <code>t</code> para verdadero. (Por lo tanto, desplazar el punto es un ‘efecto secundario’.)</p>
<p>En <code>zap-to-char</code>, la función <code>search-forward</code> se ve así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
</pre></div>
<p>La función <code>search-forward</code> toma cuatro argumentos:</p>
<ol>
<li><p>El primer argumento es el objetivo, que esta buscando. Debe ser una cadena, como <cite>z</cite>.</p>
<p>Cuando esto sucede, el argumento pasado a <code>zap-to-char</code> es un solo caracter. Debido a la forma en la que se construyen los computadores, el intérprete Lisp puede tratar un solo caracter de forma distinta a una cadena de caracteres. Dentro del computador, un solo caracter tiene un formato electrónico diferente a una cadena de un caracter. (Un solo caracter con frecuencia puede grabarse en el computador utilizardo exactamente un byte; pero una cadena puede ser mas larga, y el equipo debe estar listo para ello.) Ya que la función <code>search-forward</code> busca una cadena, el caracter que recive la función <code>zap-to-char</code> como argumento debe convertirse dentro del computador de un formato a otro; de lo contrario, la función <code>search-forward</code> fallará. Se utiliza la función <code>char-to-string</code> para realizar esta conversión.</p>
</li>
<li><p>El segundo argumento limita la búsqueda; se especifica como una posición en el búffer. En este caso, la búsqueda puede ir al final del búffer, por lo que no se establece ningun limite y el segundo argumento es <code>nil</code>.</p>
</li>
<li><p>El tercer argumento le dice a la función lo que debe hacer si la búsqueda falla––puede señalar un error (e imprimir un mensaje) o puede devolver <code>nil</code>. Un <code>nil</code> como el tercer argumento hace que la función de señal de un error cuando la búsqueda falla.</p>
</li>
<li><p>El cuarto argumento de <code>search-forward</code> es el numero de repeticion––cuántas ocurrencias de la cadena buscar. Este argumento es opcional y si la función se llamada sin contador de repeticion, este argumento pasa el valor 1. Si este argumento es negativo, la búsqueda va hacia atrás.</p>
</li>
</ol>
<p>En forma de plantilla, una expresión <code>search-forward</code> tiene este aspecto:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">search-forward</span> <span class="s">&quot;cadena-a-buscar&quot;</span>
                <span class="nv">limite-de-busqueda</span>
                <span class="nv">que-hacer-si-la-busqueda-falla</span>
                <span class="nv">contador-de-repeticion</span><span class="p">)</span>
</pre></div>
<p>A continuacion veremos <code>progn</code>.</p>
</div>
<h4 id="La-forma-especial-progn" >La forma especial <code>progn</code></h4>
<div class="hBody-4" >
<p><code>progn</code> es una forma especial que hace que cada uno de sus argumentos se evalue en secuencia y luego devuelve el valor del último. Las expresiones anteriores solo se evaluan por los efectos secundarios que realizan. Los valores que producen son descartados.</p>
<p>La plantilla de una expresión <code>progn</code> es muy simple:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">progn</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>En <code>zap-to-char</code>, la expresión <code>progn</code> tiene que hacer dos cosas: poner el punto exactamente en la posición correcta; y devolver la posición del punto para que <code>kill-region</code> sepa handa donde cortar.</p>
<p>El primer argumento de <code>progn</code> es <code>search-forward</code>. Cuando <code>search-forward</code> encuentra la cadena, la función deja el punto inmediatamente después del último caracter en la cadena objetivo. (En este caso la cadena objetivo es solo un carácter de longitud.) Si la búsqueda es hacia atrás, <code>search-forward</code> deja el punto justo antes del primer carácter objetivo. El movimiento del punto es un efecto secundario.</p>
<p>El segundo y último argumento de <code>progn</code> es la expresión <code>(point)</code>. Esta expresión devuelve el valor del punto, que en este caso será la ubicacion a la que se ha movido por <code>search-forward</code>. (En el codigo, una línea le indica a la función que debe ir un carácter atras, si va hacia adelante, se comentó en 1999; yo no recuerdo si esta caracteriscita o caracteriscita erronea alguna vez fue parte del codigo distribuido.) El valor de <code>point</code> es devuelto por la expresión <code>progn</code> y se pasa a <code>kill-region</code> como el segundo argumento de <code>kill-region</code> .</p>
</div>
<h4 id="Resumiendo-zap-to-char" >Resumiendo <code>zap-to-char</code></h4>
<div class="hBody-4" >
<p>Ahora que hemos visto cómo funcionan <code>search-forward</code> y <code>progn</code>, podemos ver cómo la función <code>zap-to-como</code> trabaja como un todo.</p>
<p>El primer argumento de <code>kill-region</code> es la posición del cursor cuando se da el comando <code>zap-to-char</code>––el valor de punto en ese momento. Dentro de <code>progn</code>, la funcion de búsqueda mueve el punto justo después de que ell caracter a borrar y <code>point</code> devuelvan el valor esa ubicacion. La función <code>kill-region</code> reune estos dos valores de punto, el primero como el inicio de la región y el segundo como el final de la región, y elimina la región.</p>
<p>La forma especial <code>progn</code> es necesario porque el comando <code>kill-region</code> toma dos argumentos; y fallaría si las expresiones <code>search-forward</code> y <code>point</code> se escribieran en secuencia como dos argumentos adicionales. La expresión <code>progn</code> es solo un argumento para <code>kill-region</code> y devuelve el valor que <code>kill-region</code> necesita para su segundo argumento.</p>
</div>
<h3 id="kill-region" ><code>kill-region</code></h3>
<div class="hBody-3" >
<p>La función <code>zap-to-char</code> utiliza la función <code>kill-region</code>. Esta función corta texto de una región y copia ese texto al anillo de la muerte, desde el cual puede ser recuperado.</p>
<p>La versión en Emacs 22 de esta funcion utiliza <code>condition-case</code> y <code>copy-region-as-kill</code>, ambas seran explicadas. <code>condition-case</code> es una forma especial importante.</p>
<p>En esencia, la función <code>kill-region</code> llama a <code>condition-case</code>, que toma tres argumentos. En esta función, el primer argumento no hace nada. El segundo argumento contiene el código hace el trabajo cuando todo va bien. El tercer argumento contiene el código que se llama en caso de un error.</p>
<p>Veremos el código de <code>condition-case</code> en un momento. Primero, veamos la definición de <code>kill-region</code>, con comentarios añadidos:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-region</span> <span class="p">(</span><span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&quot;Kill (\&quot;corta\&quot;) el texto entre el punto y marca.</span>
<span class="s">Esto elimina el texto del buffer y lo guarda en el anillo de la muerte.</span>
<span class="s">El comando \\[yank] puede recuperarlo desde alli. … &quot;</span>

  <span class="c1">;; • Pueto que el orden importa, primero pasa el punto.</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span><span class="p">)))</span>
  <span class="c1">;; • Y dinos si no podemos cortar el texto.</span>
  <span class="c1">;; ‘A menos que’ sea un ‘if’ sin parte then.</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="k">and</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
    <span class="p">(</span><span class="ne">error</span> <span class="s">&quot;La marca no esta definida, por lo que no hay ninguna region&quot;</span><span class="p">))</span>

  <span class="c1">;; • ‘condition-case’ toma tres argumentos.</span>
  <span class="c1">;;    Si el primer argumento es nil, como aqui,</span>
  <span class="c1">;;    la informacion del error no se almacena</span>
  <span class="c1">;;    para su uso por otra funcion.</span>
  <span class="p">(</span><span class="k">condition-case</span> <span class="no">nil</span>

      <span class="c1">;; • El segundo argumento de ‘condition-case’ le dice al</span>
      <span class="c1">;;    interprete Lisp que hacer cuando todo va bien.</span>

      <span class="c1">;;    Empieza con una funcion ‘let’ que extrae la cadena y</span>
      <span class="c1">;;    comprueba si existe.  Si es asi (esta es lo que comprueba</span>
      <span class="c1">;;    ‘when’), esta llama a una funcion ‘if’ que determina</span>
      <span class="c1">;;    si el comando anterior fue otra llamada a ‘kill-region’;</span>
      <span class="c1">;;    si lo fue, el nuevo texto se añade al texto anterior; se</span>
      <span class="c1">;;    no, se llama a una funcion diferente, ‘kill-new’.</span>

      <span class="c1">;;    La funcion ‘kill-append’ concatena la nueva y vieja cadena.</span>
      <span class="c1">;;    La funcion ‘kill-new’ inserta el texto dentro de un nuevo</span>
      <span class="c1">;;    elemento en el anillo de la muerte.</span>

      <span class="c1">;;    ‘when’ es un ‘if’ sin una parte else.  El segundo ‘when’</span>
      <span class="c1">;;    comprueba de nuevo si la cadena actual existe; Ademas,</span>
      <span class="c1">;;    comprueba si el comando anterior fue otra llamada a</span>
      <span class="c1">;;    ‘kill-region’.  Si uno u otra condicion es verdadera,</span>
      <span class="c1">;;    entonces establece que el comando actual sea ‘kill-region’.</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">string</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span> <span class="no">t</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nf">string</span>                    <span class="c1">;STRING es nil si BEG = END</span>
          <span class="c1">;; agrega esa cadena al anillo de la muerte, de uno forma u otra.</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
              <span class="c1">;;    − ‘yank-handler’ es un argumento opcional de</span>
              <span class="c1">;;    ‘kill-region’ que indica a las funciones ‘kill-append’</span>
              <span class="c1">;;    y ‘kill-new’ como tratar las propiedades añadidas al</span>
              <span class="c1">;;    texto, como ‘negrita’ o ‘cursiva’.</span>
              <span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">kill-new</span> <span class="nf">string</span> <span class="no">nil</span> <span class="nv">yank-handler</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="k">or</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">))</span>
          <span class="p">(</span><span class="k">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;kill-region</span><span class="p">))</span>
        <span class="no">nil</span><span class="p">)</span>

    <span class="c1">;;  • El tercer argumento de ‘condition-case’ le dice al interprete</span>
    <span class="c1">;;    que hacer con un error.</span>
    <span class="c1">;;    El tercer argumento tiene una parte de condiciones y una parte cuerpo.</span>
    <span class="c1">;;    Si se cumplen las condiciones (en este caso,</span>
    <span class="c1">;;             si el texto o el buffer son de solo lectura)</span>
    <span class="c1">;;    entonces se ejecuta el cuerpo.</span>
    <span class="c1">;;    La primer parte del tercer argumento es la siguiente:</span>
    <span class="p">((</span><span class="nv">buffer-read-only</span> <span class="nv">text-read-only</span><span class="p">)</span> <span class="c1">;; la parte if</span>
     <span class="c1">;; …  la parte then</span>
     <span class="p">(</span><span class="nv">copy-region-as-kill</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
     <span class="c1">;;    A continuacion, tambien como parte de la parte then, establece</span>
     <span class="c1">;;    this-command, por lo que se establece en un error</span>
     <span class="p">(</span><span class="k">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
     <span class="c1">;;    Finalmente, en la pante then, envia un mensaje si puede copiar</span>
     <span class="c1">;;    el texto en el anillo de la muerte sin señalar un error, pero</span>
     <span class="c1">;;    no la hace si no puede.</span>
     <span class="p">(</span><span class="k">if</span> <span class="nv">kill-read-only-ok</span>
         <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nf">message</span> <span class="s">&quot;Read only text copied to kill ring&quot;</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
       <span class="c1">;; Si el buffer no es de solo lectura, el texto es.</span>
       <span class="p">(</span><span class="nf">signal</span> <span class="ss">&#39;text-read-only</span> <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))))</span>
</pre></div>
</div>
<h4 id="condition-case" ><code>condition-case</code></h4>
<div class="hBody-4" >
<p>Como se ha visto antes (Ver Seccion <a href="#Generar-un-Mensaje-de-Error" >Generar un Mensaje de Error</a>), cuando el intérprete de Emacs Lisp tiene problemas evaluando una expresión, te proporciona ayuda; en la jerga, esto se llama “Señalar un error”. Normalmente, el computador detiene el programa y te muestra un mensaje.</p>
<p>Sin embargo, algunos programas emprenden acciones complicadas. No deben simplemente detenerse en un error. En la función <code>kill-region</code>, el error mas probable es que intente cortar texto que es de solo lectura y no puede ser eliminado. Así que la función <code>kill-region</code> contiene código para manejar esta circunstancia. Este código, que forma el cuerpo de la función <code>kill-region</code>, esté dentro de una forma especial <code>condition-case</code>.</p>
<p>La plantilla para <code>condition-case</code> tiene este aspecto:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">condition-case</span>
  <span class="nv">var</span>
  <span class="nv">cuerpo</span>
  <span class="nv">manejador-de-errores</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>El segundo argumento, <code>cuerpo</code> es sencillo. La forma especial <code>condition-case</code> hace que el intérprete Lisp evalúe el código en <code>cuerpo</code>. Si no ocurre ningún error, la forma especial devuelve el valor del código y produce efectos laterales, si los hubiera.</p>
<p>En resumen, la parte <code>cuerpo</code> de una expresión <code>condition-case</code> determina qué deberia suceder cuando todo funciona correctamente.</p>
<p>Sin embargo, si se produce un error, entre sus otras acciones, la función genera la señal de error que define uno o más nombres de condicion de error.</p>
<p>Un manejador de errores es el tercer argumento de <code>condition-case</code>. Un manejador de errores tiene dos partes, un <code>nombre-de-condicion</code> y un <code>cuerpo</code>. Si la parte <code>nombre-de-condicion</code> de un manejador de erroros coincide con un nombre de condicion generado por un error, se ejecuta la parte del <code>cuerpo</code> del manejador de errores.</p>
<p>Como es de esperar, la parte <code>nombre-de-condicion</code> de un manejador de errores puede ser un unico nombre de condicion o una lista de nombres de condición.</p>
<p>Ademas, una expresión <code>condition-case</code> completa puede contener más de un manejador de errores. Cuando se produce un error, se ejecuta el primer manejador aplicable.</p>
<p>Por ultimo, el primer argumento a la expresión <code>condition-case</code>, es el argumento <code>var</code>, en ocaciones esta unido a una variable que contiene información sobre el error. Sin embargo, si este argumento es <code>nil</code>, como es el caso en <code>kill-region</code>, esa información se descarta.</p>
<p>En resumen, en la función <code>kill-region</code>, el código <code>condition-case</code> funciona así:</p>
<pre><code class="example">Si no hay errores, ejecuta solo este codigo
    pero, si hay errores, ejecuta este otro codigo.</code></pre>
</div>
<h4 id="Macro-Lisp" >Macro Lisp</h4>
<div class="hBody-4" >
<p>La parte de la expresión <code>condition-case</code> que se evalúa en la expectativa de que todo va bien si tiene un <code>when</code>. El código utiliza <code>when</code> para determinar si la variable <code>string</code> apunta a texto que existe.</p>
<p>Una expresión <code>when</code> simplemente es una conveniencia de los programadores. Es un <code>if</code> sin la posibilidad de una cláusula else. En tu mente, puedes reemplazar <code>when</code> con <code>if</code> y entender lo que pasa. Eso es lo que hace el intérprete Lisp.</p>
<p>Técnicamente hablando, <code>when</code> es una macro Lisp. Una <dfn>macro</dfn> Lisp te permite definir nuevas construcciones de control y otras caracteristicas del lenguaje. Le indica al intérprete cómo computar otra expresión Lisp que a su vez computa el valor. En este caso, la ‘otra expresión’ es una expresión <code>if</code>.</p>
<p>La definición de la función <code>kill-region</code> también tiene una macro <code>unless</code>; es lo contario de <code>when</code>. La macro <code>unless</code> es un <code>if</code> sin una cláusula <code>then</code>.</p>
<p>Para optener más informacion sobre las macros Lisp, consulta la Seccion <a href="#info:elisp#Macros" >Macros</a> en <em>El Manual de Referencia de Emacs Lisp</em>. El lenguaje de programación C también proporciona macros. Estos son diferentes, pero también útiles.</p>
<p>Respecto a la macro <code>when</code>, en la expresión <code>condition-case</code>, cuando la cadena tiene contenido, se ejecuta otra expresión condicional. Esto es un <code>if</code> tanto con parte <code>then</code> como con una parte <code>else</code>.</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">kill-new</span> <span class="nf">string</span> <span class="no">nil</span> <span class="nv">yank-handler</span><span class="p">))</span>
</pre></div>
<p>La parte <code>then</code> se evalúa si el comando anterior fué otra llamada a <code>kill-region</code>; si no, se evalúa la parte <code>else</code>.</p>
<p><code>yank-handler</code> es un argumento opcional de <code>kill-region</code> que indica a las funciones <code>kill-append</code> y <code>kill-new</code> como tratar con propiedades agregadas al texto, como ‘negrilla’ o ‘cursiva’.</p>
<p><code>last-command</code> es una variable que viene con Emacs y que no hemos visto antes. Normalmente, siempre que se ejecuta una función, Emacs establece el valor de <code>last-command</code> al comando previo.</p>
<p>En este segmento de la definición, la expresión <code>if</code> comprueba si el comando previo fue <code>kill-region</code>. Si lo era,</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
</pre></div>
<p>concatena una copia del texto recien cortado al texto cortado previamente en el anillo de la muerte.</p>
</div>
<h3 id="copy-region-as-kill" ><code>copy-region-as-kill</code></h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> copia una región de texto desde un búffer y (via <code>kill-append</code> o <code>kill-new</code>) lo guarda en el <code>kill-ring</code>.</p>
<p>Si llamas a <code>copy-region-as-kill</code> inmediatamente después de un comando <code>kill-region</code>, Emacs agrega el texto recien copiado al texto previamente copiado. Esto significa traes el texto, lo obtienes todo, tanto esto operacion como de la anterior. Por otro lado, si algún otro comando precede a <code>copy-region-as-kill</code>, la función copia el texto dentro de una entrada separada del anillo de la muerte.</p>
<p>Aquí está el texto completo de la función <code>copy-region-as-kill</code> de la versión 22:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-region-as-kill</span> <span class="p">(</span><span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&quot;Guarda la region como si fuese cortada, pero no la corta.</span>
<span class="s">En el modo Transient Mark, desactiva la marca.</span>
<span class="s">Si ‘interprogram-cut-function’ es no-nil, tambien guarda el texto de una</span>
<span class="s">ventana del sistema corta y pega.&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;r&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">kill-append</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">kill-new</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">transient-mark-mode</span>
      <span class="p">(</span><span class="k">setq</span> <span class="nv">deactivate-mark</span> <span class="no">t</span><span class="p">))</span>
  <span class="no">nil</span><span class="p">)</span>
</pre></div>
<p>Como de costumbre, esta función se puede dividirse en las partes que la componen:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-region-as-kill</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&quot;documentacion…&quot;</span>
  <span class="p">(</span><span class="k">interactive</span> <span class="s">&quot;r&quot;</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</pre></div>
<p>Los argumentos son <code>beg</code> y <code>end</code> y la función es interactiva con <code>&quot;r&quot;</code>, por lo que los dos argumentos deben referirse al inicio y al final de la región. Si has estado leyendo este documento desde el principio, comprenderas que estas partes de una función se estan volviendo una rutina.</p>
<p>La documentación es un poco confusa a menos que se recuerdes que la palabra ‘kill’ tiene un significado diferente al habitual. Los comentarios de ‘Transient Mark’ y <code>interprogram-cut-function</code> explicar ciertos efectos secundarios.</p>
<p>Después de que se ha asignado una marca, un búffer siempre contiene una región. Si lo deseas puedes utilizar el modo Transient Mark para resaltar temporalmente la región. (Nadie quiere resaltar la región todo el tiempo, por lo que el modo Marca Transitoria lo resalta solo en los momentos apropiados. Muchas personas desactivan el modo Transient Mark, por lo que la región nunca se resalta.)</p>
<p>Ademas, un sistema de ventanas permite copiar, cortar y pegar entre programas diferentes. En el sistema X window, por ejemplo, la función <code>interprogram-cut-function</code> es <code>x-select-text</code>, que funciona con el sistema de ventanas equivalente al anillo de la muerte de Emacs.</p>
<p>El cuerpo de la función <code>copy-region-as-kill</code> inicia con una cláusula <code>if</code>. Lo que esta cláusula hace es distinguir entre dos situaciones diferentes: si este comando se ejecuta o no inmediatamente después de un comando <code>kill-region</code> previo. En el primer caso, la nueva región se concatena al texto previamente copiado. De lo contrario, se inserta al inicio del anillo de la muerte como una pieza separada de la pieza de texto anterior.</p>
<p>Las dos ultimas líneas de la función impiden que la región se ilumine si el modo Transient Mark está activo.</p>
<p>El cuerpo de <code>copy-region-as-kill</code> merece una discusión en detalle.</p>
</div>
<h4 id="El-cuerpo-de-copy-region-as-kill" >El cuerpo de <code>copy-region-as-kill</code></h4>
<div class="hBody-4" >
<p>La función <code>copy-region-as-kil</code> funciona de un modo parecido a la función <code>kill-region</code>. Ambas están escritas de manera que dos o más muertes en una fila combinan su texto en una sola entrada. Si traes el texto del anillo de la muerte, se tiene todo en una sola pieza. Ademas, las mertes que matan hacia adelante desde la posición actual del cursor se añaden al final del texto previamente copiado y los comandos que cortan el texto al reves hacia atrás lo añaden al del texto copiado previamente copiado. De este modo, las palabras en el texto permanecen en el orden correcto.</p>
<p>Al igual que <code>kill-region</code>, la función <code>copy-region-as-kill</code> hace uso de la variable <code>last-command</code> que realiza un seguimiento del comando anterior de Emacs.</p>
<p>Normalmente, siempre que se ejecuta una función, Emacs asigna el valor de <code>this-command</code> a la función que se ejecuta (que en este caso sería <code>copy-region-as-kill</code>). Al mismo tiempo, Emacs asigna el valor de <code>last-command</code> al valor previo de <code>this-command</code>.</p>
<p>En la primer parte del cuerpo de la función <code>copy-region-as-kill</code>, una expresión <code>if</code> determina si el valor de <code>last-command</code> es <code>kill-region</code>. Si es así, se evalua la parte then de la expresión <code>if</code>; Utiliza la función <code>kill-append</code> para concatenar el texto copiado en esta llamada a la función con el texto ya en el primer elemento (el <code>car</code> del anillo de la muerte. Por otro lado, si el valor de <code>last-command</code> no es <code>kill-region</code>, entonces la función <code>copy-region-as-kill</code> asigna un nuevo elemento al anillo de la muerte usando la función <code>kill-new</code>.</p>
<p>La expresión <code>if</code> se lee da la siguiente manera; utiliza <code>eq</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
    <span class="c1">;; parte then</span>
    <span class="p">(</span><span class="nv">kill-append</span>  <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">))</span>
  <span class="c1">;; parte else</span>
  <span class="p">(</span><span class="nv">kill-new</span>  <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
</pre></div>
<p>(La función <code>filter-buffer-substring</code> devuelve una subcadena filtrada del búffer, si la hay. Opcionalmente––los argumentos no están aquí, por lo que tampoco se hace––la función puede borrar el texto inicial o devolver el texto sin sus propiedades; esta función es un reemplazo para la antigua función <code>buffer-substring</code>, que vino antes de implementar las propiedades de texto.)</p>
<p>La función <code>eq</code> prueba si su primer argumento es el mismo objeto Lisp que su segundo argumento. La función <code>eq</code> es similar a la función <code>equal</code> en que se utiliza para probar la igualdad, pero difiere en que determina si dos representaciones son realmente el mismo objeto dentro de la computadora, pero con nombres diferentes. <code>equal</code> determina si la estructura y el contenido de dos expresiones son iguales.</p>
<p>Si el comando anterior fue <code>kill-region</code>, entonces el intérprete Emacs Lisp llama a la función <code>kill-append</code></p>
</div>
<h5 id="La-función-kill-append" >La función <code>kill-append</code></h5>
<div class="hBody-5" >
<p>La función <code>kill-new</code> se ve así:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-append</span> <span class="p">(</span><span class="nf">string</span> <span class="nv">before-p</span> <span class="kp">&amp;optional</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="s">&quot;Inserta STRING al fin del ultimo corte en el anillo de la muerte.</span>
<span class="s">Si BEFORE-P no es nil, anexa STRING al corte.</span>
<span class="s">… &quot;</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">cur</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">kill-new</span> <span class="p">(</span><span class="k">if</span> <span class="nv">before-p</span> <span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span> <span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>
              <span class="p">(</span><span class="k">or</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">cur</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">equal</span> <span class="nv">yank-handler</span>
                         <span class="p">(</span><span class="nf">get-text-property</span> <span class="mi">0</span> <span class="ss">&#39;yank-handler</span> <span class="nv">cur</span><span class="p">)))</span>
              <span class="nv">yank-handler</span><span class="p">)))</span>
</pre></div>
<p>La función <code>kill-append</code> es bastante sencilla. Utiliza la función <code>kill-new</code>, que discutiremos con más detalle en un momento.</p>
<p>(También, la función proporciona un argumento opcional llamado <code>yank-handler</code>; cuando se invoque, este argumento le dice a la función cómo tratar con la propiedades añadidas al texto, como ‘negrita’ o ‘cursiva’.)</p>
<p>Tiene una función <code>let*</code> para asignar el valor del primer elemento del anillo de la muerte a <code>cur</code>. (No se por qué la función no utiliza <code>let</code>; solo un valor se asigna en la expresión. ¿Tal vez este es un error que no produce problemas?</p>
<p>Considera el condicional que es uno de los dos argumentos para <code>kill-new</code>. Utiliza <code>concat</code> para concatenar el nuevo texto al <code>car</code> del anillo de la muerte. Si agrega el texto antes o despues depende del resultado una expresión <code>if</code>:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">if</span> <span class="nv">before-p</span>                            <span class="c1">; parte if</span>
    <span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span>                 <span class="c1">; parte then</span>
  <span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>                  <span class="c1">; parte else</span>
</pre></div>
<p>Si la región cortada está antes de la región que se cortó en el último comando, entonces debería ser puesta antes que el material guardado en el corte anterior; y, a la inversa, si el texto que se corto esta despues del que acaba de cortar, debe añadirse después del texto anterior. La expresión <code>if</code> depende del predicado <code>before-p</code> para decidir si el texto recien guardado debe colocarse antes o después del texto anterior.</p>
<p>El símbolo <code>before-p</code> es el nombre de uno de los argumentos a <code>kill-append</code>. Cuando la función <code>kill-append</code> se evalúa, se asocia al valor devuelto evaluando el argumento actual. En este caso, esta es la expresión <code>(&lt; end beg)</code>. Esta expresión no determina directamente si el texto cortado en este comando se localiza antes o después del texto cortado del último comando; lo que hace es determinar si el valor de la variable <code>end</code> es menor que el valor de la variable <code>beg</code>. Si es así, significa que el usuario se encara al principio del búffer. También, el resultado de evaluar la expresión del predicado. <code>(&lt; end beg)</code>, será verdadero y el texto se concatena antes del texto previo. Por otro lado, si el valor de la variable <code>end</code> es mayor que el valor del la variable <code>beg</code>, el texto será concatenado después del texto previo.</p>
<p>Cuando el texto nuevamente guardado se concatena, entonces la cadena con el nuevo texto será concatenado antes del viejo texto:</p>
<pre><code class="example">(concat string cur)</code></pre>
<p>Pero si el texto será añadido, eso será concatenado después del viejo texto:</p>
<pre><code class="example">(concat cur string))</code></pre>
<p>Para comprender cómo funciona esto, primero se necesita revisar la función <code>concat</code>. La función <code>concat</code> enlaza junto o une dos cadenas de texto. El resultado es una cadena. Por ejemplo:</p>
<pre><code class="example">(concat &quot;abc&quot; &quot;def&quot;)
     ⇒ &quot;abcdef&quot;

(concat &quot;nuevo &quot;
        (car '(&quot;primer elemento&quot; &quot;segundo elemento&quot;)))
     ⇒ &quot;nuevo primer elemento&quot;

(concat (car
        '(&quot;primer elemento&quot; &quot;segundo elemento&quot;)) &quot; modificado&quot;)
     ⇒ &quot;primer elemento modificado&quot;</code></pre>
<p>Ahora puede tener sentido <code>kill-append</code>: eso modifica los contenidos del anillo de la muerte <em>kill ring</em>. El anillo de la muerte <em>kill ring</em> es una lista, en la que cada elemento es texto guardado. La función <code>kill-append</code> usa la función <code>kill-new</code> que usa la función <code>setcar</code>.</p>
</div>
<h5 id="La-función-kill-new" >La función <code>kill-new</code></h5>
<div class="hBody-5" >
<p>La función <code>kill-new</code> se ve de esta manera:</p>
<pre><code class="example">(defun kill-new (string &amp;optional replace yank-handler)
  &quot;Crea STRING el último corte en el anillo de la muerte @e{kill
  ring}.
Asigna ‘kill-ring-yank-pointer’ para apuntarlo.

Si ‘interprogram-cut-function’ es no nulo, aplícalo a su
 STRING.
Segundo argumento opcional REPLACE no-nulo significa que STRING
 reemplazará el frente del kill ring, en vez de ser a@~andido a la lista.
…&quot;
  (if (&gt; (length string) 0)
      (if yank-handler
          (put-text-property 0 (length string)
                             'yank-handler yank-handler string))
    (if yank-handler
        (signal 'args-out-of-range
                (list string &quot;yank-handler specified for empty string&quot;))))
  (if (fboundp 'menu-bar-update-yank-menu)
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (push string kill-ring)
    (if (&gt; (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))</code></pre>
<p>(Vea que la función no es interactiva.)</p>
<p>Normalmente, se mira a esta función en partes.</p>
<p>La definición de la función tiene un argumento opcional <code>yank-handler</code>, que cuando se invoca cuenta la función de cómo tratar con propiedades añadidas al texto, tal como ‘negrilla’ o ‘itálica’. Nosotros evitaremos esto.</p>
<p>La primer línea de la documentación tiene sentido:</p>
<pre><code class="example">Crea la CADENA la última copia en el anillo de la muerte @e{kill
ring}.</code></pre>
<p>Permite saltarse el resto de la documentación por el momento.</p>
<p>También, permite salir de la expresión inicial <code>if</code> y estas líneas de código involucrando <code>menu-bar-update-yank-menu</code>. Nosotros explicaremos debajo.</p>
<p>Las líneas críticas son estas:</p>
<pre><code class="example">  (if (and replace kill-ring)
      ;; @e{entonces}
      (setcar kill-ring string)
    ;; @e{resto}
  (push string kill-ring)
    (setq kill-ring (cons string kill-ring))
    (if (&gt; (length kill-ring) kill-ring-max)
        ;; @e{avoid overly long kill ring}
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))</code></pre>
<p>El test condicional es <code>(and replace kill-ring)</code>. Esto será verdad cuando dos condiciones se encuentran: el anillo de la muerte <em>kill ring</em> tiene alguna cosa dentro, y la variable <code>replace</code> es verdad.</p>
<p>Cuando la función <code>kill-append</code> asigna <code>replace</code> para ser cierto y cuando el anillo de la muerte <em>kill ring</em> tiene al menos un ítem en eso, la expresión <code>setcar</code> es ejecutada.</p>
<pre><code class="example">(setcar kill-ring string)</code></pre>
<p>La función <code>setcar</code> actualemten cambia el primer elemento del anillo de la muerte (<code>kill-ring</code> lista al valor de <code>string</code>. Eso reemplaza el primer elemento.</p>
<p>Por otro lado, si el kill ring está vacío, o reemplazar es falso, la else-part de la condición está ejecutado:</p>
<pre><code class="example">(push string kill-ring)</code></pre>
<p><code>push</code> pone su primer argumento dentro del segundo. Es similar al viejo.</p>
<pre><code class="example">(setq kill-ring (cons string kill-ring))</code></pre>
<p>o el nuevo</p>
<pre><code class="example">(add-to-list kill-ring string)</code></pre>
<p>Cuando eso es falso, la expresión primero construye una nueva versión del anillo de la muerte <em>kill ring</em> añadiendo <code>string</code> al anillo de la muerte <em>kill ring</em> como un nuevo elemento (que es lo que <code>push</code> hace). Entonces ejecuta un segundo <code>if</code> cláusula. Este segundo <code>if</code> cláusula guarada el anillo de la muerte <em>kill ring</em> desde el creciente demasiado largo.</p>
<p>Déjanos mirar estas dos expresiones en orden.</p>
<p>La línea <code>push</code> de la parte else asigna el nuevo valor del kill ring <em>anillo de la muerte</em> a que resultados añaden la cadena siendo cortada al viejo anillo de la muerte <em>kill ring</em></p>
<p>Nosotros podemos ver cómo esto funciona con un ejemplo.</p>
<p>Primero,</p>
<pre><code class="example">(setq example-list '(&quot;aqui una clausula&quot; &quot;otra clausula&quot;))</code></pre>
<p>Después de evaluar esta expresión con <kbd>C-x C-e</kbd>, se puede evaluar <code>example-list</code> y mira lo que devuelve:</p>
<pre><code class="example">example-list
     ⇒ (&quot;aquí hay una claúsula&quot; &quot;otra claúsula&quot;)</code></pre>
<p>Ahora, se puede añadir un nuevo elemento en esta lista evaluando la siguiente expresión: @findex push, <em>ejemplo</em></p>
<pre><code class="example">(push &quot;una tercera cláusula&quot; lista-de-ejemplo)</code></pre>
<p>Cuando se evalúa <code>example-list</code>, se encuentra su valor es:</p>
<pre><code class="example">example-list
     ⇒ (&quot;una tercera claúsula&quot; &quot;aquí hay una
     claúsula&quot; &quot;otra claúsula&quot;)</code></pre>
<p>De este modo, la tercera claúsula se añade a la lista con <code>push</code>.</p>
<p>Ahora para la segunda parte de la claúsula <code>if</code>. Esta expresión deja el kill ring desde lo creciente demasiado largo. Eso se ve de la siguiente manera:</p>
<pre><code class="example">(if (&gt; (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))</code></pre>
<p>El código chequea si el tamaño del anillo de la muerte <em>kill ring</em> es más grande que el máximo tamaño permitido. Este es el valor de <code>kill-ring-max</code> (que es 60, por defecto). Si el tamaño del anillo de la muerte <em>kill ring</em> es demasiado largo, entonces este código asigna el último elemento del anillo de la muerte <em>kill ring</em> a <code>nil</code>. Eso hace esto usando dos funciones, <code>nthcdr</code> y <code>setcdr</code>.</p>
<p>Nosotros vemos que <code>setcdr</code> temprano (@pxref{setcdr, , <code>setcdr</code>}). Eso asigna el <code>cdr</code> de una lista, solo como <code>setcar</code> asigna el <code>car</code> de una lista. En este caso, sin embargo, <code>setcdr</code> no estará configurando el <code>cdr</code> del kill ring completo; la función <code>nthcdr</code> es usada para causarlo para asignar el <code>cdr</code> del siguiente al último elemento del kill ring --- esto significa que desde el <code>cdr</code> del siguiente al último elemnto del kill ring <em>anillo de la muerte</em>, eso asignará el último elemento del kill ring <em>anillo de la muerte</em>.</p>
<p>La función <code>nthcdr</code> funciona repetidamente tomando el <code>cdr</code> de una lista––eso toma el <code>cdr</code> del <code>cdr</code> del <code>cdr</code> …. Eso hace esto N veces y devuelve los resultados. (Véase Sección <a href="#nthcdr,-,-nthcdr" >nthcdr, , <code>nthcdr</code></a>.)</p>
<p>De este modo, si teniamos una lista de cuatro elemento que era supuestamente de tres elementos, se podría asignar el <code>cdr</code> del siguiente al último elemento a <code>nil</code>, y por eso se ordena la lista. (Si se asigna el último elemento a algún otro valor a <code>nil</code>, que se podría hacer, entonces no se habría ordenado la lista. Véase Sección <a href="#setcdr,-,-setcdr" >setcdr, , <code>setcdr</code></a>.)</p>
<p>Se puede ver ordenando la evaluación de las siguientes tres expresiones en turno. Primero asigna el valor de <code>arboles</code> a <code>(arce encina pino abedul)</code> entonces asigna el <code>cdr</code> de su segundo <code>cdr</code> y entonces encuentra el valor de <code>arboles</code>.</p>
<pre><code class="example">(setq arboles '(arce encina pino abedul))
     ⇒ (arce encina pino abedul)

(setcdr (nthcdr 2 arboles) nil)
     ⇒ nil

árboles
     ⇒ (arce encina pino)</code></pre>
<p>(El valor devuelto por la expresión <code>setcdr</code> es <code>nil</code> desde que es que el <code>cdr</code> es asignado.)</p>
<p>Para repetir, en <code>kill-new</code>, la función <code>nthcdr</code> toma el <code>cdr</code> un número de veces que es uno menos que el tamaño máximo permitido del anillo de la muerte <em>kill ring</em> y <code>setcdr</code> asigna el <code>cdr</code> de este elemento (que será el resto de los elementos en el anillo muerte) para <code>nil</code>. Esto previene el anillo de la muerte <em>kill ring</em> desde lo que crece demasiado largo.</p>
<p>De la siguiente a la última expresión en la función <code>kill-new</code> es</p>
<pre><code class="example">(setq kill-ring-yank-pointer kill-ring)</code></pre>
<p>El <code>kill-ring-yank-pointer</code> es una variable global que es asignado para ser el <code>kill-ring</code>.</p>
<p>Incluso aunque el <code>kill-ring-yank-pointer</code> es llamado un <samp>puntero</samp>, eso es una variable solo como el anillo de la muerte <em>kill ring</em>. Sin embargo, el nombre que ha sido elegido para ayudar a humanos a comprender cómo la variable se usa.</p>
<p>Ahora, para devolver rápido una expresión en el cuerpo de la función:</p>
<pre><code class="example">  (if (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))</code></pre>
<p>Empieza con una expresión <code>if</code></p>
<p>En este caso, la expresión chequea primero si <code>menu-bar-update-yank-menu</code> existe como una función, y si así, se llama. La función <code>fboundp</code> devuelve cierto si el símbolo que se chequea tiene una definición de función que ‘no es vacía’. Si el símbolo de la definición de función fuera vacío, recibiría un mensaje de error, como se hizo cuando se crearon errores intencionalmente (@pxref{Creando errores, , Genera un Mensaje de Error}).</p>
<p>La then-part contiene una expresión cuyo primer elemento es la función <code>and</code>.</p>
<p>La forma especial <code>and</code> evalúa cada uno de sus argumentos hasta que uno de los argumentos devuelva un valor de <code>nil</code>, en cuyo caso la expresión <code>and</code> devuelve <code>nil</code>; sin embargo, si ninguno de los argumentos devuelve una valor de <code>nil</code>, el valor resultante desde la evaluación el último argumento es devuelto. (Desde que tal valor no es <code>nil</code>, eso es considerado cierto en Emacs Lisp.) En otras palabras, una expresión <code>and</code> devuelve un valor cierto solo si todos sus argumentos son verdaderos. (Véase Sección <a href="#Repaso-2" >Revisar el segundo búffer relacionado</a>.)</p>
<p>La expresión determina si el segundo argumento <code>menu-bar-update-yank-menu</code> es verdadero o no.</p>
<p><code>menu-bar-update-yank-menu</code> es una de la funciones que lo hace posible para usar el menu ‘Seleccionar y Pegar’ en el ítem Editar de una barra de menu; usando un ratón, se pueden mirar varias piezas de texto que se han guardado y se selecciona una pieza para pegar.</p>
<p>La última expresión en la función <code>kill-new</code> añade las cadenas nuevamente copiadas a aquella facilidad que existe copiando y pegando entre diferentes programas ejecutando un sistema de ventanas. En el Sistema de Ventanas de X, por ejemplo, la función <code>x-select-text</code> toma la cadena y la almacena en memoria operada por X@. Se puede pegar la cadena en otro programa, tal como un Xterm.</p>
<p>La expresión se ve como:</p>
<pre><code class="example">  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))</code></pre>
<p>Si <code>interprogram-cut-function</code> existe, entonces Emacs ejecuta <code>funcall</code>, que en vez de llamar a su primer argumento como una función, pasa los argumentos que permanecen en eso. (Incidentalmente, tan lejos como se puede ver, esta expresión <code>if</code> podría ser reemplazado por una expresión <code>and</code> similar a uno en la primera parte de la función.)</p>
<p>Estamos yendo a discutir sistemas de ventanas y otros programas más allá pero meramente nota que este es un mecanismo que habilita GNU Emacs a trabajar fácilmente y bien con otros programas.</p>
<p>Este código para emplazar texot en el anillo de la muerte <em>kill ring</em>, concatenado con un elemento existente o como un nuevo elemento, nos lidera al código para traer texto que ha sido cortado del búffer––los comandos de corte. Sin embargo, antes de discutir los comandos de corte, es mejor aprender cómo las listas son implementadas en un ordenador. Esto dejará claro tales misterios como el uso del término ‘puntero’. Pero antes de esto, nos desviaremos a C.</p>
</div>
<h3 id="Disgresión-dentro-de-C" >Disgresión dentro de C</h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> (@pxref{copy-region-as-kill, , <code>copy-region-as-kill</code>}) usa la función <code>filter-buffer-substring</code>, que en vez de eso usa la función <code>delete-and-extract-region</code>. Eso elimina los contenidos de una región y no se puede volverlos a tener.</p>
<p>Al contrario que el otro código discutido aquí, la función <code>delete-and-extract-region</code> no está escrita en Emacs Lisp; eso está escrito en C y es una de las primitivas del sistema GNU Emacs. Puesto que es muy simple, se hará la disgresión brevemente desde el Lisp y se describe aquí.</p>
<p>Como muchas de las otras primitivas Emacs, <code>delete-and-extract-region</code> se escribe como una instancia de una macro C, una macro es una plantilla para codificar. La macro completa se parece a esto:</p>
<pre><code class="example">DEFUN (&quot;delete-and-extract-region&quot;, Fdelete_and_extract_region,
       Sdelete_and_extract_region, 2, 2, 0,
       doc: /* Borra el texto entre START y END y lo devuelve.  */)
       (Lisp_Object start, Lisp_Object end)
{
  validate_region (&amp;start, &amp;end);
  if (XINT (start) == XINT (end))
    return empty_unibyte_string;
  return del_range_1 (XINT (start), XINT (end), 1, 1);
}</code></pre>
<p>Sin ir dentro de los detalles de la macro que escribe el proceso, se hará un apunte de esta macro que empieza con la palabra <code>DEFUN</code>. La palabra <code>DEFUN</code> fué elegida puesto que el código sirve para el mismo propósito que <code>defun</code> hace en Lisp. (La macro C <code>DEFUN</code> definida en <span class="file" >emacs/src/lisp.h</span>.)</p>
<p>El palabra <code>DEFUN</code> tiene siete partes dentro de los paréntesis:</p>
<ul>
<li><p>La primera parte es el nombre dado a la función en Lisp, <code>delete-and-extract-region</code>.</p>
</li>
<li><p>La segunda parte es el nombre de la función en C, <code>Fdelete_and_extract_region</code>. Por convención, eso empieza con <samp>F</samp>. Puesto que C no usa guiones en nombres, los guiones bajos son usados a su vez.</p>
</li>
<li><p>La tercera parte es el nombre para la estructura constante C que registra información en esta función para uso interno. Es el nombre de la función en C pero empieza con una <samp>S</samp> en vez de una <samp>F</samp>.</p>
</li>
<li><p>Las partes cuarta y quinta especifican el número mínimo y máximo de argumentos que la función puede tener. Esta función demanda exactamente 2 argumentos.</p>
</li>
<li><p>La sexta parte está cerca del argumento que sigue la declaración <code>interactive</code> en una función escrita en Lisp: una carta seguida, quizás, por una consola. La única diferencia con Lisp es que si la macro se llama sin argumentos. Entonces se escribe un <code>0</code> (que es una ‘cadena nula’), como en esta macro.</p>
<p>Si se fueran a especificar argumentos, se emplazarían entre marcas de comillas. La macro C para <code>goto-char</code> incluye <code>\&quot;NGoto char \&quot;</code> en esta posición se indica que la función espera un prefijo plano, en este caso, una localización numérica en un búffer, y provee una consola.</p>
</li>
<li><p>La séptima parte es una cadena de documentación, solo como la única para una función escrita en Emacs Lisp. Esto es escrito como un comentario C. (Cuando se escribe Emacs, el programa @command{lib-src/make-docfile} extrae estos comentarios y los usa para crear la documentación “real”.)</p>
</li>
</ul>
<p>En una macro C, los parámetros son los siguientes, con una frase de este tipo de objeto se siguen por lo que podría ser llamado el ‘cuerpo’ de la macro. Para <code>delete-and-extract-region</code> el ‘cuerpo’ consiste de las siguientes cuatro líneas:</p>
<pre><code class="example">validate_region (&amp;start, &amp;end);
if (XINT (start) == XINT (end))
  return build_string (&quot;&quot;);
return del_range_1 (XINT (start), XINT (end), 1, 1);</code></pre>
<p>La función <code>validate_region</code> chequea si los valores pasados como el principio y fin de la región son el tipo apropiado y son del mismo rango. Si las posiciones del principio y fin son las mismas, entonces se devuelve una cadena vacía.</p>
<p>La función <code>del_range_1</code> actualmente borra el texto. Eso es una función compleja que no miraremos. Eso actualiza el búffer y hace otras cosas. Sin embargo, es el valorable mirar los dos argumentos pasados para <code>del_range</code>. Estos son <code>XINT (start)</code> y <code>XINT (end)</code>.</p>
<p>Tan lejos como el lenguaje C es concebido, <code>start</code> y <code>end</code> son dos enteros que marcan el principio y el fin de la región para ser borrada<span class="note" ><sup><a href="#10" >10</a></sup></span>.</p>
<p>En las primeras versiones de Emacs, estos dos números fueron 32 bits de longitud, pero el código está lentamente siendo generalizado para manejar otras longitudes. Tres de los bits disponibles son usados para especificar el tipo de información; los bits permanecen ser usados como ‘contenido’.</p>
<p><samp>XINT</samp> es una macro C que extrae los números relevantes desde la colección larga de bits; los otros tres bits se descartan.</p>
<p>El comando en <code>delete-and-extract-region</code> se parece a esto:</p>
<pre><code class="example">del_range_1 (XINT (start), XINT (end), 1, 1);</code></pre>
<p>Esto borra la región entre la posición del principio, <code>start</code>, y la posición final, <code>end</code>.</p>
<p>Desde el punto de vista de la persona que escribe Lisp, Emacs es muy simple; pero oculta en el fondo un gran trato de complejidad para hacer todo el trabajo.</p>
</div>
<h3 id="Inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> es escrita en Emacs Lisp. Dos funciones con eso, <code>kill-append</code> y <code>kill-new</code>, copiar una región en un búffer y guardarlo en una variable llamada el <code>kill-ring</code>. Esta sección describe cómo la variable <code>kill-ring</code> es creada e inicializada usando la forma especial <code>defvar</code>.</p>
<p>(De nuevo se nota que el término <code>kill-ring</code> es un sin nombre. El texto que es cortado fuera del búffer puede ser traido; eso no es un corpus de anillo, pero un anillo de texto resucitable.)</p>
<p>En Emacs Lisp, una variable tal como <code>kill-ring</code> es creada y dada por un valor inicial usando la forma especial <code>defvar</code>. El nombre viene de “definir variable”.</p>
<p>La forma especial <code>defvar</code> es similar a <code>setq</code> en este se configura el valor de una variable. Eso no es <code>setq</code> en dos modos; primero solo configura el valor de la variable si la variable no tiene ya un valor. Si la variable ya tiene un valor, <code>defvar</code> no sobreescribe el valor existente. Segundo, <code>defvar</code> tiene una cadena de documentación.</p>
<p>(Otra forma especial, <code>defcustom</code>, está diseñado para variables que la gente personaliza. Eso tiene más funcionalidades que <code>defvar</code>. (Véase Sección <a href="#Especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>.)</p>
<p>Se puede ver el actual valor de una variable, cualquier variable, usando la función <code>describe-variable</code>, que es normalmente invocado escribiendo <kbd>C-h v</kbd>. Si se escribe <kbd>C-h v</kbd> y <code>kill-ring</code> (seguido por <kbd>RET</kbd>), se verá que hay en tu anillo de la muerte actual <em>kill ring</em> al ser pulsado --- ¡esto puede ser bastante tranquilo! A la inversa, si no has estado haciendo nada esta sesión en Emacs, excepto leer este documento, se puede no tener nada dentro. También, se verá la documentación para <code>kill-ring</code>:</p>
<pre><code class="example">Documentación:
Lista de secuencias de texto muerto (guardado).
Desde que el (kill ring) se supone que interactua bien con
cut-and-paste facilita ofrecer por sistemas de ventanas,
debería usar esta variable
interactúa bin con ‘interprogram-cut-function’ y
‘interprogram-paste-function’. Las funciones ‘kill-new’,
‘kill-append’, y ‘current-kill’ se suponen para implementar esta
interacción; se puede querer usarlo en vez de manipular en anillo de
la muerte @e{kill ring} directamente.</code></pre>
<p>El kill ring <em>anillo de la muerte</em> está definido por un <code>defvar</code> del siguiente modo:</p>
<pre><code class="example">(defvar kill-ring nil
  &quot;Lista de secuencia de textos cortados.
…&quot;)</code></pre>
<p>En esta definición de variable, la variable es dada un valor inicial de <code>nil</code>, que tiene sentido, desde que si no se ha guardado nada, no se quiere nada si se da un comando <code>yank</code>. La cadena de documentación es escrito solo como la cadena de documentación de un <code>defun</code>. Como con la cadena de documentación sería una frase completa, desde que algunos comandos, como <code>apropos</code>, imprime solo la primera línea de documentación. Las líneas de exito no serían indentadas; de otro modo se mira cuando se usa <kbd>C-h v</kbd> (<code>describe-variable</code>).</p>
</div>
<h4 id="defvar-y-un-asterisco" ><code>defvar</code> y un asterisco</h4>
<div class="hBody-4" >
<p>En el pasado, Emacs usaba la forma especial <code>defvar</code> tanto para variables interna que no esperaría que un usuario cambie y para variables que espera un usuario cambie. Aunque se puede todavía usar <code>defvar</code> para variables personalizadas, por favor, usa <code>defcustom</code> en vez, desde que la forma especial provee una ruta dentro de los comando de Personalización. (Véase Sección <a href="#Especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>.)</p>
<p>Cuando se especifica una variable usando la forma especial <code>defvar</code>, se podría distinguir una variable que un usuario podría querer cambiar desde otros escribiendo, <samp>*</samp>, en la primera columna de su cadena de documentación. Por ejemplo:</p>
<pre><code class="example">(defvar shell-command-default-error-buffer nil
  &quot;*Nombre de buffer para ‘shell-command’ … salir del error.
… &quot;)</code></pre>
<p>Tu podrías (y todavía puedes) usar el comando <code>set-variable</code> para cambiar el valor de <code>shell-command-default-error-buffer</code> temporalmente. Sin embargo, las opciones configuradas usando <code>set-variable</code> no están asignadas solo por la duración de tu sesión de edición. Los nuevos valores no están guardados entre sesiones. Cada vez que Emacs empieza, lee el valor original, a menos que tu cambia el valor con tu fichero <span class="file" >.emacs</span>, si configurándolo manualmente o usando <code>customize</code>. Véase Sección <a href="#Tu-Fichero-.emacs" >Tu Fichero <span class="file" >.emacs</span></a>.</p>
<p>Para mí, el mayor uso del comando <code>set-variable</code> es sugerir variables que se podrían querer asignar en mi fichero <span class="file" >.emacs</span>. Ahora hay más de 700 variables, demasiadas para recordarlas fácilmente. Afortunadamente, se puede presionar <kbd>TAB</kbd> después de llamar al comando <code>M-x set-variable</code> para ver la lista de variables. (Véase Sección &quot;Examinando y Configurando Variables&quot; en <em>El Manual de GNU Emacs</em>.)</p>
</div>
<h3 id="Repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí hay un breve resumen de algunas funciones introducidas recientemente.</p>
<dl>
<dt><p>car</p>
</dt>
<dd><p>cdr ::</p>
<p><code>car</code> devuelve el primer elemento de una lista; <code>cdr</code> devuelve el segundo y subsiguientes elementos de una lista.</p>
<p>Por ejemplo:</p>
<pre><code class="example">(car '(1 2 3 4 5 6 7))
     ⇒ 1
(cdr '(1 2 3 4 5 6 7))
     ⇒ (2 3 4 5 6 7)</code></pre>
</dd>
<dt><p>cons</p>
</dt>
<dd><p><code>cons</code> construye una lista enlazando su primer argumento a su segundo argumento.</p>
<p>Por ejemplo:</p>
<pre><code class="example">(cons 1 '(2 3 4))
     ⇒ (1 2 3 4)</code></pre>
</dd>
<dt><p>funcall</p>
</dt>
<dd><p><code>funcall</code> evalúa su primer argumento como una función. Así pasa los argumentos que permanecen a su primer argumento.</p>
</dd>
<dt><p>nthcdr</p>
</dt>
<dd><p>Devuelve el resultado de tomar <code>cdr</code> ‘n’ veces en una lista.  The <span class="math" >n^{th}</span> <code>cdr</code>. El ‘resto del resto’, como estaba</p>
<p>Por ejemplo:</p>
<pre><code class="example">(nthcdr 3 '(1 2 3 4 5 6 7))
     ⇒ (4 5 6 7)</code></pre>
</dd>
<dt><p>setcar</p>
</dt>
<dd><p>setcdr ::</p>
<p><code>setcar</code> cambia el primer elemento de una lista; <code>setcdr</code> cambia el segundo y subsiguiente elementos de una lista.</p>
<p>Por ejemplo:</p>
<pre><code class="example">(setq triple '(1 2 3))

(setcar triple '37)

triple
     ⇒ (37 2 3)

(setcdr triple '(&quot;foo&quot; &quot;bar&quot;))

triple
     ⇒ (37 &quot;foo&quot; &quot;bar&quot;)</code></pre>
</dd>
<dt><p>progn</p>
</dt>
<dd><p>Evalúa cada argumento en secuencia y entonces devuelve el valor del último.</p>
<p>Por ejemplo:</p>
<pre><code class="example">(progn 1 2 3 4)
     ⇒ 4</code></pre>
</dd>
<dt><p>save-restriction</p>
</dt>
<dd><p>Graba siempre que encoger esté en efecto en el búffer, si cualquiera, restaura este encogimiento después de evaluar los argumentos.</p>
</dd>
<dt><p>search-forward</p>
</dt>
<dd><p>Buscar una cadena, y si la cadena es encontrada, mueve el punto. Con una expresión regular, usa algo similar a <code>re-search-forward</code>. (Véase Sección <a href="#Búsquedas-de-Expresiones-Regulares" >Búsquedas de Expresiones Regulares</a>, para una explicación de expresiones regulares patrones y búsquedas.)</p>
<p><code>search-forward</code> y <code>re-search-forward</code> tiene cuatro argumentos:</p>
<ol>
<li><p>La cadena o la expresión regular para buscar.</p>
</li>
<li><p>Opcionalmente, el límite de la búsqueda.</p>
</li>
<li><p>Opcionalmente, que haces si la búsqueda falla, devuelve <code>nil</code> o un mensaje de error.</p>
</li>
<li><p>Opcionalmente, cuántas veces se puede repetir la búsqueda; si es negativa, la búsqueda va hacia atrás.</p>
</li>
</ol>
</dd>
<dt><p>kill-region</p>
</dt>
<dd><p>delete-and-extract-region :: copy-region-as-kill       ::</p>
<p><code>kill-region</code> corta el texto entre punto y marca desde el búffer y almacena ese texto en el anillo de la muerte <em>kill ring</em>, así se puede obtener pegándolo.</p>
<p><code>copy-region-as-kill</code> copia el texto entre punto y marca dentro del anillo de la muerte <em>kill ring</em>, que se puede obtener pegándolo. La función no corta o borra el texto desde el búffer.</p>
</dd>
</dl>
<p><code>delete-and-extract-region</code> elimina el texto entre el punto y marca desde el búffer y a través. No se puede volver. Esto no es un comando interactivo.)</p>
</div>
<h3 id="Buscando-ejercicios" >Buscando ejercicios</h3>
<div class="hBody-3" >
<ul>
<li><p>Escribe una función interactiva que busca una cadena. Si la búsqueda encuentra la cadena, deja el punto después y muestra un mensaje que dice “¡Encontrado!”. (No use <code>search-forward</code> como nombre de esta función; si se hace, se sobreescribirá la versión existente <code>search-forward</code> que viene con Emacs. Use un nombre tal como <code>test-search</code> en vez de eso.</p>
</li>
<li><p>Escribe una función que imprime el tercer elemento del kill ring <em>anillo de la muerte</em> en el área echo, si cualquiera; si el kill ring <em>anillo de la muerte</em> no contiene un tercer elemento, imprime un mensaje apropiado.</p>
</li>
</ul>
</div>
<h2 id="Cómo-se-implementan-las-listas" >Cómo se implementan las listas</h2>
<div class="hBody-2" >
<p>En Lisp, los átomos se graban de manera simple, si la implementación no es sencilla en la práctica, no es, nada sencilla en la teoría. El átomo <samp>rosa</samp>, por ejemplo, se graba como las cuatro letras contiguas <samp>r</samp>, <samp>o</samp>, <samp>s</samp>, <samp>a</samp>. Una lista, por otro lado, se guarda de manera diferente. El mecanismo es igualmente simple, pero toma un momento para tener usada la idea. Una lista se guarda usando una serie de pares de punteros. En las series, el primer puntero en cada par de puntos a un átomo o a otra lista, y el segundo puntero en cada par al siguiente par, o al símbolo <code>nil</code>, que marca el fin de la lista.</p>
<p>Un puntero por sí mismo es poco simple a la dirección electrónica de la que está apuntada. Aquí, una lista se guarda como una serie de direcciones electrónicas.</p>
<p>Por ejemplo, la lista <code>(rosa violeta tulipan)</code> tiene tres elementos, <samp>rosa</samp>, <samp>violeta</samp>, y <samp>tulipan</samp>. En el ordenador, la dirección electrónica de <samp>rosa</samp> se graba en un segmento de memoria del ordenador a través de la dirección que da la dirección electrónica de donde el átomo <samp>violeta</samp> está localizado; y esta dirección (la que cuenta donde <samp>violeta</samp> está se localiza) se guarda con una dirección que cuenta donde la dirección para el átomo <samp>tulipan</samp> se localiza.</p>
<p>Esto parece más complicado de lo que es y es más fácil visto en un diagrama:</p>
<pre><code class="example">    ___ ___      ___ ___      ___ ___
   |___|___|--&gt; |___|___|--&gt; |___|___|--&gt; nil
     |            |            |
     |            |            |
     ---&gt; rosa    ---&gt; violeta ---&gt; tulipan</code></pre>
<p>En el diagrama, cada caja representa una palabra de memoria del ordenador que maneja un objeto Lisp, normalmente en la forma de una dirección de memoria. Las cajas, por ej. las direcciones, están en pares. Cada flecha apunta a lo que la dirección es la dirección de, si un átomo u otro par de direcciones. La primera caja es la dirección electrónica de <samp>rosa</samp> y la flecha apunta a <samp>rosa</samp>; la segunda caja es la dirección del siguiente par de cajas, la primera parte de la que es la dirección de <samp>violeta</samp> y la segunda parte es la dirección del siguiente par. La última caja apunta al símbolo <code>nil</code>, que marca el fin de la lista.</p>
<p>Cuando una variable es configurado a una lista con una función tal como <code>setq</code>, almacena la dirección de la primera caja en la variable. De este modo, la evaluación de la expresión es:</p>
<pre><code class="example">(setq ramo '(rosa violeta tulipan))</code></pre>
<p>crea una situación como esta:</p>
<pre><code class="example">ramo
     |
     |     ___ ___      ___ ___      ___ ___
      --&gt; |___|___|--&gt; |___|___|--&gt; |___|___|--&gt; nil
            |            |            |
            |            |            |
             --&gt; rosa     --&gt; violeta   --&gt; tulipan</code></pre>
<p>En este ejemplo, el símbolo <code>ramo</code> maneja la dirección del primer par de cajas.</p>
<p>Esta misma lista puede ser ilustrada en un modo diferente de anotación de cajas como esta:</p>
<pre><code class="example">ramo
 |
 |    --------------       ----------------       --------------------
 |   | car   | cdr  |     | car     | cdr  |     | car         | cdr  |
  --&gt;| rosa  |   o-------&gt;| violeta |   o-------&gt;| tulipan  | nil  |
     |       |      |     |         |      |     |             |      |
      --------------       ----------------       --------------------</code></pre>
<p>(Los símbolos consisten de más pares de direcciones, pero la estructura de un símbolo es hecha de direcciones. De manera profunda, el símbolo <code>ramo</code> consiste de un grupo de cajas-de-direcciones, una que es la dirección de la palabra impresa <samp>ramo</samp>, una segunda de la que es la dirección de una definición de función adjunta al símbolo, si cualquiera, un tercero del que es la dirección del primer par de cajas-de-direccion para la lista <code>(rosa violeta tulipan)</code>, y así. Aquí se está mostrando que la tercera caja de dirección del símbolo apunta al primer par de cajas-de-direccion para la lista.)</p>
<p>Si un símbolo se asigna al <code>cdr</code> de una lista, la lista en sí no cambia; el símbolo simplemente tiene una dirección abajo de la lista. (En la jerga, <code>car</code> y <code>cdr</code> son ‘no destructivos’.) De este modo, se evalúa la siguiente expresión</p>
<pre><code class="example">(setq flores (cdr ramo))</code></pre>
<p>produce esto:</p>
<pre><code class="example">ramo        flores
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --&gt; |   |   |  --&gt; |   |   |    |   |   |
       |___|___|----&gt; |___|___|--&gt; |___|___|--&gt; nil
         |              |            |
         |              |            |
          --&gt; rosa       --&gt; violeta  --&gt; tulipan</code></pre>
<p>El valor de <code>flores</code> es <code>(violeta tulipan)</code>, esto es decir que el símbolo <code>flores</code> maneja la dirección del par address-boxes el primero que maneja la dirección de <code>violeta</code>, y el segundo que maneja la dirección de <code>tulipan</code>.</p>
<p>Un par de cajas-de-direcciones se llama una <dfn>cons cell</dfn> o <dfn>par de puntos</dfn>. Véase Sección &quot;la Célula Cons y los Tipos Lista&quot; en <em>El Manual de Referencia de Emacs Lisp</em>, y <cite>Notación de Pares de Puntos</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información acerca de células cons y pares de puntos.</p>
<p>La función <code>cons</code> añade un nuevo par de direcciones al frente de una serie de direcciones como son mostradas debajo. Por ejemplo, evaluando la expresión</p>
<pre><code class="example">(setq ramo (cons 'lila ramo))</code></pre>
<p>produce:</p>
<pre><code class="example">ramo                       flores
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --&gt; |   |   |      |   |   |  --&gt; |   |   |     |   |   |
       |___|___|----&gt; |___|___|----&gt; |___|___|----&gt;|___|___|--&gt; nil
         |              |              |             |
         |              |              |             |
          --&gt; lila      --&gt; rosa       --&gt; violeta    --&gt; tulipan</code></pre>
<p>Sin embargo, esto no cambia el valor del símbolo <code>flores</code>, así puedes ver evaluando lo siguiente,</p>
<pre><code class="example">(eq (cdr (cdr ramo)) flores)</code></pre>
<p>que devuelve <code>t</code> para verdad.</p>
<p>Hasta que se resetea, <code>flores</code> todavía tiene el valor de <code>(violeta tulipan)</code>; que es, eso tiene la dirección de la celula cons cuya primera dirección es <code>violeta</code>. También, esto no altera cualquier célula prexistente cons; ellas está todavía allí.</p>
<p>De este modo, en Lisp, tiene el <code>cdr</code> de una lista, se obtiene la dirección del siguiente cons en las serie; para tener el <code>car</code> de una lista, se obtiene la dirección del primer elemento de la lista; para <code>cons</code> un nuevo elemento en una lista, se añade una nueva célula cons al frente de la lista. ¡Esto es todo lo que hay así! ¡La estructura subyacente de Lisp es brillantemente simple!</p>
<p>¿Y qué hace la última dirección en una serie de células cons se refieren? Eso es la dirección de la lista vacía, de <code>nil</code>.</p>
<p>En resumen, cuando una variable Lisp es asignada a un valor, eso provee con la dirección de la lista a la que la variable se refiere.</p>
</div>
<h3 id="Símbolos-como-una-caja-con-cajones" >Símbolos como una caja con cajones</h3>
<div class="hBody-3" >
<p>En una sección temprana, se sugería que se podría imaginar un símbolo siendo una caja con cajones. La definición de función se pone en un cajón, el valor en otro, y así. Lo que se pone en el cajón maneja el valor que puede cambiarse sin afectar a los contenidos del cajón manejando la definición de función, y viceversa.</p>
<p>Actualmente, lo que está puesto en cada cajón es la dirección del valor o definición de función. Eso es como si se encontrara un viejo cajón en el ático, y en uno de sus cajones se encontrara un mapa dándote direcciones a donde está el tesoro escondido.</p>
<p>(Además de su nombre, la definición del símbolo, y un valor de la variable, un símbolo tiene un ‘cajón’ para una <dfn>lista de propiedades</dfn> que puede ser usada para grabar otra información. Las listas de propiedades no se discuten aquí; ver <a href="Listas-de-Propiedades,-,-Listas-de-Propiedades,-elisp,-El-Manual-de-Referencia-de-Emacs-Lisp" >Listas de Propiedades, , Listas de Propiedades, elisp, El Manual de Referencia de Emacs Lisp</a>.)</p>
<p>Aquí hay una representación visionaria:</p>
<pre><code class="example">            Caja de Cajones            Contenidos de Cajones

            __   o0O0o   __
          /                 \
         ---------------------
        |    direcciones al   |            [mapeo a]
        | nombre del simbolo  |            ramo
        |                     |
        +---------------------+
        |  direcciones a la   |
        |   definición del    |            [nunca]
        |    simbolo          |
        +---------------------+
        |    direcciones al   |            [mapeo a]
        |   valor de variable |            (rosa violeta tulipan)
        |                     |
        +---------------------+
        |    direcciones a la |
        |lista de propiedades |            [no descrito aquí]
        |                     |
        +---------------------+
        |/                   \|</code></pre>
</div>
<h3 id="Ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Asignar <code>flores</code> a <code>violeta</code> y <code>tulipan</code>. Asigna dos flores más en esta lista y asigna esta nueva lista a <code>mas-flores</code>. Asigna el <code>car</code> de <code>flores</code> a un pez. ¿Qué lista contiene ahora <code>mas-flores</code>?</p>
</div>
<h2 id="Pegando-texto" >Pegando texto</h2>
<div class="hBody-2" >
<p>Siempre y cuando se corta texto fuera de un búffer con un comando `kill’ en GNU Emacs, se puede traer con un comando ‘pegar’. El texto cortado del búffer es puesto en el anillo de la muerte y en los comandos pegar, se insertan los contenidos apropiados del kill ring detrás de un búffer (no necesariamente el búffer original).</p>
<p>Un simple comando <kbd>C-y</kbd> (<code>yank</code>) inserta el primer ítem desde el anillo de la muerte <em>kill ring</em> dentro del actual búffer. Si el comando <kbd>C-y</kbd> es seguido inmediatamente para <kbd>M-y</kbd>, el primer elemento se reemplaza por el segundo elemento. Los sucesivos comandos <kbd>M-y</kbd> reemplazan el segundo elemento con el tercer, cuarto, o quinto elemento, y así. Cuando se llega al último elemento en el anillo de la muerte <em>kill ring</em>, se reemplaza por el primer elemento y el ciclo se repite. (De este modo, el kill ring se llama un ‘anillo’ en vez de solo una ‘lista’. Sin embargo, la estructura de de datos actual que maneja el texto es una lista. Véase Sección <a href="Qué-hace-el-anillo-de-la-muerte,-,-Manejando-el-anillo-de-la-muerte-kill-ring" >Qué hace el anillo de la muerte, , Manejando el anillo de la muerte <em>kill ring</em></a>, para los detalles de cómo la lista es manejada como un anillo.)</p>
</div>
<h3 id="Resumen-del-anillo-de-la-muerte" >Resumen del anillo de la muerte</h3>
<div class="hBody-3" >
<p>El anillo de la muerte <em>kill ring</em> es una lista de cadenas textuales. Esto es lo que se ve:</p>
<pre><code class="example">(&quot;algún texto&quot; &quot;una pieza diferente pieza de texto&quot;
&quot;todavía más texto&quot;)</code></pre>
<p>Si estos fueran los contenidos de mi anillo de la muerte <em>kill ring</em> y yo presionara <kbd>C-y</kbd>, la cadena de caracteres diciendo <samp>algún texto</samp> sería insertado en este búffer donde mi cursor está localizado.</p>
<p>El comando <code>yank</code> <em>pegar</em> es también usado para duplicar texto copiándolo. El texto copiado no es cortado desde el búffer, pero una copia de eso se pone en el anillo de la muerte <em>kill ring</em> y se inserta pegándolo.</p>
<p>Tres funciones se usan para atraer texto desde el anillo de la muerte <em>kill ring</em>: <code>yank</code> (<em>pegar</em>), que normalmente se asocian a <kbd>C-y</kbd>; <code>yank-pop</code>, que normalmente se asocia a <kbd>M-y</kbd>; y <code>rotate-yank-pointer</code>, que se usa por las otras dos funciones.</p>
<p>Estas funciones se refieren al kill ring <em>anillo de la muerte</em> a través de una variable llamada el <code>kill-ring-yank-pointer</code>. En vez de eso, la inserción del código para ambos son las funciones <code>yank</code> y <code>yank-pop</code>:</p>
<pre><code class="example">(insert (car kill-ring-yank-pointer))</code></pre>
<p>(Bien, no más. En GNU Emacs 22, la función se ha reemplazado por <code>insert-for-yank</code> que llama a <code>insert-for-yank-1</code> repetitivamente para cada segmento <code>yank-handler</code>. En vez de eso, <code>insert-for-yank-1</code> destituye las propiedades de texto desde el texto insertado de acuerdo a <code>yank-excluded-properties</code>. De otro modo, eso es como <code>insert</code>. Nosotros lo pegamos con un <code>insert</code> plano puesto que sea fácil de comprender.)</p>
<p>Para empezar a comprender cómo <code>yank</code> y <code>yank-pop</code> funcionan, primero es necesario mirar en la variable <code>kill-ring-yank-pointer</code>.</p>
</div>
<h3 id="La-variable-kill-ring-yank-pointer" >La variable <code>kill-ring-yank-pointer</code></h3>
<div class="hBody-3" >
<p><code>kill-ring-yank-pointer</code> es una variable, solo como <code>kill-ring</code> es una variable. Eso apunta a alguna cosa siendo asignada al valor de lo que apunta, como cualquier otra variable Lisp.</p>
<p>De este modo, si el valor del kill ring es:</p>
<pre><code class="example">(&quot;algún texto&quot; &quot;una pieza diferente pieza de texto&quot;
&quot;todavía más texto&quot;)</code></pre>
<p>y el <code>kill-ring-yank-pointer</code> apunta a la segunda cláusula, el valor de <code>kill-ring-yank-pointer</code> es:</p>
<pre><code class="example">(&quot;una pieza diferente de texto&quot; &quot;todavía más texto&quot;)</code></pre>
<p>Como se explica en el capítulo previo (Véase Sección <a href="Cómo-se-implementan-las-listas" >Cómo se implementan las listas</a>), el ordenador no guarda dos copias diferentes del texto siendo apuntado por ambos el <code>kill-ring</code> (el <em>anillo de la muerte</em>) y el <code>kill-ring-yank-pointer</code> (el <em>puntero de pegar el anillo de la muerte</em>). Las palabras “una pieza diferente de texto” y “todavía más texto” no están duplicadas. En vez de eso, las dos variables Lisp apuntan a las mismas piezas de texto. Aquí hay un diagrama:</p>
<pre><code class="example">kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---&gt; |   |   |  --&gt; |   |   |    |   |   |
          |___|___|----&gt; |___|___|--&gt; |___|___|--&gt; nil
            |              |            |
            |              |            |
            |              |             --&gt; &quot;todavía más texto&quot;
            |              |
            |               --&gt; &quot;una pieza diferente de texto&quot;
            |
             --&gt; &quot;algo de texto&quot;</code></pre>
<p>Tanto la variable <code>kill-ring</code> y la variable <code>kill-ring-yank-pointer</code> son punteros. Pero el kill ring <em>anillo de la muerte</em> en sí es normalmente descrito como si fuera actualmente de lo que está compuesto. El <code>kill-ring</code> se refiere a lo que es la lista en vez de lo que apunta a la lista. Conversando, el <code>kill-ring-yank-pointer</code> se refiere a como se apunta a una lista.</p>
<p>Estas dos maneras hablar acerca de la misma cosa suena confuso al principio pero tiene sentido para reflexionar. El kill ring <em>anillo de la muerte</em> es generalmente pensado como la estructura completa de datos que manejan la información de lo que se ha cortado reciéntemente de los búffers de Emacs. El <code>kill-ring-yank-pointer</code> en la otra mano, sirve para indicar --- que es, para ‘apuntar a’ --- esta parte del anillo de la muerte del que el primer elemento (el <code>car</code>) será insertado.</p>
</div>
<h3 id="Ejercicios-con-yank-y-nthcdr" >Ejercicios con <code>yank</code> y <code>nthcdr</code></h3>
<div class="hBody-3" >
<ul>
<li><p>Usando <kbd>C-h v</kbd> (<code>describe-variable</code>), mira en el valor de tu kill ring <em>anillo de la muerte</em>. Añade varios ítems a tu anillo de la muerte <em>kill ring</em>; mira en su valor de nuevo. Usando <kbd>M-y</kbd> (<code>yank-pop</code>, mueve todo el camino alrededor del kill ring <em>anillo de la muerte</em>. ¿Cuántos ítems estaban en tu kill ring <em>anillo de la muerte</em>? Encuentra el valor de <code>kill-ring-max</code>. ¿Estaba tu anillo de la muerte <em>kill ring</em> completo, o podrías haber guardado más bloques de texto dentro?</p>
</li>
<li><p>Usando <code>nthcrd</code> y <code>car</code>, construye una serie de expresiones para devolver, el primer, segundo, tercer y cuarto elemento de una lista.</p>
</li>
</ul>
</div>
<h2 id="Bucles-y-recursión" >Bucles y recursión</h2>
<div class="hBody-2" >
<p>Emacs Lisp tiene dos caminos primarios para causar una expresión, o una serie de expresiones, para ser evaluado repetidamente: uno usa un bucle <code>while</code>, y el otro usa <dfn>recursión</dfn>.</p>
<p>La repetición puede ser valorable. Por ejemplo, para mover hacia delante cuatro frases, tu solo necesitas escribir un programa que moverá hacia delante una frase y entonces repite el proceso cuatro veces. Ya que un ordenador no está aburrido o cansado, tal acción repetitiva no tiene los efectos de borrado por equivocación o exceso que pueden tener los humanos.</p>
<p>La gente mayoritariamente escribe funciones de Emacs Lisp usando bucles <code>while</code>; pero se puede usar recursión, que provee un poderoso camino mental para resolver problemas<span class="note" ><sup><a href="#10" >10</a></sup></span>.</p>
</div>
<h3 id="while" ><code>while</code></h3>
<div class="hBody-3" >
<p>La forma especial <code>while</code> chequea si el valor devuelto para evaluar el primer argumento es verdadero o falso. Esto es parecido a lo que el intérprete Lisp hace con un <code>if</code>; el intérprete hace lo siguiente, sin embargo, es diferente.</p>
<p>En una expresión <code>while</code>, si el valor devuelto por evaluar el primer argumento es falso, el intérprete Lisp descarta el resto de la expresión (el <dfn>cuerpo</dfn> de la expresión) y no la evalúa. Sin embargo, si el valor es cierto, el intérprete Lisp evalúa el cuerpo de la expresión y entonces de nuevo chequea si el primer argumento para <code>while</code> es cierto o falso. Si el valor devuelto de evaluar el primer argumento es cierto de nuevo, el intérprete Lisp evalúa el cuerpo de la expresión.</p>
<p>La plantilla para una expresión <code>while</code> se ve así:</p>
<pre><code class="example">(while @V{test-verdadero-o-falso}
  @V{cuerpo}…)</code></pre>
<p>En el momento en el que el true-or-false-test de la expresión <code>while</code> devuelve un valor cierto cuando eso se evalúa, el cuerpo es repetidamente evaluado. Este proceso se llama bucle puesto que el intérprete Lisp repite la misma cosa una y otra vez, como un avión haciendo un loop. Cuando el resultado de evaluar el true-or-false-test es falso, el intérprete Lisp no evalúa el resto de la expresión <code>while</code> y ‘existe el bucle’.</p>
<p>Claramente, si el valor devuelto evaluando el primer argumento para <code>while</code> es siempre cierto, el cuerpo siguiente será evaluado una y otra vez … y … para siempre. Recíprocamente, si el valor devuelto nunca es cierto, las expresiones en el cuerpo nunca serán evaluadas. La fortaleza de escribir un bucle <code>while</code> consiste de elegir un mecanismo tal que el true-or-false-test devuelva cierto solo el número de veces que requieren las subsiguientes expresiones para ser evaluadas, y entonces tener el test devuelto a falso.</p>
<p>El valor devuelto evaluando <code>while</code> es el valor del true-or-false-test. Una consecuencia interesante de esto es que un bucle <code>while</code> que evalúa sin errores devolverá <code>nil</code> o falso sin dignidad de si eso ha girado 1 o 100 veces o ninguna. ¿Una expresión <code>while</code> que se evalúa de manera exitosa nunca devuelve un valor cierto! Lo que esto significa es que <code>while</code> es siempre evaluado por sus efectos laterales, que es decir, las consecuencias de evaluar las expresiones con el cuerpo del bucle <code>while</code>. Esto tiene sentido. Eso no es el mero acto del bucle que es deseado, pero las consecuencias de lo que ocurre cuando las expresiones en el bucle son repetidamente evaluadas.</p>
</div>
<h4 id="Un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</h4>
<div class="hBody-4" >
<p>Un camino común para controlar un bucle <code>while</code> es chequear si una lista tiene cualquier elemento. Si eso se hace, el bucle se repite; pero si no, la repetición se finaliza. Puesto que esto es una técnica importante, se creará un breve ejemplo para ilustrarlo.</p>
<p>Un camino simple para chequear si una lista tiene elementos es evaluar la lista: si eso no tiene elementos, si es una lista vacía y devuelve la lista vacía, <code>()</code>, que es un sinónimo para <code>nil</code> o falso. Por otro lado, una lista con elementos devolverá estos elementos cuando eso se evalúa. Puesto que Emacs Lisp considera como cierto cualquier valor que no es <code>nil</code>, una lista que devuelve elementos chequeará cierto en un bucle <code>while</code>.</p>
<p>Por ejemplo, se puede asignar la variable <code>empty-list</code> a <code>nil</code> para evaluar la siguiente expresión <code>setq</code>:</p>
<pre><code class="example">(setq lista-vacia ())</code></pre>
<p>Después de evaluar la expresión <code>setq</code>, se puede evaluar la variable <code>lista-vacia</code> es el camino normal, posicionando el cursor después del símbolo y escribiendo <kbd>C-x C-e</kbd>; <code>nil</code> aparecerá en tu área echo:</p>
<pre><code class="example">lista-vacia</code></pre>
<p>Por otro lado, si se asigna una variable para ser una lista con elementos, la lista aparecerá cuando se evalúe la variable, como se puede ver evaluando las siguientes dos expresiones:</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

animales</code></pre>
<p>De este modo, para un bucle <code>while</code> que chequea si hay cualquier ítem en la lista <code>animales</code>, la primera parte del bucle será escrito así:</p>
<pre><code class="example">(while animales
       …</code></pre>
<p>Cuando el <code>while</code> chequea su primer argumento, la variable <code>animales</code> se evalúa. Eso devuelve una lista. Mientras la lista tiene elementos, el <code>while</code> considera los resultados del test para ser verdadero; pero cuando la lista es vacía, eso considera los resultados del test para ser falso.</p>
<p>Para prevenir que el bucle <code>while</code> se ejecute siempre, se necesita proporcionar algún mecanismo. Una técnica usada con frecuencia es tener una de las subsiguientes formas en la expresión <code>while</code> que asigna el valor de la lista para ser el <code>cdr</code> de la lista. Cada vez que la función <code>cdr</code> se evalúa, se va reduciendo, hasta que finalmente solo queda la lista vacía. En este punto, el test del bucle <code>while</code> devolverá falso, y los argumentos para el <code>while</code> no se evaluarán.</p>
<p>Por ejemplo, la lista de animales asociada a la variable <code>animals</code> se puede asignar a ser el <code>cdr</code> de la lista original con la siguiente expresión:</p>
<pre><code class="example">(setq animals (cdr animals))</code></pre>
<p>Si se han evaluado las expresiones previas y entonces se evalúa esta expresión, se verá <code>(jirafa leon tigre)</code> que aparecerá en el área echo. Si se evalúa la expresi@'n de nuevo, <code>(leon tigre)</code> aparecerá en el área echo. Si se evalúa de nuevo, <code>(tigre)</code> y todavía de nuevo aparecerá la lista vacía y se mostrará como <code>nil</code>.</p>
<p>Una plantilla para un bucle <code>while</code> usa la función <code>cdr</code> repetidamente para causar el true-or-false-test finalmente para chequear la veracidad y se parece a esto:</p>
<pre><code class="example">(while @V{test-whether-list-is-empty}
  @V{body}…
  @V{set-list-to-cdr-of-list})</code></pre>
<p>Este chequeo y uso de <code>cdr</code> puede ser puesto junto a una función que va a través de una lista e imprime cada elemento de la lista en una línea de sí misma.</p>
</div>
<h4 id="Un-ejemplo:-imprimir-elementos-de-la-lista" >Un ejemplo: <code>imprimir-elementos-de-la-lista</code></h4>
<div class="hBody-4" >
<p>La función <code>imprimir-elementos-de-la-lista</code> ilustra un bucle <code>while</code> con una lista.</p>
<p>La función requiere varias líneas por su salida. Si estás leyendo esto en una instancia reciente de GNU Emacs, se puede evaluar la siguiente expresión dentro de Info, de normal.</p>
<p>Si se está usando una versión antigua de Emacs, es necesario copiar las expresiones necesarias para el búffer <span class="file" >*scratch*</span> y evaluarlas allí. Esto es porque el área echo tenía solo una línea en las versiones antiguas.</p>
<p>Se pueden copiar las expresiones marcando el principio de la región con <kbd>C-<kbd>SPC</kbd></kbd> (<code>set-mark-command</code>), moviendo el cursor al fin de la región y entonces copiando la región usando <kbd>M-w</kbd> (<code>kill-ring-save</code>, que llama a <code>copy-region-as-kill</code> y entonces provee realimentación visual). En el búffer <span class="file" >*scratch*</span>, se pueden copiar las expresiones escribiendo <kbd>C-y</kbd> (<code>yank</code>).</p>
<p>Después de haber copiado las expresiones al búffer <span class="file" >*scratch*</span>, se evalúa cada expresión en orden. Asegúrese de evaluar la última expresión, <code>(imprimir-elementos-de-la-lista animales)</code>, escribiendo <kbd>C-u C-x C-e</kbd>, que es, dando un argumento para <code>eval-last-sexp</code>. Esto causará el resultado de la evaluación para ser impreso en el búffer <span class="file" >*scratch*</span> en vez de siendo impreso en el área echo. (De otro modo se verá alguna cosa como esto en tu área echo: <code>^Jgacela^J^Jjirafa^J^Jleon^J^Jtigre^Jnulo</code>, en cada <samp>^J</samp> se estructura una ‘nueva línea’.)</p>
<p>En una instancia de GNU Emacs reciente, se pueden evaluar estas expresiones directamente en el búffer Info, y el área echo crecerá para mostrar los resultados.</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

(defun imprimir-elementos-de-la-lista (list)
  &quot;Imprime cada elemento de LIST en una línea.&quot;
  (while list
    (print (car list))
    (setq list (cdr list))))

(imprimir-elementos-de-la-lista animales)</code></pre>
<p>Cuando se evalúan las tres expresiones en secuencia, se verá esto:</p>
<pre><code class="example">gacela

jirafa

leon

tigre
nil</code></pre>
<p>Cada elemento de la lista se imprime en una línea en sí (que es lo que la función <code>print</code> hace) y entonces el valor devuelto por la función se imprime. Desde que la última expresión en la función es el bucle <code>while</code>, y desde que el bucle <code>while</code> siempre devuelve <code>nil</code>, un <code>nil</code> se imprime después del último elemento de la lista.</p>
</div>
<h4 id="Un-bucle-con-un-contaje-incremental" >Un bucle con un contaje incremental</h4>
<div class="hBody-4" >
<p>Un bucle no es útil a menos que pare cuando debe. Bajo el control de un bucle con una lista, un camino común de parar un bucle es escribir el primer argumento como un test que devuelve falso cuando el número correcto de repeticiones es completo. Esto significa que el bucle debe tener un contador––una expresión que cuenta cuántas veces el bucle se repite a sí mismo.</p>
<p>El test para un bucle con un contador de incremento puede ser una expresión tal como <code>(&lt; contador numero-deseado)</code> que devuelve <code>t</code> para verdad si el valor de <code>contador</code> es menor que el <code>numero-deseado</code> de repeticiones y <code>nil</code> para falso si el valor de <code>contador</code> es igual a o es mayor que el <code>numero-deseado</code>. La expresión que incrementa el contador puede ser un simple <code>setq</code> tal como <code>(setq contador (1+ contador))</code>, donde <code>1+</code> es una función construida en Emacs Lisp que añade 1 a su argumento. (La expresión <code>(1+ contador)</code> tiene el mismo resultado que <code>(+ contador 1)</code>, que es fácil de leer para un humano.)</p>
<p>La plantilla para un bucle <code>while</code> controlado por un contador que se incrementa se parece a esto:</p>
<pre><code class="example">@V{asignar-contador-al-valor-inicial}
(while (&lt; contador numero-deseado)         ; @e{true-or-false-test}
  @V{body}…
  (setq contador (1+ contador)))              ; @e{incremento}</code></pre>
<p>Note que se necesita asignar el valor inicial de <code>contador</code>; normalmente asignado a 1.</p>
</div>
<h5 id="Ejemplo-con-contador-incremental" >Ejemplo con contador incremental</h5>
<div class="hBody-5" >
<p>Supón que estás jugando en la playa y decides crear un triángulo de asteriscos, poniendo un asterisco en la primera fila, dos en la segunda fila, tres en la tercera fila y así:</p>
<pre><code class="example">               *
              * *
             * * *
            * * * *</code></pre>
<p>(Hace 2500 años, Pitágoras y otras desarrollaron los principios de la teoría de números considerando preguntas como esta.)</p>
<p>Supón que quieres saber cuántos asteriscos necesitarás crear para un triángulo con 7 filas</p>
<p>Claramente, lo que necesitas hacer es añadir los números de 1 a 7. Hay dos caminos para hacer esto; se puede comenzar con los números más pequeños, uno, y añadir la lista en secuencia, 1, 2, 3, 4 y así; o empieza con el número más largo y añade la lista bajando: 7, 6, 5, 4 y así. Porque ambos mecanismos ilustran caminos comunes de escribir el bucle <code>while</code>, crearemos dos ejemplos, uno contando hacia arriba y el otro contando hacia abajo. En este primer ejemplo, empezaremos con 1 y añadimos 2, 3, 4 y así.</p>
<p>Si se quiere sumar toda una lista de números, el camino más fácil para hacer eso es sumar todos los números a la vez. Sin embargo, si no se sabe cuántos números tendrá la lista, o si se requiere estar preparado para una lista muy larga, entonces se necesita diseñar la adición, esto es, repetir un proceso simple muchas veces en vez de hacer un proceso más complejo.</p>
<p>Por ejemplo, en vez de añadir todos los asteriscos a la vez, lo que se puede hacer es añadir el número de asteriscos en la primera fila, 1, para el número en la segunda fila, 2, y entonces añadir el total de estas dos filas a la tercera fila, 3. Entonces se puede añadir el número en la cuarta fila, 4, al total de las primeras tres filas; y así.</p>
<p>La característica crítica del proceso es que cada acción repetitiva sea simple. En este caso, en cada paso nosotros añadimos solo dos números, el número de asteriscos en la fila y el total ya encontrado. Este proceso de añadir dos números es repetido de nuevo y de nuevo hasta la última fila que ha sido añadida al total de todas las filas precedentes. En un bucle más complejo la acción repetitiva podría no ser tan simple, pero será tan simple como hacer todo a la vez.</p>
</div>
<h5 id="Las-partes-de-la-definición-de-función" >Las partes de la definición de función</h5>
<div class="hBody-5" >
<p>El análisis precedente nos da los bonos de nuestra definición de función: primero, necesitaremos una variable que podemos llamar <code>total</code> que será el número total de asteriscos. Esto será el valor devuelto por la función.</p>
<p>Segundo, sabemos que la función requerirá un argumento: este argumento será el número de filas en el triángulo. Eso puede llamarse <code>number-of-rows</code>.</p>
<p>Finalmente, se necesita una variable para usarse como contador. Se podría llamar a esta variable <code>counter</code>, pero un nombre mejor es <code>row-number</code>. Debido a que lo que el contador hace en esta función es contar filas, y un programa debería escribirse para ser comprendido en la medida de lo posible.</p>
<p>Cuando el intérprete Lisp primero empieza evaluando las expresiones de la función, el valor de <code>total</code> estaría asignado a cero, ya que no hemos añadido cualquier cosa a eso. Entonces la función añadiría el número de asteriscos en la primera fila al total, y entonces añade el número de asteriscos en la segunda al total, y entonces añade el número de asteriscos a la tercera fila al total, y así, hasta que no hay más filas a la izquierda para añadir.</p>
<p>Ambos <code>total</code> y <code>row-number</code> se usan solo dentro de la función, así ellos pueden ser declarados como variables locales con <code>let</code> y valores iniciales dados. Claramente, el valor inicial para total sería 0. El valor inicial de <code>row-number</code> sería 1, desde que se comienza con la primera fila. Esto significa que la frase <code>let</code> se parece a esto:</p>
<pre><code class="example">  (let ((total 0)
        (row-number 1))
    @V{body}…)</code></pre>
<p>Después de que las variables internas se declaran y se asignan a sus valores iniciales se podría empezar el bucle <code>while</code>. La expresión que sirve como el test devolvería un valor de <code>t</code> para la verdad tan grande como el <code>row-number</code> que es menor o igual al <code>number-of-rows</code>. (La expresión devuelve cierto solo si el número de fila es menor que el número de filas en el triángulo, la última fila nunca será añadida al total; aquí el número de fila tiene que ser menor o igual el número de filas.))</p>
<p>Lisp provee la función <code>&lt;=</code> que devuelve cierto si el valor de su primer argumento es menor o igual al valor de su segundo argumento y falso de otro modo. Así la expresión que el <code>while</code> evaluará como si su test se vería como esto:</p>
<pre><code class="example">(&lt;= row-number number-of-rows)</code></pre>
<p>El número de asteriscos puede encontrarse repetidamente añadiendo el número de asteriscos en una fila al total ya encontrado. Puesto que el número de asteriscos en la fila es igual al número de la fila, el total puede encontrarse añadiendo el número de filas al total. (Claramente, en una situación más compleja, el número de asteriscos en la fila podría ser relacionada al número de la fila en un camino más complicado; si este fuera el caso, el número de fila sería reemplazado por la expresión apropiada.)</p>
<pre><code class="example">(setq total (+ total row-number))</code></pre>
<p>Lo que esto hace es asignar el nuevo valor de <code>total</code> a ser igual a la suma de añadiendo el número de asteriscos en la fila al total previo.</p>
<p>Después de configurar el valor de <code>total</code>, las condiciones deben ser establecidas para la siguiente repetición del bucle, si hay alguna. Esto se hace incrementando el valor de la variable <code>row-number</code>, que sirve como un contador. Después que la variable <code>row-number</code> ha sido incrementada, el true-or-false-test al principio del bucle <code>while</code> chequea si su valor es todavía menor o igual al valor del <code>number-of-rows</code> y si eso es, añade el nuevo valor de la variable <code>row-number</code> al <code>total</code> de la repetición del bucle.</p>
<p>La función construida en Emacs Lisp <code>1+</code> añade 1 a un número, así la variable <code>row-number</code> puede ser incrementado con esta expresión:</p>
<pre><code class="example">(setq row-number (1+ row-number))</code></pre>
</div>
<h5 id="Poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</h5>
<div class="hBody-5" >
<p>Nosotros hemos creado las partes para la definición de la función; ahora necesitamos ponerlas juntas.</p>
<p>Primero, los contenidos de la expresión <code>while</code>:</p>
<pre><code class="example">(while (&lt;= row-number number-of-rows)   ; @e{true-or-false-test}
  (setq total (+ total row-number))
  (setq row-number (1+ row-number)))    ; @e{incremento}</code></pre>
<p>Tener la expresión <code>let</code> de varlist, se acerca a completar el cuerpo de la definición de función. Sin embargo, eso requiere un elemento final, la necesidad para la que es alguna cosa pequeña.</p>
<p>El toque final es emplazar la variable <code>total</code> en una línea por sí misma después de la expresión <code>while</code>. De otro modo, el valor devuelto por la función completa es el valor de la última expresión que es evaluada en el cuerpo del <code>let</code>, y este es el valor devuelto por el <code>while</code> que es siempre <code>nil</code>.</p>
<p>Esto puede no ser evidente a primera vista. Eso casi se ve como si la expresión de incremento es la última expresión de la función completa. Pero esta expresión es parte del cuerpo del <code>while</code>; eso es el último elemento de la lista que empieza con el símbolo <code>while</code>. Más allá, el bucle <code>while</code> completo es una lista con el cuerpo del <code>let</code>.</p>
<p>En línea (<em>outline</em>), la función se parece a esto:</p>
<pre><code class="example">(defun @V{name-of-function} (@V{argument-list})
  &quot;@V{documentation}…&quot;
  (let (@V{varlist})
    (while (@V{true-or-false-test})
      @V{body-of-while}… )
    … ))                    ; @e{Necesita la expresión final aquí.}</code></pre>
<p>El resultado de evaluar el <code>let</code> es que lo que está yendo para devolver el <code>defun</code> desde el <code>let</code> que no está embebido con cualquier lista que contiene, excepto para la <code>defun</code> como un todo. Sin embargo, si el <code>while</code> es el último elemento de la expresión <code>let</code>, la función siempre devolverá <code>nil</code>. ¡Esto no es lo que quiero! En vez de eso, lo que queremos es el valor de la variable <code>total</code>. Eso devuelve simplemente emplazando el símbolo como el último elemento de la lista empezando con <code>let</code>. Eso se evalúa después de los elementos precedentes de la lista evaluada, que significa que eso se evaluó después de haber sido asignado el valor correcto para el total.</p>
<p>Eso puede ser fácil de ver imprimiendo la lista empezando con <code>let</code> todo en una línea. Este formato hace evidente que las expresiones varlist y <code>while</code> son el segundo el tercer elementos de la lista empezando con <code>let</code>, y el <code>total</code> es el último elemento:</p>
<pre><code class="example">(let (@V{varlist}) (while (@V{true-or-false-test})
@V{body-of-while}… ) total)</code></pre>
<p>Poniendo cualquier cosa junta, la definición de función <code>triangle</code> se parece a esto:</p>
<pre><code class="example">(defun triangle (number-of-rows)    ; @e{Versión con}
                                    ; @e{ contador de incremento.}
  &quot;Añade el número de asteriscos en un triángulo.
La primera fila tiene un asterisco, la segunda fila dos asteriscos,
la tercera fila tres asteriscos, y así.
El argumento es NUMBER-OF-ROWS.&quot;
  (let ((total 0)
        (row-number 1))
    (while (&lt;= row-number number-of-rows)
      (setq total (+ total row-number))
      (setq row-number (1+ row-number)))
    total))</code></pre>
<p>Después de haber instalado <code>triangle</code> para evaluar la función, se puede probar. Aquí hay dos ejemplos:</p>
<pre><code class="example">(triangle 4)

(triangle 7)</code></pre>
<p>La suma del primero de cuatro números es 10 y la suma de los primeros siete números es 28.</p>
</div>
<h4 id="Bucle-que-se-decrementa" >Bucle que se decrementa</h4>
<div class="hBody-4" >
<p>Otro camino común para escribir un bucle <code>while</code> es escribir el test así que determina si un contador es mayor que cero. Así tan largo es el contador mayor que cero, el bucle se repite. Pero cuando el contador es igual o menor que cero, el bucle se para. Para este trabajo, el contador tiene que empezar mayor que cero y entonces se hace más pequeño y pequeño por una forma que es evaluada repetidamente.</p>
<p>El test será una expresión tal como <code>(&gt; counter 0)</code> que devuelve <code>t</code> <em>cierto</em> si el valor de <code>counter</code> es mayor que cero, y <code>nil</code> <em>falso</em> si el valor de <code>counter</code> es igual a o menor que cero. La expresión hace que el número menor y menor puede ser un simple <code>setq</code> tal como <code>(setq counter (1- counter)</code>, donde <code>1-</code> es una función construida en Emacs Lisp que sustrae 1 de su argumento.</p>
<p>La plantilla para decrementar el bucle <code>while</code> se ve así:</p>
<pre><code class="example">(while (&gt; counter 0)                    ; @e{test-verdadero-o-falso}
  @V{body}…
  (setq counter (1- counter)))          ; @e{decremento}</code></pre>
</div>
<h5 id="Ejemplo-con-el-contador-que-se-decrementa" >Ejemplo con el contador que se decrementa</h5>
<div class="hBody-5" >
<p>Para ilustrar un bucle con un contador de decremento, reescribirá la función <code>triangle</code> así como el contador se decrementa a cero.</p>
<p>Esto es lo inverso de la versión temprana de la función. En este caso, para encontrar cuántos asteriscos son necesarios para crear un triángulo con 3 filas, añade el número de asteriscos en la tercera fila, 3, para el número en la fila precedente, 2, y entonces añade el total de estas dos filas a la fila que lo precede, 1.</p>
<p>Más allá, para encontrar el número de asteriscos en un triángulo con 7 filas, añade el número de asteriscos en la fila siete, 7, al número en la fila precedente, que es 6, y entonces añade el total de estas dos filas a la fila esta que lo precede, que es 5, y así. Como en el ejemplo previo, cada adición solo involucra la adición de dos números, el total de las filas ya se añadió y el número de asteriscos en la fila que está siendo añadida al total. Este proceso de añadir dos números se repite de nuevo y de nuevo hasta que no haya más asteriscos que añadir.</p>
<p>Sabemos con cuántos asteriscos empezar: el número de asteriscos en la última fila es igual al número de filas. Si el triángulo tiene siete filas, el número de asteriscos en la última fila es 7. Más allá, sabemos cuántos asteriscos están en la fila precedente: eso es uno menos que el número en la fila.</p>
</div>
<h5 id="Las-partes-de-la-definición-de-función" >Las partes de la definición de función</h5>
<div class="hBody-5" >
<p>Empezamos con tres variables: el número total de filas en el triángulo; el número de asteriscos en una fila; y el número total de asteriscos, que es lo que queremos calcular. Estas variables pueden llamarse <code>number-of-rows</code>, <code>number-of-pebbles-in-row</code>, y <code>total</code>, respectivamente.</p>
<p>Ambos <code>total</code> y <code>number-of-pebbles-in-row</code> se usan solo dentro de la función y se declaran con <code>let</code>. El valor inicial de <code>total</code> sería cero. Sin embargo, el valor inicial de <code>number-of-pebbles-in-row</code> sería igual al número de filas en el triángulo, desde la adición empezará con la fila más larga.</p>
<p>Esto significa que el principio de la expresión <code>let</code> se verá así:</p>
<pre><code class="example">(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @V{body}…)</code></pre>
<p>El número total de asteriscos puede encontrarse repetidamente añadiendo el número de asteriscos en una fila para el total ya encontrado, que, se evalúa repetidamente en la siguiente expresión:</p>
<pre><code class="example">(setq total (+ total number-of-pebbles-in-row))</code></pre>
<p>Después el <code>number-of-pebbles-in-row</code> se añade al <code>total</code>, el <code>number-of-pebbles-in-row</code> sería decrementado por uno, desde que la siguiente vez el bucle repite, la fila precedente será añadida al total.</p>
<p>El número de asteriscos en una fila precedente es uno menos que el número de asteriscos en una fila, así la función Emacs Lisp construida <code>1-</code> puede usarse para computar el número de asteriscos de la fila precedente. Esto puede ser hecho con la siguiente expresión:</p>
<pre><code class="example">(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))</code></pre>
<p>Finalmente, sabemos que el bucle <code>while</code> pararía creando repetidas adiciones cuando no hay asteriscos en una fila. Así el test para el bucle <code>while</code> es simple:</p>
<pre><code class="example">(while (&gt; number-of-pebbles-in-row 0)</code></pre>
</div>
<h5 id="Poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</h5>
<div class="hBody-5" >
<p>Se pueden poner estas expresiones juntas para crear una definición de función que funcione. Sin embargo, al examinarlas, encontraremos que una de la variables locales ¡es innecesaria!</p>
<p>La definición de función se ve como esto:</p>
<pre><code class="example">;;; @e{Primero la versión substractiva.}
(defun triangle (number-of-rows)
  &quot;Añade el número de asteriscos en un triángulo.&quot;
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (&gt; number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))</code></pre>
<p>Como se dijo, esta función funciona.</p>
<p>Sin embargo, no se necesita <code>number-of-pebbles-in-row</code>.</p>
<p>Cuando la función <code>triangle</code> se evalúa, el símbolo <code>number-of-rows</code> será asociado al número, dando un valor inicial. Este número puede ser cambiado en el cuerpo de la función si hubiera una variable local, sin miedo de que tal cambio se efectuará el valor de la variable fuera de la función. Esto es una característica muy útil de Lisp; eso significa que la variable <code>number-of-rows</code> puede ser usada en cualquier lugar en la función donde <code>number-of-pebbles-in-row</code> se usa.</p>
<p>Aquí hay una segunda versión de la función escrita un poco más limpiamente:</p>
<pre><code class="example">(defun triangle (number)                ; @e{Segunda versión.}
  &quot;Devuelve la suma de números 1 a través de NUMBER inclusive.&quot;
  (let ((total 0))
    (while (&gt; number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))</code></pre>
<p>En breve, un bucle <code>while</code> apropiadamente escrito consistirá de tres partes:</p>
<ol>
<li><p>Un test que devuelva falso después de que el bucle ha repetido por sí mismo el número de veces correcto.</p>
</li>
<li><p>Una expresión de la evaluación de que devolverá el valor deseado después de ser repetidamente evaluado.</p>
</li>
<li><p>Una expresión para cambiar el valor pasado al true-or-false-test así el test devuelve falso después de que el bucle se ha repetido por sí mismo el número de veces correcto.</p>
</li>
</ol>
</div>
<h3 id="Ahorra-tiempo:-dolist-y-dotimes" >Ahorra tiempo: <code>dolist</code> y <code>dotimes</code></h3>
<div class="hBody-3" >
<p>Además de <code>while</code>, tanto <code>dolist</code> como <code>dotimes</code> proveen un bucle. Algunas veces estos son rápidos para escribir el bucle equivalente <code>while</code>. Ambos son macros Lisp. (Véase Sección <cite>Macros</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p><code>dolist</code> funciona como un bucle <code>while</code> con ‘<code>cdr</code>s que bajan la lista’: <code>dolist</code> automáticamente ordena la lista cada vez que la lista hace bucles––toma la <code>cdr</code> de la lista––y asocia el <code>car</code> de cada versión ordenada de la lista al primero de sus argumentos.</p>
<p><code>dotimes</code> repite el bucle un número específico de veces: tu especificas el número.</p>
</div>
<h4 id="La-macro-dolist" >La macro <code>dolist</code></h4>
<div class="hBody-4" >
<p>Supón, por ejemplo, que quieres invertir una lista, así que “primero”, “segundo”, “tercero” llega a ser “tercero”, “segundo”, “primero”.</p>
<p>En la práctica, usarías la función <code>reverse</code>, como esta:</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

(reverse animales)</code></pre>
<p>Aquí se ve cómo se podría invertir la lista usando un bucle <code>while</code>:</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

(defun reverse-list-with-while (list)
  &quot;Usando while, invierte el orden de LIST.&quot;
  (let (value)  ; asegura que la lista comienza vacía
    (while list
      (setq value (cons (car list) value))
      (setq list (cdr list)))
    value))

(reverse-list-with-while animales)</code></pre>
<p>Y aquí se ve cómo podría usarse la macro <code>dolist</code>:</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

(defun reverse-list-with-dolist (list)
  &quot;Usando dolist, reverse, la orden de la LISTA.&quot;
  (let (value)  ; asegura que la lista empieza vacía
    (dolist (element list value)
      (setq value (cons element value)))))

(reverse-list-with-dolist animals)</code></pre>
<p>En Info, se puede localizar su cursor después de cerrar paréntesis de cada expresión y escribir <kbd>C-x C-e</kbd>; en cada caso, se vería</p>
<pre><code class="example">(tigre leon jirafa gacela)</code></pre>
<p>en el área echo.</p>
<p>Para este ejemplo, la función <code>reverse</code> existente es obviamente la mejor. El bucle <code>while</code> es solo como nuestro primer ejemplo (vease Seccion <a href="Un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a>). El <code>while</code> primero chequea si la lista tiene elementos; si es así, eso construye una nueva lista añadiendo el primer elemento de la lista a la lista existente (que en la primera iteración del bucle es <code>nil</code>). Puesto que el segundo elemento está asignado en frente del segundo elemento, la lista es inversa.</p>
<p>En la expresión que usa el bucle <code>while</code>, la expresión <code>(setq list (cdr list))</code> ordena la lista, así el bucle <code>while</code> finalmente para. Además, se proporciona la expresión <code>cons</code> con un nuevo primer elemento creando una nueva lista y se ordena en cada repetición del bucle.</p>
<p>La expresión <code>dolist</code> hace lo mismo que la expresión <code>while</code>, excepto que la macro <code>dolist</code> hace algo del trabajo que se tiene que hacer cuando se escribe una expresión <code>while</code>.</p>
<p>Al igual que el bucle <code>while</code>, tenemos el bucle <code>dolist</code>. Lo que es diferente es que automáticamente ordena la lista cada vez que se repite––eso es ‘recorrer los <code>cdr</code>s de la lista’ en sí––y eso automáticamente asocia el <code>car</code> de cada versión ordenada de la lista al primero de sus argumentos.</p>
<p>En el ejemplo, el <code>car</code> de cada versión ordenada de la lista se refiere a usar el símbolo <samp>element</samp>, la lista en sí se llama <samp>list</samp>, y el valor devuelto se llama <samp>value</samp>. El resto de la expresión <code>dolist</code> es el cuerpo.</p>
<p>La expresión <code>dolist</code> asocia el <code>car</code> de cada versión ordenada de la lista al <code>element</code> y entonces evalúa el cuerpo de la expresión y repite el bucle. El resultado es devuelto en <code>value</code>.</p>
</div>
<h4 id="La-macro-dotimes" >La macro <code>dotimes</code></h4>
<div class="hBody-4" >
<p>La macro <code>dotimes</code> es similar a <code>dolist</code>, excepto que el bucle se repite un número específico de veces.</p>
<p>El primer argumento <code>dotimes</code> se asigna a los números 0, 1, 2 y así vuelve al bucle, y el valor del tercer argumento se devuelve. Se necesita proveer el valor del segundo argumento, que es cuántas veces la macro hace el bucle.</p>
<p>Por ejemplo, lo siguiente asocia los números de 0 en adelante, pero no incluyendo, el número 3 al primer argumento, número, y entonces construye una lista de los tres números. (El primer número es 0, el segundo número es 1, y el tercer número es 2; esto crea un total de tres números en todo, empezando con cero como el primer número.)</p>
<pre><code class="example">(let (value)      ; de otro modo un valor es una variable vacía
  (dotimes (number 3 value)
    (setq value (cons number value))))

⇒ (2 1 0)</code></pre>
<p><code>dotimes</code> devuelve <code>value</code>, así el camino para usar <code>dotimes</code> es para operar en alguna expresión el número de veces number y entonces devolver el resultado, como una lista o un átomo.</p>
<p>Aquí hay un ejemplo de una <code>defun</code> que usa <code>dotimes</code> para añadir el número de asteriscos en un triángulo.</p>
<pre><code class="example">(defun triangle-using-dotimes (number-of-rows)
  &quot;Usando dotimes, añade el número de asteriscos en un triángulo.&quot;
(let ((total 0))  ; de otro modo un total es una variable vacía
  (dotimes (number number-of-rows total)
    (setq total (+ total (1+ number))))))

(triangle-using-dotimes 4)</code></pre>
</div>
<h3 id="Recursión" >Recursión</h3>
<div class="hBody-3" >
<p>Una función recursiva contiene código que hace que el intérprete Lisp llame a un programa que ejecute el código en sí, pero con argumentos ligeramente diferentes. El código ejecuta exactamente lo mismo porque eso tiene el mismo nombre. Sin embargo, incluso aunque el programa tenga el mismo nombre, no es la misma entidad. Eso es diferente. En la jerga, se dice es una ‘instancia’ diferente.</p>
<p>Finalmente, si el programa se escribe correctamente, los ‘argumentos ligeramente diferentes’ llegan a ser suficientemente diferentes puesto que los primeros argumentos de la instancia final se pararán.</p>
</div>
<h4 id="Construyendo-robots:-Extendiendo-la-metáfora" >Construyendo robots: Extendiendo la metáfora</h4>
<div class="hBody-4" >
<p>Algunas veces es útil pensar en un programa en ejecución como un robot que hace un trabajo. Haciendo su trabajo, una función recursiva llama a un segundo robot para que le ayude. El segundo robot es idéntico al primero en cada paso, excepto que el segundo robot ayuda al primero y se han pasado diferentes argumentos en vez del primero.</p>
<p>En una función recursiva, el segundo robot puede llamar a un tercero; y el tercero puede llamar a un cuarto, y así. Cada una de estos es una entidad diferente; pero todos son clones.</p>
<p>Desde que cada robot tiene instrucciones ligeramente diferentes --- los argumentos diferirán desde un robot al siguiente––el último robot conocería cuando pare.</p>
<p>Permite expandir la metáfora en el que un programa de ordenador es un robot.</p>
<p>Una definición de función provee impresiones para un robot. Cuando se instala una definición de función, que es, cuando se evalúa una forma especial <code>defun</code>, se instala el equipamiento para construir robots. Eso es como si tu estuvieras en una fábrica, configurando una línea de ensamblaje. Los robots con el mismo nombre son construidos de acuerdo a las mismas impresiones. Así ellos tienen, como estaban, el mismo ‘número de modelo’, pero un diferente ‘número de serie’.</p>
<p>Nosotros con frecuencia decimos que una función recursiva ‘se llama así misma’. Esto significa que las instrucciones en una función recursiva causa que el intérprete de Lisp ejecute una función diferente que tiene el mismo nombre y hace el mismo trabajo que el primero, pero con diferentes argumentos.</p>
<p>Es importante que los argumentos difieran desde una instancia a la siguiente; de otro modo, el proceso nunca parará.</p>
</div>
<h4 id="Las-partes-de-una-definición-recursiva" >Las partes de una definición recursiva</h4>
<div class="hBody-4" >
<p>Una función recursiva típicamente contiene una expresión condicional que tiene tres partes:</p>
<ol>
<li><p>Un true-or-false-test que determina si la función se llama de nuevo, aquí se llama el <dfn>do-again-test</dfn>.</p>
</li>
<li><p>El nombre de la función. Cuando este nombre se llama, es una nueva instancia de la función––un nuevo robot, así––se crea y se dice qué hacer.</p>
</li>
<li><p>Una expresión que devuelve un valor diferente cada vez que la función se llama, aquí llamada la <dfn>next-step-expression</dfn>. Consecuentemente, el argumento (o argumentos) pasados a la nueva instancia de la función serán diferentes puesto que se pasa a la instancia previa. Esto causa la expresión condicional, que el <dfn>do-again-test</dfn>, devuelva falso después del número correcto de repeticiones.</p>
</li>
</ol>
<p>Las funciones recursivas pueden ser más simples que cualquier otro tipo de funciones. De manera profunda, cuando la gente empieza a usarlas, con frecuencia se miran así misteriosamente de manera tan simple como incompresible. Como montar en bicicleta, leer una función recursiva es duro al principio, pero después es simple.</p>
<p>Hay varios patrones recursivos diferentes. Un patrón muy simple se parece a:</p>
<pre><code class="example">(defun @V{name-of-recursive-function} (@V{argument-list})
  &quot;@V{documentation}…&quot;
  (if @V{do-again-test}
    @V{body}…
    (@V{name-of-recursive-function}
         @V{next-step-expression})))</code></pre>
<p>Cada vez que una función recursiva es evaluada, una nueva instancia se crea y se dice qué hacer. Los argumentos le dicen a la instancia qué hacer.</p>
<p>Un argumento se empareja al valor de la next-step-expresion. Cada instancia se ejecuta con un valor diferente de la next-step-expression.</p>
<p>El valor en la next-step-expression es usado en la do-again-test.</p>
<p>El valor devuelto por la next-step-expression es pasada a las nuevas instancias de la función, que lo evalúa (o alguna transformación de eso) para determinar si continuar o parar. El next-step-expression está diseñado así que el do-again-test devuelve falso cuando la función no se repetiría mucho.</p>
<p>El do-again-test es algunas veces llamado la <dfn>condición de parar</dfn>, puesto que sirve para parar las repeticiones cuando se devuelve falso.</p>
</div>
<h4 id="Recursión-con-una-lista" >Recursión con una lista</h4>
<div class="hBody-4" >
<p>El ejemplo de un bucle <code>while</code> que imprimió los elementos de una lista de números puede ser escrito recursivamente. Aquí está el código, incluyendo una expresión para asignar el valor de la variable <code>animales</code> a una lista.</p>
<p>Si está leyendo esto en el Info de Emacs, se puede evaluar esta expresión directamente en Info. De otro modo, se debe copiar el ejemplo al búffer <span class="file" >*scratch*</span> y evalúa cada expresión aquí. Usa <kbd>C-u C-x C-e</kbd> para evaluar la expresión <code>(print-elements-recursively animals)</code> así que los resultado se imprimen en el búffer; de otro modo el intérprete Lisp intentará presionar los resultados dentro de una línea del área echo.</p>
<p>También, posiciona tu cursor inmediatamente después del último paréntesis que cierra la función <code>print-elements-recursively</code>, antes del comentario. De otro modo, el intérprete Lisp intentará evaluar el comentario.</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

(defun print-elements-recursively (list)
  &quot;Imprime cada elemento de la LISTA de la línea en
  sí. Usa recursión.&quot;
  (when list                            ; @e{do-again-test}
        (print (car list))              ; @e{body}
        (print-elements-recursively     ; @e{recursive call}
         (cdr list))))                  ; @e{next-step-expression}

(print-elements-recursively animales)</code></pre>
<p>La función <code>print-elements-recursively</code> primero chequea si hay cualquier contenido en la lista; si lo hay, la función imprime el primer elemento de la lista, el <code>car</code> de la lista. Entonces la función se ‘invoca en sí’, pero da a sí mismo como su argumento, no la lista completa, pero el segundo y subsiguientes elementos de la lista, el <code>cdr</code> de la lista.</p>
<p>Pon otro camino, si la lista no está vacía, la función invoca otra instancia de código que es similar al código inicial, pero es un hilo diferente de ejecución, con diferentes argumentos a la primera instancia.</p>
<p>Veamos una manera más, si la lista no está vacía, el primer robot ensambla un segundo robot que cuenta qué hacer; el segundo robot es un individuo diferente desde el principio, pero es el mismo modelo.</p>
<p>Cuando la segunda evaluación ocurre, la expresión <code>when</code> se evalúa y si es verdad, se imprime el primer elemento de la lista que recibe como su argumento (que es el segundo elemento de la lista original). Entonces la función ‘llamarse a sí mismo’ con la <code>cdr</code> del <code>cdr</code> de la lista original.</p>
<p>Note que aunque nosotros decimos que la función ‘se llama a sí misma’, lo que significa es que el intérprete Lisp ensambla e instruye una nueva instancia del programa. La nueva instancia es un clon del primero, pero es un individuo separado.</p>
<p>Cada vez que la función ‘se invoca a sí misma’, se invoca a sí misma en una versión de la lista original. Eso crea una nueva instancia que funciona como una lista ordenada.</p>
<p>Finalmente, la función se invoca a sí misma en una lista vacía. Eso crea una nueva instancia cuyo argumento es <code>nil</code>. La expresión condicional chequea el valor de <code>lista</code>. Desde el valor de <code>lista</code> a <code>nil</code>, la expresión <code>when</code> devuelve falso así la then-part no está evaluada. La función es como un todo que entonces devuelve <code>nil</code>.</p>
<p>Cuando se evalúa la expresión <code>(print-elements-recursively animals)</code> en el búffer <span class="file" >*scratch*</span>, se verá este resultado:</p>
<pre><code class="example">gacela

jirafa

leon

tigre
nil</code></pre>
</div>
<h4 id="Recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</h4>
<div class="hBody-4" >
<p>La función <code>triangle</code> describe en una sección previa si puede ser escrita recursivamente. Se ve así:</p>
<pre><code class="example">(defun triangle-recursively (number)
  &quot;Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion.&quot;
  (if (= number 1)                    ; @e{do-again-test}
      1                               ; @e{then-part}
    (+ number                         ; @e{else-part}
       (triangle-recursively          ; @e{recursive call}
        (1- number)))))               ; @e{next-step-expression}

(triangle-recursively 7)</code></pre>
<p>Se puede instalar esta función evaluando y entonces se intenta evaluar <code>(triangle-recursively 7)</code>. (Recuerda poner tu cursor inmediatamente después de los últimos paréntesis de la definición de la función, antes del comentario.) La función se evalúa a 28.</p>
<p>Para comprender cómo funciona la función, hay que considerar qué ocurre en varios casos cuando la función se le pasa 1, 2, 3, o 4 como el valor a su argumento.</p>
<p>Primero, veamos qué ocurre si el valor del argumento es 1.</p>
<p>La función tiene una expresión <code>if</code> después de la cadena de documentación. Esto chequea si el valor de <code>number</code> es igual a 1; si es así, Emacs evalúa la then-part de la expresión <code>if</code>, que devuelve el número 1 como el valor de la función. (Un triángulo con una fila tiene un asterisco dentro.)</p>
<p>Supón, sin embargo, que el valor del argumento es 2. En este caso, Emacs evalúa la parte else de la expresión <code>if</code>.</p>
<p>La parte else consiste de una adición, la llamada recursiva para <code>triangle-recursively</code> y una acción de decremento; y se ve así:</p>
<pre><code class="example">(+ number (triangle-recursively (1- number)))</code></pre>
<p>Cuando Emacs evalúa esta expresión, la expresión interna es evaluada primero; entonces las otras partes en secuencia. Aquí están los pasos en detalle:</p>
<dl>
<dt><p>Paso 1 Evalúa la expresión interna.</p>
</dt>
<dd><p>La expresión interna es <code>(1- number)</code> así Emacs decrementa el valor de <code>number</code> desde 2 a 1.</p>
</dd>
</dl>
<ul>
<li><p>Paso 2 Evalúa la función <code>triangle-recursively</code>.</p>
<p>El intérprete Lisp crea una instancia individual de <code>triangle-recursively</code>. Eso no importa que esta función está contenida con sí misma. Emacs pasa el resultado Paso 1 como el argumento usado por esta instancia de la función <code>triangle-recursively</code></p>
<p>En este caso, Emacs evalúa <code>triangle-recursively</code> con un argumento de 1. Esto significa que esta evaluación de <code>triangle-recursively</code> devuelve 1.</p>
</li>
</ul>
<dl>
<dt><p>Paso 3 Evalúa el valor de <code>number</code>.</p>
</dt>
<dd><p>La variable <code>number</code> es el segundo elemento de la lista que empieza con <code>+</code>; su valor es 2.</p>
</dd>
<dt><p>Paso 4 Evalúa la expresión <code>+</code>.</p>
</dt>
<dd><p>La expresión <code>+</code> recibe dos argumentos, el primero desde la evaluación de <code>number</code> (Paso 3) y el segundo desde la evaluación de <code>triangle-recursively</code> (Paso 2).</p>
<p>El resultado de la adición es la suma de 2 + 1, y el número 3 es devuelto, que es correcto. Un triángulo con dos filas tiene tres asteriscos ahí.</p>
</dd>
</dl>
</div>
<h5 id="Un-argumento-de-3-o-4" >Un argumento de 3 o 4</h5>
<div class="hBody-5" >
<p>Supón que <code>triangle-recursively</code> es llamado con un argumento de 3.</p>
<dl>
<dt><p>Paso 1 Evalúa la do-again-test.</p>
</dt>
<dd><p>La expresión <code>if</code> se evalúa primero. Esto es el test do-again y devuelve falso, así la parte else de la expresión <code>if</code> es evaluada. (Note que en este ejemplo, el do-again-test causa la función para llamarse a sí misma cuando eso se chequea como falso, no cuando eso se chequea como verdadero.)</p>
</dd>
<dt><p>Paso 2 Evalúa la expresión propia de la parte else.</p>
</dt>
<dd><p>La expresión propia de la parte que es evaluada, decrementa 3 a 2. Esta la next-step-expression.</p>
</dd>
<dt><p>Paso 3 Evalúa la función <code>triangle-recursively</code>.</p>
</dt>
<dd><p>El número 2 es pasado a la función <code>triangle-recursively</code>.</p>
<p>Nosotros ya sabemos qué ocurre cuando Emacs evalúa <code>triangle-recursively</code> con un argumento de 2. Después de ir a través de la secuencia de acciones descritas temprano, eso devuelve un valor de 3. Así que es lo que ocurrirá aquí.</p>
</dd>
<dt><p>Paso 4 Evalúa la adición.</p>
</dt>
<dd><p>3 será pasado como un argumento para la adición y será añadido al número con el que la función se llamó, que es 3.</p>
</dd>
</dl>
<p>El valor devuelto por la función como un todo será 6.</p>
<p>Ahora que sabemos qué ocurrirá cuando <code>triangle-recursively</code> llama con un argumento 3, es evidente lo que ocurrirá si se llama con el argumento 4:</p>
<p>En la llamada recursiva, la evaluación de</p>
<pre><code class="example">(triangle-recursively (1- 4))</code></pre>
<p>devuelve el valor de evaluar</p>
<pre><code class="example">(triangle-recursively 3)</code></pre>
<p>que es 6 este valor será añadido a 4 por la adición en la tercera línea. &lt; blood..</p>
<p>El valor devuelto por la función como un todo será 10.</p>
<p>Cada vez que <code>triangle-recursively</code> se evalúa, se interpreta una versión de sí misma––una instancia diferente en sí––con un pequeño argumento, hasta que el argumento es suficientemente pequeño así que no se evalúa en sí.</p>
<p>Note que este particular diseño para una función recursiva requiere que las operaciones sean diferidas.</p>
<p>Antes de que <code>(triangle-recursively 7)</code> pueda calcular su respuesta, debe llamarse a <code>(triangle-recursively 6)</code>; y antes a <code>(triangle-recursively 5)</code>; y así. Esto es decir, que el cálculo de <code>(triangle-recursively 7)</code> a crear debe ser diferido hasta que <code>(triangle-recursively 6)</code> haga su cálculo; y <code>(triangle-recursively 5)</code> lo complete; y así.</p>
<p>Si cada una de estas instancias de <code>triangle-recursively</code> son pensadas como diferentes robots, el primer robot debe esperar por el segundo para completar su trabajo, que debe esperar hasta los terceros completos, y así.</p>
<p>Hay un camino alrededor de este tipo de espera, que se discutirá en <a href="Recursión-sin-diferir" >Recursión sin diferir</a>.</p>
</div>
<h4 id="Ejemplo-de-recursión-usando-cond" >Ejemplo de recursión usando <code>cond</code></h4>
<div class="hBody-4" >
<p>La versión de <code>triangle-recursively</code> antes descrita se escribió con la forma especial <code>if</code>. Eso puede también ser escrita usando otra forma especial llamada <code>cond</code>. El nombre de la forma especial <code>cond</code> es una abreviación de la palabra <samp>conditional</samp>.</p>
<p>Aunque la forma especial <code>cond</code> no se usa con frecuencia en las fuentes de Emacs como <code>if</code>, se usa con suficiente frecuencia para justificarse explicando.</p>
<p>La plantilla para una expresión <code>cond</code> se parece a:</p>
<pre><code class="example">(cond
 @V{body}…)</code></pre>
<p>donde el body es una serie de listas.</p>
<p>Escrito de manera más completa, la plantilla se parece a esto:</p>
<pre><code class="example">(cond
 (@V{first-true-or-false-test} @V{first-consequent})
 (@V{second-true-or-false-test} @V{second-consequent})
 (@V{third-true-or-false-test} @V{third-consequent})
  …)</code></pre>
<p>Cuando el intérprete Lisp evalúa la expresión <code>cond</code>, evalúa el primer elemento (el <code>car</code> o true-or-false-test) de la primera expresión en una serie de expresiones con el cuerpo del <code>cond</code>.</p>
<p>Si el true-or-false-test devuelve <code>nil</code> el resto de esta expresión, el consecuente, se descarta y el true-or-false-test de la siguiente expresión se evalúa. Cuando una expresión encuentra un true-or-false-test cuyo valor no es <code>nil</code>, el consecuente de esta expresión se evalúa. El consecuente puede ser una o más expresiones. Si el consecuente consiste de más de una expresión, las expresiones son evaluadas en secuencia y el valor del último se devuelve. Si la expresión no tiene un consecuente, se devuelve el valor del true-or-false-test.</p>
<p>Si ninguno del test true-or-false-tests es cierto, la expresión <code>cond</code> devuelve <code>nil</code>.</p>
<p>Escrito usando <code>cond</code>, la función <code>triangle</code> se parece a esto:</p>
<pre><code class="example">(defun triangle-using-cond (number)
  (cond ((&lt;= number 0) 0)
        ((= number 1) 1)
        ((&gt; number 1)
         (+ number (triangle-using-cond (1- number))))))</code></pre>
<p>En este ejemplo, el <code>cond</code> devuelve 0 si el número es menor o igual a 0, eso devuelve 1 si el número es 1 y eso evalúa <code>(+ number (triangle-using-cond (1- number)))</code> si el número es más grandes que 1.</p>
</div>
<h4 id="Patrones-recursivos" >Patrones recursivos</h4>
<div class="hBody-4" >
<p>Aquí hay tres patrones recursivos. Cada uno involucra una lista. La recursión no se necesita para involucrar listas, pero Lisp se diseña para listas y esto provee un sentido de sus capacidades primarias.</p>
</div>
<h5 id="Patrón-recursivo:-every" >Patrón recursivo: <em>every</em></h5>
<div class="hBody-5" >
<p>En el patrón recursivo <code>every</code>, se desarrolla una acción por cada elemento de una lista.</p>
<p>El patrón básico es:</p>
<ul>
<li><p>Si una lista es vacía, devuelve <code>nil</code>.</p>
</li>
<li><p>Si no, se va al principio de la lista (el <code>car</code> de la lista) actuando</p>
<ul>
<li><p>a través de una llamada recursiva por la función en el resto (el <code>cdr</code>) de la lista,</p>
</li>
<li><p>y, opcionalmente, se combina el elemento sobre el que actúa, usando <code>cons</code>, con los resultados de actuar en el resto.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí está el ejemplo:</p>
<pre><code class="example">(defun square-each (numbers-list)
  &quot;El cuadrado de cada LISTA DE NUMEROS, recursivamente.&quot;
  (if (not numbers-list)                ; test-hazlo-de-nuevo
      nil
    (cons
     (* (car numbers-list) (car numbers-list))
     (square-each (cdr numbers-list))))) ; expresion-siguiente-paso

(square-each '(1 2 3))
    ⇒ (1 4 9)</code></pre>
<p>Si <code>numbers-list</code> está vacío, no hay que hacer nada. Pero si tiene contenido, se construye una lista combinando el cuadrado del primer número en la lista con el resultado de la llamada recursiva.</p>
<p>(El ejemplo sigue el patrón exactamente: se devuelve <code>nil</code> si la lista de números es vacía. En la práctica, se escribiría el condicional, así se ejecuta la acción cuando la lista de números no es vacía.)</p>
<p>La función <code>print-elements-recursively</code> (Vease Sección <a href="Recursión-con-una-Lista" >Recursión con una Lista</a>) es otro ejemplo de un patrón <code>every</code>, excepto en este caso, en vez de traer los resultados juntos usando <code>cons</code>, se imprime cada elemento de salida.</p>
<p>La función <code>print-elements-recursively</code> se parece a esto:</p>
<pre><code class="example">(setq animales '(gacela jirafa leon tigre))

(defun print-elements-recursively (list)
  &quot;Imprime cada elemento de la LISTA de la línea en
  sí. Usa recursión.&quot;
  (when list                            ; @e{do-again-test}
        (print (car list))              ; @e{body}
        (print-elements-recursively     ; @e{recursive call}
         (cdr list))))                  ; @e{next-step-expression}

(print-elements-recursively animales)</code></pre>
<p>El patrón para <code>print-elements-recursively</code> es:</p>
<ul>
<li><p>Cuando la lista está vacía, no hacer nada.</p>
</li>
<li><p>Pero cuando la lista tiene al menos un elemento,</p>
<ul>
<li><p>actúa al principio de la lista (el <code>car</code> de la lista),</p>
</li>
<li><p>y crea una llamada recursiva en el resto (el <code>cdr</code> de la lista).</p>
</li>
</ul>
</li>
</ul>
</div>
<h5 id="Patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></h5>
<div class="hBody-5" >
<p>Otro patrón recursivo es llamado el patrón <code>accumulate</code>. En el patrón recursivo <code>accumulate</code>, se realiza una acción en cada elemento de una lista y el resultado de esta acción se acumula con los resultados de desarrollar la acción en otros elementos.</p>
<p>Esto es como ‘cada’ patrón usando <code>cons</code>, excepto que este <code>cons</code> no se esté usando, pero que algún otro combine.</p>
<p>El patrón es:</p>
<ul>
<li><p>Si una lista está vacía, devuelve cero o alguna otra constante.</p>
</li>
<li><p>Lo demás, actúa al principio de la lista (el <code>car</code> de la lista),</p>
<ul>
<li><p>y combinar este elemento que actúa, usando <code>+</code> o alguna otra función de combinación, con</p>
</li>
<li><p>una llamada recursiva por la función en el resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí hay un ejemplo:</p>
<pre><code class="example">(defun add-elements (numbers-list)
  &quot;Añade los elementos de NUMBERS-LIST juntos.&quot;
  (if (not numbers-list)
      0
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))

(add-elements '(1 2 3 4))
    ⇒ 10</code></pre>
<p>Véase Sección <a href="Creando-una-lista-de-ficheros" >Creando una lista de ficheros</a>, para un ejemplo del patrón acumulado.</p>
</div>
<h5 id="Patrón-recursivo:-keep" >Patrón recursivo: <em>keep</em></h5>
<div class="hBody-5" >
<p>Un tercer patrón es llamado el patrón <code>keep</code>. En el patrón recursivo <code>keep</code>, se chequea cada elemento de una lista; se actúa en el elemento y los resultados se guardan solo si el elemento encuentra un criterio.</p>
<p>De nuevo, esto se parece al patrón ‘every’, excepto que el elemento se descarta a menos que se encuentre un criterio.</p>
<p>El patrón tiene tres partes:</p>
<ul>
<li><p>Si una lista es vacía, devuelve <code>nil</code>.</p>
</li>
<li><p>Lo demás, si el principio de la lista (el <code>car</code> de la lista) pasa un test</p>
<ul>
<li><p>actua en este elemento y lo combina, usando <code>cons</code> con</p>
</li>
<li><p>una llamada recursiva por la función en el resto (el <code>cdr</code> de la lista.</p>
</li>
</ul>
</li>
<li><p>De otro modo, si el principio de la lista (el <code>car</code> de la lista) falla el test</p>
<ul>
<li><p>para en este elemento,</p>
</li>
<li><p>y, recursivamente llama la función al resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí hay un ejemplo que usa <code>cond</code>:</p>
<pre><code class="example">(defun manten-tres-letras (lista-palabras)
  &quot;Guarda 3 palabras en WORD-LIST.&quot;
  (cond
   ;; Primero do-again-test: stop-condition
   ((not lista-palabras) nil)

   ;; Segundo do-again-test: cuando actuar
   ((eq 3 (length (symbol-name (car lista-palabras))))
    ;; combina el elemento que actúa con la llamada recursiva en la
    ;; lista ordenada
    (cons (car lista-palabras) (manten-tres-letras (cdr lista-palabras))))

   ;; Tercero do-again-test: cuando se descarte el elemento;
   ;; llama recursivamente a la lista ordenada con la next-step expression
   (t (manten-tres-letras (cdr lista-palabras)))))

(manten-tres-letras '(uno dos tres cuatro cinco seis))
    ⇒ (uno dos)</code></pre>
<p>Eso va sin decir que no se necesita usar <code>nil</code> como si el test para cuando para; y se puede, de acuerdo, combinar estos patrones.</p>
</div>
<h4 id="Recursión-sin-diferir" >Recursión sin diferir</h4>
<div class="hBody-4" >
<p>Permita considerar de nuevo qué ocurre con la función <code>triangle-recursively</code>. Nosotros encontraremos que los cálculos difieran hasta que todo pueda ser hecho.</p>
<p>Aquí está la definición de función:</p>
<pre><code class="example">(defun triangle-recursively (number)
  &quot;Devuelve la suma de los números 1 a través de NUMBER inclusive
Usa recursión.&quot;
  (if (= number 1)                    ; @e{do-again-test}
      1                               ; @e{then-part}
    (+ number                         ; @e{else-part}
       (triangle-recursively          ; @e{recursive call}
        (1- number)))))               ; @e{next-step-expression}</code></pre>
<p>¿Qué ocurre cuando se llama a esta función con un argumento de 7?</p>
<p>La primera instancia de la función <code>triangle-recursively</code> añade el número 7 al valor devuelto por una segunda instancia de <code>triangle-recursively</code>, una instancia que ha pasado un argumento de 6. Así, el primer cálculo es:</p>
<pre><code class="example">(+ 7 (triangle-recursively 6))</code></pre>
<p>La primera instancia de <code>triangle-recursively</code> --- se puede querer pensar como un pequeño robot––no puede completar su trabajo. Eso debe manejar el cálculo para <code>(triangle-recursively 6)</code> a una segunda instancia del programa, a un segundo robot. Este segundo individuo es completamente diferente desde el primero; eso es, en la jerga, una ‘diferente instanciación’. O, poner otro camino, eso es un diferente robot. Eso es el mismo modelo como el primero; eso calcula números de triángulo recursivamente; pero eso tiene un número de serie diferente.</p>
<p>¿Y qué hace <code>(triangle-recursively 6)</code> devuelve? Eso devuelve el número 6 añadido al valor devuelto para evaluar <code>triangle-recursively</code> con un argumento de 5. Usando la metáfora del robot, eso cuestiona todavía otro robot para ayudarle.</p>
<p>Ahora el total es:</p>
<pre><code class="example">(+ 7 6 (triangle-recursively 5))</code></pre>
<p>¿Y qué ocurre después?</p>
<pre><code class="example">(+ 7 6 5 (triangle-recursively 4))</code></pre>
<p>Cada vez que <code>triangle-recursively</code> es llamado, excepto por la última vez, eso crea otra instancia del programa––otro robot --- y pregunta para crear un cálculo.</p>
<p>Finalmente, la adición completa es de la siguiente manera:</p>
<pre><code class="example">(+ 7 6 5 4 3 2 1)</code></pre>
<p>Este diseño para la función difiere el cálculo del primer paso hasta el segundo puede ser hecho, y difiere esto hasta que el tercero puede ser hecho, y así. Cada defermento significa el ordenador debe recordar que está siendo esperado dentro. Esto no es un problema cuando hay solo unos pocos pasos, como en este ejemplo. Pero eso puede ser un problema cuando hay más pasos.</p>
</div>
<h4 id="No-hay-solución-pospuesta" >No hay solución pospuesta</h4>
<div class="hBody-4" >
<p>La solución al problema de operaciones pospuestas es para escribir en una manera que no posponga operaciones<span class="note" ><sup><a href="#11" >11</a></sup></span>. Esto requiere escribir a un patrón diferente, con frecuencia uno que involucra escribiendo dos definiciones de función, una función de ‘inicialización’ y una función ‘ayuda’.</p>
<p>La función ‘inicializacion’ configura el trabajo; la función ‘ayudante’ hace el trabajo.</p>
<p>Aquí hay dos definiciones para añadir números. Son así de simple, aunque se encuentre duro de comprender.</p>
<pre><code class="example">(defun triangle-initialization (number)
  &quot;Devuelve la suma de los números 1 a través de NUMBER inclusive.
Este es el componente de ‘inicialización’ de una función dúo que
usa recursión&quot;
  (triangle-recursive-helper 0 0 number))</code></pre>
<pre><code class="example">(defun triangle-recursive-helper (sum counter number)
  &quot;Devuelve SUM, usando COUNTER, a través de NUMBER inclusive.
Este es el componente ‘helper’ de unas dos funciones
que usan recursión.&quot;
  (if (&gt; counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; @e{suma}
                               (1+ counter)     ; @e{contador}
                               number)))        ; @e{número}</code></pre>
<p>Instalar ambas definiciones de función por evaluarlo, entonces llama a <code>triangle-initialization</code> con 2 filas:</p>
<pre><code class="example">(triangle-initialization 2)
    ⇒ 3</code></pre>
<p>La función ‘inicialización’ llama la primera instancia de la función ‘ayudante’ con tres argumentos: cero, cero, y un número que es el número de filas en el triángulo.</p>
<p>Los primeros dos argumentos pasaron a la función ‘ayuda’ son valores de inicialización. Estos valores son cambiados cuando <code>triangle-recursive-helper</code> invocan nuevas instancias.<span class="note" ><sup><a href="#12" >12</a></sup></span></p>
<p>Permítase ver que ocurre cuando tenemos un triángulo que tiene una fila. (¡Este triángulo tendrá un asterisco dentro!)</p>
<p><code>triangle-initialization</code> llamará su ayudante con los argumentos <code>0 0 1</code>. Esta función ejecutará el test condicional si <code>(&gt; counter number)</code>:</p>
<pre><code class="example">(&gt; 0 1)</code></pre>
<p>y encuentra que el resultado es falso, así invocará la else-part de la claúsula <code>if</code>:</p>
<pre><code class="example">    (triangle-recursive-helper
     (+ sum counter)  ; @e{sum más counter} ⇒ @e{sum}
     (1+ counter)     ; @e{incrementa counter} ⇒ @e{counter}
     number)          ; @e{number parece lo mismo}</code></pre>
<p>que computará primero:</p>
<pre><code class="example">(triangle-recursive-helper (+ 0 0)  ; @e{sum}
                           (1+ 0)   ; @e{counter}
                           1)       ; @e{number}
que es:

(triangle-recursive-helper 0 1 1)</code></pre>
<p>De nuevo, <code>(&gt; counter number)</code> será falso, así de nuevo, el intérprete Lisp evaluará <code>triangle-recursive-helper</code>, creando una nueva instancia con nuevos argumentos.</p>
<p>Esta nueva instancia será;</p>
<pre><code class="example">    (triangle-recursive-helper
     (+ sum counter)  ; @e{suma más contador} ⇒ @e{sum}
     (1+ counter)     ; @e{incrementar contador} ⇒ @e{contador}
     number)          ; @e{número empieza lo mismo}

que es:

(triangle-recursive-helper 1 2 1)</code></pre>
<p>En este caso, el test <code>(&gt; counter number)</code> ¡será cierto!  Así la instancia devolverá el valor de la suma, que será 1, como se espera.</p>
<p>Ahora, permite pasar <code>triangle-initialization</code> un argumento de 2, para encontrar cuántos asterisco hay en un triángulo con dos filas.</p>
<p>Esta función llama <code>(triangle-recursive-helper 0 0 2)</code>.</p>
<p>En fases, las instancias llamadas serán:</p>
<pre><code class="example">                          @e{suma contador número}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)</code></pre>
<p>Cuando la última instancia se llama, el <code>(&gt; counter number)</code> se chequea si será cierto, así la instancia devolverá el valor de <code>sum</code>, que será 3.</p>
<p>Este tipo de patrón ayuda cuando estás escribiendo funciones que puede usar recursos en un ordenador.</p>
</div>
<h3 id="Ejercicio-de-bucles" >Ejercicio de bucles</h3>
<div class="hBody-3" >
<ul>
<li><p>Escribe una función similar a <code>triangle</code> en el que cada fila tiene un valor que es la raíz del número de la fila. Usa un bucle <code>while</code>.</p>
</li>
<li><p>Escribe una función similar para <code>triangle</code> que multiplique en vez de añadir los valores.</p>
</li>
<li><p>Reescribe estas dos funciones recursivamente. Reescribe estas funciones usando <code>cond</code>.</p>
</li>
<li><p>Escribe una función para el modo Texinfo que crea una entrada índice al principio de un párrafo para cada <samp>@dfn</samp> con el párrafo. (En un fichero Texinfo, <samp>@dfn</samp> marca una definición. El libro es escrito en Texinfo.)</p>
<p>Muchas de las funciones necesitarán ser descritas en dos de los capítulos, <a href="Corte-y-Almacenamiento-de-Texto" >Corte y Almacenamiento de Texto</a> y <a href="Pegando-texto" >Pegando texto</a>. Si usas <code>forward-paragraph</code> para poner la entrada índice al principio del párrafo, tendrá que usar <kbd>C-h f</kbd> (<code>describe-function</code>) para encontrar cómo conseguir que el comando vaya hacia atrás.</p>
</li>
</ul>
<p>Para más información, ver “Indicando Definiciones, Comandos, etc.” en <em>Texinfo</em> el <em>Formato de Documentación de GNU</em>.</p>
</div>
<h2 id="Búsquedas-de-expresiones-regulares" >Búsquedas de expresiones regulares</h2>
<div class="hBody-2" >
<p>Las búsquedas expresiones regulares son usadas extensivamente en GNU Emacs. Las dos funciones <code>forward-sentence</code> y <code>forward-paragraph</code>, ilustran estas búsquedas bien. Usan expresiones regulares para encontrar donde mover el punto. La frase ‘expresión regular’ es con frecuencia escrita como ‘regexp’.</p>
<p>Las búsquedas de expresiones regulares son descritas en Seccion <cite>Búsqueda de Expresión Regular</cite> en <em>El Manual de GNU Emacs</em>, tan bien como en Seccion <cite>Expresiones Regulares</cite> <em>El Manual de Referencia de GNU Emacs Lisp</em>. Escribiendo este capítulo, estoy presuponiendo que tiene al menos una familiaridad con esto. El mayor punto para recordar es que las expresiones regulares te permiten buscar patrones tan bien como para cadenas literales de caracteres. Por ejemplo, el código en <code>forward-sentence</code> busca para el patrón de posibles caracteres que podrían marcar el fin de una frase, y mueve el punto al otro lado.</p>
<p>Antes de mirar en el código la función <code>forward-sentence</code>, es valorable considerar que el patrón que marca el fin de una frase debe estar. El patrón se discute en la siguiente sección; siguiendo que es una descripción de la expresión regular de búsqueda, <code>re-search-forward</code>. La función <code>forward-sentence</code> es descrito en la sección siguiente. Finalmente, la función <code>forward-paragraph</code> es descrito en la última sección de este capítulo. <code>forward-paragraph</code> es una función compleja que introduce varias funcionalidades.</p>
</div>
<h3 id="La-expresión-regular-para-sentence-end" >La expresión regular para <code>sentence-end</code></h3>
<div class="hBody-3" >
<p>El símbolo <code>sentence-end</code> se asocia al patrón que marca el fin de una frase. ¿Cuál sería esta expresión regular?</p>
<p>Claramente, una frase puede ser finalizada por un periodo, una marca de inicio de interrogación, o una marca de exclamación. Puesto que viene del inglés, solo las claúsulas que finalizan con uno de estos tres caracteres deberían ser consideradas al fin de una frase. Esto significa que el patrón incluiría el conjunto de caracteres:</p>
<pre><code class="example">[.?!]</code></pre>
<p>Sin embargo, no queremos que <code>forward-sentence</code> salte a un periodo, una marca de pregunta, o una marca de exclamación, porque tal carácter podría ser usado en el medio de una frase. Un periodo, por ejemplo, se usa después de abreviaciones. Así, otra información es necesaria.</p>
<p>De acuerdo a la convención, escribe dos espacios después de cada frase, pero solo un espacio después de un periodo, una marca de pregunta, o una marca de exclamación seguida por dos espacios es un buen indicador de un fin de frase. Sin embargo, en un fichero, los dos espacios pueden ser un tabulador o el fin de una línea. Esto significa que la expresión regular incluiría estos tres ítems como alternativas.</p>
<p>Este grupo de alternativas se parece a esto:</p>
<pre><code class="example">\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC</code></pre>
<p>Aquí, <samp>$</samp> indica el fin de la línea, y yo he apuntado donde el tab y dos espacios están insertados en la expresión. Ambos están insertados poniendo los caracteres actuales dentro de la expresión.</p>
<p>Dos barras invertidas, <samp>\\</samp>, se requiere antes de los paréntesis y barras verticales: la primera barra invertida cita la siguiente barra invertida en Emacs; y el segundo indica que el siguiente caracter, el paréntesis o la barra vertical, es especial.</p>
<p>También, una frase puede ser seguida por uno o más retornos de carro, como este:</p>
<pre><code class="example">[
]*</code></pre>
<p>Como en los tabuladores y espacios, un retorno de carro se inserta dentro de una expresión regular insertándolo literalmente. El asterisco indica que el <kbd>RET</kbd> se repite cero o más veces.</p>
<p>Pero una frase no consiste solo en un periodo, una marca de pregunta o una marca de exclamación seguida por espacios apropiados: una marca de cerrar comillas o cerrar un paréntesis de algún tipo puede preceder el espacio. En realidad más de una marca o paréntesis pueden preceder el espacio. Estas requieren una expresión que se parezca a:</p>
<pre><code class="example">[]\&quot;')@}]*</code></pre>
<p>En esta expresión, el primer <samp>]</samp> es el primer caracter en la expresión; el segundo caracter es <samp>&quot;</samp>, que está precedido por un <samp>\</samp> para contar Emacs el <samp>&quot;</samp> <em>no</em> es especial. Los últimos tres caracteres son <samp>'</samp>, <samp>)</samp>, y <samp>}</samp>.</p>
<p>Todo esto sugiere que el patrón de la expresión regular para asociar el fin de una frase sería; y, profundamente, si se evalúa <code>sentence-end</code> y encuentra que se devuelve el valor siguiente:</p>
<pre><code class="example">sentence-end
     ⇒ &quot;[.?!][]\&quot;')@}]*\\($\\|     \\|  \\)[
]*&quot;</code></pre>
<p>(Bien, no en GNU Emacs 22; porque es un esfuerzo crear el proceso simple y manejar más símbolos y lenguajes. Cuando el valor de <code>sentence-end</code> es <code>nil</code>, entonces usa el valor definido por la función <code>sentence-end</code> es <code>nil</code>, entonces usa el valor definido por la función <code>sentence-end</code>. (Aquí se usa la diferencia entre un valor y una función en Emacs Lisp.) La función devuelve un valor construido desde las variables <code>sentence-end-base</code>, <code>sentence-end-double-space</code>, <code>sentence-end-without-period</code>, y <code>sentence-end-without-space</code>. La variable crítica es <code>sentence-end-base</code>; su valor global es similar a uno descrito debajo pero también contiene marcas de cita adicionales. Estas tienen diferentes grados de curvas. La variable <code>sentence-end-without-period</code>, cuando es verdad, dice a Emacs que una frase puede finalizar sin un periodo tal como texto en Thai.)</p>
</div>
<h3 id="La-función-re-search-forward" >La función <code>re-search-forward</code></h3>
<div class="hBody-3" >
<p>La función <code>re-search-forward</code> es similar a la función <code>search-forward</code>. (Véase Sección <a href="La-Función-search-forward" >La Función <code>search-forward</code></a>.)</p>
<p><code>re-search-forward</code> busca una expresión regular. Si la búsqueda es exitosa, deja el punto inmediatamente después del último caracter en el objetivo. Si la búsqueda es hacia atrás, deja el punto antes del primer caracter en el objetivo. Se puede contar <code>re-search-forward</code> para devolver <code>t</code> a cierto. (Moviendo el punto es por ello un ‘efecto lateral’.)</p>
<p>Como <code>search-forward</code>, la función <code>re-search-forward</code> toma cuatro argumentos:</p>
<ol>
<li><p>El primer argumento es la expresión regular que la función busca. La expresión regular será una cadena entre comillas.</p>
</li>
<li><p>El segundo argumento opcional limita cómo la función busca; es un emparejamiento, que se especifica como una posición en el búffer.</p>
</li>
<li><p>El tercer argumento opcional especifica cómo la función responde al fallo: <code>nil</code> como tercer argumento que causa la función para señalar un error (e imprime un mensaje) cuando la búsqueda falla; cualquier otro valor causa devolver <code>nil</code> si la búsqueda falla y <code>t</code> si la búsqueda tiene éxito.</p>
</li>
<li><p>El cuarto argumento opcional es el contaje repetido. Un contaje negativo repetido causa <code>re-search-forward</code> para buscar hacia atrás.</p>
</li>
</ol>
<p>La plantilla para <code>re-search-forward</code> se parece a esto:</p>
<pre><code class="example">(re-search-forward &quot;@V{regular-expression}&quot;
                @V{limit-of-search}
                @V{what-to-do-if-search-fails}
                @V{repeat-count})</code></pre>
<p>El segundo, tercer, y cuarto argumentos son opcionales. Sin embargo, si se quiere pasar un valor a uno o ambos de los últimos dos argumentos, se debe también pasar un valor a todos los argumentos precedentes. De otro modo, el intérprete Lisp errará a qué argumento estás pasando el valor.</p>
<p>En la función <code>forward-sentence</code>, la expresión regular será el valor de la variable <code>sentence-end</code>. En forma simple, esto es:</p>
<pre><code class="example">&quot;[.?!][]\&quot;')@}]*\\($\\|  \\|  \\)[
]*&quot;</code></pre>
<p>El límite de la búsqueda será el fin del párrafo (desde una frase no puede ir bajo un párrafo). Si la búsqueda falla, la función devuelve <code>nil</code>, y el contaje repite será provisto por el argumento para la función <code>forward-sentence</code>.</p>
</div>
<h3 id="La-función-forward-sentence" >La función <code>forward-sentence</code></h3>
<div class="hBody-3" >
<p>El comando mueve el cursor hacia adelante una frase es una ilustración honesta de cómo usar búsquedas de expresiones regulares en Emacs Lisp. En realidad, la función parece más larga y más complicada de lo que es; esto es porque la función está diseñada para ir hacia atrás tan bien como hacia adelante; y, opcionalmente, a través de una frase. La función está normalmente asociada al comando <kbd>M-e</kbd>.</p>
<p>Aquí está la código para <code>forward-sentence</code>:</p>
<pre><code class="example">(defun forward-sentence (&amp;optional arg)
  &quot;Ve al siguiente ‘sentence-end’. Con el argumento, repite.
Con el argumento negativo, mueve atrás repetidamente a ‘sentence-beginning’.
La variable ‘sentence-end’ es una expresión regular que empareja el
fin de frases. También, cada párrafo asociado termina las frases
bien.
  (interactive &quot;p&quot;)
  (or arg (setq arg 1))
  (let ((opoint (point))
        (sentence-end (sentence-end)))
    (while (&lt; arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       (if (and (re-search-backward sentence-end par-beg t)
                (or (&lt; (match-end 0) pos)
                    (re-search-backward sentence-end par-beg t)))
           (goto-char (match-end 0))
         (goto-char par-beg)))
      (setq arg (1+ arg)))
    (while (&gt; arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward &quot; \t\n&quot;)
         (goto-char par-end)))
      (setq arg (1- arg)))
    (constrain-to-field nil opoint t)))</code></pre>
<p>La función se ve larga a primera vista y es mejor mirar primero el esqueleto, y entonces su músculo. El camino para ver el esqueleto es mirar en las expresiones que empiezan las columnas más a la izquierda:</p>
<pre><code class="example">(defun forward-sentence (&amp;optional arg)
  &quot;@V{documentation}…&quot;
  (interactive &quot;p&quot;)
  (or arg (setq arg 1))
  (let ((opoint (point)) (sentence-end (sentence-end)))
    (while (&lt; arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       @V{rest-of-body-of-while-loop-when-going-backwards}
    (while (&gt; arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       @V{rest-of-body-of-while-loop-when-going-forwards}
    @V{handle-forms-and-equivalent}</code></pre>
<p>¡Esto parece bastante simple! La definición de la función consiste de documentación una expresión <code>interactive</code>, una expresión <code>or</code>, una expresión <code>let</code>, y bucles <code>while</code>.</p>
<p>Permite mirar cada una de estas partes.</p>
<p>Notamos que la documentación es profunda y comprensible.</p>
<p>La función tiene una declaración <code>interactive &quot;p&quot;</code>. Esto signifca que el argumento prefijo, si cualquiera es pasado a la función como su argumento. (Esto será un número.) Si la función no pasa un argumento (eso es opcional) entonces el argumento <code>arg</code> será asociado a 1.</p>
<p>Cuando <code>forward-sentence</code> se llama no interactivamente sin un argumento, <code>arg</code> está asignado <code>nil</code>. La expresión <code>or</code> maneja esto. Lo que hace es dejar el valor de <code>arg</code> como eso es, pero solo si <code>arg</code> está asignado a un valor; o eso asigna el valor de <code>arg</code> a 1, en el caso de <code>arg</code> está asignado a <code>nil</code>.</p>
<p>Lo siguiente es un <code>let</code>. Que especifica los valores de dos variables locales <code>point</code> y <code>sentence-end</code>. El valor local de punto, desde antes de la búsqueda, es usada en la función <code>constrain-to-field</code> que maneja formularios y equivalentes. La variable <code>sentence-end</code> está asignada por la función <code>sentence-end</code>.</p>
</div>
<h4 id="Los-bucles-while" >Los bucles <code>while</code></h4>
<div class="hBody-4" >
<p>Sigue dos bucles <code>while</code>. El primer <code>while</code> tiene un true-or-false-test que chequea cierto si el argumento prefijo para <code>forward-sentence</code> es un número negativo. Esto es para volver hacia atrás. El cuerpo de este bucle es similar al cuerpo de la segunda cláusula <code>while</code>, pero eso no es exactamente el mismo. Se obviará este bucle <code>while</code> y concentra en el segundo bucle <code>while</code>.</p>
<p>El segundo bucle <code>while</code> está moviendo el punto hacia adelante. Su esqueleto se parece a esto:</p>
<pre><code class="example">(while (&gt; arg 0)            ; @e{true-or-false-test}
  (let @V{varlist}
    (if (@V{true-or-false-test})
        @V{then-part}
      @V{else-part}
  (setq arg (1- arg))))     ; @c{while} @e{loop decrementer}</code></pre>
<p>El bucle <code>while</code> es el tipo de decremento. (Véase Sección <a href="Los-bucles-while" >Los bucles <code>while</code></a>.) Eso tiene un true-or-false-test que chequea cierto tan largo con el contador (en este caso, la variable <code>arg</code>) es mayor que cero; y eso tiene un decremento que elimina 1 desde el valor del contador cada vez que el bucle se repite.</p>
<p>Si ningún argumento prefijo es dado para <code>forward-sentece</code>, que es el camino más común es usado, este bucle <code>while</code> ejecutará una vez, desde que el valor de <code>arg</code> será 1.</p>
<p>El cuerpo del cuerpo <code>while</code> consite de una expresión <code>let</code>, que crea y asocia una variable local, y tiene, su cuerpo, una expresión <code>if</code>.</p>
<p>El cuerpo del bucle <code>while</code> se parece a esto:</p>
<pre><code class="example">(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward &quot; \t\n&quot;)
    (goto-char par-end)))</code></pre>
<p>La expresión <code>let</code> crea y asocia la variable local <code>par-end</code>. Como se ve, esta variable local está diseñada para proporcionar una asociación o límite para la búsqueda de la expresión regular. Si la búsqueda falla para encontrar una frase apropiada finalizando en el párrafo, eso se parará logrando el fin del párrafo.</p>
<p>Pero primero, permítenos examinar cómo <code>par-end</code> se asocia a la variable del fin del párrafo. Lo que ocurre es que el <code>let</code> asigna el valor de <code>par-end</code> al valor devuelto cuando el intérprete evalúa la expresión.</p>
<pre><code class="example">(save-excursion (end-of-paragraph-text) (point))</code></pre>
<p>En esta expresión, <code>(end-of-paragraph-text)</code> mueve el punto al fin del párrafo, <code>(point)</code> devuelve el valor del punto, y entonces <code>save-excursion</code> restaura el punto a su posición original. De este modo, el <code>let</code> asocia <code>par-end</code> al valor devuelto por la expresión <code>save-excursion</code>, que es la posición del fin del párrafo.  (La función <code>end-of-paragraph-text</code> usa <code>forward-paragraph</code>, que se discutirá pronto.)</p>
<p>Emacs evalúa el cuerpo del <code>let</code>, que es una expresión <code>if</code> que se parece a esto:</p>
<pre><code class="example">(if (re-search-forward sentence-end par-end t) ; @e{if-part}
    (skip-chars-backward &quot; \t\n&quot;)              ; @e{then-part}
  (goto-char par-end)))                        ; @e{else-part}</code></pre>
<p>El test <code>if</code> si su primer argumento es cierto y si así, evalúa su parte then; de otro modo, el intérprete Emacs Lisp evalúa la parte else. El true-or-false-test de la expresión <code>if</code> es la búsqueda de la expresión regular.</p>
<p>Puede estar mal tener que mirar como el ‘trabajo real’ de la función <code>forward-sentence</code> es vista aquí, pero esto es un camino común de este tipo de operación traida en Lisp.</p>
</div>
<h4 id="La-búsqueda-de-expresiones-regulares" >La búsqueda de expresiones regulares</h4>
<div class="hBody-4" >
<p>La función <code>re-search-forward</code> busca el fin de la frase, que es, para el patrón definido por la expresión regular <code>sentence-end</code>. Si el patrón es encontrado––si el fin de la frase se encuentra––entonces la función <code>re-search-forward</code> hace dos cosas:</p>
<ol>
<li><p>La función <code>re-search-forward</code> trae un efecto secundario, que es mover el punto al final de la ocurrencia encontrada.</p>
</li>
<li><p>La función <code>re-search-forward</code> devuelve un valor de verdad. Esto es el valor recibido por el <code>if</code>, y significa que la búsqueda fué exitosa.</p>
</li>
</ol>
<p>El efecto secundario, el movimiento del punto se completa antes de la función <code>if</code> y es manejado por el valor devuelto por la exitosa conclusión de la búsqueda.</p>
<p>Cuando la función <code>if</code> recibe el valor de verdad desde una llamada exitosa a <code>re-search-forward</code>, el <code>if</code> evalúa la parte then que es la expresión <code>(skip-chars-backward &quot;\t\n&quot;)</code>. Esta expresión se mueve atrás a través de espacios en blanco, los tabuladores o retornos de carro hasta un caracter impreso es encontrado y entonces deja el punto correcto después del caracter impreso cerrado de la frase, que es normalmente un periodo.</p>
<p>Por otro lado, si la función <code>re-search-forward</code> falla para encontrar un patrón marcando el fin de la frase, la función devuelve falso. Lo falso causa el <code>if</code> para evaluar su tercer argumento, que es <code>(goto-char par-end)</code>: eso mueve el punto al final del párrafo.</p>
<p>(Y si el texto está en una forma o equivalente, y apunta a que no puede moverse completamente entonces la función <code>constrain-to-field</code> empieza a funcionar.)</p>
<p>Las búsquedas de expresiones regulares son excepcionalmente útiles y el patrón ilustrado por <code>re-search-forward</code>, en el que la búsqueda es el test de una expresión <code>if</code>, es manejable. Se verá o escribirá código incorporando este patrón con frecuencia.</p>
</div>
<h3 id="forward-paragraph:-una-mina-de-oro-de-funciones" ><code>forward-paragraph</code>: una mina de oro de funciones</h3>
<div class="hBody-3" >
<p>La función <code>forward-paragraph</code> mueve el punto al fin del párrafo. Eso está normalmente asociado a <kbd>M-}</kbd> y hace uso de un número de funciones que son importantes en sí, incluyendo <code>let*</code>, <code>match-beginning</code>, y <code>looking-at</code>.</p>
<p>La definición de función para <code>forward-paragraph</code> es considerablemente mayor que la definición de función para <code>forward-sentence</code> porque eso funciona como un párrafo, cada línea puede empezar con un prefijo de relleno <em>fill prefix</em>.</p>
<p>Un prefijo de relleno <em>fill prefix</em> consiste en una cadena de caracteres que se repite al principio de cada línea. Por ejemplo, en código Lisp, es una convención para empezar cada línea de un comentario de párrafo largo con <samp>;;; </samp>. En modo Texto, cuatro espacios en blanco crean otro prefijo de relleno <em>fill prefix</em> común, creando un párrafo indentado. (Véase Sección <cite>Fill Prefix</cite> en <em>The GNU Emacs Manual</em> para más información acerca de prefijos de relleno <em>fill prefix</em>.)</p>
<p>La existencia de un prefijo de relleno significa que además de ser capaz de encontrar el fin de un párrafo cuyas líneas empiezan más a la izquierda, la función <code>forward-paragraph</code> debe ser capaz de encontrar el fin de un párrafo cuando todas o muchas de las líneas en el búffer empiezan con el prefijo de relleno <em>fill prefix</em>.</p>
<p>Más allá, es algunas veces práctico ignorar un prefijo de relleno <em>fill prefix</em> que existe, especialmente cuando las líneas en blanco separen párrafos. Esto es una complicación añadida.</p>
<p>En vez de imprimir toda la función <code>forward-paragraph</code>, nosotros solo imprimiremos partes de la misma. ¡Lee sin preparación, la función puede estar para desanimar!</p>
<p>En esquema, la función se parece a esto:</p>
<pre><code class="example">(defun forward-paragraph (&amp;optional arg)
  &quot;@V{documentation}…&quot;
  (interactive &quot;p&quot;)
  (or arg (setq arg 1))
  (let*
      @V{varlist}
    (while (and (&lt; arg 0) (not (bobp)))     ; @e{backward-moving-code}
      …
    (while (and (&gt; arg 0) (not (eobp)))     ; @e{forward-moving-code}
      …</code></pre>
<p>Las primeras partes de la función son rutinas: la función lista argumentos que consisten de un argumento opcional. La documentación sigue.</p>
<p>La letra minúscula <samp>p</samp> en la declaración <code>interactive</code> significa que el argumento prefijo se procesa, si se pasa a la función. Eso será un número, y es el contaje repetido de cuántos párrafos se moverá.  La expresión <code>or</code> en la siguiente línea maneja el caso común cuando no hay argumentos que se pasan a la función, esto ocurre si la función se llama desde otro código en vez de interactivamente. Este caso se describe pronto. (Véase Sección <a href="La-función-forward-sentence" >La función <code>forward-sentence</code></a>.) Ahora se logra el fin de la parte familiar de esta función.</p>
</div>
<h4 id="La-expresión-let*" >La expresión <code>let*</code></h4>
<div class="hBody-4" >
<p>La siguiente línea de la función <code>forward-paragraph</code> empieza una expresión <code>let*</code>. Esto es tan diferente como <code>let</code>. El símbolo es <code>let*</code> no <code>let</code>.</p>
<p>La forma especial <code>let*</code> es como <code>let</code> excepto que Emacs asigna cada variable en secuencia, una después de otra, y las variables en la última parte de la varlist hacen uso de los valores para los que Emacs asignó variable al principio la varlist.</p>
<p>(Seccion <a href="La-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></a>.)</p>
<p>En la expresión <code>let*</code> en esta función, Emacs asigna un total de siete variables: <code>opoint</code>, <code>fill-prefix-regexp</code>, <code>parstart</code>, <code>parsep</code>, <code>sp-parstart</code>, <code>start</code>, y <code>found-start</code>.</p>
<p>La variable <code>parsep</code> aparece dos veces, primero, para borrar instancias de <samp>^</samp>, y segundo, para manejar prefijos rellenos.</p>
<p>La variable <code>opoint</code> es solo el valor de <code>point</code>. Como se puede adivinar, eso se usa en una expresión <code>constrain-to-field</code>, solo como en <code>forward-sentence</code>.</p>
<p>La variable <code>fill-prefix-regexp</code> se asigna al valor devuelto para evaluar la siguiente lista:</p>
<pre><code class="example">(and fill-prefix
     (not (equal fill-prefix &quot;&quot;))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))</code></pre>
<p>Esta es una expresión cuyo primer elemento es la forma especial <code>and</code>.</p>
<p>Como se aprendió antes la (Vease Sección <a href="Función-kill-new,-,-La-función-kill-new" >Función kill-new, , La función <code>kill-new</code></a>), la forma especial <code>and</code> evalúa cada uno de sus argumentos hasta uno de los argumentos y devuelve un valor de <code>nil</code> en el que el caso de la expresión <code>and</code> devuelve <code>nil</code>; sin embargo, si ninguno de los argumentos devuelve un valor de <code>nil</code>, el valor resultante de evaluar el último argumento es devuelto. (Puesto que tal valor no es <code>nil</code>, eso es considerado verdad en Lisp.) En otras palabras, una expresión <code>and</code> devuelve un valor de verdad solo si todos sus argumentos son verdad.  @findex and</p>
<p>En este caso, la variable <code>fill-prefix-regexp</code> está asociado a un valor no <code>nil</code> solo si el las siguientes cuatro expresiones producen un valor true (por ej., un no <code>nil</code>) cuando son evaluados; de otro modo, <code>fill-prefix-regexp</code> está asociado a <code>nil</code>.</p>
<dl>
<dt><p>fill-prefix</p>
</dt>
<dd><p>Cuando esta variable se evalúa, el valor del prefijo de relleno <em>fill prefix</em>, si cualquiera, está devuelto. Si no hay prefijo relleno, la variable devuelve <code>nil</code>.</p>
</dd>
<dt><p>(not (equal fill-prefix &quot;&quot;)</p>
</dt>
<dd><p>Esta expresión chequea si un prefijo lleno es una cadena vacía, que es, una cadena sin caracteres en eso. Una cadena vacía no es útil un prefijo relleno <em>fill prefix</em>.</p>
</dd>
<dt><p>(not paragraph-ignore-fill-prefix)</p>
</dt>
<dd><p>Esta expresión devuelve <code>nil</code> si la variable <code>paragraph-ignore-fill-prefix</code> ha sido cambiado siendo asignado un valor de verdad tal como <code>t</code>.</p>
</dd>
<dt><p>(regexp-quote fill-prefix)</p>
</dt>
<dd><p>Este es el último argumento para la forma especial <code>and</code>. Si todos los argumentos de <code>and</code> son verdaderos, el valor resultante de evaluar esta expresión será devuelto por la expresión <code>and</code> y asociado a la variable <code>fill-prefix-regexp</code>,</p>
</dd>
</dl>
<p>El resultado de evaluar esta expresión <code>and</code> con éxito es que <code>fill-prefix-regexp</code> se asociará al valor de <code>fill-prefix</code> como fué modificado por la función <code>regexp-quote</code>. Lo que <code>regexp-quote</code> hace es leer una cadena y devolver la expresión regular que asociará exactamente la cadena y nada más. Esto significa que <code>fill-prefix-regexp</code> será asignada a un valor que asociará el prefijo si el prefijo existe. De otro modo, la variable será asignada a <code>nil</code>.</p>
<p>Las dos variables locales siguientes en la expresión <code>let*</code> están diseñadas para eliminar instancias de <samp>^</samp> desde <code>parstart</code> y <code>parsep</code>, las variables locales indican que el párrafo empieza como separador de párrafo. La siguiente expresión asigna <code>parsep</code> de nuevo. Esto es manejar prefijos rellenos.</p>
<p>Esta es la configuración que requiere la llamada de la definición <code>let*</code> en vez de <code>let</code>. El true-or-false-test para el <code>if</code> depende de si la variable <code>fill-prefix-regexp</code> evalúa a <code>nil</code> o algún otro valor.</p>
<p>Si <code>fill-prefix-regexp</code> no tiene un valor, Emacs evalúa la parte else de la expresión <code>if</code> y asocia <code>parsep</code> a su valor local. (<code>parsep</code> es una expresión regular que asocia lo que los párrafos separan.)</p>
<p>Pero si <code>fill-prefix-regexp</code> tiene un valor, Emacs evalúa la parte then de la expresión <code>if</code> y asocia <code>parsep</code> a una expresión regular que incluye el <code>fill-prefix-regexp</code> como parte del patrón.</p>
<p>Específicamente, <code>parsep</code> está asignado al valor original del párrafo que separa la expresión regular concatenada con una expresión alternativa que consiste del <code>fill-prefix-regexp</code> seguido por espacios en blanco opcionales para el fin de la línea. El espacio en blanco está definido por <code>&quot;[ \t]*$&quot;</code>.) El <samp>\\|</samp> define esta porción del regexp como una alternativa a <code>parsep</code>.</p>
<p>De acuerdo a un comentario en el código, la siguiente variable local, <code>sp-parstart</code>, se usa para buscar, y entonces los dos finales, <code>start</code> y <code>found-start</code>, se asignan a <code>nil</code>.</p>
<p>Ahora tenemos dentro el cuerpo del <code>let*</code>. La primera parte del cuerpo del <code>let*</code> trata con el caso cuando la función es dada a un argumento negativo y consiguientemente moviéndose hacia atrás. Nosotros saldremos de esta sección yendo hacia atrás.</p>
</div>
<h4 id="El-bucle-while-hacia-adelante" >El bucle <code>while</code> hacia adelante</h4>
<div class="hBody-4" >
<p>La segunda parte del cuerpo del <code>let*</code> trata con el proceso hacia adelante. Eso es un bucle <code>while</code> que se repite si el valor de <code>arg</code> es mayor que cero. En el uso más común de la función el valor del argumento es 1, así el cuerpo del bucle <code>while</code> se evalúa exactamente una vez, y el cursor se mueve hacia adelante un párrafo.</p>
<p>Esta parte maneja tres situaciones: cuando el punto está entre párrafos, cuando hay un prefijo de relleno y cuando no hay prefijo de relleno <em>fill prefix</em>.</p>
<p>El bucle <code>while</code> se parece a esto:</p>
<pre><code class="example">;; @e{yendo hacia adelante y no al fin del búffer}
(while (and (&gt; arg 0) (not (eobp)))

  ;; @e{entre párrafos}
  ;; Mueve hacia adelante a través de líneas de
  ;; separación...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  ;;  @e{Esto decremento el bucle}
  (unless (eobp) (setq arg (1- arg)))
  ;; ... y una línea más
  (forward-line 1)

  (if fill-prefix-regexp
      ;; Hay un prefijo lleno; que sobreescribe parstart;
      ;; vamos adelante línea por línea
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

    ;; No hay prefijo;
    ;; vamos hacia adelante caracter por caracter
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))

    ;; y si no hay prefijo y si no estamos al final
    ;; ir a lo que fué encontrado en la búsqueda de expresiones regulares
    ;; para sp-parstart
    (if (&lt; (point) (point-max))
        (goto-char start))))</code></pre>
<p>Se puede ver que esto es un contador de decremento <code>while</code>, usando la expresión <code>(setq arg (1- arg))</code> como lo que se decrementa. Esta expresión no está lejos desde el <code>while</code>, pero está oculta en otra macro Lisp, una macro <code>unless</code>. A menos que estemos al final del búffer––esto es lo que la función <code>eobp</code> determina; eso es una abreviación de <samp>Fin del Buffer P</samp> --- nosotros decrementamos el valor de <code>arg</code> por uno.</p>
<p>(Si estamos al fin del búffer, no podemos ir más hacia adelante y el siguiente bucle de la expresión <code>while</code> chequeará falso desde que el test es un <code>and</code> con <code>(not (eobp))</code>. La función <code>not</code> significa exactamente como se esperaba; eso es otro nombre de <code>null</code>, una función que devuelve cierto cuando su argumento es falso.)</p>
<p>De manera interesante, el bucle cuenta que no se decrementa hasta que deje el espacio entre párrafos, a menos que vuelva al fin del búffer o pare viendo el valor local del separador del párrafo.</p>
<p>El segundo <code>while</code> también tiene una expresión <code>(move-to-left-margin)</code>. La función es autoexplicativa. Eso está dentro de una expresión <code>progn</code> y no el último elemento de su cuerpo, así es solo invocado para su efecto secundario, que es mover el punto al margen izquierdo de la línea actual.</p>
<p>La función <code>looking-at</code> es también auto-explicativa; eso devuelve cierto si el texto después del punto asocia la expresión regular dada como su argumento.</p>
<p>El resto del cuerpo del bucle se ve compleja al principio, pero tiene sentido cuando se comprende.</p>
<p>Primero considera que ocurre si hay un prefijo de relleno <em>fill prefix</em>:</p>
<pre><code class="example">(if fill-prefix-regexp
    ;; Hay un prefijo lleno; que sobreescribe parstart;
    ;; vamos adelante línea por línea
    (while (and (not (eobp))
                (progn (move-to-left-margin) (not (eobp)))
                (not (looking-at parsep))
                (looking-at fill-prefix-regexp))
      (forward-line 1))</code></pre>
<p>Esta expresión mueve el punto hacia adelante línea por línea tan lejos como que las cuatro condiciones son ciertas:</p>
<ol>
<li><p>Punto no está al final del búffer.</p>
</li>
<li><p>Podemos mover al margen izquierdo del texto y no estar al fin del búffer.</p>
</li>
<li><p>El siguiente punto no separa párrafos.</p>
</li>
<li><p>El patrón que sigue el punto es la expresión regular prefija rellena.</p>
</li>
</ol>
<p>La última condición puede ser un puzzle, hasta que se recuerde qué punto fué movido al principio de la línea temprana en la función <code>forward-paragraph</code>. Esto significa que si el texto tiene el prefijo relleno, la función <code>looking-at</code> se verá.</p>
<p>Considera qué ocurre cuando no hay un prefijo lleno.</p>
<pre><code class="example">(while (and (re-search-forward sp-parstart nil 1)
            (progn (setq start (match-beginning 0))
                   (goto-char start)
                   (not (eobp)))
            (progn (move-to-left-margin)
                   (not (looking-at parsep)))
            (or (not (looking-at parstart))
                (and use-hard-newlines
                     (not (get-text-property (1- start) 'hard)))))
  (forward-char 1))</code></pre>
<p>El bucle <code>while</code> nos tiene buscando hacia adelante para <code>sp-parstart</code>, que es la combinación de posibles espacios en blanco con un valor local del comienzo de un párrafo o de un párrafo separador. (Las últimas dos son con una expresión empezando con <code>(?:)</code> así que no están referenciadas por la función <code>match-beginning</code>.)</p>
<p>Las dos expresiones,</p>
<pre><code class="example">(setq start (match-beginning 0))
(goto-char start)</code></pre>
<p>significa ir al comienzo del siguiente texto localizado por la expresión regular.</p>
<p>La expresión <code>(match-beginning 0)</code> es nueva. Eso devuelve un número especificando la posición del comienzo del texto fuese asociado a la última búsqueda.</p>
<p>La función <code>match-beginning</code> es usado aquí porque una característica de una búsqueda hacia adelante: una búsqueda hacia adelante, sin dignidad si eso es una búsqueda plana o una expresión regular, mueve el punto al fin del texto que es encontrado. En este caso, una búsqueda exitosa mueve el punto al fin del patrón para <code>sp-parstart</code>.</p>
<p>Sin embargo, se quiere poner el punto al fin del actual párrafo, no en algún lugar más. En vez de eso, desde que la búsqueda posiblemente incluye el separador del párrafo, el punto puede finalizar al principio de lo siguiente a menos que se use una expresión que incluya <code>match-beginning</code>.</p>
<p>Cuando un argumento de 0, <code>match-beginning</code> devuelve la posición que es el comienzo del texto asociado por la búsqueda más reciente. En este caso, la búsqueda más reciente parece <code>sp-parstart</code>. La expresión <code>(match-beginning 0)</code> devuelve la posición del comienzo de este patrón, en vez de la posición final de este patrón.</p>
<p>(Incidentalmente, cuando se pasa un número positivo como un argumento, la función <code>match-beginning</code> devuelve la localización de punto en el que la expresión con paréntesis en la última búsqueda a menos que la expresión con paréntesis empiece con <code>\(?:</code>. No sé porque <code>\(?:</code> aparece aquí desde que el argumento es 0.)</p>
<p>La última expresión cuando no hay prefijos es</p>
<pre><code class="example">(if (&lt; (point) (point-max))
    (goto-char start))))</code></pre>
<p>Esto dice que si no hay prefijo lleno y no estamos al punto final que se movería al principio de lo que fué encontrado por la búsqueda de la expresión regular para <code>sp-parstart</code>.</p>
<p>La definición completa para la función <code>forward-paragraph</code> no solo incluye código para avanzar, también código para retroceder.</p>
<p>Si está leyendo esto dentro de GNU Emacs y quieres ver la función completa, se puede escribir <kbd>C-h f</kbd> (<code>describe-function</code>) y el nombre de la función. Esto da la documentación de función y el nombre de la librería conteniendo las fuentes de la función. Posiciona el punto a través del nombre de la librería y presionar la tecla RET; será tomado directamente a las fuentes. (¡Asegúrate de instalar las fuentes! ¡Sin eso, estarás como una persona que intenta conducir un coche con los ojos cerrados!)</p>
</div>
<h3 id="Crea-tu-propio-fichero-TAGS" >Crea tu propio fichero <span class="file" >TAGS</span></h3>
<div class="hBody-3" >
<p>Bajo <kbd>C-h f</kbd> (<code>describe-function</code>), otro camino para ver la fuente de una función es escribir <kbd>M-.</kbd> (<code>find-tag</code>) y el nombre de la función se asigna para eso. Esto es un buen hábito para obtenerlo. El comando <kbd>M-.</kbd> (<code>find-tag</code>) toma directamente a las fuentes de una función, variable, o nodo. La función depende de tablas de etiquetas para saber donde ir.</p>
<p>Si la función <code>find-tag</code> pregunta primero por el nombre de una tabla <span class="file" >TAGS</span>, dado el nombre de un fichero <span class="file" >TAGS</span> tal como <span class="file" >/usr/local/src/emacs/src/TAGS</span>. (La ruta exacta a tu fichero <span class="file" >TAGS</span> depende de cómo tu copia de Emacs fué instalada. Yo te cuento la localización que provee tanto mi C y mis fuentes de Emacs Lisp.)</p>
<p>Se puede también crear tu propio fichero <span class="file" >TAGS</span> para los directorios que faltan.</p>
<p>Con frecuencia se necesita construir e instalar etiquetas de tablas por uno mismo. Esas no son construidas automáticamente. Una tabla de etiquetas llama a un fichero <span class="file" >TAGS</span>; el nombre es letras mayúsculas.</p>
<p>Se puede crear un fichero <span class="file" >TAGS</span> llamando el programa <code>etags</code> que viene como parte de la distribución Emacs. Normalmente, <code>etags</code> está compilado e instalado cuando Emacs se construye. (<code>etags</code> no es una función Lisp o una parte de Emacs; eso es un programa C.)</p>
<p>Para crear el fichero <span class="file" >TAGS</span>, primero cambia el directorio en el que se quiere crear el fichero. En Emacs se puede hacer esto con el comando <kbd>M-x cd</kbd>, o visitando un fichero en el directorio, o listando el directorio <code>etags *.el</code> como el comando a ejecutar</p>
<pre><code class="example">M-x compile RET etags *.el RET</code></pre>
<p>crear un fichero de <span class="file" >TAGS</span> para Emacs Lisp.</p>
<p>Por ejemplo, si se tiene un gran número de ficheros en el directorio <span class="file" >~/emacs</span>, como se hace––Yo tengo 137 <span class="file" >.el</span> dentro, de que se carguen 12––se puede crear un fichero <span class="file" >TAGS</span> para los ficheros Emacs Lisp en este directorio.</p>
<p>El programa <code>etags</code> toma en toda la consola usual ‘comodines’. Por ejemplo, si tienes dos directorios para el que quieres un fichero <span class="file" >TAGS</span> simple, escribe <code>etags *.el ../elisp/*.el</code>, donde <span class="file" >../elisp/</span> es el segundo directorio:</p>
<pre><code class="example">M-x compile RET etags *.el ../elisp/*.el RET</code></pre>
<p>Tipo</p>
<pre><code class="example">M-x compile RET etags --help RET</code></pre>
<p>para ver una lista de las opciones aceptadas por <code>etags</code> tan bien como una lista de lenguajes soportados.</p>
<p>El programa <code>etags</code> maneja más de 20 lenguajes, incluyendo Emacs Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java, LaTeX, Pascal, Perl, Postscript, Python, TeX, Texinfo, makefiles, y la mayoría de ensambladores. El programa no cambia para especificar el lenguaje; eso reconoce el lenguaje como una entrada de fichero de acuerdo a su nombre de fichero y contenidos.</p>
<p><span class="file" >etags</span> es muy útil cuando se escribe código por tí mismo y quiere referirse a funciones que ya se han escrito. Ahora ejecuta <code>etags</code> de nuevo en intervalos como se escriben nuevas funciones, así llegan a ser parte del fichero <span class="file" >TAGS</span>.</p>
<p>Si piensa que un fichero <span class="file" >TAGS</span> apropiado que ya existe para lo que quieres, pero no conoces donde está, se puede usar el programa <code>locate</code> para intentar encontrarlo.</p>
<p>Escribe <kbd>M-x locate <kbd>RET</kbd> TAGS <kbd>RET</kbd></kbd> y Emacs listará para ti las rutas nombres completas de todos tus ficheros <span class="file" >TAGS</span>. En mi sistema, este comando lista 34 fichero <span class="file" >TAGS</span>.  Por otro lado, un sistema ‘vanilla plano’ que recientemente no contenía fichero <span class="file" >TAGS</span>.</p>
<p>Si la tabla de etiquetas que se quiere ha sido creada, se puede usar el comando <code>M-x visit-tags-table</code> para especificarlo. De otro modo, se necesitará la tabla de etiquetas por tí mismo y entonces usar <code>M-x visit-tags-table</code>.</p>
</div>
<h4 id="Construyendo-Etiquetas-en-las-fuentes-Emacs" >Construyendo Etiquetas en las fuentes Emacs</h4>
<div class="hBody-4" >
<p>Las fuentes GNU Emacs vienen con un <span class="file" >Makefile</span> que contiene un comando sofisticado <code>etags</code> que crea, recoge, y asocia tablas de etiquetas de todas las fuentes de Emacs y pone la información dentro de un fichero <span class="file" >TAGS</span> en el directorio <span class="file" >src/</span>. (El directorio <span class="file" >src/</span> está debajo del alto nivel de tu directorio Emacs.)</p>
<p>Para construir este fichero <span class="file" >TAGS</span>, se puede ir al alto nivel de directorio de fuentes Emacs y ejecutar el comando de compilar <code>make tags</code>:</p>
<pre><code class="example">M-x compile RET make tags RET</code></pre>
<p>(El comando <code>make tags</code> trabaja bien con las fuentes de GNU Emacs, tan bien como con otros paquetes fuentes.)</p>
<p>Para más información, mira <cite>Tablas de Etiquetas</cite> en <em>El Manual GNU Emacs</em>.</p>
</div>
<h3 id="Repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí hay un breve resumen de algunas funciones introducidas recientemente.</p>
<dl>
<dt><p>while</p>
</dt>
<dd><p>Repetidamente evalúa el cuerpo de la expresión tan larga como el primer elemento del cuerpo chequea cierto. Entonces devuelve <code>nil</code>. (La expresión es evaluado solo por sus efectos laterales.)</p>
<p>Por ejemplo:</p>
<pre><code class="example">(let ((foo 2))
  (while (&gt; foo 0)
    (insert (format &quot;foo is %d.\n&quot; foo))
    (setq foo (1- foo))))

     ⇒      foo is 2.
             foo is 1.
             nil</code></pre>
<p>(La función <code>insert</code> inserta sus argumentos en el punto; la función <code>format</code> devuelve una cadena formateada desde sus argumentos el camino <code>message</code> formatea sus argumentos; <code>\n</code> produce una nueva línea.)</p>
</dd>
<dt><p>re-search-forward</p>
</dt>
<dd><p>Busca un patrón, y si el patrón se encuentra, mueve el punto al resto solo después de eso.</p>
<p>Toma cuatro argumentos, como <code>search-forward</code>:</p>
<ol>
<li><p>Una expresión regular que especifica el patrón para buscarlo. (¡Recuerda por marcas de comillas alrededor de este argumento!)</p>
</li>
<li><p>Opcionalmente, el límite de la búsqueda.</p>
</li>
<li><p>Opcionalmente, que haces si la búsqueda falla, devuelve <code>nil</code> o un mensaje de error.</p>
</li>
<li><p>Opcionalmente, cuántas veces se puede repetir la búsqueda; si es negativa, la búsqueda va hacia atrás.</p>
</li>
</ol>
</dd>
<dt><p>let*</p>
</dt>
<dd><p>Asocia algunas variables localmente a valores particulares, y entonces evalúa los argumentos que permanencen, devolviendo el valor del último. Mientras se asocian las variables locales, se usan los valores locales de variables asociadas pronto, si acaso.</p>
<p>Por ejemplo:</p>
<pre><code class="example">(let* ((foo 7)
      (bar (* 3 foo)))
  (message &quot;`bar' is %d.&quot; bar))
     ⇒ `bar' is 21.</code></pre>
</dd>
<dt><p>match-beginning</p>
</dt>
<dd><p>Devuelve la posición del principio del texto encontrado por la última búsqueda de la expresión regular.</p>
</dd>
<dt><p>looking-at</p>
</dt>
<dd><p>Devuelve <code>t</code> para verdadero si el texto después del punto se asocia al argumento, que debería ser una expresión.</p>
</dd>
<dt><p>eobp</p>
</dt>
<dd><p>Devuelve <code>t</code> para cierto si el punto está en el fin de la parte accesible de un búffer. El fin de la parte accesible es el fin del búffer no está encogido; eso es el fin de la parte encogida si el búffer está encogido.</p>
</dd>
</dl>
</div>
<h3 id="Ejercicios-con-re-search-forward" >Ejercicios con <code>re-search-forward</code></h3>
<div class="hBody-3" >
<ul>
<li><p>Escribe una función para buscar para una expresión que detecte dos o más líneas blancas en secuencia.</p>
</li>
<li><p>Escribe una función para buscar palabras duplicadas, tales como ‘el el’. Véase Sección <cite>Sintaxis para Expresiones Regulares</cite> en <em>El Manual de GNU Emacs</em>, para información de cómo escribir un regexp (una expresión regular) para asociar una cadena que se compone de dos mitades idénticas. Se puede disponer de varios regexps; algunos son mejores que otros. La función que se usa es descrito en un apéndice, a lo largo de varios regexps. Véase Sección <a href="the-the,-,-Función-de-Palabras-Duplicadas-the-the" >the-the, , Función de Palabras Duplicadas <code>the-the</code></a>.</p>
</li>
</ul>
</div>
<h2 id="Contando:-repetición-y-regexps" >Contando: repetición y regexps</h2>
<div class="hBody-2" >
<p>La repetición y búsqueda de expresiones regulares son herramientas poderosas que con frecuencia se usan cuando se escribe código en Emacs Lisp. Este capítulo ilustra el uso de búsqueda de expresiones regulares a través de la construcción de comandos de contaje de palabras usando bucles <code>while</code> y recursión.</p>
<p>La distribución de Emacs estándar contiene una función para contar el número de líneas en una región.</p>
<p>Hay cierto tipo de pregunta escrita para contar palabras. De este modo, si se escribe un ensayo, puede limitarse a 800 palabras; si se escribe una novela, te puedes disciplinar a ti mismo a escribir 1000 palabras al día. Parece raro, pero durante mucho tiempo, a Emacs le faltó un comando para contar palabras. Quizás la gente usaba Emacs mayoritariamente para codificar o documentar cosas que no requieren contar palabras, o quizás se restringían al sistema operativo el comando de contar palabras, <code>wc</code>. De manera alternativa, la gente puede seguir la convención de las editoriales y computaban un contaje de palabras dividiendo el número de caracteres en un documento por cinco.</p>
<p>Hay mucho caminos para implementar un comando para contar palabras. Aquí hay algunos ejemplos, que pueden desear compararse con el comando de Emacs estándar, <code>count-words-region</code>.</p>
</div>
<h3 id="La-función-COUNT-WORDS" >La función <code><code class="verbatim" >COUNT-WORDS</code></code></h3>
<div class="hBody-3" >
<p>Un comando de contar palabras podría contar palabras en una línea, párrafo, región, o búffer. ¿Qué comando funcionaría? Se podría diseñar el comando para contar el número de palabras en un búffer completo. Sin embargo, la tradición Emacs anima a la flexibilidad––se puede querer contar palabras solo en una sección, en vez de en todo un búffer. Así, tiene más sentido diseñar el comando para contar el número de palabras en una región. Una vez tienes un comando <code>count-words-region</code>, se puede, si desea, contar palabras en un búffer completo marcándolo con <kbd>C-x h</kbd> (<code>mark-whole-buffer</code>).</p>
<p>Claramente, contar palabras es un acto repetitivo: empezando desde el principio de la región, se cuenta la primera palabra, entonces la segunda palabra, entonces la tercera palabra, y así, hasta que logres el fin de la región. Esto significa que contar palabras se ajusta idealmente a recursión o a un bucle <code>while</code>.</p>
<p>Primero, implementaremos el comando de contar palabras con un bucle <code>while</code>, entonces con la recursión. El comando, de acuerdo, será interactivo.</p>
<p>La plantilla para una definición de función interactiva es, como siempre:</p>
<pre><code class="example">(defun @V{name-of-function} (@V{argument-list})
  &quot;@V{documentation}…&quot;
  (@V{interactive-expression}…)
  @V{body}…)</code></pre>
<p>Lo que necesitamos hacer es rellenar los slots.</p>
<p>El nombre de la función sería auto-explicativo y similar al nombre del <code>count-lines-region</code> existente. Esto hace que el nombre sea fácil de recordar. <code>count-words-region</code> es una buena elección. Puesto que el nombre se usa ahora para el comando de Emacs estándar para contar palabras, nosotros nombraremos nuestra implementación como <code><code class="verbatim" >COUNT-WORDS</code></code>.</p>
<p>La función cuenta palabras con una región. Esto significa que el argumento lista debe contener símbolos que son asociados a las dos posiciones, el principio y fin de la región. Estas dos posiciones puede ser llamadas <samp>beginning</samp> y <samp>end</samp> respectivamente. La primera línea de la documentación sería una frase simple, desde que esto es todo lo que está impreso como documentación por un comando tal como <code>apropos</code>. La expresión interactiva será de la forma <samp>(interactive &quot;r&quot;)</samp>, puesto que causará que Emacs pase al principio y fin de la región a la lista de argumentos de función. Todo esto es rutina.</p>
<p>El cuerpo de la función necesita ser escrita para hacer tres tareas: primero, configurar condiciones bajo las que el bucle <code>while</code> pueda contar palabras, segundo, ejecutar el bucle <code>while</code>, y tercero, enviar un mensaje al usuario.</p>
<p>Cuando un usuario llama a <code><code class="verbatim" >COUNT-WORDS</code></code>, apunta a que puede estar al principio o fin de la región. Sin embargo, el proceso de conteo debe empezar al principio de la región. Esto significa que querremos poner el punto que hay si eso no está allí. Ejecutando <code>(goto-char beginning)</code> asegura esto. De acuerdo, querremos devolver el punto a su posición esperada cuando la función finalice su trabajo. Por esta razón, el cuerpo debe ser encerrado en una expresión <code>save-excursion</code>.</p>
<p>La parte central del cuerpo de la función consiste en un bucle <code>while</code> en el que una expresión salta el punto hacia delante palabra por palabra, y otra expresión cuenta estos saltos. Si el test-verdadero-o-falso del bucle <code>while</code> es verdadero, el punto saltaría hacia adelante, y si es falso el punto estaría al fin de la región.</p>
<p>Nosotros podríamos usar <code>(forward-word 1)</code> como la expresión para mover el punto hacia adelante palabra por palabra, pero eso es fácil de ver que Emacs identifica como una ‘palabra’ si se usa una búsqueda de expresión regular.</p>
<p>Una expresión regular busca lo que encuentra el patrón que se está buscando deja el punto después del último carácter emparejado. Esto significa que una sucesión de palabras exitosas busquen que moverá el punto adelante palabra por palabra.</p>
<p>Como materia práctica, se quiere que la expresión regular se busque para saltar a través de un espacio en blanco y puntúe entre palabras tan bien a través de las palabras en sí. Una expresión regexp que rechaza para saltar a través de espacios en blanco entre palabras ¡nunca saltaría más de una palabra!. Esto significa que el regexp incluiría el espacio en blanco y la puntuación sigue a una palabra cualquiera, como la palabra en sí. (Una palabra puede finalizar un búffer y no tiene cualquier espacio en blanco o puntuación, así esta parte del regexp debe ser opcional.)</p>
<p>De este modo, queremos para el regexp es un patrón definiendo una o más palabras de caracteres que constituyen caracteres seguidos, opcionalmente, por uno o más caracteres que no son palabras constituyentes. La expresión regular para esto es:</p>
<pre><code class="example">\w+\W*</code></pre>
<p>La tabla de sintaxis del búffer determina qué caracteres son y no son palabras constituyentes. Para más información acerca de sintaxis, Vease Sección <cite>Tablas de Sintaxis</cite> <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
<p>La expresión se parece a esto:</p>
<pre><code class="example">(re-search-forward &quot;\\w+\\W*&quot;)</code></pre>
<p>(Note que las barras invertidas que preceden el <samp>w</samp> y <samp>W</samp>. Una barra invertida tiene significado especial al intérprete Emacs Lisp. Eso indica que el caracter siguiente es interpretado de manera diferente que la normal. Por ejemplo, los dos caracteres, <samp>\n</samp>, son una <samp>nueva línea</samp>, en vez de una barra invertida seguida por <samp>\n</samp>. Dos barras invertidas en una fila para una ‘barra invertida no especial’, así Emacs Lisp interpreta el fin de mirar una barra invertida simple seguida por una letra. Así descubre la letra que es especial.)</p>
<p>Se necesita un contador para contar cuántas palabras hay; esta variables debe primero ser asignado a 0 y entonces incrementados cada vez que Emacs va alrededor del bucle <code>while</code>. La expresión de incremento es simple:</p>
<pre><code class="example">(setq count (1+ count))</code></pre>
<p>Finalmente, se quiere contar al usuario cuántas palabras hay en la región. La función <code>message</code> presenta este tipo de información al usuario. El mensaje tiene que ser fraseado de manera que se lea apropiadamente sin cuidado de cuantas palabras hay en la región: no se quiere decir que “hay una palabra en la región”. El conflicto entre singular y plural no es gramatical. Se puede resolver este problema usando una expresión condicional que evalúa diferentes mensajes dependiendo en el número de palabras en la región. Hay tres posibilidades: no palabras en la región, una palabra en la región, y más de una palabra. Esto significa que la forma especial <code>cond</code> es apropiada.</p>
<p>Todo esto lidera a la siguiente definición de función:</p>
<pre><code class="example"> ;;; @e{¡La Primera versión; tiene errores!}
 (defun count-words-region (beginning end)
   &quot;Imprime el número de palabras en la región.
 Las palabras están definidas al menos una palabra
 constituida de caracteres seguido por al menos un
 caracter que no constituye palabra. La tabla de
 sintaxis del búffer determina qué caracteres hay.&quot;
   (interactive &quot;r&quot;)
   (message &quot;Contando palaras en la región ... &quot;)

 ;;; @e{1. Configurar condiciones apropiadas.}
   (save-excursion
     (goto-char beginning)
     (let ((count 0))

 ;;; @e{2. Ejecutar el} @e{bucle} while.
       (while (&lt; (point) end)
         (re-search-forward &quot;\\w+\\W*&quot;)
         (setq count (1+ count)))

 ;;; @e{3. Enviar un mensaje al usuario.}
       (cond ((zerop count)
              (message
               &quot;La región no tiene palabras.&quot;))
             ((= 1 count)
              (message
               &quot;La región tiene 1 palabra.&quot;))
             (t
              (message
               &quot;La región tiene %d palabras.&quot; count))))))</code></pre>
<p>&lt; example..</p>
<p>Como se escribe, la función funciona, pero no en todas las circunstancias.</p>
</div>
<h4 id="El-error-de-espacio-en-blanco-en-COUNT-WORDS" >El error de espacio en blanco en <code><code class="verbatim" >COUNT-WORDS</code></code></h4>
<div class="hBody-4" >
<p>El comando <code><code class="verbatim" >COUNT-WORDS</code></code> descrito en la sección precedente tiene dos errores, o incluso, un error con dos manifestaciones. Primero, si se marca una región conteniendo solo espacio en blanco en el medio de algún texto el comando ¡<code><code class="verbatim" >COUNT-WORDS</code></code> cuenta que la región contiene una palabra!. Segundo, si se marca una región conteniendo solo espacios en blanco al final del búffer o la porción accesible de un búffer encogido, el comando muestra un mensaje de error que se parece a esto:</p>
<pre><code class="example">Búsqueda fallida: &quot;\\w+\\W*&quot;</code></pre>
<p>Si está leyendo esto en Info en GNU Emacs, se puede testear para estos errores por sí mismo.</p>
<p>Primero, evalúa la función de la manera usual para instalarlo.</p>
<p>Si se desea, se puede también instalar este atajo para ser evaluado:</p>
<pre><code class="example">(global-set-key &quot;\C-c=&quot; '@v{COUNT-WORDS})</code></pre>
<p>Para conducir el primer test, asigna marca y punto al principio y fin de la siguiente línea y entonces escribe <kbd>C-c =</kbd> (o <kbd>M-x <code class="verbatim" >COUNT-WORDS</code></kbd> si no se ha asignado <kbd>C-c =</kbd>):</p>
<pre><code class="example">    uno   dos  tres</code></pre>
<p>Emacs te contará, correctamente, que la región tiene tres palabras.</p>
<p>Repite el test, pero marca el lugar al principio de la línea y emplaza el punto justo <em>antes</em> de la palabra <samp>uno</samp>. De nuevo escribe el comando <kbd>C-c =</kbd> (o <kbd>M-x <code class="verbatim" >COUNT-WORDS</code></kbd>). Emacs cuenta que la región no tiene palabras, puesto que eso está compuesto solo por espacios en blanco al principio de la línea. ¡Pero en vez de que Emacs cuente que la región tiene una palabra!</p>
<p>Para el tercer test, copia la línea de ejemplo al fin del búffer <span class="file" >*scratch*</span> y entonces escribe varios espacios al fin de la línea. Posiciona la marca correcta después de la palabra <samp>tres</samp> y apunta al fin de la línea. (El fin de la línea será el fin del búffer.) Escribe <kbd>C-c =</kbd> (o <kbd>M-x <code class="verbatim" >COUNT-WORDS</code></kbd>) como se hizo antes. De nuevo, Emacs te contaría que la región no tiene palabras, puesto que eso está compuesto solo de los espacios en blanco al fin de la línea. En vez de eso, Emacs muestra un mensaje de error diciendo <samp>Búsqueda fallida</samp>.</p>
<p>Los dos errores queman el mismo problema.</p>
<p>Considere la primera manifestación del error, en el que el comando te cuenta que el espacio en blanco al principio de la línea contiene una palabra. Lo que ocurre es esto: El comando <code>M-x <code class="verbatim" >COUNT-WORDS</code></code> mueve el punto al principio de la región. El test <code>while</code> si el valor del punto es más pequeño de lo que el valor de <code>end</code>, que es. Por consiguiente, en la expresión regular se busca y encuentra la primera palabra. Eso deja el punto después de la palabra. <code>count</code> que se establece a uno. El bucle <code>while</code> repite; pero esta vez el valor del punto es más largo que el valor de <code>end</code>, el bucle sale; y la función muestra un mensaje diciendo el número de palabras en la región es uno. En breve, la expresión regular busca y encuentra la palabra incluso aunque eso esté fuera de la región marcada.</p>
<p>En la segunda manifestación del error, la región es un espacio en blanco al fin del búffer. Emacs dice <samp>Búsqueda fallida</samp>. Lo que ocurre es que true-or-false-test en el bucle <code>while</code> chequea verdad, así la expresión de búsqueda es ejecutada. Pero desde que no hay más palabras en el buffer, la búsqueda falla.</p>
<p>En ambas manifestaciones del error, la búsqueda extiende o intenta extenderse fuera de la región.</p>
<p>La solución es limitar la búsqueda a la región––esto es una acción simple y limpia, pero como tu puedes tener que llegar a esperar, eso no es tan simple como se podría pensar.</p>
<p>Como se ha visto, la función <code>re-search-forward</code> toma un patrón de búsqueda como su primer argumento. Pero además de este primer, argumento obligatorio, se aceptan tres argumentos opcionales. El segundo argumento opcional asocia la búsqueda. El tercer argumento opcional, si <code>t</code>, causa la función a devolver <code>nil</code> en vez de la señal un error si la búsqueda falla. El cuarto argumento opcional es un contador repetido. (En Emacs, se puede ver una documentación de la función escribiendo <kbd>C-h f</kbd>, el nombre de la función, y entonces <kbd>RET</kbd>.)</p>
<p>En la definición <code><code class="verbatim" >COUNT-WORDS</code></code>, el valor del fin de la región es tomada por la variable <code>end</code> que es pasada como un argumento para la función. De este modo, se puede añadir <code>end</code> como un argumento para la búsqueda de la expresión de búsqueda:</p>
<pre><code class="example">(re-search-forward &quot;\\w+\\W*&quot; fin)</code></pre>
<p>Sin embargo, si se crea solo este cambio a la definición <code><code class="verbatim" >COUNT-WORDS</code></code> y entonces se chequea la nueva versión de la definición en una extensión de espacio en blanco, se recibirá un mensaje de error diciendo <samp>Búsqueda fallida</samp>.</p>
<p>Lo que ocurre es esto: la búsqueda se limita a la región, y falla como se espera porque no hay caracteres de palabras constituyentes en la región. Puesto que eso falla, se recibe un mensaje de error. Pero no queremos recibir un mensaje de error en este caso; se quiere recibir el mensaje que &quot;La región no tiene palabras&quot;.</p>
<p>La solución a este problema es proveer <code>re-search-forward</code> con un tercer argumento de <code>t</code>, que causa la función para devolver <code>nil</code> en vez la señalar un error si la búsqueda falla.</p>
<p>Sin embargo, si se crea este cambio y se intenta, se verá el mensaje “Contando palabras en la región ...” y … se guardará viendo qué mensaje …, hasta que se escribe <kbd>C-g</kbd> (<code>keyboard-quit</code>).</p>
<p>Aquí está lo que ocurre: la búsqueda está limitada a la región, como antes, y eso falla porque no hay caracteres no constituyentes de palabras en la región, como se espera. Por tanto, la expresión <code>re-search-forward</code> devuelve <code>nil</code>. Eso no hace nada más. En particular, no mueve el punto, que hace como un efecto secundario si se encuentra la búsqueda objetiva. Después la expresión <code>re-search-forward</code> devuelve <code>nil</code>, la siguiente expresión en el bucle <code>while</code> está evaluado. Esta expresión incrementa el contador. Entonces el bucle repite. El test true-or-false-test chequea cierto porque el valor del punto es todavía menor que el valor final, desde que la expresión <code>re-search-forward</code> no movería el punto. … y el ciclo repite …</p>
<p>La definición <code><code class="verbatim" >COUNT-WORDS</code></code> requiere todavía de otra modificación para causar el true-or-false-test del bucle <code>while</code> para chequear falso si la búsqueda falla. Pon otro camino, hay dos condiciones que deben ser satisfechas en el true-or-false-test antes que el contador de palabras variable se incremente: el punto debe todavía estar con la región y la expresi@'n de búsqueda debe haber encontrado una palabra para contar.</p>
<p>Por ambas la primera condición y la segunda condición deben ser ciertas juntas, las dos expresiones, la región chequea y la expresión de búsqueda, puede estar unido con una forma especial <code>and</code> y embebido en el bucle <code>while</code> como el true-or-false-test, como esto:</p>
<pre><code class="example">(and (&lt; (point) end) (re-search-forward &quot;\\w+\\W*&quot; end t))</code></pre>
<p>(Para información acerca de <code>and</code>, ver <cite>La función <code>kill-new</code></cite>.)</p>
<p>La expresión <code>re-search-forward</code> devuelve <code>t</code> si la búsqueda es exitosa y como efecto secundario se mueve el punto. Consiguientemente, como las palabras se encuentran, el punto es movido a través de la región. Cuando la búsqueda de la expresión falla para encontrar otra palabra, o cuando el punto logra el fin de la región, el test true-or-false-test es falso, el bucle <code>while</code> existe, y la función <code><code class="verbatim" >COUNT-WORDS</code></code> muestra uno u otro de sus mensajes.</p>
<p>Después de incorporar estos cambios finales, el <code><code class="verbatim" >COUNT-WORDS</code></code> funciona sin errores (¡o al menos, sin los errores que yo haya encontrado!. Aquí está lo que parece:</p>
<pre><code class="example">;;; @e{Versión final:} @c{while}
(defun @v{COUNT-WORDS} (beginning end)
  &quot;Imprime número de palabras en la región.&quot;
  (interactive &quot;r&quot;)
  (message &quot;Contando palabras en la región ... &quot;)

;;; @e{1. Configura condiciones apropiadas.}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)

;;; @e{2. Ejecuta el} @e{bucle} while
      (while (and (&lt; (point) end)
                  (re-search-forward &quot;\\w+\\W*&quot; end t))
        (setq count (1+ count)))

;;; @e{3. Enviar un mensaje al usuario.}
      (cond ((zerop count)
             (message
              &quot;La región no tiene palabras.&quot;))
            ((= 1 count)
             (message
              &quot;La región tiene 1 palabra.&quot;))
            (t
             (message
              &quot;La región tiene %d palabras.&quot; count))))))</code></pre>
</div>
<h3 id="Cuenta-palabras-recursivamente" >Cuenta palabras recursivamente</h3>
<div class="hBody-3" >
<p>Se puede escribir la función para contar palabras tanto de manera recursiva como con un bucle <code>while</code>. Permita ver cómo se hace.</p>
<p>Primero, se necesita reconocer que la función <code><code class="verbatim" >COUNT-WORDS</code></code> tiene tres trabajos: eso configura las condiciones apropiadas para contar lo que ocurre; eso cuenta las palabras en la región; y envía un mensaje al usuario contando cuántas palabras hay.</p>
<p>Si se escribe una función recursiva simple para hacer cualquier cosa se recibirá un mensaje para cada llamada recursiva. Si la región contiene 13 palabras, se recibirán trece mensajes, uno correcto después del otro. ¡No queremos esto!. En vez de eso, se deben escribir dos funciones para hacer el trabajo, una (la función recursiva) será usada dentro de la otra. Una función configurará las condiciones y muestra el mensaje; la otra devolverá el contador de palabras.</p>
<p>Permítase comenzar con la función que causa el mensaje que se muestra. Se puede continuar por llamarse <code><code class="verbatim" >COUNT-WORDS</code></code>.</p>
<p>Esta es la función que el usuario llama. Será interactiva. En realidad, será similar a nuestras versiones previas de esta función, excepto que llamará <code>recursive-count-words</code> para determinar cuántas palabras hay en la región.</p>
<p>Se puede construir una plantilla legible para esta función, basada en versiones previas:</p>
<pre><code class="example">;; @e{Versión Recursiva; usa la búsqueda de la expresión regular}
(defun @v{COUNT-WORDS} (beginning end)
  &quot;@V{documentation}…&quot;
  (@V{interactive-expression}…)

;;; @e{1. Configura condiciones apropiadas.}
  (@V{explanatory message})
  (@V{set-up functions}…

;;; @e{2. Contar las palabras.}
    @V{recursive call}

;;; @e{3. Envía un mensaje al usuario.}
    @V{message providing word count}))</code></pre>
<p>La definición parece sencilla, excepto que como el contador devuelve la llamada recursiva que debe ser pasada al mensaje mostrando el contaje de palabras. Un pequeño pensamiento sugiere que esto puede ser hecho haciendo uso de una expresión <code>let</code> al número de palabras en la región, como se devuelve por la llamada recursiva; y entonces la expresión <code>cond</code>, que usa la asociación, puede mostrar el valor al usuario.</p>
<p>Con frecuencia, uno piensa que se puede asociar una expresión <code>let</code> como algo secundario al trabajo ‘primario’ de una función. Pero en este caso, se podría considerar el trabajo ‘primario’ de la función, contando palabras, esto es hecho con la expresión <code>let</code>.</p>
<p>Usando <code>let</code>, la definición de función se parece a:</p>
<pre><code class="example">(defun @v{COUNT-WORDS} (beginning end)
  &quot;Imprime el número de palabras en la región.&quot;
  (interactive &quot;r&quot;)

;;; @e{1. Configura condiciones apropiadas.}
  (message &quot;Contando palabras en la región ... &quot;)
  (save-excursion
    (goto-char beginning)

;;; @e{2. Contar las palabras.}
    (let ((count (recursive-count-words end)))

;;; @e{3. Enviar un mensaje al usuario.}
      (cond ((zerop count)
             (message
              &quot;La región no tiene palabras.&quot;))
            ((= 1 count)
             (message
              &quot;La región tiene 1 palabra.&quot;))
            (t
             (message
              &quot;La región tiene %d palabras.&quot; count))))))</code></pre>
<p>Lo siguiente, que se necesita es escribir la función de contaje recursivo.</p>
<p>Una función recursiva tiene al menos tres partes: el ‘do-again-test’, la ‘next-step-expression’, y la llamada recursiva.</p>
<p>El do-again-test determina si la función será o no llamada de nuevo. Puesto que estamos contando palabras en una región y puede causar que una función se mueva el punto hacia delante por cada palabra, el do-again-test puede chequear si el punto está todavía con la región. El do-again-test encontraría el valor del punto y determina si el punto está antes, en, o después del valor del fin de la región. Se puede usar la función <code>point</code> para localizar el punto. Claramente, se debe pasar el valor del fin de la región a la función de contaje recursivo como un argumento.</p>
<p>Además, el do-again-test también chequea si la búsqueda encuentra una palabra. Si no, la función no se llamaría de nuevo.</p>
<p>La next-step-expression cambia un valor así que cuando la función recursiva se supone que debe parar de llamarse así misma, se para. Más precisamente, los cambios de next-step-expression cambia un valor así en el momento adecuado, el do-again-test para la función recursiva de la llamada en sí de nuevo. En este caso, la next-step-expression puede ser la expresión que mueve el punto hacia adelante, palabra por palabra.</p>
<p>La tercera parte de una función recursiva es la llamada recursiva.</p>
<p>En algún lugar, también, se necesita una parte que hace el ‘trabajo’ de la función, una parte que es el contaje. ¡Una parte vital!</p>
<p>Pero ya, tenemos un guión de la función recursiva de contaje:</p>
<pre><code class="example">(defun recursive-count-words (region-end)
  &quot;@V{documentation}…&quot;
   @V{do-again-test}
   @V{next-step-expression}
   @V{recursive call})</code></pre>
<p>Ahora se necesita rellenar los slots. Permite comenzar con el caso más simple primero: si se apunta debajo del fin de la región, no puede haber palabras en la región, así la función devuelve cero. De otro modo, si la búsqueda falla no hay palabras para contar, así la función devolvería cero.</p>
<p>Por otro lado, si se apunta con la región y la búsqueda tiene éxito, la función se llamaría de nuevo.</p>
<p>De este modo, do-again-test se vería así:</p>
<pre><code class="example">(and (&lt; (point) region-end)
     (re-search-forward &quot;\\w+\\W*&quot; region-end t))</code></pre>
<p>Note que la expresión de búsqueda es parte del do-again-test --- la función devuelve <code>t</code> si su búsqueda tiene éxito y <code>nil</code> si falla. (Véase Sección <a href="Error-de-espacio-en-blanco,-,-El-Error-de-Espacio-en-Blanco-en-COUNT-WORDS" >Error de espacio en blanco, , El Error de Espacio en Blanco en <code><code class="verbatim" >COUNT-WORDS</code></code></a>), para una explicación de cómo <code>re-search-forward</code> funciona.)</p>
<p>El do-again-test es el test true-or-false de una cláusula <code>if</code>. Claramente si el do-again-test tiene éxito, la then-part de la cláusula <code>if</code> llamaría a la función; pero si eso falla, la else-part devolvería cero desde que el punto está fuera de la región o la búsqueda falló porque no había palabras a encontrar.</p>
<p>Pero antes de considerar la llamada recursiva, se necesita considerar la next-step-expression. ¿Qué es eso? De manera interesante, eso es la parte de la búsqueda del do-again-test.</p>
<p>Además para devolver <code>t</code> o <code>nil</code> para el do-again-test, <code>re-search-forward</code> mueve el punto hacia adelante como un efecto secundario de una búsqueda exitosa. Esta es la acción que cambia el valor de punto así que la función recursiva para de llamarse a sí misma cuando el punto complete su movimiento a través de la región. Por consiguiente, la expresión <code>re-search-forward</code> es la next-step-expression.</p>
<p>En esquema, entonces, el cuerpo de la función <code>recursive-count-words</code> se parece a esto:</p>
<pre><code class="example">(if @V{do-again-test-and-next-step-combined}
    ;; @e{then}
    @V{recursive-call-returning-count}
  ;; @e{else}
  @V{return-zero})</code></pre>
<p>¿Cómo incorporar el mecanismo que cuenta?</p>
<p>Si no estás acostumbrado a escribir funciones recursivas, una pregunta como esta puede ser un problema. Pero eso puede y sería enfocado sistemáticamente.</p>
<p>Se sabe que el mecanismo de contaje sería asociado en algún lugar con la llamada recursiva. En vez de eso, desde que la next-step-expression mueve el punto hacia adelante por una palabra, y desde que una llamada recursiva es hecha para cada palabra, el mecanismo de contaje debe ser una expresión que añade uno al valor devuelto por una llamada para <code>recursive-count-words</code></p>
<p>Considera varias casos:</p>
<ul>
<li><p>Si hay dos palabras en la región, la función devolverá un valor resultante de añadir uno al valor devuelto al contar la primera palabra, más el número devuelto al contar las palabras que permanecen en la región, que en este caso es una.</p>
</li>
<li><p>Si hay una palabra en la región, la función devolvería un valor resultante de añadir uno al valor devuelto cuando eso cuenta esta palabra más el número devuelto cuando eso cuenta las palabras que permanecen en la región, que en este caso es cero.</p>
</li>
<li><p>Si no hay palabras en la región, la función devolvería cero.</p>
</li>
</ul>
<p>Desde el esquema se puede ver que la parte else del <code>if</code> devuelve cero para el caso en el que no hay palabras. Esto significa que la parte then del <code>if</code> debe devolver un valor resultante de añadir uno al valor devuelto desde el contaje de las palabras que permanecen.</p>
<p>La expresión se parece a esto, donde <code>1+</code> es una función que añade uno a su argumento.</p>
<pre><code class="example">(1+ (recursive-count-words region-end))</code></pre>
<p>La función completa <code>recursive-count-words</code> entonces se parecerá e esto:</p>
<pre><code class="example">(defun recursive-count-words (region-end)
  &quot;@V{documentation}…&quot;

;;; @e{1. do-again-test}
  (if (and (&lt; (point) region-end)
           (re-search-forward &quot;\\w+\\W*&quot; region-end t))

;;; @e{2. then-part: la llamada recursiva}
      (1+ (recursive-count-words region-end))

;;; @e{3. else-part}
    0))</code></pre>
<p>Permíteme examinar cómo esto funciona:</p>
<p>Si no hay palabras en la región, la parte else de la expresión <code>if</code> es evaluada y, por tanto, la función devuelve cero.</p>
<p>Si hay una palabra en la región, el valor del punto es menor que el valor de <code>region-end</code> y la búsqueda tiene éxito. En este caso, el true-or-false-test de la expresión <code>if</code> chequea cierto, y la then-part de la expresión <code>if</code> es evaluada. La expresión de contaje se evalúa. Esta expresión devuelve un valor (que será el valor devuelto por la función completa) que es la suma de uno añadida al valor devuelto por una llamada recursiva.</p>
<p>Mientras tanto, la next-step-expression ha causado el punto para saltar a través de la primera (y en este caso única) palabra en la región. Esto significa que cuando <code>(recursive-count-words region-end)</code> está evaluada una segunda vez, como un resultado de la llamada recursiva, el valor del punto será igual o mayor que el valor de la región final. Así esta vez, <code>recursive-count-words</code> devolverá cero. El cero será añadido a uno, y la evaluación original de <code>recursive-count-words</code> devolverá uno más cero (uno) que es la cantidad correcta.</p>
<p>Claramente, si hay dos palabras en la región, la primera llamada a <code>recursive-count-words</code> devuelve uno que se añade al valor devuelto por el siguiente <code>recursive-count-words</code> en una región donde está la palabra que permanece––que es, eso añadir uno a uno, produciendo dos, que es la cantidad correcta.</p>
<p>Similarmente, si hay tres palabras en la región, la primera llamada <code>recursive-count-words</code> devuelve uno añadido al valor devuelto llamado <code>recursive-count-words</code> en una región conteniendo las dos palabras que faltan––y así.</p>
<p>Con documentación completa las dos funciones se parecen a esto:</p>
<p>La función recursiva:</p>
<pre><code class="example">(defun recursive-count-words (region-end)
  &quot;Número de palabras entre punto y REGION-END.&quot;

;;; @e{1. do-again-test}
  (if (and (&lt; (point) region-end)
           (re-search-forward &quot;\\w+\\W*&quot; region-end t))

;;; @e{2. then-part: la llamada recursiva}
      (1+ (recursive-count-words region-end))

;;; @e{3. else-part}
    0))</code></pre>
<p>El envoltorio:</p>
<pre><code class="example">;;; @e{Versión Recursiva}
(defun @v{COUNT-WORDS} (beginning end)
  &quot;Imprime el número de palabras en la región.

Las palabras son definidas como al menos una palabra constituyente
seguida por al menos un caracter que es una palabra constituyente. La
tabla de sintaxis del buffer determina qué caracter hay.
  (interactive &quot;r&quot;)
  (message &quot;Contando palabras en la región ... &quot;)
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
      (cond ((zerop count)
             (message
              &quot;La región no tiene palabras.&quot;))
            ((= 1 count)
             (message &quot;La región tiene 1 palabra.&quot;))
            (t
             (message
              &quot;La región tiene %d palabras.&quot; count))))))</code></pre>
</div>
<h3 id="Ejercicio:-contando-puntuación" >Ejercicio: contando puntuación</h3>
<div class="hBody-3" >
<p>Usando un bucle <code>while</code>, escriba una función para contar el número de marcas de puntuación en una región––periodo, coma, punto y coma, dos puntos, exclamación, marca y marca de pregunta. Haga lo mismo usando recursión.</p>
</div>
<h2 id="Contando-palabras-en-una-defun" >Contando palabras en una <code>defun</code></h2>
<div class="hBody-2" >
<p>El siguiente proyecto es contar el número de palabras en una definición de función. Claramente, esto se puede hacer usando alguna variante de <code><code class="verbatim" >COUNT-WORDS</code></code>. Véase Sección <a href="Contando-palabras,-,-Contando-palabras:-repetición-y-regexps" >Contando palabras, , Contando palabras: repetición y regexps</a>. Si se está ahora yendo a contar las palabras en una definición, es suficientemente fácil marcar la definición con el comando <kbd>C-M-h</kbd> (<code>mark-defun</code>), y entonces se llama a <code><code class="verbatim" >COUNT-WORDS</code></code>.</p>
<p>Sin embargo, soy más ambicioso: Yo quiero contar las palabras y símbolos en cada definición en las fuentes de Emacs y entonces imprimir un grafo que muestre cuántas funciones hay de cada tamaño: cuántas contienen de 40 a 49 palabras o símbolos, cuántas contienen de 50 a 59 palabras o símbolos, y así. Yo he sido con frecuencia curioso de cómo es una función típica, y esto se contará.</p>
<p>Descrito en una frase, el proyecto desanima; pero dividido dentro de numerosos pequeños pasos, cada uno de los que podemos tomar en un momento, el proyecto llegar ser menos atemorizante. Permítenos considerar qué pasos deben ser:</p>
<ul>
<li><p>Primero, escribe una función para contar las palabras en una definición. Esto incluye el problema de manejar símbolos tan bien como palabras.</p>
</li>
<li><p>Segundo, escribe una función para listar los números de palabras en cada función en un fichero. Esta función puede usar la función <code>count-words-in-defun</code>.</p>
</li>
<li><p>Tercero, escribe una función para listar los números de palabras en cada función en cada uno de varios ficheros. Esto encola automáticamente encontrando varios ficheros, cambiándolos, y contando las palabras en las definiciones con ellos.</p>
</li>
<li><p>Cuarto, escribe una función para convertir la lista de números que nosotros creamos en tres pasos para un formulario que se ajustará para imprimir un grafo.</p>
</li>
<li><p>Quinto, escribe una función para imprimir los resultados como un grafo.</p>
</li>
</ul>
<p>¡Esto es un proyecto! Pero si tomamos cada paso lentamente, eso no será difícil.</p>
</div>
<h3 id="¿Qué-contar?" >¿Qué contar?</h3>
<div class="hBody-3" >
<p>Cuando nosotros primero empezamos pensando acerca del contaje de palabras en una definición de función, la primera pregunta es (o podría ser) ¿qué se va a contar?  Cuando se habla de ‘palabras’ con repecto a una definición de función Lisp, estamos actualmente hablando, en parte, de ‘símbolos’. Por ejemplo, la siguiente función <code>multiply-by-seven</code> contiene los cinco símbolos <code>defun</code>, <code>multipy-by-seven</code>, <code>number</code>, <code>*</code>, y <code>7</code>. Además, en la cadena de documentación, contiene cuatro palabras <samp>Multiplicar</samp>, <samp>NUMBER</samp>, <samp>por</samp>, y <samp>siete</samp>. El símbolo <samp>número</samp> es repetido, así la definición contiene un total de diez palabras y símbolos.</p>
<pre><code class="example">(defun multiply-by-seven (number)
  &quot;Multiplicar NUMBER por siete.&quot;
  (* 7 number))</code></pre>
<p>Sin embargo, si se marca la definición <code>multiply-by-seven</code> con <kbd>C-M-h</kbd> (<code>mark-defun</code>), y entonces se llama a <code><code class="verbatim" >COUNT-WORDS</code></code> dentro, se encontrará que <code><code class="verbatim" >COUNT-WORDS</code></code> ¡reclama la definición tiene once palabras, no diez! ¡Alguna cosa está mal!</p>
<p>El problema es doble: <code><code class="verbatim" >COUNT-WORDS</code></code> no cuenta el <samp>*</samp> como una palabra, y eso cuenta el símbolo simple, <code>multiply-by-seven</code>, conteniendo tres palabras. Las conexiones son tratadas como si fueran espacios entre palabras en vez de conectores entre palabras <samp>multiply-by-seven</samp> se cuenta como si fuese escrito <samp>multiply-by-seven</samp>.</p>
<p>La causa de esta confusión es la expresión regular que busca la definición <code><code class="verbatim" >COUNT-WORDS</code></code> que mueve el punto hacia delante palabra por palabra. En la versión canónica de <code><code class="verbatim" >COUNT-WORDS</code></code>, el regexp es:</p>
<pre><code class="example">&quot;\\w+\\W*&quot;</code></pre>
<p>Esta expresión regular es un patrón definiendo una o más palabras constituyendo caracteres posiblemente seguidos por uno o más caracteres que no son palabras constituyentes. Esto significa que los ‘caracteres que constituyen palabras’ nos traen la cuestión de la sintaxis, que es el valor de una sección en sí.</p>
</div>
<h3 id="¿Qué-constituye-una-palabra-o-símbolo?" >¿Qué constituye una palabra o símbolo?</h3>
<div class="hBody-3" >
<p>Emacs trata diferentes caracteres perteneciendo a diferentes <dfn>categorías de sintaxis</dfn>. Por ejemplo, la expresión regular, <samp>\\w+</samp>, es un patrón especificando uno o más caracteres de <em>palabras constituyentes</em>. Los caracteres de palabras constituyentes son miembros de una categoría de sintaxis. Otras categoría de sintaxis incluye la clase de caracteres de puntuación, tales como el espacio en blanco o el caracter de tabulación. (Para más información, ver Seccion <cite>La Tabla de Sintaxis</cite> en <em>El Manual GNU Emacs</em>, y Seccion <cite>Tablas de Sintaxis) en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</cite></p>
<p>Las tablas de sintaxis especifican qué caracteres pertenecen a qué categorías. Normalmente un guión no está especificado como un ‘caracter constituido por una palabra’. En vez de eso, se especificó como estando en la ‘clase de caracteres que son parte de los nombres de símbolos, pero no las palabras.’  Esto significa que la función <code><code class="verbatim" >COUNT-WORDS</code></code> se trata del mismo modo que trata un espacio en blanco entre palabras, que es el por qué <code><code class="verbatim" >COUNT-WORDS</code></code> cuenta <samp>multiply-by-seven</samp> como tres palabras.</p>
<p>Hay dos caminos para causar que Emacs cuente <samp>multiply-by-seven</samp> como un símbolo: modificar la tabla de sintaxis o modificar la expresión regular.</p>
<p>Se podría redefinir un guión (<em>hyphen</em>) como un caracter que constituye una palabra modificando la tabla de sintaxis que Emacs guarda por cada modo. Esta acción serviría nuestro propósito, excepto que una conexión es meramente el caracter más común con símbolos que no son típicamente un caracter de palabra constituyente; hay otros, también.</p>
<p>Alternativamente, se puede redefinir la expresión regular <em>regexp</em> usada en la definición <code>count-words</code> así como incluir símbolos. Este procedimiento tiene el mérito de la claridad, pero la tarea es un pequeño truco.</p>
<p>La primera parte es suficientemente simple: el patrón debe asignarse “al menos un carácter que es una palabra o símbolo constituyente”. De este modo:</p>
<pre><code class="example">&quot;\\(\\w\\|\\s_\\)+&quot;</code></pre>
<p>El <samp>\\(</samp> es la primera parte del constructo que agrupa esto que incluye el <samp>\\w</samp> y el <samp>\\s_</samp> como alternativas, separadas por los <samp>\\|</samp>.  El <samp>\\w</samp> asocia cualquier caracter de palabra constituyente y el <samp>\\s_</samp> asocia cualquier caracter que es parte de un nombre de símbolo pero no una palabra de caracteres constituyente. El <samp>+</samp> sigue al grupo que indica que la palabra o símbolo constituyan caracteres que deben ser asociados al menos por uno.</p>
<p>Sin embargo, la segunda parte de regexp es más difícil de diseñar. Lo que queremos es seguir la primera parte con “opcionalmente uno o más caracteres que no constituyen una palabra o símbolo”. Primero, se pensaba que se podría definir esto con lo siguiente:</p>
<pre><code class="example">&quot;\\(\\W\\|\\S_\\)*&quot;</code></pre>
<p>Las mayúsculas <samp>W</samp> y <samp>S</samp> asocian caracteres que <em>no</em> son constituyente de palabra o símbolo. Desafortunadamente, esta expresión asocia cualquier caracter que sea o no una palabra constituyente no un símbolo constituyente. ¡Esto asocia cualquier caracter!</p>
<p>Entonces se notificó que cada palabra o símbolo en mi región test fué seguida por algún espacio (espacio en blanco, tabulador, o nueva línea). Así yo intenté emplazar un patrón para asociar uno o más espacios en blanco después del patrón para una o más palabras o símbolos constituyentes. Esto falló, también. Palabras y símbolos son con frecuencia separados por espacios en blanco, pero en el código actual los paréntesis pueden seguir símbolos y puntuación puede seguir las palabras. Así finalmente, se diseño un patrón en el que la palabra o símbolo constituyente es seguido opcionalmente por caracteres que no son espacios en blanco y entonces son seguidos opcionalmente por espacios en blanco.</p>
<p>Aquí está la expresión regular completa:</p>
<pre><code class="example">&quot;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&quot;</code></pre>
</div>
<h3 id="La-función-count-words-in-defun" >La función <code>count-words-in-defun</code></h3>
<div class="hBody-3" >
<p>Se ha visto que hay varios caminos para escribir una función <code>count-word-region</code>. Para escribir un <code>count-words-in-defun</code>, se necesita solamente adaptar una de estas versiones.</p>
<p>La versión que usa un bucle <code>while</code> es fácil de comprender, así estoy yendo a adaptar esto. Porque <code>count-words-in-defun</code> será parte de un programa más complejo, eso no necesita ser interactivo y no necesita mostrar un mensaje pero solo devuelve el contaje. Estas consideraciones simplifican la definición un poco.</p>
<p>Por otro lado, <code>count-words-in-defun</code> será usado con un buffer que contiene definiciones de función. Consiguientemente, es razonable preguntar que la función determina si se llamó cuando el punto está con una definición de función, y eso es, para devolver el contaje para esta definición. Esto añade complejidad a la definición, pero nos guarda desde la necesidad de pasar argumentos a la función.</p>
<p>Estas consideraciones nos llevan a preparar la siguiente plantilla:</p>
<pre><code class="example">(defun count-words-in-defun ()
  &quot;@V{documentation}…&quot;
  (@V{set up}…
     (@V{while loop}…)
   @V{return count})</code></pre>
<p>Así, el trabajo es rellenar los slots.</p>
<p>Primero, la configuración.</p>
<p>Estamos presuponiendo que esta función será llamada con un búffer conteniendo definiciones de función. Apunta si será con una definición de función o no. Para que <code>count-words-in-defun</code> funcione, el punto debe moverse al principio de la definición, un contador debe empezar a cero, y el bucle contando debe parar cuando el punto logre el fin de la definición.</p>
<p>La función <code>beginning-of-defun</code> busca atrás para un delimitador de apertura tal como <samp>(</samp> al principio de una línea, y mueve el punto a esta posición, o sino al límite de la búsqueda. En la práctica, esto significa que <code>beginning-of-defun</code> mueve el punto al principio de un cierre o definición de función precedente, o sino al principio del buffer.</p>
<p>El bucle <code>while</code> requiere un contador para guardar la traza de las palabras o símbolos siendo contados. Una expresión <code>let</code> puede ser usado para crear una variable local para este propósito, y lo asocia a un valor inicial de cero.</p>
<p>La función <code>end-of-defun</code> funciona como <code>beginning-of-defun</code> excepto que mueve el punto al fin de la definición. <code>end-of-defun</code> puede ser usado como parte de una expresión que determina la posición del fin de la definición.</p>
<p>La configuración para <code>count-words-in-defun</code> toma forma rápidamente: primero movemos el punto al principio de la definición, entonces se crea una variable local para manejar el conteo, y finalmente, se graba la posición del fin de la definición así el bucle <code>while</code> conocerá cuando parar el bucle.</p>
<p>El código se parece a esto:</p>
<pre><code class="example">(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))</code></pre>
<p>El código es simple. La única ligera complicación es probablemente ir al <code>end</code>: eso está asociado a la posición del fin de la definición por una expresión <code>save-excursion</code> que devuelve el valor del punto después de <code>end-of-defun</code> temporalmente se mueve al fin de la definición.</p>
<p>La segunda parte del <code>count-words-in-defun</code>, después de la configuración, es el bucle <code>while</code>.</p>
<p>El bucle debe contener una expresión que mueva el punto hacia adelante palabra por palabra y símbolo por símbolo, y otra expresión que cuente los saltos. El test-verdadero-o-falso para el bucle <code>while</code> chequearía verdadero tan largo como el punto debería saltar hacia adelante, y falso si apunta al fin de la definición. Ya se ha redefinido la expresión regular para esto, así el bucle es sencillo:</p>
<pre><code class="example">(while (and (&lt; (point) end)
            (re-search-forward
             &quot;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&quot; end t)
  (setq count (1+ count)))</code></pre>
<p>La tercera parte de la definición devuelve el contaje de palabras y símbolos. Esta parte es la última expresión con el cuerpo de la expresión <code>let</code>, y puede ser, muy la variable local <code>count</code>, que cuando se evalúa devuelve el contaje.</p>
<p>Puesto junto, la definición <code>count-words-in-defun</code> se ve así:</p>
<pre><code class="example">(defun count-words-in-defun ()
  &quot;Devuelve el número de palabras y símbolos en una defun.&quot;
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
    (while
        (and (&lt; (point) end)
             (re-search-forward
              &quot;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&quot;
              end t))
      (setq count (1+ count)))
    count))</code></pre>
<p>¿Cómo se chequea esto? La función no es interactiva, pero es fácil poner un envoltorio alrededor de la función para hacerla interactiva; se puede usar casi el mismo código como la versión recursiva de <code><code class="verbatim" >COUNT-WORDS</code></code>:</p>
<pre><code class="example">;;; @e{Versión Interactiva.}
(defun count-words-defun ()
  &quot;Número de palabras y símbolos en una definición
  de función.&quot;
  (interactive)
  (message
   &quot;Contando palabras y símbolos en la definición de función ... &quot;)
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       &quot;La definición NO tiene palabras o símbolos.&quot;))
     ((= 1 count)
      (message
       &quot;La definición tiene 1 palabra o símbolo.&quot;))
     (t
      (message
       &quot;La definición tiene %d palabras o símbolos.&quot; count)))))</code></pre>
<p>Permite reutilizar <kbd>C-c =</kbd> como un atajo conveniente:</p>
<pre><code class="example">(global-set-key &quot;\C-c=&quot; 'count-words-defun)</code></pre>
<p>Ahora se puede intentar <code>count-words-defun</code>: instala ambas funciones <code>count-words-in-defun</code> y <code>count-words-defun</code>, y asigna el atajo, y entonces emplaza el cursor con la siguiente definición:</p>
<pre><code class="example">(defun multiply-by-seven (number)
  &quot;Multiplicar NUMBER por siete.&quot;
  (* 7 number))
     ⇒ 10</code></pre>
<p>¡Éxito! La definición tiene 10 palabras y símbolos.</p>
<p>El siguiente problema es contar los números de palabras y símbolos en varias definiciones con un fichero simple.</p>
</div>
<h3 id="Contar-varias-defuns-en-un-fichero" >Contar varias <code>defuns</code> en un fichero</h3>
<div class="hBody-3" >
<p>Un fichero tal como <span class="file" >simple.el</span> puede tener un centenar o más definiciones de función dentro. Nuestro objetivo es recoger estadísticas en muchos ficheros, pero en un primer paso, nuestro objetivo inmediato es recoger estadísticas en un fichero.</p>
<p>La información será una serie de números, cada número siendo el tamaño de una definición de función. Se pueden almacenar los números en una lista.</p>
<p>Se sabe que se querrá incorporar la información considerando un fichero con información acerca de muchos otros ficheros; esto significa que la función para contar el tamaño de contaje con un fichero solo necesita devolver la lista de tamaños. Eso no necesita y no mostraría mensajes.</p>
<p>Los comando de contar palabras contienen una expresión para saltar el punto hacia adelante palabra por palabra y otra expresión para contar los saltos. La función devuelve los tamaños de definiciones que pueden ser diseñadas para trabajar del mismo modo, con una expresión para saltar el punto hacia la definición por definición y otra expresión para construir el tamaño de la lista.</p>
<p>Esta frase del problema hace elemental escribir la definición de función. Claramente, empezaremos el conteo al principio del fichero, así el primer comando será <code>(goto-char (point-min))</code>. Lo siguiente, es empezar el bucle <code>while</code>; y este true-or-false del bucle puede ser una búsqueda de expresión regular para la siguiente definición de función --- así en el momento que la búsqueda tiene éxito, el punto se mueve hacia adelante y entonces el cuerpo del bucle es evaluado. El cuerpo necesita una expresión que construye la lista de tamaños. <code>cons</code>, la lista de construcción del comando, puede ser usado para crear la lista. Esto es casi todo lo que hay.</p>
<p>Aquí está este fragmento de código que se ve así:</p>
<pre><code class="example">(goto-char (point-min))
(while (re-search-forward &quot;^(defun&quot; nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))</code></pre>
<p>Dejamos fuera el mecanismo para encontrar el fichero que contiene las definiciones de función.</p>
<p>En ejemplos previos, nosotros habíamos usado esto, el fichero Info, o cambiamos atrás y adelante a algún otro búffer, tal como el búffer <span class="file" >*scratch*</span>.</p>
<p>Encontrar un fichero es un nuevo proceso que no tenemos todavía discutido.</p>
</div>
<h3 id="Encontrar-un-fichero" >Encontrar un fichero</h3>
<div class="hBody-3" >
<p>Para encontrar un fichero en Emacs, se usa el comando <kbd>C-x C-f</kbd> (<code>find-file</code>). Este comando es casi, pero no bastante correcto para el problema de tamaños.</p>
<p>Permita mirar el fuente para <code>find-file</code>:</p>
<pre><code class="example">(defun find-file (filename)
  &quot;Edita el fichero FILENAME.
Cambia a un búffer visitando el fichero FILENAME,
creando uno si no existe ya.&quot;
  (interactive &quot;FFind file: &quot;)
  (switch-to-buffer (find-file-noselect filename)))</code></pre>
<p>(La versión más reciente de la definición de función <code>find-file</code> permite comodines especiales para visitar múltiples ficheros; que hacen la definición más compleja y no se discutirá aquí, ya que no es relevante. Se pueden ver sus fuentes usando <kbd>M-.</kbd> (<code>find-tag</code>) o <kbd>C-h f</kbd> (<code>describe-function</code>).)</p>
<p>La definición que se está mostrando posee una documentación corta, pero completa y una especificación interactiva que muestra un nombre de fichero cuando se usa el comando interactivamente. El cuerpo de la definición contiene dos funciones, <code>find-file-noselect</code> y <code>switch-to-buffer</code>.</p>
<p>De acuerdo a su documentación como muestra por <kbd>C-h f</kbd> (el comando <code>describe-function</code>), la función <code>find-file-noselect</code> lee el fichero nombrado dentro de un búffer y devuelve el búffer. (Su versión más reciente incluye un argumento comodín, también, así como otro para leer un fichero literalmente y otro que suprime mensajes de aviso. Estos argumentos opcionales son irrelevantes.)</p>
<p>Sin embargo, la función <code>find-file-noselect</code> no selecciona el búffer en el que se pone el fichero. Emacs no cambia su atención (o la tuya si estás usando <code>find-file-noselect</code>) al búffer seleccionado. Esto es lo que <code>switch-to-buffer</code> hace: eso cambia el búffer al que se dirige la atención de Emacs; y eso cambia el búffer mostrado en la ventana al nuevo búffer. Se ha discutido el búffer cambiando a otro lugar. (Véase Sección <a href="Cambiando-búffers" >Cambiando búffers</a>.)</p>
<p>En este proyecto de histograma, no se necesita mostrar cada fichero en la pantalla como el programa determina el tamaño de cada definición con eso. En vez de emplear <code>switch-to-buffer</code>, se puede trabajar con <code>set-buffer</code>, que redirige la atención del programa de ordenador para un búffer diferente pero no lo muestra en pantalla. Así en vez llamar a <code>find-file</code> para hacer el trabajo, debe escribir nuestra expresión.</p>
<p>La tarea es fácil: usar <code>find-file-noselect</code> y <code>set-buffer</code>.</p>
</div>
<h3 id="lengths-list-file-en-detalle" ><code>lengths-list-file</code> en detalle</h3>
<div class="hBody-3" >
<p>El núcleo de la función <code>lengths-list-file</code> es un bucle <code>while</code> conteniendo una función para mover el punto hacia delante ‘función a función’ y una función para contar el número de palabras y símbolos en cada función. Este núcleo debe ser rodeado por funciones que hacen otras tareas varias, incluyendo encontrar el fichero, y asegurando que el punto empieza al principio del fichero. La definición de la función se parece a: @findex lengths-list-file</p>
<pre><code class="example">(defun lengths-list-file (filename)
  &quot;Devuelve la lista de tamaños de definiciones con FILE.
La lista devuelta es una lista de números.
Cada número es el número de palabras o
símbolos en una definición.&quot;
  (message &quot;Trabajando en `%s' ... &quot; filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward &quot;^(defun&quot; nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))</code></pre>
<p>La función pasa un argumento, el nombre del fichero en el que se trabajará. Eso tiene cuatro líneas de documentación, pero sin especificación interactiva. Para evitar la preocupación de si se ha estropeado el programa o no, la primera línea del cuerpo es un mensaje de aviso.</p>
<p>La siguiente línea contiene un <code>save-excursion</code> que devuelve a Emacs la atención al actual búffer cuando la función se completa. Esto es útil en caso de embeber esta función en otra función que presume que el punto restaura el búffer original.</p>
<p>En la varlist de la expresión <code>let</code>, Emacs encuentra el fichero y ajusta la variable local <code>buffer</code> al búffer conteniendo el fichero. Al mismo tiempo, Emacs crea <code>lengths-list</code> como una variable local.</p>
<p>Lo siguiente, Emacs cambia su atención al búffer.</p>
<p>En la siguiente línea, Emacs crea el búffer de solo lectura. Idealmente, esta línea no es necesaria. Ninguna de las funciones para contar palabras y símbolos en una definición de función cambiaría el búffer. Debajo, el búffer no está yendo para ser guardado, incluso si eso fuese cambiado. Esta línea es enteramente la consecuencia grata, quizás excesiva precaución. La razón para la precaución es que esta función y esta se llama a trabajar en las fuentes para Emacs y eso es un inconveniente si están inadvertidamente modificadas. Eso va sin decir que no se realizó una necesidad para esta línea hasta que un experimento fué cambiado hacia un lado y empezó a modificar mis ficheros de fuentes Emacs …</p>
<p>Lo siguiente llama a alargar el búffer si eso está encogido. Esta función es normalmente innecesaria––Emacs crea un búffer fresco si ninguno ya existe; pero si un búffer está visitando el fichero que ya existe que Emacs devuelve uno. En este caso, el búffer puede ser encogido y debe ser amplio. Si se quiere ser completamente ‘amigo del usuario’, se pondría en orden para guardar la restricción y la localización del punto, pero no.</p>
<p>La expresión <code>(goto-char (point-min))</code> mueve el punto al principio del búffer.</p>
<p>Entonces llega un bucle <code>while</code> en el que se devuelve el ‘trabajo’ de la función. En el bucle, Emacs determina el tamaño de cada definición y construye una lista de tamaños conteniendo la información.</p>
<p>Emacs corta el búffer después de trabajar a través de eso. Esto es guardar espacio dentro de Emacs. Mi versión de GNU Emacs 19 contenía 300 ficheros fuente de interés; GNU Emacs 22 contiene a través de un millar de ficheros fuente. Otra función aplicará <code>lengths-list-file</code> a cada uno de los ficheros.</p>
<p>Finalmente, la última expresión con la expresión <code>let</code> es la variable <code>lengths-list</code>; su valor es devuelto como el valor de la función completa.</p>
<p>Se puede probar esta función instalándolo en el modo usual. Entonces posiciona tu cursor después de la siguiente expresión y escribe <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>).</p>
<pre><code class="example">(lengths-list-file
 &quot;/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el&quot;)</code></pre>
<p>(Se puede necesitar cambiar la ruta del fichero; el único aquí es para GNU Emacs versión 22.1.1. Para cambiar la expresión, cópialo al búffer <span class="file" >*scratch*</span> y edítalo.</p>
<p>(También, para ver el tamaño completo de la lista, en vez de una versión truncada se puede tener que evaluar lo siguiente:</p>
<pre><code class="example">(custom-set-variables '(eval-expression-print-length nil))</code></pre>
<p>(Véase Sección <a href="Especificar-Variables-usando-defcustom" >Especificar Variables usando <code>defcustom</code></a>. Entonces evalúa la expresión <code>lengths-list-file</code>.)</p>
<p>La lista de tamaños para <span class="file" >debug.el</span> toma menos de un segundo para producirse esto en GNU Emacs 22:</p>
<pre><code class="example">(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)</code></pre>
<p>(Usando mi vieja máquina, la versión 19 lista tamaños para <span class="file" >debug.el</span> que en siete segundos para producen esto:</p>
<pre><code class="example">(75 41 80 62 20 45 44 68 45 12 34 235)</code></pre>
<p>(La versión nueva de <span class="file" >debug.el</span> contiene más defuns que la temprana; y mi nueva máquina es más rápida que la vieja.</p>
<p>Nótese que el tamaño de la última definición en el fichero es el primero en la lista.</p>
</div>
<h3 id="Contar-palabras-en-defuns-en-diferentes-ficheros" >Contar palabras en <code>defuns</code> en diferentes ficheros</h3>
<div class="hBody-3" >
<p>En la sección previa, se creaba una función que devuelve una lista de los tamaños de cada definición en un fichero. Ahora, se quiere definir una función para devolver una lista maestra de los tamaños de las definiciones en una lista de ficheros.</p>
<p>Trabajar en cada elemento de una lista de ficheros es un acto repetitivo, así se puede usar un bucle <code>while</code> o recursión.</p>
<p>El diseño usando un bucle <code>while</code> es rutina. El argumento que se pasaba a la función es una lista de ficheros. Como se vió pronto (Vease Sección <a href="Ejemplo-de-bucle" >Ejemplo de bucle</a>), se puede escribir un bucle <code>while</code> de un modo que el cuerpo del bucle es evaluado si tal lista contiene elementos, pero sale del bucle si la lista está vacía. Para que este diseño funcione, el cuerpo del bucle debe contener una expresión que ordene la lista cada vez que el cuerpo es evaluado, de modo que finalmente la lista esté vacía. La técnica normal es asignar el valor de la lista para el valor del <code>cdr</code> de la lista cada vez que el cuerpo es evaluado.</p>
<p>La plantilla se ve así:</p>
<pre><code class="example">(while @V{test-whether-list-is-empty}
  @V{body}…
  @V{set-list-to-cdr-of-list})</code></pre>
<p>También, recuérdanos que un bucle <code>while</code> devuelve <code>nil</code> (el resultado de evaluar el true-or-false-test), no el resultado de cualquier evaluación con su cuerpo. (Las evaluaciones con el cuerpo del bucle son hechas para sus efectos laterales.) Sin embargo, la expresión que asigna la lista de tamaños es parte del cuerpo––y que es el valor que queremos devuelto por la función como un todo. Para hacer esto cerramos el bucle <code>while</code> con una expresión <code>let</code>, y pone en orden que el último elemento de la expresión <code>let</code> contiene el valor de lista de tamaños. (Véase Sección <a href="Ejemplo-de-Incremento,-,-El-Ejemplo-del-Bucle-con-un-Contador-de-Incremento" >Ejemplo de Incremento, , El Ejemplo del Bucle con un Contador de Incremento</a>.)</p>
<p>Estas consideraciones lideran directamente a la función en sí:</p>
<pre><code class="example">;;; @e{Usar bucle @c{while}.}
(defun lengths-list-many-files (list-of-files)
  &quot;Devuelve la lista de tamaños de funciones en LIST-OF-FILES.&quot;
  (let (lengths-list)

;;; @e{true-or-false-test}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list

;;; @e{Genera una lista de tamaños.}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))

;;; @e{Crea una lista ordenada de ficheros.}
      (setq list-of-files (cdr list-of-files)))

;;; @e{Devuelve la lista final de valores de tamaños.}
    lengths-list))</code></pre>
<p><code>expand-file-name</code> es una función construida que convierte un nombre de fichero al absoluto, forma de nombre de ruta. La función emplea el nombre del directorio en el que la función se llama.</p>
<p>De este modo, si <code>expand-file-name</code> es llamado en <code>debug.el</code> cuando Emacs está visitando el directorio <span class="file" >/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/</span></p>
<pre><code class="example">debug.el</code></pre>
<p>llega a ser</p>
<pre><code class="example">/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el</code></pre>
<p>El único nuevo elemento de esta definición de función es la todavía no estudiada función <code>append</code>, que merece una corta sección en sí.</p>
</div>
<h4 id="La-función-append" >La función <code>append</code></h4>
<div class="hBody-4" >
<p>La función <code>append</code> adjunta una lista a otra. De este modo,</p>
<pre><code class="example">(append '(1 2 3 4) '(5 6 7 8))</code></pre>
<p>produce la lista</p>
<pre><code class="example">(1 2 3 4 5 6 7 8)</code></pre>
<p>Esto es exactamente cómo queremos adjuntar dos listas de tamaños producidas por <code>lengths-list-file</code> a cualquier otra. Los resultados contrastan con <code>cons</code>,</p>
<pre><code class="example">(cons '(1 2 3 4) '(5 6 7 8))</code></pre>
<p>que construye una nueva lista en el que el primer argumento para <code>cons</code> llega a ser el primer elemento de la nueva lista:</p>
<pre><code class="example">((1 2 3 4) 5 6 7 8)</code></pre>
</div>
<h3 id="Recursivamente-cuenta-palabras-en-diferentes-ficheros" >Recursivamente cuenta palabras en diferentes ficheros</h3>
<div class="hBody-3" >
<p>Bajo un bucle <code>while</code>, se puede trabajar cada lista de ficheros con recursión. Una versión recursiva de <code>lengths-list-many-files</code> es corta y simple.</p>
<p>La función recursiva tiene las partes normales: el ‘do-again-test’, la ‘next-step-expression’, y la llamada recursiva. El ‘do-again-test’ determina si la función se llamaría, que hará si la <code>list-of-files</code> contiene los elementos que permanecen; la ‘next-step-expression’ resetea el <code>list-of-files</code> al <code>cdr</code> en sí, así finalmente la lista será vacía; y la llamada recursiva llama en sí a la lista ordenada. ¡La función completa está ordenada por esta descripción!</p>
<pre><code class="example">(defun recursive-lengths-list-many-files (list-of-files)
  &quot;Devuelve la lista de tamaños de cada defun en LIST-OF-FILES.&quot;
  (if list-of-files                     ; @e{do-again-test}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))</code></pre>
<p>En una frase, la función devuelve de tamaños de la lista para la el primero de la <code>list-of-files</code> al resultado de llamarse así mismo al resto de <code>list-of-files</code>.</p>
<p>Aquí hay un test <code>recursive-lengths-list-many-files</code>, a lo largo de los resultados de ejecutar <code>lengths-list-file</code> en cada uno de los ficheros individualmente.</p>
<p>Instala <code>recursive-lengths-list-many-files</code> y <code>lengths-list-file</code>, si es necesario, y entonces evalúa las siguientes expresiones. Se puede necesitar cambiar las rutas de ficheros; aquí se trabaja cuando este fichero Info y las fuentes de Emacs están localizadas en sus lugares personales. Para cambiar las expresiones, cópialas al búffer <span class="file" >*scratch*</span>, edítalos y entonces evalúalos.</p>
<p>Los resultados son mostrados después del <samp>⇒</samp>. (Estos resultados son para ficheros de Emacs versión 22.1.1; ficheros desde otras versiones de Emacs puede producir diferentes resultados.)</p>
<pre><code class="example">(cd &quot;/usr/local/share/emacs/22.1.1/&quot;)

(lengths-list-file &quot;./lisp/macros.el&quot;)
     ⇒ (283 263 480 90)

(lengths-list-file &quot;./lisp/mail/mailalias.el&quot;)
     ⇒ (38 32 29 95 178 180 321 218 324)

(lengths-list-file &quot;./lisp/makesum.el&quot;)
     ⇒ (85 181)

  (recursive-lengths-list-many-files
   '(&quot;./lisp/macros.el&quot;
     &quot;./lisp/mail/mailalias.el&quot;
     &quot;./lisp/makesum.el&quot;))
       ⇒ (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)</code></pre>
<p>La función <code>recursive-lengths-list-many-files</code> produce la salida que queremos.</p>
<p>El siguiente paso es preparar el dato en la lista para mostrarlo en un grafo.</p>
</div>
<h3 id="Preparar-los-datos-para-mostrarlos-en-un-grafo" >Preparar los datos para mostrarlos en un grafo</h3>
<div class="hBody-3" >
<p>La función <code>recursive-lengths-list-many-files</code> devuelve una lista de números. Cada número graba el tamaño de una definición de función. Lo que se necesita hacer ahora es transformar estos datos dentro de una lista de números ajustado para generar un grafo. La nueva lista contará cuántas definiciones de funciones contienen menos de 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuántas contienen entre 20 y 29 palabras y símbolos, y así.</p>
<p>En breve, se necesita ir a través el tamaño de la lista producida por la función <code>recursive-lengths-list-many-files</code> y contar el número de defuns con cada rango de tamaños, y produce una lista de esto de números.</p>
<p>Basado en lo que hemos hecho antes, se prevee que no sería difícil escribir una función que ‘<code>cdr</code>s’ bajo la lista de tamaños, parece que cada elemento, determina que rango de tamaños está dentro, e incrementa un contador para este rango.</p>
<p>Sin embargo, antes de empezar a escribir tal función, nosotros consideraríamos las ventajas de ordenar los tamaños de la lista primero, así los números son ordenados desde el más pequeño al más largo. Primero, ordenando se hará fácil contar los números en cada rango, desde dos números adyacentes será el mismo rango del tamaño en rangos adyacentes. Segundo, inspeccionando una lista ordenada, se puede descubrir el número mayor y menor, y esto significa determinar el rango de tamaño mayor y menor que necesitará.</p>
</div>
<h4 id="Ordenando-listas" >Ordenando listas</h4>
<div class="hBody-4" >
<p>Emacs contiene una función para listas ordenadas, llamadas (como se podría adivinar) <code>sort</code>. La función <code>sort</code> toma dos argumentos, la lista es ordenada, y un predicado que determina si la primera de dos elementos de lista es “menor” que la segunda.</p>
<p>Como se vió antes (Vease Sección <cite>Usando el Tipo Incorrecto de Objeto como un Argumento</cite>), un predicado es una función que determina si alguna propiedad es verdadera o falsa. La función <code>sort</code> reordenará una lista de acuerdo a lo que la propiedad del predicado usa; esto significa que <code>sort</code> puede ser usado para ordenar listas no numéricas por un criterio no numérico --- eso puede, por ejemplo, alfabetizar una lista.</p>
<p>La función <code>&lt;</code> se usa cuando se ordena una lista numérica. Por ejemplo,</p>
<pre><code class="example">(sort '(4 8 21 17 33 7 21 7) '&lt;)</code></pre>
<p>produce esto:</p>
<pre><code class="example">(4 7 7 8 17 21 21 33)</code></pre>
<p>(Note que en este ejemplo, ambos argumentos se citan así que los símbolos no se evalúan antes de ser pasados por <code>sort</code> como argumentos.)</p>
<p>Ordenando la lista devuelta por la función <code>recursive-lengths-list-many-files</code> es honesta; eso usa la funci@'n <code>&lt;</code>:</p>
<pre><code class="example">(sort
 (recursive-lengths-list-many-files
  '(&quot;./lisp/macros.el&quot;
    &quot;./lisp/mailalias.el&quot;
    &quot;./lisp/makesum.el&quot;))
 '&lt;)</code></pre>
<p>que produce:</p>
<pre><code class="example">(29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)</code></pre>
<p>(Note que en este ejemplo, el primer argumento para <code>sort</code> no está citado, desde que la expresión debe ser evaluado así como producir la lista que es pasada para <code>sort</code>.)</p>
</div>
<h4 id="Creando-una-lista-de-ficheros" >Creando una lista de ficheros</h4>
<div class="hBody-4" >
<p>La función <code>recursive-lengths-list-many-files</code> requiere una lista de fichero como argumento. Para nuestros ejemplos de test, se construyeron tal como una lista a mano; pero el directorio fuente de Emacs Lisp es demasiado grande para hacer esto. Así, se escribirá una función para hacer el trabajo. En esta función, se usa tanto un bucle <code>while</code> como una llamada recursiva.</p>
<p>En viejas versiones de GNU Emacs no hizo falta tener que escribir esta función, puesto que todos los ficheros <samp>.el</samp> en un directorio. En vez de eso, se puede ser capaz de usar la función <code>directory-files</code>, que lista los nombres de fichero que hay en un directorio simple.</p>
<p>Sin embargo, las versiones reciente Emacs emplazan ficheros de Emacs Lisp en subdirectorios del directorio de alto nivel <span class="file" >lisp</span>. Esto facilita la navegación. Por ejemplo, todos los ficheros de correo relacionados que están en el subdirectorio llamado <span class="file" >mail</span>. Pero al mismo tiempo, esta facilidad fuerza a crear un fichero listando la función que desciende dentro de los subdirectorios.</p>
<p>Se puede crear esta función, llamada <code>files-en-below-directory</code>, usando funciones familiares tales como <code>car</code>, <code>nthcdr</code>, y <code>substring</code> en conjunción con una función existente llamada <code>directory-files-and-attributes</code>. Esta última función no solo listas de ficheros en un directorio, incluyendo los nombres de subdirectorios, pero también sus atributos.</p>
<p>Para empezar nuestro objetivo: crear una función que nos permita alimentas ficheros a <code>recursive-lengths-list-many-files</code> como una lista que se parece a esto (pero con más elementos):</p>
<pre><code class="example">(&quot;./lisp/macros.el&quot;
 &quot;./lisp/mail/rmail.el&quot;
 &quot;./lisp/makesum.el&quot;)</code></pre>
<p>La función <code>directory-files-and-attributes</code> devuelve una lista de listas. Cada una de las listas con la lista principal consiste de 13 elementos. El primer elemento es una cadena que contiene el nombre del fichero––que, en GNU/Linux, puede ser un ‘directorio fichero’, que dice, un fichero con los atributos especiales de un directorio. El segundo elemento de la lista es <code>t</code> para un directorio, es una cadena para el enlace simbólico (la cadena es el nombre enlazado), o <code>nil</code>.</p>
<p>Por ejemplo, el primer fichero <samp>.el</samp> en el directorio es <span class="file" >abbrev.el</span>. Su nombre es <span class="file" >/usr/local/share/emacs/22.1.1/lisp/abbrev.el</span> y no es un directorio o un enlace simbólico.</p>
<p>Esto es cómo <code>directory-files-and-attributes</code> lista este fichero y sus atributos:</p>
<pre><code class="example">(&quot;abbrev.el&quot;
nil
1
1000
100
(20615 27034 579989 697000)
(17905 55681 0 0)
(20615 26327 734791 805000)
13188
&quot;-rw-r--r--&quot;
nil
2971624
773)</code></pre>
<p>Por otro lado, <span class="file" >mail/</span> es un directorio con el directorio <span class="file" >lisp/</span>. El principio del listado se parece a esto:</p>
<pre><code class="example">(&quot;mail&quot;
t
…
)</code></pre>
<p>(Para aprender acerca de los diferentes atributos, mira en la documentación de <code>file-attributes</code>. Tenga en mente que la función <code>file-attributes</code> no lista el nombre del fichero, así su primer elemento es <code>directory-files-and-attributes</code> que es el segundo elemento.)</p>
<p>Se querrán nuestras nuevas funciones, <code>files-in-below-directory</code>, para listar los fichero <samp>.el</samp> en el directorio eso es contado para chequear, y en los directorios bajo este directorio.</p>
<p>Esto nos da una sugestión de como construir <code>files-in-below-directory</code>: con un directorio, la función añadir los nombres de ficheros <samp>.el</samp> a una lista; y si, con un directorio, la función viene con un subdirectorio, iría dentro de este subdirectorio y repite sus acciones.</p>
<p>Sin embargo, nosotros notaríamos que cada directorio contiene un nombre que se refiere a sí mismo, llamado <span class="file" >.</span>, (“dot”) y un nombre que se refiere a su directorio padre, llamado <span class="file" >..</span> (“doble punto”). (En <span class="file" >/</span>, el directorio raíz, <span class="file" >..</span> se refiere así mismo, desde que <span class="file" >/</span> no tiene padre.) Claramente, no que se quiere nuestra función <code>files-in-below-directory</code> para introducir estos directorio, desde que ellos siempre nos lideran, directamente o indirectamente, al directorio actual.</p>
<p>Consecuentemente, nuestra función <code>files-in-below-directory</code> debe hacer varias tareas:</p>
<ul>
<li><p>Chequee para ver si se está mirando en un nombre de fichero que finaliza en <samp>.el</samp> y si es así, se añade el nombre a una lista.</p>
</li>
<li><p>Chequee para ver si está mirando en un nombre de fichero que es el nombre de un directorio; y si es así,</p>
<ul>
<li><p>Chequee para ver si está mirando en <span class="file" >.</span> o <span class="file" >..</span>; y si es así sal.</p>
</li>
<li><p>O además, ve dentro de este directorio y repite el proceso.</p>
</li>
</ul>
</li>
</ul>
<p>Se permite escribir una definición de función para hacer estas tareas. Se usará un bucle <code>while</code> para mover de un nombre de fichero a otro con un directorio chequeando lo que necesita ser hecho; y se usa una llamada recursiva para repetir las acciones en cada subdirectorio. El patrón recursivo es ‘acumular’ (Vease Sección <a href="Patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></a>) usando <code>append</code> para combinar.</p>
<p>Aquí está la función:</p>
<pre><code class="example">(defun files-in-below-directory (directory)
  &quot;Lista los ficheros .el en DIRECTORIO y en sus subdirectorios.&quot;
  ;; Aunque la función será usada no interactivamente,
  ;; será fácil chequear si lo hacemos interactivo.
  ;; El directorio tendrá un nombre tal como
  ;;  &quot;/usr/local/share/emacs/22.1.1/lisp/&quot;
  (interactive &quot;DNombre del Directorio: &quot;)
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; mientras estamos en el directorio actual
    (while current-directory-list
      (cond
       ;; chequee para ver si el nombre del fichero finaliza en ‘.el’
       ;; y si es así, añade su nombre a una lista.
       ((equal &quot;.el&quot; (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
       ;; chequee si el nombre del fichero es un directorio
       ((eq t (car (cdr (car current-directory-list))))
        ;; decide si salir o hacer recursión
        (if
            (equal &quot;.&quot;
                   (substring (car (car current-directory-list)) -1))
            ;; entonces no hagas nada puesto que el nombre del fichero es
            ;; el actual directorio o padre, &quot;.&quot; o &quot;..&quot;
            ()
          ;; else desciende dentro del directorio y repite el proceso
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; mueve al siguiente fichero en la lista; esto también
      ;; ordena la lista así mientras el bucle
      ;; eventualmente llega a un fin
      (setq current-directory-list (cdr current-directory-list)))
    ;; devuelve los ficheros
    el-files-list))</code></pre>
<p>Las funciones <code>files-in-below-directory</code> <code>directory-files</code> toma un argumento, el nombre de un directorio.</p>
<p>De este modo, en mi sistema,</p>
<pre><code class="example">(length
 (files-in-below-directory &quot;/usr/local/share/emacs/22.1.1/lisp/&quot;))</code></pre>
<p>se cuenta que dentro y debajo de mi directorio de fuentes Lisp hay 1031 ficheros <samp>.el</samp></p>
<p><code>files-in-below-directory</code> devuelve una lista en orden alfabético inverso. Una expresión para ordenar la lista en orden que parece como este:</p>
<pre><code class="example">(sort
 (files-in-below-directory &quot;/usr/local/share/emacs/22.1.1/lisp/&quot;)
 'string-lessp)</code></pre>
</div>
<h4 id="Contando-definiciones-de-función" >Contando definiciones de función</h4>
<div class="hBody-4" >
<p>Nuestro objetivo inmediato es generar una lista que cuenta, cuantas definiciones de funciones contienen menos de 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuantas contienen entre 20 y 29 palabras y símbolos, y así.</p>
<p>Con una lista ordenada de números, es fácil: se cuentan cuantos elementos de la lista son más pequeños de 10, entonces, se devuelven los números contados, se cuenta cuantos son más pequeños de 20, entonces se devuelven los números contados, después se cuentan los que son más pequeños de 30, y así. Cada uno de los números, 10, 20, 30, 40, y como, es más grande que el tope de este rango. Se puede llamar a la lista de tales números, la lista <code>top-of-ranges</code>.</p>
<p>Si se desea, se podría generar esta lista automáticamente, pero es más simple escribir una lista manualmente. Aquí está: @vindex top-of-ranges</p>
<pre><code class="example">(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 &quot;Listar especificando rangos para ‘defuns-per-range’.&quot;)</code></pre>
<p>Para cambiar los rangos, se edita esta lista.</p>
<p>Lo siguiente, que se necesita es escribir la función que crea la lista del número de definiciones con cada rango. Claramente, esta función debe tomar el <code>sorted-lengths</code> y las listas <code>top-of-ranges</code> listas como argumentos.</p>
<p>La función <code>defuns-per-range</code> debe hacer dos cosas una y otra vez: eso debe contar el número de definiciones con un rango específico por el actual valor top-of-range; y eso debe dividir al siguiente gran valor en la lista <code>top-of-ranges</code> después de contar el número de definiciones en el rango actual. Desde que cada una de estas acciones es repetitiva, se puede usar los bucles <code>while</code> para el trabajo. Un bucle cuenta el número de definiciones en el rango definido por el valor actual top-of-range, y el otro bucle selecciona cada uno de los valores top-of-range en turno.</p>
<p>Varias entradas de la lista <code>sorted-lengths</code> se cuentan para cada rango; esto significa que el bucle para la lista <code>sorted-lengths</code> será dentro del bucle para la lista <code>top-of-ranges</code>, como un pequeño adorno dentro de un gran adorno.</p>
<p>El bucle interno cuenta el número de definiciones con el rango. Eso es un simple contaje del tipo en el que se ha visto antes. (Véase Sección <a href="Un-bucle-con-un-contaje-incremental" >Un bucle con un contaje incremental</a>). El test true-or-false del bucle chequea si el valor desde la lista <code>sorted-lengths</code> es más pequeña que el actual valor de lo alto del rango. Si es así, la función incrementa el contador y se chequea el siguiente valor desde la lista <code>sorted-lengths</code>.</p>
<p>El bucle interno se parece a esto:</p>
<pre><code class="example">(while @V{length-element-smaller-than-top-of-range}
  (setq number-within-range (1+ number-within-range))
  (setq sorted-lengths (cdr sorted-lengths)))</code></pre>
<p>El bucle de fuera debe empezar con el valor más bajo de la lista <code>top-of-ranges</code>, y entonces se asigna a cada uno de los valores superiores exitosos a su vez. Esto puede ser hecho con un bucle como este:</p>
<pre><code class="example">(while top-of-ranges
  @V{body-of-loop}…
  (setq top-of-ranges (cdr top-of-ranges)))</code></pre>
<p>Se ponen juntos, los dos bucles como este:</p>
<pre><code class="example">(while top-of-ranges

  ;; @e{Contar el número de elementos con el actual rango.}
  (while @V{length-element-smaller-than-top-of-range}
    (setq number-within-range (1+ number-within-range))
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @e{Mover al siguiente rango.}
  (setq top-of-ranges (cdr top-of-ranges)))</code></pre>
<p>Además, en cada circuito del bucle exterior, Emacs grabaría el número de definiciones con este rango (el valor de <code>number-within-range</code>) en una lista. Se puede usar <code>cons</code> para este propósito. (Véase Sección <a href="cons" ><code>cons</code></a>.)</p>
<p>La función <code>cons</code> trabaja bien, excepto que la lista que se construye contendrá el número de definiciones para el alto rango y su principio el número de definiciones para el más bajo rango a su fin. Esto es porque <code>cons</code> adjunta nuevos elementos de la lista al principio de la lista, y desde los dos bucles que hacen cálculos a través de la lista de tamaños desde lo bajo finaliza primero, el <code>defuns-per-range-list</code> finalizará el primer número más largo. Pero lo que se quiere es imprimir nuestro grafo con pequeños valores primero y el más grande después. La solución es invertir el orden del <code>defuns-per-range-list</code>. Nosotros podemos hacer esto usando la función <code>nreverse</code>, que invierte el orden de una lista.  @findex nreverse</p>
<p>Por ejemplo,</p>
<pre><code class="example">(nreverse '(1 2 3 4))</code></pre>
<p>produce:</p>
<pre><code class="example">(4 3 2 1)</code></pre>
<p>Note que la función <code>nreverse</code> es “destructiva”––que es, cambiar la lista a la que se aplica; esto contrasta con las funciones <code>car</code> y <code>cdr</code>, que no son destructivas. En este caso, no se quiere que el original <code>defuns-per-range-list</code>, de manera que no hay materia que se destruya. (La función <code>reverse</code> provee un copia inversa de una lista, dejando la lista original como es.)  @findex reverse</p>
<p>Pon todo junto, el <code>defuns-per-range</code> se parece a esto:</p>
<pre><code class="example">(defun defuns-per-range (sorted-lengths top-of-ranges)
  &quot;funciones de SORTED-LENGTHS en cada rango TOP-OF-RANGES.&quot;
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)

    ;; @e{Bucle Exterior.}
    (while top-of-ranges

      ;; @e{Bucle Interno.}
      (while (and
              ;; @e{Necesita el número para el test numérico.}
              (car sorted-lengths)
              (&lt; (car sorted-lengths) top-of-range))

        ;; @e{Contar número de definiciones con el rango actual.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @e{Sal del bucle interno pero permanece con el bucle externo.}

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @e{Resetear el contaje a cero.}

      ;; @e{Mover al siguiente rango.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @e{Especifica el siguiente mejor rango de valores.}
      (setq top-of-range (car top-of-ranges)))

    ;; @e{Salir del bucle externo y contar el número de defuns más
    ;; largas que}
    ;; @e{el valor más largo del valor top-of-range.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; @e{Devuelve una lista del número de definiciones con cada rango,}
    ;; @e{ del más pequeño al más largo.}
    (nreverse defuns-per-range-list)))</code></pre>
<p>La función es simple excepto para una pequeña funcionalidad. El test verdadero-o-falso para el bucle interno se parece a esto:</p>
<pre><code class="example">(and (car sorted-lengths)
     (&lt; (car sorted-lengths) top-of-range))</code></pre>
<p>en vez de algo como esto:</p>
<pre><code class="example">(&lt; (car sorted-lengths) top-of-range)</code></pre>
<p>El propósito del test es determinar si el primer ítem en la lista <code>sorted-lengths</code> es menor que el valor de lo mejor del rango.</p>
<p>La versión simple del test trabaja bien a menos que la lista <code>sorted-lengths</code> tiene un valor <code>nil</code>. En este caso, la expresión <code>(car sorted-lengths)</code> devuelve <code>nil</code>. La función <code>&lt;</code> no se puede compara un número a <code>nil</code>, que es una lista vacía, así Emacs señala un error y para la función desde el intento de continuar la ejecución.</p>
<p>La lista <code>sorted-lengths</code> siempre llega a ser <code>nil</code> cuando el contador logra el fin de la lista. Esto significa que cualquier intento de usar la función <code>defuns-per-range</code> con la versión simple del test fallará.</p>
<p>Se resuelve el problema usando <code>(car sorted-lengths)</code> en conjunción con la expresión <code>and</code>. La expresión <code>(car sorted-lengths)</code> devuelve un valor no <code>nil</code> tan largo como la lista que tiene al menos un número con eso, pero devuelve <code>nil</code> si la lista está vacía. La expresión <code>and</code> primero evalúa el <code>(car sorted-lengths)</code>, y si eso es <code>nil</code>, devuelve falso <em>sin</em> evaluar la expresión <code>&lt;</code> y devuelve este valor como el valor de la expresión <code>and</code>.</p>
<p>Este camino, evita un error.  (Para información acerca de <code>and</code>, ver <a href="La-función-kill-new" >La función <code>kill-new</code></a></p>
<p>Aquí hay un pequeño test de la función <code>defuns-per-range</code>. Primero, evalúa la expresión que ajusta (una resumida) lista <code>top-of-ranges</code> a la lista de valores, entonces evalúa la expresión para ajustar la lista <code>sorted-lengths</code>, y entonces evalúa la función <code>defuns-per-range</code>.</p>
<pre><code class="example">;; @e{(La lista ordenada que usará después.)}
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)</code></pre>
<p>La lista devuelta se parece a esto:</p>
<pre><code class="example">(2 2 2 0 0 1 0 2 0 0 4)</code></pre>
<p>Dentro, hay dos elementos de la lista <code>sorted-lengths</code> menores de 110, dos elementos entre 110 y 119, dos elementos entre 120 y 129 y así. Hay cuatro elementos con un valor de 200 o superior.</p>
</div>
<h2 id="Leyendo-un-grafo" >Leyendo un grafo</h2>
<div class="hBody-2" >
<p>Nuestro objetivo es construir un grafo mostrando los números de definiciones de función de varios tamaños en las fuentes de Emacs lisp.</p>
<p>Como una materia práctica, si se estuviese creando un grafo, probablemente usarías un programa tal como <code>gnuplot</code> para hacer el trabajo. (<code>gnuplot</code> está bien integrado dentro de GNU Emacs.) En este caso, sin embargo, creamos uno desde cero, y en el proceso lo reconstruimos nosotros mismos con algo de lo que se aprende antes y así poder aprender más.</p>
<p>En este capítulo, primero se escribe un grafo simple imprimiendo la función. Esta primera definición será un <dfn>prototipo</dfn>, una función escrita rápidamente nos permite reconocer este territorio de crear un grafo. Se descubren dragones, o resulta que son mitos. Después de olisquear el terreno, nos sentiremos más confidentes y mejoraremos la función para etiquetar las coordenadas automáticamente.</p>
<p>Puesto que Emacs está diseñado para ser flexible y trabajar con todo tipo de terminales, incluyendo los terminales de caracteres, el grafo necesitará ser hecho desde símbolos de ‘escritura’. Un asterisco hará; como nosotros mejoramos la función de impresión del grafo, se puede crear la elección del símbolo como una opción de usuario.</p>
<p>Se puede llamar a esta función <code>graph-body-print</code>; se tomará un <code>numbers-list</code> como su único argumento. En esta fase, no se etiquetará el grafo, pero se imprime su cuerpo.</p>
<p>La función <code>graph-body-print</code> inserta una columna vertical de asteriscos para cada elemento en la lista <code>numbers-list</code>. La altura de cada línea está determinada por el valor de este elemento de la <code>numbers-list</code>.</p>
<p>Insertar columnas es un acto repetitivo; que significa que esta función debe ser escrita con un bucle <code>while</code> o recursivamente.</p>
<p>Nuestro primer reto es descubrir como imprimir una columna de asteriscos. Normalmente, en Emacs, se imprimen caracteres dentro de una pantalla horizontalmente, línea a línea, escribiendo. Se tienen dos rutas que se pueden seguir: escribir nuestra función column-insertion o descubrir si una que exista en Emacs.</p>
<p>Para ver si hay uno en Emacs, se puede usar el comando <kbd>M-x apropos</kbd>. Este comando es como el comando <kbd>C-h a</kbd> (<code>command-apropos</code>), excepto que último encuentra solo estas funciones que son comandos. El comando <kbd>M-x apropos</kbd> lista todos los símbolos que se asocian a una expresión regular, incluyendo funciones que no son interactivas.  @findex apropos</p>
<p>Lo que se quiere buscar es algún comando que imprima o inserte columnas. Muy probablemente, el nombre de la función contendrá la palabra ‘print’ o la palabra ‘insert’ o la palabra ‘column’. Por esta razón, podemos simplemente escribir <kbd>M-x apropos RET print \|insert\|column RET</kbd> y se ve el resultado. En mi sistema, este comando toma todavía algún tiempo, y entonces se produce una lista de 79 funciones y variables. Ahora no se tarda mucho y se produce una lista de 211 funciones y variables. Escaneando la lista, la única función que se ve como si se pudiera hacer el trabajo que es <code>insert-rectangle</code>.</p>
<p>En realidad, esta es la función que queremos; su documentación dice:</p>
<pre><code class="example">insert-rectangle:
Insertar texto de RECTANGLE con la esquina izquierda a punto
La primera línea de RECTANGLE es insertada al punto
su segunda línea es insertada a un punto verticalmente
bajo el punto, etc.
El RECTANGLE debería ser una lista de cadenas.
Después de este comando, la marca está en la esquina izquierda
superior y el punto en la esquina derecha inferior.</code></pre>
<p>Se puede ejecutar un test rápido, para asegurar que hace lo que se espera de eso.</p>
<p>Aquí está el resultado de emplazar el cursor después de la expresión <code>insert-rectangle</code> y escribiendo <kbd>C-u C-x C-e</kbd> (<code>eval-last-sexp</code>). La función inserta las cadenas <samp>&quot;primero&quot;</samp>, <samp>&quot;segundo&quot;</samp>, y <samp>&quot;tercero&quot;</samp> en el punto. También la función devuelve <code>nil</code>.</p>
<pre><code class="example">(insert-rectangle '(&quot;primero&quot; &quot;segundo&quot; &quot;tercer&quot;))primero
                                              segundo
                                              terceronil</code></pre>
<p>De acuerdo, no se inserta el texto de la expresión <code>insert-rectangle</code> en sí dentro del búffer en el que se marca el grafo, pero se llamará la función de nuestro programa. Nosotros, sin embargo, tenemos que asegurar que el punto está en el búffer en el lugar donde la función <code>insert-rectangle</code> insertará la columna de cadenas.</p>
<p>Si se está leyendo esto en Info, se puede ver como este trabajo cambia a otro búffer, tal como el búffer <span class="file" >*scratch*</span>, emplazando el punto a algún lugar en el búffer, se escribe <kbd>M::</kbd>, después se escribe la expresión <code>insert-rectangle</code> dentro del minibúffer en la consola, y entonces se escribe <kbd>RET</kbd>. Esto causa que Emacs evalúe la expresión en el minibúffer, pero usa como el valor del punto la posición del punto en el búffer <span class="file" >*scratch*</span>. (<kbd>M::</kbd> es el atajo para <code>eval-expression</code>. <code>nil</code> tampoco aparece en el búffer <span class="file" >*scratch*</span> desde que la expresión se evalúa en el minibúffer.)</p>
<p>Se encuentra cuando hacer esto hasta el punto que finaliza al fin de la última línea insertada––es decir, esta función mueve el punto como un efecto secundario. Si se iba a repetir el comando, con el punto en esta posición, la siguiente inserción sería debajo y a la derecha de la inserción previa. ¡Nosotros no queremos esto!. Si se está yendo a crear un gráfico de barras, las columnas necesitan estar debajo unas de otras.</p>
<p>Así se descubre que cada ciclo del bucle <code>while</code> de column-inserting debe reposicionar el punto al lugar que queremos, y este lugar estará arriba, no abajo, de la columna. Más allá, se recuerda que cuando se imprime un grafo, no esperan todas las columnas para estar a la misma altura. Esto significa que el alto de cada columna puede estar a una altura diferente desde una previa. Nosotros simplemente reposicionamos el punto a la misma línea cada vez, pero movido cubriendo a la derecha––o quizás se puede …</p>
<p>Estamos planeando crear las columnas de la barra gráfica sin asteriscos. El número de asteriscos en la columna es el número específico por el elemento actual del <code>numbers-list</code>. Necesitamos construir una lista de asteriscos del tamaño derecho para cada llamada a <code>insert-rectangle</code>. Si esta lista consiste únicamente del número requerido de asteriscos, entonces tendremos la posición de punto el número correcto de líneas bajo la base del gráfico para imprimirse correctamente. Esto podría ser difícil.</p>
<p>Alternativamente, si podemos figurarnos algún camino para pasar <code>insert-rectangle</code> del mismo tamaño cada vez, entonces podemos posicionar el punto en la misma línea cada vez, pero se mueve a través de una columna a la derecha por cada nueva columna. Si hacemos esto, sin embargo, alguna de las entradas en la lista pasaba a <code>insert-rectangle</code> y deben ser espacios en blanco en vez de asteriscos. Por ejemplo, si la altura máxima del grafo es 5, pero la altura de la columna es 3, entonces <code>insert-rectangle</code> requiere un argumento que se parezca a esto:</p>
<pre><code class="example">(&quot; &quot; &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;*&quot;)</code></pre>
<p>Esta última propuesta no es tan difícil, de hecho se puede determinar la altura de la columna. Hay dos caminos para nosotros especificar la altura de la columna: se puede arbitrariamente situar lo que será, lo que funcionaría bien para gráficas de esta altura; o podemos buscar a través de la lista de números y usar la altura máxima de la lista como la altura máxima del grafo. Si la última operación fuera difícil, entonces el procedimiento formal sería fácil, pero hay una función construida en Emacs para determinar el máximo de sus argumentos. Se puede usar esta función. La función se llamaba <code>max</code> y eso devuelve el mayor de sus argumentos, que deben ser números. De este modo, por ejemplo,</p>
<pre><code class="example">(max  3 4 6 5 7 3)</code></pre>
<p>devuelve 7. (Una función correspondiente llamada <code>min</code> devuelve lo más pequeño de todos sus argumentos.)  @findex max @findex min</p>
<p>Sin embargo, no podemos simplemente llama a <code>max</code> en el <code>numbers-list</code>; la función <code>max</code> espera números como sus argumentos, no una lista de números. De este modo, la siguiente expresión,</p>
<pre><code class="example">(max  '(3 4 6 5 7 3))</code></pre>
<p>produce el siguiente mensaje error;</p>
<pre><code class="example">Mal tipo de argumento: number-or-marker-p, (3 4 6 5 7 3)</code></pre>
<p>Se necesita una función que pasa una lista de argumentos a una función. Esta función es <code>apply</code>. Esta función ‘aplica’ su primer argumento (una función) para los argumentos que permanecen, el último puede ser una lista.</p>
<p>Por ejemplo,</p>
<pre><code class="example">(apply 'max 3 4 7 3 '(4 8 5))</code></pre>
<p>devuelve 8</p>
<p>(Incidentalmente, yo no sabría cómo aprender acerca de esta función sin un libro tal como este. Eso es posible descubrir otras funciones, como <code>search-forward</code> o <code>insert-rectangle</code>, adivinando una parte de sus nombres y entonces usando <code>apropos</code>. Incluso aunque su base metafórica es clara––‘apply’ su primer argumento al resto––dudo que un novicio vendría con esta palabra particular usando <code>apropos</code> u otra ayuda. De acuerdo, podría ser incorrecto; después de todo, la función fué primero llamada por alguien quien lo había inventado.</p>
<p>El segundo y subsiguientes argumentos para <code>apply</code> son opcionales, así se puede usar <code>apply</code> para llamar a una función y pasan los elementos de una lista, como este, que también devuelve 8:</p>
<pre><code class="example">(apply 'max '(4 8 5))</code></pre>
<p>Este camino tardío usará <code>apply</code>. La función <code>recursive-lengths-list-many-files</code> devuelve una lista de números que se puede aplicar a <code>max</code> (se podría también aplicar <em>(hacer apply)</em> a la lista de números ordenados; eso no importa si la lista está o no).</p>
<p>Aquí, la operación para encontrar el tamaño máximo del grafo es este:</p>
<pre><code class="example">(setq max-graph-height (apply 'max numbers-list))</code></pre>
<p>Ahora se puede devolver la pregunta de como crear una lista de cadenas para una columna del grafo. Cuenta la máxima altura del grafo y el número de asteriscos que aparecerían en la columna, la función devolverá una lista de cadenas para el comando a insertar <code>insert-rectangle</code>.</p>
<p>Cada columna se realiza con asteriscos o espacios en blanco. Puesto que la función pasa el valor del alto de la columna y el número de asteriscos en el columna, el número de espacios en blanco puede ser encontrado sustrayendo el número de asteriscos desde lo alto de la columna. Dado el número de espacios en blanco y el número de asteriscos, dos bucles <code>while</code> puede ser usado para construir la lista:</p>
<pre><code class="example">;;; @e{Primera versión.}
(defun column-of-graph (max-graph-height actual-height)
  &quot;Devuelve la lista de cadenas que una columna de un grafo.&quot;
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @e{Llenar asteriscos.}
    (while (&gt; actual-height 0)
      (setq insert-list (cons &quot;*&quot; insert-list))
      (setq actual-height (1- actual-height)))

    ;; @e{Rellena espacios en blanco.}
    (while (&gt; number-of-top-blanks 0)
      (setq insert-list (cons &quot; &quot; insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @e{Devuelve la lista completa.}
    insert-list))</code></pre>
<p>Si se instala esta función y entonces evalúa la siguiente expresión se verá que devuelve la lista como se desea:</p>
<pre><code class="example">(column-of-graph 5 3)</code></pre>
<p>devuelve</p>
<pre><code class="example">(&quot; &quot; &quot; &quot; &quot;*&quot; &quot;*&quot; &quot;*&quot;)</code></pre>
<p>Como está escrito, <code>column-of-graph</code> contiene una grieta mayor: los símbolos usados para el espacio en blanco para las entradas marcadas en la columna son ‘codificadas duras’ como un espacio y un asterisco. Esto está bien para un prototipo, pero tu, u otro usuario, puede desear usar otros símbolos. Por ejemplo, chequeando la función grafo, tu quieres usar un periodo en vez del espacio, asegura el punto que está siendo reposicionando apropiadamente cada vez que la función <code>insert-rectangle</code> se llama; o se podría querer sustituir un signo <samp>+</samp> u otro símbolo para el asterisco. Se podría incluso querer hacer un graph-column que es más que un ancho de columna. El programa debería ser más flexible. El camino para hacer esto es reemplazar el espacio en blanco y el asterisco con dos variables que se puede llamar <code>graph-blank</code> y <code>graph-symbol</code> y define estas variables separadamente.</p>
<p>También la documentación no está escrita. Estas consideraciones nos llevan también a la segunda versión de la función:</p>
<pre><code class="example">(defvar graph-symbol &quot;*&quot;
  &quot;Cadena usada como símbolo en grafo, normalmente un asterisco.&quot;)

(defvar graph-blank &quot; &quot;
  &quot;La cadena como un espacio en blanco en grafo, normalmente un
  espacio en blanco.
graph-blank debe ser el mismo número de columnas amplio como graph-symbol.&quot;)</code></pre>
<p>(Para una explicación de <code>defvar</code>, ver <a href="Inicializando-una-Variable-con-defvar" >Inicializando una Variable con <code>defvar</code></a>.)</p>
<pre><code class="example">;;; @e{Segunda versión.}
(defun column-of-graph (max-graph-height actual-height)
  &quot;Devuelve cadenas MAX-GRAPH-HEIGHT; ACTUAL-HEIGHT son
  símbolos de grafos.

Los graph-symbols son entradas contiguo al fin de la lista.
La lista será insertado como una columna de un grafo.
Las cadenas son tanto graph-blank o graph-symbol.

  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @e{Rellenar en @c{graph-symbols}.}
    (while (&gt; actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))

    ;; @e{Rellenar en @c{graph-blanks}.}
    (while (&gt; number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @e{Devuelve la lista completa.}
    insert-list))</code></pre>
<p>Si se desea, podríamos reescribir <code>column-of-graph</code> una tercera vez para proporcionar opcionalmente un gráfico de líneas, como gráfico de barras. Esto no sería duro de hacer. Un camino para pensar en un grafo de líneas es que no es más que un grafo de barras en el que la parte de cada barra que está debajo del alto es blanco. Para construir una columna para gráfico de líneas, la función primero construyen una lista de espacios en blanco que es una más ordenada que el valor, entonces usa <code>cons</code> para adjuntar un símbolo gráfico a la lista; entonces eso usa <code>cons</code> de nuevo para adjuntar el ‘alto de espacios en blanco’ a la lista.</p>
<p>Es fácil ver como escribir tal función, pero puesto que no se necesita eso, no se hará. Pero el trabajo podría ser hecho, y si eso se hiciera, se haría con <code>column-of-graph</code>. Incluso más importante, no se valora nada más que pocos cambios que tendrían que ser hechos de cualquier otra manera. La mejora, que se desea hacer, es simple.</p>
<p>Ahora, finalmente, volvemos a nuestra primera función de grafo impresa. Esto imprime el cuerpo de un grafo, no las etiquetas para los ejes horizontal y vertical, así se puede llamar este <code>graph-body-print</code>.</p>
</div>
<h3 id="La-función-graph-body-print" >La función <code>graph-body-print</code></h3>
<div class="hBody-3" >
<p>Después de nuestra preparación en la sección precedente, la función <code>graph-body-print</code> es simple. La función imprimirá la columna después de la columna de asteriscos y espacios en blanco, usando los elementos de la lista de números para especificar el número de asteriscos en cada columna. Esto es un acto repetitivo, que significa que se puede usar un bucle <code>while</code> que decrementa o una función recursiva para el trabajo. En esta sección, se escribirá la definición usando un bucle <code>while</code>.</p>
<p>La función <code>column-of-graph</code> requiere el alto del grafo como un argumento, así se asigna y guarda esto como una variable local.</p>
<p>Esto lidera a la siguiente plantilla para el bucle <code>while</code> versión de esta función:</p>
<pre><code class="example">(defun graph-body-print (numbers-list)
  &quot;@V{documentation}…&quot;
  (let ((height  …
         …))

    (while numbers-list
      @V{insert-columns-and-reposition-point}
      (setq numbers-list (cdr numbers-list)))))</code></pre>
<p>Necesitamos rellenar los slots de la plantilla.</p>
<p>Claramente, se puede usar la expresión <code>(apply 'max numbers-list)</code> para determinar el alto del grafo.</p>
<p>El bucle <code>while</code> iterará a través de <code>numbers-list</code> un elemento a la vez. Como eso está ordenado por la expresión <code>(setq numbers-list (cdr numbers-list))</code>, el <code>car</code> de cada instancia de la lista es el valor del argumento para <code>column-of-graph</code>.</p>
<p>En cada ciclo del bucle <code>while</code>, la función <code>insert-rectangle</code> inserta la lista devuelta por <code>column-of-graph</code>. Desde que la función <code>insert-rectangle</code>, se necesita guardar la localización de punto al tiempo que el rectángulo se inserta, mueve atrás a esta posición después de que el rectángulo es insertado, y entonces se mueve horizontalmente al siguiente lugar desde el que <code>insert-rectangle</code> se llama.</p>
<p>Si las columnas se insertan en un carácter amplio, será si los espacios en blanco y asteriscos se usan, el comando de reposición es simple <code>(forward-char 1)</code>; sin embargo, el ancho de una columna puede ser más grande que uno. Esto significa que el comando de reposicionamiento sería escrito <code>(forward-char symbol-width)</code>. El mejor lugar para asociar la variable <code>symbol-width</code> al valor del width de la columna grafo está en la varlist de la expresión <code>let</code>.</p>
<p>Estas consideraciones lideran a la siguiente definición de función:</p>
<pre><code class="example">(defun graph-body-print (numbers-list)
  &quot;Imprime un gráfico de barras de la NUMBERS-LIST.
La numbers-list consiste en los valores del eje Y.&quot;

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)

    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
      ;; @e{Dibuja la columna del grafo por columna.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @e{Emplaza el punto para etiquetas de ejes X.}
    (forward-line height)
    (insert &quot;\n&quot;)
))</code></pre>
<p>La expresión inesperada en esta función es la expresión <code>(sit-for 0)</code> en el bucle <code>while</code>. Esta expresión hace que el grafo imprima la operación más interesante para vigilar lo que sería de otro modo. La expresión causa que Emacs pare (sit-for 0) para un momento cero y entonces redibuje la pantalla. Puesto aquí, eso causa que Emacs redibuje la pantalla columna por columna. Sin eso, Emacs no redibujaría la pantalla hasta que la función exista.</p>
<p>Se puede chequear <code>graph-body-print</code> con una pequeña lista de números.</p>
<ol>
<li><p>Instala <code>graph-symbol</code>, <code>graph-blank</code>, <code>column-of-graph</code>, que están en <a href="Leyendo-un-grafo" >Leyendo un grafo</a>, and <code>graph-body-print</code>.</p>
</li>
<li><p>Copia la siguiente expresión:</p>
<pre><code class="example">(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))</code></pre>
</li>
<li><p>Cambia al búffer <span class="file" >*scratch*</span> y emplaza el cursor donde quiere que el grafo empiece.</p>
</li>
<li><p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li><p>Pega la expresión <code>graph-body-print</code> dentro del minibúffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li><p>Presiona <kbd>RET</kbd> para evaluar la expresión <code>graph-body-print</code>.</p>
</li>
</ol>
<p>Emacs imprimirá un grafo como este:</p>
<pre><code class="example">        *
    *   **
    *  ****
   *** ****
  ********* *
 ************
*************</code></pre>
</div>
<h3 id="La-función-recursive-graph-body-print" >La función <code>recursive-graph-body-print</code></h3>
<div class="hBody-3" >
<p>La función <code>graph-body-print</code> puede también ser escrito recursivamente. La solución recursiva es dividida dentro de dos partes: una fuera ‘wrapper’ <em>envoltorio</em> que usa una expresión <code>let</code> para determinar los valores varias variables que solo necesitan ser encontradas una vez, tal como la máxima altura del grafo, y una función dentro que es llamada recursivamente para imprimir el grafo.</p>
<p>El ‘envoltorio’ no es complicado:</p>
<pre><code class="example">(defun recursive-graph-body-print (numbers-list)
  &quot;Imprime un gráfico de barras del NUMBERS-LIST.
El numbers-list consiste en los valores del eje Y.&quot;
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))</code></pre>
<p>La función recursiva es un poco más difícil. Eso tiene cuatro partes: el ‘do-again-test’, el código impreso, la llamada recursiva, y la ‘next-step-expression’. El ‘do-again-test’ es una expresión <code>when</code> determina si la <code>numbers-list</code> contiene cualquier elemento que permanece; si hace eso, la función imprime una columna del grafo usando el código impreso y se llama así mismo de nuevo. La función se llama así misma de nuevo de acuerdo al valor producido por la ‘next-step-expression’ que causa para llamar a actuar en una versión ordenada de la <code>numbers-list</code>.</p>
<pre><code class="example">(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  &quot;Imprime un gráfico de barras.
Usado con la función recursive-graph-body-print.&quot;

  (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @e{Dibuja un gráfico columna por columna.}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))</code></pre>
<p>Después de la siguiente instalación, esta expresión puede ser chequeada; aquí hay un ejemplo:</p>
<pre><code class="example">(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))</code></pre>
<p>Aquí está lo que <code>recursive-graph-body-print</code> produce:</p>
<pre><code class="example">    *
   **   *
  ****  *
  **** ***
* *********
************
*************</code></pre>
<p>Cada una de estas dos funciones, <code>graph-body-print</code> o <code>recursive-graph-body-print</code>, crea el cuerpo de un grafo.</p>
</div>
<h3 id="Necesidad-para-ejes-impresos" >Necesidad para ejes impresos</h3>
<div class="hBody-3" >
<p>Un grafo necesita ejes impresos, así se puede orientar a tí mismo. Para un proyecto do-once, eso puede ser razonable dibujar los ejes a mano usando el modo de emacs Picture, pero un grafo dibuja la función que puede ser usada más de una vez.</p>
<p>Por esta razón, se han escrito mejoras a la función básica <code>print-graph-body</code> que automáticamente imprime etiquetas para los ejes horizontal y vertical. Puesto que la etiqueta de imprimir funciones no contiene mucho material nuevo, se ha emplazado su descripción en un apéndice Véase Sección <a href="Un-Grafo-con-Ejes-Etiquetados" >Un Grafo con Ejes Etiquetados</a>.</p>
</div>
<h3 id="Ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Escribe una versión de línea de grafo de la funciones de impresión del grafo.</p>
</div>
<h2 id="Tu-fichero-.emacs" >Tu fichero <span class="file" >.emacs</span></h2>
<div class="hBody-2" >
<p>“No te tiene que gustar Emacs para lo que te gusta”––esto que parece una frase paradójica es el secreto de GNU Emacs. En realidad, Emacs es una herramienta genérica. La mayoría de la gente que usa Emacs, lo personaliza para ajustarlo a sus necesidades.</p>
<p>GNU Emacs está mayoritariamente escrito en Emacs Lisp; esto significa que escribiendo expresiones en Emacs Lisp se puede modificar o extender Emacs.</p>
<p>Hay quien aprecia la configuración por defecto de Emacs. Después de todo, Emacs empieza en modo C cuando se edita un fichero C, empieza en modo Fortran cuando se edita un fichero Fortran, y empieza en modo Fundamental cuando se edita un fichero no adornado. Esto tiene sentido, si no sabes quien está yendo a usar Emacs. ¿Quién sabe lo que una persona espera hacer con un fichero no adornado? El modo fundamental es el modo correcto por defecto para tal fichero, tal como el modo C es lo correcto para editar código C. (Suficientes lenguajes de programación tienen sintaxis que permiten compartir funcionalidades, tal como el modo C es ahora proporcionado por el modo CC, la ‘Colección C’.)</p>
<p>Pero cuando se conoce quien está yendo a usar Emacs––tu, tu mismo––entonces eso tiene sentido para personalizar Emacs.</p>
<p>Por ejemplo, yo raramente quiero el modo Fundamental cuando edito un fichero de otro modo no distinguido; yo quiero el modo Texto. Esto es por lo que yo personalizo Emacs: así eso se ajusta a mí.</p>
<p>Se puede personalizar y extender Emacs escribiendo o adaptando un fichero <span class="file" >~/.emacs</span>. Esto es un fichero de inicialización personal; sus contenidos, escritos en Emacs Lisp, cuentan a Emacs qué hacer.<span class="note" ><sup><a href="#13" >13</a></sup></span></p>
<p>Un fichero <span class="file" >~/.emacs</span> contiene código Emacs Lisp. Se puede escribir este código por uno mismo; o se puede usar la funcionalidad <code>customize</code> para escribir el código para ti. Se puede combinar tus propias expresiones y expresiones auto-escritas personalizadas en tu fichero <span class="file" >.emacs</span>.</p>
<p>(Yo prefiero por mí mismo escribir mis propias expresiones, excepto para estas, fuentes particularmente, que se encuentran fáciles de manipular usando el comando <code>customize</code>. Yo combino los dos métodos.)</p>
<p>La mayoría de este capítulo es acerca de escribir expresiones por uno mismo. Eso describe un fichero <span class="file" >.emacs</span> simple; para más información, mira <cite>El Fichero de Inicio</cite> en <em>El Manual GNU Emacs</em>, y la Seccion <cite>El Fichero de Inicio</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
</div>
<h3 id="Fichero-de-inicialización-site-wide" >Fichero de inicialización site-wide</h3>
<div class="hBody-3" >
<p>Además de tu fichero de inicialización personal, Emacs automáticamente carga varios ficheros de inicialización amplios, si existen. Tienen la misma forma que tu fichero <span class="file" >.emacs</span>, pero se cargan por cualquiera.</p>
<p>Dos ficheros de incialización, <span class="file" >site-load.el</span> y <span class="file" >site-init.el</span>, están cargados dentro de Emacs y volcados <em>dumped</em> sin una versión dumped de Emacs se creó, como es más común. (Las copias dumped de Emacs cargan más rápidamente. Sin embargo, puesto que un fichero se carga y compila, un cambio no llega a ser un cambio en Emacs a menos que se cargue por uno mismo o se recompile Emacs. Véase Sección <cite>Construyendo Emacs</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, y el fichero <span class="file" >INSTALL</span>)</p>
<p>Los otros tres ficheros de inicialización se cargan automáticamente cada vez que se inicia Emacs, si existen. Son <span class="file" >site-start.el</span>, que se carga <em>antes</em> que tu fichero <span class="file" >.emacs</span>, y <span class="file" >default.el</span>, y el tipo de fichero terminal, que se cargan <em>después</em> de tu fichero <span class="file" >.emacs</span>.</p>
<p>Las configuraciones y definiciones en tu fichero <span class="file" >.emacs</span> sobreescribirán las configuraciones en conflicto y definiciones en un fichero <span class="file" >site-start.el</span>, si eso existe; pero las configuraciones y definiciones en un <span class="file" >default.el</span> o el tipo de fichero terminal sobreescribirá estos en tu fichero <span class="file" >.emacs</span>. (Se pueden prevenir interferencias desde un tipo de fichero terminal configurando <code>term-file-prefix</code> para <code>nil</code>. Véase Sección <a href="Una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></a>.)</p>
<p>El fichero <span class="file" >INSTALL</span> que viene en la distribución contiene descripciones de los fichero <span class="file" >site-init.el</span> y <span class="file" >site-load.el</span>.</p>
<p>Los ficheros <span class="file" >loadup.el</span>, <span class="file" >startup.el</span>, y <span class="file" >loaddefs.el</span> controlan la carga. Estos ficheros están en el directorio <span class="file" >lisp</span> de la distribución Emacs y tiene valor de uso.</p>
<p>El fichero <span class="file" >loaddefs.el</span> contiene buenas sugerencias como las que poner dentro de tu propio fichero <span class="file" >.emacs</span>, o dentro de un fichero de inicialización amplio.</p>
</div>
<h3 id="Especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></h3>
<div class="hBody-3" >
<p>Se pueden especificar variables usando <code>defcustom</code> así que la gente pueda usar la funcionalidad de Emacs <code>customize</code> para asignar sus valores. (No se puede usar <code>customize</code> para escribir definiciones de función; pero se pueden escribir <code>defuns</code> en tu fichero <span class="file" >.emacs</span>. En vez de eso, se puede escribir cualquier expresión Lisp en tu fichero <span class="file" >.emacs</span>).</p>
<p>La funcionalidad <code>customize</code> depende de la forma especial <code>defcustom</code>. Aunque se puede usar <code>defvar</code> o <code>setq</code> para las variables que los usuarios asignan, la forma especial <code>defcustom</code> está diseñada para el trabajo.</p>
<p>Se puede usar tu conocimiento de <code>defvar</code> para escribir los primeros tres argumentos para <code>defcustom</code>. El primer argumento para <code>defcustom</code> es el nombre de la variable. El segundo argumento es el valor inicial de la variable, cualquiera; y este valor es asignado solo si el valor no ha sido ya asignado. El tercer argumento es la documentación.</p>
<p>El cuarto y subsiguientes argumentos para <code>defcustom</code> especifican los tipos y opciones; estos no son funcionales en <code>defvar</code>. (Estos argumentos son opcionales.)</p>
<p>Cada uno de estos argumentos consiste de una palabra seguido de una palabra por un valor. Cada palabra clave empieza con los dos puntos <samp>:</samp>.</p>
<p>Por ejemplo, la variable de opciones personalizable <code>text-mode-hook</code> se parece a esto:</p>
<pre><code class="example">(defcustom text-mode-hook nil
  &quot;El hook normal se ejecuta cuando se introduce en modo texto y
  muchos modos relacionados.&quot;
  :type 'hook
  :options '(turn-on-auto-fill flyspell-mode)
  :group 'data)</code></pre>
<p>El nombre de la variable es <code>text-mode-hook</code>; no tiene valor por defecto; y su cadena de documentación cuenta lo que hace.</p>
<p>La palabra clave <code>:type</code> le cuenta a Emacs el tipo de datos para los que <code>text-mode-hook</code> sería asignado y como muestra el valor en un búffer de Personalización.</p>
<p>La palabra clave <code>:options</code> especifica una lista sugerida de valores para la variable. Normalmente, <code>:options</code> se asocia a un gancho (<em>hook</em>. La lista es solo una sugerencia; esa no es exclusiva; una persona quien asigna la variable puede asignarse a otros valores; la lista mostrada siguiendo la palabra clave <code>:options</code> se pretende ofrecer elecciones convenientes a un usuario.</p>
<p>Finalmente, la palabra clave <code>:group</code> cuenta el comando de Personalización de Emacs en el que el grupo de la variable está localizado. Esto cuenta dónde encontralo.</p>
<p>La función <code>defcustom</code> reconoce más de una docena de palabras clave. Para más información, mire <cite>Escribiendo las Definiciones de Personalización</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
<p>Considere <code>text-mode-hook</code> como un ejemplo.</p>
<p>Hay dos caminos para personalizar esta variable. Se puede usar el comando de personalización o escribir las expresiones apropiadas por uno mismo.</p>
<p>Usando el comando de personalización, se puede escribir:</p>
<pre><code class="example">M-x customize</code></pre>
<p>y encuentre que el grupo para editar ficheros de datos se llama ‘datos’. Introduzca este grupo. El Hook <em>Disparador</em> es el primer miembro. Se puede hacer click en sus opciones varias, tal como <code>turn-on-auto-fill</code>, para asignar los valores. Después de hacer click en el botón.</p>
<pre><code class="example">Guárdalo para Futuras Sesiones</code></pre>
<p>Emacs escribirá una expresión en tu fichero <span class="file" >.emacs</span>. Se parecerá a esto:</p>
<pre><code class="example">(custom-set-variables
  ;; custom-set-variables fué añadido por Custom.
  ;; Si se edita a mano, tu podrías liarte,
  ;; así que ten cuidado.
  ;; Tu fichero init contendría solo esta instancia.
  ;; Si hay más de uno, ellos no quieren trabajar.
 '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))</code></pre>
<p>(La función <code>text-mode-hook-identify</code> cuenta <code>toggle-text-mode-auto-fill</code> que buffers hay en modo Texto.  Eso viene automáticamente)</p>
<p>La función <code>custom-set-variables</code> funciona de alguna manera diferente más de un <code>setq</code>. Mientras yo nunca he aprendido las diferencias, yo modifico las expresiones <code>custom-set-variable</code> en mi fichero <span class="file" >.emacs</span> a mano: yo creo los cambios en los que aparecen a mi para ser una manera razonable y no tener problemas. Otros prefieren usar el comando de Personalización y permitir a Emacs hacer el trabajo para ellos.</p>
<p>Otra función <code>custom-set-…</code> es <code>custom-set-faces</code>. Esta función asigna varios tipos de fuentes. A través del tiempo, yo he asignado un considerable número de tipos. Algo de tiempo, yo las reseteo usando <code>customize</code>; otras veces, simplemente edito la expresión <code>custom-set-faces</code> en mi fichero <span class="file" >.emacs</span> en sí.</p>
<p>El segundo modo de personalizar tu <code>text-mode-hook</code> es asignarte a tí mismo en tu fichero <span class="file" >.emacs</span> usando código que no tiene nada que hacer con las funciones <code>custom-set-…</code>.</p>
<p>Cuando se hace esto, y después usa <code>customize</code>, se verá un mensaje que dice:</p>
<pre><code class="example">CHANGED fuera de Personalizar; operando dentro aquí
puede ser no confiable.</code></pre>
<p>Este mensaje es solo un aviso. Si se puede cliquear en el botón a</p>
<pre><code class="example">Guárdalo para Futuras Sesiones</code></pre>
<p>Emacs escribirá una expresión <code>custom-set-…</code> cerca del fin de tu fichero <span class="file" >.emacs</span> que será evaluado después de que tu expresión sea escrita a mano. Por esta razón, se sobreescribirá tu expresión escrita a mano. Ningún daño será hecho. Cuando se haga esto, sin embargo, ten cuidado para recordar que expresión está activa; si olvidas, puedes confundirte por tí mismo.</p>
<p>Tan largo como se recuerda donde los valores son configurados, no habrá problemas. En cualquier eventos, los valores son siempre configurados en tu fichero de inicialización, que es normalmente llamado <span class="file" >.emacs</span>.</p>
<p>Yo mismo hago un <code>customize</code> para cualquier cosa. Mayoritariamente, escribo expresiones por mí mismo.</p>
<p>Incidentalmente, para ser una definición concerniente más completa: <code>defsubst</code> define una función inline. La sintaxis es solo como esta de <code>defun</code>. <code>defconst</code> define un símbolo como una constante. El intento es que ningún programa o usuario cambiarían un valor asignado por <code>defconst</code>. (Se puede cambiar; el valor asignado es una variable; pero por favor no lo haga.)</p>
</div>
<h3 id="Empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></h3>
<div class="hBody-3" >
<p>Cuando se abre Emacs, se carga tu fichero <span class="file" >.emacs</span> a menos que se cuente que no se especifique <samp>-q</samp> en la línea de comandos. (El comando <code>emacs -q</code> tu da un Emacs plano, fuera.)</p>
<p>Un fichero <span class="file" >.emacs</span> contiene expresiones Lisp. Con frecuencia, no hay más expresiones para configura valores; algunas veces esas son definiciones de funciones.</p>
<p>Véase Sección <a href="El-Fichero-de-Inicio-~/.emacs-en-El-Manual-GNU-Emacs,-para-una-corta-descripción-de-fichero-de-inicialización." >El Fichero de Inicio <span class="file" >~/.emacs</span> en <em>El Manual GNU Emacs</em>, para una corta descripción de fichero de inicialización.</a></p>
<p>Este capítulo cubre algo del mismo suelo, pero es un paseo entre extractos desde un completo, largamente usado fichero <span class="file" >.emacs</span>––por mí.</p>
<p>La primera parte del fichero consiste en comentario: me recuerdo a mí mismo. Por ahora, yo recuerdo estas cosas, pero cuando empecé, no.</p>
<pre><code class="example">;;;; fichero .emacs de Bob
; Robert J. Chassell
; 26 de Septiembre de 1985</code></pre>
<p>¡Mira en esta fecha! Yo empecé este fichero hace mucho tiempo. Yo he estado añadiendo cosas desde siempre.</p>
<pre><code class="example">; Cada sección en este fichero es introducido por una
; línea empezando con cuatro puntos y comas y cada
; entrada es introducida por una línea empezando con
; tres puntos y comas.</code></pre>
<p>Esto describe las convenciones usuales para comentarios en Emacs Lisp. Cada cosa en una línea que sigue un punto y coma es un comentario. Dos, tres, y cuatro puntos y coma son usados como subsección y marcas de sección. (Véase Sección <cite>Comentarios</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más comentarios.)</p>
<pre><code class="example">;;;; La Tecla de Ayuda
; Control-h es la tecla de ayuda;
; después escribiendo control-h, escribe una letra a
; indica el asunto acerca del que quieres ayuda.
; Para una explicación de la facilidad de ayuda,
; escribe control-h dos veces en una fila.</code></pre>
<p>Solo recuerda: escribe <kbd>C-h</kbd> dos veces para ayudar.</p>
<pre><code class="example">; Para informarse acerca de cualquier modo, escribe control-h m
; mientras esté en este modo. Por ejemplo, para encontrar
; acerca del modo correo, introduce el modo correo y entonces
; escribe control-h m.</code></pre>
<p>‘Modo ayuda’, como yo llamo a esto, es muy útil. Usualmente, se cuenta todo lo que se necesita saber.</p>
<p>De acuerdo, no se necesitan incluir comentarios y ficheros como estos <span class="file" >.emacs</span>. Yo los incluí en el mío porque se olvida el Modo ayuda o las convenciones para comentarios––pero era capaz de recordar ver aquí recordármelo a mí mismo.</p>
</div>
<h3 id="Modo-texto-y-auto-relleno" >Modo texto y auto relleno</h3>
<div class="hBody-3" >
<p>Ahora regresa a la parte que ‘vuelve’ al modo Texto y modo Auto Relleno.</p>
<pre><code class="example">;;; Modo texto modo Auto Fill
;; Las siguiente dos líneas puestas en Emacs dentro de
;; modo Texto y en el modo Auto Fill, son para escritores que
;; quieren empezar a escribir prosa en vez de código.
(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)</code></pre>
<p>¡Aquí está la primera parte de este fichero <span class="file" >.emacs</span> que hace alguna cosa bajo recuerdo de un humano olvidado!</p>
<p>La primera de las dos líneas entre paréntesis cuentan a Emacs a cambiar al modo Texto que se encuentra un fichero, <em>a menos que</em> el fichero iría dentro de algún otro modo, tal como el modo C.</p>
<p>Cuando Emacs lee un fichero, eso parece la extensión al nombre del fichero. (La extensión es la parte que viene después de un <samp>.</samp>.) Si el fichero finaliza con una extensión <samp>.c</samp> o <samp>.h</samp> entonces Emacs cambia al modo C. También, Emacs parece al principio una línea no blanca del fichero; si la línea dice <samp>-*- C -*-</samp>, Emacs cambia al modo C. Emacs posee una lista de extensiones y especificaciones que usa automáticamente. Además, Emacs se ve cerca de la última página por buffer, “lista variables locales”.</p>
<p>Mira las secciones “Cómo los Modos Mayores son Elegidos” y “Variables Locales en Fichero” en <em>El Manual GNU Emacs</em>.</p>
<p>Ahora, regresa al fichero <span class="file" >.emacs</span>.</p>
<p>Aquí está la línea de nuevo; ¿cómo funciona?</p>
<pre><code class="example">(setq major-mode 'text-mode)</code></pre>
<p>Esta línea es un resumen, pero completa la expresión Emacs Lisp.</p>
<p>Ya estamos familiarizados con <code>setq</code>. Eso asigna la siguiente variable, <code>major-mode</code>, al subsiguiente valor, que es <code>text-mode</code>. La marca de cita simple antes de <code>text-mode</code> cuenta a Emacs como tratar directamente con el símbolo, no con cualquier cosa que pudiera existir. Véase Sección <a href="Configurando-el-Valor-de-una-Variable" >Configurando el Valor de una Variable</a>, por un recuerdo de como <code>setq</code> funciona. El principal punto es que no hay diferencia entre el procedimiento que se usa para asignar un valor en su fichero <span class="file" >.emacs</span> y el procedimiento que se usa en cualquier lugar más en Emacs.</p>
<p>Aquí está la siguiente línea:</p>
<pre><code class="example">(add-hook 'text-mode-hook 'turn-on-auto-fill)</code></pre>
<p>En esta línea, el comando <code>add-hook</code> añade <code>turn-on-auto-fill</code> para la variable.</p>
<p>¡<code>turn-on-auto-fill</code> es el nombre de un programa, que se adivina!, cambia al modo Auto Fill.</p>
<p>Cada vez que Emacs cambia al modo texto, Emacs ejecuta el comando ‘hooked’ dentro de modo Texto. Así que cada vez que Emacs cambia al modo Texto, Emacs también cambia al modo de autoajuste.</p>
<p>En breve, la primera línea causa a Emacs a entrar en modo Texto cuando se edite un fichero, a menos que la extensión del nombre del fichero, una línea no en blanco, variables locales para contar a Emacs de otro modo.</p>
<p>El modo texto entre otras acciones, asigna la tabla de sintaxis para trabajar adecuadamente a escritores. En modo texto, Emacs considera un apóstrofe como parte de una palabra como una letra; pero Emacs no considera un período o un espacio como parte de una palabra. De este modo, <kbd>M-f</kbd> se mueve hacia tí a través de <samp>eso</samp>. Por otro lado, en modo C, <kbd>M-f</kbd> para solo después del <samp>t</samp> de <samp>eso</samp>.</p>
<p>La segunda línea causa que Emacs active el modo Auto Fill cuando cambia al modo Texto. En modo Auto Fill, Emacs automáticamente rompe una línea que es demasiado amplio y trae la parte excesivamente amplia de la línea de debajo a la siguiente línea. Emacs rompe líneas entre palabras con ellas.</p>
<p>Cuando el modo Auto Fill está desactivado, las líneas continúan a la derecha como se escriben. Dependiendo de como configuras el valor de <code>truncate-lines</code>, las palabras que se escribe si desaparecen al lado derecho de la pantalla, o lo demás son mostradas, en un modo feo e ilegible, como una línea de continuación en la pantalla.</p>
<p>Además, en esta parte de mi fichero <span class="file" >.emacs</span>, yo cuento a Emacs el ajuste de comandos para insertar dos espacios después de dos puntos:</p>
<pre><code class="example">(setq colon-double-space t)</code></pre>
</div>
<h3 id="Alias-de-correo" >Alias de correo</h3>
<div class="hBody-3" >
<p>Aquí hay un <code>setq</code> que ‘activa’ el alias de correo, para más ocasiones.</p>
<pre><code class="example">;;; Modo Correo
; Para entrar en el modo correo, escribe ‘C-x m’
; Para introducir RMAIL (para leer el correo),
; escribe ‘M-x rmail’
(setq mail-aliases t)</code></pre>
<p>Este comando <code>setq</code> asigna el valor de la variable <code>mail-aliases</code> al <code>t</code>. Desde que <code>t</code> significa cierto, la línea dice, en efecto, “Sí uso alias de correo.”</p>
<p>Los alias de correo son nombres cortos convenientes para largas direcciones de correo o para listas de direcciones de correo. El fichero donde guardar tus ‘aliases’ es <span class="file" >~/.mailrc</span>. Se escribe un alias como este:</p>
<pre><code class="example">alias geo george@@foobar.wiz.edu</code></pre>
<p>Cuando se escribe un mensaje a Jorge, la dirección a <samp>geo</samp>; el correo automáticamente expandirá <samp>geo</samp> a la dirección completa.</p>
</div>
<h3 id="Indentar-modo-de-tabulaciones" >Indentar modo de tabulaciones</h3>
<div class="hBody-3" >
<p>Por defecto, Emacs inserta tabulaciones en lugar en múltiples espacios cuando se formatea una región. (Por ejemplo, se podrían indentar muchas líneas de texto todo a la vez con el comando <code>indent-region</code>.) Los tabuladores se ven bien en un terminal o con impresión ordinaria, pero ellos producen mala salida de indentación cuando se usa T<sub>E</sub>X o Texinfo puesto que T<sub>E</sub>X ignora tabuladores.</p>
<p>Lo siguiente desactiva el modo de Indentar Tabulaciones:</p>
<pre><code class="example">;;; Prevenir Tabulaciones Extrañas
(setq-default indent-tabs-mode nil)</code></pre>
<p>Note que esta línea usa <code>setq-default</code> en vez de el comando <code>setq</code> que hemos visto antes. El comando <code>setq-default</code> asigna valores solo en búffers que no tienen sus propios valores locales para la variable.</p>
<p>Ver secciones “Tabuladores versus Espacios” y “Variables Locales en Ficheros” en <em>El Manual de GNU Emacs</em>.</p>
</div>
<h3 id="Atajos-de-teclado" >Atajos de teclado</h3>
<div class="hBody-3" >
<p>Ahora para algunos atajos personales:</p>
<pre><code class="example">;;; Compara ventanas
(global-set-key &quot;\C-cw&quot; 'compare-windows)</code></pre>
<p><code>compare-windows</code> es un comando excelente que compara el texto en tu ventana actual con texto de la siguiente ventana. Eso hace la comparación empezando al punto en cada ventana, moviendo a través del texto en cada ventana tan lejos como ellos asocian. Yo uso este comando todo el tiempo.</p>
<p>Esto también muestra como configurar una tecla globalmente, para todo los modos</p>
<p>El comando es <code>global-set-key</code>. Es seguido por el atajo. En un fichero <span class="file" >.emacs</span>, el atajo es escrito como se ve: <code>\C-c</code> que se asocia a ‘control-c’, que significa ‘presionar la tecla de control y la tecla <kbd>c</kbd> al mismo tiempo’. La <code>w</code> significa ‘presionar la tecla <kbd>w</kbd>’. El atajo es rodeado por dobles comillas. En la documentación, se escribiría esto como <kbd>C-c w</kbd>. (Si estuviera asociando una tecla <kbd>META</kbd>, tal como <kbd>M-c</kbd>, en vez de una tecla de <kbd>CTRL</kbd>, se escribiría <code>\M-c</code> en su fichero <span class="file" >.emacs</span>. Véase Sección <cite>Reasociando Teclas en Su Fichero Init</cite> en <em>El Manual de GNU Emacs</em>, para más detalles.)</p>
<p>El comando invocado por las teclas es <code>compare-windows</code>. Note que <code>compare-windows</code> es precedido por una comilla simple; de otro modo, Emacs primero intentaría evaluar el símbolo para determinar su valor.</p>
<p>Estas tres cosas, las marcas de dobles comillas, la barra invertida antes de la <samp>C</samp>, y la marca de comilla simple son partes necesarias de atajos de teclado que tiendo a olvidar. Afortunadamente, he llegado a recordar que miraría mi fichero <span class="file" >.emacs</span> existente, y lo adaptaría a lo que hay.</p>
<p>Como para el atajo en sí: <kbd>C-c w</kbd>, combina la tecla prefija, <kbd>C-c</kbd>, con un caracter simple, en este caso, <kbd>w</kbd>. Este conjunto de teclas, <kbd>C-c</kbd> seguido por un caracter simple, es estrictamente reservado para un uso propio individual. (Esto se llama teclas ‘propias’, puesto que estas son para su propio uso). Siempre sería capaz de crear tal atajo para el uso propio sin pisar fuerte en algún atajo más. Si siempre se escribe una extensión a Emacs, por favor, evite tomar cualquiera de estas teclas para uso público. Se cree que una tecla como <kbd>C-c C-w</kbd> en vez de eso. De otra manera, ejecutará sin sus ‘propias’ teclas.</p>
<p>Aquí hay otro atajo, con un comentario:</p>
<pre><code class="example">;;; Atajo para ‘occur’
; Yo uso mucho occur, así permite asignarlo a una tecla:
(global-set-key &quot;\C-co&quot; 'occur)</code></pre>
<p>El comando <code>occur</code> muestra todas las líneas en el buffer actual que contiene un emparejamiento para una expresión regular. Asociar las líneas que se muestran en un búffer llamado <span class="file" >*Occur*</span>. Este buffer sirve como un menu para saltar a ocurrencias.</p>
<p>Aquí se muestra como desasignar una tecla, así no funciona:</p>
<pre><code class="example">;;; Desasociar ‘C-x f’
(global-unset-key &quot;\C-xf&quot;)</code></pre>
<p>Hay una razón para esta no asociación: Yo encontré inadvertidamente escrito <kbd>C-x f</kbd> cuando significó escribir <kbd>C-x C-f</kbd>. En vez de encontrar un fichero, como se pretende, accidentalmente asigna el ancho para el fichero lleno, casi siempre a un tamaño que no quería. Puesto que duramente se reseteó mi ancho por defecto, yo simplemente disocié la tecla.</p>
<p>Lo siguiente reasocia una tecla existente:</p>
<pre><code class="example">;;; Reasocia ‘C-x C-b’ al ‘buffer-menu’
(global-set-key &quot;\C-x\C-b&quot; 'buffer-menu)</code></pre>
<p>Por defecto, <kbd>C-x C-b</kbd> ejecute el comando <code>list-buffers</code>. Este comando lista sus buffers en <em>otra</em> ventana. Desde que casi siempre se quiere hacer alguna cosa en esta ventana, se prefiere el comando <code>buffer-menu</code>, que no solo lista los buffers, pero mueve el punto dentro de esta ventana.</p>
</div>
<h3 id="Mapas-de-teclado" >Mapas de teclado</h3>
<div class="hBody-3" >
<p>Emacs usa <dfn>keymaps</dfn> para grabar qué teclas llaman a qué comandos. Cuando se use <code>global-set-key</code> para asignar los atajos de teclados a un simple comando en todo <code>current-global-map</code>.</p>
<p>Modos específicos, tales como modo C o modo Texto, tiene sus propios mapas de teclado; mapas de teclado de modo específico sobreescribe el mapa global que es compartido por todos los buffers.</p>
<p>La función <code>global-set-key</code> asocia, o reasocia, el mapa de teclado global. Por ejemplo, las siguientes asociaciones la tecla <kbd>C-x C-b</kbd> a la función <code>buffer-menu</code>:</p>
<pre><code class="example">(global-set-key &quot;\C-x\C-b&quot; 'buffer-menu)</code></pre>
<p>Mapas de teclado específico de modo son asociados usando la función <code>define-key</code>, que toma un mapa de teclado específico como un argumento, tan bien como la tecla y el comando. Por ejemplo, mi fichero <span class="file" >.emacs</span> contiene la siguiente expresión asociada al comando <code>texinfo-insert-@group</code> comando a <kbd>C-c C-c g</kbd>:</p>
<pre><code class="example">(define-key texinfo-mode-map &quot;\C-c\C-cg&quot; 'texinfo-insert-@@group)</code></pre>
<p>La función <code>texinfo-insert-@group</code> en sí es una pequeña extensión del modo Texinfo que inserta <samp>@group</samp> dentro de un fichero Texinfo. Se usa este comando todo el tiempo y se prefieren escribir los tres atajos <kbd>C-c C-c g</kbd> en vez de los seis atajos <kbd>@ g r o u p</kbd>. (<samp>@group</samp> y su asociación <samp>@end group</samp> son comandos que guarda todo el texto cerrado junto a una página; muchos ejemplos multi-línea en este libro están rodeados por <samp>@group … @end group</samp>.)</p>
<p>Aquí está la definición de función <code>texinfo-insert-@group</code>:</p>
<pre><code class="example">(defun texinfo-insert-@@group ()
  &quot;Inserta la cadena @@group en un búffer Texinfo.&quot;
  (interactive)
  (beginning-of-line)
  (insert &quot;@@group\n&quot;))</code></pre>
<p>(De acuerdo, podría haber usado el modo Abbrev para dejar de escribir, en vez de escribir una función para insertar una palabra; pero prefiero atajos de teclado consitentes con otro modo Texinfo para atajos de teclado.)</p>
<p>Verá numerosas expresiones <code>define-key</code> en <span class="file" >loaddefs.el</span> tan bien como en varios modos de librerías, tal como <span class="file" >cc-mode.el</span> y <span class="file" >lisp-mode.el</span>.</p>
<p>Véase Sección <cite>Personalizando Atajos de Teclado</cite> en <em>El Manual GNU Emacs</em>, y <cite>Mapas de Teclado</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más información acerca de mapas de teclado.</p>
</div>
<h3 id="Cargando-ficheros" >Cargando ficheros</h3>
<div class="hBody-3" >
<p>Muchas personas en la comunidad de GNU Emacs han escrito extensiones a Emacs. Hace tiempo, que estas extensiones son con frecuencia incluidas en las nuevas entregas <em>releases</em>. Por ejemplo, los paquetes Calendario y Diario son ahora parte del estándar GNU Emacs, como es Calc.</p>
<p>Se puede usar un comando <code>load</code> para evaluar un fichero completo que significa instalar todas las funciones y variables en el fichero Emacs. Por ejemplo:</p>
<pre><code class="example">(load &quot;~/emacs/slowsplit&quot;)</code></pre>
<p>Esto evalúa, por ej.@: carga, el fichero <span class="file" >slowsplit.el</span> o si eso existe, lo más rápido, el fichero compilado <span class="file" >slowsplit.elc</span> desde el subdirectorio <span class="file" >emacs</span> del directorio home. El fichero contiene la función <code>split-window-quietly</code>, que John Robinson escribió en 1989.</p>
<p>La función <code>split-window-quietly</code> divide una ventana con el mínimo de redisplay. Yo lo instalé en 1989 porque trabajó bien con los terminales de 1200 baudios que entonces estaba usando. Ahora, ocasionalmente vengo a través de una conexión lenta, pero continúa usando la función porque me gusta el camino que deja arriba del búffer en el bajo de las nuevas ventanas y arriba en la ventana superior.</p>
<p>Para reemplazar el atajo de teclado por defecto <code>split-window-vertically</code>, se debe también desasignar esta tecla y asociar las teclas a <code>split-window-quietly</code>, como este:</p>
<pre><code class="example">(global-unset-key &quot;\C-x2&quot;)
(global-set-key &quot;\C-x2&quot; 'split-window-quietly)</code></pre>
<p>Si se cargan muchas extensiones, como yo hago, entonces en vez de especificar la posición exacta del fichero, como se muestra arriba, se puede especificar que directorio como parte del <code>load-path</code> de Emacs. Entonces, cuando Emacs carga un fichero, buscará que directorio tan bien como su lista por defecto de directorios. (La lista por defecto es especificada en <span class="file" >paths.h</span> cuando Emacs se construye.)</p>
<p>El comando siguiente añade tu directorio <span class="file" >~/emacs</span> a la ruta existente:</p>
<pre><code class="example">;;; Ruta Emacs
(setq load-path (cons &quot;~/emacs&quot; load-path))</code></pre>
<p>Incidentalmente, <code>load-library</code> es un interfaz interactivo a la función <code>load</code>. La función se parece a esto:</p>
<pre><code class="example">(defun load-library (library)
  &quot;Carga la librería llamada LIBRARY.
Esto es una interfaz a la función ‘load’.&quot;
  (interactive
   (list (completing-read &quot;Carga la librería: &quot;
                          (apply-partially 'locate-file-completion-table
                                           load-path
                                           (get-load-suffixes)))))
  (load library))</code></pre>
<p>El nombre de la función, <code>load-libray</code>, viene desde el uso de ‘library’ como un sinónimo para ‘file’. La fuente para el comando <code>load-library</code> está en la librería <span class="file" >files.el</span>.</p>
<p>Otro comando interactivo que hace un trabajo ligeramente diferente es <code>load-file</code>. Véase Sección <cite>Librerías de Código Lisp para Emacs</cite> en <em>El Manual GNU Emacs</em>, para información en la distinción entre <code>load-library</code> y este comando.</p>
</div>
<h3 id="Autoloading" >Autoloading</h3>
<div class="hBody-3" >
<p>En vez de instalar una función cargando el fichero que lo contiene, o evaluando la definición de función, se puede hacer la función disponible pero actualmente no se instala hasta la primera vez llamada. Este proceso se llama <dfn>autocarga</dfn> (<em>autoloading</em>).</p>
<p>Cuando se ejecuta una función de autocarga, Emacs automáticamente evalúa el fichero que contiene la definición, y entonces llama a la función.</p>
<p>Emacs empieza rápido con funciones de autocarga, puesto que sus librerías no se cargan bien; pero si necesita esperar un momento cuando su primer uso tal como una función, mientras que el fichero que lo contiene se evalúa.</p>
<p>Raramente las funciones usadas son frecuentemente autocargadas. La librería <span class="file" >loaddefs.el</span> coniene cientos de funciones autocargadas, desde <code>bookmark-set</code> a <code>wordstar-mode</code>. Si se usa una función ‘rara’ frecuentemente, se debería cargar este fichero de función con una expresión de <code>load</code> en tu fichero <span class="file" >.emacs</span>.</p>
<p>En mi fichero <span class="file" >.emacs</span>, se cargan 14 librerías que contienen funciones que de otro modo serían autocargadas. (Actualmente, eso habría sido mejor para incluir estos ficheros en mi Emacs ‘volcado’, pero se olvida. Véase Sección <cite>Construyendo Emacs</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>, y el fichero <span class="file" >INSTALL</span> para más acerca de volcados.)</p>
<p>Se puede también querer incluir expresiones autocargadas en tu fichero <span class="file" >.emacs</span>. <code>autoload</code> es una función construida que toma cinco argumento, los tres finales de los que son opcionales. El primer argumento es el nombre de la función para ser autocargada. El segundo es el nombre del fichero para ser cargado. El tercer argumento es documentación para la función, y el cuarto cuenta si la función puede ser llamada interactivmente. El quinto argumento cuenta que tipo de objeto––<code>autoload</code> puede manejar un mapa de teclado o macro tan bien como una función (por defecto es una función).</p>
<p>Aquí hay un ejemplo típico:</p>
<pre><code class="example">(autoload 'html-helper-mode
  &quot;html-helper-mode&quot; &quot;Editar documentos HTML&quot; t)</code></pre>
<p>(<code>html-helper-mode</code> es una vieja alternativa a <code>html-mode</code>, que es una parte estándar de la distribución.)</p>
<p>Esta expresión autocarga la función <code>html-helper-mode</code>. Esto se toma desde el fichero <span class="file" >html-helper-mode-el</span> (o desde la versión compilada <span class="file" >html-helper-mode.elc</span>, si eso existe). El fichero debe ser localizado en un directorio específico por <code>load-path</code>. La documentación dice que esto es un modo para ayudar a editar documentos escritos en Lenguaje de Marcas de Hiper Texto. Se puede llamar este modo interactivamente escribiendo <kbd>M-x html-helper-mode</kbd>. (Se necesitan duplicar las funciones regulares de documentación en la expresión de autocarga porque la función regular no está todavía cargada, así su documentación no está disponible.)</p>
<p>Véase Sección <cite>Autocarga</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.</p>
</div>
<h3 id="Una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></h3>
<div class="hBody-3" >
<p>Aquí hay una simple extensión a Emacs que mueve el punto de línea arriba de la ventana. Yo uso esto todo el tiempo, para hacer fácil de leer el texto.</p>
<p>Se puede poner el siguiente código dentro de un fichero separado y entonce cargarlo desde tu fichero <span class="file" >.emacs</span>, o se puede incluir con tu fichero <span class="file" >.emacs</span>.</p>
<p>Aquí está la definición</p>
<pre><code class="example">;;; Línea a lo alto de la ventana;
;;; reemplaza tres secuencias de atajos de teclado  C-u 0 C-l
(defun line-to-top-of-window ()
  &quot;Mueve la línea que apunta a lo alto de la ventana.&quot;
  (interactive)
  (recenter 0))</code></pre>
<p>Ahora el atajo.</p>
<p>En estos días, las teclas de función así como los eventos del ratón y caracteres no <code>ascii</code> son escritos con corchetes, sin marcas de citas. (En Emacs versión 18 y anteriores, se tenía que escribir diferentes teclas de función asignadas por cada diferente creación del terminal.)</p>
<p>Se puede asociar <code>line-to-top-of-window</code> a la tecla de función <kbd>F6</kbd> así:</p>
<pre><code class="example">(global-set-key [f6] 'line-to-top-of-window)</code></pre>
<p>Para más información, mira <cite>Reasociando Teclas en tu fichero init</cite> en <em>El Manual GNU Emacs</em>.</p>
<p>Si ejecutas dos versiones de GNU Emacs, tal como las versiones 22 y 23, y usas un fichero <span class="file" >.emacs</span>, se puede seleccionar qué código evalúa el siguiente condicional:</p>
<pre><code class="example">(cond
 ((= 22 emacs-major-version)
  ;; evalúa la version 22
  ( … ))
 ((= 23 emacs-major-version)
  ;; evalúa la version 23
  ( … )))</code></pre>
<p>Por ejemplo, en versiones más recientes se ocultan los cursores por defecto. Si se odia tal ocultación se escribe lo siguiente en mi fichero <span class="file" >.emacs</span><span class="note" ><sup><a href="#14" >14</a></sup></span>:</p>
<pre><code class="example">(when (&gt;= emacs-major-version 21)
  (blink-cursor-mode 0)
  ;; Inserta la nueva línea cuando se presiona ‘C-n’ (next-line)
  ;; al fin del búffer
  (setq next-line-add-newlines t)
  ;; Cambia la imagen viendo
  (auto-image-file-mode t)
  ;; Activa la barra de menu (esta barra tiene texto)
  ;; (Usa un argumento numérico para activarlo)
  (menu-bar-mode 1)
   ;; Desactiva la barra de herramientas (esta barra tiene iconos)
   ;; (Usa argumentos numéricos para activarlo)
   (tool-bar-mode nil)
  ;; Desactiva el modo tooltip para la tool bar
  ;; (Este modo causa explicaciones de iconos al pop up)
  ;; (Usa el argumento numérico para activarlo)
  (tooltip-mode nil)
  ;; Si los tooltips activados, crea consejos aparecen en el prompt
  (setq tooltip-delay 0.1)  ; por defecto es de 0.7 segundos
   )</code></pre>
</div>
<h3 id="Colores-X11" >Colores X11</h3>
<div class="hBody-3" >
<p>Se pueden especificar colores cuando se usa Emacs con el Sistema de Ventanas X del MIT.</p>
<p>Si disgustan los colores por defecto y especifica unos propios.</p>
<p>Aquí están las expresiones en un fichero <span class="file" >.emacs</span> que establecen los valores:</p>
<pre><code class="example">;; Asigna el color del cursor
(set-cursor-color &quot;white&quot;)

;; Asigna el color del ratón
(set-mouse-color &quot;white&quot;)

;; Asigna foreground y background
(set-foreground-color &quot;white&quot;)
(set-background-color &quot;darkblue&quot;)

;;; Asigna colores para isearch y drag
(set-face-foreground 'highlight &quot;white&quot;)
(set-face-background 'highlight &quot;blue&quot;)

(set-face-foreground 'region &quot;cyan&quot;)
(set-face-background 'region &quot;blue&quot;)

(set-face-foreground 'secondary-selection &quot;skyblue&quot;)
(set-face-background 'secondary-selection &quot;darkblue&quot;)

;; Asigna colores al calendario
(setq calendar-load-hook
      '(lambda ()
         (set-face-foreground 'diary-face   &quot;skyblue&quot;)
         (set-face-background 'holiday-face &quot;slate blue&quot;)
         (set-face-foreground 'holiday-face &quot;white&quot;)))</code></pre>
<p>Las varias sombras de azul disparan mi ojo y me preveen de ver la ventana desplegada.</p>
<p>Alternativamente, se podrían haber configurado mis especificaciones en varios ficheros inicialización de X. Por ejemplo, se podría asignar el foreground, background, cursor y puntero (por ej., ratón) colores en mi fichero <span class="file" >~/.Xresources</span> como esto:</p>
<pre><code class="example">Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white</code></pre>
<p>En cualquier evento que no es parte de Emacs, se asigna el color raíz de mi ventana X en mi fichero <span class="file" >~/.xinitrc</span>, como este<span class="note" ><sup><a href="#15" >15</a></sup></span></p>
<pre><code class="example">xsetroot -solid Navy -fg white &amp;</code></pre>
</div>
<h3 id="Configuraciones-misceláneas-para-un-fichero-.emacs" >Configuraciones misceláneas para un fichero <span class="file" >.emacs</span></h3>
<div class="hBody-3" >
<p>Aquí hay unas pocas configuraciones misceláneas:</p>
<ul>
<li><p>Asigna la forma y color del ratón del cursor:</p>
<pre><code class="example">; Formas de Cursor están definidas en
; ‘/usr/include/X11/cursorfont.h’;
; por ejemplo, el cursor ‘objetivo’ es número 128;
; el cursor ‘top_left_arrow’ es el número 132.

(let ((mpointer (x-get-resource &quot;*mpointer&quot;
                                &quot;*emacs*mpointer&quot;)))
  ;; Si no se ha asignado tu puntero de ratón
  ;; entonces asignalo, de otro modo, déjalo así:
  (if (eq mpointer nil)
      (setq mpointer &quot;132&quot;)) ; top_left_arrow
  (setq x-pointer-shape (string-to-int mpointer))
  (set-mouse-color &quot;white&quot;))</code></pre>
</li>
<li><p>O se pueden asignar los valores de una variedad de funcionalidades en una alist, como esta:</p>
<pre><code class="example">(setq-default
 default-frame-alist
 '((cursor-color . &quot;white&quot;)
   (mouse-color . &quot;white&quot;)
   (foreground-color . &quot;white&quot;)
   (background-color . &quot;DodgerBlue4&quot;)
   ;; (cursor-type . bar)
   (cursor-type . box)
   (tool-bar-lines . 0)
   (menu-bar-lines . 1)
   (width . 80)
   (height . 58)
   (font .
         &quot;-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1&quot;)
   ))</code></pre>
</li>
<li><p>Convierte <kbd><kbd>CTRL</kbd>-h</kbd> dentro <kbd>DEL</kbd> y <kbd>DEL</kbd> dentro de <kbd><kbd>CTRL</kbd>-h</kbd>.@* (Algunos viejos teclados lo necesitan, aunque yo no he visto el problema recientemente.)</p>
<pre><code class="example">;; Traducir ‘C-h’ a &lt;DEL&gt;.
; (keyboard-translate ?\C-h ?\C-?)

;; Traducir &lt;DEL&gt; a ‘C-h’.
(keyboard-translate ?\C-? ?\C-h)</code></pre>
</li>
<li><p>¡Desactiva un cursor oculto!</p>
<pre><code class="example">(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))</code></pre>
<p>o empieza GNU Emacs con el comando <code>emacs -nbc</code>.</p>
</li>
<li><p>Cuando se usa ‘grep’</p>
<dl>
<dt><p><samp>-i</samp></p>
</dt>
<dd><p>Ignore distinciones de letras@*</p>
</dd>
<dt><p><samp>-n</samp></p>
</dt>
<dd><p>El prefijo de cada línea de la salida con el número de líneas@*</p>
</dd>
<dt><p><samp>-H</samp></p>
</dt>
<dd><p>Imprime el nombre de fichero para cada cadena encontrada.@*</p>
</dd>
<dt><p><samp>-e</samp></p>
</dt>
<dd><p>Protege patrones empezando con un caracter de guión, <samp>-</samp></p>
<pre><code class="example">(setq grep-command &quot;grep -i -nH -e &quot;)</code></pre>
</dd>
</dl>
</li>
</ul>
<dl>
<dt><p>Encuentra un búffer existente, incluso si eso tiene un nombre diferente</p>
</dt>
<dd><p>Esto evita problemas con enlaces simbólicos.</p>
<pre><code class="example">(setq find-file-existing-other-name t)</code></pre>
</dd>
</dl>
<ul>
<li><p>Configura tu entorno de lenguaje y el método de entrada por defecto</p>
<pre><code class="example">(set-language-environment &quot;latin-1&quot;)
;; Recuerda que se puede habilitar o deshabilitar el texto de lenguaje
;; multilingüe con el comando @c{toggle-input-method'} (@k{C-\})
(setq default-input-method &quot;latin-1-prefix&quot;)</code></pre>
<p>Si se quiere escribir con el caracter Chino ‘GB’, asigna esto:</p>
<pre><code class="example">(set-language-environment &quot;Chinese-GB&quot;)
(setq default-input-method &quot;chinese-tonepy&quot;)</code></pre>
</li>
</ul>
</div>
<h4 id="Arreglando-Atajos-de-Teclados" >Arreglando Atajos de Teclados</h4>
<div class="hBody-4" >
<p>Algunos sistemas asocian teclas de maneras no agradables. Algunas veces, por ejemplo, la tecla <kbd>CTRL</kbd> en un modo perverso en vez de la lejanía a la izquierda de la fila.</p>
<p>Normalmente, cuando las personas arreglan estos atajos de teclado, no se cambia su fichero <span class="file" >~/.emacs</span>. En vez de eso, se asocian las teclas apropiadas en sus consolas con los comandos <code>loadkeys</code> o <code>install-keymap</code> en su script de inicio y entonces incluyen comandos <code>xmodmap</code> en su fichero <span class="file" >.xinitrc</span> o <span class="file" >.Xsession</span> para X Windows.</p>
<p>Para un script de inicio:</p>
<pre><code class="example">loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

or

install-keymap emacs2</code></pre>
<p>Para un fichero <span class="file" >.xinitrc</span> o un fichero <span class="file" >.Xsession</span> cuando la tecla <kbd>Caps Lock</kbd> es que tan lejos de la fila del home:</p>
<pre><code class="example"># Asocia la tecla etiquetada ‘Caps Lock’ a ‘Control’
# (Tal como un interfaz de usuario roto sugiere que el teclado hecho
# piensa que los ordenadores son máquinas de escribir desde 1885.)

xmodmap -e &quot;clear Lock&quot;
xmodmap -e &quot;add Control = Caps_Lock&quot;</code></pre>
<p>En un <span class="file" >.xinitrc</span> o <span class="file" >.Xsession</span>, para convertir una tecla <kbd>ALT</kbd> a una tecla <kbd>META</kbd>:</p>
<pre><code class="example"># Algunos teclados mal diseñados tienen una tecla etiquetada ALT y no Meta
xmodmap -e &quot;keysym Alt_L = Meta_L Alt_L&quot;</code></pre>
</div>
<h3 id="Una-línea-modificada" >Una línea modificada</h3>
<div class="hBody-3" >
<p>Finalmente, una funcionalidad que realmente me gusta: un mode line modificado.</p>
<p>Cuando se trabaja a través de una red, se olvida que máquina se está usando. También, se tiende a perder la traza de donde se está, y a qué línea se apunta.</p>
<p>Así se resetea mi mode line para que se parezca a esto:</p>
<pre><code class="example">::-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top</code></pre>
<p>Estoy visitando un fichero llamado <span class="file" >foo.texi</span>, en mi máquina <span class="file" >rattlesnake</span> en mi búffer <span class="file" >/home/bob</span>. Yo estoy en la línea 1, en modo Texinfo, y estoy arriba del búffer.</p>
<p>Mi fichero <span class="file" >.emacs</span> tiene una sección que se parece a esto:</p>
<pre><code class="example">;; Asigna un Mode Line que nos cuente que máquina, que directorio,
;; y que línea estoy on, más la información de client.
(setq-default mode-line-format
 (quote
  (#(&quot;-&quot; 0 1
     (help-echo
      &quot;mouse-1: select window, mouse-2: delete others ...&quot;))
   mode-line-mule-info
   mode-line-modified
   mode-line-frame-identification
   &quot;    &quot;
   mode-line-buffer-identification
   &quot;    &quot;
   (:eval (substring
           (system-name) 0 (string-match &quot;\\..+&quot; (system-name))))
   &quot;:&quot;
   default-directory
   #(&quot; &quot; 0 1
     (help-echo
      &quot;mouse-1: select window, mouse-2: delete others ...&quot;))
   (line-number-mode &quot; Line %l &quot;)
   global-mode-string
   #(&quot;   %[(&quot; 0 6
     (help-echo
      &quot;mouse-1: select window, mouse-2: delete others ...&quot;))
   (:eval (mode-line-mode-name))
   mode-line-process
   minor-mode-alist
   #(&quot;%n&quot; 0 2 (help-echo &quot;mouse-2: widen&quot; local-map (keymap ...)))
   &quot;)%] &quot;
   (-3 . &quot;%P&quot;)
   ;;   &quot;-%-&quot;
   )))</code></pre>
<p>Aquí, se redefine el mode line por defecto. La mayoría de las partes son desde el original; pero yo creo unos pocos cambios. Yo asigno el formato de mode line <em>default</em> así como permitir varios modos, tales como Info, para sobreescribirlo.</p>
<p>Muchos elementos en la lista son auto-explicativos: <code>mode-line-modified</code> es una variable que cuenta si el búffer ha sido modificado, <code>mode-name</code> cuenta el nombre del modo, y así. Sin embargo, el formato parece complicado porque las dos funcionalidades no han sido discutidas.</p>
<p>La nueva cadena de formato tiene una sintaxis especial:</p>
<pre><code class="example">#(&quot;-&quot; 0 1 (help-echo &quot;mouse-1: select window, ...&quot;))</code></pre>
<p>El <code>#(</code> empieza una lista. El primer elemento de la lista es la cadena en sí, solo un <samp>-</samp>. El segundo y tercer elemento especifica el rango a través del cuarto elemento aplicado. Un rango empieza <em>después</em> un carácter, así un cero significa el rango que empieza solo después del primer caracter; un 1 significa que el rango finaliza solo después del primer caracter. El tercer elemento es la propiedad para el rango. Eso consiste en una lista de propiedades, un nombre de propiedad, en este caso, <samp>help-echo</samp>, seguido por un valor, en este caso, una cadena. El segundo, tercer y cuarto elemento de este nuevo formato de cadena puede ser repetido.</p>
<p>Véase Sección <cite>Propiedades de Texto</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, y ver <cite>Formato Mode Line</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.</p>
<p><code>mode-line-buffer-identification</code> muestra el nombre del buffer. Eso es una lista empezando por <code>(#(&quot;%12b&quot; 0 4 …</code>. El <code>#(</code> empieza la lista.</p>
<p>El <samp>&quot;%12b&quot;</samp> muestra el nombre del actual búffer, usando la función <code>buffer-name</code> con la que estamos familiarizados; el ‘12’ especifica el número máximo de caracteres que serán mostrados. Cuando un nombre tiene pocos caracteres, el espacio en blanco se añade para rellenar este número. (Los nombres del búffer puede y con frecuencia serán más largos de 12 caracteres; esta longitud funciona bien en la típica ventana de 80 columnas de ancho.)</p>
<p><code>:eval</code> dice evaluar la siguiente forma y usa el resultado como una cadena para mostrarse. En este caso, la expresión muestra el primer componente del sistema completo. El fin del primer componente es un <samp>.</samp> (‘periodo’), así se usa la función <code>string-match</code> para contar el tamaño del primer componente. La subcadena desde el caracter cero a este tamaño del primer componente. La subcadena desde el caracter cero a este tamaño es el nombre de la máquina.</p>
<p>Esta es la expresión:</p>
<pre><code class="example">(:eval (substring
        (system-name) 0 (string-match &quot;\\..+&quot; (system-name))))</code></pre>
<p><samp>%[</samp> y <samp>%]</samp> causa un par de corchetes que aparezcan por cada edición nivel de edición recursiva editando el nivel. <samp>%n</samp> dice ‘Encoger’ cuando esto puede hacerse. <samp>%P</samp> te cuenta el porcentaje del búffer que está debajo de la ventana, o ‘arriba’, ‘abajo’, o ‘todo’. (Una minúscula <samp>p</samp> cuenta el porcentaje bajo el alto de la ventana.) <samp>%-</samp> inserta suficientes guiones para rellenar la línea.</p>
<p>Recuerda, “No tiene que gustarte Emacs para que le gustes”––Emacs puede tener diferentes colores, diferentes comandos, y diferentes teclas que un Emacs por defecto.</p>
<p>Por otro lado, si se quiere traer un plano ‘fuera de la caja’ Emacs, sin personalización, escribe:</p>
<pre><code class="example">emacs -q</code></pre>
<p>Esto inicializará un Emacs que <em>no</em> cargue tu <span class="file" >~/.emacs</span> fichero de inicialización. Uno plano, el que trae Emacs por defecto. Nada más.</p>
</div>
<h2 id="Depurando" >Depurando</h2>
<div class="hBody-2" >
<p>GNU Emacs tiene dos depuradores, <code>debug</code> y <code>edebug</code>. El primero es construido dentro de las tripas de Emacs y está siempre contigo; el segundo requiere que exista una función antes de que se pueda usar.</p>
<p>Ambos depuradores son descritos extensivamente en Seccion <cite>Depurando</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>. En este capítulo, se explicará un breve ejemplo de esto.</p>
</div>
<h3 id="depurar" ><code>depurar</code></h3>
<div class="hBody-3" >
<p>Supón que se ha escrito una definición de función que se pretende devolver la suma de los números 1 a través de un número dado. (Esta es la función <code>triangle</code> discutida pronto. Véase Sección <a href="Ejemplo-de-Decremento,-,-Ejemplo-con-Contador-de-Decremento" >Ejemplo de Decremento, , Ejemplo con Contador de Decremento</a>, para una discusión.)</p>
<p>Sin embargo, tu definición de función tiene un error. Se ha malescrito <samp>1=</samp> por <samp>1-</samp>. Aquí está la definición rota:</p>
<pre><code class="example">(defun triangle-bugged (number)
  &quot;Devuelve suma de números 1 a través de NUMBER inclusive.&quot;
  (let ((total 0))
    (while (&gt; number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @e{Error aquí.}
    total))</code></pre>
<p>Si se está leyendo esto en Info, se puede evaluar esta definición en el modo normal. Se verá que <code>triangle-bugged</code> aparece en el área echo.</p>
<p>Ahora evalúa la función <code>triangle-bugged</code> con un argumento de 4:</p>
<pre><code class="example">(triangle-bugged 4)</code></pre>
<p>En un GNU Emacs reciente, se creará e introducirá un búffer <span class="file" >*Backtrace*</span> que dice:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (&gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (&gt; number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>(Se ha reformateado este ejemplo ligeramente; el depurador no contiene muchas líneas. Así, se puede salir del depurador escribiendo <kbd>q</kbd> en el buffer <span class="file" >*Backtrace*</span>.)</p>
<p>En la práctica, debido a un error tan simple como este, la línea de ‘error Lisp’ explica lo que se necesita saber para corregir la definición. La función <code>1=</code> está ‘vacía’.</p>
<p>Sin embargo, si no se conoce con bastante certeza lo que está pasando, se puede leer la traza completa.</p>
<p>En este caso, se necesita ejecutar una versión reciente de GNU Emacs, que automáticamente empieza el depurador que pone en el búffer <span class="file" >*Backtrace*</span>; o además, se necesita para empezar el depurador manualmente como se describe debajo.</p>
<p>Lee el búffer <span class="file" >*Backtrace*</span> de abajo a arriba; eso cuenta lo que le hizo a Emacs tener un error. Emacs hace una llamada interactiva a <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>), que lleva a la evaluación de la expresión <code>triangle-bugged</code>. Cada línea de debajo cuenta lo que el intérprete Lisp evaluó.</p>
<p>La tercera línea desde lo alto del búffer es</p>
<pre><code class="example">(setq number (1= number))</code></pre>
<p>Emacs intentó evaluar esta expresión; para hacerlo así, se intentó evaluar la expresión interna para ser mostrada en la segunda línea desde arriba:</p>
<pre><code class="example">(1= number)</code></pre>
<p>Aquí es donde el error ocurre; como se dice en la línea de arriba:</p>
<pre><code class="example">Debugger entered--Lisp error: (void-function 1=)</code></pre>
<p>Se puede corregir el error, reevalúa la definición de función, y entonces se puede testear de nuevo.</p>
</div>
<h3 id="debug-on-entry" ><code>debug-on-entry</code></h3>
<div class="hBody-3" >
<p>Un GNU Emacs actual abre el depurador automáticamente cuando la función tiene un error.</p>
<p>Incidentalmente, se puede empezar el depurador manualmente para todas las versiones de Emacs; la ventaja es que el depurador se ejecuta incluso si no se tiene un error en su código. Algunas veces, ¡su código estará libre de errores!</p>
<p>Se puede introducir el depurador cuando se llama a la función llamando <code>debug-on-entry</code>.</p>
<p>Tipo:</p>
<pre><code class="example">M-x debug-on-entry RET triangle-bugged RET</code></pre>
<p>Ahora, evalúa lo siguiente:</p>
<pre><code class="example">(triangle-bugged 5)</code></pre>
<p>Todas las versiones de Emacs crearán un búffer <span class="file" >*Backtrace*</span> y cuenta tu que eso es el principio para evaluar la función <code>triangle-bugged</code>:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>En el búffer <span class="file" >*Backtrace*</span>, escribe <kbd>d</kbd>. Emacs evaluará la primera expresión en <code>triangle-bugged</code>; el búffer se parece a esto:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (&gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>Ahora, escribe <kbd>d</kbd> de nuevo, ocho veces, lentamente. Cada vez que se escribe <kbd>d</kbd> Emacs evaluará otra expresión en la definición de función.</p>
<p>Eventualmente, el búffer se parece a esto:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (&gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
* (let ((total 0)) (while (&gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------</code></pre>
<p>Finalmente, después se escribe <kbd>d</kbd> dos veces más, Emacs logrará el error y las dos líneas superiores del buffer <span class="file" >*Backtrace*</span> se ve así:</p>
<pre><code class="example">---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
…
---------- Buffer: *Backtrace* ----------</code></pre>
<p>Escribiendo <kbd>d</kbd>, sería capaz de pasear a través de la función.</p>
<p>Se puede salir de un buffer <span class="file" >*Backtrace*</span> escribiendo <kbd>q</kbd>; esto se sale de la traza, pero no cancela <code>debug-on-entry</code>.</p>
<p>Para cancelar el efecto de <code>debug-on-entry</code>, llama a <code>cancel-debug-on-entry</code> y el nombre de la función, como esto:</p>
<pre><code class="example">M-x cancel-debug-on-entry RET triangle-bugged RET</code></pre>
<p>(Si está leyendo esto en Info, cancela <code>debug-on-entry</code> ahora.)</p>
</div>
<h3 id="debug-on-quit-y-(debug)" ><code>debug-on-quit</code> y <code>(debug)</code></h3>
<div class="hBody-3" >
<p>Adición a la configuración <code>debug-on-error</code> o llamando <code>debug-on-entry</code>, hay otros dos caminos para empezar <code>debug</code>.</p>
<p>Se puede empezar <code>debug</code> siempre y cuando se escribe <kbd>C-g</kbd> (<code>keyboard-quit</code>) se configura la variable <code>debug-on-quit</code> para <code>t</code>. Esto es útil para depurar bucles infinitos.</p>
<p>O, se puede insertar un línea que dice <code>(debug)</code> dentro de tu código donde se quiere que el depurador empiece, así:</p>
<pre><code class="example">(defun triangle-bugged (number)
  &quot;Devuelve suma de números 1 a través de NUMERO inclusive.&quot;
  (let ((total 0))
    (while (&gt; number 0)
      (setq total (+ total number))
      (debug)                         ; @e{Empieza el depurador.}
      (setq number (1= number)))      ; @e{Error aquí.}
    total))</code></pre>
<p>La función <code>debug</code> se describe en detalle en <cite>El Depurador Lisp</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
</div>
<h3 id="El-depurador-de-nivel-de-fuentes-edebug" >El depurador de nivel de fuentes <code>edebug</code></h3>
<div class="hBody-3" >
<p>Edebug es un depurador a nivel de fuentes Edebug que normalmente muestra las fuentes del código que se está depurando, con una flecha a la izquierda que muestra que línea se está actualmente ejecutando.</p>
<p>Se puede pasear a través de la ejecución de una función, línea a línea, o ejecutarse rápidamente hasta lograr un <dfn>punto de ruptura</dfn> donde la ejecución pare.</p>
<p>Edebug se describe en Seccion <cite>edebug</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
<p>Aquí hay una función con errores para <code>triangle-recursively</code>. Véase Sección <a href="Recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</a>, para una revisión de eso.</p>
<pre><code class="example">(defun triangle-recursively-bugged (number)
  &quot;Devuelve la suma of números 1 a través de NUMBER inclusive.
Usa recursión.&quot;
  (if (= number 1)
      1
    (+ number
       (triangle-recursively-bugged
        (1= number)))))               ; @e{Error aquí.}</code></pre>
<p>Normalmente, se instalaría esta definición posicionando su cursor después de la función cerrando paréntesis y escribiendo <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>) o lo demás posicionando tu cursor con la definición y escribiendo <kbd>C-M-x</kbd> (<code>eval-defun</code>). (Por defecto, el comando <code>eval-defun</code> funciona solo en modo Emacs Lisp o en el modo de interacción de Lisp.)</p>
<p>Sin embargo, para preparar esta definición de función para Edebug, se debe primero <dfn>instrumentar</dfn> el código usando un comando diferente. Se puede hacer esto posicionando el cursor dentro o después de la definición y escribiendo</p>
<pre><code class="example">M-x edebug-defun RET</code></pre>
<p>Esto causará que Emacs cargue Edebug automáticamente si eso no está ya cargado y, apropiadamente prepara la función.</p>
<p>Después de preparar la función, emplaza tu cursor después de la siguiente expresión y escribe <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>):</p>
<pre><code class="example">(triangle-recursively-bugged 3)</code></pre>
<p>Se vuelve a las fuentes de <code>triangle-recursively-bugged</code> y el cursor se posiciona al principio del <code>if</code> de la línea de la función. También, se verá una flecha en la mano izquierda al lado de esta línea donde la función se está ejecutando. (En los siguientes ejemplos, se muestra la flecha con <samp>=&gt;</samp>; en un sistema de ventanas, se puede ver la flecha como un triángulo sólido en el ‘borde’ de la ventana.)</p>
<pre><code class="example">=&gt;★(if (= number 1)</code></pre>
<p>En el ejemplo, la posición del punto es mostrado con una estrella, <samp>★</samp> (en Info, eso es mostrado como <samp>-!-</samp>).</p>
<p>Si ahora se presiona <kbd>SPC</kbd>, el punto se moverá a la siguiente expresión para ejecutarse; la línea se parece a esto:</p>
<pre><code class="example">=&gt;(if ★(= number 1)</code></pre>
<p>Como se continua presionando <kbd>SPC</kbd>, el puntero se moverá desde la expresión a la expresión. Al mismo tiempo, siempre y cuando una expresión devuelva un valor, este valor será mostrado en el área echo. Por ejemplo, después de mover el punto pasado <code>number</code>, se verá lo siguiente:</p>
<pre><code class="example">Resultado: 3 (#o3, #x3, ?\C-c)</code></pre>
<p>Esto significa el valor de <code>number</code> es 3, que son tres octales, tres hexadecimales, y <code>ascii</code> ‘control-c’ (la tercera letra del alfabeto, en caso de que se necesite conocer esta información).</p>
<p>Uno puede continuar moviéndose a través del código hasta que logre la línea con el error. Antes de la evaluación, esta línea se parece a esto:</p>
<pre><code class="example">=&gt;        ★(1= number)))))               ; @e{Error aquí.}</code></pre>
<p>Cuando se presiona <kbd>SPC</kbd> una vez de nuevo, se producirá un mensaje de error que dice:</p>
<pre><code class="example">La definición de la función está vacío:@: 1=</code></pre>
<p>Este es el error.</p>
<p>Presiona <kbd>q</kbd> para salir de Edebug.</p>
<p>Para eliminar la instrumentación desde una definición de función, simplemente se reevalúa con un comando que no lo instrumente. Por ejemplo, se podría posicionar su cursor después de la definición cerrando paréntesis y escribiendo <kbd>C-x C-e</kbd>.</p>
<p>Edebug hace un gran trato antes de entrar en una función. Se puede dirigir así mismo, parando solo en un error o en puntos específicos, se puede causar para mostrar los valores cambiantes de varias expresiones; se puede encontrar cuantas veces una función se llama, y más.</p>
<p>Edebug se describe en <cite>edebug</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
</div>
<h3 id="Ejercicios-de-depuración" >Ejercicios de depuración</h3>
<div class="hBody-3" >
<ul>
<li><p>Instale la función <code><code class="verbatim" >COUNT-WORDS</code></code> y provoque que se introduzca el depurador construido cuando se llame. Ejecute el comando en una región conteniendo dos palabras. Se necesitará presionar <kbd>d</kbd> un número remarcable de veces. En el sistema, es un ‘hook’ llamado después que el comando se finaliza. (Para información sobre hooks, mira Seccion <cite>Resumen del Comando Bucle</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
</li>
<li><p>Copie <code><code class="verbatim" >COUNT-WORDS</code></code> dentro del búffer <span class="file" >*scratch*</span>, instrumente la función para Edebug, y navegue a través de su ejecución. La función no necesita tener un error, aunque se puede introducir uno si se desea. Si a la función le falta un error, el paseo se completa sin problemas.</p>
</li>
<li><p>Mientras se ejecuta Edebug, escriba <kbd>?</kbd> para ver una lista de todos los comandos Edebug. (El <code>global-edebug-prefix</code> normalmente es <kbd>C-x X</kbd>, por ej@: <kbd><kbd>CTRL</kbd>-x</kbd> seguido por una tecla mayúscula <kbd>X</kbd>; use este prefijo para comandos hechos fuera del búffer de depuración Edebug.)</p>
</li>
<li><p>En el búffer de depuración Edebug, usa el comando <kbd>p</kbd> (<code>edebug-bounce-point</code>) para ver si <code><code class="verbatim" >COUNT-WORDS</code></code> está funcionando.</p>
</li>
<li><p>Mueve el punto a algún sitio debajo de la función y entonces escribe el comando <kbd>h</kbd> (<code>edebug-goto-here</code>) para saltar a esta localización.</p>
</li>
<li><p>Usa el comando <kbd>t</kbd> (<code>edebug-trace-mode</code>) para causar que Edebug pasee a través de la función en sí; usa una letra mayúscula <kbd>T</kbd> para <code>edebug-Trace-fast-mode</code>.</p>
</li>
<li><p>Asigna un punto de ruptura, entonces ejecuta Edebug en modo Traza hasta que se logre el punto de parada.</p>
</li>
</ul>
</div>
<h2 id="Conclusión" >Conclusión</h2>
<div class="hBody-2" >
<p>Ahora se ha llegado al fin de esta Introducción. Se ha aprendido lo suficiente acerca de programación en Emacs Lisp para asignar valores, para escribir ficheros <span class="file" >.emacs</span> para tí mismo y tus amigos, y escribir personalizaciones simples y extensiones a Emacs.</p>
<p>Este es un lugar para parar. O, si se desea, se puede ir adelante, y aprender más por uno mismo.</p>
<p>Se han aprendido algunas bases de programación. Pero solo algunas. Todavía hay muchas cosas que son fáciles de usar que no se han tocado.</p>
<p>Otra idea para seguir es leer las fuentes de Emacs o @ifnotinfo <em>El Manual de Referencia de GNU Emacs</em>.</p>
<p>Las fuentes de Emacs Lisp son una aventura. Cuando se leen las fuentes vienen a través de una función o expresión que nos es familiar, se necesita imaginar o encontrar qué se hace.</p>
<p>Ir al Manual de Referencia. Eso está a través del completo, limpio y fácil de leer descripción de Emacs Lisp. Está escrito no solo para expertos, pero sí para gente que conoce lo que usted conoce. (El <em>Manual de Referencia</em> viene con la distribución de GNU Emacs. Como esta introducción, viene como un fichero fuente Texinfo, así se puede leer on-line como un libro impreso.)</p>
<p>Ir a otra ayuda on-line que sea parte de GNU Emacs: la documentación on-line para todas las funciones y variables, y <code>find-tag</code>, el programa que va a las fuentes.</p>
<p>Aquí hay un ejemplo de cómo explorar las fuentes. Porque su nombre, <span class="file" >simple.el</span> es el fichero que se vió primero, hace tiempo. Como eso ocurre alguna de las funciones en <span class="file" >simple.el</span> son complicadas, o al menos parece complicado a primera vista. La función <code>open-line</code>, por ejemplo, parece complicada.</p>
<p>Se puede querer pasear a través de esta función lentamente, como nosotros hicimos la función <code>forward-sentence</code>. (Véase Sección <a href="La-función-forward-sentence" >La función <code>forward-sentence</code></a>.) O se puede querer salir de esta función y mirar en otra, tal como <code>split-line</code>. No se necesita leer todas las funciones. De acuerdo a <code>count-words-in-defun</code>, la función <code>split-line</code> contiene 102 palabras y símbolos.</p>
<p>Incluso aunque sean pocas, <code>split-line</code> contiene expresiones que no se han estudiado: <code>skip-chars-forward</code>, <code>indent-to</code>, <code>current-column</code> y <code>insert-and-inherit</code>.</p>
<p>Considera la función <code>skip-chars-forward</code>. (Eso es parte de la definición de función para <code>back-to-indentation</code>, que muestra la <a href="Repaso:-Cómo-escribir-definiciones-de-funciones" >Repaso</a>.)</p>
<p>En GNU Emacs, se puede encontrar más acerca de <code>skip-chars-forward</code> escribiendo <kbd>C-h f</kbd> (<code>describe-function</code>) y el nombre de la función. Esto te da la documentación de función.</p>
<p>Se puede ser capaz de adivinar que se hace por una función bien llamada tal como <code>indent-to</code>; o se puede buscar, también. Incidentalmente, la función <code>describe-function</code> en sí está en <span class="file" >help.el</span>; esta es una de estas largas, pero descifrables funciones. ¡Se puede buscar <code>describe-function</code> usando el comando <kbd>C-h f</kbd>!</p>
<p>En esta instancia, desde el código es Lisp, el búffer <span class="file" >*Help*</span> contiene el nombre de la librería conteniendo las fuentes de la función. Se puede poner el punto a través del nombre de la librería y presiona la tecla RET, que está en esta situación está asociado a <code>help-follow</code>, y se toma directamente de las fuentes, en el mismo camino que <kbd>M-.</kbd> (<code>find-tag</code>).</p>
<p>La definición para <code>describe-function</code> ilustra como personalizar las expresiones <code>interactive</code> sin usar los códigos de caracter estándar y eso muestra como crear un búffer temporal.</p>
<p>(La función <code>indent-to</code> es escrita en C en vez de Emacs Lisp; eso es una función ‘construida’. <code>help-follow</code> toma su fuente como <code>find-tag</code>, cuando se configura apropiadamente.)</p>
<p>Se puede mirar en las fuentes de la función usando <code>find-tag</code>, que está asociado a <kbd>M-.</kbd>. Finalmente, se puede encontrar que el Manual de Referencia tiene que decir visitando el manual en Info, y escribiendo <kbd>i</kbd> (<code>Info-index</code>) y el nombre de la función, o buscando la función en el índice a una copia impresa del manual.</p>
<p>Similarmente, se puede encontrar que significa por <code>insert-and-inherit</code>.</p>
<p>Otros ficheros fuente interesantes incluyen <span class="file" >paragraphs.el</span>, <span class="file" >loaddefs.el</span> y <span class="file" >loadup.el</span>. El fichero <span class="file" >paragraphs.el</span> incluye ordenar, funciones fácilmente comprendidas tan bien como las largas. El fichero <span class="file" >loaddefs.el</span> contiene muchos autoloads estándar y muchos mapas de teclado. Nunca se ha buscado en todo; solo en las partes. <span class="file" >loadup.el</span> es el fichero que carga las partes estándar de Emacs; eso cuenta un gran trato acerca de cómo Emacs está construido. (Véase Sección <cite>Construyendo Emacs</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más acerca de construcción.)</p>
<p>Como dije, se han aprendido algunas cosas; sin embargo, y de manera muy importante, se han tocado fuertes aspectos de la programación; no se ha dicho nada acerca de como ordenar la información, excepto para usar la función predefinida <code>sort</code>; no se ha dicho nada acerca de cómo almacenar la información, excepto para usar variables y listas; no se ha dicho nada acerca de como escribir programas que escriben programas. Esto son asuntos para otro tipo diferente de libro, un diferente tipo de aprendizaje.</p>
<p>Lo que se ha hecho es aprender lo suficiente para hacer mucho trabajo práctico con GNU Emacs. Lo que se ha hecho es comenzar. Este es el fin del principio de una gran amistad.</p>
</div>
<h3 id="Apéndice-A-La-función-the-the" >Apéndice A La función <code>the-the</code></h3>
<div class="hBody-3" >
<p>Algunas veces cuando se se escribe texto, se duplican palabras––como con “se se” cerca del principio de esta frase. Se encuentra que lo más frecuente, es duplicar “el”; aquí, se llama a la función para detectar las palabras duplicadas, <code>the-the</code>.</p>
<p>Como primer paso, se podrían usar las siguientes expresiones regulares para buscar duplicados:</p>
<pre><code class="example">\\(\\w+[ \t\n]+\\)\\1</code></pre>
<p>Este regexp asocia uno o más caracteres que constituyen palabras seguidas por uno o más espacios, tabuladores, o nuevas líneas. Sin embargo, eso no detecta palabras duplicadas en diferentes líneas, desde la finalización de la primera palabra, el fin de la línea, es diferente desde el fin de la segunda palabra, un espacio. (Para más información acerca de expresiones regulares, mira el Capitulo 12 <a href="Búsquedas-de-Expresiones-Regulares" >Búsquedas de Expresiones Regulares</a>, tan bien como la Seccion <cite>Sintaxis de Expresiones Regulares</cite> en <em>El Manual de GNU Emacs</em>, y la Seccion <cite>Expresiones Regulares</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p>Se podrían intentar buscar caracteres duplicados pero no si el patrón detecta dobles tales como las dos ocurrencias de ‘th’ en ‘with the’.</p>
<p>Otro posible regexp busca caracteres constituyentes de palabras seguidos por caracteres de no palabras constituyentes, reduplicadas. Aquí, <samp>\\w+</samp> asocia a una o más caracteres de palabras constituyente y <samp>\\W*</samp> asocia cero o más caracteres que no constituyen palabras.</p>
<pre><code class="example">\\(\\(\\w+\\)\\W*\\)\\1</code></pre>
<p>De nuevo, no útil.</p>
<p>Aquí está el patrón que uso. No es perfecto, pero suficientemente bueno. <samp>\\b</samp> asocia la cadena vacía provista al principio o fin de una palabra; <samp>[^@ \n\t]+</samp> asocia una o más ocurrencias de qué caracteres que <em>no</em> son un @-signo, espacio, nueva línea, o tabulador.</p>
<pre><code class="example">\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b</code></pre>
<p>Uno puede escribir expresiones más complicadas, pero esta expresión es suficientemente buena así.</p>
<p>Aquí está la función <code>the-the</code>, como se incluye en mi fichero <span class="file" >.emacs</span>, a lo largo de un atajo global manejable:</p>
<pre><code class="example">(defun the-the ()
  &quot;Busca hacia adelante para una palabra duplicada.&quot;
  (interactive)
  (message &quot;Buscando palabras duplicadas ...&quot;)
  (push-mark)
  ;; Este regexp no es perfecto
  ;; pero es limpiamente bueno a pesar de todo:
  (if (re-search-forward
       &quot;\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b&quot; nil 'move)
      (message &quot;Palabra encontrada duplicada.&quot;)
    (message &quot;Fin de búffer&quot;)))

;; Asocia ‘the-the’ a  C-c \
(global-set-key &quot;\C-c\\&quot; 'the-the)</code></pre>
<p>Aquí está el test del texto:</p>
<pre><code class="example">uno dos tres cuatro cinco
cinco seis siete</code></pre>
<p>Se pueden sustituir las otras expresiones regulares mostradas debajo en la definición de función y se prueba cada una de ellas en esta lista.</p>
</div>
<h3 id="Apéndice-B-Manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</h3>
<div class="hBody-3" >
<p>El anillo de la muerte es una lista que es transformada dentro de un anillo que trabaja con la función <code>current-kill</code>. Los comandos <code>yank</code> y <code>yank-pop</code> usan la función <code>current-kill</code>.</p>
<p>Este apéndice describe la función <code>current-kill</code> y los comandos <code>yank</code> y <code>yank-pop</code>, pero primero, considere los trabajo del kill ring.</p>
<p>El anillo de la muerte <em>kill ring</em> tiene el tamaño máximo de sesenta elementos; hacer una explicación con este número máximo quedaría demasiado larga. En vez de eso, pensemos qué ocurre si se asígna a cuatro. Por favor, evalúe lo siguiente:</p>
<pre><code class="example">(setq old-kill-ring-max kill-ring-max)
(setq kill-ring-max 4)</code></pre>
<p>Entonces, por favor, copie cada línea del siguiente ejemplo indentado dentro del anillo de la muerte <em>kill ring</em>. Se puede cortar cada línea con <kbd>C-k</kbd> o marcarla y copiarla con <kbd>M-w</kbd>.</p>
<p>(En un búffer de solo lectura, tal como el búffer <span class="file" >*info*</span>, el comando kill, <kbd>C-k</kbd> (<code>kill-line</code>), no eliminará el texto, solamente lo mueve al anillo de la muerte <em>kill ring</em>. Sin embargo, el ordenador puede avisar con un beep. Alternativamente, para silenciar, se puede copiar la región de cada línea con el comando <kbd>M-w</kbd> (<code>kill-ring-save</code>). Se debe marcar cada línea de este comando para tener éxito, pero no importa si al final se posiciona en el punto o la marca).</p>
<p>Por favor, invoque las llamadas en orden, de modo que los cinco elementos rellenen el anillo de la muerte <em>kill ring</em>.</p>
<pre><code class="example">primero algo de texto
segunda pieza de texto
tercera línea
cuarta línea de texto
quinto bit de texto</code></pre>
<p>Entonces encuentra el valor de <code>kill-ring</code> evaluando</p>
<pre><code class="example">kill-ring</code></pre>
<p>Eso es:</p>
<pre><code class="example">(&quot;quinto bit de texto&quot; &quot;cuarta línea de texto&quot;
&quot;tercera línea&quot; &quot;segunda pieza de texto&quot;)</code></pre>
<p>El primer elemento, <samp>primero algo de texto</samp>, fué borrado.</p>
<p>Para devolver el viejo valor para el tamaño del kill ring, evalúe:</p>
<pre><code class="example">(setq kill-ring-max old-kill-ring-max)</code></pre>
</div>
<h4 id="La-función-current-kill" >La función <code>current-kill</code></h4>
<div class="hBody-4" >
<p>La función <code>current-kill</code> cambia el elemento en el anillo de la muerte <em>kill ring</em> para el que el <code>kill-ring-yank-pointer</code> apunta. (También, la función <code>kill-new</code> asigna <code>kill-ring-yank-pointer</code> para apuntar al último elemento del anillo de la muerte <em>kill ring</em>. La función <code>kill-new</code> se usa directamente o indirectamente por <code>kill-append</code>, <code>copy-region-as-kill</code>, <code>kill-ring-save</code>, <code>kill-line</code>, y <code>kill-region</code>.)</p>
<p>La función <code>current-kill</code> es usada por <code>yank</code> y por <code>yank-pop</code>. Aquí está el código para <code>current-kill</code>:</p>
<pre><code class="example">(defun current-kill (n &amp;optional do-not-move)
&quot;Rota el punto de pegue por N lugares, y entonces devuelve lo cortado.
Si N es cero, ‘interprogram-paste-function’ se asigna, y si se llama
devuelve una cadena, entonces esta cadena se añade al frente del
anillo de la muerte @e{kill ring} y devuelve el último corte.
Si el argumento opcional DO-NOT-MOVE es no nulo, entonces no muevas el
punto de pegue; solo devuelve el Nth corte hacia adelante.
   (let ((interprogram-paste (and (= n 0)
                                  interprogram-paste-function
                                  (funcall interprogram-paste-function)))))
    (if interprogram-paste
        (progn
          ;; Deshabilita el programa de la función de corte cuando se
          ;; añade el nuevo texto al anillo de la muerte @e{kill ring},
          ;; así Emacs no intenta poseer la selección
          ;; con idéntico texto.
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
      (or kill-ring (error &quot;Kill ring is empty&quot;))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))</code></pre>
<p>Recuerde también que la función <code>kill-new</code> asigna <code>kill-ring-yank-pointer</code> al último elemento del anillo de la muerte <em>kill ring</em>, que significa que todas las funciones lo llaman y asigna el valor de manera indirecta: <code>kill-append</code>, <code>copy-region-as-kill</code>, <code>kill-ring-save</code>, <code>kill-line</code> y <code>kill-region</code>.</p>
<p>Aquí está la línea en <code>kill-new</code>, que se explica en la <a href="La-función-kill-new" >La función <code>kill-new</code></a>.</p>
<pre><code class="example">(setq kill-ring-yank-pointer kill-ring)</code></pre>
<p>La función <code>current-kill</code> parece compleja, pero usual, eso puede ser comprendido tomándolo aparte pieza por pieza. Primero míralo en la forma esquelética:</p>
<pre><code class="example">(defun current-kill (n &amp;optional do-not-move)
  &quot;Rota el punto a pegar por N lugares, y entonces devuelve el texto cortado.&quot;
  (let @V{varlist}
    @V{body}…)</code></pre>
<p>Esta función tiene dos argumentos, uno es opcional. Hay una cadena de documentación. <em>No</em> es una función interactiva.</p>
<p>El cuerpo de la definición de función es una expresión <code>let</code>, que por sí misma tiene tanto un cuerpo como una varlist.</p>
<p>La expresión <code>let</code> declara una variable que será solo usable con las asociaciones de esta función. Esta variable se llama <code>interprogram-paste</code> y se copia a otro programa. No se copia con esta instancia de GNU Emacs. La mayoría de los sistemas de ventanas proveen una facilidad para pegar el interprograma. Tristemente, esta facilidad normalmente provee solo el último elemento. La mayoría de los sistemas de ventanas no han adoptado un anillo de muchas posibilidades, incluso aunque Emacs haya provisto esto durante décadas.</p>
<p>La expresión <code>if</code> tiene dos partes, una si existe <code>interprogram-paste</code> y otra si no.</p>
<p>Permítenos considerar el ‘si no’ o la parte else de la función <code>current-kill</code>. (La parte then usa la función <code>kill-new</code>, que ya hemos descrito. Véase Sección <a href="La-función-kill-new." >La función <code>kill-new</code>.</a>)</p>
<pre><code class="example">(or kill-ring (error &quot;El Kill ring está vacío&quot;))
(let ((ARGth-kill-element
       (nthcdr (mod (- n (length kill-ring-yank-pointer))
                    (length kill-ring))
               kill-ring)))
  (or do-not-move
      (setq kill-ring-yank-pointer ARGth-kill-element))
  (car ARGth-kill-element))</code></pre>
<p>El código primero chequea si el kill ring <em>anillo de la muerte</em> tiene contenido; de otro modo señala un error.</p>
<p>Note que la expresión <code>or</code> es muy similar para testear el tamaño con un <code>if</code>:</p>
<pre><code class="example">(if (zerop (length kill-ring))          ; @e{parte-si}
    (error &quot;Anillo de la muerte vacío&quot;))       ; @e{parte-entonces}
  ;; No hay parte-resto</code></pre>
<p>Si no hay nada en el kill ring <em>anillo de la muerte</em>, su tamaño debe ser cero y un mensaje de error se envía al usuario: <samp>El kill ring está vacío</samp>. La función <code>current-kill</code> usa una expresión <code>or</code> que es simple. Pero una expresión <code>if</code> recuerda lo que lleva.</p>
<p>Esta expresión <code>if</code> usa la función <code>zerop</code> que devuelve cierto si el valor que se chequea es cero. Cuando <code>zerop</code> chequea cierto, la parte then del <code>if</code> se evalúa. La parte then es una lista empezando con la función <code>error</code>, que es una función que es similar a la función <code>message</code> (Vease Sección <a href="message,-,-La-Función-message" >message, , La Función <code>message</code></a>) que imprime un mensaje de una línea en el área echo. Sin embargo, además de imprimir un mensaje, <code>error</code> también evalúa la función que está embebida. Esto significa que el resto de la función no será evaluada si el tamaño del anillo de la muerte <em>kill ring</em> es cero.</p>
<p>Entonces la función <code>current-kill</code> selecciona el elemento a devolver. La selección depende del número de lugares que <code>current-kill</code> rota y donde <code>kill-ring-yank-pointer</code> apunta.</p>
<p>Lo siguiente, si el argumento <code>do-not-move</code> opcional es verdadero o el actual valor de <code>kill-ring-yank-pointer</code> se establece al punto de la lista. Finalmente, otra expresión devuelve el primer elemento de la lista incluso si el argumento <code>do-not-move</code> es verdadero.</p>
<p>En mi opinión, es ligeramente erróneo, al menos para humanos, usar el término ‘error’ como el nombre de la función <code>error</code>. Un término mejor sería ‘cancelar’. Estrictamente hablando, de acuerdo, no se puede apuntar, mucho menos rotar un puntero a una lista que no tiene tamaño, así desde el punto de vista del ordenador, la palabra ‘error’ es correcta. Pero un humano espera intentar algo, si solo si se encuentra el anillo de la muerte <em>kill ring</em> esté lleno o vacío. Esto es un acto de exploración.</p>
<p>Desde el punto de vista humano, el acto de exploración y descubrimiento no es necesariamente un error, y por esta razón no sería etiquetado como tal, incluso las vocales de un ordenador. Como tal, el código en Emacs implica que un humano que está actuando virtuosamente, explorando su entorno, está teniendo un error. Esto está mal. Incluso aunque el ordenador tome los mismos pasos como cuando hay ‘error’, un término tal como ‘cancelar’ tendría una clara connotación.</p>
<p>Entre otras acciones, la else-part de la expresión <code>if</code> asigna el valor de <code>kill-ring-yank-pointer</code> a <code>ARGth-kill-element</code> cuando el kill ring <em>anillo de la muerte</em> tiene alguna cosa dentro y el valor de <code>do-not-move</code> es <code>nil</code>.</p>
<p>El código se parece a esto:</p>
<pre><code class="example">(nthcdr (mod (- n (length kill-ring-yank-pointer))
             (length kill-ring))
        kill-ring)))</code></pre>
<p>Esto necesita algún examen. A menos que no se suponga mover el puntero, la función <code>current-kill</code> cambia donde <code>kill-ring-yank-pointer</code> apunta. Esto es lo que la expresión <code>(setq kill-ring-yank-pointer ARGth-kill-element)</code> hace. También, claramente, <code>ARGth-kill-element</code> está siendo asignado para ser igual a algún <code>cdr</code> del anillo de la muerte <em>kill ring</em>, usando la función <code>nthcdr</code> que está descrita en una sección temprana. (Véase Sección <a href="copy-region-as-kill" >copy-region-as-kill</a>.)  ¿Cómo se hace?</p>
<p>Como se ha visto antes (Vease Sección <a href="nthcdr" >nthcdr</a>), la función <code>nthcdr</code> funciona repetidamente tomando el <code>cdr</code> de una lista––eso toma el <code>cdr</code>, del <code>cdr</code>, del <code>cdr</code>, …</p>
<p>Las siguientes dos expresiones producen el mismo resultado:</p>
<pre><code class="example">(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))</code></pre>
<p>Sin embargo, la expresión <code>nthcdr</code> es más complicada. Usa la función <code>mod</code> para determinar que <code>cdr</code> para seleccionar.</p>
<p>(Se recordará buscar funciones propias primero, en vez de esto, tendremos que ir dentro del <code>mod</code>.)</p>
<p>La función <code>mod</code> devuelve el valor de su primer argumento módulo el segundo; que es decir, eso devuelve el resto después de dividir el primer argumento por el segundo. El valor devuelto tiene el mismo signo que el segundo argumento.</p>
<p>De este modo,</p>
<pre><code class="example">(mod 12 4)
  ⇒ 0  ;; @e{porque no hay resto}
(mod 13 4)
  ⇒ 1</code></pre>
<p>En este caso, el primer argumento es con frecuencia pequeño que el segundo. Que está bien.</p>
<pre><code class="example">(mod 0 4)
  ⇒ 0
(mod 1 4)
  ⇒ 1</code></pre>
<p>Se puede adivinar lo que la función <code>-</code> hace. Eso es como <code>+</code> pero sustrae en vez de añadir; la función <code>-</code> sustrae su segundo argumento desde el primero. También, ya se sabe que la función <code>length</code> hace (Vease Sección <a href="Encuentra-la-longitud-de-una-lista:-length" >Encuentra la longitud de una lista: <code>length</code></a>). Eso devuelve el tamaño de una lista.</p>
<p>Y <code>n</code> es el nombre del argumento requerido a la función <code>current-kill</code>.</p>
<p>Así cuando el primer argumento a <code>nthcdr</code> es cero, la expresión <code>nthcdr</code> devuelve la lista entera, como se puede ver evaluando lo siguiente:</p>
<pre><code class="example">;; kill-ring-yank-pointer @e{and} kill-ring @e{tener un tamaño de cuatro}
;; @e{and} (mod (- 0 4) 4) ⇒ 0
(nthcdr (mod (- 0 4) 4)
        '(&quot;cuarta línea de texto&quot;
          &quot;tercera línea&quot;
          &quot;segunda pieza de texto&quot;
          &quot;primero algo de texto&quot;))</code></pre>
<p>Cuando el primer argumento a la función <code>current-kill</code> es uno, la expresión <code>nthcdr</code> devuelve la lista sin su primer elemento.</p>
<pre><code class="example">(nthcdr (mod (- 1 4) 4)
        '(&quot;cuarta línea de texto&quot;
          &quot;tercera línea&quot;
          &quot;segunda pieza de texto&quot;
          &quot;primero algo de texto&quot;))</code></pre>
<p>Incidentalmente, tanto <code>kill-ring</code> y <code>kill-ring-yank-pointer</code> son <dfn>variables globales</dfn>. Esto significa que cualquier expresión en Emacs Lisp puede acceder a ellas. Ellas no son como las variables locales asignadas por <code>let</code> o como los símbolos en una lista de argumentos. Las variables locales pueden solo ser accedidas con el <code>let</code> que los define o la función que los especifica en una lista de argumentos (y con expresiones llamadas por ellos).</p>
</div>
<h4 id="pegar" ><code>pegar</code></h4>
<div class="hBody-4" >
<p>Después de aprender acerca de <code>current-kill</code>, el código para la función <code>yank</code> es casi fácil.</p>
<p>La función <code>yank</code> no usa la variable <code>kill-ring-yank-pointer</code> directamente. Eso llama a <code>insert-for-yank</code> que llama a <code>current-kill</code> que asigna la variable <code>kill-ring-yank-pointer</code>.</p>
<p>El código se parece a esto:</p>
<pre><code class="example">(defun yank (&amp;optional arg)
  &quot;Reinserta (\&quot;pega\&quot;) el último logro del texto cortado.
Más precisamente, reinserta el texto cortado más recientemente.
Pon el punto al final, y asigna la marca al principio.
Solo con \\[universal-argument] como argumento, lo mismo pero pon el
punto al principio (y la marca al final). Con el argumento N, reinserta
el N más recientemente cortado.
Cuando este comando inserta texto cortado dentro del búffer, eso
honra a ‘yank-excluded-properties’ y ‘yank-handler’ como se describe
la cadena de documentación para ‘insert-for-yank-1’, que se ve.
Ver también el comando \\[yank-pop].&quot;
  (interactive &quot;*P&quot;)
  (setq yank-window-start (window-start))
  ;; Si no tenemos todo el camino a través, crea last-command que
  ;; indique esto para el siguiente comando.
  (setq this-command t)
  (push-mark (point))
  (insert-for-yank (current-kill (cond
                                  ((listp arg) 0)
                                  ((eq arg '-) -2)
                                  (t (1- arg)))))
  (if (consp arg)
      ;; Esto es como like exchange-point-and-mark,
      ;;     pero no activa la marca.
      ;; Es limpio evitar la activación, incluso aunque el comando
      ;; loop would desactivaría la marca porque se
      ;; insertara el texto.
      (goto-char (prog1 (mark t)
                   (set-marker (mark-marker) (point) (current-buffer)))))
  ;; Si tenemos todo el camino, haz que this-command lo indique.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)</code></pre>
<p>La expresión clave es <code>insert-for-yank</code>, que inserta la cadena devuelta por <code>current-kill</code>, pero elimina algo de propiedades de texto desde eso.</p>
<p>Sin embargo, antes de tener esta expresión, la función asigna el valor de <code>yank-window-start</code> a la posición devuelta por la expresión <code>(window-start)</code>, la posición que muestra lo que actualmente empieza. La función <code>yank</code> también asigna <code>this-command</code> y empuja la marca.</p>
<p>Después de pegar el elemento apropiado, si el argumento opcional es un <code>cons</code> en vez de un número o nada, se pone el punto al principio del texto pegado y se marca al final.</p>
<p>(La función <code>prog1</code> es como <code>progn</code> pero devuelve el valor de su primer argumento en vez del valor de su último argumento. Su primer argumento fuerza devolver la marca del búffer como un entero. Se puede ver la documentación para estas funciones emplazando el punto a través de ellas en este búffer y entonces escribiendo <kbd>C-h f</kbd> (<code>describe-function</code>) seguido por un <kbd>RET</kbd>; por defecto es la función.)</p>
<p>La última parte de la función cuenta que hacer cuando eso sucede.</p>
</div>
<h4 id="yank-pop" ><code>yank-pop</code></h4>
<div class="hBody-4" >
<p>Después de comprender <code>yank</code> y <code>current-kill</code>, se conoce como enfocar la función <code>yank-pop</code>. Dejando fuera la documentación para guardar el espacio, se parece a esto:</p>
<pre><code class="example">(defun yank-pop (&amp;optional arg)
  &quot;…&quot;
  (interactive &quot;*p&quot;)
  (if (not (eq last-command 'yank))
      (error &quot;El comando previo no fué un corte&quot;))
  (setq this-command 'yank)
  (unless arg (setq arg 1))
  (let ((inhibit-read-only t)
        (before (&lt; (point) (mark t))))
    (if before
        (funcall (or yank-undo-function 'delete-region) (point) (mark t))
      (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
    (setq yank-undo-function nil)
    (set-marker (mark-marker) (point) (current-buffer))
    (insert-for-yank (current-kill arg))
    ;; Asigna la ventana a volver donde estaba el comando yank,
    ;; si es posible
    (set-window-start (selected-window) yank-window-start t)
    (if before
        ;; Esto es como exchange-point-and-mark,
        ;; pero no activa la marca.
        ;; Es limpio evitar la activación, incluso aunque el comando
        ;; desactivase la marca porque se insertara el texto.
        (goto-char (prog1 (mark t)
                     (set-marker (mark-marker)
                                 (point)
                                 (current-buffer))))))
  nil)</code></pre>
<p>La función es interactive con una pequeña <samp>p</samp> así el argumento prefijo es procesado y pasado a la función. El comando puede solo ser usado después del yank previo; de otro modo un mensaje de error se envía. Este chequeo usa la variable <code>last-command</code> que se asigna por <code>yank</code> y discutida de algún modo. (Véase Sección <a href="copy-region-as-kill" >copy-region-as-kill</a>.)</p>
<p>La cláusula <code>let</code> asigna la variable <code>before</code> a cierto o falso dependiendo de si el punto está antes o después de la marca y entonce la región entre punto y marca se borra. Esta es la región que fué insertada por el yank previo y eso es este texto que será reemplazado.</p>
<p><code>funcall</code> llama a su primer argumento como una función, pasando los argumentos que permanecen. El primer argumento es el que la expresión <code>or</code> devuelve. Los dos argumentos que permanecen son las posiciones de punto y marca asignadas por el comando <code>yank</code> precedente.</p>
<p>Hay más, pero esta es la parte más dura.</p>
</div>
<h4 id="El-fichero-ring.el" >El fichero <span class="file" >ring.el</span></h4>
<div class="hBody-4" >
<p>De manera interesante, GNU Emacs posee un fichero llamado <span class="file" >ring.el</span> que provee muchas de las funcionalidades que ahora se discuten. Pero las funciones tales como <code>kill-ring-yank-pointer</code> no usan esta librería, posiblemente porque fueron escritas pronto.</p>
</div>
<h3 id="Apéndice-C-Un-grafo-con-ejes-etiquetados" >Apéndice C <span id="Un grafo con ejes etiquetados" >Un grafo con ejes etiquetados</span></h3>
<div class="hBody-3" >
<p>Los ejes impresos ayudan a comprender un grafo. Para crear escalas. En un capítulo anterior (Vease Sección <a href="Leyendo-un-grafo,-,-Leyendo-un-grafo" >Leyendo un grafo, , Leyendo un grafo</a>), se escribió el código para imprimir el cuerpo de un grafo. Aquí se escribe el código para imprimir y etiquetar ejes horizontales y verticales, a lo largo del cuerpo en sí.</p>
<p>Puesto que las inserciones rellenan un búffer a la derecha y debajo del punto, el nuevo grafo imprime la función que primero imprimiría el eje vertical Y, después el cuerpo del grafo, y finalmente el eje horizontal X. Esta secuencia nos da los contenidos de la función:</p>
<ol>
<li><p>Configura código.</p>
</li>
<li><p>Imprime el eje Y.</p>
</li>
<li><p>Imprime el cuerpo del grafo.</p>
</li>
<li><p>Imprime el eje X.</p>
</li>
</ol>
<p>Aquí hay un ejemplo de como se ve un grafo finalizado:</p>
<pre><code class="example">0 -
             *
             *  *
             *  **
             *  ***
5 -      *   *******
       * *** *******
       *************
     ***************
1 - ****************
    |   |    |    |
    1   5   10   15</code></pre>
<p>En este grafo, en ambos ejes vertical y horizontal se etiquetan con números. Sin embargo, en algunos grafos, el eje horizontal es tiempo y estaría mejor etiquetarlo con meses, así:</p>
<pre><code class="example">5 -      *
       * ** *
       *******
     ********** **
1 - **************
    |    ^      |
  Enero Junio Enero</code></pre>
<p>Dentro, con un pequeño pensamiento, se puede fácilmente venir con una variedad de esquemas de etiquetado verticales y horizontales. Nuestra tarea podría llegar a ser complicada. Pero las complicaciones generan confusión. En vez de permitir esto, es mejor elegir un simple esquema de etiquetado para nuestro primer esfuerzo, y modificarlo o reemplazarlo después.</p>
<p>Estas consideraciones sugieren el siguiente outline para la función <code>print-graph</code>:</p>
<pre><code class="example">(defun print-graph (numbers-list)
  &quot;@V{documentation}…&quot;
  (let ((height  …
        …))
    (print-Y-axis height … )
    (graph-body-print numbers-list)
    (print-X-axis … )))</code></pre>
<p>Nosotros podemos trabajar en cada parte de la definición de función <code>print-graph</code>.</p>
</div>
<h4 id="La-varlist-print-graph" >La varlist <code>print-graph</code></h4>
<div class="hBody-4" >
<p>Para escribir la función <code>print-graph</code>, la primera tarea es escribir la varlist en la expresión <code>let</code>. (Nosotros dejaremos por ahora cualquier pensamiento acerca de hacer la función interactive o acerca de los contenidos de su cadena de documentación.)</p>
<p>La varlist asignaría varios valores. Claramente, la etiqueta superior del eje vertical debe ser al menos la altura del grafo, que significa que debe obtener esta información aquí. Note que la función <code>print-graph-body</code> también requiere esta información. No hay razón para calcular la altura del grafo en dos lugares diferentes, así cambiaría <code>print-graph-body</code> desde el camino que definimos pronto para tomar ventaja del cálculo.</p>
<p>De manera similar, tanto la función para imprimir la etiqueta del eje X y la función <code>print-graph-body</code> se necesita aprender el valor del ancho de cada símbolo. Se puede desarrollar el cálculo aquí y cambiar la definición para <code>print-graph-body</code> desde el camino que se definió en el capítulo previo.</p>
<p>El tamaño de la etiqueta para el eje horizontal debe ser al menos tan largo como el grafo. Sin embargo, esta información es usada solo en la función que imprime el eje horizontal, así no necesita calcularse aquí.</p>
<p>Estos pensamientos nos llevan directamente a la siguiente forma para la varlist en el <code>let</code> para <code>print-graph</code>:</p>
<pre><code class="example">(let ((height (apply 'max numbers-list)) ; @e{Primera versión.}
      (symbol-width (length graph-blank)))</code></pre>
<p>Como se verá, esta expresión no es bastante correcta.</p>
</div>
<h4 id="La-función-print-Y-axis" >La función <code>print-Y-axis</code></h4>
<div class="hBody-4" >
<p>El trabajo de la función <code>print-Y-axis</code> es imprimir una etiqueta para el eje vertical que se parece a esto:</p>
<pre><code class="example">    10 -




     5 -



     1 -</code></pre>
<p>La función se pasaría a lo alto del grafo, y así construyen e insertan los números y marcas apropiados.</p>
<p>Es suficientemente fácil ver en la figura que la etiqueta del eje Y pero se puede decir en palabras, y entonces escribir una definición de función para hacer el trabajo es otra materia. No es bastante verdad decir que se quiere un número y un tic cada cinco líneas: solo hay tres líneas entre el <samp>1</samp> y el <samp>5</samp> (líneas 2, 3 y 4), pero cuatro líneas entre el <samp>5</samp> y el <samp>10</samp> (líneas 6, 7, 8 y 9). Es mejor decir que se quiere un número y un tic en la quinta línea desde abajo a cada línea que es un múltiplo de cinco.</p>
<p>La siguiente cuestión es a que altura se etiquetaría. Supón que la máxima altura de la columna mayor del grafo es siete. La etiqueta superior en el eje Y sería <samp>5 -</samp>, ¿y el grafo se pegaría debajo de la etiqueta?, ¿o la etiqueta superior sería <samp>7 -</samp>, y marcar la vertical del grafo? ¿o sería la etiqueta superior <code>10 -</code>, que es múltiplo de cinco, y es superior al valor más alto del grafo?</p>
<p>La última forma es preferida. La mayoría de los grafos son rectángulos cuyos lados son un número integral de pasos a lo largo––5, 10, 15, y así para un paso a distancia de cinco. Pero tan pronto se decide usar un paso alto para el eje vertical, se descubre que la expresión simple en la varlist para la altura de la computación es errónea. La expresión es <code>(apply 'max numbers-list)</code>. Esto devuelve la altura precisa, no la altura máxima más de lo que es necesario para redondear el múltiplo de cinco. Una expresión más compleja es requerida.</p>
<p>Como es normal en casos como este, un problema complejo llega a ser simple si está dividido en varios problemas pequeños.</p>
<p>Primero, considere el caso cuando el valor superior del grafo es un múltiplo integral de cinco––cuando eso es 5, 10, 15, o algún múltiplo de cinco. Se puede usar este valor como la altura del eje Y.</p>
<p>Un camino simple y limpio para determinar si un número es múltiplo de cinco se divide por cinco y mira si la división devuelve resto. Si no hay resto, el número es un múltiplo de cinco. De este modo, siete dividido tiene un resto de dos, y siete no es un entero múltiplo de cinco. Dicho de otra manera, recordando la escuela, cinco entre siete es uno y me llevo dos. Sin embargo, diez entre dos, no tiene resto: diez es un múltiplo entero de cinco.</p>
</div>
<h5 id="Viaje-lateral:-Calcula-un-resto" >Viaje lateral: Calcula un resto</h5>
<div class="hBody-5" >
<p>En Lisp, la función para calcular un resto es <code>%</code>. La función devuelve el resto de su primer argumento dividido por su segundo argumento. Como ocurre, <code>%</code> es una función en Emacs Lisp que no se puede implementar usando <code>apropos</code>: no se puede encontrar nada si se escribe <kbd>M-x apropos <kbd>RET</kbd> resto <kbd>RET</kbd></kbd>. El único camino para aprender la existencia de <code>%</code> es leer acerca de eso en un libro tal como este o en las fuentes de Emacs Lisp.</p>
<p>Se puede probar la función <code>%</code> evaluando las siguientes dos expresiones:</p>
<pre><code class="example">(% 7 5)

(% 10 5)</code></pre>
<p>La primera expresión devuelve 2 y la segunda expresión devuelve 0.</p>
<p>Para chequear si el valor devuelto es cero o algún otro número, se puede usar la función <code>zerop</code>. Esta función devuelve <code>t</code> si su argumento debe ser un número, es cero.</p>
<pre><code class="example">(zerop (% 7 5))
     ⇒ nil

(zerop (% 10 5))
     ⇒ t</code></pre>
<p>De este modo, la siguiente expresión devolverá <code>t</code> si la altura del grafo es divisible por cinco:</p>
<pre><code class="example">(zerop (% height 5))</code></pre>
<p>(El valor de <code>height</code>, de acuerdo, puede ser encontrado desde <code>(apply 'max numbers-list)</code>.)</p>
<p>Por otro lado, si el valor de <code>height</code> no es un múltiplo de cinco, nosotros queremos resetear el valor al siguiente múltiplo de cinco. Esta es la aritmética sencilla usando funciones con las que ya se está familiarizado. Primero, se divide el valor de <code>height</code> por cinco para determinar cuantas veces cinco va dentro del número. De este modo, cinco va dentro doce veces. Si se añade uno a este cociente y se multiplica por cinco, obtendremos el valor del siguiente múltiplo de cinco que es más largo que el mayor. Cinco va dentro de doce dos veces. Añade uno a dos, y multiplica por cinco; el resultado es quince, que es el siguiente múltiplo de cinco que es mayor de doce. La expresión Lisp para esto es:</p>
<pre><code class="example">(* (1+ (/ height 5)) 5)</code></pre>
<p>Por ejemplo, si se evalúa lo siguiente, el resultado es 15:</p>
<pre><code class="example">(* (1+ (/ 12 5)) 5)</code></pre>
<p>Todo a través de esta discusión, se ha estado usando ‘cinco’ como el valor para las etiquetas espaciadas en el eje Y; pero se puede querer usar algún otro valor. Generalmente, reemplazaría ‘cinco’ con una variable a la que poder asignar un valor. El mejor nombre que puedo pensar para esta variable es <code>Y-axis-label-spacing</code>.</p>
<p>Usando este término, y una expresión <code>if</code>, se produce lo siguiente:</p>
<pre><code class="example">(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @e{else}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))</code></pre>
<p>Esta expresión devuelve el valor de <code>height</code> en sí si la altura es incluso un múltiplo del valor del <code>Y-axis-label-spacing</code> o lo demás computa y devuelve un valor de <code>height</code> que es igual al siguiente múltiplo mayor del valor del <code>Y-axis-label-spacing</code>.</p>
<p>Se puede ahora incluir esta expresión en la expresión <code>let</code> de la función <code>print-graph</code> (después de la primera configuración del valor de <code>Y-axis-label-spacing</code>): @vindex Y-axis-label-spacing</p>
<pre><code class="example">(defvar Y-axis-label-spacing 5
  &quot;Número de líneas desde una etiqueta del eje Y al siguiente.&quot;)

…
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
          ;; @e{else}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
…</code></pre>
<p>(Note que el uso de la función <code>let*</code>: el valor inicial de la altura es calculada una vez por la expresión <code>(apply 'max numbers-list)</code> y entonces el valor resultado de <code>height</code> es usado para computar su valor final. Véase Sección <a href="La-expresión-let*" >La expresión <code>let*</code></a>, para más acerca de <code>let*</code>.)</p>
</div>
<h5 id="Construye-un-elemento-del-eje-Y" >Construye un elemento del eje Y</h5>
<div class="hBody-5" >
<p>Cuando se imprime el eje vertical, se quieren insertar cadenas tales como <samp>5 -</samp> y <samp>10 - </samp> cada cinco líneas. Más allá, se quieren los números agitados para alinear, así pocos números deben ser acuñados con espacios de guía. Si alguna de las cadenas usan dos dígitos, las cadenas con un simple dígito deben incluir una guía en blanco antes del número.</p>
<p>Para figurarse el tamaño del número, se usa la función <code>length</code>. Pero la función <code>length</code> funciona solo con una cadena, no con un número. Así el número tiene que ser convertido desde un número a una cadena. Esto se hace con la función <code>number-to-string</code>. Por ejemplo,</p>
<pre><code class="example">(length (number-to-string 35))
     ⇒ 2

(length (number-to-string 100))
     ⇒ 3</code></pre>
<p>(<code>number-to-string</code> se llama <code>int-to-string</code>; se verá este nombre alternativo en varias fuentes.)</p>
<p>Además, en cada etiqueta, cada número es seguido por una cadena tal como <samp> - </samp>, que llamará al marcador <code>Y-axis-tic</code>. Esta variable está definida con <code>defvar</code>:</p>
<pre><code class="example">(defvar Y-axis-tic &quot; - &quot;
   &quot;La Cadena que sigue el número en una etiqueta del eje Y.&quot;)</code></pre>
<p>El tamaño de la etiqueta Y es la suma del tamaño del eje Y y el tamaño del número del alto del grafo.</p>
<pre><code class="example">(length (concat (number-to-string height) Y-axis-tic)))</code></pre>
<p>Este valor será calculado por la función <code>print-graph</code> en su varlist como <code>full-Y-label-width</code> y se pasa dentro. (Note que no se pensaba en incluir esto en el varlist cuando se propuso.)</p>
<p>Para crear un eje vertical completo, una marca de tic es concatenada con un número; y los dos juntos pueden ser precedidos por uno o más espacios dependiendo de cómo de largo es el número. La etiqueta consiste de tres partes: los espacios que se lideran (opcional), el número, y la marca tic. La función se pasa al valor del número para la fila específica, y el valor del ancho de la línea de arriba, que es calculada (solo una vez) por <code>print-graph</code>.</p>
<pre><code class="example">(defun Y-axis-element (number full-Y-label-width)
  &quot;Construye una etiqueta NUMERADA
Un elemento numerado se parece a esto ‘ 5 - ’,
y está tan acuñado como se necesita así todo se
alinea con el elemento para el número mayor.&quot;
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))</code></pre>
<p>La función <code>Y-axis-element</code> concatena junto los espacios que se lideran si cualquiera; el número, como una cadena; y la marca tic.</p>
<p>Para imaginarnos cuantos espacios guía la etiqueta necesita, la función sustrae el tamaño de la etiqueta––el tamaño del número más el tamaño de la marca tic––desde el ancho de la etiqueta deseada.</p>
<p>Los espacios en blanco se insertan usando la función <code>make-string</code>. Esta función tiene dos argumentos: lo primero cuenta como de larga será a cadena y el segundo es un símbolo para el caracter a insertar, en un formato espcial. El formato es una marca de pregunta seguida por un espacio en blanco, como este, <samp>?</samp>. Véase Sección <cite>Tipo de Caracter</cite> en <em>El Manual de Referencia Emacs Lisp</em>, para una descripción de la sintaxis para caracteres. (De acuerdo, se podría querer reemplazar el espacio en blanco por algún otro caracter …. Tu sabes qué hacer.)</p>
<p>La función <code>number-to-string</code> es usada en la expresión de concatenación, para convertir el número a una cadena que es concatenada con los espacios que se lideran y la marca de tic.</p>
</div>
<h5 id="Crea-un-eje-de-la-columna-Y" >Crea un eje de la columna Y</h5>
<div class="hBody-5" >
<p>Las funciones precedentes proporcionan todas las herramientas necesarias para construir una función que genera una lista de cadenas enumeradas y en blanco para inserta como la etiqueta para el eje vertical:</p>
<pre><code class="example">(defun Y-axis-column (height width-of-label)
  &quot;Construye la lista de ejes Y etiquetadas y cadenas en blanco.
Para height @e{la altura} de la línea de debajo y width-of-label.&quot;
  (let (Y-axis)
    (while (&gt; height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @e{Insertar etiqueta.}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
        ;; @e{Else, insertar blancos.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @e{Insertar la línea base.}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))</code></pre>
<p>En esta función, nosotros empezamos con el valor de <code>height</code> y repetitivamente sustrae uno desde su valor. Después de cada sustración, se chequea para ver si el valor es una integral múltiple del <code>Y-axis-label-spacing</code>. Si eso es, se construye una etiqueta numerada usando la función <code>Y-axis-element</code>; si no, se construye una etiqueta blanca usando la función <code>make-string</code>. La línea base consiste del número uno seguido por una marca tic.</p>
</div>
<h5 id="La-versión-no-demasiado-final-de-print-Y-axis" >La versión no demasiado final de <code>print-Y-axis</code></h5>
<div class="hBody-5" >
<p>La lista construida por la función <code>Y-axis-column</code> está pasada a la función <code>print-Y-axis</code>, que inserta la lista como una columna.</p>
<pre><code class="example">(defun print-Y-axis (height full-Y-label-width)
  &quot;Inserta el eje Y usando HEIGHT y FULL-Y-LABEL-WIDTH.
La altura debe ser la máxima altura del grafo.
El ancho completo es el ancho del mayor elemento de la
etiqueta&quot;
;; El valor del alto y full-Y-label-width
;; son pasadas por ‘print-graph’.
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
    ;; @e{Posiciona el punto listo para inserta el grafo.}
    (goto-char start)
    ;; @e{Mueve el punto hacia adelante por valor de} full-Y-label-width
    (forward-char full-Y-label-width)))</code></pre>
<p>El <code>print-Y-axis</code> usa la función <code>insert-rectangle</code> para inserta el eje Y creado por la función <code>Y-axis-column</code>. Además, eso emplaza el punto en la posición correcta para imprimir el cuerpo del grafo.</p>
<p>Se puede chequear <code>print-Y-axis</code>:</p>
<ul>
<li><p>Instalar</p>
<pre><code class="example">Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis</code></pre>
</li>
<li><p>Copia la siguiente expresión:</p>
<pre><code class="example">(print-Y-axis 12 5)</code></pre>
</li>
<li><p>Cambia al búffer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li><p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li><p>Pega la expresión <code>graph-body-print</code> dentro del minibúffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li><p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá etiquetas verticalmente, el primero siendo <samp>10 - </samp>. (La función <code>print-graph</code> pasará el valor de <code>height-of-top-line</code>, que en este caso finalizará en 15, por esto lo que se obtiene podría aparecer como un error.)</p>
</div>
<h4 id="La-función-print-X-axis" >La función <code>print-X-axis</code></h4>
<div class="hBody-4" >
<p>Las etiquetas del eje X son como las etiquetas del eje Y, excepto que los ticks son un línea debajo de los números. Las etiquetas se parece como esto:</p>
<pre><code class="example">|   |    |    |
1   5   10   15</code></pre>
<p>El primer tic está bajo la primera columna del grafo y está precedido por varios espacios en blanco. Estos espacios proporcionan la habitación en filas de debajo para las etiquetas del eje Y. El segundo, tercer, cuarto, y subsiguientes ticks son todos espaciados igualmente, de acuerdo al valor de <code>X-axis-label-spacing</code>.</p>
<p>La segunda fila del eje X consiste de números, precedidos por varios espacios en blanco y también separado de acuerdo al valor de la variable <code>X-axis-label-spacing</code>.</p>
<p>El valor de la variable <code>X-axis-label-spacing</code> sería medido en unidades de <code>symbol-width</code>, puesto que se puede querer cambiar el ancho de los símbolos que estás usando para imprimir el cuerpo del grafo sin cambiar los caminos del grafo que está etiquetado.</p>
<p>La función <code>print-X-axis</code> está construida más o menos del mismo modo como que la función <code>print-Y-axis</code> excepto que tiene dos líneas: la línea de marcas tic y los números. Nosotros escribiremos una función separado a imprimir cada línea y entonces combinarlo con la función <code>print-X-axis</code>.</p>
<p>Esto es un proceso de tres pasos:</p>
<ol>
<li><p>Escribe una función para imprimir el eje X marca tic, <code>print-X-axis-tic-line</code>.</p>
</li>
<li><p>Escribe una función imprime los números X, <code>print-X-axis-numbered-line</code>.</p>
</li>
<li><p>Escribe una función para imprimir ambas líneas, la función <code>print-X-axis</code>, usando <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>.</p>
</li>
</ol>
</div>
<h5 id="Eje-X-marca-tic" >Eje X marca tic</h5>
<div class="hBody-5" >
<p>La primera función imprimiría las marcas de tic del eje X. Se deben especificar las marcas en sí y su espacio:</p>
<pre><code class="example">(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  &quot;Números de unidades desde un eje X al siguiente.&quot;)</code></pre>
<p>(Note que el valor de <code>graph-blank</code> est'a asignado por otro <code>defvar</code>. El predicado <code>boundp</code> chequea si ya ha sido asignado; <code>boundp</code> devuelve <code>nil</code> si no lo tiene. Si <code>graph-blank</code> fuera disociado y no usara esta construcción condicional, en un GNU Emacs reciente, se introduciría el depurador y mirará un mensaje de error diciendo <samp>Debugger entered--Lisp error: (void-variable graph-blank)</samp></p>
<p>Aquí está el <code>defvar</code> para <code>X-axis-tic-symbol</code>:</p>
<pre><code class="example">(defvar X-axis-tic-symbol &quot;|&quot;
  &quot;Cadena para insertar para apuntar a una columna en el eje X.&quot;)</code></pre>
<p>El objetivo es crear una línea que se parece a esto:</p>
<pre><code class="example">|   |    |    |</code></pre>
<p>El primer tic es indentado así que está bajo la primera columna, que es indentado para proveer espacio para las etiquetas del eje Y.</p>
<p>Un elemento tic consiste en espacios en blanco que se extienden desde un tic al siguiente más un símbolo tic. El número de espacios en blanco se determinan por el ancho del símbolo tic y el <code>X-axis-label-spacing</code>.</p>
<p>El código se parece a esto:</p>
<pre><code class="example">;;; X-axis-tic-element
…
(concat
 (make-string
  ;; @e{Crea una cadena de blancos.}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @e{Concatena blancos con símbolos.}
 X-axis-tic-symbol)
…</code></pre>
<p>Lo siguiente, determina cuantos espacios en blanco son necesarios para indentar la primera marca tic a la primera del grafo. Esto usa el valor de <code>full-Y-label-width</code> pasaba por la función <code>print-graph</code>.</p>
<p>El código para crear <code>X-axis-leading-spaces</code> se parece a esto:</p>
<pre><code class="example">;; X-axis-leading-spaces
…
(make-string full-Y-label-width ? )
…</code></pre>
<p>También necesita determinar el tamaño del eje horizontal, que es el tamaño de la lista de números, y el número de ticks en el eje horizontal:</p>
<pre><code class="example">;; X-length
…
(length numbers-list)

;; tic-width
…
(* symbol-width X-axis-label-spacing)

;; number-of-X-ticks
(if (zerop (% (X-length tic-width)))
    (/ (X-length tic-width))
  (1+ (/ (X-length tic-width))))</code></pre>
<p>Todo esto lidera directamente a la función para imprimir el eje X:</p>
<p>@findex print-X-axis-tic-line ..example &gt; (defun print-X-axis-tic-line (number-of-X-tics X-axis-leading-spaces X-axis-tic-element) &quot;Imprime ticks para el eje X.&quot; (insert X-axis-leading-spaces) (insert X-axis-tic-symbol)  ; <em>En la primera columna.</em> ;; <em>Inserta el segundo tic en el lugar adecuado.</em> (insert (concat (make-string (-  (* symbol-width X-axis-label-spacing) ;; <em>Inserta el espacio en blanco al segundo símbolo tic.</em> (* 2 (length X-axis-tic-symbol))) ? ) X-axis-tic-symbol)) ;; <em>Inserta los ticks que permanecen.</em> (while (&gt; number-of-X-tics 1) (insert X-axis-tic-element) (setq number-of-X-tics (1- number-of-X-tics)))) &lt; example..</p>
<p>La línea de números es igualmente simple:</p>
<p>Primero, creamos un elemento numerado con espacios en blanco antes de cada número:</p>
<pre><code class="example">(defun X-axis-element (number)
  &quot;Construye un elemento del eje X numerado.&quot;
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))</code></pre>
<p>Lo siguiente, se crea la función para imprimir la línea numerada, empezando con el número “1” para la primera columna:</p>
<pre><code class="example">(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  &quot;Imprime la líneas de números del eje X&quot;
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert &quot;1&quot;)
    (insert (concat
             (make-string
              ;; @e{Inserta espacios en blanco al siguiente número.}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (number-to-string number)))
    ;; @e{Insertar números.}
    (setq number (+ number X-axis-label-spacing))
    (while (&gt; number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))</code></pre>
<p>Finalmente, se necesita escribir lo que <code>print-X-axis</code> que usa <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>.</p>
<p>La función debe determinar los valores locales de las variables usadas por <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>, y entonces eso debe llamarlas. También, debe imprimir el retorno de carro que separe las dos líneas.</p>
<p>La función consiste de una varlist que especifica cinco variables locales, y llama cada una de las dos líneas imprimiendo funciones:</p>
<pre><code class="example">(defun print-X-axis (numbers-list)
  &quot;Imprime el eje X etique al tamaño de NUMBERS-LIST.&quot;
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @e{se provee por} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
       (X-tic
        (concat
         (make-string
          ;; @e{Crea una cadena de espacios en blanco.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
         ;; @e{Concatena espacio en blanco con símbolos
         tic.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert &quot;\n&quot;)
    (print-X-axis-numbered-line tic-number leading-spaces)))</code></pre>
<p>Se puede testear <code>print-X-axis</code>:</p>
<ul>
<li><p>Instale <code>X-axis-tic-symbol</code>, <code>X-axis-label-spacing</code>, <code>print-X-axis-tic-line</code>, tanto como <code>X-axis-element</code>, <code>print-X-axis-numbered-line</code>, y <code>print-X-axis</code>.</p>
</li>
<li><p>Copia la siguiente expresión:</p>
<pre><code class="example">(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))</code></pre>
</li>
<li><p>Cambia al búffer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li><p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li><p>Pegue la expresión de test dentro del minibuffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li><p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá el eje horizontal así</p>
<pre><code class="example">|   |    |    |    |
1   5   10   15   20</code></pre>
</div>
<h3 id="Imprimiendo-el-grafo-completo" >Imprimiendo el grafo completo</h3>
<div class="hBody-3" >
<p>Ahora estamos listos para imprimir el grafo completo.</p>
<p>La función para imprimir el grafo con las etiquetas apropiadas sigue el esquema que creamos antes (Vease Sección <a href="Un-Grafo-con-Ejes-Etiquetados" >Un Grafo con Ejes Etiquetados</a>), pero con adiciones.</p>
<p>Aquí está el esquema:</p>
<pre><code class="example">(defun print-graph (numbers-list)
  &quot;@V{documentation}…&quot;
  (let ((height  …
        …))
    (print-Y-axis height … )
    (graph-body-print numbers-list)
    (print-X-axis … )))</code></pre>
<p>La versión final es diferente desde que se planea en dos caminos: primero, contiene los valores adicionales calculadas una vez que en la varlist; segundo, eso trae una opción para específicar las etiquetas se incrementa la fila. Esta última funcionalidad cambia a ser esencial; de otro modo, un grafo puede tener más filas que ajustarse en una muestra o en una hoja de papel.</p>
<p>Esta nueva funcionalidad requiere un cambio a la función <code>Y-axis-column</code>, para añadir <code>vertical-step</code> para eso. Esta función es parece a esto:</p>
<pre><code class="example">;;; @e{Versión Final.}
(defun Y-axis-column
  (height width-of-label &amp;optional vertical-step)
  &quot;Construye una lista de etiquetas para el eje Y.
HEIGHT es la máxima altura del grafo.
WIDTH-OF-LABEL es el máximo ancho de la etiqueta.
VERTICAL-STEP, una opción, es un entero positivo
que especifica cuanto una etiqueta de eje Y incrementa
cada línea. Por ejemplo, un paso de 5
significa que cada línea es cinco unidades
del grafo.&quot;
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (&gt; height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @e{Inserta etiqueta.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
        ;; @e{Else, inserta espacios en blanco.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @e{Inserta línea base.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))</code></pre>
<p>Los valores para la máxima altura del grafo y el ancho de un símbolo se computan por <code>print-graph</code> es su expresión <code>let</code>; así <code>graph-body-print</code> debe ser cambiado para aceptarlos.</p>
<pre><code class="example">;;; @e{Versión Final.}
(defun graph-body-print (numbers-list height symbol-width)
  &quot;Imprime una gráfica de barras del NUMBERS-LIST.
El numbers-list consiste en los valores del eje Y.
HEIGHT es la máxisma altura del grafo.
SYMBOL-WIDTH es el número de cada columna.&quot;
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
      ;; @e{Dibuja el grafo columna por columna.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @e{Posiciona el punto para las etiquetas del eje X.}
    (forward-line height)
    (insert &quot;\n&quot;)))</code></pre>
<p>Finalmente, el código para la función <code>print-graph</code>:</p>
<pre><code class="example">;;; @e{Versión Final.}
(defun print-graph
  (numbers-list &amp;optional vertical-step)
  &quot;El gráfico de barras etiquetadas del NUMBERS-LIST.
El numbers-list consiste en los valores de eje Y.

Opcionalmente, VERTICAL-STEP, un entero positivo, especifica cuanto el
eje Y incrementa cada línea. Por ejemplo, un paso de 5
significa que cada fila es de cinco unidades.
  (let* ((symbol-width (length graph-blank))
         ;; @c{height} @e{en ambos es el número más largo}
         ;; @e{y el número con la mayoría de los digitos.}
         (height (apply 'max numbers-list))
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @e{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))</code></pre>
</div>
<h5 id="Testeando-print-graph" >Testeando <code>print-graph</code></h5>
<div class="hBody-5" >
<p>Se puede chequear la función <code>print-graph</code> con una lista ordenada de números:</p>
<ul>
<li><p>Instala las versiones finales de <code>Y-axis-column</code>, <code>graph-body-print</code>, y <code>print-graph</code> (además del resto del código.)</p>
</li>
<li><p>Copia la siguiente expresión:</p>
<pre><code class="example">(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))</code></pre>
</li>
<li><p>Cambia al búffer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li><p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li><p>Pegue la expresión de test dentro del minibuffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li><p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá un grafo que se parece a:</p>
<pre><code class="example">10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15</code></pre>
<p>Por otro lado, si se pasa a <code>print-graph</code> un <code>vertical-step</code> valor de 2, evaluando esta expresión:</p>
<pre><code class="example">(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)</code></pre>
<p>El grafo se parece a esto:</p>
<pre><code class="example">20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15</code></pre>
<p>(Una pregunta: ¿es el ‘2’ debajo del eje vertical un error o una funcionalidad? Si se piensa que es un error, y sería un ‘1’, (o incluso un ‘0’), se pueden modificar las fuentes.)</p>
</div>
<h5 id="Creando-gráficas-de-números-de-palabras-y-símbolos" >Creando gráficas de números de palabras y símbolos</h5>
<div class="hBody-5" >
<p>Ahora para el gráfico para el que todo este código fué escrito: un gráfico que muestra cuantas definiciones de función contienen unas pocas 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuantos contienen entre 20 y 29 palabras y símbolos, y así.</p>
<p>Esto es un proceso de múltiples pasos. Primero asegúrate que has cargado todo el requisito del código.</p>
<p>Eso es una buena idea para eliminar el valor de <code>top-of-ranges</code> en caso de que has asignado a algún valor diferente. Se puede evaluar lo siguiente:</p>
<pre><code class="example">(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)</code></pre>
<p>Lo siguiente crea una lista del número de palabras y símbolos en cada rango.</p>
<p>Evalúa lo siguiente:</p>
<pre><code class="example">(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files
           (directory-files &quot;/usr/local/emacs/lisp&quot;
                            t &quot;.+el$&quot;))
          '&lt;)
         top-of-ranges))</code></pre>
<p>En mi vieja máquina, esto lleva como una hora. Se parece a 303 ficheros Lisp en mi copia de Emacs version 19.23. Después de toda esta computación, el <code>list-for-graph</code> tenía este valor:</p>
<pre><code class="example">(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)</code></pre>
<p>Esto significa que mi copia de Emacs tiene 537 definiciones de funciones con poco menos de 10 palabras o símbolos en sí, 1027 definiciones de función con 10 a 19 palabras o símbolos dentro, 955 definiciones de función con 20 a 29 palabras o símbolos dentro, y así.</p>
<p>Claramente, solo buscando esta lista se puede ver que la mayoría de definiciones de función contienen de diez a treinta palabras y símbolos.</p>
<p>Ahora para imprimir. Nosotros <em>no</em> queremos imprimir un grafo que es de 1030 líneas de alto …. En vez de eso, imprimiría un grafo que es mejor que venticinco líneas de alto. Un grafo cuya altura puede ser mostrada en casi cualquier monitor, y fácilmente impreso en una hoja de papel.</p>
<p>Esto significa que cada valor en <code>list-for-graph</code> debe ser reducido a un quinceavo de su valor presente.</p>
<p>Aquí hay una corta función para hacer esto, usando dos funciones que no se han visto todavía, <code>mapcar</code> y <code>lambda</code>.</p>
<pre><code class="example">(defun one-fiftieth (full-range)
  &quot;Devuelve la lista, con el cincuenteavo de cada elemento.&quot;
 (mapcar '(lambda (arg) (/ arg 50)) full-range))</code></pre>
</div>
<h5 id="Una-expresión-lambda:-Anonimicidad-útil" >Una expresión <code>lambda</code>: Anonimicidad útil</h5>
<div class="hBody-5" >
<p><code>lambda</code> es el símbolo para una función anónima, una función sin un nombre. Cada vez que se use una función anónima, se necesita incluir su cuerpo completo.</p>
<p>De este modo,</p>
<pre><code class="example">(lambda (arg) (/ arg 50))</code></pre>
<p>es una definición de función que dice ‘devuelve el valor resultante de dividir cualquier cosa que es pasada como <code>arg</code> por 50’.</p>
<p>Pronto, por ejemplo, se tenía una función <code>multiply-by-seven</code>; se multiplica su argumento por 7. Esta función es similar, excepto que divide su argumento por 50; y, no tiene nombre. El equivalente anónimo de <code>multiply-by-seven</code> es:</p>
<pre><code class="example">(lambda (number) (* 7 number))</code></pre>
<p>(Véase Sección <a href="La-forma-especial-defun" >La forma especial <code>defun</code></a>.)</p>
<p>Si queremos multiplicar 3 por 7, podemos escribir:</p>
<pre><code class="example">(multiply-by-seven 3)
 \_______________/ ^
         |         |
      función  argumento</code></pre>
<p>Esta expresión devuelve 21.</p>
<p>De manera similar, se puede escribir:</p>
<pre><code class="example">((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      función anónima     argumento</code></pre>
<p>Si queremos dividir 100 por 50, se puede escribir:</p>
<pre><code class="example">((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
     función anónima   argumento</code></pre>
<p>Esta expresión devuelve 2. El 100 es pasado para la función, que divide este número por 50.</p>
<p>Véase Sección <cite>Expresiones Lambda</cite> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más acerca de <code>lambda</code>. Lisp y expresiones Lambda se derivan del Cálculo Lambda.</p>
</div>
<h4 id="La-función-mapcar" >La función <code>mapcar</code></h4>
<div class="hBody-4" >
<p><code>mapcar</code> es una función que llama a su primer argumento con cada elemento de su segundo argumento. El segundo argumento debe ser una secuencia.</p>
<p>La parte <samp>map</samp> del nombre viene de la frase matemática, ‘mapeando a través de un dominio’, significa hace apply a una función a cada uno de los elementos en un dominio. La frase matemática está basada en la metáfora de un superviviente paseando, un paso en un momento, a través de un área él está mapeando. Y <samp>car</samp>, de acuerdo, viene desde la noción Lisp del primero de una lista.</p>
<p>Por ejemplo,</p>
<pre><code class="example">(mapcar '1+ '(2 4 6))
     ⇒ (3 5 7)</code></pre>
<p>La función <code>1+</code> añade uno a su argumento, es ejecutada en <em>each</em> de la lista, y una nueva lista es devuelta.</p>
<p>En contraste con esto <code>apply</code>, se aplica su primer argumento a todo lo que permanece. (Véase Sección <a href="Leyendo-un-grafo" >Leyendo un grafo</a>, para una explicación de <code>apply</code>.)</p>
<p>En la definición de <code>one-fiftieth</code>, el primer argumento es la función anónima:</p>
<pre><code class="example">(lambda (arg) (/ arg 50))</code></pre>
<p>y el segundo argumento es <code>full-range</code>, que será asociado para <code>list-for-graph</code>.</p>
<p>La expresión completa se parece a esto:</p>
<pre><code class="example">(mapcar (lambda (arg) (/ arg 50)) full-range))</code></pre>
<p>Véase Sección <cite>Mapeando Funciones</cite> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más acerca de <code>mapcar</code>.</p>
<p>Usando la función <code>one-fiftieth</code>, se puede generar una lista en el que cada elemento es un cincuenteavo del tamaño del correspondiente elemento en <code>list-for-graph</code>.</p>
<pre><code class="example">(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))</code></pre>
<p>La lista resultante se parece a esto:</p>
<pre><code class="example">(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)</code></pre>
<p>Así, ¡ya estamos casi listos para imprimir!  (También se notifica la pérdida de información: muchos de los rangos superiores son 0, esto significa que menos de 50 funciones tenían muchas palabras o símbolos––pero no necesariamente significando que niguna tenía muchas palabras o símbolos.)</p>
</div>
<h5 id="Otro-error-…-más-insidioso" >Otro error … más insidioso</h5>
<div class="hBody-5" >
<p>¡Se dijo ‘casi listo para imprimir’! De acuerdo, hay un error en la función <code>print-graph</code> …. Esta tiene una opción <code>vertical-step</code>, pero no una opción <code>horizontal-step</code>. La escala <code>top-of-range</code> va desde 10 a 300 por decenas. Pero la función <code>print-graph</code> imprimirá solo uno por uno.</p>
<p>Esto es un ejemplo clásico de lo que algunos consideramos el tipo más insidioso de error, el error de omisión. Este no es el tipo de error que se puede encontrar estudiando el código, para eso no es el código; es una funcionalidad omitida. Tus mejores acciones son probar tu programa pronto y con frecuencia; e intentar poner en orden, tanto como se pueda, escribir código que sea fácil de comprender y fácil de cambiar. Intenta ser consciente, siempre y cuando se pueda, esto es siempre que tengas que escribir, <em>será</em> reescrito, si no pronto, eventualmente. Un máximo duro de seguir.</p>
<p>Esta es la función <code>print-X-axis-numbered-line</code> que necesita el trabajo; y entonces el <code>print-X-axis</code> y la función <code>print-graph</code> necesita ser adaptada. No se necesita mucho para ser hecho; hay uno simpático: los números podrían alinearse con marcas de tic. Esto toma un pequeño pensamiento.</p>
<p>Aquí está el <code>print-X-axis-numbered-line</code> corregido:</p>
<pre><code class="example">(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &amp;optional horizontal-step)
  &quot;Imprime la líneas de números X-axis&quot;
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
    (insert X-axis-leading-spaces)
    ;; @e{Elimina espacios extra de guía.}
    (delete-char
     (- (1-
         (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
              ;; @e{Inserta espacio en blanco.}
              (-  (* symbol-width
                     X-axis-label-spacing)
                  (1-
                   (length
                    (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string
              (* number horizontal-step))))
    ;; @e{Insertar los números que permanecen.}
    (setq number (+ number X-axis-label-spacing))
    (while (&gt; number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))</code></pre>
<p>Si se está leyendo esto en Info, se pueden ver las nuevas versiones <code>print-X-axis</code> y <code>print-graph</code> y los evaluarlas. Si se está leyendo esto en un libro impreso, se pueden ver las líneas cambiadas aquí (el texto completo es mucho para imprimir).</p>
<pre><code class="example">(defun print-X-axis (numbers-list horizontal-step)
  …
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
(defun print-graph
  (numbers-list
   &amp;optional vertical-step horizontal-step)
  …
    (print-X-axis numbers-list horizontal-step))</code></pre>
</div>
<h5 id="El-gráfico-impreso" >El gráfico impreso</h5>
<div class="hBody-5" >
<p>Cuando esté hecho e instalado, se puede llamar al comando <code>print-graph</code> como esto:</p>
<pre><code class="example">(print-graph fiftieth-list-for-graph 50 10)</code></pre>
<p>Aquí está el gráfico:</p>
<pre><code class="example">1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350</code></pre>
<p>El grupo largo de funciones contienen de 10 a 19 palabras y símbolos.</p>
</div>
<h3 id="Apéndice-D-Software-Libre-y-Manuales-Libres" >Apéndice D Software Libre y Manuales Libres</h3>
<div class="hBody-3" >
<p>@ @b{por Richard M. Stallman}</p>
<p>La mayor deficiencia en sistemas operativos libres no está en el software––es la falta de buenos manuales libres que se puedan incluir en estos sistemas. Muchos de nuestros programas más importantes no vienen con manuales completos. La documentación es una parte esencial de cualquier paquete de software; cuando un paquete de software libre no viene con un manual libre, es una brecha mayor. Nosotros tenemos muchas brechas hoy.</p>
<p>Érase una vez, hace muchos años, se piensa que aprendería Perl. Se tiene una copia de un manual libre, pero se encontró difícil de leer. Cuando pregunto a los usuarios de Perl acerca de alternativas, me contaron que serían mejor los manuales introductorios––pero estos no eran libres.</p>
<p>¿Por qué era esto? Los autores de los buenos manuales los habían escrito para O'Reilly Associates, que los publicaron con términos restrictivos––no copiando, no modificando, los ficheros fuentes están disponibles––que los excluyen desde la comunidad de software libre.</p>
<p>No era la primera vez que esto ocurría, y (para nuestra comunidad es una gran pérdida) eso está lejos desde el último. Las editoriales de manuales privativos han logrado que muchos autores restrinjan sus manuales desde entonces. Muchas veces se ha oido que un usuario de GNU hábil me cuente que un manual que está escribiendo, con el que él espera ayudar al proyecto GNU––y entonces tenía mis esperanzas frustradas, como se ha procedió a explicar que él tenía que haber firmado un contrato con una editorial que restringiría eso, así que no puede usarlo.</p>
<p>Debido a que escribir buen inglés es una habilidad rara entre programadores, se pueden perder manuales por este motivo.</p>
<p>La documentación, como el software, es una cuestión de libertad, no de precio. El problema con estos manuales no eran que O'Reilly Associates impusiera un precio por las copias impresas––que en sí estaban bien. La Free Software Foundation <em>Fundación por el Software Libre</em> <a href="http://shop.fsf.org,-vende-copias-impresas" >http://shop.fsf.org, vende copias impresas</a> de <a href="http://www.gnu.org/doc/doc.html,-manuales-libres-de-GNU" >http://www.gnu.org/doc/doc.html, manuales libres de GNU</a>, también. Pero los manuales de GNU están disponibles en forma de código fuente, mientras que estos manuales están disponibles solo en papel. Los manuales de GNU vienen con permiso para copiar y modificar; los manuales de Perl no. Estas restricciones son un problema.</p>
<p>El criterio para un manual libre es parecido al del software libre: es una cuestión de dar a todos los usuarios ciertas libertades. La redistribución (incluyendo redistribución comercial) debe ser permitida, así el manual puede acompañar cada copia del programa, en líne o en papel. El permiso para modificar es crucial también.</p>
<p>Como regla general, no se cree que sea esencial para la gente tener permisos para modificar todas las partes de artículos y libro. Las cuestiones para escritos no son necesariamente las mismas como estas para el software. Por ejemplo, no se sabe si se está obligado a dar permisos para modificar artículos como este, que describen nuestras acciones y nuestras vistas.</p>
<p>Pero hay una razón particular de por qué la libertad de modificar es crucial para la documentación de software libre. Cuando las personas ejercita su derecho a modificar el software, y añadir o cambiar sus funcionalidades, si son consciente ellos cambiarán el manual también––así se puede proveer documentación usable y cuidada con el programa modificado. Un manual que prohibe a los programadores ser consciente y finalizar el trabajo, o más precisamente requiere escribir un nuevo manual desde cero si ellos cambian el programa, no se ajusta a las necesidades de nuestra comunidad.</p>
<p>Mientras una serie de prohibiciones en la modificación es inaceptable, algunos tipos de límites en el método de modificar no tiene tanto problema. Por ejemplo, los requisitos para preservar la noticia de autores del copyright, los términos de distribución, o la lista de autores, estén ok. Eso es también no da problemas para requerir versiones modificadas para incluir notificar que fueron modificadas, incluso tienen secciones enteras que puede no ser eliminadas o cambiadas, tan largo como estas secciones tratan con asuntos no técnicos. (Algunos manuales de GNU los tienen).</p>
<p>Estos tipos de restricciones no son un problema porque, como materia práctica, no para al programador consciente desde la adaptación del manual para ajustar el programa modificado. En otras palabras, no se bloquea la comunidad del software libre haciendo el uso completo del manual.</p>
<p>Sin embargo, debe ser posible modificar todo el contenido técnico del manual, y entonces se distribuye el resultado en todos los medios usuales, a través de todos los canales usuales; de otro modo, las restricciones bloquean la comunidad, el manual no es libre, y así no se necesita otro manual.</p>
<p>Desafortunadamente, con frecuencia es duro encontrar a alguien a escribir otro manual cuando un manual privativo. El obstáculo es que muchos usuario piensan que un manual privativo es suficientemente bueno––así ellos no ven la necesidad de escribir un manual libre. Ellos no ven que el sistema operativo tiene un gazapo que necesita se rellenado.</p>
<p>¿Por qué los usuarios piensan que los manuales privativos son suficientemente buenos? Algunos no han considerado la cuestión. Espero que este artículo hará alguna cosa para cambiar esto.</p>
<p>Otros usuarios considera manuales privativos aceptables para la misma razón así muchas personas software privativo aceptable: ellos judgan en términos puramente prácticos, no usando la liberta como un criterio. Estas personas son tituladas a sus opiniones, pero desde que estas opciones crezcan desde valores que no incluyen libertad, ellas no están guiadas por esto quienes valoran la libertad.</p>
<p>Por favor, populariza esta cuestión. Se continúa a perder manuales para publicación privativa. Si se populariza que los manuales privativos no son suficientes, quizás la siguiente persona que quiere ayudar a GNU escribiendo documentación realizará, antes de que sea demasiado tarde, lo que él debe que todo sea libre.</p>
<p>Se puede también animar editoriales comerciales a vender manuales libres o con copyleft en vez de uno privativo. Un camino que se puede ayudar esto chequea los términos de la distribución de un manual antes de que se compre, y preferimos manuales copyleft a los no copyleft.</p>
<p>Note: La Fundación para el Software Libre mantiene una página en su sitio Web que liste libros libres disponibles desde otras editoriales:@* <a href="http://www.gnu.org/doc/other-free-books.html" >http://www.gnu.org/doc/other-free-books.html</a></p>
</div>
<h2 id="Appendix-E-GNU-Free-Documentation-License" >Appendix E GNU Free Documentation License</h2>
<div class="hBody-2" >
<div class="center" >
<p>Version 1.3, 3 November 2008</p>
</div>
<p>Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</p>
<p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>
</div>
<h3 id="0.-PREAMBLE" >0. PREAMBLE</h3>
<div class="hBody-3" >
<p>The purpose of this License is to make a manual, textbook, or other functional and useful document &quot;free&quot; in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</p>
<p>This License is a kind of &quot;copyleft&quot;, which means that derivative works of the document must themselves be free in the same sense.  It complements the GNU General Public License, which is a copyleft license designed for free software.</p>
<p>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does.  But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book.  We recommend this License principally for works whose purpose is instruction or reference.</p>
</div>
<h3 id="1.-APPLICABILITY-AND-DEFINITIONS" >1. APPLICABILITY AND DEFINITIONS</h3>
<div class="hBody-3" >
<p>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License.  Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein.  The &quot;Document&quot;, below, refers to any such manual or work.  Any member of the public is a licensee, and is addressed as &quot;you&quot;.  You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</p>
<p>A &quot;Modified Version&quot; of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</p>
<p>A &quot;Secondary Section&quot; is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject.  (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.)  The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</p>
<p>The &quot;Invariant Sections&quot; are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License.  If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant.  The Document may contain zero Invariant Sections.  If the Document does not identify any Invariant Sections then there are none.</p>
<p>The &quot;Cover Texts&quot; are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License.  A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</p>
<p>A &quot;Transparent&quot; copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters.  A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent.  An image format is not Transparent if used for any substantial amount of text.  A copy that is not &quot;Transparent&quot; is called &quot;Opaque&quot;.</p>
<p>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification.  Examples of transparent image formats include PNG, XCF and JPG.  Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.</p>
<p>The &quot;Title Page&quot; means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page.  For works in formats which do not have any title page as such, &quot;Title Page&quot; means the text near the most prominent appearance of the work's title, preceding the beginning of the body of the text.</p>
<p>The &quot;publisher&quot; means any person or entity that distributes copies of the Document to the public.</p>
<p>A section &quot;Entitled XYZ&quot; means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language.  (Here XYZ stands for a specific section name mentioned below, such as &quot;Acknowledgements&quot;, &quot;Dedications&quot;, &quot;Endorsements&quot;, or &quot;History&quot;.)  To &quot;Preserve the Title&quot; of such a section when you modify the Document means that it remains a section &quot;Entitled XYZ&quot; according to this definition.</p>
<p>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document.  These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</p>
</div>
<h3 id="2.-VERBATIM-COPYING" >2. VERBATIM COPYING</h3>
<div class="hBody-3" >
<p>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License.  You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute.  However, you may accept compensation in exchange for copies.  If you distribute a large enough number of copies you must also follow the conditions in section 3.</p>
<p>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</p>
</div>
<h3 id="3.-COPYING-IN-QUANTITY" >3. COPYING IN QUANTITY</h3>
<div class="hBody-3" >
<p>If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover.  Both covers must also clearly and legibly identify you as the publisher of these copies.  The front cover must present the full title with all words of the title equally prominent and visible.  You may add other material on the covers in addition.  Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</p>
<p>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</p>
<p>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material.  If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</p>
<p>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</p>
</div>
<h3 id="4.-MODIFICATIONS" >4. MODIFICATIONS</h3>
<div class="hBody-3" >
<p>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:</p>
<ol>
<li><p>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document).  You may use the same title as a previous version if the original publisher of that version gives permission.</p>
</li>
<li><p>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.</p>
</li>
<li><p>State on the Title page the name of the publisher of the Modified Version, as the publisher.</p>
</li>
<li><p>Preserve all the copyright notices of the Document.</p>
</li>
<li><p>Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.</p>
</li>
<li><p>Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.</p>
</li>
<li><p>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice.</p>
</li>
<li><p>Include an unaltered copy of this License.</p>
</li>
<li><p>Preserve the section Entitled &quot;History&quot;, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page.  If there is no section Entitled &quot;History&quot; in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.</p>
</li>
<li><p>Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the &quot;History&quot; section.  You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.</p>
</li>
<li><p>For any section Entitled &quot;Acknowledgements&quot; or &quot;Dedications&quot;, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.</p>
</li>
<li><p>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles.  Section numbers or the equivalent are not considered part of the section titles.</p>
</li>
<li><p>Delete any section Entitled &quot;Endorsements&quot;.  Such a section may not be included in the Modified Version.</p>
</li>
<li><p>Do not retitle any existing section to be Entitled &quot;Endorsements&quot; or to conflict in title with any Invariant Section.</p>
</li>
<li><p>Preserve any Warranty Disclaimers.</p>
</li>
</ol>
<p>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant.  To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice.  These titles must be distinct from any other section titles.</p>
<p>You may add a section Entitled &quot;Endorsements&quot;, provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version.  Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity.  If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</p>
<p>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</p>
</div>
<h3 id="5.-COMBINING-DOCUMENTS" >5. COMBINING DOCUMENTS</h3>
<div class="hBody-3" >
<p>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</p>
<p>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy.  If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number.  Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</p>
<p>In the combination, you must combine any sections Entitled &quot;History&quot; in the various original documents, forming one section Entitled &quot;History&quot;; likewise combine any sections Entitled &quot;Acknowledgements&quot;, and any sections Entitled &quot;Dedications&quot;.  You must delete all sections Entitled &quot;Endorsements&quot;.</p>
</div>
<h3 id="6.-COLLECTIONS-OF-DOCUMENTS" >6. COLLECTIONS OF DOCUMENTS</h3>
<div class="hBody-3" >
<p>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</p>
<p>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</p>
</div>
<h3 id="7.-AGGREGATION-WITH-INDEPENDENT-WORKS" >7. AGGREGATION WITH INDEPENDENT WORKS</h3>
<div class="hBody-3" >
<p>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an &quot;aggregate&quot; if the copyright resulting from the compilation is not used to limit the legal rights of the compilation's users beyond what the individual works permit.  When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.</p>
<p>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document's Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form.  Otherwise they must appear on printed covers that bracket the whole aggregate.</p>
</div>
<h3 id="8.-TRANSLATION" >8. TRANSLATION</h3>
<div class="hBody-3" >
<p>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4.  Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections.  You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers.  In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</p>
<p>If a section in the Document is Entitled &quot;Acknowledgements&quot;, &quot;Dedications&quot;, or &quot;History&quot;, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.</p>
</div>
<h3 id="9.-TERMINATION" >9. TERMINATION</h3>
<div class="hBody-3" >
<p>You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License.  Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.</p>
<p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p>
<p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p>
<p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.</p>
</div>
<h3 id="10.-FUTURE-REVISIONS-OF-THIS-LICENSE" >10. FUTURE REVISIONS OF THIS LICENSE</h3>
<div class="hBody-3" >
<p>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.  See http://www.gnu.org/copyleft/.</p>
<p>Each version of the License is given a distinguishing version number.  If the Document specifies that a particular numbered version of this License &quot;or any later version&quot; applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation.  If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation.  If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Document.</p>
</div>
<h3 id="11.-RELICENSING" >11. RELICENSING</h3>
<div class="hBody-3" >
<p>&quot;Massive Multiauthor Collaboration Site&quot; (or &quot;MMC Site&quot;) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works.  A public wiki that anybody can edit is an example of such a server.  A &quot;Massive Multiauthor Collaboration&quot; (or &quot;MMC&quot;) contained in the site means any set of copyrightable works thus published on the MMC site.</p>
<p>&quot;CC-BY-SA&quot; means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.</p>
<p>&quot;Incorporate&quot; means to publish or republish a Document, in whole or in part, as part of another Document.</p>
<p>An MMC is &quot;eligible for relicensing&quot; if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.</p>
<p>The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.</p>
</div>
<h2 id="ADDENDUM:-How-to-use-this-License-for-your-documents" >ADDENDUM: How to use this License for your documents</h2>
<div class="hBody-2" >
<p>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</p>
<pre><code class="example">Copyright (c)  YEAR  YOUR NAME.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled &quot;GNU
Free Documentation License&quot;.</code></pre>
<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the &quot;with...Texts.&quot; line with this:</p>
<pre><code class="example">with the Invariant Sections being LIST THEIR TITLES, with the
Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.</code></pre>
<p>If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.</p>
<p>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</p>
</div>
<h3 id="Acerca-del-Autor" >Acerca del Autor</h3>
<div class="hBody-3" >
<p>Robert J. Chassell ha trabajado con GNU Emacs desde 1985. Él escribe, edita y enseña Emacs y Emacs Lisp, y habla alrededor del mundo acerca de la libertad del software. Chassell es Director fundador y Tesorero de la Fundación por el Software Libre (FSF). Él se graduó la Universidad de Cambridge, en Inglaterra. Él tiene un interés contínuo en historia económica y social y vuela su propio aeroplano</p>
</div>
<h2 id="footnotes" >footnotes</h2>
<div class="hBody-2" >
<dl>
<dt><p><span class="defnote" id="1" >1</span></p>
</dt>
<dd><p>El apóstrofo o comilla es una abreviación para la función <code>quote</code>; no necesitas pensar acerca de funciones ahora; las funciones se definen en la Seccion <a href="Generar-un-mensaje-de-error" >Generar un mensaje de error</a>.</p>
</dd>
<dt><p><span class="defnote" id="2" >2</span></p>
</dt>
<dd><p>Es curioso trazar la ruta por la cual la palabra ‘argumento’ llego a tener dos significados distintos, uno en matemáticas y otro en el inglés cotidiano. De acuerdo al <em>Oxford English Dictionary</em>, la palabra deriva del Latín para <samp>dejar claro, probar</samp>; por lo tanto, paso a significar, por un hilo de derivación, ‘la evidencia ofrecida como prueba’, es decir ‘la informacion que se ofrece’, que conduce a su significado en Lisp. Pero en el otro hilo de derivación, paso a significar ‘para afirmar de una manera lo que otros pueden afirmar en contra’, lo que llevó a la disputa del significado de la palabra. (Nóte aquí que la palabra Inglésa tiene dos definiciones distintas al mismo tiempo. En contraste, en Emacs Lisp, un símbolo no puede tener dos definiciones de funcion diferentes al mismo tiempo.)</p>
</dd>
<dt><p><span class="defnote" id="3" >3</span></p>
</dt>
<dd><p><code>(quote hola)</code> es una expansión de la abreviatura <code>'hola</code>.</p>
</dd>
<dt><p><span class="defnote" id="4" >4</span></p>
</dt>
<dd><p>En realidad, puede utilizar <code>%s</code> para imprimir un número. Es no específico. <code>%d</code> imprime solo la parte de un número a la izquierda del punto decimal, excluyendo cualquier cosa que no sea un número.</p>
</dd>
<dt><p><span class="defnote" id="5" >5</span></p>
</dt>
<dd><p>En realidad, por defecto, si el búffer desde el que has cambiado es visible por tí en otra ventana, <code>other-buffer</code> elegirá el búffer más reciente que no puedas ver; esta es una sutileza que a menudo olvido.</p>
</dd>
</dl>
<ul>
<li><p><span class="defnote" id="6" >6</span> -: O mejor, para evitar escribir, probablemente solo necesite pulsar <kbd>RET</kbd> si <span class="file" >*scratch*</span> es el buffer por defecto, de ser diferente, solo escriba parte del nombre, por ejemplo <code>*sc</code>, luego presione la tecla <kbd>TAB</kbd> para hacer que se expanda el nombre completo, y finalmente pulsa <kbd>RET</kbd>.</p>
</li>
<li><p><span class="defnote" id="7" >7</span> -: Recuerda, esta expresión te desplaza al buffer diferente más reciente que no puedas ver. Si realmente quieres ir al ultimo búffer seleccionado, incluso si es visible, es necesario evaluar la siguiente expresión más compleja:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
</pre></div>
<p>En este caso, el primer argumento de <code>other-buffer</code> le dice a que búffer saltar––el actual––y el segundo argumento le indica a <code>other-buffer</code> que esta BIEN cambiar a un búffer visible. La utilidad de <code>switch-to-buffer</code> es llevarte a una ventana invisible ya que probablemente usarias <kbd>C-x o</kbd> (<code>other-window</code>) para ir a otro búffer visible.</p>
</li>
</ul>
<dl>
<dt><p><span class="defnote" id="8" >8</span></p>
</dt>
<dd><p>De acuerdo con Jared Diamond en <em>Guns, Germs, and Steel</em>, “… las cebras se vuelven increiblemente peligrosas a medida que envejecen” pero la demanda aquí es que no llegan a ser fieras como un tigre. (1997, W. W. Norton and Co., ISBN 0-393-03894-2, pagina 171)</p>
</dd>
<dt><p><span class="defnote" id="9" >9</span></p>
</dt>
<dd><p>Actualmente, se puede <code>cons</code> un elemento para un átomo para producir a para punteado. Los pares punteados no se discuten aquí; ver Seccion &quot;Notación de Para Punteado&quot; en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
</dd>
<dt><p><span class="defnote" id="10" >10</span></p>
</dt>
<dd><p>Más precisamente, y requiriendo conocimiento más experto para comprender, los dos enteros son del tipo ‘Lisp_Object’, que puede también ser una unión C en vez de un tipo de entero.</p>
</dd>
<dt><p><span class="defnote" id="11" >11</span></p>
</dt>
<dd><p>Se pueden escribir funciones recursivas para ser frugal o basura mental o recursos de ordenador; como eso ocurre, los métodos que la gente encuentra fáciles––son frugales de ‘recursos mentales’––algunas veces usan recursos de ordenador considerables. Emacs fué diseñado para ejecutarse en máquinas que ahora se consideran limitadas y sus configuraciones por defecto son conservadoras. Se puede querer incrementar los valores de <code>max-specdl-size</code> y <code>max-lisp-eval-depth</code>. En mi fichero <span class="file" >.emacs</span>, yo los asigno a 15 o 30 veces su valor por defecto.</p>
</dd>
<dt><p><span class="defnote" id="12" >12</span></p>
</dt>
<dd><p>La frase <dfn>cola recursiva</dfn> es usado para describir tal proceso, uno que usa ‘espacio constante’.</p>
</dd>
<dt><p><span class="defnote" id="13" >13</span></p>
</dt>
<dd><p>La jerga es medianamente confusa: <code>triangle-recursive-helper</code> usa un proceso que es iterativo en un procedimiento que es recursivo. El proceso se llama iterativo porque el ordenador necesita solo grabar los tres valores, <code>suma</code>, <code>contador</code>, y <code>número</code>: el procedimiento es recursivo porque la función ‘llama a sí mismo’. Por otro lado, ambos el proceso y el procedimiento usado por <code>triangle-recursively</code> son llamados recursivos. La palabra ‘recursivo’ tiene diferentes significados en los dos contextos.</p>
</dd>
<dt><p><span class="defnote" id="14" >14</span></p>
</dt>
<dd><p>Tu puedes también añadir <span class="file" >.el</span> para <span class="file" >~/.emacs</span> y llama a un fichero <span class="file" >~/.emacs</span>. En el pasado, fué prohibido escribir los atajos de teclado extra que el nombre <span class="file" >~/.emacs.el</span> requiere, pero ahora puedes. El nuevo formato es consistente con las conveniciones de nombre del fichero Emacs Lisp; el viejo formato guarda la escritura.</p>
</dd>
<dt><p><span class="defnote" id="15" >15</span></p>
</dt>
<dd><p>Cuando se empiezan las instancias de Emacs que no cargan mi fichero <span class="file" >.emacs</span> o cualquier fichero, también se puede deshabilitar la ocultación:</p>
<pre><code class="example">emacs -q --no-site-file -eval
'(blink-cursor-mode nil)' @exdent O ahora, usando un conjunto más
sofisticado de opciones, emacs -Q - D</code></pre>
</dd>
<dt><p><span class="defnote" id="16" >16</span></p>
</dt>
<dd><p>también se ejecutan gestores de ventanas más modernos, tales como Enlightenment, Gnome, o KDE; en estos casos, con frecuencia se especifica una imagen en vez de un color plano.</p>
</dd>
</dl>
</div>
</body>
</html>
