<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" />
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es" >
<head>
  <title>Una introducción a la programación en Emacs Lisp</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="subtitle" content="Revisada la tercera edición" />
  <meta name="author" content="Robert J. Chassell" />
  <meta name="translator" content="David Arroyo Menéndez" />
  <meta name="translator" content="nasciiboy" />
  <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />
</head>

<body>
<div id="toc">
  <p>index</p>
  <div id="toc-contents">
  <ul>
  <li><a class="h2" href="#prefacio" >Prefacio</a></li>
    <ul>
    <li><a class="h3" href="#sobre-la-lectura-de-este-texto" >Sobre la lectura de este texto</a></li>
    <li><a class="h3" href="#para-quien-está-escrito-esto" >Para quien está escrito esto</a></li>
    <li><a class="h3" href="#historia-de-lisp" >Historia de Lisp</a></li>
    <li><a class="h3" href="#nota-para-principiantes" >Nota para principiantes</a></li>
    <li><a class="h3" href="#agradecimientos" >Agradecimientos</a></li>
    </ul>
  <li><a class="h2" href="#procesamiento-de-listas" >Procesamiento de listas</a></li>
    <ul>
    <li><a class="h3" href="#listas-lisp" >Listas Lisp</a></li>
      <ul>
      <li><a class="h4" href="#átomos-lisp" >Átomos Lisp</a></li>
      <li><a class="h4" href="#espacios-en-blanco-en-listas" >Espacios en blanco en listas</a></li>
      <li><a class="h4" href="#gnu-emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</a></li>
      </ul>
    <li><a class="h3" href="#ejecutar-un-programa" >Ejecutar un programa</a></li>
    <li><a class="h3" href="#generar-un-mensaje-de-error" >Generar un mensaje de error</a></li>
    <li><a class="h3" href="#nombres-de-símbolos-y-definiciones-de-funciones" >Nombres de símbolos y definiciones de funciones</a></li>
    <li><a class="h3" href="#el-intérprete-lisp" >El intérprete Lisp</a></li>
      <ul>
      <li><a class="h4" href="#codigo-compilado" >Codigo Compilado</a></li>
      </ul>
    <li><a class="h3" href="#evaluación" >Evaluación</a></li>
      <ul>
      <li><a class="h4" href="#evaluación-de-listas-internas" >Evaluación de listas internas</a></li>
      </ul>
    <li><a class="h3" href="#variables" >Variables</a></li>
      <ul>
      <li><a class="h4" href="#mensaje-de-error-de-un-símbolo-sin-una-función" >Mensaje de error de un símbolo sin una función</a></li>
      <li><a class="h4" href="#mensaje-de-error-de-un-símbolo-sin-un-valor" >Mensaje de error de un símbolo sin un valor</a></li>
      </ul>
    <li><a class="h3" href="#argumentos" >Argumentos</a></li>
      <ul>
      <li><a class="h4" href="#tipos-de-datos-de-los-argumentos" >Tipos de datos de los argumentos</a></li>
      <li><a class="h4" href="#un-argumento-como-el-valor-de-una-variable-o-lista" >Un argumento como el valor de una variable o lista</a></li>
      <li><a class="h4" href="#número-variable-de-argumentos" >Número variable de argumentos</a></li>
      <li><a class="h4" href="#usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a></li>
      <li><a class="h4" href="#la-función-message" >La función <code>message</code></a></li>
      </ul>
    <li><a class="h3" href="#configurando-el-valor-de-una-variable" >Configurando el valor de una variable</a></li>
      <ul>
      <li><a class="h4" href="#usando-set" >Usando <code>set</code></a></li>
      <li><a class="h4" href="#usando-setq" >Usando <code>setq</code></a></li>
      <li><a class="h4" href="#conteo" >Conteo</a></li>
      </ul>
    <li><a class="h3" href="#resumen" >Resumen</a></li>
    <li><a class="h3" href="#ejercicios" >Ejercicios</a></li>
    </ul>
  <li><a class="h2" href="#practicando-la-evaluación" >Practicando la Evaluación</a></li>
    <ul>
    <li><a class="h3" href="#nombres-de-búfer" >Nombres de búfer</a></li>
    <li><a class="h3" href="#obtención-de-búfers" >Obtención de Búfers</a></li>
    <li><a class="h3" href="#cambiando-búfers" >Cambiando búfers</a></li>
    <li><a class="h3" href="#tamaño-del-búfer-y-la-ubicación-del-punto" >Tamaño del búfer y la ubicación del punto</a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#cómo-escribir-definiciones-de-funciones" >Cómo escribir definiciones de funciones</a></li>
    <ul>
    <li><a class="h3" href="#la-forma-especial-defun" >La forma especial <code>defun</code></a></li>
    <li><a class="h3" href="#instalar-una-definición-de-función" >Instalar una definición de función</a></li>
      <ul>
      <li><a class="h4" href="#cambiar-una-definición-de-función" >Cambiar una definición de función</a></li>
      </ul>
    <li><a class="h3" href="#crear-una-función-interactiva" >Crear una función interactiva</a></li>
      <ul>
      <li><a class="h4" href="#multiplicar-por-siete-interactivo" ><code>multiplicar-por-siete</code> interactivo</a></li>
      </ul>
    <li><a class="h3" href="#diferentes-opciones-para-interactive" >Diferentes opciones para <code>interactive</code></a></li>
    <li><a class="h3" href="#instalar-código-permanentemente" >Instalar Código Permanentemente</a></li>
    <li><a class="h3" href="#let" ><code>let</code></a></li>
      <ul>
      <li><a class="h4" href="#partes-de-una-expresión-let" >Partes de una expresión <code>let</code></a></li>
      <li><a class="h4" href="#ejemplo-de-expresión-let" >Ejemplo de Expresión <code>let</code></a></li>
      <li><a class="h4" href="#variables-sin-inicializar-en-un-sentencia-let" >Variables sin inicializar en un sentencia <code>let</code></a></li>
      </ul>
    <li><a class="h3" href="#la-forma-especial-if" >La forma especial <code>if</code></a></li>
      <ul>
      <li><a class="h4" href="#la-función-tipo-de-animal-en-detalle" >La función <code>tipo-de-animal</code> en detalle</a></li>
      </ul>
    <li><a class="h3" href="#expresiones-if–then–else" >Expresiones if–then–else</a></li>
    <li><a class="h3" href="#verdad-y-falsedad-en-emacs-lisp" >Verdad y Falsedad en Emacs Lisp</a></li>
    <li><a class="h3" href="#save-excursion" ><code>save-excursion</code></a></li>
      <ul>
      <li><a class="h4" href="#plantilla-para-una-expresión-save-excursion" >Plantilla para una Expresión <code>save-excursion</code></a></li>
      </ul>
    <li><a class="h3" href="#repaso:-cómo-escribir-definiciones-de-funciones" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios" >Ejercicios</a></li>
    </ul>
  <li><a class="h2" href="#algunas-funciones-relacionadas-al-bufer" >Algunas funciones relacionadas al bufer</a></li>
    <ul>
    <li><a class="h3" href="#encontrar-más-información" >Encontrar Más información</a></li>
    <li><a class="h3" href="#una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></a></li>
    <li><a class="h3" href="#la-definición-de-mark-whole-buffer" >La definición de <code>mark-whole-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#cuerpo-de-mark-whole-buffer" >Cuerpo de <code>mark-whole-buffer</code></a></li>
      </ul>
    <li><a class="h3" href="#la-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-interactiva-append-to-buffer" >La expresión interactiva <code>append-to-buffer</code></a></li>
      <li><a class="h4" href="#el-cuerpo-de-append-to-buffer" >El cuerpo de <code>append-to-buffer</code></a></li>
      <li><a class="h4" href="#save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></a></li>
      </ul>
    <li><a class="h3" href="#repaso" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios" >Ejercicios</a></li>
    </ul>
  <li><a class="h2" href="#algunas-funciones-más-complejas" >Algunas Funciones Más Complejas</a></li>
    <ul>
    <li><a class="h3" href="#la-definición-de-copy-to-buffer" >La definición de <code>copy-to-buffer</code></a></li>
    <li><a class="h3" href="#la-definición-de-insert-buffer" >La definición de <code>insert-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-interactiva-en-insert-buffer" >La expresión interactiva en <code>insert-buffer</code></a></li>
        <ul>
        <li><a class="h5" href="#un-búfer-de-solo-lectura" >Un búfer de solo lectura</a></li>
        <li><a class="h5" href="#b-en-una-expresión-interactiva" ><samp>b</samp> en una expresión interactiva</a></li>
        </ul>
      <li><a class="h4" href="#el-cuerpo-de-la-función-insert-buffer" >El cuerpo de la función <code>insert-buffer</code></a></li>
      <li><a class="h4" href="#insert-buffer-con-un-if-en-lugar-de-un-or" ><code>insert-buffer</code> con un <code>if</code> en lugar de un <code>or</code></a></li>
      <li><a class="h4" href="#el-or-en-el-cuerpo" >El <code>or</code> en el cuerpo</a></li>
      <li><a class="h4" href="#la-expresión-let-en-insert-buffer" >La expresión <code>let</code> en <code>insert-buffer</code></a></li>
      <li><a class="h4" href="#nuevo-cuerpo-para-insert-buffer" >Nuevo cuerpo para <code>insert-buffer</code></a></li>
      </ul>
    <li><a class="h3" href="#definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#argumentos-opcionales" >Argumentos opcionales</a></li>
      <li><a class="h4" href="#beginning-of-buffer-con-un-argumento" ><code>beginning-of-buffer</code> con un argumento</a></li>
        <ul>
        <li><a class="h5" href="#qué-ocurre-en-un-búfer-de-gran-tamaño" >Qué ocurre en un búfer de gran tamaño</a></li>
        <li><a class="h5" href="#lo-que-sucede-en-un-búfer-pequeño" >Lo que sucede en un búfer pequeño</a></li>
        </ul>
      <li><a class="h4" href="#funcion-beginning-of-buffer-completa" >Funcion <code>beginning-of-buffer</code> Completa</a></li>
      </ul>
    <li><a class="h3" href="#repaso:-algunas-funciones-más-complejas" >Repaso</a></li>
    <li><a class="h3" href="#ejercicio-con-el-argumento-opcional" >Ejercicio con el argumento <code>opcional</code></a></li>
    </ul>
  <li><a class="h2" href="#reducir-y-extender" >Reducir y Extender</a></li>
    <ul>
    <li><a class="h3" href="#la-forma-especial-save-restriction" >La forma especial <code>save-restriction</code></a></li>
    <li><a class="h3" href="#what-line" ><code>what-line</code></a></li>
    <li><a class="h3" href="#ejercicio-con-reduccion" >Ejercicio con Reduccion</a></li>
    </ul>
  <li><a class="h2" href="#car,-cdr,-cons:-funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</a></li>
    <ul>
    <li><a class="h3" href="#car-y-cdr" ><code>car</code> y <code>cdr</code></a></li>
    <li><a class="h3" href="#cons" ><code>cons</code></a></li>
      <ul>
      <li><a class="h4" href="#descubrir-la-longitud-de-una-lista:-length" >Descubrir la longitud de una lista: <code>length</code></a></li>
      </ul>
    <li><a class="h3" href="#nthcdr" ><code>nthcdr</code></a></li>
    <li><a class="h3" href="#nth" ><code>nth</code></a></li>
    <li><a class="h3" href="#setcar" ><code>setcar</code></a></li>
    <li><a class="h3" href="#setcdr" ><code>setcdr</code></a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#corte-y-almacenamiento-de-texto" >Corte y Almacenamiento de Texto</a></li>
    <ul>
    <li><a class="h3" href="#zap-to-char" ><code>zap-to-char</code></a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-interactive" >La expresión <code>interactive</code></a></li>
      <li><a class="h4" href="#el-cuerpo-de-zap-to-char" >El cuerpo de <code>zap-to-char</code></a></li>
      <li><a class="h4" href="#la-función-search-forward" >La Función <code>search-forward</code></a></li>
      <li><a class="h4" href="#la-forma-especial-progn" >La forma especial <code>progn</code></a></li>
      <li><a class="h4" href="#resumiendo-zap-to-char" >Resumiendo <code>zap-to-char</code></a></li>
      </ul>
    <li><a class="h3" href="#kill-region" ><code>kill-region</code></a></li>
      <ul>
      <li><a class="h4" href="#condition-case" ><code>condition-case</code></a></li>
      <li><a class="h4" href="#macro-lisp" >Macro Lisp</a></li>
      </ul>
    <li><a class="h3" href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a></li>
      <ul>
      <li><a class="h4" href="#el-cuerpo-de-copy-region-as-kill" >El cuerpo de <code>copy-region-as-kill</code></a></li>
        <ul>
        <li><a class="h5" href="#la-función-kill-append" >La función <code>kill-append</code></a></li>
        <li><a class="h5" href="#la-función-kill-new" >La función <code>kill-new</code></a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#disgresión-dentro-de-c" >Disgresión dentro de C</a></li>
    <li><a class="h3" href="#inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></a></li>
      <ul>
      <li><a class="h4" href="#defvar-y-un-asterisco" ><code>defvar</code> y un asterisco</a></li>
      </ul>
    <li><a class="h3" href="#repaso" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios-de-busqueda" >Ejercicios de Busqueda</a></li>
    </ul>
  <li><a class="h2" href="#cómo-se-implementan-las-listas" >Cómo se implementan las listas</a></li>
    <ul>
    <li><a class="h3" href="#símbolos-como-una-caja-con-cajones" >Símbolos como una caja con cajones</a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#pegando-texto" >Pegando texto</a></li>
    <ul>
    <li><a class="h3" href="#resumen-del-anillo-de-la-muerte" >Resumen del anillo de la muerte</a></li>
    <li><a class="h3" href="#la-variable-kill-ring-yank-pointer" >La variable <code>kill-ring-yank-pointer</code></a></li>
    <li><a class="h3" href="#ejercicios-con-yank-y-nthcdr" >Ejercicios con <code>yank</code> y <code>nthcdr</code></a></li>
    </ul>
  <li><a class="h2" href="#bucles-y-recursión" >Bucles y recursión</a></li>
    <ul>
    <li><a class="h3" href="#while" ><code>while</code></a></li>
      <ul>
      <li><a class="h4" href="#un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a></li>
      <li><a class="h4" href="#un-ejemplo:-imprimir-elementos-de-la-lista" >Un ejemplo: <code>imprimir-elementos-de-la-lista</code></a></li>
      <li><a class="h4" href="#un-bucle-con-un-contador-incremental" >Un bucle con un contador incremental</a></li>
        <ul>
        <li><a class="h5" href="#ejemplo-con-contador-incremental" >Ejemplo con contador incremental</a></li>
        <li><a class="h5" href="#las-partes-de-la-definición-de-función" >Las partes de la definición de función</a></li>
        <li><a class="h5" href="#juntando-la-definición-de-función" >Juntando la definición de función</a></li>
        </ul>
      <li><a class="h4" href="#bucle-con-contador-decreciente" >Bucle con contador decreciente</a></li>
        <ul>
        <li><a class="h5" href="#ejemplo-con-contador-decreciente" >Ejemplo con contador decreciente</a></li>
        <li><a class="h5" href="#las-partes-de-la-definición-de-función" >Las partes de la definición de función</a></li>
        <li><a class="h5" href="#juntando-la-definición-de-función" >Juntando la definición de función</a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#ahorra-tu-tiempo:-dolist-y-dotimes" >Ahorra tu tiempo: <code>dolist</code> y <code>dotimes</code></a></li>
      <ul>
      <li><a class="h4" href="#la-macro-dolist" >La macro <code>dolist</code></a></li>
      <li><a class="h4" href="#la-macro-dotimes" >La macro <code>dotimes</code></a></li>
      </ul>
    <li><a class="h3" href="#recursividad" >Recursividad</a></li>
      <ul>
      <li><a class="h4" href="#construyendo-robots:-extendiendo-la-metáfora" >Construyendo robots: Extendiendo la metáfora</a></li>
      <li><a class="h4" href="#las-partes-de-una-definición-recursiva" >Las partes de una definición recursiva</a></li>
      <li><a class="h4" href="#recursividad-con-una-lista" >Recursividad con una lista</a></li>
      <li><a class="h4" href="#recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</a></li>
        <ul>
        <li><a class="h5" href="#un-argumento-de-3-o-4" >Un argumento de 3 o 4</a></li>
        </ul>
      <li><a class="h4" href="#ejemplo-de-recursión-usando-cond" >Ejemplo de recursión usando <code>cond</code></a></li>
      <li><a class="h4" href="#patrones-recursivos" >Patrones recursivos</a></li>
        <ul>
        <li><a class="h5" href="#patrón-recursivo:-every" >Patrón recursivo: <em>every</em></a></li>
        <li><a class="h5" href="#patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></a></li>
        <li><a class="h5" href="#patrón-recursivo:-keep" >Patrón recursivo: <em>keep</em></a></li>
        </ul>
      <li><a class="h4" href="#recursividad-sin-deferencias" >Recursividad sin deferencias</a></li>
      <li><a class="h4" href="#solucion-sin-deferencia" >Solucion sin Deferencia</a></li>
      </ul>
    <li><a class="h3" href="#ejercicio-de-bucles" >Ejercicio de bucles</a></li>
    </ul>
  <li><a class="h2" href="#búsqueda-de-expresiones-regulares" >Búsqueda de expresiones regulares</a></li>
    <ul>
    <li><a class="h3" href="#la-expresión-regular-de-sentence-end" >La expresión regular de <code>sentence-end</code></a></li>
    <li><a class="h3" href="#la-función-re-search-forward" >La Función <code>re-search-forward</code></a></li>
    <li><a class="h3" href="#la-función-forward-sentence" >La Función <code>forward-sentence</code></a></li>
      <ul>
      <li><a class="h4" href="#los-bucles-while" >Los bucles <code>while</code></a></li>
      <li><a class="h4" href="#la-búsqueda-de-expresiones-regulares" >La búsqueda de expresiones regulares</a></li>
      </ul>
    <li><a class="h3" href="#forward-paragraph:-una-mina-de-oro-de-funciones" ><code>forward-paragraph</code>: una mina de oro de funciones</a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-let*" >La expresión <code>let*</code></a></li>
      <li><a class="h4" href="#el-bucle-while-hacia-adelante" >El bucle <code>while</code> hacia adelante</a></li>
      </ul>
    <li><a class="h3" href="#crea-tu-propio-fichero-tags" >Crea tu propio fichero <span class="file" >TAGS</span></a></li>
      <ul>
      <li><a class="h4" href="#construyendo-etiquetas-en-el-codigo-de-emacs" >Construyendo Etiquetas en el codigo de Emacs</a></li>
      </ul>
    <li><a class="h3" href="#repaso" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios-con-re-search-forward" >Ejercicios con <code>re-search-forward</code></a></li>
    </ul>
  <li><a class="h2" href="#conteo:-repetición-y-regexps" >Conteo: repetición y regexps</a></li>
    <ul>
    <li><a class="h3" href="#la-función-count-words-example" >La función <code>count-words-example</code></a></li>
      <ul>
      <li><a class="h4" href="#el-error-de-espacio-en-blanco-en-count-words-example" >El error de espacio en blanco en <code>count-words-example</code></a></li>
      </ul>
    <li><a class="h3" href="#contar-palabras-recursivamente" >Contar Palabras Recursivamente</a></li>
    <li><a class="h3" href="#ejercicio:-conteo-de-signos-de-puntuación" >Ejercicio: Conteo de signos de puntuación</a></li>
    </ul>
  <li><a class="h2" href="#contando-palabras-en-una-defun" >Contando palabras en una <code>defun</code></a></li>
    <ul>
    <li><a class="h3" href="#¿qué-contar?" >¿Qué contar?</a></li>
    <li><a class="h3" href="#¿qué-constituye-una-palabra-o-símbolo?" >¿Qué constituye una palabra o símbolo?</a></li>
    <li><a class="h3" href="#la-función-contar-palabras-en-definicion" >La función <code>contar-palabras-en-definicion</code></a></li>
    <li><a class="h3" href="#contar-varias-defuns-dentro-de-un-fichero" >Contar varias <code>defuns</code> dentro de un fichero</a></li>
    <li><a class="h3" href="#encontrar-un-fichero" >Encontrar un fichero</a></li>
    <li><a class="h3" href="#lista-de-longitudes-en-fichero-en-detalle" ><code>lista-de-longitudes-en-fichero</code> en detalle</a></li>
    <li><a class="h3" href="#contar-palabras-en-defuns-en-diferentes-ficheros" >Contar palabras en <code>defuns</code> en diferentes ficheros</a></li>
      <ul>
      <li><a class="h4" href="#la-función-append" >La función <code>append</code></a></li>
      </ul>
    <li><a class="h3" href="#contar-palabras-recursivamente-en-diferentes-ficheros" >Contar palabras recursivamente en diferentes ficheros</a></li>
    <li><a class="h3" href="#preparar-los-datos-para-visualizarlos-en-un-grafico" >Preparar los datos para visualizarlos en un grafico</a></li>
      <ul>
      <li><a class="h4" href="#ordenando-listas" >Ordenando listas</a></li>
      <li><a class="h4" href="#creando-una-lista-de-ficheros" >Creando una lista de ficheros</a></li>
      <li><a class="h4" href="#contando-definiciones-de-función" >Contando definiciones de función</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#preparar-un-grafico" >Preparar un grafico</a></li>
    <ul>
    <li><a class="h3" href="#la-función-imprimir-cuerpo-grafico" >La función <code>imprimir-cuerpo-grafico</code></a></li>
    <li><a class="h3" href="#la-función-imprimir-cuerpo-grafico-con-recursividad" >La función <code>imprimir-cuerpo-grafico-con-recursividad</code></a></li>
    <li><a class="h3" href="#necesidad-de-ejes-de-impresion" >Necesidad de Ejes de impresion</a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#tu-fichero-.emacs" >Tu fichero <span class="file" >.emacs</span></a></li>
    <ul>
    <li><a class="h3" href="#fichero-de-inicialización-site-wide" >Fichero de inicialización site-wide</a></li>
    <li><a class="h3" href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a></li>
    <li><a class="h3" href="#empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></a></li>
    <li><a class="h3" href="#modo-texto-y-auto-relleno" >Modo texto y auto relleno</a></li>
    <li><a class="h3" href="#alias-de-correo" >Alias de correo</a></li>
    <li><a class="h3" href="#indentar-modo-de-tabulaciones" >Indentar modo de tabulaciones</a></li>
    <li><a class="h3" href="#atajos-de-teclado" >Atajos de teclado</a></li>
    <li><a class="h3" href="#mapas-de-teclado" >Mapas de teclado</a></li>
    <li><a class="h3" href="#cargando-ficheros" >Cargando ficheros</a></li>
    <li><a class="h3" href="#autoloading" >Autoloading</a></li>
    <li><a class="h3" href="#una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></a></li>
    <li><a class="h3" href="#colores-x11" >Colores X11</a></li>
    <li><a class="h3" href="#configuraciones-misceláneas-para-un-fichero-.emacs" >Configuraciones misceláneas para un fichero <span class="file" >.emacs</span></a></li>
      <ul>
      <li><a class="h4" href="#arreglando-atajos-de-teclados" >Arreglando Atajos de Teclados</a></li>
      </ul>
    <li><a class="h3" href="#una-línea-modificada" >Una línea modificada</a></li>
    </ul>
  <li><a class="h2" href="#depurando" >Depurando</a></li>
    <ul>
    <li><a class="h3" href="#depurar" ><code>depurar</code></a></li>
    <li><a class="h3" href="#debug-on-entry" ><code>debug-on-entry</code></a></li>
    <li><a class="h3" href="#debug-on-quit-y-(debug)" ><code>debug-on-quit</code> y <code>(debug)</code></a></li>
    <li><a class="h3" href="#el-depurador-de-nivel-de-fuentes-edebug" >El depurador de nivel de fuentes <code>edebug</code></a></li>
    <li><a class="h3" href="#ejercicios-de-depuración" >Ejercicios de depuración</a></li>
    </ul>
  <li><a class="h2" href="#conclusión" >Conclusión</a></li>
    <ul>
    <li><a class="h3" href="#apéndice-a-la-función-the-the" >Apéndice A La función <code>the-the</code></a></li>
    <li><a class="h3" href="#apéndice-b-manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</a></li>
      <ul>
      <li><a class="h4" href="#la-función-current-kill" >La función <code>current-kill</code></a></li>
      <li><a class="h4" href="#pegar" ><code>pegar</code></a></li>
      <li><a class="h4" href="#yank-pop" ><code>yank-pop</code></a></li>
      <li><a class="h4" href="#el-fichero-ring.el" >El fichero <span class="file" >ring.el</span></a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#apéndice-c" >Apéndice C Un grafico con ejes etiquetados</a></li>
    <ul>
    <li><a class="h3" href="#la-varlist-print-graph" >La varlist <code>print-graph</code></a></li>
    <li><a class="h3" href="#la-función-print-y-axis" >La función <code>print-Y-axis</code></a></li>
      <ul>
      <li><a class="h4" href="#viaje-lateral:-calcula-un-resto" >Viaje lateral: Calcula un resto</a></li>
      <li><a class="h4" href="#construye-un-elemento-del-eje-y" >Construye un elemento del eje Y</a></li>
      <li><a class="h4" href="#crea-un-eje-de-la-columna-y" >Crea un eje de la columna Y</a></li>
      <li><a class="h4" href="#la-versión-no-demasiado-final-de-print-y-axis" >La versión no demasiado final de <code>print-Y-axis</code></a></li>
      </ul>
    <li><a class="h3" href="#la-función-print-x-axis" >La función <code>print-X-axis</code></a></li>
      <ul>
      <li><a class="h4" href="#eje-x-marca-tic" >Eje X marca tic</a></li>
      </ul>
    <li><a class="h3" href="#imprimiendo-el-grafico-completo" >Imprimiendo el grafico completo</a></li>
      <ul>
      <li><a class="h4" href="#testeando-print-graph" >Testeando <code>print-graph</code></a></li>
      <li><a class="h4" href="#creando-gráficas-de-números-de-palabras-y-símbolos" >Creando gráficas de números de palabras y símbolos</a></li>
      <li><a class="h4" href="#una-expresión-lambda:-anonimicidad-útil" >Una expresión <code>lambda</code>: Anonimicidad útil</a></li>
      </ul>
    <li><a class="h3" href="#la-función-mapcar" >La función <code>mapcar</code></a></li>
      <ul>
      <li><a class="h4" href="#otro-error-…-más-insidioso" >Otro error … más insidioso</a></li>
      <li><a class="h4" href="#el-gráfico-impreso" >El gráfico impreso</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#apéndice-d-software-libre-y-manuales-libres-por-richard-m.-stallman" >Apéndice D Software Libre y Manuales Libres (<b>por Richard M. Stallman</b>)</a></li>
  <li><a class="h2" href="#appendix-e-gnu-free-documentation-license" >Appendix E GNU Free Documentation License</a></li>
    <ul>
    <li><a class="h3" href="#0.-preamble" >0. PREAMBLE</a></li>
    <li><a class="h3" href="#1.-applicability-and-definitions" >1. APPLICABILITY AND DEFINITIONS</a></li>
    <li><a class="h3" href="#2.-verbatim-copying" >2. VERBATIM COPYING</a></li>
    <li><a class="h3" href="#3.-copying-in-quantity" >3. COPYING IN QUANTITY</a></li>
    <li><a class="h3" href="#4.-modifications" >4. MODIFICATIONS</a></li>
    <li><a class="h3" href="#5.-combining-documents" >5. COMBINING DOCUMENTS</a></li>
    <li><a class="h3" href="#6.-collections-of-documents" >6. COLLECTIONS OF DOCUMENTS</a></li>
    <li><a class="h3" href="#7.-aggregation-with-independent-works" >7. AGGREGATION WITH INDEPENDENT WORKS</a></li>
    <li><a class="h3" href="#8.-translation" >8. TRANSLATION</a></li>
    <li><a class="h3" href="#9.-termination" >9. TERMINATION</a></li>
    <li><a class="h3" href="#10.-future-revisions-of-this-license" >10. FUTURE REVISIONS OF THIS LICENSE</a></li>
    <li><a class="h3" href="#11.-relicensing" >11. RELICENSING</a></li>
    </ul>
  <li><a class="h2" href="#addendum:-how-to-use-this-license-for-your-documents" >ADDENDUM: How to use this License for your documents</a></li>
    <ul>
    <li><a class="h3" href="#acerca-del-autor" >Acerca del Autor</a></li>
    </ul>
  <li><a class="h2" href="#footnotes" >footnotes</a></li>
  </ul>
  </div>
</div>

<h1>Una introducción a la programación en Emacs Lisp</h1>
<div class="hBody-1" >
<p>Esto es una <em>Introducción a la Programación en Emacs Lisp</em>, para personas que no son programadoras.</p>
<p>Traducido desde la edición 3.10</p>
<p>Copyright ® 1990–1995, 1997, 2001–2013 Free Software Foundation, Inc.</p>
<p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; there being no Invariant Section, with the Front-Cover Texts being “A GNU Manual”, and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled “GNU Free Documentation License”.</p>
<p>(a) The FSF&#39;s Back-Cover Text is: “You have the freedom to copy and modify this GNU manual. Buying copies from the FSF supports it in developing GNU and promoting software freedom.”</p>
</div>
<h2 id="prefacio" >Prefacio</h2>
<div class="hBody-2" >
<p>La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje de programación llamado Emacs Lisp. El código escrito en este lenguaje de programación es el software––el conjunto de instrucciones––que le indican al ordenador qué hacer cuando se le dan comandos. Emacs está diseñado de forma que se puede escribir nuevo código en Emacs Lisp e instalarlo fácilmente como una extensión al editor.</p>
<p>(GNU Emacs se define muchas veces como un “editor extensible”, pero hace mucho más que proporcionar capacidad de edición. Es mejor referirse a Emacs como un “entorno de computación extensible”. Sin embargo, esta frase es un poco pretenciosa. Es más fácil referirse a Emacs simplemente como un editor. De hecho, cada cosa que se hace en Emacs––encontrar la fecha Maya y fases de la luna, simplificar polinomios, depurar código, administrar ficheros, leer cartas, escribir libros––todas estas actividades son maneras de editar en un sentido amplio de la palabra.)</p>
<p>Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un lenguaje de programación completo. Se puede usar Emacs Lisp del mismo modo que con cualquier otro lenguaje de programación.</p>
<p>Quizás quiera comprender la programación; quizás quiera extender Emacs; o quizás quiera llegar a ser un programador. Esta introducción a Emacs Lisp está diseñada para que empieces: para guiarte en el aprendizaje de los fundamentos de la programación y, lo que es más importante, para mostrarte como puedes aprender a ir mas más allá.</p>
</div>
<h3 id="sobre-la-lectura-de-este-texto" >Sobre la lectura de este texto</h3>
<div class="hBody-3" >
<p>A lo largo de este documento, verá pequeños programas de ejemplo que se pueden ejecutar dentro de Emacs. Si se lee este documento dentro de GNU Emacs, puede ejecutar los programas tal y como aparecen. (Esto es fácil de hacer y se explica cuando se presentan los ejemplos). Alternativamente, puede leer esta introducción como un libro impreso mientras se está sentando con un ordenador ejecutando Emacs. (Esto es lo que me gusta hacer; me gustan los libros impresos.) Si usted no se está ejecutando Emacs, todavía se puede leer este libro, pero en este caso, lo mejor es tratarlo como una novela, o como una guía de viaje a un país que aún no visitado: interesante, pero no es lo mismo que estar allí.</p>
<p>Gran parte de esta introducción se dedica a paseos guiados de código usado en GNU Emacs. Estos paseos están diseñados para dos propósitos: primero, familiarizarse con código real que funciona (código que se usa cada día); y, segundo, familiarizarse con cómo funciona Emacs. Es interesante ver cómo se implementa un entorno completamente operativo. También, espero que aprenda el hábito de navegar a través del código fuente. Puedes aprender mucho comparando código de otros con el propio y extraer nuevas ideas. Tener GNU Emacs es como tener la cueva del dragón de los tesoros.</p>
<p>Además de aprender sobre Emacs como editor y Emacs Lisp como lenguaje de programación, los ejemplos y visitas guiadas le darán una oportunidad para familiarizarse con Emacs como un entorno de programación Lisp. GNU Emacs soporta programación y provee herramientas que llegara a sentirse comodo usando, como <kbd>M-.</kbd> (el atajo que invoca el comando <code>find-tag</code>). También aprendera sobre búfers y otros objetos que forman parte del entorno. Aprender estas funcionalidades de Emacs es como aprender nuevas rutas alrededor de tu ciudad natal.</p>
<p>Finalmente, espero poder transmitir algunas habilidades para utilizar Emacs para aprender aspectos de programación que no conoces. Con frecuencia se puede usar Emacs para ayudarte a entender un rompecabezas o para encontrar la manera de hacer algo nuevo. Este auto-descubrimiento no es solo un placer, también es una ventaja.</p>
</div>
<h3 id="para-quien-está-escrito-esto" >Para quien está escrito esto</h3>
<div class="hBody-3" >
<p>Este texto está escrito como una introducción elemental para personas que no son programadoras. Si usted es un programador, es posible que no este satisfecho con este manual. La razón es que un programador puede tener que convertirse en experto leyendo manuales de referencia y este texto no está organizado como un manual de referencia.</p>
<p>Un programador experto que revisó este texto me dijo:</p>
<blockquote>
<p>Prefiero aprender desde manuales de referencia. Me “zambullo” en cada párrafo y “subo a tomar aire” entre párrafos.</p>
<p>Cuando llego al fin de un párrafo, asumo que este asunto está hecho, terminado, que sé todo lo que necesito (con la posible excepción del caso cuando el siguiente párrafo empiece a hablar de el con más detalle). Espero que un manual de referencia bien escrito no tenga mucha redundancia, y que tenga excelentes indicadores del (unico) lugar donde está la información que quiero.</p>
</blockquote>
<p>¡Esta introducción no está escrita para esta persona!</p>
<p>En primer lugar, intento decir cada cosa al menos tres veces: primero, para introducirlo; segundo, para mostrarlo en contexto; y tercero, para mostrarlo en un contexto diferente, o para revisarlo.</p>
<p>En segundo lugar, casi nunca pongo toda la información sobre un tema en un solo lugar, y mucho menos en un párrafo. A mi manera de pensar, eso impone una carga bastante pesada al lector. En vez de eso intento explicarte solo lo que se necesitas saber en ese momento. (Algunas veces incluyo una pequeña información extra, para que no haya sorpresas más tarde cuando la información adicional sea introducida formalmente.)</p>
<p>Cuando usted lee este texto, no espera aprender todo la primera vez. Frecuentemente, solo necesita hacer, por asi decirlo, un ‘reconocimiento’ con alguno de los articulos mencionados. Mi esperanza es haber estructurado el texto y dar suficientes pistas para indicar lo que es importante y concentrarse en ello.</p>
<p>Necesitaras “sumergirte” en algunos párrafos; no hay otro modo de leerlos. Pero he intentado reducir el número de esos párrafos. Este libro pretende ser como una colina accesible, mas que una montaña abrumadora.</p>
<p>Esta introducción a <em>Programación en Emacs Lisp</em> viene acompañada de un documento complementario. <em>El Manual de Referencia de GNU Emacs Lisp</em>. El manual de referencia tiene más detalles que esta introducción. En el manual de referencia, toda la información sobre un asunto está concentrada en un solo lugar. Usted debe recurrir a ella si es como el programador citado anteriormente. Y, por supuesto, después de haber leido esta <em>Introducción</em>, encontrara el <em>Manual de Referencia</em> util cuando este escribiendo sus propios programas.</p>
</div>
<h3 id="historia-de-lisp" >Historia de Lisp</h3>
<div class="hBody-3" >
<p>Lisp fué originariamente desarrollado a finales de los años 50 en el Instituto Tecnológico de Massachusetts para la investigacion en inteligencia artificial. El gran poder del lenguaje Lisp lo hace superior para otros propósitos también, como la escritura de comandos de edición y entornos integrados.</p>
<p>GNU Emacs Lisp está fuertemente inspirado en Maclisp, que fue escrito en el MIT en la decada de 1960. Está en cierto modo inspirado en Common Lisp, que se convirtio en un estándar en los 80. Sin embargo, Emacs Lisp es mucho más simple que Common Lisp. (La distribución estándar de Emacs contiene un fichero de extensiones opcional, <span class="file" >cl.el</span>, que añade muchas caracteristicas de Common Lisp a Emacs Lisp.)</p>
</div>
<h3 id="nota-para-principiantes" >Nota para principiantes</h3>
<div class="hBody-3" >
<p>Si usted no conoce GNU Emacs, todavia puede leer este documento provechosamente. Sin embargo, te recomiendo que aprendas Emacs, al menos aprender a moverse alrededor de la pantalla del ordenador. Uno puede aprender de manera autodidacta cómo usar Emacs con el tutorial incluido. Para usarlo, escriba <kbd>C-h t</kbd>. (Esto significa que debe presionar la tecla <kbd>CTRL</kbd> y la <kbd>h</kbd> al mismo tiempo, y luego presionar y soltar <kbd>t</kbd>).</p>
<p>Con frecuencia, también me refiero a uno de los comandos estándar de Emacs listando las teclas que se presionan para invocar el comando y, luego doi el nombre del comando entre paréntesis, de la siguiente manera: <kbd>M-C-\</kbd> (<code>indent-region</code>). Esto significa invocar el comando <code>indent-region</code> presionando <kbd>M-C-\</kbd>. (Puede, Si lo desea, cambiar las teclas que se presionan para invocar el comando; esto se denomina <dfn>rebinding</dfn>. Véa la Sección <a href="#mapas-de-teclado" >Mapas de teclado</a>.)  La abreviatura <kbd>M-C-\</kbd> significa que usted presiona la tecla <kbd>META</kbd>, <kbd>CTRL</kbd>, y <kbd>\</kbd> todo al mismo tiempo. (En muchos teclados modernos la tecla <kbd>META</kbd> es etiquetada con <kbd>ALT</kbd>.) Algunas veces una combinación como esta se llama <em>keychord</em>, puesto que es similar a tocar un acorde en un piano. Si el teclado no tiene una tecla <kbd>META</kbd>, en su lugar se usa la tecla <kbd>ESC</kbd> como prefijo. En este caso <kbd>M-C-\</kbd> significa que se presiona y libera <kbd>ESC</kbd> y luego presiona la tecla <kbd>CTRL</kbd> y la tecla <kbd>\</kbd> al mismo tiempo. Pero normalmente <kbd>M-C-\</kbd> significa presionar la tecla <kbd>CTRL</kbd> junto a la tecla que está marcada como <kbd>ALT</kbd> y, al mismo tiempo, presionar la tecla <kbd>\</kbd>.</p>
<p>Además de pulsar una sola combinación de teclas, se puede prefijar lo que se escribe con <kbd>C-u</kbd>, que es llamado el ‘argumento universal’. El atajo <kbd>C-u</kbd> pasa a ser un argumento para el comando subsiguiente. Asi, para indentar una región de texto plano a 6 espacios, se marca la región, y entonces presione <kbd>C-u 6 M-C-\</kbd>. (Si no se especifica un número, Emacs pasa el número 4 al comando o ejecuta el comando de forma diferente). Véa la Sección <a href="info:emacs#Arguments" >Argumentos Numéricos</a> en <em>El Manual de GNU Emacs</em>.</p>
<p>Si se está leyendo esto en Info usando GNU Emacs, puedes avanzar a través de todo este documento presionando la barra de espacio, <kbd>SPC</kbd>. (Para aprender acerca de Info, presiona <kbd>C-h i</kbd> y luego selecciona Info.)</p>
<p>Una nota sobre terminología: cuando uso la palabra Lisp sola, con frecuencia me estoy refiriendo a los diversos dialectos de Lisp en general, pero cuando hablo de Emacs Lisp, me estoy refiriendo a GNU Emacs Lisp en particular.</p>
</div>
<h3 id="agradecimientos" >Agradecimientos</h3>
<div class="hBody-3" >
<p>Estoy agradecido a todos los que me ayudaron con este libro. Mi agradecimiento especial a Jim Blandy, Noah Friedman, Jim Kingdon, Roland McGrath, Frank Ritter, Randy Smith, Richard M. Stallman, y Melissa Weisshaus. Gracias también a Philip Johnson y David Stampe por su ánimo paciente. Mis errores son míos.</p>
<div class="right" >
<p>Robert J. Chassell <a href="mailto:bob@gnu.org" >mailto:bob@gnu.org</a></p>
</div>
</div>
<h2 id="procesamiento-de-listas" >Procesamiento de listas</h2>
<div class="hBody-2" >
<p>Para el ojo inexperto, Lisp es un lenguaje de programación extraño. En código Lisp hay paréntesis por todas partes. Algunas personas incluso afirman que el nombre signfica ‘Lots of Isolated Silly Parentheses’ (‘Montones de Paréntesis Aislados Estúpidos’). Pero la protesta no tiene fundamento. Lisp significa LISt Processing, y el lenguaje de programación maneja <em>listas</em> (y listas de listas) poniéndolas entre paréntesis. Los paréntesis marcan los límites de la lista. Algunas veces una lista va precedida por un apóstrofe simple o una marca de cita, <samp>&#39;</samp><span class="note" ><sup><a href="#1" >1</a></sup></span> Las listas son el fundamento de Lisp.</p>
</div>
<h3 id="listas-lisp" >Listas Lisp</h3>
<div class="hBody-3" >
<p>En Lisp, una lista tiene el siguiente aspecto: <code>&#39;(rosa violeta margarita tulipan)</code>. Esta lista es precedida por una comilla. Bien, podría estar escrita de la siguiende manera, que se parece mas al tipo de lista con la que se está familiarizado:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span>
  <span class="nv">violeta</span>
  <span class="nv">margarita</span>
  <span class="nv">tulipan</span><span class="p">)</span>
</code></pre>
<p>Los elementos de esta lista son los nombres de 4 flores diferentes, separados por espacios en blanco y rodeados de paréntesis, como flores en un campo con un muro de piedras alrededor de ellas.</p>
<p>Las listas pueden también tener números dentro, como en esta lista: <code>(+ 2 2)</code>. Esta lista tiene un signo más, <samp>+</samp>, seguido por dos <samp>2</samp>, cada uno separado por espacios en blanco.</p>
<p>En Lisp, tanto datos como programas se representan de la misma manera; es decir, son a la vez listas de palabras, números, u otras listas, separadas por espacios en blanco y rodeadas de paréntesis. (Puesto que un programa son datos, un programa puede servir fácilmente como datos para otros; esta es un caracteristica muy poderosa de Lisp.)  (A proposito, estas dos marcas de paréntesis <em>no</em> son listas Lisp, porque contienen <samp>;</samp> y <samp>.</samp> como marcas de puntuación.)</p>
<p>Aquí hay otra lista, esta vez con una lista dentro:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">tiene</span> <span class="p">(</span><span class="nv">una</span> <span class="nv">lista</span> <span class="nv">dentro</span> <span class="nv">de</span> <span class="nv">ella</span><span class="p">))</span>
</code></pre>
<p>Los componentes de esta lista son las palabras <samp>esta</samp>, <samp>lista</samp>, <samp>tiene</samp>, y la lista <samp>(una lista dentro de ella)</samp>. La lista interior se construye con las palabras <samp>una</samp>, <samp>lista</samp>, <samp>dentro</samp>, <samp>de</samp>, <samp>ella</samp>.</p>
</div>
<h4 id="átomos-lisp" >Átomos Lisp</h4>
<div class="hBody-4" >
<p>En Lisp, lo que hemos estado llamando palabras son en realidad <dfn>átomos</dfn>. Este término proviene del significado historico de la palabra átomo, que significa ‘indivisible’. En lo que a Lisp concierne, las palabras que hemos estado usando en las listas no se pueden dividir en partes mas pequeñas, sin perder su significado dentro del programa; lo mismo ocurre con números y símbolos de un caracterer como <samp>+</samp>. Por otro lado, a diferencia de un átomo antiguo, una lista puede dividirse en partes. Vea la seccion <a href="#car,-cdr,-cons:-funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</a>.</p>
<p>En una lista, los átomos se separan unos de otros por espacios en blanco. Pueden ir pegados a un paréntesis.</p>
<p>Técnicamente hablando, una lista en Lisp consiste en paréntesis que rodean átomos separados por espacios en blanco o alrededor de otras lista o alrededor de ambos átomos y otras listas. Una lista puede tener solo un átomo o no tener absolutamente nada en ella. Una lista con nada dentro se ve así: <code>()</code>, y se llama <dfn>lista vacía</dfn>. A diferencia de cualquier otra cosa, una lista vacía es tanto un átomo, como una lista al mismo tiempo.</p>
<p>La representación impresa de átomos y listas se llaman <dfn>expresiones simbólicas</dfn> o, más concisamente, <dfn>expresiones-s</dfn>. La palabra <dfn>expresión</dfn> por sí misma puede referir o bien a la representación impresa, o al átomo o a la lista tal como se encuentra internamente en el ordenador. Con frecuencia, las personas usan el término <dfn>expresión</dfn> indiscriminadamente. (También, en muchos textos, la palabra <dfn>forma</dfn> se usa como un sinónimo de expresión.)</p>
<p>Por cierto, los átomos que componen nuestro universo fueron nombrados asi cuando se pensaba que eran indivisibles; pero se ha encontrado que los átomos fisicos no son indivisibles. Las partes pueden dividir un átomo o puede fisionarse en 2 partes de igual tamaño. Los átomos físicos se nombraron prematuramente, antes de que su verdadera naturaleza fuese encontrada. En Lisp, ciertos tipos de átomos, como un array, pueden ser separados en partes; pero el mecanismo de hacer esto es diferente del mecanismo para dividir una lista. En lo que se refiere a las operaciones de lista, los átomos de una lista son indivisibles.</p>
<p>Al igual que en el español, el significado de las letras que componen un átomo Lisp difieren del significado de las letras compuestas como una palabra. Por ejemplo, la expresión <samp>ay</samp>, es completamente diferente de las dos palabras <samp>a</samp>, e <samp>y</samp>.</p>
<p>Hay muchos tipos de átomos en la naturaleza, pero solo unos pocos en Lisp: por ejemplo, los <dfn>números</dfn>, como 37, 511, o 1729, y los <dfn>símbolos</dfn>, como <samp>+</samp>, <samp>foo</samp>, o <samp>forward-line</samp>. Las palabras que hemos listado en los ejemplos anteriores son todos símbolos. En una conversacion cotidiana de Lisp, la palabra “átomo” no se usa con frecuencia, porque los programadores normalmente intentan ser más específicos acerca del tipo de átomo que están tratando. La programación Lisp es mayormente sobre símbolos (y algunas veces números) dentro de listas. (De ese modo, tres palabras rodeadas de paréntesis son una lista apropiada en Lisp, ya que consiste de átomos, que en este caso son símbolos, separados por espacios en blanco y encerrados entre paréntesis, sin ninguna puntuacion ajena a Lisp.)</p>
<p>El texto entre comillas––incluso oraciones o párrafos––son también un átomo. Aquí hay un ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">incluye</span> <span class="s">&#34;texto entre comillas.&#34;</span><span class="p">)</span>
</code></pre>
<p>En Lisp, todo el texto citado incluyendo la marca de puntuación y los espacios en blanco son un solo átomo. Este tipo de átomo es llamado <dfn>string</dfn> (<em>cadena</em>, por ‘cadena de caracteres’) y es el tipo de cosa que se utiliza para los mensajes que un ordenador puede imprimir para que un humano lea. Las cadenas son un tipo de átomo diferente a los números, o símbolos y se utilizan de manera diferente.</p>
</div>
<h4 id="espacios-en-blanco-en-listas" >Espacios en blanco en listas</h4>
<div class="hBody-4" >
<p>La cantidad de espacios en blanco en una lista no importa. Desde el punto de vista del lenguaje Lisp,</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span>
   <span class="nv">se</span> <span class="nv">ve</span> <span class="nv">asi</span><span class="p">)</span>
</code></pre>
<p>es exactamente lo mismo que esto:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">se</span> <span class="nv">ve</span> <span class="nv">asi</span><span class="p">)</span>
</code></pre>
<p>Ambos ejemplos muestran que en Lisp es la misma lista, la lista hecha de los símbolos <samp>esta</samp>, <samp>lista</samp>, <samp>se</samp>, <samp>ve</samp>, y <samp>asi</samp> en ese orden.</p>
<p>Los espacios en blanco adicionales y los saltos de línea están diseñados para crear una lista más legible para los humanos. Cuando Lisp lee la expresión, se deshace de los espacios en blanco extra (pero necesita tener al menos un espacio entre los átomos para distinguirlos.)</p>
<p>Aunque parezca raro, los ejemplos que hemos visto cubren casi todas las listas en Lisp. Cualquier otra lista en Lisp se ve más o menos igual a uno de estos ejemplos, excepto que la lista puede ser más larga y compleja. En resumen, una lista está entre paréntesis, una cadena está entre comillas, un símbolo se parece a una palabra, y un número a un número. (Para ciertas situaciones, es pueden utilizar corchetes, puntos y otros caracteres especiales; sin embargo; iremos bastante lejos sin ellos.)</p>
</div>
<h4 id="gnu-emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</h4>
<div class="hBody-4" >
<p>Cuando se escribe una expresión Lisp en GNU Emacs usando el modo de Interacción Lisp o el modo Emacs Lisp, están disponibles varios comandos para formatear la expresión Lisp, de modo que sea fácil de leer. Por ejemplo, presionando la tecla <kbd>TAB</kbd> automáticamente se indenta la línea donde se encuetra el cursor a la cantidad correcta. Un comando para indentar apropiadamente el código en una región está asociado a <kbd>M-C-\</kbd>. La indentación está diseñada de modo que se pueda ver qué elementos percecen a cada lista––los elementos de una sublista están más indentados que los elementos de la lista adjunta.</p>
<p>Además, cuando escribes un paréntesis de cierre, Emacs mueve momentáneamente el cursor hacia el parentesis de apertura correspondiente, para que puedas ver cual es. Esto es muy útil, ya que cada lista que se escribe en Lisp debe tener sus paréntesis emparejados con sus paréntesis de apertura. (Vea la Seccion <a href="info:emacs#Major-Modes" >Modos Mayores</a> en <em>El Manual de GNU Emacs</em>, para más información sobre los modos de Emacs.)</p>
</div>
<h3 id="ejecutar-un-programa" >Ejecutar un programa</h3>
<div class="hBody-3" >
<p>Una lista en Lisp––cualquier lista––es un programa listo para ejecutarse. Si lo ejecutas (lo que la jerga Lisp llama <dfn>evaluar</dfn>), el ordenador hará una de tres cosas: nada excepto devolverte la lista misma; enviar un mensaje de error; o, tomar el primer símbolo en la lista como un comando para hacer alguna cosa. (¡Normalmente, por supuesto, es la última de estas tres cosas lo que realmente quieres!).</p>
<p>El apóstrofe, <code>&#39;</code>, que pongo delante de algunas de las listas de ejemplo en las secciones anteriores se llama <dfn>quote</dfn> (citar); cuando precede a una lista, le dice a Lisp que no haga nada con la lista, ademas de tomarla tal como está escrita. Pero si no hay una cita precediendo la lista, el primer elemento de la lista es especial: es un comando que el ordenador debe obedecer. (En Lisp, estos comandos se llaman <em>funciones</em>.) La lista <code>(+ 2 2)</code> montrada a continuación no tiene una cita delante de ella, por lo que Lisp comprende que <code>+</code> es una instrucción para hacer alguna cosa con el resto de la lista: sumar los números que siguen.</p>
<p>Si estás leyendo esto dentro de GNU Emacs, aquí está como puedes evaluar tal lista: coloca tu cursor justo después del paréntesis derecho de la siguiente lista y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>Verás que el número <code>4</code> aparece en el área eco. (En la jerga, lo que acabas de hacer es “evaluar la lista.” El área de eco es la línea en la parte inferior de la pantalla que muestra o hace “eco” del texto.) Ahora intenta lo mismo con una lista citada: posiciona el cursor justo después de la siguiente lista y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esto</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nv">citada</span><span class="p">)</span>
</code></pre>
<p>Verás aparecer <code>(esto es una lista citada)</code> en el área eco.</p>
<p>En ambos casos, lo que estás haciendo es dar un comando al programa dentro de GNU Emacs llamado <dfn>intérprete Lisp</dfn>––dando al intérprete un comando para evaluar la expresión. El nombre del intérprete Lisp viene de la palabra para la tarea hecha por un humano que viene con el significado de una expresión––quien lo “interpreta”.</p>
<p>También se puede evaluar un átomo que no es parte de una lista––uno que no está rodeado por paréntesis; de nuevo, el intérprete Lisp traduce desde la expresión legible humanamente al lenguaje del ordenador. Pero antes de discutir esto (vea la Seccion <a href="#variables" >Variables</a>), vamos a discutir lo que el intérprete de Lisp hace cuando cometes un el error.</p>
</div>
<h3 id="generar-un-mensaje-de-error" >Generar un mensaje de error</h3>
<div class="hBody-3" >
<p>No te preocupes si generas un mensaje de error de manera accidental, ahora daremos un comando al intérprete de Lisp que genara un mensaje de error. Esta es una accion inofensiva; y de hecho, a menudo se intenta generar mensajes de error de manera intencional. Una vez se comprende la jerga, los mensajes de error pueden ser informativos. En vez de ser llamados mensajes de “error”, deberían ser llamados mensajes de “ayuda”. Son como letreros para un viajero en un país extraño; descifrarlos puede ser duro, pero una vez comprendidos, pueden señalar el camino.</p>
<p>El mensaje de error es generado por un depurador de codigo incorporado dentro de GNU Emacs. Vamos a ‘entrar al depurador’. Se sale del depurador pulsando <code>q</code>.</p>
<p>Lo que vamos a hacer es evaluar una lista que no tiene cita y ni un comando con significado como su primer elemento. Aquí hay una lista casi exactamente igual a la que acabamos de usar, pero sin la cita al inicio. Coloque el cursor a la derecha donde esta finaliza y presione <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">esto</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nf">sin</span> <span class="nv">cita</span><span class="p">)</span>
</code></pre>
<p>Se abrirá una ventana <span class="file" >*Backtrace*</span> y se verá lo siguiente:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function esto)
  (esto es una lista sin cita)
  eval((esto es una lista sin cita) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Tu cursor estará en esta ventana (es posible que tenga que esperar unos pocos segundos antes de que sea visible). Para salir del depurador y de su ventana, presione:</p>
<div class="example-block" >
<pre class="example" >q
</pre>
</div>
<p>Por favor, ahora presiona <kbd><b>q</b></kbd>, para que puedas comprobar que se puede salir del depurador. A continuacion, presiona {C-x C-e} una vez mas para re-entrar.</p>
<p>Basandones en lo que ya sabemos, casi podemos leer este mensaje de error.</p>
<p>Lees el búfer <span class="file" >*Backtrace*</span> desde abajo hacia arriba; te dice lo que hizo Emacs. Cuando se presionaste <kbd>C-x C-e</kbd>, se hace una llamada interactiva al comando <code>eval-last-sexp</code>. <code>eval</code> es una abreviatura para ‘evaluar’ y <code>sexp</code> es una abreviatura para ‘expresión simbólica’. El comando significa ‘evalúa la última expresión simbólica’, que es la expresión inmediatamente anterior al cursor.</p>
<p>Cada linea sober esta cuenta lo que el intérprete Lisp evaluo después. La acción más reciente está en la parte superior. El búfer se llama <span class="file" >*Backtrace*</span> ya que permite realizar un seguimiento de Emacs hacia atrás.</p>
<p>En la parte superior del búfer <span class="file" >*Backtrace*</span>, verá la línea:</p>
<div class="example-block" >
<pre class="example" >Debugger entered--Lisp error: (void-function esto)
</pre>
</div>
<p>El intérprete Lisp intentó evaluar el primer átomo de la lista, la palabra <samp>esto</samp>. Esta es la acción que ha generado el mensaje de error <samp>void-function esto</samp>.</p>
<p>El mensaje contiene las palabras <samp>void-function</samp> y <samp>esto</samp>.</p>
<p>La palabra <samp>function</samp> fué mencionada antes. Es una palabra muy importante. Para nuestros propósitos, podemos definirla diciendo que una <dfn>función</dfn> (<em>function</em>) es un conjunto de instrucciones para decirle al ordenador que haga alguna cosa.</p>
<p>Ahora podemos empezar a entender el mensaje de error: <samp>void-function esto</samp>. La función (es decir, la palabra <samp>esto</samp>) no tiene una definición de ningun conjunto de instrucciones que el ordenador pueda realizar.</p>
<p>La palabra ligeramente extraña, <samp>void-function</samp>, está diseñada para cubrir la forma en que Emacs Lisp lo implementa, que es cuando un símbolo no tiene una definición de función adjunta, el sitio que contiene la instruccion esta ‘vacio’ (<samp>void</samp>).</p>
<p>Por otro lado, ya que fuimos capaces de sumar 2 más 2 de manera exitosa, evaluando <code>(+ 2 2)</code>, se puede inferir que el símbolo <code>+</code> debe tener un conjunto de instrucciones que el ordenador ejecuta y estas instrucciones deben ser para sumar los números despues del <code>+</code>.</p>
<p>Es posible evitar que Emacs entre en el depurador en casos como este. No se explicará cómo hacer esto aquí, pero se mencionará como se ve el resultado, porque puede que te encuentres con una situación similar si hay un error en algún código de Emacs que estes usando. En tales casos, solo verá una línea de mensaje de error; aparecer en el área eco con el siguente aspecto:</p>
<div class="example-block" >
<pre class="example" >Symbol&#39;s function definition is void: esto
</pre>
</div>
<p>El mensaje desaparece tan pronto se presione una tecla, aunque sólo sea para mover el cursor.</p>
<p>Conocemos el significado de la palabra <samp>Symbol</samp>. Se refiere al primer átomo de la lista, la palabra <samp>este</samp>. La palabra <samp>function</samp> se refiere a las instrucciones que indican al ordenador que hacer. (Técnicamente, el símbolo le indica al ordenador donde encontrar las instrucciones, pero esta es una complicación que podemos ignorar por el momento.)</p>
<p>El mensaje de error es comprensible: <samp>La definición del símbolo está vacía: este</samp>. El símbolo (que es, la palabra <samp>este</samp>) carece de instrucciones para que el ordenador lo lleve a cabo.</p>
</div>
<h3 id="nombres-de-símbolos-y-definiciones-de-funciones" >Nombres de símbolos y definiciones de funciones</h3>
<div class="hBody-3" >
<p>Se puede articular otra característica de Lisp basada en lo que hemos discutido hasta ahora––una característica importante: un símbolo, como <code>+</code>, no es en sí mismo el conjunto de instrucciones que el ordenador lleva a cabo. En su lugar, el símbolo se utiliza, quizás temporalmente, como una forma de localizar la definición o conjunto de instrucciones. Lo que vemos es el nombre con el cual se pueden encontrar las instrucciones. Los nombres de las personas funcionan de la misma manera. Por ejemplo puede referirse a mi como <samp>Bob</samp>; sin embargo, no soy las letras <samp>B</samp>, <samp>o</samp>, <samp>b</samp> pero soy, o fuí, conscientemente asociado con una forma de vida particular. El nombre no soy yo, pero puede ser usado para referirse a mi.</p>
<p>En Lisp, un conjunto de instrucciones puede ligarse a varios nombres. Por ejemplo, las instrucciones para sumar números pueden ligarse al símbolo <code>mas</code> asi como a el símbolo <code>+</code> (y se encuentran en algunos dialectos de Lisp). Entre los humanos, puede referirse a <samp>Robert</samp> tan bien como <samp>Bob</samp> y con otras palabras también.</p>
<p>Por otra parte, un símbolo solo puede estar ligado con una función a la vez. De lo contrario, el ordenador estaría confundido acerca de qué definición usar. Si este fuera el caso entre las gente, solo una persona en el mundo podría llamarse <samp>Bob</samp>. Sin embargo, la definición de función a la que el nombre hace referencia puede cambiarse fácilmente. (Vea la Sección <a href="#instalar-una-definición-de-función" >Instalar una Definición de Función</a>.)</p>
<p>Ya que Emacs Lisp es extenso, se acostumbra nombrar los símbolos de una manera que identifique la parte de Emacs a la que pertenece la función. En consecuencia, todos los nombres de funciones relacionadas con Texinfo comienzan con <samp>texinfo-</samp> y aquellas relacionadas con la lectura de correo empiezan con <samp>rmail-</samp>.</p>
</div>
<h3 id="el-intérprete-lisp" >El intérprete Lisp</h3>
<div class="hBody-3" >
<p>Basado en lo que hemos visto, ahora podemos empezar a entender lo que hace el intéprete Lisp cuando le ordenamos que evalue una lista. Primero, examina si hay un símbolo cita antes de la lista; si lo hay, el intérprete solo nos da la lista. Por otra parte, si no hay cita, el intéprete mira si el primer elemento de la lista tiene una definición de función. De lo contrario, el intérprete imprime un mensaje de error.</p>
<p>Así es como funciona Lisp. Simple. Hay complicaciones añadidas a las que llegaremos en un minuto, pero estos son los fundamentos. Claro está, para escribir programas Lisp, se necesita saber como escribir definiciones de función y vincularlas a nombres, y como hacer esto sin confundirnos a nosotros mismos o al ordenador.</p>
<p>Ahora, una primera complicación. Además de las listas, el intérprete Lisp puede evaluar un símbolo no citado y sin paréntesis en torno a el. El intérprete intentará determinar el valor del símbolo como una <dfn>variable</dfn>. Esta situación se descrita en el apartado de las variables. (Vea la Seccion <a href="#variables" >Variables</a>.)</p>
<p>La segunda complicación ocurre debido a que algunas funciones son inusuales y no funcionan de la manera habitual. Estas son llamadas <dfn>formas especiales</dfn> (<em>special forms</em>). Son usadas para trabajos especiales, como definir una función, y no son muchas de ellas. En los siguientes capítulos, se presentaran varias de las formas especiales más importantes.</p>
<p>La tercera y ultima complicación es la siguiente: si la función que el intérprete Lisp está examinando no es una forma especial, y si es parte de una lista, el intérprete Lisp mira si la lista tiene una lista dentro de ella. Si hay una lista interna, el intérprete Lisp primero calcula lo qué debe hacer con la lista interna, y luego trabaja en la lista externa. Si hay otra lista embebida dentro de la lista interna, trabaja en esta primero, y así. Siempre se trabaja en la lista mas interna primero. El interprete trabaja primero en la lista más interana, para evaluar el resultado de esta lista. El resultado puede ser usado por la expresión entre paréntesis.</p>
<p>Por lo demas, el intérprete trabaja de izquierda a derecha, de una expresión a la siguiente.</p>
</div>
<h4 id="codigo-compilado" >Codigo Compilado</h4>
<div class="hBody-4" >
<p>Otro aspecto de la interpretación: el intérprete Lisp es capaz de interpretar dos tipos de entidades: código legible humanamente, en el que nos centraremos exclusivamente, y código especialmente procesado, llamado <dfn>compilado</dfn>, que no es humanamente legible. El código máquina compilado se ejecuta más rápido que el código humanamente legible.</p>
<p>Tu puedes transformar código legible por humanos en código compilado ejecutando uno de los comandos de compilación como <code>byte-compile-file</code>. El código compilado se almacena normalmente en un fichero que finaliza con una extensión <span class="file" >.elc</span> en vez de una extensión <span class="file" >.el</span>. Verás ambos tipos de ficheros en el directorio <span class="file" >emacs/lisp</span>; los ficheros para leer estos tinen la extensión <span class="file" >.el</span>.</p>
<p>Como una cuestión práctica, para hacer la mayoría de las cosas como personalizar o extender Emacs, no necesitas compilar codigo; y no comentare el asunto aquí. Vea la Seccion <a href="info:emacs#Byte-Compilation" >Código Compilado</a> en <em>El Manual de Referencia de GNU Emacs</em>, para una descripción completa de la compilacion de código.</p>
</div>
<h3 id="evaluación" >Evaluación</h3>
<div class="hBody-3" >
<p>Cuando el intérprete Lisp trabaja en una expresión, el término para la actividad es llamada <dfn>evaluación</dfn>. Decimos que el intérprete ‘evalúa la expresión’. Yo he usado este término varias veces antes. La palabra proviene de su uso en el lenguaje cotidiano, ‘para determinar el valor o la cantidad de; para estimar’ segun el <em>Webster&#39;s New Collegiate Dictionary</em>.</p>
<p>Después de evaluar una expresión, lo mas probable es que el intérprete Lisp <dfn>devuelva</dfn> el valor que el ordenador produce al ejecutar las instrucciones que encuentra en la definición de la función, o quizás se de por vencido con en esa función y produzca un mensaje de error. (El intérprete también puede quedarse colgado, por así decirlo, a una función diferente o puede intentar repetir continuamente lo que está haciendo por siempre  en lo que se llama un ‘bucle infinito’. Estas acciones son menos comunes; y podemos ignorarlas). Con mayor frecuencia, el intérprete devuelve un valor.</p>
<p>Al mismo tiempo que el intérprete devuelve un valor, también puede realizar cualquier otra cosa, como mover un cursor o copiar un fichero; este otro tipo de acción se denomina <dfn>efecto secundario</dfn>. Acciones que los humanos pensamos que son importantes, como imprimir resultados, con frecuencia son, “efectos secundarios” del intérprete Lisp. La jerga puede sonar peculiar, pero resulta que es bastante fácil aprender a utilizar los efectos secundarios.</p>
<p>En resumen, la evaluacion de una expresión simbólica normalmente causa que el intérprete devuelva un valor y tal vez lleve a cabo un efecto secundario; o al menos produca un error.</p>
</div>
<h4 id="evaluación-de-listas-internas" >Evaluación de listas internas</h4>
<div class="hBody-4" >
<p>Si la evaluación se aplica a una lista que está dentro de otra lista, la lista externa puede usar el valor devuelto por la primer evaluación como información cuando se evalua la lista externa. Esto explica por qué las expresiones internas se evaluan primero: los valores devueltos son usados por las expresiones externas.</p>
<p>Podemos investigar este proceso evaluando otro ejemplo de sumas. Coloca tu cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<p>El número 8 aparecerá en el área de eco.</p>
<p>Lo que ocurre es que el intérprete Lisp primero evalúa la expresión interna, <code>(+ 3 3)</code>, para lo cual se devuelve el valor 6; luego evalúa la expresión externa como si fuera escrita <code>(+ 2 6)</code>, que devuelve el valor 8. Puesto que no hay más expresiones adjuntas a evaluar el intérprete imprime este valor en el área de eco.</p>
<p>Ahora es fácil comprender el nombre del comando invocado por el atajo <kbd>C-x C-e</kbd>: el nombre es <code>eval-last-sexp</code>. Las letras <code>sexp</code> son una abreviatura para ‘expresión simbólica’, y <code>eval</code> es una abreviatura para ‘evaluar’ (<em>evaluate</em>). El comando significa ‘evaluar la última expresión simbólica’.</p>
<p>Como un experimento, puedes intentar evaluar la expresión poniendo el cursor al principio de la siguiente línea inmediatamente después de la expresión, o dentro de la expresión.</p>
<p>Aquí hay otra copia de la expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<p>Si colocas el cursor al principio de la línea en blanco que sigue inmediatamente a la expresión y presionas <kbd>C-x C-e</kbd>, aún se obtendrá el valor 8 impreso en el área eco. Ahora coloca el cursor dentro de la expresión. Si lo pones justo después del penúltimo paréntesis (de modo que parezca estar sobre el último paréntesis), ¡obtendrá un 6 impreso en el área de eco! Esto es porque el comando evalúa la expresión <code>(+ 3 3)</code>.</p>
<p>Ahora coloca el cursor inmediatamente después de un número. Presiona <kbd>C-x C-e</kbd> y obtendras el número en sí. En Lisp, si evalúas un número, obtienes el número en sí––así es cómo los números difieren de los símbolos. Si se evalúa una lista que inicia con un símbolo como <code>+</code>, se optiene un valor devuelto que es el resultado del ordenador tras ejecutar las instrucciones que aparecen en la definición de la función ligada a ese nombre. Si se evalua un símbolo por sí mismo, sucede algo diferente, como veremos en la siguiente sección.</p>
</div>
<h3 id="variables" >Variables</h3>
<div class="hBody-3" >
<p>En Emacs Lisp, un símbolo puede estar ligado a un valor como a una definición de función. Las dos son diferentes. La definición de función es un conjunto de instrucciones que el ordenador ejecuta. Por otro lado, un valor, es algo, como un número o un nombre, que puede variar (es por ello, que tal símbolo se llama variable). El valor de un símbolo puede ser cualquier expresión en Lisp, por ejemplo un símbolo, número, lista, o cadena. Un símbolo que tiene un valor con frecuencia se llama <dfn>variable</dfn>.</p>
<p>Un símbolo puede tanto una definición de función como un valor asociado a el al mismo tiempo. O puede tener solo uno u otro. Los dos son independientes. Esto es algo similar a la forma en que el nombre Cambridge puede referirse a la ciudad en Massachusetts y tener alguna información ligada al nombre, por ejemplo, un “gran centro de programación”.</p>
<p>Otra forma de pensar en esto es imaginar un símbolo como un mueble con cajones. La definición de función se pone en un cajón, el valor en otro, y asi sucesivamente. Lo que se pone en el cajón que contiene el valor se puede cambiar sin afectar los contenidos del cajón que almacena la definición de función, y viceversa.</p>
<p>La variable <code>fill-column</code> ilustra un símbolo con un valor adjunto: en cada buffer de GNU Emacs, este símbolo se establece en algún valor, normalmente 72 o 70, pero algunas veces en algún otro valor. Para encontrar el valor de este símbolo, evalúalo por sí mismo. Si estás leyendo esto dentro de GNU Emacs, puedes hacerlo poniendo el cursor después del símbolo y pulsar <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="nv">fill-column</span>
</code></pre>
<p>Después de presionar <kbd>C-x C-e</kbd>, Emacs imprimió el número 72 en mi área de eco. Este es el valor que he establecido para <code>fill-column</code> mientras escribo esto. Puede ser diferente en tu búfer. Observa que el valor devuelto como una variable se imprime exactamente de la misma forma que el valor devuelto por una función tras ejecutar sus instrucciones. Desde el punto de vista del intérprete Lisp, un valor devuelto es un valor devuelto. La clase de expresion de la que proviene deja de importar una vez que se conoce el valor.</p>
<p>Un símbolo puede tener cualquier valor ligado a él o, siendo tecnicos, se puede <dfn>enlazar</dfn> la variable a un valor: a un número, por ejemplo 72; a una cadena, <code>&#34;como esta&#34;</code>; a una lista, como <code>(abeto pino roble)</code>; podemos incluso asociar una variable a una definición de función.</p>
<p>Un símbolo puede vincularse a un valor de varias maneras. Vea la Sección <a href="#configurando-el-valor-de-una-variable" >Configurando el valor de una variable</a>, para obtener información sobre como hacerlo.</p>
</div>
<h4 id="mensaje-de-error-de-un-símbolo-sin-una-función" >Mensaje de error de un símbolo sin una función</h4>
<div class="hBody-4" >
<p>Cuando evaluamos <code>fill-column</code> para encontrar su valor como una variable, no pusimos paréntesis alrededor de la palabra. Esto se debe a que no pretendiamos usarla como un nombre de función.</p>
<p>Si <code>fill-column</code> fuese el primer o único elemento de una lista, el intérprete Lisp intentaría encontrar la definición de función adjunta. Pero <code>fill-column</code> no tiene una definición de función. Trata de evaluar esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">fill-column</span><span class="p">)</span>
</code></pre>
<p>Se creará un buffer <span class="file" >*Backtrace*</span> que dice:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>(Recuerda, para salir del depurador y hacer que la ventana del depurador desaparezca, presiona <kbd>q</kbd> en el buffer <span class="file" >*Backtrace*</span>.)</p>
</div>
<h4 id="mensaje-de-error-de-un-símbolo-sin-un-valor" >Mensaje de error de un símbolo sin un valor</h4>
<div class="hBody-4" >
<p>Si intenta evaluar un símbolo que no tiene un valor asociado, recibirá un mensaje de error. Esto se puede ver experimentando con nuestra suma 2 más 2. En la siguiente expresión, pon el cursor justo después del <code>+</code>, antes del primer número 2, presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>En GNU Emacs 22, se creará un buffer <span class="file" >*Backtrace*</span> que dice:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+ nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>(De nuevo, puedes salir del depurador pulsando <kbd>q</kbd> en el búfer <span class="file" >*Backtrace*</span>.)</p>
<p>Esta traza inversa es diferente del primer mensaje de error que vimos, que decia, <samp>Debugger entered--Lisp error: (void-function esto)</samp>. En este caso, la función no tiene una valor como variable; mientras en el otro mensaje de error, la función (la palabra ‘esto’) no tuvo una definición.</p>
<p>En este experimento con el <code>+</code>, lo que hicimos fué hacer que el intérprete Lisp evalúe el <code>+</code> y busque el valor de la variable en lugar de la definición de la función. Hicimos esto colocando el cursor justo después del símbolo en lugar de ponerlo al final de los parentesis que cierran la lista como hicimos antes. Como consecuencia, el intérprete Lisp evaluó la expresión-s anterior, que en este caso fué el <code>+</code> en sí.</p>
<p>Ya que <code>+</code> no tiene un valor asociado, solo la definición de función, el mensaje de error informaba que el valor del símbolo como una variable estaba vacío.</p>
</div>
<h3 id="argumentos" >Argumentos</h3>
<div class="hBody-3" >
<p>Para ver cómo la información se pasa a las funciones, veamos de nuevo nuestro viejo recurso, la suma de dos más dos. En Lisp, esto se escribe de la siguiente manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>Si evalúas esta expresión, el número 4 aparecerá en el área de eco. Lo que el intérprete de Lisp hace es sumar los números despues del <code>+</code>.</p>
<p>Los números sumados por <code>+</code> se llaman <dfn>argumentos</dfn> de la función <code>+</code>. Estos números son la información que se da o <dfn>pasa</dfn> a la función.</p>
<p>La palabra ‘argumento’ proviene de la forma en que se usa en matemáticas y no se refiere a una disputa entre 2 personas, En su lugar, se refiere a la información entregada a la función, en este caso, al <code>+</code>. En Lisp, los argumentos de una función son los átomos o listas que siguen a la función. Los valores devueltos por la evaluación de estos átomos o listas se transfieren a la función. Funciones diferentes requieren diferentes números de argumentos; algunas funciones no requieren ninguno en absoluto.<span class="note" ><sup><a href="#2" >2</a></sup></span></p>
</div>
<h4 id="tipos-de-datos-de-los-argumentos" >Tipos de datos de los argumentos</h4>
<div class="hBody-4" >
<p>El tipo de dato que deben transmitirse a una función dependen de que tipo de información se utilice. Los argumentos de una función como <code>+</code> deben tener valores númericos, ya que <code>+</code> suma números. Otras funciones utilizan diferentes tipos de datos para sus argumentos.</p>
<p>Por ejemplo, la función <code>concat</code> concatena o une dos o más cadenas de texto para producir una cadena. Los argumentos son cadenas. Concatenar las cadenas de caracteres <code>abc</code>, <code>def</code> produce una cadena <code>abcdef</code>. Esto puede verse evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;abc&#34;</span> <span class="s">&#34;def&#34;</span><span class="p">)</span>
</code></pre>
<p>El valor producido al evaluar esta expresión es <code>&#34;abcdef&#34;</code>.</p>
<p>Una función como <code>substring</code> utiliza una cadena y numeros como argumentos. La función devuelve una parte de la cadena, una subcadena del primer argumento. Esta función toma tres argumentos. Su primer argumento es la cadena de caracteres, el segundo y tercer argumento son números que indican el principio y el fin de la subcadena. Los números son un conteo del número de caracteres (incluyendo espacios y puntuaciones) desde el principio de la cadena.</p>
<p>Por ejemplo, si evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">substring</span> <span class="s">&#34;El rápido zorro marrón saltó.&#34;</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">)</span>
</code></pre>
<p>Verá aparecer <code>&#34;zorro&#34;</code> en el área de eco. Los argumentos son la cadena y los dos números.</p>
<p>Tenga en cuenta que la cadena pasada a <code>substring</code> es un solo átomo a pesar de estar compuesto de varias palabras separadas por espacios. Lisp considera todo entre las dos comillas como parte de la cadena, incluyendo los espacios. Se puede pensar en la función <code>substring</code> como una especie de ‘acelerador de particulas’ ya que toma un átomo de otro modo indivisible y extrae una parte. Sin embargo, <code>substring</code> solo es capaz de extraer una subcadena de un argumento que es una cadena, no de otro tipo de átomo por ejemplo un número o símbolo.</p>
</div>
<h4 id="un-argumento-como-el-valor-de-una-variable-o-lista" >Un argumento como el valor de una variable o lista</h4>
<div class="hBody-4" >
<p>Un argumento puede ser un símbolo que devuelve un valor cuando se evalua. Por ejemplo, evaluar el símbolo <code>fill-column</code> en si, devuelve un número. Este número se puede utilizar en una suma.</p>
<p>Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="nv">fill-column</span><span class="p">)</span>
</code></pre>
<p>El valor será dos, mas el número que se obtiene al evaluar solamente <code>fill-column</code>. En mí caso, es 74, porque mi valor de <code>fill-column</code> es 72.</p>
<p>Como acabamos de ver, un argumento puede ser un símbolo que devuelve un valor cuando se evalúa. Además, un argumento puede ser una lista que devuelve un valor cuando se evalúa. Por ejemplo, en la siguiente expresión, los argumentos de la función <code>concat</code> son las cadenas <code>&#34;Los &#34;</code> y <code>&#34; zorros rojos.&#34;</code> y la lista <code>(number-to-string (+ 2 fill-column))</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;Los &#34;</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="nv">fill-column</span><span class="p">))</span> <span class="s">&#34; zorros rojos.&#34;</span><span class="p">)</span>
</code></pre>
<p>Si evaluas esta expresión––y si, como con mi Emacs, <code>fill-column</code> se evalúa a 72––aparecerá <code>&#34;Los 74 zorros rojos.&#34;</code> en el área de eco. (Ten en cuenta que debes poner espacios después de la palabra <samp>Los</samp> y antes de la palabra <samp>zorros</samp> que aparece en la cadena final. La función <code>number-to-string</code> convierte el entero que devuelve la función suma a una cadena. <code>number-to-string</code> también se conoce como <code>int-to-string</code>.)</p>
</div>
<h4 id="número-variable-de-argumentos" >Número variable de argumentos</h4>
<div class="hBody-4" >
<p>Algunas funciones, como <code>concat</code>, <code>+</code>, o <code>*</code>, toman cualquier número de argumentos. (<code>*</code> es el símbolo para la multiplicacion.) Esto puede verse evaluando cada una de las siguientes expresiones de la forma habitual.</p>
<p>En el primer conjunto, las funciones no tienen argumentos:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">+</span><span class="p">)</span>
</span><span class="out" >0
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">*</span><span class="p">)</span>
</span><span class="out" >1
</span></code></pre>
<p>En este conjunto, las funciones tienen un argumento cada una:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">+</span> <span class="mi">3</span><span class="p">)</span>
</span><span class="out" >3
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">*</span> <span class="mi">3</span><span class="p">)</span>
</span><span class="out" >3
</span></code></pre>
<p>En este conjunto, las funciones tienen tres argumentos cada una:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">+</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="out" >12
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">*</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="out" >60
</span></code></pre>
</div>
<h4 id="usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</h4>
<div class="hBody-4" >
<p>Cuando a una función se le pasa un argumento del tipo incorrecto, el interpréte Lisp genera un mensaje de error. Por ejemplo, la función <code>+</code> espera que los valores de sus argumentos sean números. Como un experimento podemos pasar el símbolo citado <code>hola</code> en lugar de un número. Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="ss">&#39;hola</span><span class="p">)</span>
</code></pre>
<p>Al hacer esto se generará un mensaje de error. Lo qué ha ocurrido es que <code>+</code> ha intentado sumar el 2 al valor devuelto por <code>&#39;hola</code>, pero el valor devuelto por <code>&#39;hola</code> es el símbolo <code>hola</code>, no un número. Solo los números se pueden sumar. Por tanto <code>+</code> no pudo llevar a cabo su suma.</p>
<p>Se creará e ingresara a un búfer <span class="file" >*Backtrace*</span> que diga:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p hola)
  +(2 hola)
  eval((+ 2 (quote hola)) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Como de costumbre, el mensaje de error intenta ser útil y tiene sentido después de aprender cómo leerlo.<span class="note" ><sup><a href="#3" >3</a></sup></span></p>
<p>La primer parte del mensaje de error es sencilla; dice <samp>wrong type argument</samp> (tipo de argumento incorrecto). A continuación viene la misteriosa jerga tecnica <samp>number-or-marker-p</samp>. Esta palabra está intentando decirte qué tipo de argumento espera <code>+</code>.</p>
<p>El símbolo <code>number-or-marker-p</code> dice que el intérprete Lisp está intentando determinar si la información presentada (el valor del argumento) es un número o una marca (un objeto especial que representa una posición de buffer). Lo que hace es probar si se le estan dando numeros a sumar a <code>+</code>. También prueba si el argumento es algo llamado marcador, que es una caracteristica específica de Emacs Lisp. (En Emacs, las ubicaciones en un búfer se registran como marcadores. Cuando se establece la marca con el comando <kbd>C-@</kbd> o <kbd>C-SPC</kbd>, su posición se guarda como un marcador. La marca se puede consider un número––el número de caracteres es la ubicacion desde el comienzo del búfer.)  En Emacs Lisp, <code>+</code> se puede utilizar para sumar el valor numérico de los marcadores como números.</p>
<p>La <samp>p</samp> en <code>number-or-marker-p</code> es la encarnación de una práctica iniciada en los primeros días de la programación Lisp. La <samp>p</samp> significa ‘predicado’. En la jerga usada por los primeros investigadores de Lisp, un predicado se refiere a una función para determinar si alguna propiedad es verdadera o falsa. Entonces la <samp>p</samp> nos dice que <code>number-or-marker-p</code> es el nombre de una función que determina si el argumento dado es un número o una marca. Otros símbolos Lisp que finalizan en <samp>p</samp> incluyen <code>zerop</code>, una función que comprueba si su argumento tiene el valor de cero, y <code>listp</code>, una función que comprueba si su argumento es una lista.</p>
<p>Finalmente, la última parte del mensaje de error es el símbolo <code>hola</code>. Este es el valor del argumento que se paso a <code>+</code>. Si a la suma se le hubiese pasado el tipo de objeto correcto, el valor habría sido un número, como 37, en lugar de un símbolo como <code>hola</code>. Pero entonces no habrías obtenido el mensaje de error.</p>
</div>
<h4 id="la-función-message" >La función <code>message</code></h4>
<div class="hBody-4" >
<p>Al igual que <code>+</code>, la función <code>message</code> toma un número variable de argumentos. Se utiliza para enviar mensajes al usuario y es tan útil que vamos la describiremos aqui.</p>
<p>Se imprime un mensaje en el área de eco. Por ejemplo, puede imprimir un mensaje en su área de eco evaluando la siguiente lista:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Este mensaje aparece en el área de eco!&#34;</span><span class="p">)</span>
</code></pre>
<p>Toda la cadena entre comillas dobles es un unico argumento y se imprime <i>en su totalidad</i>. (Note que en este ejemplo, el mensaje en sí aparece en el área de eco entre comillas dobles; esto se debe a que ves el valor devuelto por la función <code>message</code>. En la mayoría de programas que escribiras, el texto se imprimira en el área de eco como un efecto secundario de <code>message</code>, sin las comillas. Vea la Sección <a href="#un-multiply-by-seven-interactivo" >Un <code>multiply-by-seven</code> interactivo</a> en detalle, para un ejemplo de esto.)</p>
<p>Sin embargo, si hay un <samp>%s</samp> en la cadena de caracteres citada, la función <code>message</code> no imprime el <samp>%s</samp> como tal, si no que busca el siguente argumento a continuacion de la cadena. Evalúa el segundo argumento e imprime el valor en la ubicación de la cadena donde está el <samp>%s</samp>.</p>
<p>Puede ver esto colocando el cursor después de la siguiente expresión y presionar <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El nombre de este búfer es: %s.&#34;</span> <span class="p">(</span><span class="nf">buffer-name</span><span class="p">))</span>
</code></pre>
<p>En Info, <code>&#34;El nombre de este búfer es: *info*.&#34;</code> aparecerá en el área de eco. La función <code>buffer-name</code> devuelve el nombre del búfer como una cadena, que la función <code>message</code> inserta en lugar de <code>%s</code>.</p>
<p>Para imprimir un valor como un entero, utiliza <samp>%d</samp> de la misma forma que <samp>%s</samp>. Por ejemplo, para imprimir un mensaje en el área de eco que indique el valor de <code>fill-column</code>, evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El valor de fill-column es %d.&#34;</span> <span class="nv">fill-column</span><span class="p">)</span>
</code></pre>
<p>En mi sistema, cuando evalúo esta lista, <code>&#34;El valor de fill-column es 72&#34;</code> aparece en mi área de eco<span class="note" ><sup><a href="#4" >4</a></sup></span>.</p>
<p>Si hay más de un <samp>%s</samp> en la cadena citada, el valor del primer argumento después de la cadena citada se imprime en la posición del primer <samp>%s</samp> y el valor del segundo argumento se imprime en la posición del segundo <samp>%s</samp>, y así sucesivamente.</p>
<p>Por ejemplo, si evalúa lo siguiente,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Hay %d %s en la oficina!&#34;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">fill-column</span> <span class="mi">14</span><span class="p">)</span> <span class="s">&#34;elefantes rosas&#34;</span><span class="p">)</span>
</code></pre>
<p>Un mensaje un poco caprichoso aparecerán en el área de eco. En mi sistema dice <code>&#34;¿Hay 58 elefantes rosas en la oficina!&#34;</code></p>
<p>Se evalúa la expresión <code>(- fill-column 14)</code> y el número resultante se inserta en lugar del <samp>%d</samp>; y la cadena entre comillas dobles, <code>&#34;elefantes rosas&#34;</code>, se trata como un argumento unico y se inserta en lugar del <samp>%s</samp>. (Es decir, una cadena entre comillas dobles se evalúa así misma, como un número.)</p>
<p>Por último, aquí está un ejemplo algo complejo que no solo ilustra el cálculo de un número, también muestra como se puede usar una expresión dentro de una expresión para generar el texto que sustituira el <samp>%s</samp>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Él vió %d %s&#34;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">fill-column</span> <span class="mi">36</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;rojos &#34;</span>
                 <span class="p">(</span><span class="nf">substring</span>
                  <span class="s">&#34;Los rápidos zorros marrones saltaron.&#34;</span> <span class="mi">12</span> <span class="mi">18</span><span class="p">)</span>
                 <span class="s">&#34; saltando.&#34;</span><span class="p">))</span>
</code></pre>
<p>En este ejemplo, <code>message</code> tiene tres argumentos: la cadena, <code>&#34;Él vió %d %s&#34;</code>, la expresión, <code>(- fill-column 32)</code>, y la expresion que comienza con la función <code>concat</code>. El valor resultante de la evaluación de <code>(- fill-column 32)</code> se inserta en lugar del <samp>%d</samp>; y el valor devuelto por la expresión que inicia con <code>concat</code> se inserta en lugar del <samp>%s</samp>.</p>
<p>Cuando <code>fill-column</code> es 70 y evaluas la expresión, aparecera el mensaje <code>&#34;Él vió 38 rojos zorros saltando.&#34;</code> en tu área de eco.</p>
</div>
<h3 id="configurando-el-valor-de-una-variable" >Configurando el valor de una variable</h3>
<div class="hBody-3" >
<p>Hay varias formas de asignar un valor a una variable. Una de ellas es utilizar la función <code>set</code> o la función <code>setq</code>. Otra forma es utilizar <code>let</code> (Vea la Seccion <a href="#let" ><code>let</code></a>). (La jerga para este proceso es <dfn>ligar</dfn> (<em>bind</em>) una variable a un valor.)</p>
<p>Las siguientes secciones no solo describen cómo operan <code>set</code> y <code>setq</code>, también ilustran como se pasan los argumentos.</p>
</div>
<h4 id="usando-set" >Usando <code>set</code></h4>
<div class="hBody-4" >
<p>Para establecer el valor del símbolo <code>flores</code> a la lista <code>&#39;(rosa violeta margarita tulipan)</code>, evalúa la siguiente expresión colocando el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set</span> <span class="ss">&#39;flores</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>La lista <code>(rosa violeta margarita tulipan)</code> aparecerá en el área de eco. Esto es la que <em>devuelve</em> la función <code>set</code>. Como efecto secundario, el símbolo <code>flores</code> esta ligado a la lista; es decir, el símbolo <code>flores</code>, puede verse como una variable, que entrega la lista como su valor. (Por cierto, este proceso, ilustra como un efecto secundario al intérprete Lisp, estableciendo el valor, puede ser el principal efecto que nos interesa a los humanos. Esto se debe a que cada función Lisp debe devolver un valor si no obtiene un error, pero solo tendrá un efecto secundario si está diseñada para tener uno.)</p>
<p>Después de evaluar la expresión <code>set</code>, se puede evaluar el símbolo <code>flores</code> y ha de devolver el valor que acaba de establecer. Aquí está el símbolo. Coloca el cursor al final de este y presiona <kbd>C-x C-e</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="nv">flores</span>
</code></pre>
<p>Al evalúar <code>flores</code>, aparece la lista <code>(rosa violeta margarita tulipan)</code> en el área de eco.</p>
<p>Por cierto, si se evalúa <code>&#39;flores</code>, la variable con una cita frente a ella, lo que verá en el área de eco es el símbolo en sí mismo, <code>flores</code>. Aquí está el símbolo citado, asi que puedes intentarlo:</p>
<pre class="code" ><code class="chroma" ><span class="ss">&#39;flores</span>
</code></pre>
<p>Tenga en cuenta también, que cuando se utiliza <code>set</code>, es necesario citar ambos argumentos para <code>set</code>, a menos que los quiera evaluar. Puesto que no queremos evaluar, ni la variable <code>flores</code>, ni la lista <code>(rosa violeta margarita tulipan)</code>, ambos se citan. (Cuando se utiliza <code>set</code> sin citar su primer argumento, el primer argumento se evalúa antes de realizar cualquier otra cosa. Si hizo esto y <code>flores</code> no tenía ya un valor, otendria un mensaje de error con el <samp>Valor de símbolo como variable esta vacío</samp>; por otro lado, si <code>flores</code> regreso un valor después de ser evaluado, <code>set</code> intentaría establecer el valor que fue devuelto. Hay situaciones donde esto es justo lo que la función a de hacer, pero estas situaciones son poco frecuentes.)</p>
</div>
<h4 id="usando-setq" >Usando <code>setq</code></h4>
<div class="hBody-4" >
<p>Como una cuestión práctica, casi siempre se cita el primer argumento de <code>set</code>. La combinación de <code>set</code> y un primer argumento citado es tan común que tiene nombre propio: la forma especial <code>setq</code>. Esta forma especial es similar a <code>set</code> excepto que el primer argumento es citado automáticamente, por lo que no necesita escribir la marca de cita. También, para mayor comodidad, <code>setq</code> permite asignar varias variables diferentes a diferentes valores, todo en una sola expresión.</p>
<p>Para establecer el valor de la variable <code>carnívoros</code> a la lista <code>&#39;(leon tigre leopardo)</code> usando <code>setq</code>, se utiliza la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">carnivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">))</span>
</code></pre>
<p>Esto es exactamente igual que usar <code>set</code> excepto que el primer argumento es citado automáticamente por <code>setq</code>. (La <samp>q</samp> en <code>setq</code> significa <code>quote</code> (<em>cita</em>).)</p>
<p>Con <code>set</code>, la expresión que se vería es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set</span> <span class="ss">&#39;carnivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">))</span>
</code></pre>
<p>Además, <code>setq</code> se puede utilizar para asignar diferentes valores a diferentes variables. El primer argumento se une al valor del segundo argumento, el tercer argumento se une a al valor del cuarto argumento, y así sucesivamente. Por ejemplo, podría utilizar lo siguiente para asignar una lista de árboles al símbolo <code>arboles</code> y una lista de herbívoros al símbolo <code>herbivoros</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">arboles</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
      <span class="nv">herbivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">))</span>
</code></pre>
<p>(La expresión podría también haber estado en una sola línea, pero podría no caber en una página; y a los humanos les resulta más fácil leer listas con un formato agradable.)</p>
<p>Aunque he estado usando el término ‘asignar’, hay otra forma de pensar respecto a el funcionamiento de <code>set</code> y <code>setq</code>; y consiste en decir que <code>set</code> y <code>setq</code> crean un símbolo que <em>apunta</em> a la lista. Esta ultima forma de pensar es muy común y en los proximos capítulos encontraremos por lo menos un símbolo con un ‘puntero’ como parte de su nombre. El nombre se elige porque el símbolo tiene un valor, específicamente una lista, unida a el; o, expresado de otra manera, el símbolo se fija para “apuntar” a la lista.</p>
</div>
<h4 id="conteo" >Conteo</h4>
<div class="hBody-4" >
<p>He aquí un ejemplo que muestra cómo utilizar <code>setq</code> en un contador. Es posible usar esto para contar cuantas veces una parte de un programa se repite. En primer lugar establesca una variable a cero; luego sume uno al número cada vez que el programa se repita. Para ello, se necesita una variable que sirva como un contador, y dos expresiones: una expresión <code>setq</code> inicial que asigna la variable contador a cero; y una segunda expresión <code>setq</code> que incrementa el contador cada vez se evalue.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="mi">0</span><span class="p">)</span>                <span class="c1">; Llamemos a esto el inicializador.</span>

<span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">contador</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">; Este es el incremento.</span>

<span class="nv">contador</span>                         <span class="c1">; Este es el contador.</span>
</code></pre>
<p>(El texto que sigue al <samp>;</samp> son los comentarios. Vea la Seccion <a href="#cambiar-una-definición-de-función" >Cambiar una definición de función</a>.)</p>
<p>Si evalúas la primera de estas expresiones, el inicializador, <code>(setq contador 0)</code>, y luego evalúas la tercera expresión, <code>contador</code>, el número <code>0</code> aparecerá en el área de eco. Si a continuación se evalúa la segunda expresión, el incremento, <code>(setq contador (+ contador 1))</code>, el contador tendrá el valor 1. Así que si evalúas de nuevo <code>contador</code>, el número <code>1</code> aparecerá en el área de eco. Cada vez que se evalúa la segunda expresión, el valor del contador se incrementara.</p>
<p>Al evalúar el incremento, <code>(setq contador (+ contador 1))</code>, el intérprete Lisp evalúa en primer lugar la lista interna; esta es la suma. Para evaluar esta lista, se debe evaluar la variable <code>contador</code> y el número <code>1</code>. Cuando evalúa la variable <code>contador</code>, recibe su valor actual. Se pasa este valor y el número <code>1</code> a <code>+</code> que los suma. La suma se devuelve como el valor de la list interior y pasa a <code>setq</code> que establece la variable <code>contador</code> a este nuevo valor. Por lo tanto, el valor de la variable <code>contador</code>, cambia.</p>
</div>
<h3 id="resumen" >Resumen</h3>
<div class="hBody-3" >
<p>Aprender Lisp es como subir una colina en la que la primera parte es la mas empinada. Ahora has subido la parte más difícil; lo que queda se vuelve más fácil a medida que avanzas hacia adelante.</p>
<p>En resumen,</p>
<ul>
<li>
<p>Los programas Lisp se componen de expresiones, que son listas o átomos individuales.</p>
</li>
<li>
<p>La listas se componen de cero o más átomos o listas internas, separadas por espacios en blanco y rodeadas por paréntesis. Una lista puede estar vacía.</p>
</li>
<li>
<p>Los átomos son símbolos de varios caracteres, como <code>forward-paragraph</code>, símbolos de un solo caracter como <code>+</code>, cadenas de caracteres entre comillas dobles, o números.</p>
</li>
<li>
<p>Un número se evalúa a sí mismo.</p>
</li>
<li>
<p>Una cadena entre comillas dobles también se evalúa a sí misma.</p>
</li>
<li>
<p>Cuando se evalúa un símbolo a sí mismo, se devuelve su valor.</p>
</li>
<li>
<p>Cuando se evalúa una lista, el intérprete Lisp mira el primer símbolo en la lista y luego la definición de función asociada a ese símbolo. A continuación se ejecutan las instrucciones en la definición de la función.</p>
</li>
<li>
<p>Una marca de cita, <code>&#39;</code>, le indica al intérprete Lisp que devuelva la siguiente expresión tal como esta escrita, y no la evalúa como lo haria si la cita no estuviera alli.</p>
</li>
<li>
<p>Los argumentos son la información que se pasa a una función. Los argumentos de una función se calculan evaluando el resto de los elementos de la lista de los cuales la función es el primer elemento.</p>
</li>
<li>
<p>Una función siempre devuelve un valor cuando se evalúa (a menos que obtenga un error); además, también se puede llevar a cabo alguna acción llamada “efecto secundario”. En muchos casos, el propósito principal de una función es crear un efecto secundario.</p>
</li>
</ul>
</div>
<h3 id="ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<p>Unos pocos ejercicios simples:</p>
<ul>
<li>
<p>Generar un mensaje de error evaluando un símbolo apropiado que no este entre paréntesis.</p>
</li>
<li>
<p>Generar un mensaje de error evaluando un símbolo apropiado situado entre paréntesis.</p>
</li>
<li>
<p>Crear un contador que se incrementa en dos en lugar de uno.</p>
</li>
<li>
<p>Escribe una expresión que imprima un mensaje en el área de eco cuando se evalue.</p>
</li>
</ul>
</div>
<h2 id="practicando-la-evaluación" >Practicando la Evaluación</h2>
<div class="hBody-2" >
<p>Antes de aprender como escribir una definición de función en Emacs Lisp, es útil pasar un poco de tiempo evaluando varias expresiones que ya han sido escritas. Estas expresiones serán listas con funciones como su primer (y con frecuencia único) elemento. Dado que algunas de las funciones asociadas con búfers son a la vez simples e interesantes, empezaremos por ellas. En esta sección, vamos a evaluar algunas. En otra sección, estudiaremos el código de varias otras funciones relacionadas con búfers, para ver la forma cómo fueron escritas.</p>
<p><i>Siempre que proporciona un comando de edición</i> a Emacs Lisp, como el comando para mover el cursor o para desplazar por la pantalla, <i>se está evaluando una expresión</i>, cuyo primer elemento es una función. <i>Así es cómo funciona Emacs</i>.</p>
<p>Al presionar las teclas, haces que el interprete Lisp evalue una expresion y asi es como obtienes tus resultados. Incluso escribir texto plano implica evalúar una función de Emacs Lisp, en este caso, se utiliza <code>self-insert-command</code>, que simplemente inserta el caracter que escribiste. Las funciones que se evalúan presionando atajos de teclado se llaman funciones <dfn>interactivas</dfn>, o <dfn>comandos</dfn>; la forma de hacer que una funcion sea interactiva se ilustrara en el capítulo sobre cómo escribir definiciones de funciones. Vea la Seccion <a href="#crear-una-función-interactiva" >Crear una Función Interactiva</a>.</p>
<p>Además de presionar comandos de teclado, hemos visto una segunda manera de evaluar una expresión: colocar el cursor después de una lista y presionar <kbd>C-x C-e</kbd>. Esto es lo que haremos en el resto de esta sección. Hay otras maneras de evaluar una expresión; que serán descritas a medida que llegemos a ellas.</p>
<p>Ademas de utilizarce para prácticar la evaluación, las funciones que se muestran en las siguientes secciones son importantes por derecho propio. Un estudio de estas funciones deja claro la distinción entre búfers y ficheros, cómo cambiar a un búfer, y como determinar una ubicación dentro de el.</p>
</div>
<h3 id="nombres-de-búfer" >Nombres de búfer</h3>
<div class="hBody-3" >
<p>Las dos funciones, <code>buffer-name</code> y <code>buffer-file-name</code>, muestran la diferencia entre un fichero y un búfer. Cuando se evalúa la siguiente expresión, <code>(buffer-name)</code>, el nombre del buffer aparece en el area eco. Al evaluar <code>(buffer-file-name)</code>, el nombre del fichero al que se relaciona el búfer aparece en el área de eco. Por lo general, el nombre devuelto por <code>(buffer-name)</code> es el mismo que el nombre del fichero al que hace referencia, y el nombre devuelto por <code>(buffer-file-name)</code> es la ruta completa del fichero.</p>
<p>Un fichero y un búfer son dos entidades diferentes. Un fichero es la información grabada de manera permanente en el ordenador (a menos que se elimine). Un búfer, por otro lado, es la información dentro de Emacs que desaparecerá al final de la sesión de edición (o cuando matas el búfer). Por lo general, un búfer contiene información que se ha copiado desde un fichero; decimos que el búfer está <dfn>visitando</dfn> ese fichero. Esta copia es en la que se trabaja y modifica. Los cambios al búfer no cambian el fichero, hasta ser guardados. Al guardar el búfer, el búfer se copia en el fichero y por lo tanto se guarda de forma permanente.</p>
<p>Si está leyendo esto dentro de GNU Emacs, puede evaluar cada una de las siguientes expresiones colocando el cursor después de estas y pulsando <kbd>C-x C-e</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">buffer-name</span><span class="p">)</span>

<span class="p">(</span><span class="nf">buffer-file-name</span><span class="p">)</span>
</code></pre>
<p>Cuando hago esto en el búfer <span class="file" >*info*</span>, el valor devuelto evaluando <code>(buffer-name)</code> es <span class="file" >&#34;*info*&#34;</span>, y el valor devuelto evaluando <code>(buffer-file-name)</code> es <span class="file" >nil</span>.</p>
<p>Por otro lado, mientras escribo este documento, el valor devuelto por la evaluación de <code>(buffer-name)</code> es <code>&#34;introduction.texinfo&#34;</code>, y el valor devuelto por la evaluación de <code>(buffer-file-name)</code> es <code>&#34;/gnu/work/intro/introduction.texinfo&#34;</code>.</p>
<p>El primero es el nombre del búfer y el segundo es el nombre del fichero. En Info, el nombre del búfer es <span class="file" >&#34;*info*&#34;</span>. Info no apunta a ningún fichero, por lo que el resultado de evaluar <code>(buffer-file-name)</code>] es <span class="file" >nil</span>. El símbolo <code>nil</code> proviene del latin, significa ‘nada’; en este caso, significa que el búfer no está asociado con ningun fichero. (En Lisp, <code>nil</code> también se utiliza con el significado de ‘falso’ y es sinómino para la lista vacía, <code>()</code>.)</p>
<p>Al escribir esto, el nombre de mi búfer es <code>&#34;introduction.texinfo&#34;</code>. El nombre del fichero al que apunta es <code>&#34;/gnu/work/intro/introduction.texinfo&#34;</code>.</p>
<p>(En las expresiones, los paréntesis le indican al intérprete Lisp que trate a <code>buffer-name</code> y <code>buffer-file-name</code> como funciones; sin los paréntesis, el intérprete intentaría evaluar los símbolos como variables. Vea la Sección <a href="#variables" >Variables</a>.)</p>
<p>A pesar de la distinción entre ficheros y búfers, con frecuencia encontrara personas referirse a un fichero cuando quieren un búfer y viceversa. De hecho, la mayoría de la gente dice, “Estoy editando un fichero”, en lugar de decir, “Estoy editando un búfer que pronto voy a guardar en un fichero”. Esto casi siempre queda claro a partir del contexto de lo que la gente dice. No obstante, Al tratar con programas de ordenador, es importante mantener la distinción en mente, ya que el ordenador no es tan inteligente como una persona.</p>
<p>Por cierto, la palabra ‘búfer’, viene del significado de la palabra como un cojín que amortigua la fuerza de una colisión. En los primeros ordenadores, un búfer amortiguaba la interacción entre los ficheros y la unidad central de procesamiento del ordenador. Los tambores o cintas que contenian un fichero y la unidad de procesamiento eran piezas de equipamiento muy diferentes entre si, que trabajaban a sus propias velocidades, por rafagas. El búfer hizo posible que ambos trabajaran juntos de manera efectiva. Con el tiempo, el búfer pasó de ser un intermediario, un lugar de almacenamiento temporal, a ser el lugar donde se realiza el trabajo. Esta transformación se parace bastante a la de un pequeño puerto que se convierte en una gran ciudad: una vez fué simplemente el lugar donde la carga era depositada temporalmente antes de ser cargada en los barcos; despues se convirtio en un centro comercial y cultural por derecho propio.</p>
<p>No todos los búfers están asociados con ficheros. Por ejemplo, el búfer <span class="file" >*scratch*</span> no visita ningun fichero. Del mismo modo, un búfer <span class="file" >*Help*</span> no está asociado a ningun fichero.</p>
<p>En los viejos tiempos, cuando se carecia de un fichero <span class="file" >~/.emacs</span> y se iniciava una sesión Emacs escribiendo unicamente el comando <code>emacs</code>, sin nombrar ningun fichero, Emacs iniciaba con el búfer <span class="file" >*scratch*</span> visible. Hoy en día, vera una pantalla de bienvenida. Puede seguir uno de los comandos sugeridos en dicha pantalla, visitar un fichero, o presionar la barra espaciadora para acceder al búfer <span class="file" >*scratch*</span>.</p>
<p>Si cambias al búfer <span class="file" >*scratch*</span>, escribe <code>(buffer-name)</code>, coloca el cursor al final de la expresión, y presiona <kbd>C-x C-e</kbd> para evaluar la expresión. El nombre <code>*scratch*</code> será devuelto y aparecerá en el área de eco. <code>*scratch*</code> es el nombre del búfer. Al escribir y evaluar <code>(buffer-file-name)</code> en el búfer <span class="file" >*scratch*</span>, aparecerá <code>nil</code> en el área de eco, igual que cuando evalúas <code>(buffer-file-name)</code> en Info.</p>
<p>Por cierto, si estas en el búfer <span class="file" >*scratch*</span> y quieres que el valor devuelto por una expresión aparezca en el búfer en sí y no en el área de eco, presiona <kbd>C-u C-x C-e</kbd> en lugar de <kbd>C-x C-e</kbd>. Esto hace que el valor devuelto aparezca después de la expresión. El búfer se verá así:</p>
<div class="example-block" >
<pre class="example" >(buffer-name)&#34;*scratch*&#34;
</pre>
</div>
<p>No se puede hacer esto en Info ya que Info es de solo lectura y no se permitirá cambiar el contenido del búfer. Pero puedes hacer esto en cualquier búfer que puedas editar; y cuando escribes código o documentación (como este libro), esta caracteristica es muy útil.</p>
</div>
<h3 id="obtención-de-búfers" >Obtención de Búfers</h3>
<div class="hBody-3" >
<p>La función <code>buffer-name</code> devuelve el <em>nombre</em> del búfer; para obtener el búfer <em>en sí</em>, se necesita una función diferente: la función <code>current-buffer</code>. Si utiliza esta función en el código, lo que se obtiene es el búfer en sí.</p>
<p>Un nombre y el objeto o entidad al que se refiere el nombre son diferentes entre si. Tu no eres tu nombre, eres una persona a la que se refieren los demas por tu nombre. Si pides hablar con Jorge y alguien te entrega una tarjeta con las letras <samp>J</samp>, <samp>o</samp>, <samp>r</samp>, <samp>g</samp>, y <samp>e</samp> estritas, podrias divertirte, pero no estarías satisfecho. No quieres hablar con el nombre, sino con la persona a la que se refiere el nombre. Un búfer es similar: el nombre del búfer scratch es <span class="file" >*scratch*</span>, pero el nombre no es el búfer. Para obtener un búfer en sí, es necesario utilizar una función como <code>current-buffer</code>.</p>
<p>Sin embargo, hay una ligera complicación: si evalúas <code>current-buffer</code> en una expresión por sí sola, como haremos aquí, lo que se ve es una representación impresa del nombre del búfer sin el contenido del búfer. Emacs funciona de esta forma por dos razones: el búfer puede contener miles de líneas––demasiado largo para ser mostrado convenientemente; y, otro búfer puede tener el mismo contenido pero un nombre diferente, y es importante distinguir entre ellos.</p>
<p>Aquí hay una expresión que contiene la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span>
</code></pre>
<p>Si evalúa esta expresión en Info de la manera habitual, aparecerá <span class="file" >#&lt;buffer *info*&gt;</span> en el área de eco. El formato especial indica que el búfer en sí está siendo devuelto, en lugar de solo su nombre.</p>
<p>Por cierto, si bien puedes escribir un número o símbolo en un programa, no se puede hacer esto con la representación impresa del búfer: la única manera de optener un búfer en sí mismo es con una función como <code>current-buffer</code>.</p>
<p>Un función relacionada es <code>other-buffer</code>. Esta devuelve el último bufer seleccionado distinto al que te encuentras actualmente, no una representación impresa de su nombre. Si recientemente has ido y vuelto del búfer <span class="file" >*scratch*</span>, <code>other-buffer</code> devolverá ese búfer.</p>
<p>Puedes ver esto evaluando la expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">other-buffer</span><span class="p">)</span>
</code></pre>
<p>Verás que <code>#&lt;buffer *scratch*&gt;</code> aparece en el área de eco, o el nombre de cualquier otro búfer al que allas cambiado anteriormente a partir del más reciente<span class="note" ><sup><a href="#5" >5</a></sup></span></p>
</div>
<h3 id="cambiando-búfers" >Cambiando búfers</h3>
<div class="hBody-3" >
<p>La función <code>other-buffer</code> realmente proporciona un búfer cuando se utiliza como argumento de una función que requiera uno. Podemos ver esto usando <code>other-buffer</code> y <code>switch-to-buffer</code> para cambiar a un búfer diferente.</p>
<p>Pero primero, una breve introducción a la función <code>switch-to-buffer</code>. Cuando cambias de ida y vuelta de Info al búfer <span class="file" >*scratch*</span> para evaluar <code>(buffer-name)</code>, normalmente se presiona <kbd>C-x b</kbd> y luego se pasa <span class="file" >*scratch*</span><span class="note" ><sup><a href="#6" >6</a></sup></span> en el minibuffer cuando se le solicita el nombre del buffer al que quieres cambiar. El atajo, <kbd>C-x b</kbd>, hace que el intérprete Lisp evalúe la función interactiva <code>switch-to-buffer</code>. Como hemos dicho anteriormente, así es como funciona Emacs: diferentes atajos de teclado llaman o ejecutan diferentes funciones. Por ejemplo, <kbd>C-f</kbd> llama a <code>forward-char</code>, <kbd>M-e</kbd> llama a <code>forward-sentence</code>, etcétera.</p>
<p>Al escribir <code>switch-to-buffer</code> en una expresión, y darle un búfer al que cambiar, podemos cambiar de búfer tal y como hace <kbd>C-x b</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nf">other-buffer</span><span class="p">))</span>
</code></pre>
<p>El símbolo <code>switch-to-buffer</code> es el primer elemento de la lista, por lo que el intérprete Lisp lo tratará como una función y llevara a cabo las instrucciones adjuntas al mismo. Pero antes de hacer esto, el intérprete observara que <code>other-buffer</code> está dentro de paréntesis y trabajara en este símbolo primero. <code>other-buffer</code> es el primer (y en este caso, el único) elemento de esta lista, por lo que el intérprete llama o ejecuta la función. Esto devuelve un búfer distinto al actual. A continuación, el intérprete ejecuta <code>switch-to-buffer</code>, pasando, como argumento, el búfer devuelto, que es al que Emacs cambiara. Si estás leyendo esto en Emacs, prueba ahora. Evalúa la expresión. (Para regresar, presiona <kbd>C-x b RET</kbd>.)<span class="note" ><sup><a href="#7" >7</a></sup></span></p>
<p>En los ejemplos de las secciones siguentes, veras con más frecuencia la función <code>set-buffer</code> que <code>switch-to-buffer</code>. Esto se debe a la diferencia entre programas de ordenador y los humanos: los humanos tienen ojos y esperan ver el búfer en el que están trabajando en la terminal de su ordenador. Esto es tan evidente, que se sobreentiende. Sin embargo, los programas no tienen ojos. Cuando un programa de ordenador trabaja en un búfer, el búfer no necesita ser visible en la pantalla.</p>
<p><code>switch-to-buffer</code> está diseñado para los humanos y hace dos cosas diferentes: cambia el búfer a el que Emacs dirige la atención; y cambia el búfer mostrado en la ventana al nuevo búfer. <code>set-buffer</code>, por otro lado, solo hace una cosa: cambia la atención del programa del ordenador a un búfer diferente. El búfer en la pantalla permanece sin cambios (por supuesto, normalmente no pasa nada hasta que el comando termina de ejecutarse).</p>
<p>Además, acabamos introduciendo otro termino tecnico, la palabra <dfn>llamada</dfn>. Cuando se evalúa una lista en la que el primer símbolo es una función, se llama a esa función. El uso del término viene de la noción de la función como una entidad que puede algo hacer por ti cuando la ‘llamas’––al igual que un fontanero es una entidad que puede arreglar una fuga si lo llamas.</p>
</div>
<h3 id="tamaño-del-búfer-y-la-ubicación-del-punto" >Tamaño del búfer y la ubicación del punto</h3>
<div class="hBody-3" >
<p>Por último, vamos a ver varias funciones bastante sencillas, <code>buffer-size</code>, <code>point</code>, <code>point-min</code>, y <code>point-max</code>. Estas proporcionan información sobre el tamaño de un búfer y la ubicación del punto dentro de el.</p>
<p>La función <code>buffer-size</code> te dice el tamaño del búfer actual; es decir, la función devuelve un conteo del número de caracteres en el buffer.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">buffer-size</span><span class="p">)</span>
</code></pre>
<p>Puedes evaluar esto de la forma habitual, coloca el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>.</p>
<p>En Emacs, la posición actual del cursor se denomina <dfn>punto</dfn>. La expresión <code>(point)</code> devuelve un número que indica donde esta situado el cursor como un conteo del número de caracteres desde el principio del búfer hasta el punto.</p>
<p>Puedes ver el conteo de caracteres del punto para este búfer evaluando la siguiente expresión de la forma habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">point</span><span class="p">)</span>
</code></pre>
<p>Mientras escribo esto, el valor de <code>point</code> es 65724. La función <code>point</code> se utiliza con frecuencia en algunos de los ejemplos mas adelante en este libro.</p>
<p>El valor del punto depende, por supuesto, de su ubicacion dentro del búfer. Si evaluas el punto en este lugar, el número será mayor:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">point</span><span class="p">)</span>
</code></pre>
<p>Para mí, el valor del punto en esta posición es 66043, lo que significa que hay 319 caracteres (incluyendo espacios) entre las dos expresiones.  (Sin duda, verás números diferentes, ya que lo habré editado desde que evalue el punto por primera vez.)</p>
<p>La función <code>point-min</code> es similar a <code>point</code>, pero devuelve el valor mínimo permisible del punto en el búfer actual. Este es el numero 1 a menos que <dfn>narrowing</dfn> esté en efecto. (Narrowing (<em>Reduccion</em>) es un mecanismo mediante el cual puedes restringirte a ti mismo, o un programa, a operar solo en un parte de un búfer. Vea la Sección <a href="#reducir-y-extender" >Reducir y Extender</a>.)  Del mismo modo, la función <code>point-max</code> devuelve el valor máximo permisible del punto en el búfer actual.</p>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Busca un fichero en el que trabarjar y avanza hasta la mitad. Encuentra el nombre de búfer, el nombre del fichero, su tamaño, y la posición en el fichero.</p>
</div>
<h2 id="cómo-escribir-definiciones-de-funciones" >Cómo escribir definiciones de funciones</h2>
<div class="hBody-2" >
<p>Cuando el intérprete Lisp evalúa una lista, mira si el primer símbolo tiene una definición de funcion adjunta; o, dicho de otro modo, si el símbolo apunta a una definición de función. Si lo hace, el ordenador lleva a cabo las instrucciones que aparecen en la definición. Un símbolo que tiene una definición de función se llamada, simplemente, una función (aunque hablando con propiedad, la definición es la función y el símbolo se refiere a ella.)</p>
<p>Todas las funciones se defininen en términos de otras funciones, a excepción de algunas <dfn>primitivas</dfn> que estan escritas en el lenguaje de programación C. Cuando escribas definiciones de funciones, debes escribirlas en Emacs Lisp y utilizar otras funciones como bloques de construcción. Algunas de las funciones a utilizar estaran a su vez escritas en Emacs Lisp (quizás por tí) y otras serán primitivas escritas en C. Las funciones primitivas se usan exactamente igual que las escritas en Emacs Lisp y se comportan de igual forma. Están escritas en C para que podamos ejecutar facilmente GNU Emacs en cualquier ordenador que tenga la potencia suficiente y pueda ejecutar C.</p>
<p>Permíteme volver a enfatizar esto: cuando se escribe código en Emacs Lisp, no se distinge entre el uso de funciones escritas en C y el uso de funciones escritas en Emacs Lisp. La diferencia es irrevelante. Mencioné la distinción solo porque es interesante conocerla. De hecho, a menos de que investigues, no sabras si una función ya estrita esta en Emacs Lisp o en C.</p>
</div>
<h3 id="la-forma-especial-defun" >La forma especial <code>defun</code></h3>
<div class="hBody-3" >
<p>En Lisp, un símbolo como <code>mark-whole-buffer</code> tiene un código adjunto que le dice al ordenador que hacer cuando se invoca la función. Este código se denomina la <dfn>definición de función</dfn> y se crea evaluando una expresión Lisp que comienza con el símbolo <code>defun</code> (que es una abreviatura para <em>define function</em> (<em>definir función</em>)). Debido a que <code>defun</code> no evalúa sus argumentos en la manera habitual, se le llama una <dfn>forma especial</dfn>.</p>
<p>En las siguientes secciones, vamos a ver las definiciones de función partiendo del código fuente de Emacs, como <code>mark-whole-buffer</code>. En esta sección, describiremos una definición de función sencilla para que puedas ver su aspecto. Esta definición de función usa aritmética porque es un ejemplo simple. A algunas personas les disgustan los ejemplos que usan aritmética; sin embargo, si usted es tal persona, no se desespere. Casi ningun codigo a estudiar en el resto de esta introducción implica aritmética o matemáticas. Los ejemplos involucran principalmente texto en una forma u otra.</p>
<p>Una definición de función tiene un máximo de cinco partes despues de la palabra <code>defun</code>:</p>
<ol class="num" >
<li>
<p>El nombre del símbolo al que debe vincularse la definición de función.</p>
</li>
<li>
<p>Una lista de los argumentos que se pasan a la función. Si no hay argumentos que pasar a la función, tendremos una lista vacía, <code>()</code>.</p>
</li>
<li>
<p>Documentación que describe la función. (Técnicamente opcional, pero muy recomendable.)</p>
</li>
<li>
<p>Opcionalmente, una expresión para hacer que la función sea interactiva, de manera que puede utilizarla presionando <kbd>M-x</kbd> seguido del nombre de la función; o pulsando una tecla o atajo de teclado.</p>
</li>
<li>
<p>El código que indica a el ordenador qué hacer: el <dfn>cuerpo</dfn> de la definición de función.</p>
</li>
</ol>
<p>Es útil pensar que las cinco partes de una definición de función estan organizadas como en una plantilla, con ranuras para cada parte:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-función</span> <span class="p">(</span><span class="nv">argumentos</span><span class="err">…</span><span class="p">)</span>
  <span class="s">&#34;documentación-opcional…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="nv">argument-passing-info</span><span class="p">)</span>     <span class="c1">; opcional</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>A modo de ejemplo, aquí está el código de una función que multiplica su argumento por 7. (Este ejemplo no es interactivo. Vea la Sección <a href="#crear-una-función-interactiva" >Crear una Función Interactiva</a>, para obtener esa información.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Esta definición comienza con un paréntesis y el símbolo <code>defun</code> seguido por el nombre de la función.</p>
<p>El nombre de la función es seguido por una lista que contiene los argumentos que se pasaran a la función. Esta lista se llama <dfn>lista de argumentos</dfn>. En este ejemplo, la lista solo tiene un elemento, el símbolo <code>numero</code>. Cuando se utiliza la función, el símbolo sera asociado al valor que se utiliza como argumento de la función.</p>
<p>En lugar de elegir la palabra <code>numero</code> para el nombre del argumento, podría haber escogido cualquier otro nombre. Por ejemplo, la palabra <code>multiplicando</code>. Escogi la palabra ‘numero’ porque indica qué tipo de valor se pretende para este espacio; pero podría haber elegido ‘multiplicando’ para indicar el papel que jugara el valor en el funcionamiento de la función. Podría haberlo llamado <code>foogle</code>, pero habría sido una mala elección, ya que no comunicaria a los humanos qué significa. La elección del nombre es responsabilidad del programador y debe elegirse para hacer que el significado de la función quede claro.</p>
<p>De hecho, puedes elegir cualquier nombre que desees para un símbolo en una lista de argumentos, incluso el nombre de un símbolo utilizado en alguna otra función: el nombre que utilices en una lista de argumentos es privado para esta definición particular. En esta definición, el nombre hace referenecia a una entidad diferente a cualquiera que utilice el mismo nombre fuera de la definición de función. Supón que tu familia te apoda ‘Enano’; cuando tus familiares digan ‘Enano’, queren hacer referencia a ti. Pero fuera de tu familia, en una película, por ejemplo, el nombre ‘Enano’ se refiere a alguien más. Debido a que el nombre en una lista de argumentos es privado para la definición de la función, se puede cambiar el valor de un símbolo dentro del cuerpo de una función sin cambiar su valor fuera de la función. El efecto es similar al producido por la expresión <code>let</code>. (Vea la sección <a href="#let" ><code>let</code></a>.)</p>
<p>La lista de argumentos es seguida por la cadena de documentación que describe la función. Esto es lo ves cuando presionas <kbd>C-h f</kbd> y escribes el nombre de una función. Por cierto, cuando escribas una cadena de documentación como esta, debes confeccionar la primera linea como una frace completa ya que algunos comandos, como <code>apropos</code>, solo imprimen la primera línea de una cadena de documentación de varias líneas. Ademas, no debes indentar la segunda línea de la cadena de documentación, si tienes una, porque se ve extraño al utilizar <kbd>C-h f</kbd> (<code>describe-function</code>). La cadena de documentación es opcional, pero es tan útil, que debería incluirse en casi cualquier función que escribas.</p>
<p>La tercera línea del ejemplo consiste en el cuerpo de la definición de función. (La mayoría de las definiciones de funcion, claro esta, son más extensas que esta.) En esta función, el cuerpo es la lista, <code>(* 7 numero)</code>, que indica multiplicar el valor de <code>numero</code> por 7. (En Emacs Lisp, <code>*</code> es la función para la multiplicación, al igual que <code>+</code> es la función de suma.</p>
<p>Cuando se utiliza la función <code>multiplicar-por-siete</code>, el argumento <code>numero</code> se evalúa al número que desees usar. He aquí un ejemplo que muestra como utilizar <code>multiplicar-por-siete</code>; pero ¡no intentes evaluar esto primero!.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">multiplicar-por-siete</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>El símbolo <code>numero</code>, especificado en la definición de función en la siguiente sección, se da o “une a” el valor 3 en el actual uso de la función. Note que aunque <code>numero</code> estaba dentro de paréntesis en la definición de función, el argumento pasado a la función <code>multiplicar-por-siete</code> no está entre paréntesis. Los paréntesis se escriben en la definición de función para que el ordenador pueda averiguar donde termina la lista de argumentos e inicia el resto de la definición de función.</p>
<p>Si evalúas este ejemplo, es probable que obtengas un mensaje de error. (¡adelante, intentalo!) Esto se debe a que hemos escrito la definición de función, pero aún no se ha comunicado al ordenador sobre la definición––no hemos instalado (o ‘cargado’) la definición de función en Emacs. Instalar una función es el proceso de comunicar al intérprete Lisp la definición de la función. La instalación se describe en la siguiente sección.</p>
</div>
<h3 id="instalar-una-definición-de-función" >Instalar una definición de función</h3>
<div class="hBody-3" >
<p>Si estás leyendo esto dentro en Emacs, puedes probar la función <code>multiplicar-por-siete</code> evaluando en primer lugar la definición de función y luego evaluando <code>(multiplicar-por-siete 3)</code>. Hay una copia de la definición a continuación. Coloca el cursor después del último paréntesis de la definición de función y presiona <kbd>C-x C-e</kbd>. Al hacer esto, <code>multiplicar-por-siete</code> aparecerá en el área de eco. (Esto significa que cuando una se evalua una definición de función, el valor devuelto es el nombre de la función definida.) Al mismo tiempo, esta acción instala la definición de función.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Al evaluar este <code>defun</code>, estas instanlado <code>multiplicar-por-siete</code> en Emacs. La función ahora es una parte de Emacs tanto como <code>forward-word</code> o cualquier otra función de edición que utilices. (<code>multiplicar-por-siete</code> permanecera instalado hasta que salgas de Emacs. Para volver a cargar el código automáticamente cada vez que Emacs inicie, revisa la sección <a href="#instalar-código-permanentemente" >Instalar Código Permanentemente</a>.)</p>
<p>Puedes ver el efecto de instalar <code>multiplicar-por-siete</code> evaluando el siguiente ejemplo. Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>. Aparacerá el número 21 en el área de eco.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">multiplicar-por-siete</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>Si lo deseas, puedes leer la documentación de la función presiona <kbd>C-h f</kbd> (<code>describe-function</code>) y luego escribe el nombre de la función, <code>multiplicar-por-siete</code>. Al hacer esto, una ventana <span class="file" >*Help*</span> aparecerá en tu pantalla diciendo:</p>
<div class="example-block" >
<pre class="example" >multiplicar-por-siete is a Lisp function.
(multiplicar-por-siete NUMERO)

Multiplica NUMERO por siete.
</pre>
</div>
<p>(Para volver a una unica ventana en la pantalla, presiona <kbd>C-x 1</kbd>.)</p>
</div>
<h4 id="cambiar-una-definición-de-función" >Cambiar una definición de función</h4>
<div class="hBody-4" >
<p>Si deseas modificar el código de <code>multiplicar-por-siete</code>, simplemente vuelve a escribirlo. Para instalar la nueva versión en lugar de la anterior, evalúa nuevamente la definición de la función. Esta, es la forma de modificar el código en Emacs. Es muy simple,</p>
<p>A modo de ejemplo, puedes cambiar la función <code>multiplicar-por-siete</code> para sumar el número a sí mismo siete veces en lugar de multiplicar el número por siete. Esto produce el mismo resultado, pero por una ruta diferente. Al mismo tiempo, añadiremos un comentario al codigo; un comentario es texto que el intérprete Lisp ignora, pero un lector humano puede encontrar útil o esclarecedor. El comentario es, que esta es la “segunda versión”.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Segunda versión.</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>El comentario sigue a un punto y coma, <samp>;</samp>. En Lisp cualquier cosa en una línea despues de un punto y coma es un comentario. El fin de la línea es el fin del comentario. Para extender un comentario por dos o más líneas, inicia cada línea con un punto y coma.</p>
<p>Vé las Secciónes <a href="#empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></a> y <a href="info:emacs#Comments" >Comentarios</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más informacion sobre los comentarios.</p>
<p>Puedes instalar esta versión de <code>multiplicar-por-siete</code> evaluándo esta del misma modo en que evaluaste la primer función: coloca el cursor después del último paréntesis y presiona <kbd>C-x C-e</kbd>.</p>
<p>En resumen, asi es como puedes escribir código en Emacs Lisp: escribes una función; la instalas; la pruebas; luego haces correcciones o mejoras y la vuelves a instalar.</p>
</div>
<h3 id="crear-una-función-interactiva" >Crear una función interactiva</h3>
<div class="hBody-3" >
<p>Puedes hacer a una función interactiva colocando una lista que inicia con la forma especial <code>interactive</code> inmediatamente después de la documentación. Un usuario puede invocar una función interactiva con <kbd>M-x</kbd> seguido del nombre de la función; o con un atajo de teclado ligado a esta, por ejemplo, presionando <kbd>C-n</kbd> para <code>next-line</code> o <kbd>C-x h</kbd> para <code>mark-whole-buffer</code>.</p>
<p>Cusionamente, cuando llamas a una función interactiva interactivamente, el valor devuelto no se muestra automáticamente en el área de eco. Esto se debe a que a menudo se llama a una función interactiva por sus efectos secundarios, como avanzar hacia adelante una palabra o una línea, y no por el valor devuelto. Si el valor devuelto se mostrara en el área de eco cada vez que presionas una tecla, seria muy molesto.</p>
<p>Tanto el uso de la forma especial <code>interactive</code> y la forma de mostrar un valor en el área de eco pueden ilustrarse creando una versión interactiva de <code>multiplicar-por-siete</code>.</p>
<p>Aquí está el código:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Versión Interactiva.</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">)))</span>
</code></pre>
<p>Para instalar este código coloca el cursor después del ultimo parentesis y presiona <kbd>C-x C-e</kbd>. El nombre de la función aparecerá en el área de eco. Despues, puedes utilizar este código al presionar <kbd>C-u</kbd> segudo de un número, luego <kbd>M-x multiplicar-por-siete</kbd> y finalmente <kbd>RET</kbd>. La frase <samp>El resultado es …</samp> seguida por el producto, aparecerá en el área de eco.</p>
<p>Hablando en terminos mas generales, puedes invocar una función como ésta de dos maneras:</p>
<ol class="num" >
<li>
<p>Al escribir un argumento prefijo que contiene el número a pasar, y a continuación presionar <kbd>M-x</kbd> y escribir el nombre de la función, como ocurre con <kbd>C-u 3 M-x forward-sentence</kbd>; o,</p>
</li>
<li>
<p>Escribir cualquier tecla o atajo de teclado ligado a la función, como ocurre con <kbd>C-u 3 M-e</kbd>.</p>
</li>
</ol>
<p>Ambos ejemplos operan de forma identica moviendo el punto hacia adelante tres oraciones. (Ya que <code>multiply-by-seven</code> no esta ligado a un atajo, no se puede utilizar como ejemplo.)</p>
<p>(Vea la Seccion <a href="#atajos-de-teclado" >Atajos de teclado</a>, para aprender como vincular un comando a una atajo.)</p>
<p>Un argumento prefijo se pasa a una función interactiva pulsando la tecla <kbd>META</kbd> seguida de un número, por ejemplo, <kbd>M-3 M-e</kbd>, o con <kbd>C-u</kbd> y luego un número, por ejemplo, <kbd>C-u 3 M-e</kbd> (si presionas <kbd>C-u</kbd> sin ningun número, el valor por defecto es 4).</p>
</div>
<h4 id="multiplicar-por-siete-interactivo" ><code>multiplicar-por-siete</code> interactivo</h4>
<div class="hBody-4" >
<p>Veamos es uso de la forma especial <code>interactive</code> y luego la función <code>message</code> en la versión interactiva de <code>multiplicar-por-siete</code>. Recordaras que la definición de función tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Versión Interactiva.</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">)))</span>
</code></pre>
<p>En esta función, la expresión, <code>(interactive &#34;p&#34;)</code>, es una lista de dos elementos. La <code>&#34;p&#34;</code> le indica a Emacs que debe pasar el argumento prefijo a la función y utilizar este valor para el argumento de la función.</p>
<p>El argumento debe ser un número. Esto significa que el símbolo <code>numero</code> estara asociado a un número en la línea:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Por ejemplo, si tu argumento prefijo es 5, el intérprete Lisp evaluará la línea como si fuera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>(Si estás leyendo esto en GNU Emacs, puedes evaluar esta expresión por ti mismo.) Primero, el intérprete evaluará la lista interna, que es <code>(* 7 5)</code>. Esto devuelve un valor de 35. A continuación, se evaluará la lista externa, pasando los valores del segundo y posteriores elementos de la lista a la función <code>message</code>.</p>
<p>Como hemos visto, <code>message</code> es una función Emacs Lisp especialmente diseñada para enviar un mensaje de una línea al usuario. (Vea la Seccion <a href="#la-función-message" >La función <code>message</code></a>.) En resumen, la función <code>message</code> imprime su primer argumento en el área de eco tal cual, excepto para las apariciones de <samp>%d</samp>, o <samp>%s</samp> (y varias otras secuencias de control que no hemos mencionado). Cuando aparece una secuencia de control, la función busca el segundo o posteriores argumentos e imprime el valor del argumento en la ubicación donde se encuartra la secuencia de control.</p>
<p>En la función interactiva <code>multiplicar-por-siete</code>, la cadena de control es <samp>%d</samp>, que requiere un número, y el valor devuelto por la evaluación de <code>(* 7 5)</code> es el número 35. Por consiguiente, el número 35 se imprime en lugar de <samp>%d</samp> y el mensaje es <samp>El resultado es 35</samp>.</p>
<p>(Observa que cuando llamas a la función <code>multiplicar-por-siete</code>, el mensaje se imprime sin comillas, pero cuando llamas a <code>message</code>, el texto se imprime entre comillas. Esto se debe a que el valor devuelto por <code>message</code> aparece en el área de eco cuando evalúas una expresión cuyo primer elemento es <code>message</code>; pero si se integra en una función, <code>message</code> imprime el texto como un efecto secundario sin comillas.)</p>
</div>
<h3 id="diferentes-opciones-para-interactive" >Diferentes opciones para <code>interactive</code></h3>
<div class="hBody-3" >
<p>En el ejemplo, <code>multiplicar-por-siete</code> utilizo <code>&#34;p&#34;</code> como el argumento para <code>interactive</code>. Este argumento indica a Emacs que interprete cualquer cosa que escriba despues de <kbd>C-u</kbd> o del comando <kbd>META</kbd> como un numero que sera el argumento a pasar a la funcion. Emacs tiene más de veinte caracteres predefinidos para usar con <code>interactive</code>. En casi todos los casos, una de estas opciones te permitira pasar la información correcta de forma interactiva a una función. (Vea la Seccion <a href="info:elisp#Interactive" >Codigo de Caracteres para <code>interactive</code></a> en <em>El Manual de Referencia GNU Emacs Lisp</em>).</p>
<p>Considera la función <code>zap-to-char</code>. Su expresión interactiva es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
</code></pre>
<p>La primer parte del argumento de <code>interactive</code> es <samp>p</samp>, con el que ya estás familiarizado. Este argumento le indica a Emacs intepretar un ‘prefijo’, como un número que se pasa a la función. Puedes especificar un prefijo presionando <kbd>C-u</kbd> seguido de un número o igualmente con <kbd>META</kbd> seguido por un número. El prefijo es un número de caracteres especifico. De este modo, si el prefijo es tres y el caracter especificado es <samp>x</samp>, entonces se borrará todo el texto hasta e incluido el tercer <samp>x</samp> siguiente. Si no se establece un prefijo, entonces borras todo el texto hasta e incluido el carácter establecido, pero no más.</p>
<p>La <samp>c</samp> indica a la función el nombre del carácter que va a eliminar.</p>
<p>Más formalmente, una función con dos o más argumentos puede tener información que pasa a cada argumento añadiendo partes en la cadena que a continuacion de <code>interactive</code>. Al hacer esto, la información se pasa a cada argumento en el mismo orden que se especifica en la lista <code>interactive</code>. En la cadena, cada parte está separada de la siguente parte por un <samp>\n</samp>, que significa nueva línea. Por ejemplo, a <samp>p</samp> puede continuar un <samp>\n</samp> y un <samp>cZap to char: </samp>. Esto hace que Emacs pase el valor del argumento prefijo (si lo hay) y el carácter.</p>
<p>En este caso, la definición de función se parece a la siguiente, donde <code>arg</code> y <code>char</code> son los símbolos que <code>interactive</code> vincula el argumento prefijo y el caracter especificado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">arg</span> <span class="nv">char</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
  <span class="nv">cuerpo-de-funcion</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>(El espacio después de los dos puntos en el prompt hace que se vea mejor. Vea la Seccion <a href="#la-definición-de-copy-to-buffer" >La Definición de <code>copy-to-buffer</code></a>, para un ejemplo.)</p>
<p>Cuando una función no toma argumentos, <code>interactive</code> no requiere ninguno. Una función asi contiene unicamente la expresión <code>(interactive)</code>. La función <code>mark-whole-buffer</code> es asi.</p>
<p>Alternativamente, si los códigos especiales de letras no son adecuados para su aplicación, puedes pasar tus propios propios argumentos a <code>interactive</code> como una lista.</p>
<p>Vea la Seccion <a href="#la-definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>, para un ejemplo. Vea la Sección <a href="info:elisp#Using-Interactive" >Usando <code>interactive</code></a> en <em>El Manual de GNU Emacs Lisp</em>, para una explicación más completa sobre esta técnica.</p>
</div>
<h3 id="instalar-código-permanentemente" >Instalar Código Permanentemente</h3>
<div class="hBody-3" >
<p>Cuando instalas una definición de función evaluandola, permanecera instalada hasta que salgas de Emacs. La proxima vez que inicies una nueva sesión de Emacs, la función no sera instalada a menos que evalúes la definición de nuevo.</p>
<p>En algún momento, podrias necesitar que el código se instale automáticamente cada vez que inicies una nueva sesión de Emacs. Hay varias formas de hacer esto:</p>
<ul>
<li>
<p>Si tienes código solo para tu uso, puedes poner el código de la definición de función en el fichero de inicialización <span class="file" >.emacs</span>. Cuando se inicia Emacs, el fichero <span class="file" >.emacs</span> se evalúa automática y se instalan todas sus definiciones de función. Vér la Sección <a href="#tu-fichero-.emacs" >Tu Fichero <span class="file" >.emacs</span></a>.</p>
</li>
<li>
<p>Como Alternativa, puedes poner las definiciones de función en uno o más ficheros y usar la función <code>load</code> para hacer que Emacs evalue y con ello instale cada una de las funciones en los ficheros. Vea la Seccion <a href="#cargando-ficheros" >Cargando ficheros</a>.</p>
</li>
<li>
<p>En Tercer lugar, si tienes código que todo tu sitio va a utilizar, es normal ponerlo en un fichero llamado <span class="file" >site-init.el</span> que se carga cuando se construye Emacs. Esto hace que el código este disponible para todos los usuarios de tu máquina. (Mira el fichero <span class="file" >INSTALL</span> que forma parte de la distribución Emacs.)</p>
</li>
</ul>
<p>Finalmente, si tienes código que cualquier usuario de Emacs pueda querer, puedes publicarlo en una red de informatica o enviar una copia a la Free Software Foundation. (Al hacer esto, por favor licencia el código y su documentación bajo una licencia que permita a otras personas ejecutar, copiar, estudiar, modificar, y redistribuir el código y te protege de quien tome tu trabajo.) Si envias una copia de tu código a la Free Software Foundation, y lo proteges apropiadamente de ti mismo y otros, puede ser incluido en la siguiente version de Emacs. En gran parte, esta es la forma como ha crecido Emacs a través de los años, a traves de donaciones.</p>
</div>
<h3 id="let" ><code>let</code></h3>
<div class="hBody-3" >
<p>La expresión <code>let</code> es una forma especial en Lisp que tendras que utilizar en la mayoría de las definiciones de función.</p>
<p><code>let</code> se utiliza para unir o enlazar un símbolo a un valor de tal manera que el intérprete no confunda la variable con otra variable del mismo nombre que no forme parte de la función.</p>
<p>Para entender por qué la forma especial <code>let</code> es necesaria, considera la situación donde eres dueño de una casa que generalmente vinculas con ‘la casa’, como en la frase, “La casa necesita pintura”. Si visitas a un amigo y tu anfitrion hace referencia a ‘la casa’, es probable que se refiera a <em>su</em> casa, no a la tuya, es decir, a una casa diferente.</p>
<p>Si tu amigo se refiere a su casa y tu crees que el se esta refiriendo a tu casa, puedes tener cierta confusión. Lo mismo podría suceder en Lisp si una variable que se usa dentro de una función tiene el mismo nombre que una variable usada dentro de otra función, y las dos no tienen la intencion de referirse al mismo valor. La forma especial <code>let</code> permite evitar este tipo de confusión.</p>
<p>La forma especial <code>let</code> evita confusiones. <code>let</code> crea un nombre para una <dfn>variable local</dfn> que eclipsa cualquier uso del mismo nombre fuera de la expresión <code>let</code>. Esto es como entender que cuando tu anfitrion se refiera a ‘la casa’, el quiere decir su casa, no la tuya. (Los símbolos usados en las listas de argumentos funcionan de la misma manera. Véa la Sección <a href="#la-forma-especial-defun" >La Forma Especial <code>defun</code></a>.)</p>
<p>Las variable locales creadas por una expresión <code>let</code> retienen su valor <em>solo</em> dentro de la expresión <code>let</code> (y dentro de expresiones llamadas dentro de la expresión <code>let</code>); las variables locales no tiene efecto fuera de la expresión <code>let</code>.</p>
<p>Otra forma de persar sobre <code>let</code> es que es como un <code>setq</code> que es temporal y local. Los valores establecidos por <code>let</code> se deshacen automáticamente cuando <code>let</code> finaliza. La configuración solo afecta a las expresiones que se encuentran dentro de los limites de la expresión <code>let</code>. En jerga informatica, diríamos que “la union de un simbolo es visible solo en las funciones llamadas en la forma <code>let</code>; en Emacs Lisp, el alcance es dinámico, no léxico.”</p>
<p><code>let</code> puede crear más de una variable a la vez. Ademas, <code>let</code> da a cada variable que crea un valor inicial, ya sea un valor especificado por tí, o <code>nil</code>. (En la jerga, eso se llama ‘enlazar la variable al valor’.)  Después de que <code>let</code> ha creado y enlazado las variables, ejecuta el código en el cuerpo del <code>let</code> y devuelve el valor de la última expresión en el cuerpo, como el valor de toda la expresión <code>let</code>. (‘Ejecutar’ es un término tecnico que significa evaluar una lista; proviene del significando de la palabra ‘llevar a la practica’ (<em>Oxford English Dictionary</em>). Ya que evalúas una expresión para realizar una acción, ‘ejecutar’ ha evolucionado como un sinónimo para ‘evaluar’.)</p>
</div>
<h4 id="partes-de-una-expresión-let" >Partes de una expresión <code>let</code></h4>
<div class="hBody-4" >
<p>Una expresión <code>let</code> es una lista de tres partes. La primer parte es el símbolo <code>let</code>. La segunda parte es una lista, llamada <dfn>varlist</dfn> (lista de variables), cada uno de cuyos elementos es un símbolo por sí mismo o una lista de dos elementos, cuyo primer elemento es un símbolo. La tercera parte de la expresión <code>let</code> es el cuerpo de <code>let</code>. El cuerpo normalmente consiste de una o más listas.</p>
<p>Una plantilla para una expresión <code>let</code> tiene el siguente aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="nv">varlist</span> <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Los símbolos de la lista de varibles (<code>varlist</code>) son las variables a las que la forma especial <code>let</code> da valores de inicio. Los símbolos por si solos reciven el valor de inicio <code>nil</code>; y cada símbolo que sea el primer elemento de una lista de dos elementos se vincula al valor que se devuelve cuando el interprete Lisp evalúa el segundo elemento.</p>
<p>Por lo tanto, una varlist podria verse asi: <code>(thread (needles 3))</code>. En este caso, en una expresión <code>let</code>, Emacs une el símbolo <code>thread</code> a un valor inicial de <code>nil</code>, y une el símbolo <code>needles</code> a un valor inicial de 3.</p>
<p>Cuando escribes una expresión <code>let</code>, lo que haces es poner las expresiones apropiadas en los espacios de la plantilla de expresión <code>let</code>.</p>
<p>Si la varlist está compuesta de listas de 2 elementos, como suele ser el caso, la plantilla de la expresión <code>let</code> es la sigiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="ejemplo-de-expresión-let" >Ejemplo de Expresión <code>let</code></h4>
<div class="hBody-4" >
<p>La siguiente expresión crea y da valores los iniciales a las dos variables <code>cebra</code> y <code>tigre</code>. El cuerpo de la expresión <code>let</code> es una lista que llama a la función <code>message</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cebra</span> <span class="ss">&#39;rayas</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">tigre</span> <span class="ss">&#39;fiero</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Un tipo de animal tiene %s y otro es %s.&#34;</span>
           <span class="nv">cebra</span> <span class="nv">tigre</span><span class="p">))</span>
</code></pre>
<p>Aquí, la varlist es <code>((cebra &#39;rayas) (tigre &#39;fiero))</code>.</p>
<p>Las dos variables son <code>cebra</code> y <code>tigre</code>. Cada variable es el primer elemento de una lista de dos elementos y cada valor es el segundo elemento de su lista de dos elementos. En la varlist, Emacs une la variable <code>cebra</code> al valor <code>rayas</code><span class="note" ><sup><a href="#8" >8</a></sup></span>, y la variable <code>tigre</code> al valor <code>fiero</code>. En este ejemplo, ambos valores son símbolos precedidos por una cita. Los valores podrían muy bien haber sido otra lista o una cadena. El cuerpo de <code>let</code> sigue después de la lista que contiene las variables. En este ejemplo, el cuerpo es una lista que usa la función <code>message</code> para imprimir una cadena en el área de eco.</p>
<p>Puedes evaluar el ejemplo de la forma habitual, coloca el cursor después del último paréntesis y presiona <kbd>C-x C-e</kbd>. Al hacer esto, aparecerá lo siguiente en el área de eco:</p>
<pre class="code" ><code class="chroma" ><span class="s">&#34;Un tipo de animal tiene rayas y otro es fiero.&#34;</span>
</code></pre>
<p>Como hemos visto anteriormente, la función <code>message</code> imprime su primer argumento, excepto <samp>%s</samp>. En este ejemplo, el valor de la variable <code>cebra</code> se imprime en la ubicacion del primer <samp>%s</samp> y el valor de la variable <code>tigre</code> se imprime en la ubicacion del segundo <samp>%s</samp>.</p>
</div>
<h4 id="variables-sin-inicializar-en-un-sentencia-let" >Variables sin inicializar en un sentencia <code>let</code></h4>
<div class="hBody-4" >
<p>Si no se unen las variables en una sentencia <code>let</code> con valores de inicio específicos, automáticamente seran unidos a un valor de inicio <code>nil</code>, como en la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">abedul</span> <span class="mi">3</span><span class="p">)</span>
      <span class="nv">pino</span>
      <span class="nv">abeto</span>
      <span class="p">(</span><span class="nv">roble</span> <span class="ss">&#39;algunos</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&#34;Aquí están %d variables con %s, %s, y el valor %s.&#34;</span>
   <span class="nv">abedul</span> <span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span><span class="p">))</span>
</code></pre>
<p>Aquí, la varlist es <code>((abedul 3) pino abeto (roble &#39;algunos))</code>.</p>
<p>Si evalúas esta expresión de la forma habitual, aparecerá lo siguiente en el área de eco:</p>
<div class="example-block" >
<pre class="example" >&#34;Aquí están 3 variables con nil, nil, y el valor algunos.&#34;
</pre>
</div>
<p>En este ejemplo, Emacs une el símbolo <code>abedul</code> al número 3, une los símbolos <code>pino</code> y <code>abeto</code> a <code>nil</code>, y el símbolo <code>roble</code> al valor <code>algunos</code>.</p>
<p>Observe que en la primera parte de <code>let</code>, las variables <code>pino</code> y <code>abeto</code> son unicamente átomos que no están rodeados por paréntesis; esto es porque estan siendo unidos a <code>nil</code>, la lista vacía. Pero <code>roble</code> su une a <code>algunos</code> por que es parte de la lista <code>(roble &#39;algunos)</code>. De manera similar, <code>abedul</code> se une al número 3 en una lista con este número. (Ya que un número se evalúa a sí mismo, el número no necesita ser citado. Ademas, el número se imprime en el mensaje utilizando un <samp>%d</samp> en lugar de un <samp>%s</samp>.) Las cuatro variables como grupo son puestas dentro de una lista para delimitarla del cuerpo de <code>let</code>.</p>
</div>
<h3 id="la-forma-especial-if" >La forma especial <code>if</code></h3>
<div class="hBody-3" >
<p>Además de <code>let</code> y <code>defun</code>, esta la forma especial condicional <code>if</code>. Esta forma se utiliza para indicar al ordenador que tome decisiones. Puedes escribir definiciones de función sin necesidad de utilizar <code>if</code>, pero se usa con bastante frecuencia, y es lo suficientemente importante como para incluirse aquí. Se utiliza, por ejemplo, en el código de la función <code>beginning-of-buffer</code>.</p>
<p>La idea básica detras de <code>if</code>, es que “<em>si</em> (<em>if</em>) una prueba es verdadera <em>entonces</em> se evalua la expresión”. Si la prueba no es verdadera, la expresión no se evalua. Por ejemplo, podría tomar una decisión como, “si hace sol y calor, ve a la playa!”</p>
<p>Al escribir una expresión <code>if</code> en Lisp no se utiliza la palabra ‘then’; la prueba y la acción son los elementos segundo y tercero de la lista cuyo primer elemento es <code>if</code>. No obstante, la parte de la prueba en una expresión <code>if</code> a menudo se llamada <dfn>parte-si</dfn> (if-part) y el segundo argumento a menudo se llamada <dfn>parte-entonces</dfn> (then-part).</p>
<p>Ademas, cuando se escribe una expresión <code>if</code>, la prueba-verdadero-o-falso normalmente se escribe en la misma línea que el símbolo <code>if</code>, pero la acción a llevar a cabo si la prueba es verdadera, “parte-entonces”, se escribe en la segunda y suguientes líneas. Esto hace que la expresión <code>if</code> sea mas fácil de leer.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-el-test-es-cierto</span><span class="p">)</span>
</code></pre>
<p>La prueba-verdadero-o-falso es una expresión que evalua el intérprete Lisp.</p>
<p>Aquí hay un ejemplo que puedes evaluar. La prueba consiste en si el número 5 es mayor que el número 4. Ya que es asi, se imprime el mensaje <samp>¡5 es mayor que 4!</samp>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>                           <span class="c1">; parte-si</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡5 es mayor que 4!&#34;</span><span class="p">))</span>   <span class="c1">; parte-entonces</span>
</code></pre>
<p>(La función <code>&gt;</code> comprueba si su primer argumento es mayor que su segundo argumento y devuelve verdadero si lo es.)</p>
<p>Por supuesto, en un caso real, la prueba en una expresión <code>if</code> no será siempre la misma, como en la expresión <code>(&gt; 5 4)</code>. En su lugar, al menos una de las variables utilizadas en la prueba estara unida a un valor de antemano desconocido. (Si el valor se conociera de antemano, ¡no necesitariamos realizar la prueba!)</p>
<p>Por ejemplo, el valor puede estar unido a un argumento de una definición de función. En la siguiente definición de función, el tipo de animal es un valor que se pasa a la función. Si el valor unido a <code>caracteristica</code> es <code>fiero</code>, entonces se imprime el mensaje, <samp>¡Es un tigre!</samp>; de otro modo, se devolvera <code>nil</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&#34;Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
</span><span class="s">Si la CARACTERISTICA es el símbolo ‘fiero’,
</span><span class="s">entonces advierte que es un tigre.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Es un tigre!&#34;</span><span class="p">)))</span>
</code></pre>
<p>Si estás leyendo esto dentro de GNU Emacs, puedes evaluar la definición de función de la forma habitual para instalarlo en Emacs, y luego puedes evaluar las dos expresiones siguientes para ver los resultados:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;fiero</span><span class="p">)</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;cebra</span><span class="p">)</span>
</code></pre>
<p>Al evaluar <code>(tipo-de-animal &#39;fiero)</code>, veras el siguiente mensaje impreso en el área eco: <code>&#34;¡Es un tigre!&#34;</code>; y cuando se evalúa <code>(tipo-de-animal &#39;cebra)</code> verás <code>nil</code> impreso en el área de eco.</p>
</div>
<h4 id="la-función-tipo-de-animal-en-detalle" >La función <code>tipo-de-animal</code> en detalle</h4>
<div class="hBody-4" >
<p>Veamos la función <code>tipo-de-animal</code> en detalle.</p>
<p>La definición de función <code>tipo-de-animal</code> se escribio llenando los espacios de dos plantillas, la primera para la definición de función como un todo, y la segunda para una expresión <code>if</code>.</p>
<p>La plantilla para cada función no interactiva es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Las partes de la función que coinciden con esta plantilla tienen este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&#34;Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
</span><span class="s">     Si la CARACTERISTICA es el símbolo ‘fiero’,
</span><span class="s">     entonces advierte que es un tigre.&#34;</span>
  <span class="nv">cuerpo:</span> <span class="nv">la</span> <span class="nv">expresion</span> <span class="nb">if</span><span class="p">)</span>
</code></pre>
<p>El nombre de función es <code>tipo-de-animal</code>; se pasa al valor de un argumento. A la lista de argumentos le sigue una cadena de documentación multilínea. La cadena de documentación se incluiye en el ejemplo porque es un buen hábito escribir un cadena de documentación para cada definición de función. El cuerpo de la definición de función consiste en la expresión <code>if</code>.</p>
<p>La plantilla para una expresión <code>if</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-la-prueba-devuelve-verdadero</span><span class="p">)</span>
</code></pre>
<p>En la función <code>tipo-de-animal</code>, el código para <code>if</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Es un tigre!&#34;</span><span class="p">)))</span>
</code></pre>
<p>Aquí, está la expresión prueba-verdadero-o-falso</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
</code></pre>
<p>En Lisp, <code>equal</code> es una función que determina si su primer argumento es igual al segundo. El segundo argumento es el símbolo citado <code>&#39;fiero</code> y el primer argumento es el valor del símbolo <code>característica</code>––en otras palabras, el argumento pasado a esta función.</p>
<p>En la primer prueba de <code>tipo-de-animal</code>, el argumento <code>fiero</code> se pasa a <code>tipo-de-animal</code>. Ya que <code>fiero</code> es igual a <code>fiero</code>, la expresión, <code>(equal caracteristica &#39;fiero)</code>, devuelve el valor verdadero. Cuando esto sucede, <code>if</code> evalúa el segundo argumento o la parte-entonces del <code>if</code>: <code>(message &#34;¡Es un tigre!&#34;)</code>.</p>
<p>Por otro lado, en la segunda prueba de <code>tipo-de-animal</code>, se pasa el argumento <code>cebra</code> a <code>tipo-de-animal</code>. <code>cebra</code> no es igual a <code>fiero</code>, por lo que la parte-entonces no se evalua y la expresión <code>if</code> devuelve <code>nil</code>).</p>
</div>
<h3 id="expresiones-if–then–else" >Expresiones if–then–else</h3>
<div class="hBody-3" >
<p>Una expresión <code>if</code> puede tener un tercer argumento opcional, llamado <dfn>else-part</dfn> (parte-de-otro-modo), en caso de que la prueba-verdadero-o-falso devuelva falso. Cuando esto sucede, el segundo argumento o parte-entonces de la expresión <code>if</code> global <em>no</em> se evalúa, pero el tercer argumento o parte-de-otro-modo <em>se</em> evalúa. Podría pensar en esto como la alternativa del día nublado para la decisión “si es cálido y soleado, entonces ir a la playa!, de otro modo leer un libro!”</p>
<p>La palabra “else” (de otro modo) no se escribe en el código Lisp; la parte-de-otro-modo de una expresión <code>if</code> viene después de la parte-entonces. En Lisp, la parte-de-otro-modo suele escribirse al inicio de una nueva linea y se indenta menos que la parte-entonces:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-la-prueba-devuelve-verdadero</span>
  <span class="nv">accion-a-realizar-si-la-prueba-devuelve-falso</span><span class="p">)</span>
</code></pre>
<p>Por ejemplo, la siguiente expresión <code>if</code> imprime el mensaje <samp>¡4 no es mayor que 5!</samp> al evaluarse en la forma habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>                                   <span class="c1">; parte-if</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡4 falsamente es mayor que 5!&#34;</span><span class="p">)</span> <span class="c1">; parte-then</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡4 no es mayor que 5!&#34;</span><span class="p">))</span>          <span class="c1">; parte-else</span>
</code></pre>
<p>Tenga en cuenta que los diferentes niveles de indentación hacen fácil distinguir la parte-entonces de la parte-de-otro-modo. (GNU Emacs tiene varios comandos que indentan expresiones <code>if</code> automáticamente. Vea la Seccion <a href="#gnu-emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</a>.)</p>
<p>Podemos ampliar la función <code>tipo-de-animal</code> para incluir una parte-else simplemente incorporando una parte adicional para la expresión <code>if</code>.</p>
<p>Puedes ver las consecuencias de hacer esto si evalúas la siguiente versión de la definición de función <code>tipo-de-animal</code> y luego evaluas las dos expresiones siguientes que pasan diferentes argumentos a la función.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&#34;Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
</span><span class="s">Si la CARACTERISTICA es el símbolo ‘fiero’,
</span><span class="s">entonces advierte que es un tigre.
</span><span class="s">de otro modo decir que no es fiero&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Es un tigre!&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;!No es feroz!&#34;</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;fiero</span><span class="p">)</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;cebra</span><span class="p">)</span>
</code></pre>
<p>Al evalar <code>(tipo-de-animal &#39;fiero)</code>, verás el siguiente mensaje en el área de eco: <code>&#34;¡Es un tigre!&#34;</code>; pero cuando evalues <code>(tipo-de-animal &#39;cebra)</code>, verás <code>&#34;¡No es feroz!&#34;</code>.</p>
<p>(Por supuesto, si <code>característica</code> fuera <code>muy feroz</code>, se imprimiria el mensaje <code>&#34;¡No es feroz!&#34;</code>; ¡y sería un error!  Cuando escribas código, necesitas tener en cuenta la posibilidad de que algun argumento como este será puesto a prueba por <code>if</code> y acorde a ello escribir tu programa.</p>
</div>
<h3 id="verdad-y-falsedad-en-emacs-lisp" >Verdad y Falsedad en Emacs Lisp</h3>
<div class="hBody-3" >
<p>Hay un aspecto importante para la prueba verdadero en una expresión <code>if</code>. Hasta ahora, hemos hablado de ‘verdadero’ y ‘falso’ como valores de predicados como si fueran nuevos tipos de objetos Emacs Lisp. De hecho, solo nuestro viejo amigo <code>nil</code> es ‘falso’. Cualquier otra cosa––cualquiera en absoluto––es ‘verdadero’.</p>
<p>La expresión que prueba si es verdadero se interpreta como <dfn>true</dfn> (verdadero) si el resultado de la evaluacion es no <code>nil</code>. En otras palabras, el resultado de la prueba se considera verdadero si el valor devuelto es un número como 47, una cadena como <code>&#34;hola&#34;</code>, o un símbolo (distinto a <code>nil</code>) como <code>flores</code>, o una lista (siempre y cuando no este vacía) o incluso ¡un búfer!</p>
<p>Antes de ilustrar una prueba para verdadero, necesitamos una explicación de <code>nil</code>.</p>
<p>En Emacs Lisp, el símbolo <code>nil</code> tiene dos significados. En primer lugar, significa que la lista está vacía. En segundo lugar, significa falso y es el valor devuelto cuando una prueba-verdadero-o-falso obtiene falso. <code>nil</code> puede escribirse como una lista vacia, <code>()</code>, o como <code>nil</code>. En lo referente al interprete Lisp <code>()</code> y <code>nil</code> son lo mismo. Los humanos, sin embargo, tienden a usar <code>nil</code> para falso y <code>()</code> para lista vacía.</p>
<p>En Emacs Lisp, cualquier valor que no sea <code>nil</code>––no es una lista vacía––se considera verdadero. Esto significa que si una evaluación devuelve algo que no es una lista vacía, una expresión <code>if</code> pondra la prueba a verdadero. Por ejemplo, si un número se coloca en el lugar de la prueba, se evaluara y devolverá su valor, ya que eso es lo que hacen los números cuando se evalúan. En esta condicion, la expresión <code>if</code> devuelve verdadero. La expresión devuelve falso solo cuando <code>nil</code>, o una lista vacía, son devueltas al evaluar la expresión.</p>
<p>Puedes ver esto evaluando las dos expresiones en los ejemplos siguientes.</p>
<p>En el primer ejemplo, el número 4 se evalua como la prueba en la expresión <code>if</code> y devuelve el numero en si; en consecuencia, se evalua y devuelve la parte-then de la expresión: aparece <samp>verdadero</samp> en el área de eco. En el segundo ejemplo, <code>nil</code> indica falso; en consecuencia, se evalua y devuelve la parte-else de la expresión: aparece <samp>falso</samp> en el área de eco.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="mi">4</span>
    <span class="ss">&#39;verdadero</span>
  <span class="ss">&#39;falso</span><span class="p">)</span>

<span class="p">(</span><span class="nb">if</span> <span class="no">nil</span>
    <span class="ss">&#39;verdadero</span>
  <span class="ss">&#39;falso</span><span class="p">)</span>
</code></pre>
<p>Por cierto, si algún otro valor de utilidad no está disponible para una prueba que devuelve verdadero, entonces el intérprete Lisp devolvera el símbolo <code>t</code> para verdadero. Por ejemplo, la expresión <code>(&gt; 5 4)</code> devuelve <code>t</code> cuando se evalúa, como puedes comprobar si evaluas:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Por otra parte, esta función devuelve <code>nil</code> si la prueba es falsa.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="save-excursion" ><code>save-excursion</code></h3>
<div class="hBody-3" >
<p>La función <code>save-excursion</code> es la cuarta y última forma especial que discutiremos en este capítulo.</p>
<p>En los programas Emacs Lisp utilizados para la edición, la función <code>save-excursion</code> es muy común. Guarda la posición del punto y marca, ejecuta el cuerpo de la función, y luego restaura el punto y marca a sus posiciones previas si sus posiciones fueron cambiadas. Su objetivo principal es impedir que el usuario se sorprenda y perturbe por el movimiento inesperado del punto o marca.</p>
<p>Sin embargo, antes de hablar de <code>save-excursion</code>, puede ser útil examinar primero que son el punto y la marca en GNU Emacs. <dfn>Punto</dfn> es la posición actual del cursor. Donde sea que se encuentre el cursor, estara el punto. De forma más precisa, en los terminales donde el cursor aparece sobre un carácter, el punto está inmediatamente antes del carácter. En Emacs Lisp, el punto es un numero entero. El primer carácter en un búfer es el número uno, el segundo es el número dos, y así sucesivamente. La función <code>point</code> devuelve la posición actual del cursor como un número. Cada búfer tiene su propio valor para el punto.</p>
<p>La <dfn>marca</dfn> es otra posición en el búfer; su valor se puede establecer con un comando como <kbd>C-SPC</kbd> (<code>set-mark-command</code>). Si una marca se ha establecido, puede utilizar el comando <kbd>C-x C-x</kbd> (<code>exchange-point-and-mark</code>) para hacer que el cursor salte a la marca y establecer la marca como la posición anterior del punto. Además, si se establece otra marca, la posición de la marca anterior se guarda en el anillo de marcas. De este modo puede guardar varias posiciones de la marca. Se puede mover el cursor a una marca guardada presionando <kbd>C-u C-SPC</kbd> una o más veces.</p>
<p>La parte del búfer entre el punto y la marca se llamada <dfn>la región</dfn>. Numerosos comandos trabajan en la región, incluyendo <code>center-region</code>, <code>count-lines-region</code>, <code>kill-region</code> y <code>print-region</code>.</p>
<p>La forma especial <code>save-excursion</code> guarda la ubicacion del punto y la marca y restaura estas posiciones después de que el interprete Lisp evalua el código dentro del cuerpo de la forma especial. De este modo, si el punto se encontraba al inicio de un trozo de texto y algún código desplazo el punto al final del búfer, <code>save-excursion</code> volvera a poner el punto donde estaba antes, luego que las expresiones en el cuerpo de la funcion sean evaluadas.</p>
<p>En Emacs, con frecuencia una función mueve el punto como parte de su funcionamiento interno a pesar de que un usuario no espere esto. Por ejemplo, <code>count-lines-region</code> mueve el punto. Para evitar que el usuario sea molestado por saltos inesperados y (desde el punto de vista del usuario) innecesarios, <code>save-excursion</code> se utiliza a menudo para conservar el punto y la marca en la posición esperada por el usuario. El uso de <code>save-excursion</code> es bueno para mantener el orden.</p>
<p>Para asegurarse que la casa se mantiene limpia, <code>save-excursion</code> restaura los valores del punto y la marca incluso si algo va mal en el código interno (o, para ser más preciso y usar el lenguaje tecnico apropiado, “en caso de salida anormal”). Esta funcionalidad es muy útil.</p>
<p>Además de registrar los valores del punto y marca, <code>save-excursion</code> registra el buffer actual, y lo restaura. Esto significa que puedes escribir código que cambie de bufer y <code>save-excursion</code> debe volver al bufer original. Asi es como se utiliza <code>save-excursion</code> en <code>append-to-buffer</code>. (Vea la Seccion <a href="#la-definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>.)</p>
</div>
<h4 id="plantilla-para-una-expresión-save-excursion" >Plantilla para una Expresión <code>save-excursion</code></h4>
<div class="hBody-4" >
<p>La plantilla de código usando <code>save-excursion</code> es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>El cuerpo de la función es una o más expresiones que serán evaluadas de forma secuencial por el intérprete Lisp. Si hay más de una expresión en el cuerpo, el valor de la última será devuelto como el valor de la función <code>save-excursion</code>. Las otras expresiones en el cuerpo solo se evaluan por sus efectos secundarios; y <code>save-excursion</code> en sí, solo se utiliza por su efecto secundario (que es restaurar las posiciones del punto y la marca).</p>
<p>La siguiente plantilla explica <code>save-excursion</code>, con más detalle:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">primera-expresion-en-el-cuerpo</span>
  <span class="nv">segunda-expresion-en-el-cuerpo</span>
  <span class="nv">tercera-expresion-en-el-cuerpo</span>
   <span class="err">…</span>
  <span class="nv">ultima-expresion-en-el-cuerpo</span><span class="p">)</span>
</code></pre>
<p>Una expresión, por supuesto, puede ser un símbolo por sí mismo o una lista.</p>
<p>En el código Emacs Lisp, una expresión <code>save-excursion</code> a menudo ocurre dentro del cuerpo de una expresión <code>let</code>. Se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="nv">varlist</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</code></pre>
</div>
<h3 id="repaso:-cómo-escribir-definiciones-de-funciones" >Repaso</h3>
<div class="hBody-3" >
<p>En los últimos capítulos se han introducido un buen número de funciones y formas especiales. A continuacion se describen brevemente, junto con algunas funciones similares que aun no se han mencionado.</p>
<dl>
<dt><code>eval-last-sexp</code></dt>
<dd>
<p>Evalúar la última expresión simbólica antes de la posición actual del punto. El valor se imprime en el área de eco a menos que la función se invoque con un argumento; en este caso, la salida se imprime en el búfer actual. Este comando normalmente esta asociado a <kbd>C-x C-e</kbd>.</p>
</dd>
<dt><code>defun</code></dt>
<dd>
<p>Define una función. Esta forma especial consta de hasta cinco partes: el nombre, una plantilla para los argumentos que se pasan a la función, la documentacion, una declaración interactiva opcional, y el cuerpo de la definición.</p>
<p>Por ejemplo, en las primeras versiones de Emacs, la definición de la función <code>back-to-indentation</code> era como sigue. (Eso es ligeramente más complejo ahora que se busca el primer caracter que no es espacio en lugar del primer caracter visible.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">back-to-indentation</span> <span class="p">()</span>
  <span class="s">&#34;Mueve el punto al primer caracter visible de la linea.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">beginning-of-line</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">skip-chars-forward</span> <span class="s">&#34; \t&#34;</span><span class="p">))</span>
</code></pre>
</dd>
<dt><code>interactive</code></dt>
<dd>
<p>Anuncia al intérprete que la función se puede usar de forma interactiva. Esta forma especial puede ir seguida de una cadena con una o más partes que pasan la información a los argumentos de la función, de forma secuencial. Estas partes pueden también decir al intérprete que solicite información. Las partes de la cadena estan separadas por saltos de linea, <samp>\n</samp>.</p>
<p>Los codigos de caractere comúnes son:</p>
<dl>
<dt><code>b</code></dt>
<dd>
<p>El nombre de un búfer existente.</p>
</dd>
<dt><code>f</code></dt>
<dd>
<p>El nombre de un fichero existente</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>El argumento prefijo numérico. (Tenga en cuenta que esta ‘p’ es minúscula.)</p>
</dd>
<dt><code>r</code></dt>
<dd>
<p>Punto y marca, como dos argumentos numéricos, el más pequeño primero. Este es el unico codigo de una letra que especifica dos argumentos sucesivos en lugar de uno.</p>
</dd>
</dl>
<p>Vea la Seccion <a href="info:elips#Interactive-Codes" >Codigo de caracteres para <samp>interactive</samp></a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para obtener una lista completa de los codigos de caracteres.</p>
</dd>
<dt><code>let</code></dt>
<dd>
<p>Declara una lista de variables para utilizarla dentro del cuerpo de <code>let</code> y darle a cada variable un valor inicial, ya sea <code>nil</code> o un valor específico; luego evaluar el resto de las expresiones en el cuerpo del <code>let</code> y devuelve el valor de la última expresion. Dentro del cuerpo del <code>let</code>, el intérprete Lisp no ve los valores de variables con el mismos nombre fuera de <code>let</code>.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">foo</span> <span class="p">(</span><span class="nf">buffer-name</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">bar</span> <span class="p">(</span><span class="nf">buffer-size</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&#34;Este buffer es %s y tiene %d caracteres.&#34;</span>
   <span class="nv">foo</span> <span class="nv">bar</span><span class="p">))</span>
</code></pre>
</dd>
<dt><code>save-excursion</code></dt>
<dd>
<p>Registra los valores de punto, marca y el búfer actual antes de evaluar el cuerpo de esta forma especial. Restaura los valores de punto, marca y el búfer luego de esto.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Estamos %d caracteres dentro de este buffer.&#34;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">save-excursion</span>
              <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</code></pre>
</dd>
<dt><code>if</code></dt>
<dd>
<p>Evalúa el primer argumento de la función; si es verdadero, evalúa el segundo argumento; de otra forma evalúa el tercer argumento, si lo hay.</p>
<p>La forma especial <code>if</code> se llamada <dfn>condicional</dfn>. Hay otros condicionales en Emacs Lisp, pero <code>if</code> es quizás el más comúnmente usado.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="mi">24</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Esta es la version 24 de Emacs&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Esta no es la version 24 de Emacs&#34;</span><span class="p">))</span>
</code></pre>
</dd>
<dt><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></dt>
<dd>
<p>La función <code>&lt;</code> prueba si su primer argumento es menor que su segundo argumento. <code>&gt;</code>, prueba si el primer argumento es mayor que el segundo. Del mismo modo, <code>&lt;=</code> prueba si el primer argumento es menor o igual al segundo y <code>&gt;=</code> si el primer argumento es mayor o igual al segundo. En todos los casos, ambos argumentos deben ser números o marcadores (los marcadores indican posiciones en búfers).</p>
</dd>
<dt><code>=</code></dt>
<dd>
<p>La función <code>=</code> prueba si dos argumentos, ambos números o marcadores, son iguales.</p>
</dd>
<dt><code>equal</code>, <code>eq</code></dt>
<dd>
<p>Prueba si dos objetos son el mismo. <code>equal</code> utiliza un signicado de la palabra ‘mismo’ y <code>eq</code> utiliza otro: <code>equal</code> devuelve verdadero si los dos objetos tienen una estructura y contenidos similares, por ejemplo, dos copias del mismo libro. Por otro lado, <code>eq</code>, devuelve verdadero si ambos argumentos son realmente el mismo objeto.</p>
</dd>
<dt><code>string&lt;</code>, <code>string-lessp</code>, <code>string=</code>, <code>string-equal</code></dt>
<dd>
<p>La función <code>string-lessp</code> prueba si su primer argumento es menor que el segundo. Un nombre alternativo mas corto para la misma función (un <code>defalias</code>) es <code>string&lt;</code>.</p>
<p>Los argumentos para <code>string-lessp</code> deben ser cadenas o símbolos; la ordenación es lexicográfica, por lo que mayusculas o minusculas son significativas. Los nombres impresos de símbolos se utilizan en lugar de los símbolos mismos.</p>
<p>Una cadena vacía, <samp>&#34;&#34;</samp>, una cadena sin caracteres en ella, es más pequeña que cualquier cadena de caracteres.</p>
<p><code>string-equal</code> proporciona la prueba correpondiente para la igualdad. Su nombre alternativo es <code>string=</code>. No hay funciones de prueba que correspondan a <code>&gt;</code>, <code>&gt;=</code> o <code>&lt;=</code>.</p>
</dd>
<dt><code>message</code></dt>
<dd>
<p>Imprime un mensaje en el área de eco. El primer argumento es una cadena que puede contener, <samp>%s</samp>, <samp>%d</samp>, o <samp>%c</samp> para imprimir el valor de los argumentos que siguen a la la cadena. El argumento utilizado por <samp>%s</samp> debe ser una cadena o un simbolo, el argumeto utilizado por <samp>%d</samp> debe ser un número. El argumento usado por <samp>%c</samp> debe ser un codigo númerico <em>ASCII</em>; se imprimira como el caracter con este código <em>ASCII</em>. (No se han mencionado otras secuencias <q>porcentuales</q> <code>%-</code>).</p>
</dd>
<dt><code>setq</code>, <code>set</code></dt>
<dd>
<p>La función <code>setq</code> asigna al valor de su primer argumento el valor del segundo argumento. El primer argumento se cita automáticamente por <code>setq</code>. Hace lo mismo para los pares sucesisvos de argumentos. Otra función, <code>set</code>, toma solo dos argumentos y evalúa ambos antes de asignar el valor devuelto por su primer argumento al valor devuelto por el segundo argumento.</p>
</dd>
<dt><code>buffer-name</code></dt>
<dd>
<p>Sin un argumento, devuelve el nombre del búfer, como una cadena.</p>
</dd>
<dt><code>buffer-file-name</code></dt>
<dd>
<p>Sin un argumento, devuelve el nombre del fichero del búfer que se esta visitando.</p>
</dd>
<dt><code>current-buffer</code></dt>
<dd>
<p>Devuelve el búfer en el que Emacs se encuentra activo; Puede que no sea el búfer que es visible en la pantalla.</p>
</dd>
<dt><code>other-buffer</code></dt>
<dd>
<p>Devuelve el ultimo búfer seleccionado mas recientemente (distinto del buffer pasado a <code>other-buffer</code> como un argumento y distinto del búfer actual).</p>
</dd>
<dt><code>switch-to-buffer</code></dt>
<dd>
<p>Selecciona un búfer de Emacs para activarlo y mostralo en la ventana actual para que los usuarios puedan verlo. Normalmente ligado a <kbd>C-x b</kbd>.</p>
</dd>
<dt><code>set-buffer</code></dt>
<dd>
<p>Cambiar la atención de Emacs a un búfer en el que se ejecutaran programas. No altera lo que la ventana está mostrando.</p>
</dd>
<dt><code>buffer-size</code></dt>
<dd>
<p>Devuelve el número de caracteres en el búfer actual.</p>
</dd>
<dt><code>point</code></dt>
<dd>
<p>Devuelve el valor de la posicion actual del cursor, como un entero contando el número de caracteres desde el inicio del búfer.</p>
</dd>
<dt><code>point-min</code></dt>
<dd>
<p>Devuelve el valor mínimo admisible del punto en el búfer actual. Esto es 1, a menos que narrowing esté activo</p>
</dd>
<dt><code>point-max</code></dt>
<dd>
<p>Devuelve el valor máximo admisible del punto en el búfer actual. Este es el fin del búfer, a menos que narrowing este activo.</p>
</dd>
</dl>
</div>
<h3 id="ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función no interactiva que duplique el valor de su argumento, un número. Luego haz la función interactiva.</p>
</li>
<li>
<p>Escribe una función que compruebe si el valor actual de <code>fill-column</code> es mayor que el argumento pasado a la función, y si es así, imprime un mensaje apropiado.</p>
</li>
</ul>
</div>
<h2 id="algunas-funciones-relacionadas-al-bufer" >Algunas funciones relacionadas al bufer</h2>
<div class="hBody-2" >
<p>En este capítulo estudiamos en detalle varias de las funciones usadas en GNU Emacs. Esto se denomina un “recorrido” (visita o demostracion de un area o tarea). Estas funciones se utilizan como ejemplos de código Lisp, pero no son ejemplos imaginarios; con excepción del primero, con la definición de función simplificada, estas funciones muestran el código real usado en GNU Emacs. Se puede aprender mucho de estas definiciones. Las funciones descritas aquí están todas relacionadas a búfers. Mas tarde, estudiaremos otras funciones.</p>
</div>
<h3 id="encontrar-más-información" >Encontrar Más información</h3>
<div class="hBody-3" >
<p>En este recorrido, describire cada nueva función, algunas veces en detalle y algunas veces brevemente. Si estás interesado, puedes obtener la documentación completa de cualquier función de Emacs Lisp en cualquier momento presiona <kbd>C-h f</kbd> y luego escribe el nombre de la función (y luego <kbd>RET</kbd>). Del mismo modo, se puede obtener la documentación completa de una variable con <kbd>C-h v</kbd>, luego el nombre de la variable (y despues <kbd>RET</kbd>).</p>
<p>Ademas, <code>describe-function</code> te dira la ubicacion de la definición de la función.</p>
<p>Coloca el punto dentro del nombre del fichero que contiene la función y presiona la tecla <kbd>RET</kbd>. En este caso, <kbd>RET</kbd> significa <code>push-button</code> en lugar de ‘return’ o ‘enter’. Emacs te llevara directamente a la definición de la función.</p>
<p>De manera más general, si quieres ver una función en su fichero fuente original, puedes utilizar la función <code>find-tag</code> para saltar a la misma. <code>find-tag</code> trabaja con una amplia variedad de lenguajes, no solo Lisp, y C, y tambien funciona con texto en general. Por ejemplo, <code>find-tag</code> saltará a los distintos nodos del codigo fuente de este documento. La función <code>find-tag</code> depende de ‘tablas de etiquetas’ que registran las ubicaciones de las funciones, variables, y otros elementos a los que <code>find-tag</code> salta.</p>
<p>Para usar el comando <code>find-tag</code>, presiona <kbd>M-.</kbd> (es decir, presiona la tecla punto mientras presionas la tecla <kbd>META</kbd>, o presiona <kbd>ESC</kbd> y luego la tecla punto), a continuacion, en el prompt, escribe el nombre de la función para ver su código fuente, por ejemplo <code>mark-whole-buffer</code>, y luego pulsa <kbd>RET</kbd>. Emacs cambiará de búfer y mostrará el código fuente de la función en la pantalla. Para regresar a tu búfer actual, presiona <kbd>C-x b RET</kbd>. (En algunos teclados, la tecla <kbd>META</kbd> se etiqueta como <kbd>ALT</kbd>.)</p>
<p>Dependiendo de la configuracion de los valores iniciales por defecto de tu copia de Emacs, puede ser necesario especificar la posición de tu ‘tabla de etiquetas’, que es un fichero llamado <span class="file" >TAGS</span>. Por ejemplo, si estás interesado en el codigo fuente de Emacs, la tabla de etiquetas, si ya ha sido creada, estará en un subdirectorio del directorio <span class="file" >/usr/local/share/emacs</span>; de este modo se usaría el comando <code>M-x visit-tags-table</code> y se especifica una ruta como <span class="file" >/usr/local/share/emacs/24.1.1/lisp/TAGS</span>. Si la tabla de etiquetas no ha sido creada, tendrás que crearla por tí mismo. Estara en un fichero como <span class="file" >/usr/local/src/emacs/src/TAGS</span>.</p>
<p>Para crear un fichero <span class="file" >TAGS</span> en un directorio específico, cambia a ese directorio en Emacs mediante el comando <kbd>M-x cd</kbd>, o lista el directorio con <kbd>C-x d</kbd> (<code>dired</code>). A continuacion ejecuta el comando de compilacion, con <code>etags *.el</code> como:</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags *.el RET
</pre>
</div>
<p>Para más información, ver la Seccion <a href="#crea-tu-propio-fichero-tags" >Crea tu propio fichero <span class="file" >TAGS</span></a>.</p>
<p>Después de te familiarices con Emacs Lisp, te encontrarás con frecuencia utilizando <code>find-tag</code> como metodo de navegar atraves del código fuente; y crearás tus propias tablas <span class="file" >TAGS</span>.</p>
<p>Por cierto, los ficheros que contienen código Lisp son llamados convencionalmente <dfn>librerías</dfn>. La metáfora se deriva que una librería especializada, tal como una librería de leyes o una librería de ingeniería, en lugar de una librería general. Cada librería, o fichero, contiene funciones que se relacionan con un tema o actividad particular, por ejemplo <span class="file" >abbrev.el</span> para el manejo de abreviaturas y otros atajos, y <span class="file" >help.el</span> para ayuda en linea. (Algunas veces varias librerías proporcionan código para una sola actividad, como los distintos ficheros <span class="file" >rmail…</span>  que proporcionan codigo para leer correo electrónico.) En <em>El Manual de GNU Emacs</em>, verás varias frases como “El comando <kbd>C-h p</kbd> te permite buscar las librerias estándar de Emacs Lisp por la palabra clave del tema.</p>
</div>
<h3 id="una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></h3>
<div class="hBody-3" >
<p>El comando <code>beginning-of-buffer</code> es una buena función para empezar, ya que es probable que estes familiarizado con ella y es fácil de entender. Usado como un comando interactivo, <code>beginning-of-buffer</code> mueve el cursor al inicio del búfer, dejando la marca en la posición anterior. Esta generalmente unido a <kbd>M-&lt;</kbd>.</p>
<p>En esta sección, vamos a hablar de una versión reducida de la función que muestra como se utiliza con mayor frecuencia. Esta función reducida funciona como esta escrita, pero no contiene código para una opcion compleja. En otra sección, describiremos la función entera. (Vea la Seccion <a href="#definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></a>.</p>
<p>Antes de mirar el código, vamos a considerar lo que la definición de función tiene que contener: debe incluir una expresión que haga la función interactiva por lo que se puede llamar escribiendo <kbd>M-x beginning-of-buffer</kbd> o pulsando algun atajo como <kbd>M-&lt;</kbd>; debe incluir código para dejar una marca en la posición original del búfer; y debe incluir código para mover el cursor al inicio del búfer.</p>
<p>Aquí está el texto completo la versión reducida de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">simplified-beginning-of-buffer</span> <span class="p">()</span>
  <span class="s">&#34;Mover el punto al inicio del buffer;
</span><span class="s">deja la marca en la posicion anterior.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
</code></pre>
<p>Al igual que todas las definiciones de función, esta definición tiene cinco partes siguiendo la forma especial <code>defun</code>:</p>
<ol class="num" >
<li>
<p>El nombre: en este ejemplo, <code>simplified-beginning-of-buffer</code>.</p>
</li>
<li>
<p>Una lista de los argumentos: en este ejemplo, una lista vacía, <code>()</code>,</p>
</li>
<li>
<p>La cadena de documentación.</p>
</li>
<li>
<p>La expresión interactiva.</p>
</li>
<li>
<p>El cuerpo.</p>
</li>
</ol>
<p>En esta definición de función, la lista de argumentos está vacía; esto significa que esta función no requiere ningun argumento. (Cuando nos fijamos en la definición de la función completa, veremos que se puede pasar un argumento opcional.)</p>
<p>La expresión interactiva le informa a Emacs que se pretende utilizar la función de forma interactiva. En este ejemplo, <code>interactive</code> no tiene un argumento porque <code>simplified-beginning-of-buffer</code> no requiere uno.</p>
<p>El cuerpo de la función consiste de dos líneas:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
</code></pre>
<p>La primera de estas líneas es la expresión, <code>(push-mark)</code>. Cuando el interprete Lisp evalua esta expresión, se establece una marca en la posición actual del cursor, donde sea que este. La posición de esta marca se guarda en el anillo de marcas.</p>
<p>La siguiente línea es <code>(goto-char (point-min))</code>. Esta expresión hace saltar el cursor hasta el punto mínimo en el búfer, es decir, al inicio del búfer (o al inicio de la porción accesible del búfer si narrowed esta activo. Vea la Seccion <a href="#reducir-y-extender" >Reducir y Extender</a>.)</p>
<p>El comando <code>push-mark</code> establece una marca en el sitio donde se encontraba el cursor antes de que la expresion expresión <code>(goto-char (point-min))</code> lo moviera al principio del bufer. En consecuencia, puedes, si quieres, volver a donde estabas originalmente presionando <kbd>C-x C-x</kbd>.</p>
<p>¡Esto es todo lo que hay en la definición de función!</p>
<p>Cuando leas código como este y te encuentres con una función desconocida, como <code>goto-char</code>, puedes averiguar que es lo que hace mediante el comando <code>describe-function</code>. Para usar este comando, presiona <kbd>C-h f</kbd> y luego escribe el nombre de la función y presiona <kbd>RET</kbd>. El comando <code>describe-function</code> imprimirá la cadena de documentacion de la función en una ventana <span class="file" >*Help*</span>. Por ejemplo, la documentación de <code>goto-char</code> es:</p>
<div class="example-block" >
<pre class="example" >Establece el punto a POSICION, un numero o marcador.
El inicio del buffer es la posicion (point-min), el final es (point-max).
</pre>
</div>
<p>El argumento de la función es la posición deseada.</p>
<p>(En el caso de <code>describe-function</code> el prompt te facilita el símbolo adelante o anterior al cursor, lo que te puede evitar escribir el nombre de la funcion al colocar el cursor encima o después de la función y luego presionando <kbd>C-h f RET</kbd>.)</p>
<p>La definición de la función <code>end-of-buffer</code> se escribe de la misma forma que la definición <code>beginnig-of-buffer</code> excepto que el cuerpo de la función contiene la expresión <code>(goto-char (point-max))</code> en lugar de <code>(goto-char (point-min))</code></p>
</div>
<h3 id="la-definición-de-mark-whole-buffer" >La definición de <code>mark-whole-buffer</code></h3>
<div class="hBody-3" >
<p>La función <code>mark-whole-buffer</code> no es mas difícil de entender que la función <code>simplified-beginning-of-buffer</code>. En este caso, sin embargo, vamos a ver la función completa, no una versión reducida.</p>
<p>La función <code>mark-whole-buffer</code> no se utiliza tan comúnmente como la función <code>beginning-of-buffer</code>, pero no es menos útil: marca un búfer completo como una región colocando el punto al inicio y una marca al fin del búfer. Generalmente se enlaza a <kbd>C-x h</kbd>.</p>
<p>En GNU Emacs 22, el código de la función completa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">mark-whole-buffer</span> <span class="p">()</span>
  <span class="s">&#34;Coloca el punto al inicio y marca el fin del buffer.
</span><span class="s">Probablemente no deberias utilizar esta funcion en programas Lisp;
</span><span class="s">Por lo general es un error que una funcion Lisp utilice cualquier subrutina
</span><span class="s">que utiliza o establece la marca.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
</code></pre>
<p>Al igual que todas las demas funciones, la función <code>mark-whole-buffer</code> encaja dentro de la plantilla de una definición de funcion. La plantilla luce asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nv">expresion-interactiva</span><span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Asi es cómo funciona la función: el nombre de la función es <code>mark-whole-buffer</code>; le sigue una lista de argumentos vacía, <samp>()</samp>, lo que significa que la función no requiere argumentos. La documentación viene despues.</p>
<p>La siguiente línea es una expresión <code>(interactive)</code> que indica a Emacs que la función se utilizara de forma interactiva. Estos detalles son similares a la función <code>simplified-beginning-of-buffer</code> descrita en la sección anterior</p>
</div>
<h4 id="cuerpo-de-mark-whole-buffer" >Cuerpo de <code>mark-whole-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>mark-whole-buffer</code> consiste en tres líneas de código:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
<span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
</code></pre>
<p>La primera de estas líneas es la expresión, <code>(push-mark (point))</code>.</p>
<p>Esta línea hace exactamente el mismo trabajo que la primera línea del cuerpo de la función <code>simplified-beginning-of-buffer</code>, en la que solo se escribe <code>(push-mark)</code>. En ambos casos, el intérprete Lisp coloca una marca en la posición actual del cursor.</p>
<p>No sé por qué en la expresión <code>mark-whole-buffer</code> se escribe <code>(push-mark (point))</code> y en la expresión <code>beginning-of-buffer</code> se escribe <code>(push-mark)</code>. Quizás quien escribió el código no conocia que los argumentos de <code>push-mark</code> son opcionales y que si no se pasa un argumento a <code>push-mark</code>, la función establece automáticamente la marca en la posicion del punto por defecto. O quizás la expresión fué escrita paralelamente a la estructura de la siguiente línea. En cualquier caso, la línea proboca que Emacs determine la posición del punto y coloque una marca allí.</p>
<p>En versiones anteriores de GNU Emacs, la siguiente línea de <code>mark-whole-buffer</code> era <code>(push-mark (point-max))</code>. Esta expresión establece una marca en el punto del búfer que tiene el número más alto. Este será el final del búfer (o, si el búfer tiene activo narrowing, el final de la porción accesible del búfer. Vea la Seccion <a href="#reducir-y-extender" >Reducir y Extender</a>, para más informacion sobre norrowing). Después de colocar esta marca, la marca anterior, la establecida en el punto, ya no esta configurada, pero Emacs recuerda su posición, al igual que todas las otras marcas recientes. Esto significa que, si lo deseas, puedes volver a esta posición presionando <kbd>C-u C-SPC</kbd> dos veces.</p>
<p>En GNU Emacs 22, <code>(point-max)</code> es ligeramente más complicado. La línea es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>La expresión funciona casi igual que antes. Se establece una marca en la posicion con el numero mas alto posible en el búfer. Sin embargo, en esta versión, <code>push-mark</code> tiene dos argumentos adicionales. El segundo argumento de <code>push-mark</code> es <code>nil</code>. Esto le indica a la función que debe <em>mostrar</em> un mensaje que dice ‘Mark set’ cuando se coloca la marca. El tercer argumento es <code>t</code>. Esto indica a <code>push-mark</code> que active la marca cuando el modo Transient Mark está activo. Transient Mark mode resalta la región activa. Con frecuencia esta desactivado.</p>
<p>Finalmente, la última línea de la función es <code>(goto-char (point-min))</code>. Esta escrito exactamente de la misma forma como está escrito <code>beginning-of-buffer</code>. La expresión mueve el cursor al punto mínimo en el búfer, es decir, al inicio del búferr (o al inicio de la porción accesible del búfer). Como resultado de esto, punto se coloca al inicio del búfer y la marca se encuentra al final del búfer. Por tanto, todo el búfer es la región.</p>
</div>
<h3 id="la-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></h3>
<div class="hBody-3" >
<p>El comando <code>append-to-buffer</code> es más complejo que el comando <code>mark-whole-buffer</code>. Lo que hace es copiar la región (es decir, la parte del búfer entre el punto y la marca) del buffer actual a un búfer específico.</p>
<p>El comando <code>append-to-buffer</code> utiliza la función <code>insert-buffer-substring</code> para copiar la región. <code>insert-buffer-substring</code> se describe por su nombre: toma una cadena de caracteres de una parte de un búfer, una “subcadena”, y la inserta en otro búfer.</p>
<p>La mayor parte de <code>append-to-buffer</code> tiene que ver con el establecimiento de las condiciones para que <code>insert-buffer-substring</code> funcione: el código debe especificar tanto el búfer al que ira el texto, la ventana fuente y destino, y la región que será copiada.</p>
<p>Aquí está el texto completo de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Agregar a un buffer especifico el texto de la region.
</span><span class="s">Este se inserta en ese buffer antes de su punto.
</span><span class="s">
</span><span class="s">Cuando se llama desde un programa, se pasan tres argumentes:
</span><span class="s">BUFFER (o nombre del buffer), START y END.
</span><span class="s">START y END especifican la porcion del buffer actual a copiar.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span>
   <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">read-buffer</span> <span class="s">&#34;Agregar al buffer: &#34;</span> <span class="p">(</span><span class="nf">other-buffer</span>
                                            <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">region-beginning</span><span class="p">)</span> <span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">append-to</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">windows</span> <span class="p">(</span><span class="nv">get-buffer-window-list</span> <span class="nv">append-to</span> <span class="no">t</span> <span class="no">t</span><span class="p">))</span>
             <span class="nf">point</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">append-to</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nf">point</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">window</span> <span class="nv">windows</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">window-point</span> <span class="nv">window</span><span class="p">)</span> <span class="nf">point</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">set-window-point</span> <span class="nv">window</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))))))</span>
</code></pre>
<p>Se puede entender la función si se mira como una serie de plantillas rellenas.</p>
<p>La plantilla exterior es para la definición de función. Esta función, se ve como asi (con varios espacios ocupados):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>La primer línea de la función incluye su nombre y tres argumentos. Los argumentos son el <code>búfer</code> al cual copiar el texto, <code>start</code> y <code>end</code> que son el inicio y el fin de la región del buffer actual desde donde se va a copiar.</p>
<p>La siguiente parte de la función es la documentación, que es clara y completa. Como es convencional, los tres argumentos estan escritos en mayúsculas para que los notes con facilidad. Aun mejor, se describen en el mismo orden que en la lista de argumentos.</p>
<p>Observe que la documentación distingue entre un búfer y su nombre. (La función puede manejar cualquiera.)</p>
</div>
<h4 id="la-expresión-interactiva-append-to-buffer" >La expresión interactiva <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>Ya que la función <code>append-to-buffer</code> se puede utilizar de forma interactiva, la función debe tener una expresión <code>interactive</code>. (Para una analisis de <code>interactive</code>, ve la seccion <a href="#crear-una-función-interactiva" >Crear una función interactiva</a>.)  La expresión se lee de la siguiente manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span>
 <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">read-buffer</span>
        <span class="s">&#34;Agregar al buffer: &#34;</span>
        <span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">region-beginning</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
</code></pre>
<p>Esta expresión no tiene letras para representar partes, como se describio anteriormente. En su lugar, inicia una lista con estas partes:</p>
<p>La primer parte de la lista es una expresión para leer el nombre de un búfer y devolverlo como una cadena. Es decir <code>read-buffer</code>. La función requiere un prompt como primer argumento, <samp>&#34;Agregar al buffer: &#34;</samp>. El segundo argumento le indica al comando que valor proporcionar si no se especifica nada.</p>
<p>En este caso este segundo argumento es una expresión que contiene la función <code>other-buffer</code>, una excepción, y una <samp>t</samp>, para representar verdadero.</p>
<p>El primer argumento de <code>other-buffer</code>, la excepción, es otra función, <code>current-buffer</code>. Esto no va a ser devuelto. El segundo argumento es el símbolo de verdadero, <code>t</code>. Que le dice a <code>other-buffer</code> que puede mostrar búfers visibles (excepto en este caso, no se mostrará el búfer actual, lo cual tiene sentido).</p>
<p>La expresión se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>El segundo y tercer argumento de la expresión <code>list</code> son <code>(region-beginning)</code> y <code>(region-end)</code>. Estas dos funciones especifican el inicio y el final del texto que se añade</p>
<p>Originalmente, el comando utilizaba las letras <samp>B</samp> y <samp>r</samp>. Toda la expresión <code>interactive</code> se veia así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;BAppend to buffer: \nr&#34;</span><span class="p">)</span>
</code></pre>
<p>Pero cuando se hacia esto, el valor por defecto del búfer de cambió era invisible. Esto no era lo que se queria.</p>
<p>(El prompt se separo del segundo argumento con una línea nueva, <samp>\n</samp>. Seguido por un <samp>r</samp> que le indica a Emacs unir los dos argumentos que siguen al símbolo <code>buffer</code> en la lista de argumentos de la función (es decir, <code>start</code> y <code>end</code>) a los valores del punto y marca. Este argumento funcionaba bien.)</p>
</div>
<h4 id="el-cuerpo-de-append-to-buffer" >El cuerpo de <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>append-to-buffer</code> inicia con <code>let</code>.</p>
<p>Como hemos visto antes (ver Seccion <a href="#let" ><code>let</code></a>), el propósito de una expresión <code>let</code> es crear y dar valores iniciales a una o más variables que solo se usaran dentro del cuerpo del <code>let</code>. Esto significa que esa variable no se debe confundir con cualquier variable del mismo nombre fuera de la expresión <code>let</code>.</p>
<p>Podemos ver como la expresión <code>let</code> encaja en la función como un todo mostrando una plantilla de <code>append-to-buffer</code> con la expresión <code>let</code> en general:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="err">…</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">))</span>
        <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>La expresión <code>let</code> tiene tres elementos:</p>
<ol class="num" >
<li>
<p>El símbolo <code>let</code>;</p>
</li>
<li>
<p>Una varlist que contiene, en este caso, una unica lista de dos elementos, <code>(variable valor)</code>;</p>
</li>
<li>
<p>El cuerpo de la expresión <code>let</code>.</p>
</li>
</ol>
<p>En la función <code>append-to-buffer</code>, la varlist es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))</span>
</code></pre>
<p>En esta parte de la expresión <code>let</code>, la unica variable, <code>oldbuf</code> se une al valor devuelto por la expresión <code>(current-buffer)</code>. La variable, <code>oldbuf</code>, se utiliza para guardar un registro del búfer en el que estás trabajando y desde donde se copiara.</p>
<p>El elemento o elementos de una varlist esta rodeado por un conjunto de paréntesis por lo que el intérprete Lisp puede distinguir la varlist del cuerpo del <code>let</code>. Como consecuencia, la lista de dos elementos dentro de la varlist está rodeada por un conjunto circunscrito de paréntesis. La línea tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="err">…</span> <span class="p">)</span>
</code></pre>
<p>Los dos paréntesis antes de <code>oldbuf</code> podrían sorprenderte si no fuera porque el primer paréntesis marca el límite de la varlist y el segundo paréntesis marca el inicio de la lista de dos elementos, <code>(oldbuf (current-buffer))</code>.</p>
</div>
<h4 id="save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la expresión <code>let</code> dentro de <code>append-to-buffer</code> consiste de una expresión <code>save-excursion</code>.</p>
<p>La función <code>save-excursion</code> guarda las posiciones de punto y marca, y restaura estas posiciones después de que las expresiones en el cuerpo de <code>save-excursion</code> completan su ejecución. Además, <code>save-excursion</code> no pierde de vista el búfer original, y lo restaura. Asi es como se utizia <code>save-excursion</code> en <code>append-to-buffer</code>.</p>
<p>Por cierto, vale la pena señalar que una función Lisp normalmente se formatea de modo que todo lo que esta encerrado en un conjunto de multiples lineas se indente más a la derecha que el primer símbolo. En esta definición de función, <code>let</code> se indenta más que <code>defun</code>, y <code>save-excursion</code> se indenta más que <code>let</code>, asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="err">…</span>
  <span class="err">…</span>
  <span class="err">…</span>
  <span class="p">(</span><span class="nb">let</span><span class="err">…</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="err">…</span>
</code></pre>
<p>Esta convención de formato hace que sea fácil de ver que líneas en el cuerpo de <code>save-excursion</code> estan rodeadas por los parentesis asociados con <code>save-excursion</code>, de igual forma el mismo <code>save-excursion</code> esta rodeado por los paréntesis asociados con <code>let</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="err">…</span>
    <span class="p">(</span><span class="nf">set-buffer</span> <span class="err">…</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
    <span class="err">…</span><span class="p">))</span>
</code></pre>
<p>El uso de la función <code>save-excursion</code> puede ser visto como el proceso de llenar ranuras de una plantilla:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">primer-expresion-en-el-cuerpo</span>
  <span class="nv">segunda-expresion-en-el-cuerpo</span>
   <span class="err">…</span>
  <span class="nv">ultima-expresion-en-el-cuerpo</span><span class="p">)</span>
</code></pre>
<p>En esta función, el cuerpo de <code>save-excursion</code> contiene solo una expresión, la expresión <code>let*</code>. Ya conoces la función <code>let</code>. La función <code>let*</code> es diferente. Posee un <samp>*</samp> en su nombre. Esto le permite a Emacs colocar cada variable de su varlist en secuencia, una después de otra.</p>
<p>Su caracteristica fundamental es que las siguientes variables en la varlist puedan hacer uso de los valores establecidos por Emacs antes en la varlist. Vea la Seccion <a href="#la-expresión-let*" >La expresión <code>let*</code></a>.</p>
<p>Vamos a omitir funciones como <code>let*</code> y nos centraremos en dos: la función <code>set-buffer</code> y la función <code>insert-buffer-substring</code>.</p>
<p>En los viejos tiempos, la expresión <code>set-buffer</code> era simplemente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">))</span>
</code></pre>
<p>pero ahora es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">append-to</span><span class="p">)</span>
</code></pre>
<p><code>append-to</code> esta unido al <code>(get-buffer-create-buffer)</code> anterior en la expresión <code>let*</code>. Esta union extra no sería necesaria excepto que <code>append-to</code> se utiliza despues en la varlist como un argumento para <code>get-buffer-window-list</code>.</p>
<p>La definición de la función <code>append-to-buffer</code> inserta texto desde el búfer en el que te encuentras actualmente al buffer que se indique. Sucede que <code>insert-buffer-substring</code> copia texto desde otro búfer al búfer actual, justo al reves––es por ello que la definición <code>append-to-buffer</code> inicia con un <code>let</code> que une el símbolo local <code>oldbuf</code> al valor devuelto por <code>current-buffer</code>.</p>
<p>La expresión <code>insert-buffer-substring</code> es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
</code></pre>
<p>La función <code>insert-buffer-substring</code> copia una cadena <em>desde</em> el búfer especificado como su primer argumento e inserta la cadena dentro del búfer actual. En este caso, el argumento de <code>insert-buffer-substring</code> es el valor de la variable creada y vinculada por <code>let</code>, es decir, el valor de <code>oldbuf</code>, que era el búfer actual cuando diste el comando <code>append-to-buffer</code>.</p>
<p>Después de que <code>insert-buffer-substring</code> ha hecho su trabajo, <code>save-excursion</code> restaurará la acción al búfer original y <code>append-to-buffer</code> habrá hecho su trabajo.</p>
<p>Escrito en forma de esqueletal, los funcionamientos del cuerpo se ven asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">unir-oldbuf-al-valor-del-buffer-actual</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>                       <span class="c1">; guarda un registro del buffer.</span>
    <span class="nv">cambio-de-buffer</span>
    <span class="nv">insertar-subcadena-desde-oldbuf-a-buffer</span><span class="p">)</span>

  <span class="nv">regresar-al-buffer-original-al-terminar</span>
<span class="nv">dejar-que-el-siginificado-local-de-oldbuf-desaparacesca-al-terminar</span>
</code></pre>
<p>En resumen, <code>append-to-buffer</code> funciona de la siguiente manera: guarda el valor del búfer actual en la variable <code>oldbuf</code>. Obtiene el nuevo búfer (creando uno si es necesario) y cambia la atención de Emacs a este. Usando el valor de <code>oldbuf</code>, inserta la región del texto desde el búfer antiguo dentro del nuevo búfer; y luego usando <code>save-excursion</code>, regresa al búfer original.</p>
<p>Al observar <code>append-to-buffer</code>, se ha explorado una función bastante compleja. Muestra como usar <code>let</code> y <code>save-excursion</code>, y como cambiar y volver desde otro buffer. Muchas definiciones de función usan <code>let</code>, <code>save-excursion</code>, y <code>set-buffer</code> de esta manera.</p>
</div>
<h3 id="repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí está un breve resumen de las diferentes funciones descritas en este capítulo.</p>
<dl>
<dt><code>describe-function</code>, <code>describe-variable</code></dt>
<dd>
<p>Imprime la documentación de una función o variable. Convencionalmente unidas a <kbd>C-h f</kbd> y <kbd>C-h v</kbd>.</p>
</dd>
<dt><code>find-tag</code></dt>
<dd>
<p>Encuentra el fichero que contiene el codigo de una función o variable y cambia a dicho buffer, colocando el punto al inicio del elemento. Convencionalmente ligado a <kbd>M-.</kbd> (esto es un punto luego de la tecla <kbd>META</kbd>).</p>
</dd>
<dt><code>save-excursion</code></dt>
<dd>
<p>Guarda la posicion de punto y marca y restaura sus valores tras evaluar los argumentos de <code>save-excursion</code>. Ademas, recuerda el buffer actual y regresa a el.</p>
</dd>
<dt><code>push-mark</code></dt>
<dd>
<p>Asigna la marca a una posicion y guarda el valor de la marca previa en el anillo de marcas. La marca es una ubicacion en el búfer que mantendra su posición relativa, incluso si se añade o borra texto del búfer.</p>
</dd>
<dt><code>goto-char</code></dt>
<dd>
<p>Establece el punto a la ubicacion especificada por el valor del argumento, que puede ser un número, una marca, o una expresión que devuelve el número de una posición, como <code>(point-min)</code>.</p>
</dd>
<dt><code>insert-buffer-substring</code></dt>
<dd>
<p>Copia una región de texto desde un búfer que se pasa a la función como un argumento e inserta la región dentro del búfer actual.</p>
</dd>
<dt><code>mark-whole-buffer</code></dt>
<dd>
<p>Marca el búfer completo como una región. Normalmente unido a <kbd>C-x h</kbd>.</p>
</dd>
<dt><code>set-buffer</code></dt>
<dd>
<p>Cambia la atención de Emacs a otro búfer, pero no se muestra el cambio en la ventana. Se utiliza cuando un programa y no humano trabaja en un búfer distinto.</p>
</dd>
<dt><code>get-buffer-create</code>, <code>get-buffer</code></dt>
<dd>
<p>Busca el búfer con nombre o crea uno si el búfer con ese nombre no existe. La función <code>get-buffer</code> devuelve <code>nil</code> si el nombre del búfer no existe.</p>
</dd>
</dl>
</div>
<h3 id="ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe tu propia definición de la función <code>simplified-end-of-buffer</code>; luego pruebala para ver si funciona.</p>
</li>
<li>
<p>Utiliza <code>if</code> y <code>get-buffer</code> para escribir una función que imprima un mensaje que te diga si un buffer existe.</p>
</li>
<li>
<p>Usando <code>find-tag</code>, busca el codigo de la función <code>copy-to-buffer</code></p>
</li>
</ul>
</div>
<h2 id="algunas-funciones-más-complejas" >Algunas Funciones Más Complejas</h2>
<div class="hBody-2" >
<p>En este capítulo, nos basamos en lo que hemos aprendido en los capítulos anteriores examinando funciones más complejas. La función <code>copy-to-buffer</code> ilustra el uso de dos expresiones <code>save-excursion</code> en una definición, mientras que la función <code>insert-buffer</code> ilustra el uso de un asterisco en una expresión <code>interactive</code>, el uso de <code>or</code>, y la importante distinción entre un nombre y el objeto al que el nombre hace referencia.</p>
</div>
<h3 id="la-definición-de-copy-to-buffer" >La definición de <code>copy-to-buffer</code></h3>
<div class="hBody-3" >
<p>Después de comprender cómo trabaja <code>append-to-buffer</code>, es fácil entender <code>copy-to-buffer</code>. Esta función copia texto dentro de un búfer, pero en lugar de agregarlo al segundo búfer, sustituye todo el texto anterior en el segundo búfer.</p>
<p>El cuerpo de <code>copy-to-buffer</code> tiene este aspecto,</p>
<pre class="code" ><code class="chroma" ><span class="err">…</span>
<span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;BCopy to buffer: \nr&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">with-current-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">erase-buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)))))</span>
</code></pre>
<p>La función <code>copy-to-buffer</code> tiene una expresión <code>interactive</code> mas sencilla que <code>append-to-buffer</code>.</p>
<p>La definición dice:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">with-current-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">)</span> <span class="err">…</span>
</code></pre>
<p>En primer lugar, mira en la expresión más interna; que se evalua primero. Esta expresión inicia con <code>get-buffer-create buffer</code>. La función le indica al ordenador que utilice el búfer con el nombre específicado como aquel que quieres copiar, o si tal búfer no existe, que debe créarlo. Luego, la función <code>with-current-buffer</code> evalúa su cuerpo con este búfer temporal.</p>
<p>(Esto demuestra otra forma de cambiar la atención de la computadora pero no por parte del usuario. La función <code>append-to-buffer</code> muestro como hacer lo mismo con <code>save-excursion</code> y <code>set-buffer</code>. <code>with-current-buffer</code> es un nuevo mecanismo, posiblemente mas sencillo.)</p>
<p>La función <code>barf-if-buffer-read-only</code> envía un mensaje de error diciendo que el búfer es de solo lectura si no se puede modificar.</p>
<p>La siguiente línea tiene la función <code>erase-buffer</code> como su único contenido. Este función borra el búfer.</p>
<p>Finalmente, las últimas dos líneas contienen la expresión <code>save-excursion</code> con <code>insert-buffer-substring</code> como su cuerpo. La expresión <code>insert-buffer-substring</code> copia el texto desde el búfer en el que te encuentras (y no has visto que el computador cambie su atención, por lo que no sabes que ese búfer ahora se llama <code>oldbuf</code>).</p>
<p>Por cierto, esto es lo que se entiende por ‘reemplazo’. Para reemplazar el texto Emacs borra el texto anterior y luego inserta el texto nuevo.</p>
<p>A grandes rasgos, el cuerpo de <code>copy-to-buffer</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">enlazar-oldbuf-al-valor-del-bufer-actual</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">con-el-bufer-al-que-estas-copiando</span>
      <span class="p">(</span><span class="nv">pero-no-borrar-o-copiar-a-un-bufer-de-solo-lectura</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">erase-buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">save-excursion</span>
        <span class="nv">insertar-la-subcadena-de-oldbuf-en-el-bufer</span><span class="p">)))</span>
</code></pre>
</div>
<h3 id="la-definición-de-insert-buffer" >La definición de <code>insert-buffer</code></h3>
<div class="hBody-3" >
<p><code>insert-buffer</code> es otra función relacionada con búfers. Este comando copia otro búfer <em>dentro</em> del búfer actual. Es lo contrario a <code>append-to-buffer</code> o <code>copy-to-buffer</code>, dado que copia una región de texto <em>desde</em> el búfer actual a otro búfer.</p>
<p>Aquí examinamos en el código original. El código fue simplificado en 2003 y es mas dificil de entender.</p>
<p>(Vea la Seccion <a href="#nuevo-cuerpo-para-insert-buffer" >Nuevo Cuerpo para <code>insert-buffer</code></a>, para ver una discusión del nuevo cuerpo.)</p>
<p>Además, este código ilustra el uso de <code>interactive</code> con un búfer que podría ser <dfn>read-only</dfn> (de solo lectura) y la importante distinción entre el nombre de un objeto y el objeto al que realmente hace referencia.</p>
<p>Aquí está el código anterior:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&#34;Insertar despues del punto el contenido de BUFFER.
</span><span class="s">Coloca la marca despues del texto insertado.
</span><span class="s">BUFFER puede ser un buffer o el nombre de un buffer.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*bInsert buffer: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">newmark</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nb">save-excursion</span>
        <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">push-mark</span> <span class="nv">newmark</span><span class="p">)))</span>
</code></pre>
<p>Al igual que con otras definiciones de función, se puede usar una plantilla para ver un esquema de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*bInsert buffer: &#34;</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="la-expresión-interactiva-en-insert-buffer" >La expresión interactiva en <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>En <code>insert-buffer</code>, el argumento de la declaración <code>interactive</code> tiene dos partes, un asterisco, <samp>*</samp>, y <samp>bInsert buffer: </samp>.</p>
</div>
<h5 id="un-búfer-de-solo-lectura" >Un búfer de solo lectura</h5>
<div class="hBody-5" >
<p>El asterisco se utliza cuando el búfer actual es un búfer de solo lectura––un búfer que no puede ser modificado. Si se llama a <code>insert-buffer</code> cuando el búfer actual es de solo lectura, se imprime un mensaje en el area de eco y el terminal puede emitir un beep o parpadear; no se permitira insertar nada en el búfer actual. El asterisco no tiene que ser seguido por un salto de linea para separarlo del siguiente argumento.</p>
</div>
<h5 id="b-en-una-expresión-interactiva" ><samp>b</samp> en una expresión interactiva</h5>
<div class="hBody-5" >
<p>El siguiente argumento de la expresión interactiva inicia con una letra <samp>b</samp> minúscula. (Esto es diferente del código para <code>append-to-buffer</code>, que utiliza una <samp>B</samp> mayúscula. Vea la Seccion <a href="#la-definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>.) La <samp>b</samp> minúscula le indica al intérprete Lisp que el argumento de <code>insert-buffer</code> debe ser un buffer existente o su nombre. (La opcion <samp>B</samp> mayúscula permite la posibilidad que el búfer no exista.)  Emacs te pedira el nombre del búfer, ofreciendo un búfer por defecto, con el autocompletado de nombre habilitado. Si el búfer no existe, recibiras un mensaje que dice “No match” (<q>no concuerda</q>); tu terminal tambien puede emitir un beep.</p>
<p>El nuevo código simplificado genera una lista <code>interactive</code>. Este utiliza las funciones <code>barf-if-buffer-read-only</code> y <code>read-buffer</code> con las que ya estamos familiarizados y la forma especial <code>progn</code> con la que no lo estamos. (Se describira mas adelaste).</p>
</div>
<h4 id="el-cuerpo-de-la-función-insert-buffer" >El cuerpo de la función <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>insert-buffer</code> tiene dos partes principales: una expresión <code>or</code> y una expresión <code>let</code>. El propósito de la expresión <code>or</code> es asegurar que el argumento <code>buffer</code> esta unido a un búfer y no es solo el nombre de un búfer. El cuerpo de la expresión <code>let</code> contiene el código que copia el otro búfer dentro del búfer actual.</p>
<p>A grades rasgos, las dos expresiones encajan asi en la función <code>insert-buffer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*bInsert buffer: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="err">…</span>
      <span class="err">…</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">varlist</span><span class="p">)</span>
      <span class="nv">cuerpo-de-let</span><span class="err">…</span> <span class="p">)</span>
</code></pre>
<p>Para entender como la expresión <code>or</code> asegura que el argumento <code>buffer</code> esta unido a un buffer y no al nombre de un búfer, primero es necesario entender la función <code>or</code>.</p>
<p>Antes de hacer esto, permíteme reescribir esta parte de la función utilizando <code>if</code> de esta manera puedes ver como se hace de una manera que resulta familiar.</p>
</div>
<h4 id="insert-buffer-con-un-if-en-lugar-de-un-or" ><code>insert-buffer</code> con un <code>if</code> en lugar de un <code>or</code></h4>
<div class="hBody-4" >
<p>El trabajo a realizar es asegurarse de que el valor de <code>buffer</code> sea un búfer en sí mismo y no el nombre de un búfer. Si el valor es el nombre, entonces debe optenerse el búfer en sí.</p>
<p>Puedes imaginarte a tí mismo en una conferencia donde un acomodador está observando una lista con tu nombre en ella y mirándote: el acomodador sabe “asociar” tu nombre, no a tí; pero cuando el acomodador te encuentra y te toma el brazo, el acomodador llega a “asociarte” a tí.</p>
<p>En Lisp, se podría describir esta situación así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">tomar-al-invitado</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">encontrar-y-tomar-del-brazo-al-invitado</span><span class="p">))</span>
</code></pre>
<p>Queremos hacer lo mismo con un búfer––si no tenemos el búfer en sí, queremos conseguirlo.</p>
<p>Usando un predicado llamado <code>bufferp</code> que nos informa si tenemos un búfer (en lugar de su nombre), podemos escribir el código de esta manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">))</span>              <span class="c1">; parte-if</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>  <span class="c1">; parte-then</span>
</code></pre>
<p>Aquí, la prueba verdadero-o-falso de la expresión <code>if</code> es <code>(not (bufferp buffer))</code>; y la parte <em>then</em> es la expresión <code>(setq buffer (get-buffer buffer))</code>.</p>
<p>En la prueba, la función <code>bufferp</code> devuelve cierto si su argumento es un búfer––sino falso si el argumento es el nombre del búfer. (El último carácter del nombre de la función <code>bufferp</code> es el carácter <samp>p</samp>; como vimos anteriormente, tal uso de <samp>p</samp> es una convención que indica que la función es un predicado, que es un término que significa que la función determinará si alguna propiedad es verdadera o falsa. Vea la Seccion <a href="#usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a>.)</p>
<p>La función <code>not</code> precede la expresión <code>(bufferp buffer)</code>, así la prueba verdadero-o-falso es la siguente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">))</span>
</code></pre>
<p><code>not</code> es una función que devuelve verdadero si su argumento es falso y falso si su argumento es verdadero. Por lo que si <code>(bufferp buffer)</code> devuelve cierto, la expresión <code>not</code> devuelve falso y vice-versa: lo que es “no verdadero” es falso y lo que es “no falso” es verdadero.</p>
<p>Usando esta prueba, la expresión <code>if</code> funciona de la siguiente manera: cuando el valor de la variable <code>buffer</code> es en realidad un búfer en lugar de su nombre, la prueba verdadero-o-falso devuelve falso y la expresión <code>if</code> no evalúa la parte then. Esto está bien, ya que no tenemos que hacer nada para la variable <code>buffer</code> si realmente es un búfer.</p>
<p>Por otro lado, cuando el valor de <code>buffer</code> no es un buffer en sí, pero si el nombre de un buffer, la prueba verdadero-o-falso devuelve verdadero y se evalua la parte then de la expresión. En este caso, la parte then es <code>(setq buffer (get-buffer buffer))</code>. Esta expresión utiliza la función <code>get-buffer</code> para devolver un buffer en real, dado su nombre. Luego <code>setq</code> asigna la variable <code>buffer</code> reemplazando su valor anterior (que era el nombre del buffer).</p>
</div>
<h4 id="el-or-en-el-cuerpo" >El <code>or</code> en el cuerpo</h4>
<div class="hBody-4" >
<p>El propósito de la expresión <code>or</code> en la función <code>insert-buffer</code> es asegurar que el argumento <code>buffer</code> está asociado a un búfer y no solo al nombre de un búfer. La sección previa muestra como se podría haber hecho el trabajo usando una expresión <code>if</code>. Sin embargo, la función <code>insert-buffer</code> utiliza <code>or</code>. Para entender esto, es necesario entender como funciona <code>or</code>.</p>
<p>Una función <code>or</code> puede tener cualquier número de argumentos. Esta evalúa un argumento a la ves y devuelve el valor del primero de sus argumentos que no es <code>nil</code>. Ademas, y esta es una caracteristica crucial de <code>or</code>, es no evalúar los argumentos posteriores después de regresar el primer valor no-<code>nil</code>.</p>
<p>La expresión <code>or</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>
</code></pre>
<p>El primer argumento de <code>or</code> es la expresión <code>(bufferp buffer)</code>. Esta expresión devuelve verdadero (un valor no-<code>nil</code>) si el búfer es realmente un búfer, y no solo el nombre de un búfer. En la expresión <code>or</code>, si este es el caso, la expresión <code>or</code> devuelve este valor verdadero y no evalúa la siguiente expresión––y esto es bueno para nosotros, ya que no queremos hacer nada al valor de <code>buffer</code> si realmente es un búfer.</p>
<p>Por otro lado, si el valor de <code>(bufferp buffer)</code> es <code>nil</code>, si el valor de <code>buffer</code> es el nombre de un buffer, el intérprete Lisp evalúa el siguiente elemento de la expresión. Esta es la expresión <code>(setq buffer (get-buffer buffer))</code>. Esta expresión devuelve un valor no-<code>nil</code>, que es el valor para el que asigna la variable <code>buffer</code>––y este valor es un búfer en sí, no el nombre de un búfer.</p>
<p>El resultado de todo esto es que el símbolo <code>buffer</code> siempre se enlaza a un búfer en sí en vez de al nombre de un búfer. Todo esto es necesario debido a que la función <code>set-buffer</code> en la línea siguiente solo funciona con un buffer en sí, no con el nombre de un búfer.</p>
<p>A proposito, usando <code>or</code>, la escena con el acomodador se escribiria así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">tomar-al-invitado</span><span class="p">)</span> <span class="p">(</span><span class="nv">encontrar-y-tomar-del-brazo-al-invitado</span><span class="p">))</span>
</code></pre>
</div>
<h4 id="la-expresión-let-en-insert-buffer" >La expresión <code>let</code> en <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>Después de asegurarse que la variable <code>buffer</code> se refiere a un buffer en sí y no solo al nombre de uno, la función <code>insert-buffer</code> continúa con una expresión <code>let</code>. Esta especifica tres variables locales, <code>start</code>, <code>end</code> y <code>newmark</code> y las une al valor inicial <code>nil</code>. Estas variables se utilizan dentro del resto de <code>let</code> y ocultan temporalmente cualquier otra ocurrencia de variables con el mismo nombre en Emacs hasta el final de <code>let</code>.</p>
<p>El cuerpo de <code>let</code> contiene dos expresiones <code>save-excursion</code>. Primero, veremos la expresión interna <code>save-excursion</code> en detalle. La expresión se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
</code></pre>
<p>La expresión <code>(set-buffer buffer)</code> cambia la atención de Emacs del búfer actual al buffer del que se copiara el texto. En ese búfer las variables <code>start</code> y <code>end</code> se asignan al inicio y al fin del búfer, usando los comandos <code>point-min</code> y <code>point-max</code>. Tenga en cuenta que aquí tenemos un ejemplo de cómo <code>setq</code> es capaz de asignar dos variables en la misma expresión. El primer argumento de <code>setq</code> se establece al valor del segundo, y su tercer argumento se establece al valor del cuarto.</p>
<p>Después de evaluar el interior del cuerpo de <code>save-excursion</code>, <code>save-excursion</code> restaura el búfer original, pero <code>start</code> y <code>end</code> retienen los valores del inicio y fin del búfer del que se copiara el texto.</p>
<p>La expresión extena de <code>save-excursion</code> luce asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="p">(</span><span class="nv">expresion-interior-de-save-excursion</span>
     <span class="p">(</span><span class="nv">ir-al-nuevo-bufer-y-establecer-start-y-end</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</code></pre>
<p>La función <code>insert-buffer-substring</code> copia el texto <em>dento</em> del búfer actual <em>desde</em> la región indicada por <code>start</code> y <code>end</code> en el <code>búfer</code>. Puesto que la totalidad del segundo búfer se encuentra entre <code>start</code> y <code>end</code>, todo dentro del segundo búfer se copia el el bufer que se esta editando. A continuacion, el valor del punto, que será al fin del texto insertado, se registra en la variable <code>newmark</code>.</p>
<p>Después evaluar el cuerpo del <code>save-excursion</code> externo, el punto y la marca se vuelven a colocar en su posicion original.</p>
<p>Sin embargo, es conveniente ubicar una marca al fin del texto recien insertado y ubicar el punto al principio. La variable <code>newmark</code> registra el fin del texto insertado. En la última línea de la expresión <code>let</code>, la expresión <code>(push-mark newmark)</code> asigna una marca a esta posición. (La posición anterior de la marca aun es accesible; está grabada en el anillo de marcas y puedes volver a ella con <kbd>C-u C-SPC</kbd>.) Mientras tanto, el punto se encuentra al principio del texto insertado, que es donde estaba antes de llamar a la función de insercion, cuya posición fue guardada por la primer <code>save-excursion</code>.</p>
<p>La expresión <code>let</code> completa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">newmark</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="nv">newmark</span><span class="p">))</span>
</code></pre>
<p>Al igual que la función <code>append-to-buffer</code>, la función <code>insert-buffer</code> utiliza <code>let</code>, <code>save-excursion</code> y <code>set-buffer</code>. Además, la función ilustra una forma de utilizar <code>or</code>. Todas estas funciones son bloques de construccion que vamos a encontrar y utilizar una y otra vez.</p>
</div>
<h4 id="nuevo-cuerpo-para-insert-buffer" >Nuevo cuerpo para <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo en la versión 22 de GNU Emacs es más confuso que en el original.</p>
<p>Consta de dos expresiones</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nv">push-mark</span>
   <span class="p">(</span><span class="nb">save-excursion</span>
     <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>

   <span class="no">nil</span>
</code></pre>
<p>excepto que, y esto es lo que confunde a los principiantes, se hace un trabajo muy importante al interior de la expresión <code>push-mark</code>.</p>
<p>La función <code>get-buffer</code> devuelve un búfer con el nombre proporcionado. Notaras que la función <em>no</em> se llama <code>get-buffer-create</code>; esta no crea un búfer si uno no existe ya. El búfer devuelto por <code>get-buffer</code>, un búfer existente, se pasa a <code>insert-buffer-substring</code>, que inserta todo el búfer (ya que no se especifica ninguna cosa más).</p>
<p>La posición donde se inserta el buffer se registra por <code>push-mark</code>. Despues la función devuelve <code>nil</code>, el valor de su último comando. Dicho de otra manera, la función <code>insert-buffer</code> existe solo para producir un efecto secundario, insertando otro buffer, no para devolver ningun valor.</p>
</div>
<h3 id="definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></h3>
<div class="hBody-3" >
<p>Ya se ha discutido la estructura básica de la función <code>beginning-of-buffer</code>. (Vea la Seccion <a href="#una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></a>). Esta sección describe la parte compleja de la definición.</p>
<p>Como se ha descrito anteriormente, cuando se invoca <code>beginning-of-buffer</code> sin argumento, mueve el cursor al inicio del búfer (en realidad, al inicio de la porción accesible del búfer), dejando la marca en la posición anterior. Sin embargo, cuando el comando se invoca con un número entre uno y diez, la función considera que ese número es una fracción del tamaño del búfer, medido en decenas, y Emacs mueve el cursor a dicha fracción del reccorrido desde el inicio del búfer. Por lo tanto, puedes llamar a esta función con el comando de teclado <kbd>M-&lt;</kbd>, que moverá el cursor al principio del búfer, o con un comando de teclado como <kbd>C-u 7 M-&lt;</kbd> que moverá el cursor a un 70% del recorrido a través del búfer. Si se utiliza un número mayor a diez como argumento, se movera al final del búfer.</p>
<p>La función <code>beginning-of-buffer</code> puede llamarse con o sin argumentos. El uso del argumento es opcional.</p>
</div>
<h4 id="argumentos-opcionales" >Argumentos opcionales</h4>
<div class="hBody-4" >
<p>A menos que se diga lo contrario, Lisp espera que una función con un argumento en su definición de función sea llamada con un valor para ese argumento. Si esto no ocurre, se obtiene un error y un mensaje que dice <samp>Wrong number of arguments</samp> (<q>Número de argumentos erróneo</q>).</p>
<p>Sin embargo, los argumentos opcionales son una caracteristica de Lisp: se utiliza una <dfn>palabra clave</dfn> en concreto para decirle al intérprete Lisp que un argumento es opcional. La palabra clave es <code>&amp;optional</code>. (El <samp>&amp;</samp> al frente de <samp>optional</samp> es parte de la palabra clave.) En una definición de función, si un argumento va despues de la palabra clave <code>&amp;optional</code>, no necesita pasar ningún valor para este argumento al llamar a la función.</p>
<p>Por lo tanto la primera línea de la definición de función de <code>beginning-of-buffer</code> tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
</code></pre>
<p>En lineas generales, toda la función se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;P&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">es-el-argumento-una-cons-cell</span> <span class="nv">argumento</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="nv">ambos-transient-mark-mode-y-mark-active-son-verdadero</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">push-mark</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">determina-el-tamano-y-lo-establece</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span>
    <span class="p">(</span><span class="nv">si-hay-un-argumento</span>
        <span class="nv">averigua-donde-ir</span>
      <span class="nv">de-otro-modo-va-a</span>
      <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
   <span class="nv">do-nicety</span>
</code></pre>
<p>La función es similar a la función <code>simplified-beginning-of-buffer</code> excepto que la expresión <code>interactive</code> tiene <code>&#34;P&#34;</code> como argumento y la función <code>goto-char</code> es seguida por una expresión if-then-else que calcula donde poner el cursor si hay un argumento que no es un cons cell.</p>
<p>(Puesto que no explico que es un <em>cons cell</em> en muchos capítulos, por favor, considera ignorar la función <code>consp</code>. Ve la Seccion <a href="#cómo-se-implementan-las-listas" >Cómo se implementan las listas</a>, y la Seccion <a href="info:elisp#Cons-Cell-Type" >&#34;Cons Cell y Tipos de Listas&#34;</a> en <em>El Manual de Referencia GNU Emacs Lisp</em>).</p>
<p>La <code>&#34;P&#34;</code> en la expresión <code>interactive</code> le indica a Emacs cómo pasar a la funcion argumento prefijo, si es que hay uno, en su forma <q>plana</q> sin procesar. Un argumento prefijo se crea presionando la tecla <kbd>META</kbd> seguida por un número, o pulsando <kbd>C-u</kbd> y luego un número. (Si no escribes un número, <kbd>C-u</kbd> por defecto pasa un cons cell con un 4. Una <code>&#34;p&#34;</code> minúscula en la expresión <code>interactive</code> hace que la función convierta un argumento prefijo a un número.)</p>
<p>La prueba verdadero-o-falso de la expresión <code>if</code> parace compleja, pero no lo es: se comprueba si <code>argumento</code> tiene un valor que no es <code>nil</code> y si es un cons cell. (Esto es lo que hace <code>consp</code>; comprueba si su argumento es un cons cell.) Si <code>argumento</code> tiene un valor distinto a <code>nil</code> (y no es un cons cell), que será el caso si <code>beginning-of-buffer</code> se llama con un argumento numerico, la prueba verdadero-o-falso devolverá verdadero y se evaluara la parte-then de la expresión <code>if</code>. Por otro lado, si <code>beginning-of-bufer</code> no se llama con un argumento, el valor de <code>argumento</code> será <code>nil</code> y se evaluara la parte-else de la expresión <code>if</code>. La parte-else es un simple <code>point-min</code>, y cuando este es el resultado, toda la expresión <code>goto-char</code> es <code>(goto-char (point-min))</code>, que es cómo vimos la función <code>beginning-of-buffer</code> en su forma simplificada.</p>
</div>
<h4 id="beginning-of-buffer-con-un-argumento" ><code>beginning-of-buffer</code> con un argumento</h4>
<div class="hBody-4" >
<p>Cuando se llama a <code>beginning-of-buffer</code> con un argumento, se evalua una expresión que calcula que valor pasar a <code>goto-char</code>. A primera vista esta expresion es bastante compleja. Incluye una expresión <code>if</code> y mucha aritmética. Se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">buffer-size</span><span class="p">)</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="c1">;; Evita el desbordamiento en buffers de gran tamaño!</span>
    <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span>
        <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
     <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Como otras expresiones que parecen complejas, la expresión condicional dentro de <code>beginning-of-buffer</code> se puede desenredar viendola como partes de una plantilla, en este caso, la plantilla para una expresión if-then-else. En forma esquelética, la expresión se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">si</span> <span class="p">(</span><span class="nv">buffer-es-grande</span>
    <span class="nv">divide-el-tamaño-del-buffer-por-10-y-multiplicalo-por-arg</span>
  <span class="nv">de-otra-forma-utiliza-el-calculo-alternativo</span>
</code></pre>
<p>La prueba verdadero-o-falso de la expresión <code>if</code> interna comprueba el tamaño del buffer. La razón de esto es que la vieja versión de Emacs 18 utilizaba números que no superaban los ocho millones y en el siguiente calculo, el programador temía que Emacs pudiera intentar usar numeros demasiado grandes si el búfer fuese extenso. El término ‘desbordamiento’, que se menciona en el comentario, significa que los números son demaciado grandes. Las versiones más recientes de Emacs utilizan números mas grandes, pero este código no ha sido tocado, aunque solo sea porque la gente ahora mira búfers que son mucho, mucho mas grandes que antes.</p>
<p>Hay dos casos: si el búfer es grande, o si no lo es.</p>
</div>
<h5 id="qué-ocurre-en-un-búfer-de-gran-tamaño" >Qué ocurre en un búfer de gran tamaño</h5>
<div class="hBody-5" >
<p>En <code>beginning-of-buffer</code>, la expresión <code>if</code> interna prueba si el tamaño del búfer es mayor a 10000 caracteres. Para hacer esto, se utiliza la función <code>&gt;</code> y el calculo de <code>size</code> que previene de la expresión <code>let</code>.</p>
<p>En los viejos tiempos, se utilizaba la función <code>buffer-size</code>. No solo se llamo varias ocaciones esa funcion, sino que die el tamaño completo del búfer, no la parte accesible. El calculo tiene mucho más sentido cuando se maneja solo la parte accesible. (Vea la Seccion <a href="#reducir-y-extender" >Reducir y Extender</a>, para obtener más información sobre como centrar la atención en una parte ‘accesible’.)</p>
<p>La linea se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">size</span> <span class="mi">10000</span><span class="p">)</span>
</code></pre>
<p>Cuando el búfer es grande, se evalua la parte <code>then</code> de la expresión <code>if</code>. Se lee así (después de formatearlo para facilitar la lectura):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span>
  <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Esta expresión es una multiplicación, con dos argumentos para la función <code>*</code>.</p>
<p>El primer argumento es <code>(prefix-numeric-value arg)</code>. Cuando se usa <code>&#34;P&#34;</code> como argumento para <code>interactive</code>, el valor pasado a la función como argumento es un “argumento prefijo en bruto”, y no un número. (Es un número en una lista). Para realizar el calculo, se necesita una conversión, y <code>prefix-numeric-value</code> hace el trabajo.</p>
<p>El segundo argumento es <code>(/ size 10)</code>. Esta expresión divide el valor numérico por diez––el valor numérico del tamaño de la porción accesible del búfer. Esto produce un número que indica cuántos caracteres componen una decena parte del tamaño del búfer. (En Lisp, <code>/</code> se utiliza para la división, igual que <code>*</code> se utiliza para la multiplicación.)</p>
<p>En la expresión de multiplicación como un todo, esta cantidad se multiplica por el valor del argumento prefijo––la multiplicación es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="nv">valor-numerico-del-argumento-prefijo-arg</span>
   <span class="nv">numero-de-caracteres-en-una-decima-parte-de-la-porcion-accesible-del-buffer</span><span class="p">)</span>
</code></pre>
<p>Por ejemplo, si el argumento prefijo es <samp>7</samp>, el valor de una decima parte será multiplicado por 7 para dar una posición al 70% del trayecto.</p>
<p>El resultado de todo esto es que si la porción accesible del búfer es grande, la expresión <code>goto-char</code> es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">)))</span>
</code></pre>
<p>Esto coloca el cursor donde lo queremos.</p>
</div>
<h5 id="lo-que-sucede-en-un-búfer-pequeño" >Lo que sucede en un búfer pequeño</h5>
<div class="hBody-5" >
<p>Si el búfer contiene menos de 10000 caracteres, se lleva a cabo un calculo ligeramente diferente. Podrías pensar que esto no es necesario, ya que el primer calculo podría hacer el trabajo. Sin embargo, en un búfer pequeño, el primer método puede no colocar el cursor exactamente en la línea deseada; el segundo método hace un mejor trabajo.</p>
<p>El código tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span> <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Para averiguar que ocure en este código debemos descubrir como se anidan las funciones entre paréntesis. Es mas fácil de leer si se reformate cada expresión, indentando la expresión que contiene:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nf">/</span>
   <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span>
      <span class="p">(</span><span class="nf">*</span>
       <span class="nv">size</span>
       <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
   <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Observando los paréntesis, vemos que la operación mas profunda es <code>(prefix-numeric-value arg)</code>, que convierte el argumento prefijo en bruto a un número. En la siguiente expresión, este número se multiplica por el tamaño de la porción accesible del búfer:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">))</span>
</code></pre>
<p>Esta multiplicación crea un número que puede ser mayor al tamaño del buffer––siete veces mayor si el argumento es 7, por ejemplo. Luego se suma diez a éste numero y finalmente el número es dividido por 10 para proporcionar un valor que es un carácter más grande que la posición porcentual en el búfer.</p>
<p>El número que resulta de todo esto se pasa a <code>goto-char</code> y el cursor se mueve a ese punto.</p>
</div>
<h4 id="funcion-beginning-of-buffer-completa" >Funcion <code>beginning-of-buffer</code> Completa</h4>
<div class="hBody-4" >
<p>Aquí está el texto completo de la función <code>beginning-of-buffer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;Mueve el punto al principio del bufer;
</span><span class="s">deja la marca en la posicion anterior.
</span><span class="s">Con el prefijo \\[universal-argument],
</span><span class="s">no pone la marca en la posicion anterior.
</span><span class="s">Con un argumento numerico N,
</span><span class="s">coloca el punto N/10 del camino desde el enicio.
</span><span class="s">
</span><span class="s">Si el bufer tiene activo narrowing,
</span><span class="s">este comando utiliza el principio y el tamaño
</span><span class="s">de la parte accesible del bufer.
</span><span class="s">
</span><span class="s">No use este comando en los programas Lisp!
</span><span class="s">\(goto-char (point-min)) es mas rapido y evita
</span><span class="s">tocar la marca.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;P&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="nv">transient-mark-mode</span> <span class="nv">mark-active</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">push-mark</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">size</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">arg</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)))</span>
                   <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span>
                      <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">size</span> <span class="mi">10000</span><span class="p">)</span>
                          <span class="c1">;; Avoid overflow for large buffer sizes!</span>
                          <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
                        <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
                           <span class="mi">10</span><span class="p">)))</span>
                 <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre>
<p>Excepto por dos pequeños puntos, la discusión anterior muestra cómo funciona esta función. El primer punto se refiere a un detalle en la cadena de documentación, y el segundo se refiere a la última línea de la función.</p>
<p>En la cadena de documentación, se hace referencia a una expresión:</p>
<div class="example-block" >
<pre class="example" >\\[universal-argument]
</pre>
</div>
<p>Se usa Un <samp>\\</samp> antes del primer corchete de esta expresión. Este <samp>\\</samp> le indica al intérprete Lisp que sustituya cualquier clave qué se encuentre dentro de <samp>[…]</samp> por su convinacion de teclado actual. En el caso de <code>universal-argument</code>, suele ser <kbd>C-u</kbd>, pero podría ser distinta. (Véa la Sección <a href="info:elisp#Documentation-Tips" >Consejos para Cadenas de Documentación</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.)</p>
<p>Finalmente, la última línea del comando <code>beginning-of-buffer</code> indica mover el punto al inicio de la siguiente línea si el comando se invoca con un argumento:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre>
<p>Esto pone el cursor al inicio de la primer línea despues de la posicion inidicada en decenas en el búfer. Esto significa que el cursor siempre se localiza <em>al menos</em> las decenas solicitadas del recorrido del búfer, esta es una sutiliza, quizás, no necesaria, pero que, si no ocurriera, seguro generaria quejas.</p>
<p>Por otro lado, tambien significa que si se especifica el comando con <kbd>C-u</kbd>, pero sin un número, es decir, si el ‘argumento prefijo en bruto’ simplemente es un cons cell, entonces el comando te coloca al inicio de la segunda línea … no sé si se pretende esto o si nadie ha tratado el código para evitar que esto suceda.</p>
</div>
<h3 id="repaso:-algunas-funciones-más-complejas" >Repaso</h3>
<div class="hBody-3" >
<p>He aquí un breve resumen de algunos de los temas cubiertos en este capítulo.</p>
<dl>
<dt><code>or</code></dt>
<dd>
<p>Evalúa cada argumento en secuencia, y devuelve el valor del primer argumento que no es <code>nil</code>, si ninguno devuelve un valor que no sea <code>nil</code>, devuelve <code>nil</code>. En resumen, devuelve el primer valor verdadero de los argumento; devuelve un valor verdadero si uno <em>o</em> cualquiera de los otros es verdadero.</p>
</dd>
<dt><code>and</code></dt>
<dd>
<p>Evalúa cada argumento en secuencia, y si alguno es <code>nil</code>, devuelve <code>nil</code>; si ninguno es <code>nil</code>, devuelve el valor del último argumento. En resumen, devuelve un valor verdadero solo si todos los argumentos son verdaderos; devuelve un valor verdadero si uno <em>y</em> cada uno de los otros son verdadero.</p>
</dd>
<dt>&amp;optional</dt>
<dd>
<p>Una palabra clave utilizada para indicar que un argumento en una definición de función es opcional; esto significa que la función se puede evaluar sin el argumento, si se desea.</p>
</dd>
<dt><code>prefix-numeric-value</code></dt>
<dd>
<p>Convierte el ‘argumento prefijo en bruto’ producido por <code>(interactive &#34;P&#34;)</code> en un valor numérico.</p>
</dd>
<dt><code>forward-line</code></dt>
<dd>
<p>Mueve el punto hacia adelante al principio de la siguiente línea, o si el argumento es mayor a uno, hacia delante varias líneas. Si no se puede mover tan lejos hacia delante como se supone, <code>forward-line</code> va hacia adelante tan lejos como pueda y luego devuelve un conteo del número de líneas adicionales que no se pudo mover.</p>
</dd>
<dt><code>erase-buffer</code></dt>
<dd>
<p>Elimina todo el contenido del búfer actual.</p>
</dd>
<dt><code>bufferp</code></dt>
<dd>
<p>Devuelve <code>t</code> si su argumento es un búfer; de otro modo devuelve <code>nil</code>.</p>
</dd>
</dl>
</div>
<h3 id="ejercicio-con-el-argumento-opcional" >Ejercicio con el argumento <code>opcional</code></h3>
<div class="hBody-3" >
<p>Escribe una función interactiva con un argumento opcional que comprueve si su argumento, un número, es mayor que o igual a, o de lo contrario, menor que el valor de <code>fill-column</code>, y lo informe, en un mensaje. Sin embargo, si no pasas un argumento a la función, utiliza 56 como valor por defecto.</p>
</div>
<h2 id="reducir-y-extender" >Reducir y Extender</h2>
<div class="hBody-2" >
<p>La reduccion es una funcionalidad de Emacs que hace posible que puedas focalizarte en una parte específica de un búfer, y trabajar sin cambiar accidentalmente otras partes. La reduccion normalmente se deshabilita ya que puede confundir a los principiantes.</p>
<p>Con la reduccion, el resto del búfer se hace invisible, como si no estuviera alli. Esto es una ventaja si, por ejemplo, se quiere reemplazar una palabra en una parte del búfer pero no en otra: limitas la parte que deseas y el reemplazo se lleva a cabo solo en esa sección, no en el resto del búfer. Las búsquedas solo funcionarán con la región reducida, no fuera de ella, de esta forma si estás reparando una parte de un documento, puedes mantener fuera la parte que no necesitas. (El atajo asociado a <code>narrow-to-region</code> es <kbd>C-x n n</kbd>.)</p>
<p>Sin embargo, la reduccion hace invisible el resto del búfer, lo que puede asustar a quien invoca inadvertidamente la reduccion y piensa que ha eliminado una parte de su fichero. Ademas, el comando <code>undo</code> (usualmente ligado a <kbd>C-x u</kbd>) no desactiva la reduccion (ni debe hacerlo), por lo que las personas pueden llegar a desesperarse si no saben que pueden devolver el resto del buffer visible cor el comando <code>widen</code> que es <kbd>C-x n w</kbd>.)</p>
<p>La reduccion es igual de util para el intérprete Lisp como para un humano. Con frecuencia, una función Emacs Lisp está diseñada para trabajar solo en parte de un búfer; o por el contrario, una función Emacs Lisp necesita trabajar en todo un búfer que ha sido reducido. La función <code>what-line</code>, por ejemplo, elimina la reduccion de un búfer, si este tiene alguna reduccion y al terminar su trabajo, restaura la reduccion. Por otro lado, la función <code>count-lines</code> utiliza la reduccion para restringirse a sí misma solo a la porción del búfer en la que se está interesado y luego restablece la situación anterior.</p>
</div>
<h3 id="la-forma-especial-save-restriction" >La forma especial <code>save-restriction</code></h3>
<div class="hBody-3" >
<p>En Emacs Lisp, se puede utilizar la forma especial <code>save-restriction</code> para llevar un registro de cualquier reduccion en efecto. Cuando el intérprete Lisp se encuentra con <code>save-restriction</code>, ejecuta el código en el cuerpo de la expresión <code>save-restriction</code>, y luego deshace cualquier cambio en la reduccion que el código proboco. Si, por ejemplo, el búfer es reducido y el código que sigue al comando <code>save-restriction</code> se deshace de la reduccion, <code>save-restriction</code> devuelve el búfer a su región reducida.  En el comando <code>what-line</code>, cualquier reduccion del búfer es deshecha por el comando <code>widen</code> inmediatamente despues del comando <code>save-restriction</code>. Se restaura cualquier reduccion original justo antes de finalizar la función.</p>
<p>La plantilla para una expresión <code>save-restriction</code> es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-restriction</span>
  <span class="nv">cuerpo</span><span class="err">…</span> <span class="p">)</span>
</code></pre>
<p>El cuerpo de <code>save-restriction</code> es una o más expresiones que seran evaluadas de forma secuencial por el intérprete Lisp.</p>
<p>Finalmente, un punto a tener en cuenta: cuando utilices <code>save-excursion</code> y <code>save-restriction</code> a la vez, una detras de la otra, debes utilizar <code>save-excursion</code> primero. Si lo escribes en el orden inverso, es posible que no registre la reduccion en el búfer al que emacs debe cambiar Emacs despues de llamar a <code>save-excursion</code>. Por lo tanto, cuando escribas a la vez <code>save-excursion</code> y <code>save-restriction</code> debe ser así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="p">(</span><span class="nb">save-restriction</span>
    <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</code></pre>
<p>En otras circunstancias, cuando no se escriban a la vez, las formas especiales <code>save-excursion</code> y <code>save-restriction</code> deben escribirse en el orden adecuado para la función.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-restriction</span>
  <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</code></pre>
</div>
<h3 id="what-line" ><code>what-line</code></h3>
<div class="hBody-3" >
<p>El comando <code>what-line</code> informa el número de la línea en la que el cursor esta colocado. La función ilustra el uso de los comandos <code>save-restriction</code> y <code>save-excursion</code>. Aquí está el texto original de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">what-line</span> <span class="p">()</span>
  <span class="s">&#34;Imprime el numero de linea actual (en el bufer) del punto.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-restriction</span>
    <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">beginning-of-line</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Line %d&#34;</span>
               <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))))))</span>
</code></pre>
<p>(En versiones recientes de GNU Emacs, la función <code>what-line</code> se ha ampliado para informarte el numero de linea en un búfer reducido, asi como el número de línea en un búfer extendido. La versión reciente es más compleja que la versión que se muestra aqui. Si te sientes aventurero, puede que quieras verla despues de averiguar como funciona esta version. Probablemente necesites utilizar <kbd>C-h f</kbd> (<code>describe-function</code>). La nueva versión utiliza un condicional para determinar si se ha reducido el búfer.</p>
<p>(También, utiliza <code>line-number-at-pos</code>, que entre otras expresiones sencillas, como <code>(goto-char (point-min))</code>, mueve el punto al inicio de la línea actual con <code>(forward-line 0)</code> en lugar de <code>beginning-of-line</code>.)</p>
<p>La función <code>what-line</code> que se muestra aqui tiene una línea de documentación y es interactiva, como es de esperar. Las dos líneas siguientes utilizan las funciones <code>save-restriction</code> y <code>widen</code>.</p>
<p>La forma especial <code>save-restriction</code> observa cualquier reduccion activa, en el buffer actual y restaura la reduccion despues de evaluar el código de su cuerpo.</p>
<p>La forma especial <code>save-restriction</code> es seguida por <code>widen</code>. Esta función deshace cualquier reduccion que pudo haber tenido el búfer actual cuando se llama a <code>what-line</code>. (La reduccion que esta alli es la reduccion que <code>save-restriction</code> recuerda.) Esta ampliación hace posible que los comandos para el conteo de lineas cuenten desde el inicio del búfer. De lo contrario, se habría limitado a contar dentro de la región accesible. Cualquier reduccion original se restaura justo antes de completar la funcion por la forma especial <code>save-restriction</code>.</p>
<p>La llamada a <code>widen</code> va seguida por <code>save-excursion</code>, que guarda la posición del cursor (es decir, el punto) y la marca, y los restaura después despues de que el código en el cuerpo de <code>save-excursion</code> utiliza la función <code>beginning-of-line</code> para mover el punto.</p>
<p>(Ten en cuenta que la expresión <code>(widen)</code> ocurre entre las formas especiales <code>save-restriction</code> y <code>save-excursion</code>. Cuando escribas las dos expresiones <code>save-…</code> consecutivamente, escribe <code>save-excursion</code> primero.)</p>
<p>Las dos últimas líneas de la función <code>what-line</code> son funciones para contar el número de líneas en el búfer y luego imprimir el número en el área de eco.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Line %d&#34;</span>
         <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))))))</span>
</code></pre>
<p>La función <code>message</code> imprime un mensaje de una línea en la parte inferior de la pantalla de Emacs. El primer argumento esta dentro de comillas y se imprime como una cadena de caracteres. Sin embargo, contiene una expresión <samp>%d</samp> para imprimir el siguiente argumento. <samp>%d</samp> imprime el argumento como un decimal, por lo que el mensaje dirá algo como <samp>Línea 243</samp>.</p>
<p>El número que se imprime en lugar del <samp>%d</samp> se calcula por la última línea de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</code></pre>
<p>Lo que esto hace es contar las líneas desde la primer posición del búfer indicada por el <code>1</code>, hasta <code>(point)</code>, y luego sumar uno a este número. (La función <code>1+</code> suma uno a su argumento.) Se suma uno porque la línea 2 tiene solo una línea antes de ella, y <code>count-lines</code> cuenta solo las líneas <em>antes</em> de la línea actual.</p>
<p>Después que <code>count-lines</code> termina su trabajo, y se imprime el mensaje en el área de eco, la función <code>save-excursion</code> restaura el punto y marca a sus posiciones originales; y <code>save-restriction</code> restaura la reduccion original, si la hubiera.</p>
</div>
<h3 id="ejercicio-con-reduccion" >Ejercicio con Reduccion</h3>
<div class="hBody-3" >
<p>Escribe una función que muestre los primeros 60 caracteres del búfer actual, incluso si has reducido el búfer a la mitad de modo que la primer línea sea inaccesible. Restaura el punto, marca y la reduccion. Para este ejercicio, necesitas utilizar todo un popurri de funciones, incluyendo <code>save-restriction</code>, <code>widen</code>, <code>goto-char</code>, <code>point-min</code>, <code>message</code>, y <code>buffer-substring</code>.</p>
<p>(<code>buffer-substring</code> es una función que no aun no se menciona, tendrás que investigarla por tu cuenta; o quizás tengas que utilizar <code>buffer-substring-no-properties</code> o <code>filter-buffer-substring</code> …, u otras funciones. Las propiedades de texto son una funcionalidad que no sera discutida aquí. Vea la Seccion <a href="info:elisp#Text-Properties" >Propiedades de Texto</a> en <em>El Manual de Referencia de Emacs Lisp</em>.)</p>
<p>Además, ¿realmente se necesita <code>goto-char</code> o <code>point-min</code>?  ¿O se puede escribir la función sin ellas?</p>
</div>
<h2 id="car,-cdr,-cons:-funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</h2>
<div class="hBody-2" >
<p>En Lisp, <code>car</code>, <code>cdr</code>, y <code>cons</code> son funciones fundamentales. La función <code>cons</code> se utiliza para construir listas, y las funciones <code>car</code> y <code>cdr</code> se utilizan para desmontarlas.</p>
<p>En el recorrido a través de la función <code>copy-region-as-kill</code>, veremos <code>cons</code>, asi como dos variantes de <code>cdr</code>, llamadas <code>setcdr</code> y <code>nthcdr</code>. (Véa la Sección <a href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a>.)</p>
<p>El nombre de la función <code>cons</code> no es irazonable: es una abreviatura de la palabra ‘construct’ (<q>construir</q>). Por otra parte, el origen de los nombres <code>car</code> y <code>cdr</code>, es esoterico: <code>car</code> es un acrónimo de la frase ‘Contents of the Address part of the Register’ (<q>Contenidos de las Direcciónes parte del Registro</q>); y <code>cdr</code> (pronunciado ‘could-er’) es un acrónimo de la frase ‘Contents of the Decrement part of the Register’ (<q>Contenidos de la parte de Decremento del Registro</q>). Estas frases se refieren a piezas específicas de hardware en el ordenador en el que se desarrollo el Lisp original. Ademas de ser obsoletas, las frases han sido completamente irrelevantes por más de 25 años para cualquiera que piense en Lisp. No obstante, aunque algunos pocos académicos valientes han empezado a utilizar nombres más razonables para estas funciones, los viejos términos aun continuan en uso. En particular, porque los términos se utilizan en el código fuente de Emacs Lisp, los usaremos en esta introducción.</p>
</div>
<h3 id="car-y-cdr" ><code>car</code> y <code>cdr</code></h3>
<div class="hBody-3" >
<p>El <code>car</code> de una lista es sencillamente, el primer elemento de la lista. De este modo, el <code>car</code> de la lista <code>(rosa violeta margarita tulipan)</code> es <code>rosa</code>.</p>
<p>Si estás leyendo esto en GNU Emacs, puedes verlo evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>Después de evaluar la expresión, aparecerá <code>rosa</code> en el área de eco.</p>
<p>Claramente, un nombre más razonable para la función <code>car</code> sería <code>first</code> y esto es con frecuencia lo que se sugiere.</p>
<p><code>car</code> no elimina el primer elemento de la lista; solo informa de lo que es. Después de aplicar <code>car</code> a una lista, la lista sigue siendo la misma que antes. En la jerga, <code>car</code> es ‘no destructiva’. Esta caracteristica resulta ser importante.</p>
<p>El <code>cdr</code> de una lista es el resto de la lista, es decir, la función <code>cdr</code> devuelve la parte de la lista que sigue al primer elemento. Por lo tanto, mientras que el <code>car</code> de la lista <code>&#39;(rosa violeta margarita tulipan)</code> es <code>rosa</code>, el resto de la lista, el valor devuelto por la función <code>cdr</code>, es <code>(violeta margarita tulipan)</code>.</p>
<p>Puedes ver esto evaluando lo siguiente del modo habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>Al evaluar esto, aparece <code>(violeta margarita tulipan)</code> en el área de eco.</p>
<p>Al igual que <code>car</code>, <code>cdr</code> no elimina los elementos de la lista––simplemente devuelve un informe del segundo y los subsiguientes elementos presentes.</p>
<p>A propositio, en el ejemplo, se cita la lista de flores. De otra forma, el intérprete Lisp intentaría evaluar la lista llamando a <code>rosa</code> como una función. En este ejemplo, no queremos hacer esto.</p>
<p>Claramente, un nombre más razonable para <code>cdr</code> sería <code>rest</code> (<q>resto</q>).</p>
<p>(Hay una lección aquí: Cuando des nombre a nuevas funciones, considera muy cuidadosamente lo que estes haciendo, ya que puedes adherirte a los nombres mas tiempo del esperado. La razón por la que este documento perpetúa estos nombres se debe a que el código fuente de Emacs Lisp usa, y de no usarlos, tendrias dificultades para leer el codigo; por favor, intenta evitar usar estos términos por tu cuenta. Las personas que vengan después te lo agradecerán.</p>
<p>Cuando se aplican <code>car</code> y <code>cdr</code> a una lista compuesta por símbolos, como la lista <code>(pino abeto roble arce)</code>, el elemento de la lista devuelto por la función <code>car</code> es el símbolo <code>pino</code> sin ningun paréntesis alrededor. <code>pino</code> es el primer elemento en la lista. Sin embargo, el <code>cdr</code> de la lista es una lista en si misma, <code>(abeto roble arce)</code>, como puedes observar al evaluar las siguientes expresiones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</code></pre>
<p>Por otro lado, en una lista de listas, el primer elemento es en sí mismo una lista. <code>car</code> devuelve este primer elemento como una lista. Por ejemplo, la siguiente lista contiene tres sub-listas, una lista de carnívoros, una lista de herbívoros y una lista de mamíferos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ballena</span> <span class="nv">delfin</span> <span class="nv">foca</span><span class="p">)))</span>
</code></pre>
<p>En este ejemplo, el primer elemento de <code>car</code> de la lista es la lista de carnívoros, <code>(leon tigre leopardo)</code>, y el resto de la lista es <code>((gacela antilope cebra) (ballena delfin foca))</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ballena</span> <span class="nv">delfin</span> <span class="nv">foca</span><span class="p">)))</span>
</code></pre>
<p>vale la pena decir nuevamente que <code>car</code> y <code>cdr</code> son no destructivos––es dicir, no modifican ni cambian las listas a las que se aplican. Esto es muy importante para su uso.</p>
<p>En el primer capítulo, en la discusión sobre los átomos, dije que en Lisp, “ciertos tipos de átomos, como un arreglo, pueden ser separados en partes; pero el mecanismo para hacer esto es diferente del mecanismo para separar una lista. Para Lisp, los átomos de una lista son indivisibles.” (Vea la Seccion <a href="#átomos-lisp" >Átomos Lisp</a>.) Las funciones <code>car</code> y <code>cdr</code> se utilizan para dividir listas y se consideran fundamentales en Lisp. Ya que no se puede dividir o tener acceso a las partes de un arreglo, un arreglo se considera un átomo. Por otro lado, la otra función fundamental, <code>cons</code>, puede armar o construir una lista, pero no un arreglo. (Los arreglos se manejan mediante funciones especificas de arreglos. Vea la Seccion <a href="info:elisp#Arrays" >Arreglos</a> en el <em>El Manual de Referencia de GNU Emacs Lisp</em>.)</p>
</div>
<h3 id="cons" ><code>cons</code></h3>
<div class="hBody-3" >
<p>La función <code>cons</code> construye listas; que es lo opuesto a <code>car</code> y <code>cdr</code>. Por ejemplo, se puede utilizar <code>cons</code> para hacer una lista de cuatro elementos de la lista de tres elementos, <code>(abeto roble arce)</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;pino</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</code></pre>
<p>Después de evaluar esto, veras aparecer</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
</code></pre>
<p>en el área de eco. <code>cons</code> produce una nueva lista en la que el elemento es seguido por los elementos de la lista original.</p>
<p>Con frecuencia decimos que ‘<code>cons</code> coloca un nuevo elemento al principio de una lista; que agrega o empuja el elemento en la lista’, pero esta frase puede ser engañosa, ya que <code>cons</code> no modifica una lista existente, sino que crea una nueva.</p>
<p>Al igual que <code>car</code> y <code>cdr</code>, <code>cons</code> es no destructivo.</p>
<p><code>cons</code> debe tener una lista a unir.<span class="note" ><sup><a href="#9" >9</a></sup></span> No puedes iniciar de la nada absoluta. Si estás construyendo una lista, es necesario proporcionar al menos una lista vacía al inicio. Aquí hay una serie de expresiones <code>cons</code> que construyen una lista de flores. Si está leyendo esto en GNU Emacs, puedes evaluar cada una de las expresiones para corroborar el resultado.</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;tulipan</span> <span class="p">())</span>
</span><span class="out" >(tulipan)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;margarita</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >(margarita tulipan)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;violeta</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >(violeta margarita tulipan)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;rosa</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >(rosa violeta margarita tulipan)
</span></code></pre>
<p>En el primer ejemplo, la lista vacía se muestra como <code>()</code> y se construye una lista compuesta por <code>tulipan</code> seguida por la lista vacía. Como puedes ver, la lista vacía no se muestra en la lista que fué construida. Todo lo que ves es <code>(tulipan)</code>. La lista vacía no cuenta como un elemento de una lista porque no hay nada en una lista vacía. En terminos generales, una lista vacía es invisible.</p>
<p>El segundo ejemplo, <code>(cons &#39;margarita &#39;(tulipan))</code> construye una nueva lista de dos elemento colocando <code>margarita</code> delante de <code>tulipan</code>; y el tercer ejemplo construye una lista de tres elementos colocando <code>violeta</code> delante de <code>margarita</code> y <code>tulipan</code>.</p>
</div>
<h4 id="descubrir-la-longitud-de-una-lista:-length" >Descubrir la longitud de una lista: <code>length</code></h4>
<div class="hBody-4" >
<p>Pueden averiguar cuántos elementos hay en una lista utilizando la función Lisp <code>length</code>, como en los siguientes ejemplos:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >1
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >2
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;violeta</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">)))</span>
</span><span class="out" >3
</span></code></pre>
<p>En el tercer ejemplo, la función <code>cons</code> se utiliza para construir una lista de tres elementos que se pasa como argumento a la función <code>length</code>.</p>
<p>También podemos utilizar <code>length</code> para contar el número de elementos en una lista vacía:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="p">())</span>
</span><span class="out" >0
</span></code></pre>
<p>Como era de esperar, el número de elementos en una lista vacía es cero.</p>
<p>Un experimento interesante es averiguar qué ocurre si se intenta encontrar la longitud de ninguna lista; es decir, si se intenta llamar a <code>length</code> sin darle un argumento, ni siquiera una lista vacía:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span> <span class="p">)</span>
</code></pre>
<p>La que se ve, si evalúas esto, es el mensaje de error</p>
<div class="example-block" >
<pre class="example" >Lisp error: (wrong-number-of-arguments length 0)
</pre>
</div>
<p>Esto significa que la función recibe un número incorrecto de argumentos, cero, cuando se espera algún otro número de argumentos. En este caso, se espera un argumento, el argumento es una lista cuya longitud mide la función. (Ten en cuenta que <em>una</em> lista es <em>un</em> argumento, incluso si la lista tiene muchos elementos en su interior.)</p>
<p>La parte del mensaje de error que dice <samp>length</samp> es el nombre de la función.</p>
</div>
<h3 id="nthcdr" ><code>nthcdr</code></h3>
<div class="hBody-3" >
<p>La función <code>nthcdr</code> se asocia con la función <code>cdr</code>. Lo que hace es tomar la <code>cdr</code> de una lista repetidamente.</p>
<p>Si tomas el <code>cdr</code> de la lista <code>(pino abeto roble arce)</code>, te devuelve la lista <code>(abeto roble arce)</code>. Si repites esto al retorno, devolverá la lista <code>(roble arce)</code>. (Por supuesto, repetir <code>cdr</code> en la lista original solo dará el <code>cdr</code> original, ya que la función no cambia la lista. Necesitas evaluar el <code>cdr</code> del <code>cdr</code> y así sucesivamente.) Si esto contiúa, finalmente se devuelve una lista vacía, que en este caso, en vez de mostrarse como <code>()</code> se muestra como <code>nil</code>.</p>
<p>Para comprovarlo, aquí hay una serie de <code>cdr</code>s repetidos.</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(abeto roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >nil
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="ss">&#39;nil</span><span class="p">)</span>
</span><span class="out" >nil
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="p">())</span>
</span><span class="out" >nil
</span></code></pre>
<p>También puedes hacer varios <code>cdr</code>s sin imprimir los valores intermedios, de esta forma:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)))</span>
</span><span class="out" >(roble arce)
</span></code></pre>
<p>En este ejemplo, el intérprete Lisp primero evalúa la lista mas interna. La lista mas interna se cita, por lo que solo pasa la lista tal cual al <code>cdr</code> interno. Este <code>cdr</code> pasa una lista formada por el segundo y los subsiguientes elementos de la lista al <code>cdr</code> externo, que produce una lista compuesta del tercer y los subsiguientes elementos de la lista original. En este ejemplo, la función <code>cdr</code> se repite y devuelve una lista que consiste en la lista original sin sus primeros dos elementos.</p>
<p>La función <code>nthcdr</code> hace lo mismo que repetir la llamada a <code>cdr</code>. En el siguiente ejemplo, el argumento 2 se pasa a la función <code>nthcdr</code>, junto con la lista, y el valor devuelto es la lista sin sus dos primeros elementos, que es exactamente los mismos que repetir dos veces <code>cdr</code> en la lista:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(roble arce)
</span></code></pre>
<p>Utilizando la lista original de cuatro elementos, podemos ver qué ocurre cuando se pasan varios argumentos numéricos a <code>nthcdr</code>, incluyendo 0, 1, y 5:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Deja la lista como estaba.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(pino abeto roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia sin el primer elemento.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(abeto roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia de la lista sin tres elementos.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia sin los cuatro elementos.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">4</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >nil
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia sin todos los elementos.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">5</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >nil
</span></code></pre>
</div>
<h3 id="nth" ><code>nth</code></h3>
<div class="hBody-3" >
<p>La función <code>nthcdr</code> toma el <code>cdr</code> de una lista repetidamente. La función <code>nth</code> toma el <code>car</code> del resultado devuelto por <code>nthcdr</code>. Devuelve el enesimo elemento de la lista.</p>
<p>Por lo tanto, si <code>nth</code> no estubiera definido en C por velocidad, su definición sería:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nf">nth</span> <span class="p">(</span><span class="nv">n</span> <span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Devuelve el N-esimo elemento de la lista.
</span><span class="s">N cuenta apartir de cero. Si LIST no es tan largo, devuelve nil.&#34;</span>
  <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="nv">n</span> <span class="nf">list</span><span class="p">)))</span>
</code></pre>
<p>(Originalmente, <code>nth</code> se definio en Emacs Lisp dentro de <span class="file" >subr.el</span>, pero su definición fué rehecha en C en los 1980s.)</p>
<p>La función <code>nth</code> devuelve un solo elemento de una lista. Esto puede ser muy conveniente.</p>
<p>Toma en cuenta que los elementos estan numerados apartir del cero, no de uno. Es decir, el primer elemento de una lista, su <code>car</code> es el elemento cero. Esto se llama contar en ‘base a cero’ y con frecuencia molesta a las personas que estan acostumbradas a que el primer elemento en una lista sea el número uno, que es ‘basado en uno’.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nth</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;uno&#34;</span> <span class="s">&#34;dos&#34;</span> <span class="s">&#34;tres&#34;</span><span class="p">))</span>
</span><span class="out" >&#34;uno&#34;

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nth</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;uno&#34;</span> <span class="s">&#34;dos&#34;</span> <span class="s">&#34;tres&#34;</span><span class="p">))</span>
</span><span class="out" >&#34;dos&#34;
</span></code></pre>
<p>Vale la pena mencionar que <code>nth</code>, al igual que <code>nthcdr</code> y <code>cdr</code>, no modifica la lista original––la función es no destructiva. Esto contrasta fuertemente con las funciones <code>setcar</code> y <code>setcdr</code>.</p>
</div>
<h3 id="setcar" ><code>setcar</code></h3>
<div class="hBody-3" >
<p>Como podrías adivinar desde sus nombres, las funciones <code>setcar</code> y <code>setcdr</code> asignan el <code>car</code> o el <code>cdr</code> de una lista a un nuevo valor. Ambos cambian realmente la lista original, a diferencia de <code>car</code> y <code>cdr</code> que dejan la lista original como estaba. Una forma de averiguar cómo funcionan es experimentar. Vamos a empezar con la función <code>setcar</code>.</p>
<p>Primero, podemos crear una lista y luego asignar el valor de una variable a la lista, usando la función <code>setq</code>. Aquí hay una lista de animales:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">antilope</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>
</code></pre>
<p>Si estás leyendo esto dentro de GNU Emacs, puedes evaluar esta expresión de la forma habitual, coloca el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>. (Estoy haciendo esto aqui mismo, mientras lo escribo. Esta es una de las ventajas de tener el intérprete construido dentro del entorno informatico. Por cierto, cuando no hay nada en la línea después del paréntesis final, como un comentario, el punto puede estar en la siguiente línea. De este modo, si tu cursor está en la primera columna de la siguiente línea, no es necesario moverlo. En realidad, Emacs permite cualquier cantidad de espacios en blanco después del paréntesis final.)</p>
<p>Cuando evaluamos la variable <code>animales</code>, vemos que está unida a la lista <code>(antilope jirafa leon tigre)</code>:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales</span>
</span><span class="out" >(antilope jirafa leon tigre)
</span></code></pre>
<p>Dicho de otro modo, la variable <code>animales</code> apunta a la lista <code>(antilope jirafa leon tigre)</code>.</p>
<p>A continuacion, evalua la función <code>setcar</code> mientras le pasas dos argumentos, la variable <code>animales</code> y el símbolo citado <code>hipopotamo</code>; esto se hace escribiendo la lista de tres elementos <code>(setcar animales &#39;hipopotamo)</code> y luego evaluandola de la forma habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">setcar</span> <span class="nv">animales</span> <span class="ss">&#39;hipopotamo</span><span class="p">)</span>
</code></pre>
<p>Después de evaluar esta expresión, evalúa la variable <code>animales</code> de nuevo. Veras que la lista de animales ha cambiado:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales</span>
</span><span class="out" >(hipopótamo jirafa leon tigre)
</span></code></pre>
<p>El primer elemento de la lista, <code>antilope</code> es reemplazado por <code>hipopotamo</code>.</p>
<p>Así podemos ver que <code>setcar</code> no agrega un nuevo elemento a la lista como haria <code>cons</code>; Se reemplaza <code>antílope</code> con <code>hipopótamo</code>; esto <em>cambia</em> la lista.</p>
</div>
<h3 id="setcdr" ><code>setcdr</code></h3>
<div class="hBody-3" >
<p>La función <code>setcdr</code> es similar a la función <code>setcar</code>, excepto que la función reemplaza el segundo y subsiguientes elementos de una lista en lugar del primer elemento.</p>
<p>(Para ver cómo cambiar el último elemento de una lista, mira directamente en la Seccion <a href="#la-función-kill-new" >La función <code>kill-new</code></a>, que utiliza las funciones <code>nthcdr</code> y <code>setcdr</code>.)</p>
<p>Para ver cómo funciona esto, asigna el valor de la variable a una lista de animales domesticados evaluando la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales-domesticos</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">caballo</span> <span class="nv">vaca</span> <span class="nv">oveja</span> <span class="nv">cabra</span><span class="p">))</span>
</code></pre>
<p>Si evalúas la lista, debe devolverte la lista <code>(caballo vaca oveja cabra)</code>:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales-domesticos</span>
</span><span class="out" >(caballo vaca oveja cabra)
</span></code></pre>
<p>Luego, evalúa <code>setcdr</code> con dos argumentos, el nombre de la variable que tiene una lista como su valor, y la lista a la que se establecera el <code>cdr</code> de la primera lista;</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">setcdr</span> <span class="nv">animales-domesticos</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gato</span> <span class="nv">perro</span><span class="p">))</span>
</code></pre>
<p>Si evalúas esta expresión, la lista <code>(gato perro)</code> aparecerá en el área echo. Este es el valor devuelto por la función. El resultado que nos interesa es el “efecto secundario”, que podemos ver evaluando la variable <code>animales-domesticos</code>:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales-domesticos</span>
</span><span class="out" >(caballo gato perro)
</span></code></pre>
<p>En efecto, la lista cambia de <code>(caballo vaca oveja cabra)</code> a <code>(caballo gato perro)</code>. El <code>cdr</code> de la lista cambia de <code>(vaca oveja cabra)</code> a <code>(gato perro)</code>.</p>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Construye una lista de cuatro pájaros evaluando varias expresiones con <code>cons</code>. Descubre que ocurre cuando aplicas <code>cons</code> a una lista sobre si misma. Reemplaza el primer elemento de la lista de cuatro pájaros con un pez. Reemplaza el resto de esta lista con una lista de otros peces.</p>
</div>
<h2 id="corte-y-almacenamiento-de-texto" >Corte y Almacenamiento de Texto</h2>
<div class="hBody-2" >
<p>Siempre se corta o guarda texto de un búfer con un comando ‘kill’, se almacena en una lista y puedes traerlo de vuelta con un comando ‘yank’.</p>
<p>(El uso de la palabra ‘kill’ (<q>matar</q>) en Emacs para procesos que específicamente <em>no</em> destruyen los valores de las entidades es un accidente histórico desafortunado. Una palabra mucho más apropiada seria ‘clip’ (<q>cortar</q>) ya que eso es lo que hacen los comandos <samp>kill</samp>; recortan el texto de un búfer y lo guardan en un almacenamiento, donde puede traerse de vuelta. Con frecuencia me he sentido tentado a sustituir globalmente todas las apariciones de ‘kill’ en el codigo de Emacs con ‘clip’ y todas las apariciones de ‘killed’ (destruido) con ‘clipped’ (cortado).)</p>
<p>Cuando el texto se corta de un búfer, se almacena en una lista. Fragmentos de texto se almacenan en la lista sucesivamente, por lo que la lista podría verse así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;una pieza de texto&#34;</span> <span class="s">&#34;pieza anterior&#34;</span><span class="p">)</span>
</code></pre>
<p>La función <code>cons</code> se puede utilizar para crear una nueva lista a partir de un trozo de texto (un ‘átomo’, para usar la jerga) y una lista existente, como esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cons</span> <span class="s">&#34;otra pieza&#34;</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;una pieza de texto&#34;</span> <span class="s">&#34;pieza anterior&#34;</span><span class="p">))</span>
</code></pre>
<p>Si evaluas esta expresión, aparecera una lista de tres elementos en el área de eco:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;otra pieza&#34;</span> <span class="s">&#34;una pieza de texto&#34;</span> <span class="s">&#34;pieza anterior&#34;</span><span class="p">)</span>
</code></pre>
<p>Puedes recuperar cualquier pieza de texto que desees, con las funciones <code>car</code> y <code>nthcdr</code>. Por ejemplo, en el siguiente código, <code>nthcdr 1 …</code> devuelve la lista con el primer elemento eliminado; y <code>car</code> devuelve el primer elemento de ese resto––el segundo elemento de la lista original:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;otra pieza&#34;</span>
                 <span class="s">&#34;una pieza de texto&#34;</span>
                 <span class="s">&#34;pieza anterior&#34;</span><span class="p">)))</span>
</span><span class="out" >&#34;una pieza de texto&#34;
</span></code></pre>
<p>Por supuesto, las funciones reales en Emacs son más complejas que esto. El código para el corte y recuperarcion de texto tiene que ser escrito de modo que Emacs pueda determinar qué elemento en la lista se quiere––el primero, segundo, tercero o cualquier otro. Además, cuando se llega al final de la lista, Emacs deberia darte el primer elemento de la lista, en lugar de nada en absoluto.</p>
<p>La lista que contiene los trozos de texto se llama <dfn>kill ring</dfn> (<q>anillo de la muerte</q>). En este capítulo se hace una descripción del anillo de la muerte y como se utiliza para un primer rastreo en la función <code>zap-to-char</code>. Esta función utiliza (o ‘llama’) a una función que invoca a otra función que manipula el anillo de la muerte. Por la tanto, antes de llegar a las montañas, debemos escalar las colinas.</p>
<p>En un capítulo posterior se describe cómo se recupera el texto que se corta de un buffer. Ver Sección <a href="#pegando-texto" >Pegando texto</a>.</p>
</div>
<h3 id="zap-to-char" ><code>zap-to-char</code></h3>
<div class="hBody-3" >
<p>La función <code>zap-to-char</code> apenas ha variado entre la versión 19 y 22 de GNU Emacs. Sin embargo, <code>zap-to-char</code> llama a otra función, <code>kill-region</code>, que ha tenido una reescritura importante.</p>
<p>La función <code>kill-region</code> en Emacs 19 es compleja, pero no utiliza código que sea importante en este momento. Nos Lo saltaremos.</p>
<p>La función <code>kill-region</code> en Emacs 22 es más de fácil de leer que la misma función en Emacs 19 e introduce un concepto muy importante, la gestion de errores. Caminaremos a través de la función.</p>
<p>Pero primero, veamos la función interactiva <code>zap-to-char</code>.</p>
<p>La función <code>zap-to-char</code> elimina el texto en la región entre la ubicacion del cursor (es decir. del punto) hasta e incluyendo la siguiente aparicion de un caracter específicado. El texto que <code>zap-to-char</code> elimina se pone en el anillo de la muerte; y se puede recuperar escribiendo <kbd>C-y</kbd> (<code>yank</code>). Si el comando recive un argumento, elimina el texto a través de este número de ocurrencias. Por lo tanto, si el cursor estuviera al inicio de esta frase y el carácter fuera <samp>s</samp>, se eliminaria <samp>Por la tanto, </samp>. Si el argumento fueran dos, se eliminaria <samp>Por lo tanto, si el curs</samp>, hasta e incluiendo la <samp>s</samp> en <samp>cursor</samp>.</p>
<p>Si no se encuentra el carácter específicado <code>zap-to-char</code> dirá “Búsqueda fallida”, te indicaria el caracter que escribiste, y no eliminara ningun texto.</p>
<p>Para determinar la cantidad de texto a eliminar <code>zap-to-char</code> utiliza una función de búsqueda. Las búsquedas se utilizan ampliamente en código que manipula el texto, y vamos a centrar la atención en ellos, asi como en el comando de eliminacion.</p>
<p>Aquí está el texto completo de la función en la versión 22:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">zap-to-char</span> <span class="p">(</span><span class="nv">arg</span> <span class="nv">char</span><span class="p">)</span>
  <span class="s">&#34;Corta e incluye la aparicion de la enesima ocurrencia (ARG) del caracter CHAR.
</span><span class="s">Se ignora entre mayusculas y minusculas si ‘case-fold-search’ es no-nil en
</span><span class="s">el buffer actual.
</span><span class="s">Retrocede si ARG es negativo; error si CHAR no se encuentra.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">char-table-p</span> <span class="nv">translation-table-for-input</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">char</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">aref</span> <span class="nv">translation-table-for-input</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">char</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nb">progn</span>
                         <span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</code></pre>
<p>La linea de documentacion esta traducida al español. En la version original no se utiliza la palabra ‘Corta’ en su lugar se utiliza ‘kill’.</p>
</div>
<h4 id="la-expresión-interactive" >La expresión <code>interactive</code></h4>
<div class="hBody-4" >
<p>La expresión interactiva en el comando <code>zap-to-char</code> es esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
</code></pre>
<p>La parte entre comillas, <code>&#34;p\ncZap to char: &#34;</code>, especifica dos cosas diferentes. Primero, y lo mas sencillo, es la <samp>p</samp>. Esta parte se separa de la siguiente parte por una línea nueva, <samp>\n</samp>. La <samp>p</samp> significa que el primer argumento de la función será pasando el valor de un ‘prefijo procesado’. El argumento prefijo se pasa escribiendo <kbd>C-u</kbd> y un número, o <kbd>M-</kbd> y un número. Si la función se llamada interactivamente sin un prefijo, se pasa 1 a este argumento.</p>
<p>La segunda parte de <code>&#34;p\ncZap to char: &#34;</code> es <samp>cZap to char:</samp>. En esta parte, la <samp>c</samp> minuscula indica que <code>interactive</code> espera un prompt y que el argumento será un caracter. El prompt va despues de <samp>c</samp> y es la cadena <samp>Zap to char: </samp> (con un espacio después de los dos puntos para verse bien).</p>
<p>Todo lo que esto hace es preparar los argumentos de <code>zap-to-char</code> para que sean del tipo correcto, y darle al usuario un prompt.</p>
<p>En un búfer de solo lectura, la función <code>zap-to-char</code> copia el texto al anillo de la muerte, pero no lo elimina. El área de eco muestra un mensaje diciendo que el búfer es de solo lectura. Ademas, el terminal puede emitir un pitido o parpadear.</p>
</div>
<h4 id="el-cuerpo-de-zap-to-char" >El cuerpo de <code>zap-to-char</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>zap-to-char</code> contiene el código que mata (es decir, elimina) el texto en la región desde la posición actual del cursor hasta e incluyendo el carácter especificado.</p>
<p>La primera parte del código se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">char-table-p</span> <span class="nv">translation-table-for-input</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">char</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">aref</span> <span class="nv">translation-table-for-input</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">char</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nb">progn</span>
                       <span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
                       <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</code></pre>
<p><code>char-table-p</code> es una función que aun no hemos visto. Determina si su argumento es una tabla de caracteres. Si lo es, establece el caracter pasado a <code>zap-to-char</code> a uno de ellos, si ese carácter existe, o al carácter en sí. (Esto es importante para ciertos caracteres en lenguas no Europeas. La función <code>aref</code> extrae un elemento desde un arreglo. Esta funcion es específica para arreglos y no sera descrita en este documento. Vea la Seccion <a href="info:elisp#Arrays" >Arreglos</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.)</p>
<p><code>(point)</code> es la posición actual del cursor.</p>
<p>La siguiente parte del código es una expresión utilizando <code>progn</code>. El cuerpo del <code>progn</code> consiste en llamadas a <code>search-forward</code> y <code>point</code>.</p>
<p>Es fácil comprender cómo funciona <code>progn</code> después de aprender sobre <code>search-forward</code>, asi que veremos <code>search-forward</code> y luego <code>progn</code>.</p>
</div>
<h4 id="la-función-search-forward" >La Función <code>search-forward</code></h4>
<div class="hBody-4" >
<p>La función <code>search-forward</code> se utiliza para localizar el caracter a borrar en <code>zap-to-char</code>. Si la búsqueda es exitosa, <code>search-forward</code> deja el punto inmediatamente después del último carácter en la cadena objetivo. (En <code>zap-to-char</code>, la cadena objetivo tiene solo un carácter longitud. <code>zap-to-char</code> usa la función <code>char-to-string</code> para asegurar que el computador trata este carácter como una cadena). Si la búsqueda es hacia atrás, <code>search-forward</code> deja el punto justo antes del primer carácter en el objetivo. Ademas, <code>search-forward</code> devuelve <code>t</code> para verdadero. (Por lo tanto, desplazar el punto es un ‘efecto secundario’.)</p>
<p>En <code>zap-to-char</code>, la función <code>search-forward</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
</code></pre>
<p>La función <code>search-forward</code> utiliza cuatro argumentos:</p>
<ol class="num" >
<li>
<p>El primer argumento es el objetivo, que esta buscando. Debe ser una cadena, como <q>z</q>.</p>
<p>Sucede que el argumento pasado a <code>zap-to-char</code> es un solo caracter. Debido a la forma en la que se construyen los computadores, el intérprete Lisp puede tratar un solo caracter de forma distinta a una cadena de caracteres. Dentro del computador, un solo caracter tiene un formato electrónico diferente a una cadena de un caracteres. (Un solo caracter con frecuencia puede grabarse en el computador utilizardo exactamente un byte; pero una cadena puede ser mas larga, y el equipo debe estar listo para ello.) Ya que la función <code>search-forward</code> busca una cadena, el caracter que recive la función <code>zap-to-char</code> como argumento debe convertirse dentro del computador de un formato a otro; de lo contrario, la función <code>search-forward</code> fallará. Se utiliza la función <code>char-to-string</code> para realizar esta conversión.</p>
</li>
<li>
<p>El segundo argumento limita la búsqueda; se especifica como una posición en el búfer. En este caso, la búsqueda puede ir al final del búfer, por lo que no se establece ningun limite y el segundo argumento es <code>nil</code>.</p>
</li>
<li>
<p>El tercer argumento le dice a la función lo que debe hacer si la búsqueda falla––puede señalar un error (e imprimir un mensaje) o puede devolver <code>nil</code>. Un <code>nil</code> como el tercer argumento hace que la función señåle un error cuando la búsqueda falla.</p>
</li>
<li>
<p>El cuarto argumento de <code>search-forward</code> es el numero de repeticion––cuántas ocurrencias de la cadena hay que buscar. Este argumento es opcional y si la función se llamada sin contador de repeticion, este argumento pasa el valor 1. Si este argumento es negativo, la búsqueda va hacia atrás.</p>
</li>
</ol>
<p>En formato plantilla, una expresión <code>search-forward</code> tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">search-forward</span> <span class="s">&#34;cadena-a-buscar&#34;</span>
                <span class="nv">limite-de-busqueda</span>
                <span class="nv">que-hacer-si-la-busqueda-falla</span>
                <span class="nv">contador-de-repeticion</span><span class="p">)</span>
</code></pre>
<p>A continuacion veremos <code>progn</code>.</p>
</div>
<h4 id="la-forma-especial-progn" >La forma especial <code>progn</code></h4>
<div class="hBody-4" >
<p><code>progn</code> es una forma especial que hace que cada uno de sus argumentos sea evaluado en secuencia y luego devuelve el valor del último. Las expresiones anteriores solo se evaluan por los efectos secundarios que realizan. Los valores que producen son descartados.</p>
<p>La plantilla de una expresión <code>progn</code> es muy simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">progn</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>En <code>zap-to-char</code>, la expresión <code>progn</code> tiene que hacer dos cosas: poner el punto exactamente en la posición correcta; y devolver la posición del punto para que <code>kill-region</code> sepa handa donde cortar.</p>
<p>El primer argumento de <code>progn</code> es <code>search-forward</code>. Cuando <code>search-forward</code> encuentra la cadena, la función deja el punto inmediatamente después del último caracter en la cadena objetivo. (En este caso la cadena objetivo tiene solo un carácter de longitud.) Si la búsqueda es hacia atrás, <code>search-forward</code> deja el punto justo antes del primer carácter objetivo. El movimiento del punto es un efecto secundario.</p>
<p>El segundo y último argumento de <code>progn</code> es la expresión <code>(point)</code>. Esta expresión devuelve el valor del punto, que en este caso será la ubicacion a la que se ha movido por <code>search-forward</code>. (En el codigo, una línea le indica a la función que debe ir un carácter atras, si va hacia adelante, se comentó en 1999; yo no recuerdo si esta caracteriscita o funcion incorrecta alguna vez fue parte del codigo distribuido.) El valor de <code>point</code> es devuelto por la expresión <code>progn</code> y se pasa a <code>kill-region</code> como el segundo argumento de <code>kill-region</code> .</p>
</div>
<h4 id="resumiendo-zap-to-char" >Resumiendo <code>zap-to-char</code></h4>
<div class="hBody-4" >
<p>Ahora que hemos visto cómo funcionan <code>search-forward</code> y <code>progn</code>, podemos ver cómo la función <code>zap-to-como</code> trabaja como un todo.</p>
<p>El primer argumento de <code>kill-region</code> es la posición del cursor cuando se da el comando <code>zap-to-char</code>––el valor de punto en ese momento. Dentro de <code>progn</code>, la funcion de búsqueda mueve el punto justo después del caracter a borrar y <code>point</code> devuelvan el valor esa ubicacion. La función <code>kill-region</code> reune estos dos valores de punto, el primero como el inicio de la región y el segundo como el final de la región, y elimina la región.</p>
<p>La forma especial <code>progn</code> es necesaria porque el comando <code>kill-region</code> toma dos argumentos; y fallaría si las expresiones <code>search-forward</code> y <code>point</code> se escribieran en secuencia como dos argumentos adicionales. La expresión <code>progn</code> es solo un argumento para <code>kill-region</code> y devuelve el valor que <code>kill-region</code> necesita para su segundo argumento.</p>
</div>
<h3 id="kill-region" ><code>kill-region</code></h3>
<div class="hBody-3" >
<p>La función <code>zap-to-char</code> utiliza la función <code>kill-region</code>. Esta función corta texto de una región y copia ese texto al anillo de la muerte, desde el que puede recuperarse.</p>
<p>La versión en Emacs 22 de esta funcion utiliza <code>condition-case</code> y <code>copy-region-as-kill</code>, ambas seran explicadas. <code>condition-case</code> es una forma especial importante.</p>
<p>En esencia, la función <code>kill-region</code> llama a <code>condition-case</code>, que toma tres argumentos. En esta función, el primer argumento no hace nada. El segundo argumento contiene el código que hace el trabajo cuando todo va bien. El tercer argumento contiene el código que se llama en caso de error.</p>
<p>Revisaremos el código de <code>condition-case</code> en un momento. Primero, veamos la definición de <code>kill-region</code>, con comentarios añadidos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-region</span> <span class="p">(</span><span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Kill (\&#34;corta\&#34;) el texto entre el punto y la marca.
</span><span class="s">Esto elimina el texto del buffer y lo guarda en el anillo de la muerte.
</span><span class="s">El comando \\[yank] puede recuperarlo desde alli. … &#34;</span>

  <span class="c1">;; • Puesto que el orden importa, primero pasa el punto.</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span><span class="p">)))</span>
  <span class="c1">;; • Y dinos si no podemos cortar el texto.</span>
  <span class="c1">;; ‘A menos que’ sea un ‘if’ sin parte then.</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
    <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;La marca no esta definida, asi que no hay ninguna region&#34;</span><span class="p">))</span>
  <span class="c1">;; • ‘condition-case’ toma tres argumentos.</span>
  <span class="c1">;;    Si el primer argumento es nil, como aqui,</span>
  <span class="c1">;;    la informacion del error no se almacena</span>
  <span class="c1">;;    para ser utilizado por otra funcion.</span>
  <span class="p">(</span><span class="nb">condition-case</span> <span class="no">nil</span>

      <span class="c1">;; • El segundo argumento de ‘condition-case’ le dice al</span>
      <span class="c1">;;    interprete Lisp que hacer cuando todo va bien.</span>

      <span class="c1">;;    Empieza con una funcion ‘let’ que extrae la cadena y</span>
      <span class="c1">;;    comprueba si existe. Si es asi (eso es lo que comprueba</span>
      <span class="c1">;;    ‘when’), esta llama a una funcion ‘if’ que determina</span>
      <span class="c1">;;    si el comando anterior fue otra llamada a ‘kill-region’;</span>
      <span class="c1">;;    si lo fue, el nuevo texto se añade al texto anterior; si</span>
      <span class="c1">;;    no, se llama a una funcion diferente, ‘kill-new’.</span>

      <span class="c1">;;    La funcion ‘kill-append’ concatena la cadena nueva y antigua.</span>
      <span class="c1">;;    La funcion ‘kill-new’ inserta el texto dentro de un nuevo</span>
      <span class="c1">;;    elemento en el anillo de la muerte.</span>

      <span class="c1">;;    ‘when’ es un ‘if’ sin una parte else. El segundo ‘when’</span>
      <span class="c1">;;    comprueba de nuevo si la cadena actual existe; Ademas,</span>
      <span class="c1">;;    comprueba si el comando anterior fue otra llamada a</span>
      <span class="c1">;;    ‘kill-region’. Si una u otra condicion es verdadera,</span>
      <span class="c1">;;    entonces establece que el comando actual sea ‘kill-region’.</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nf">string</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span> <span class="no">t</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nf">string</span>                    <span class="c1">;STRING es nil si BEG = END</span>
          <span class="c1">;; agrega esa cadena al anillo de la muerte, de uno forma u otra.</span>
          <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
              <span class="c1">;;    − ‘yank-handler’ es un argumento opcional de</span>
              <span class="c1">;;    ‘kill-region’ que indica a las funciones ‘kill-append’</span>
              <span class="c1">;;    y ‘kill-new’ como tratar las propiedades añadidas al</span>
              <span class="c1">;;    texto, como ‘negrita’ o ‘cursiva’.</span>
              <span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">kill-new</span> <span class="nf">string</span> <span class="no">nil</span> <span class="nv">yank-handler</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">or</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;kill-region</span><span class="p">))</span>
        <span class="no">nil</span><span class="p">)</span>

    <span class="c1">;;  • El tercer argumento de ‘condition-case’ le dice al interprete</span>
    <span class="c1">;;    que hacer con un error.</span>
    <span class="c1">;;    El tercer argumento tiene una parte de condiciones y una parte cuerpo.</span>
    <span class="c1">;;    Si se cumplen las condiciones (en este caso,</span>
    <span class="c1">;;             si el texto o el buffer son de solo lectura)</span>
    <span class="c1">;;    entonces se ejecuta el cuerpo.</span>
    <span class="c1">;;    La primer parte del tercer argumento es la siguiente:</span>
    <span class="p">((</span><span class="nv">buffer-read-only</span> <span class="nv">text-read-only</span><span class="p">)</span> <span class="c1">;; la parte if</span>
     <span class="c1">;; …  la parte then</span>
     <span class="p">(</span><span class="nv">copy-region-as-kill</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
     <span class="c1">;;    A continuacion, tambien como parte de la parte then, establece</span>
     <span class="c1">;;    this-command, por lo que se establece en un error</span>
     <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
     <span class="c1">;;    Finalmente, en la pante then, envia un mensaje si puede copiar</span>
     <span class="c1">;;    el texto en el anillo de la muerte sin señalar un error, pero</span>
     <span class="c1">;;    no lo hace si no puede.</span>
     <span class="p">(</span><span class="nb">if</span> <span class="nv">kill-read-only-ok</span>
         <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Read only text copied to kill ring&#34;</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
       <span class="c1">;; Si el buffer no es de solo lectura, el texto lo es.</span>
       <span class="p">(</span><span class="ne">signal</span> <span class="ss">&#39;text-read-only</span> <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))))</span>
</code></pre>
</div>
<h4 id="condition-case" ><code>condition-case</code></h4>
<div class="hBody-4" >
<p>Como se ha visto antes (ver la Seccion <a href="#generar-un-mensaje-de-error" >Generar un Mensaje de Error</a>), cuando el intérprete de Emacs Lisp tiene problemas evaluando una expresión, te proporciona ayuda; en la jerga, esto se llama “Señalar un error”. Normalmente, el computador detiene el programa y te muestra un mensaje.</p>
<p>Sin embargo, algunos programas emprenden acciones complicadas. No deberian simplemente detenerse en un error. En la función <code>kill-region</code>, el error mas probable es que intente cortar texto que es de solo lectura y no puede ser eliminado. Así que la función <code>kill-region</code> contiene código para manejar esta circunstancia. Este código, que forma el cuerpo de la función <code>kill-region</code>, se encuentra dentro de una forma especial <code>condition-case</code>.</p>
<p>La plantilla para <code>condition-case</code> tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">condition-case</span>
  <span class="nv">var</span>
  <span class="nv">cuerpo</span>
  <span class="nv">gestor-de-errores</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>El segundo argumento, <code>cuerpo</code> es sencillo. La forma especial <code>condition-case</code> hace que el intérprete Lisp evalúe el código en <code>cuerpo</code>. Si no ocurre ningún error, la forma especial devuelve el valor del código y produce efectos secundarios, si los hubiera.</p>
<p>En resumen, la parte <code>cuerpo</code> de una expresión <code>condition-case</code> determina qué deberia suceder cuando todo funciona correctamente.</p>
<p>Sin embargo, si se produce un error, entre sus otras acciones, la función genera la señal de error que define uno o más nombres de condicion de error.</p>
<p>El gestor de errores es el tercer argumento de <code>condition-case</code>. Un gestor de errores tiene dos partes, un <code>nombre-de-condicion</code> y un <code>cuerpo</code>. Si la parte <code>nombre-de-condicion</code> de un gestor de errores coincide con un nombre de condicion generado por un error, se ejecuta la parte del <code>cuerpo</code> del gestor de errores.</p>
<p>Como es de esperar, la parte <code>nombre-de-condicion</code> de un gestor de errores puede ser un unico nombre de condicion o una lista de nombres de condición.</p>
<p>Ademas, una expresión <code>condition-case</code> completa puede contener más de un gestor de errores. Cuando se produce un error, se ejecuta el primer gestor aplicable.</p>
<p>Por ultimo, el primer argumento de la expresión <code>condition-case</code>, el argumento <code>var</code>, en ocaciones se vincula a una variable que contiene información sobre el error. Sin embargo, si este argumento es <code>nil</code>, como es el caso en <code>kill-region</code>, esa información se descarta.</p>
<p>En resumen, en la función <code>kill-region</code>, el código <code>condition-case</code> funciona de la siguiente manera:</p>
<div class="example-block" >
<pre class="example" >Si no hay errores, ejecuta solo este codigo
    pero, si hay errores, ejecuta este otro codigo.
</pre>
</div>
</div>
<h4 id="macro-lisp" >Macro Lisp</h4>
<div class="hBody-4" >
<p>La parte de la expresión <code>condition-case</code> que se evalúa en la expectativa de que todo va bien si tiene un <code>when</code>. El código utiliza <code>when</code> para determinar si la variable <code>string</code> apunta a texto que existe.</p>
<p>Una expresión <code>when</code> simplemente es una conveniencia para los programadores. Es un <code>if</code> sin la posibilidad de una cláusula else. En tu mente, puedes reemplazar <code>when</code> con <code>if</code> y entender lo que pasa. Eso es lo que hace el intérprete Lisp.</p>
<p>Técnicamente hablando, <code>when</code> es una macro Lisp. Una <dfn>macro</dfn> Lisp te permite definir nuevas construcciones de control y otras caracteristicas del lenguaje. Le indica al intérprete cómo calcular otra expresión Lisp que a su vez calcula el valor. En este caso, la ‘otra expresión’ es una expresión <code>if</code>.</p>
<p>La definición de la función <code>kill-region</code> también tiene una macro <code>unless</code>; es lo contario de <code>when</code>. La macro <code>unless</code> es un <code>if</code> sin una cláusula <code>then</code>.</p>
<p>Para optener más informacion sobre las macros Lisp, consulta la Seccion <a href="#info:elisp#Macros" >Macros</a> en <em>El Manual de Referencia de Emacs Lisp</em>. El lenguaje de programación C también proporciona macros. Estos son diferentes, pero también útiles.</p>
<p>Respecto a la macro <code>when</code>, en la expresión <code>condition-case</code>, cuando la cadena tiene contenido, se ejecuta otra expresión condicional. Esto es un <code>if</code> tanto con parte <code>then</code> como con una parte <code>else</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">kill-new</span> <span class="nf">string</span> <span class="no">nil</span> <span class="nv">yank-handler</span><span class="p">))</span>
</code></pre>
<p>La parte <code>then</code> se evalúa si el comando anterior era otra llamada a <code>kill-region</code>; si no, se evalúa la parte <code>else</code>.</p>
<p><code>yank-handler</code> es un argumento opcional de <code>kill-region</code> que indica a las funciones <code>kill-append</code> y <code>kill-new</code> como tratar con propiedades agregadas al texto, como ‘negrilla’ o ‘cursiva’.</p>
<p><code>last-command</code> es una variable que viene con Emacs y que no hemos visto antes. Normalmente, siempre que se ejecuta una función, Emacs establece el valor de <code>last-command</code> al comando anterior.</p>
<p>En este segmento de la definición, la expresión <code>if</code> comprueba si el comando anterior fue <code>kill-region</code>. Si lo fuera,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
</code></pre>
<p>concatena una copia del texto recien cortado al texto cortado previamente en el anillo de la muerte.</p>
</div>
<h3 id="copy-region-as-kill" ><code>copy-region-as-kill</code></h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> copia una región de texto de un búfer y (via <code>kill-append</code> o <code>kill-new</code>) lo guarda en el <code>kill-ring</code>.</p>
<p>Si llamas a <code>copy-region-as-kill</code> inmediatamente después de un comando <code>kill-region</code>, Emacs agregara el texto recien copiado al texto copiado previamente. Esto significa que traes el texto, lo obtienes todo, tanto de esta operacion como de la anterior. Por otra parte, si algún otro comando precede a <code>copy-region-as-kill</code>, la función copia el texto dentro de una entrada separada en el anillo de la muerte.</p>
<p>Aquí está el texto completo de la función <code>copy-region-as-kill</code> de la versión 22:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-region-as-kill</span> <span class="p">(</span><span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Guarda la region como si fuese cortada, pero no la corta.
</span><span class="s">En el modo Transient Mark, desactiva la marca.
</span><span class="s">Si ‘interprogram-cut-function’ es no-nil, tambien guarda el texto de una
</span><span class="s">ventana del sistema corta y pega.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">kill-append</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">kill-new</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">transient-mark-mode</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">deactivate-mark</span> <span class="no">t</span><span class="p">))</span>
  <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>Como de costumbre, esta función puede dividirse en las partes que la componen:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-region-as-kill</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Los argumentos son <code>beg</code> y <code>end</code> y la función es interactiva con <code>&#34;r&#34;</code>, por lo que los dos argumentos deben referirse al inicio y al final de la región. Si has estado leyendo este documento desde el principio, entender estas partes de una función es casi una rutina.</p>
<p>En la documentación, los comentarios de ‘Transient Mark’ y <code>interprogram-cut-function</code> explican ciertos efectos secundarios.</p>
<p>Después de asignar una marca, un búfer siempre contiene una región. Si lo deseas puedes utilizar el modo Transient Mark para resaltar temporalmente la región. (Nadie quiere resaltar la región todo el tiempo, por lo que el modo Trasient Mark lo resalta solo en los momentos apropiados. Muchas personas desactivan el modo Transient Mark, por lo que la región nunca se resalta.)</p>
<p>Ademas, un sistema de ventanas permite copiar, cortar y pegar entre diferentes programas. En el sistema de ventanas X, por ejemplo, la función <code>interprogram-cut-function</code> es <code>x-select-text</code>, que funciona con el sistema de ventanas equivalente al anillo de la muerte de Emacs.</p>
<p>El cuerpo de la función <code>copy-region-as-kill</code> inicia con una cláusula <code>if</code>. Lo que esta cláusula hace es distinguir entre dos situaciones diferentes: si este comando se ejecuta o no inmediatamente después de un comando <code>kill-region</code> anterior. En el primer caso, la nueva región se concatena al texto copiado previamente. De lo contrario, se inserta al inicio del anillo de la muerte como una pedazo separado del texto anterior.</p>
<p>Las dos ultimas líneas de la función impiden que la región se ilumine si el modo Transient Mark está activo.</p>
<p>El cuerpo de <code>copy-region-as-kill</code> merece ser discutido en detalle.</p>
</div>
<h4 id="el-cuerpo-de-copy-region-as-kill" >El cuerpo de <code>copy-region-as-kill</code></h4>
<div class="hBody-4" >
<p><code>copy-region-as-kill</code> funciona de un modo parecido a la función <code>kill-region</code>. Ambas están escritas de manera que dos o más muertes en una fila combinan su texto en una sola entrada. Si sacas el texto del anillo de la muerte, se optiene todo en una sola pieza. Ademas, las muertes que matan hacia adelante desde la posición actual del cursor se añaden al final del texto copiado previamente y los comandos que cortan el texto hacia atrás lo añaden al principio del texto copiado previamente. De esta manera, las palabras del texto permanecen en el orden correcto.</p>
<p>Al igual que <code>kill-region</code>, la función <code>copy-region-as-kill</code> hace uso de la variable <code>last-command</code> que mantiene el registro del comando Emacs anterior.</p>
<p>Normalmente, siempre que se ejecuta una función, Emacs asigna el valor de <code>this-command</code> a la función que se ejecuta (que en este caso sería <code>copy-region-as-kill</code>). Al mismo tiempo, Emacs asigna el valor de <code>last-command</code> al valor anterior de <code>this-command</code>.</p>
<p>En la primer parte del cuerpo de la función <code>copy-region-as-kill</code>, una expresión <code>if</code> determina si el valor de <code>last-command</code> es <code>kill-region</code>. Si es así, se evalua la parte then de la expresión <code>if</code>; utiliza la función <code>kill-append</code> para concatenar el texto copiado en esta llamada a la función con el texto ya en el primer elemento (el <code>car</code> del anillo de la muerte. Por otro lado, si el valor de <code>last-command</code> no es <code>kill-region</code>, entonces la función <code>copy-region-as-kill</code> asigna un nuevo elemento al anillo de la muerte usando la función <code>kill-new</code>.</p>
<p>La expresión <code>if</code> se lee da la siguiente manera; se utiliza <code>eq</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
    <span class="c1">;; parte then</span>
    <span class="p">(</span><span class="nv">kill-append</span>  <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">))</span>
  <span class="c1">;; parte else</span>
  <span class="p">(</span><span class="nv">kill-new</span>  <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
</code></pre>
<p>(La función <code>filter-buffer-substring</code> devuelve una subcadena filtrada del búfer, si existe. Opcionalmente––los argumentos no están aquí, por lo que tampoco se hace––la función puede borrar el texto inicial o devolver el texto sin sus propiedades; esta función es un reemplazo para la antigua función <code>buffer-substring</code>, que vino antes de implementar las propiedades de texto.)</p>
<p>La función <code>eq</code> prueba si su primer argumento es el mismo objeto Lisp que su segundo argumento. La función <code>eq</code> es similar a la función <code>equal</code> que se utiliza para probar la igualdad, pero difiere en que determina si dos representaciones son realmente el mismo objeto dentro de la computadora, pero con nombres diferentes. <code>equal</code> determina si la estructura y el contenido de dos expresiones son iguales.</p>
<p>Si el comando anterior fue <code>kill-region</code>, entonces el intérprete Emacs Lisp llama a la función <code>kill-append</code></p>
</div>
<h5 id="la-función-kill-append" >La función <code>kill-append</code></h5>
<div class="hBody-5" >
<p>La función <code>kill-new</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-append</span> <span class="p">(</span><span class="nf">string</span> <span class="nv">before-p</span> <span class="kp">&amp;optional</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="s">&#34;Inserta STRING al fin del ultimo corte en el anillo de la muerte.
</span><span class="s">Si BEFORE-P no es nil, anexa STRING al corte.
</span><span class="s">… &#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">cur</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">kill-new</span> <span class="p">(</span><span class="nb">if</span> <span class="nv">before-p</span> <span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span> <span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">cur</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">equal</span> <span class="nv">yank-handler</span>
                         <span class="p">(</span><span class="nf">get-text-property</span> <span class="mi">0</span> <span class="ss">&#39;yank-handler</span> <span class="nv">cur</span><span class="p">)))</span>
              <span class="nv">yank-handler</span><span class="p">)))</span>
</code></pre>
<p>La función <code>kill-append</code> es bastante sencilla. Utiliza la función <code>kill-new</code>, que discutiremos con más detalle en un momento.</p>
<p>(También, la función proporciona un argumento opcional llamado <code>yank-handler</code>; cuando se invoca, este argumento le dice a la función cómo tratar con la propiedades añadidas al texto, como ‘negrita’ o ‘cursiva’.)</p>
<p>Tiene una función <code>let*</code> para asignar el valor del primer elemento del anillo de la muerte a <code>cur</code>. (No se por qué la función no utiliza <code>let</code> en su lugar; solo un valor se asigna en la expresión. ¿Tal vez este es un bug que no produce problemas?</p>
<p>Considera el condicional que es uno de los dos argumentos de <code>kill-new</code>. Utiliza <code>concat</code> para concatenar el nuevo texto al <code>car</code> del anillo de la muerte. Si agrega el texto antes o despues depende del resultado de la expresión <code>if</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">before-p</span>                            <span class="c1">; parte if</span>
    <span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span>                 <span class="c1">; parte then</span>
  <span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>                  <span class="c1">; parte else</span>
</code></pre>
<p>Si la región cortada está antes de la región que se cortó en el último comando, entonces debería ser puesta antes que el material guardado en el corte anterior; y, a la inversa, si el texto que se corto esta despues del que acaba de cortar, debe añadirse después del texto anterior. La expresión <code>if</code> depende del predicado <code>before-p</code> para decidir si el texto recien guardado debe colocarse antes o después del texto anterior.</p>
<p>El símbolo <code>before-p</code> es el nombre de uno de los argumentos para <code>kill-append</code>. Cuando se evalúa la función <code>kill-append</code>, se asocia al valor devuelto evaluando el argumento actual. En este caso, esta es la expresión <code>(&lt; end beg)</code>. Esta expresión no determina directamente si el texto cortado en este comando se localiza antes o después del texto cortado del último comando; lo que hace es determinar si el valor de la variable <code>end</code> es menor que el valor de la variable <code>beg</code>. Si es así, significa que problamemente el usuario se dirige al principio del búfer. También, el resultado de evaluar la expresión del predicado. <code>(&lt; end beg)</code>, será verdadero y el texto se concatena antes del texto anterior. Por otro lado, si el valor de la variable <code>end</code> es mayor que el valor del la variable <code>beg</code>, el texto se agregara después del texto anterior.</p>
<p>Cuando se prepara el texto recien guardado, la cadena con el nuevo texto se concatena antes que el texto anterior:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span>
</code></pre>
<p>Pero si el texto será añadido, será concatenado después del viejo texto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>
</code></pre>
<p>Para comprender cómo funciona esto, primero se necesita revisar la función <code>concat</code>. La función <code>concat</code> enlaza o une dos cadenas de texto. El resultado es una cadena. Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;abc&#34;</span> <span class="s">&#34;def&#34;</span><span class="p">)</span>
</span><span class="out" >&#34;abcdef&#34;

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;nuevo &#34;</span>
        <span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;primer elemento&#34;</span> <span class="s">&#34;segundo elemento&#34;</span><span class="p">)))</span>
</span><span class="out" >&#34;nuevo primer elemento&#34;

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">car</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;primer elemento&#34;</span> <span class="s">&#34;segundo elemento&#34;</span><span class="p">))</span> <span class="s">&#34; modificado&#34;</span><span class="p">)</span>
</span><span class="out" >&#34;primer elemento modificado&#34;
</span></code></pre>
<p>Ahora podemos dar sentido a <code>kill-append</code>: modifica el contenido del anillo de la muerte. El anillo de la muerte es una lista, en la que cada elemento es un texto guardado. La función <code>kill-append</code> usa la función <code>kill-new</code> que a su vez utiliza la función <code>setcar</code>.</p>
</div>
<h5 id="la-función-kill-new" >La función <code>kill-new</code></h5>
<div class="hBody-5" >
<p>La función <code>kill-new</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-new</span> <span class="p">(</span><span class="nf">string</span> <span class="kp">&amp;optional</span> <span class="nv">replace</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="s">&#34;Hace que STRING sea el último corte en el anillo de la muerte.
</span><span class="s">Asigna ‘kill-ring-yank-pointer’ para apuntar a el.
</span><span class="s">
</span><span class="s">Si ‘interprogram-cut-function’ es no nulo, aplícalo a STRING.
</span><span class="s">El segundo argumento opcional REPLACE no-nulo significa que STRING
</span><span class="s"> reemplazará el frente del kill ring, en lugar de agregarse a la lista.
</span><span class="s">…&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nf">string</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">if</span> <span class="nv">yank-handler</span>
          <span class="p">(</span><span class="nf">put-text-property</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">length</span> <span class="nf">string</span><span class="p">)</span>
                             <span class="ss">&#39;yank-handler</span> <span class="nv">yank-handler</span> <span class="nf">string</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">if</span> <span class="nv">yank-handler</span>
        <span class="p">(</span><span class="ne">signal</span> <span class="ss">&#39;args-out-of-range</span>
                <span class="p">(</span><span class="nf">list</span> <span class="nf">string</span> <span class="s">&#34;yank-handler specified for empty string&#34;</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;menu-bar-update-yank-menu</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">menu-bar-update-yank-menu</span> <span class="nf">string</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="nv">kill-ring</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">setcar</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">push</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">kill-ring-max</span><span class="p">)</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="no">nil</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">interprogram-cut-function</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="nv">interprogram-cut-function</span> <span class="nf">string</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">replace</span><span class="p">))))</span>
</code></pre>
<p>(Observa que la función no es interactiva.)</p>
<p>Como de costumbre, podemos ver esta función en partes.</p>
<p>La definición de la función tiene un argumento opcional <code>yank-handler</code>, que cuando se invoca le dice a la función cómo manejar las propiedades añadidas al texto, tales como ‘negrilla’ o ‘cursiva’. Nos Saltaremos eso.</p>
<p>La primer línea de la documentación tiene sentido:</p>
<div class="example-block" >
<pre class="example" >Hace que STRING sea el último corte en el anillo de la muerte.
</pre>
</div>
<p>Vamos a saltarnos el resto de la documentación por el momento.</p>
<p>También, vamos a saltar la expresión <code>if</code> inicial y las líneas de código en <code>menu-bar-update-yank-menu</code>. Les explicaremos mas tarde.</p>
<p>Las líneas críticas son estas:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="nv">kill-ring</span><span class="p">)</span>
      <span class="c1">;; entonces</span>
      <span class="p">(</span><span class="nf">setcar</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
    <span class="c1">;; de otra forma</span>
  <span class="p">(</span><span class="nb">push</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring</span> <span class="p">(</span><span class="nf">cons</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
        <span class="c1">;; evita desbordar el anillo de la muerte</span>
        <span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">kill-ring-max</span><span class="p">)</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="no">nil</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">interprogram-cut-function</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="nv">interprogram-cut-function</span> <span class="nf">string</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">replace</span><span class="p">))))</span>
</code></pre>
<p>El test condicional es <code>(and replace kill-ring)</code>. Esto será verdadero cuando se cumplan dos condiciones: el anillo de la muerte tiene algo en el, y la variable <code>replace</code> es verdadera.</p>
<p>Cuando la función <code>kill-append</code> establece <code>replace</code> como verdadero y cuando el anillo de la muerte tiene al menos un elemento en el, se ejecuta la expresión <code>setcar</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">setcar</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
</code></pre>
<p>La función <code>setcar</code> realmente cambia el primer elemento de la lista <code>kill-ring</code> al valor de <code>string</code>. Eso reemplaza el primer elemento.</p>
<p>Por otro lado, si el anillo de la muerte está vacío, o <code>replace</code> es falso, se ejecuta la parte else de la condición:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">push</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">)</span>
</code></pre>
<p><code>push</code> pone su primer argumento dentro del segundo. Es similar a la mas antigua</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring</span> <span class="p">(</span><span class="nf">cons</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">))</span>
</code></pre>
<p>o la mas reciente</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">add-to-list</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
</code></pre>
<p>Cuando es falso, la expresión primero construye una nueva versión del anillo de la muerte, añadiendo <code>string</code> al anillo como un nuevo elemento (que es lo que hace <code>push</code>). Entonces ejecuta una segunda clausula <code>if</code>. Este segundo <code>if</code> impide que el anillo de la muerte se haga demaciado largo.</p>
<p>Veamos estas dos expresiones en orden.</p>
<p>La línea <code>push</code> de la parte else asigna el nuevo valor del anillo de la muerte a los resultados de agregar la cadena que esta siendo cortada al viejo anillo de la muerte.</p>
<p>Podemos ver cómo funciona esto con un ejemplo.</p>
<p>Primero,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-ejemplo</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;aqui hay una clausula&#34;</span> <span class="s">&#34;otra clausula&#34;</span><span class="p">))</span>
</code></pre>
<p>Después de evaluar esta expresión con <kbd>C-x C-e</kbd>, se puede evaluar <code>lista-de-ejemplo</code> y ver que devuelve:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">lista-de-ejemplo</span>
</span><span class="out" >(&#34;aquí hay una claúsula&#34; &#34;otra claúsula&#34;)
</span></code></pre>
<p>Ahora, podemos agregar un nuevo elemento a esta lista evaluando la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">push</span> <span class="s">&#34;una tercera cláusula&#34;</span> <span class="nv">lista-de-ejemplo</span><span class="p">)</span>
</code></pre>
<p>Cuando evaluamos <code>lista-de-ejemplo</code>, encontramos que su valor es:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">lista-de-ejemplo</span>
</span><span class="out" >(&#34;una tercera claúsula&#34; &#34;aquí hay una claúsula&#34; &#34;otra claúsula&#34;)
</span></code></pre>
<p>Asi pues, la tercer claúsula se añade a la lista con <code>push</code>.</p>
<p>Ahora la segunda parte de la claúsula <code>if</code>. Esta expresión evita que el anillo de la muerte crezca demasiado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">kill-ring-max</span><span class="p">)</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
</code></pre>
<p>El código verifica si la longitud del anillo de la muerte es mayor al tamaño máximo permitido. Este es el valor de <code>kill-ring-max</code> (que es 60, por defecto). Si el tamaño del anillo de la muerte es demasiado largo, entonces este código establece el último elemento del anillo de la muerte a <code>nil</code>. Hace esto usando dos funciones, <code>nthcdr</code> y <code>setcdr</code>.</p>
<p>Vimos <code>setcdr</code> anteriormente (ver Seccion <a href="#setcdr" ><code>setcdr</code></a>). Esto asigna el <code>cdr</code> de una lista, asi como <code>setcar</code> asigna el <code>car</code> de una lista. En este caso, sin embargo, <code>setcdr</code> no estará configurando el <code>cdr</code> del anillo de la muerte completo; se usa la función <code>nthcdr</code> para asignar el <code>cdr</code> del último elemento del anillo de la muerte––esto significa que desde el <code>cdr</code> del siguiente al último elemento del anillo de la muerte, se asignará el último elemento del anillo de la muerte.</p>
<p>La función <code>nthcdr</code> funciona tomando repetidamente el <code>cdr</code> de una lista––toma el <code>cdr</code> del <code>cdr</code> del <code>cdr</code> …. hace esto <span class="math" >N</span> veces y devuelve los resultados. (Vea la Seccion <a href="#nthcdr" ><code>nthcdr</code></a>.)</p>
<p>De este modo, si teniamos una lista de cuatro elementos que supuestamente debia tener tres elementos de longitud, podriamos asignar el <code>cdr</code> del elemento siguiente al último a <code>nil</code>, y asi acortar la lista. (Si se asigna el último elemento en algún otro valor distinto a <code>nil</code>, que se podría hacer, entonces no se habría acortado la lista. Véase Sección <a href="#setcdr" ><code>setcdr</code></a>.)</p>
<p>Puedes ver el acortamiento evaluando las tres siguientes expresiones. Primero asigna el valor de <code>arboles</code> a <code>(arce roble pino abedul)</code> luego asigna el <code>cdr</code> de su segundo <code>cdr</code> y entonces descubre el valor de <code>arboles</code>.</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">setq</span> <span class="nv">arboles</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">arce</span> <span class="nv">roble</span> <span class="nv">pino</span> <span class="nv">abedul</span><span class="p">))</span>
</span><span class="out" >(arce roble pino abedul)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">2</span> <span class="nv">arboles</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
</span><span class="out" >nil

</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">arboles</span>
</span><span class="out" >(arce roble pino)
</span></code></pre>
<p>(El valor devuelto por la expresión <code>setcdr</code> es <code>nil</code>, ya que en esto se establece el <code>cdr</code>.)</p>
<p>Repitiendo, en <code>kill-new</code>, la función <code>nthcdr</code> toma el <code>cdr</code> un número de veces, que es uno menos que el tamaño máximo permitido del anillo de la muerte y <code>setcdr</code> asigna el <code>cdr</code> de este elemento (que será el resto de los elementos en el anillo de la muerte) en <code>nil</code>. Esto evita el anillo de la muerte crezca demaciado largo.</p>
<p>La penultima expresión en la función <code>kill-new</code> es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
</code></pre>
<p><code>kill-ring-yank-pointer</code> es una variable global que se establece para ser el <code>kill-ring</code>.</p>
<p>Apesar de llamar a <code>kill-ring-yank-pointer</code> un <samp>puntero</samp>, es una variable al igual que el anillo de la muerte. Sin embargo, el nombre ha sido elegido para ayudar a los humanos a entender cómo se usa la variable.</p>
<p>Ahora, volviendo a una expresión anterior en el cuerpo de la función:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;menu-bar-update-yank-menu</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">menu-bar-update-yank-menu</span> <span class="nf">string</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">))))</span>
</code></pre>
<p>Empieza con una expresión <code>if</code></p>
<p>En este caso, la expresión prueba primero si <code>menu-bar-update-yank-menu</code> existe como una función, y si es así, se llama. La función <code>fboundp</code> devuelve verdadero si el símbolo que se prueba tiene una definición de función que ‘no es nula’. Si el símbolo de la definición de función fuera nulo, recibiríamos un mensaje de error, como lo hicimos cuando se crearon errores intencionadamente (ver Seccion <a href="#generar-un-mensaje-de-error" >Generar un mensaje de error</a>).</p>
<p>La parte-entonces contiene una expresión cuyo primer elemento es la función <code>and</code>.</p>
<p>La forma especial <code>and</code> evalúa cada uno de sus argumentos hasta que uno de los argumentos devuelve un valor o <code>nil</code>, en cuyo caso la expresión <code>and</code> devuelve <code>nil</code>; sin embargo, si ninguno de los argumentos devuelve una valor <code>nil</code>, se devuelve el resultado de la evaluación del último argumento. (Dado que tal valor no es <code>nil</code>, en Emacs Lisp se considera verdadero.) En otras palabras, una expresión <code>and</code> devuelve un valor cierto solo si todos sus argumentos son verdaderos. (Vea la Seccion <a href="#Repaso:-Algunas-Funciones-Más-Complejas" >Revisar el segundo búfer relacionado</a>.)</p>
<p>La expresión determina si el segundo argumento <code>menu-bar-update-yank-menu</code> es verdadero o no.</p>
<p><code>menu-bar-update-yank-menu</code> es una de la funciones que permite utilizar el menu ‘Seleccionar y Pegar’ en el elemento Editar de la barra de menu; usando un ratón, pueden ver las distintas piezas de texto que se han guardado y se seleccionar una pieza para pegar.</p>
<p>La última expresión en la función <code>kill-new</code> añade la nueva cadena recien copiada a cualquier facilidad existente para copiar y pegar texto entre diferentes programas que se ejecutan en un sistema de ventanas. En el Sistema de Ventanas X, por ejemplo, la función <code>x-select-text</code> toma la cadena y la almacena en la memoria manejada por X. Puede pegar la cadena en otro programa, como Xterm.</p>
<p>La expresión se ve asi:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">if</span> <span class="nv">interprogram-cut-function</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="nv">interprogram-cut-function</span> <span class="nf">string</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">replace</span><span class="p">))))</span>
</code></pre>
<p>Si <code>interprogram-cut-function</code> existe, entonces Emacs ejecuta <code>funcall</code>, que a su vez llama a su primer argumento como una función y le pasa los argumentos restantes. (Incidentalmente, hasta donde puedo ver, esta expresión <code>if</code> podría reemplazarse por una expresión <code>and</code> similar a la de la primer parte de la función.)</p>
<p>No vamos a discutir mas sobre sistemas de ventanas y otros programas, sino simplemente indicar que este es un mecanismo que permite a GNU Emacs trabajar bien y fácilmente con otros programas.</p>
<p>Este código para colocar texto en el anillo de la muerte, concatenandolo con un elemento existente o como un nuevo, nos brinda la habilidad para traer texto que ha sido cortado del búfer––los comandos de corte (<em>yank</em>). Sin embargo, antes de discutir los comandos de corte, es mejor aprender cómo se implementan las listas en un ordenador. Esto pondra de manifiesto misterios como el uso del término ‘puntero’. Pero antes de eso, nos desviaremos a C.</p>
</div>
<h3 id="disgresión-dentro-de-c" >Disgresión dentro de C</h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> (ver Seccion <a href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a>) usa la función <code>filter-buffer-substring</code>, que a su vez utiliza la función <code>delete-and-extract-region</code>. Eso elimina el contenido de una región y no se puede volverlos a recuperar.</p>
<p>A diferencia del otro código discutido aquí, la función <code>delete-and-extract-region</code> no está escrita en Emacs Lisp; está escrita en C y es una de las primitivas del sistema GNU Emacs. Puesto que es muy simple, voy a desviarme brevemente de Lisp y describirla aquí.</p>
<p>Al igual que muchas de las otras primitivas Emacs, <code>delete-and-extract-region</code> se escribe como una instancia de una macro C, una macro es una plantilla de codigo. La macro completa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="n">DEFUN</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;delete-and-extract-region&#34;</span><span class="p">,</span> <span class="n">Fdelete_and_extract_region</span><span class="p">,</span>
       <span class="n">Sdelete_and_extract_region</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
       <span class="nl">doc</span><span class="p">:</span> <span class="cm">/* Borra el texto entre START y END y lo devuelve.  */</span><span class="p">)</span>
       <span class="p">(</span><span class="n">Lisp_Object</span> <span class="n">start</span><span class="p">,</span> <span class="n">Lisp_Object</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">validate_region</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">empty_unibyte_string</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">del_range_1</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Sin entrar en los detalles del proceso de escritura de la macro, permitame señalar que esta macro comienza con la palabra <code>DEFUN</code>. La palabra <code>DEFUN</code> fué elegida ya que el código tiene el mismo propósito que <code>defun</code> en Lisp. (La macro C <code>DEFUN</code> se define en en <span class="file" >emacs/src/lisp.h</span>.)</p>
<p>La palabra <code>DEFUN</code> tiene siete partes dentro de los paréntesis:</p>
<ul>
<li>
<p>La primera parte es el nombre dado a la función en Lisp, <code>delete-and-extract-region</code>.</p>
</li>
<li>
<p>La segunda parte es el nombre de la función en C, <code>Fdelete_and_extract_region</code>. Por convención, comienza con <samp>F</samp>. Puesto que C no usa guiones en los nombres, en su lugar se utilizan guiones bajos.</p>
</li>
<li>
<p>La tercera parte es el nombre para la estructura constante C que registra información en esta función para uso interno. Es el nombre de la función en C pero empieza con una <samp>S</samp> en vez de una <samp>F</samp>.</p>
</li>
<li>
<p>Las partes cuarta y quinta especifican el número mínimo y máximo de argumentos que la función puede tener. Esta función requiere exactamente 2 argumentos.</p>
</li>
<li>
<p>La sexta parte es casi como el argumento que sigue a la declaración <code>interactive</code> en una función escrita en Lisp: una letra seguida, tal vez, por un prompt. La única diferencia con Lisp es que si la macro se llama sin argumentos. Entonces se escribe un <code>0</code> (que es una ‘cadena nula’), como en esta macro.</p>
<p>Si fueras a especificar argumentos, se colocarian entre comillas. La macro C para <code>goto-char</code> incluye <code>\&#34;NGoto char \&#34;</code> en esta posición se indica que la función espera un prefijo en bruto, en este caso, una localización numérica en un búfer, y proporciona un prompt.</p>
</li>
<li>
<p>La séptima parte es una cadena de documentación, como la de una función escrita en Emacs Lisp. Se escribe como un comentario C. (Cuando se escribe Emacs, el programa <code class="command" >lib-src/make-docfile</code> extrae estos comentarios y los usa para crear la documentación “real”.)</p>
</li>
</ul>
<p>En una macro C, los parámetros formales vienen a continuacion, con una declaracion de que tipo de objeto son, seguido por lo que podría llamarse el ‘cuerpo’ de la macro. Para <code>delete-and-extract-region</code> el ‘cuerpo’ se compone de las cuatro líneas siguientes:</p>
<pre class="code" ><code class="chroma" ><span class="n">validate_region</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">build_string</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;&#34;</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">del_range_1</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
<p>La función <code>validate_region</code> comprueba si los valores pasados como el principio y fin de la región son del tipo apropiado y estan dentro del rango. Si las posiciones de inicio principio y fin son las mismas, entonces devuelve una cadena vacía.</p>
<p>La función <code>del_range_1</code> borra el texto. Es una función compleja que no examinaremos. Actualiza el búfer y hace otras cosas. Sin embargo, vale la pena mirar los dos argumentos pasados a <code>del_range</code>. Estos son <code>XINT (start)</code> y <code>XINT (end)</code>.</p>
<p>Por lo que respecta al lenguaje C, <code>start</code> y <code>end</code> son dos enteros que marcan el principio y el fin de la región a eliminar<span class="note" ><sup><a href="#10" >10</a></sup></span>.</p>
<p>En las primeras versiones de Emacs, estos dos números tenian 32 bits de longitud, pero el código está lentamente siendo generalizado para manejar otras longitudes. Tres de los bits disponibles son usados para especificar el tipo de información; los bits restantes se utilizan como ‘contenido’.</p>
<p><samp>XINT</samp> es una macro C que extrae los números relevantes desde una colección larga de bits; los otros tres bits se descartan.</p>
<p>El comando en <code>delete-and-extract-region</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="n">del_range_1</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
<p>Borra la región entre la posición inicial, <code>start</code>, y la posición final, <code>end</code>.</p>
<p>Desde el punto de vista de la persona que escribe Lisp, Emacs es muy simple; pero oculta en el fondo mucha complejidad para hacer que funcione.</p>
</div>
<h3 id="inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> esta escrita en Emacs Lisp. Dos funciones dentro de ella, <code>kill-append</code> y <code>kill-new</code>, copian una región en un búfer y la guardan en una variable llamada el <code>kill-ring</code>. Esta sección describe cómo se crea e inicializa la variable <code>kill-ring</code> usando la forma especial <code>defvar</code>.</p>
<p>(De nuevo se señala que el término <code>kill-ring</code> es un mal nombre. El texto que se corta del búfer puede ser devuelto; no es un anillo de cadaveres, sino un anillo de texto resucitable.)</p>
<p>En Emacs Lisp, una variable como <code>kill-ring</code> se crea y da un valor inicial usando la forma especial <code>defvar</code>. El nombre proviene de “definir variable”.</p>
<p>La forma especial <code>defvar</code> es similar a <code>setq</code> en la que se establece el valor de una variable. Se diferencia de <code>setq</code> en dos formas: primero solo establece el valor de la variable si la variable no tiene ya un valor. Si la variable ya tiene un valor, <code>defvar</code> no sobreescribe el valor existente. Segundo, <code>defvar</code> tiene una cadena de documentación.</p>
<p>(Otra forma especial, <code>defcustom</code>, está diseñada para variables que la gente personaliza. Tiene más funcionalidades que <code>defvar</code>. (Véase Sección <a href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>.)</p>
<p>Se puede ver el valor actual de una variable, cualquier variable, usando la función <code>describe-variable</code>, que normalmente se invoca escribiendo <kbd>C-h v</kbd>. Si presionas <kbd>C-h v</kbd> y luego escribes <code>kill-ring</code> (seguido por <kbd>RET</kbd>), veras lo que hay actualmente en tu anillo de la muerte––¡esto puede ser bastante grande! Por el contrario, si no has estado haciendo nada en esta sesión en Emacs, excepto leer este documento, es posible no tener nada en el. También, se verá la documentación para <code>kill-ring</code>:</p>
<div class="example-block" >
<pre class="example" >Documentación:
Lista de secuencias de texto muerto (guardado).
Ya que el anillo de la muerte se supone que interactua bien con
el copia-y-pega que ofrecen los sistemas de ventanas, el uso de
esta variable debería interactuar bien con las funciones
‘interprogram-cut-function’ y ‘interprogram-paste-function’.
Las funciones ‘kill-new’, ‘kill-append’, y ‘current-kill’ deben
implementar esta interacción; es posible que desee utilizarlas
en lugar de manipular el anillo de la muerte directamente.
</pre>
</div>
<p>El anillo de la muerte es definido por un <code>defvar</code> del siguiente modo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">kill-ring</span> <span class="no">nil</span>
  <span class="s">&#34;Lista de secuencia de textos cortados.
</span><span class="s">…&#34;</span><span class="p">)</span>
</code></pre>
<p>En esta definición de variable, a la variable se le da un valor inicial de <code>nil</code>, lo que tiene sentido, ya que si no has guardado nada, no quieres nada de vuelta si das un comando <code>yank</code>. La cadena de documentación se escribe igual que la cadena de documentación de un <code>defun</code>. Al igual que con la cadena de documentacion del defun, la primera linea de la documentación deberia ser una frase completa, ya que algunos comandos, como <code>apropos</code>, imprimen solo la primer línea de documentación. Las líneas sucesivas no deben indentarse; de lo contrario, se veran extrañas cuando se use <kbd>C-h v</kbd> (<code>describe-variable</code>).</p>
</div>
<h4 id="defvar-y-un-asterisco" ><code>defvar</code> y un asterisco</h4>
<div class="hBody-4" >
<p>En el pasado, Emacs usaba la forma especial <code>defvar</code> tanto para variables internas que se esperaba que un usuario cambiara como para las que no se esperaban cambios de parte del usuario. Aunque todavía se puede usar <code>defvar</code> para variables personalizadas, por favor, usa <code>defcustom</code> en su lugar, ya que esa forma especial proporciona una ruta a los comando de personalización. (Vea la Seccion <a href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>.)</p>
<p>Cuando se especifica una variable utilizando la forma especial <code>defvar</code>, se podría distinguir una variable que un usuario podría querer cambiar de otros escribiendo, <samp>*</samp>, en la primera columna de su cadena de documentación. Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">shell-command-default-error-buffer</span> <span class="no">nil</span>
  <span class="s">&#34;*Nombre de buffer para ‘shell-command’ … salida de error.
</span><span class="s">… &#34;</span><span class="p">)</span>
</code></pre>
<p>Podrías (y todavía puedes) usar el comando <code>set-variable</code> para cambiar temporalmente el valor de <code>shell-command-default-error-buffer</code>. Sin embargo, las opciones configuradas usando <code>set-variable</code> solo se establecen por la duración de tu sesión actual. Los nuevos valores no se guardan entre sesiones. Cada vez que Emacs inicia, lee el valor original, a menos que cambie el valor dentro de su fichero <span class="file" >.emacs</span>, ya sea configurándolo manualmente o utilizando <code>customize</code>. Vea la Seccion <a href="#tu-fichero-.emacs" >Tu Fichero <span class="file" >.emacs</span></a>.</p>
<p>Para mí, el mayor uso del comando <code>set-variable</code> es sugerir variables que se podría querer establecer en mi fichero <span class="file" >.emacs</span>. Ahora hay más de 700 variables, demasiadas para recordarlas fácilmente. Afortunadamente, se puede presionar <kbd>TAB</kbd> después de llamar al comando <code>M-x set-variable</code> para ver la lista de variables. (Vea la Seccion <a href="info:emacs#Examining-and-Setting-Variables" >Examinando y Configurando Variables</a> en <em>El Manual de GNU Emacs</em>.)</p>
</div>
<h3 id="repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí hay un breve resumen de algunas funciones introducidas recientemente.</p>
<dl>
<dt><code>car</code>, <code>cdr</code></dt>
<dd>
<p><code>car</code> devuelve el primer elemento de una lista; <code>cdr</code> devuelve el segundo y los siguientes elementos de una lista.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
</span><span class="out" >1
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
</span><span class="out" >(2 3 4 5 6 7)
</span></code></pre>
</dd>
<dt><code>cons</code></dt>
<dd>
<p><code>cons</code> construye una lista enlazando su primer argumento a su segundo argumento.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="out" >(1 2 3 4)
</span></code></pre>
</dd>
<dt><code>funcall</code></dt>
<dd>
<p><code>funcall</code> evalúa su primer argumento como una función. Pasa los argumentos restantes a su primer argumento.</p>
</dd>
<dt><code>nthcdr</code></dt>
<dd>
<p>Devuelve el resultado de tomar <code>cdr</code> ‘n’ veces en una lista. El <span class="math" >n^{th}</span> <code>cdr</code>. El ‘resto del resto’, por asi decirlo.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
</span><span class="out" >(4 5 6 7)
</span></code></pre>
</dd>
<dt><code>setcar</code>, <code>setcdr</code></dt>
<dd>
<p><code>setcar</code> cambia el primer elemento de una lista; <code>setcdr</code> cambia el segundo y los siguientes elementos de una lista.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">setq</span> <span class="nv">triple</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span><span class="out" >
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">setcar</span> <span class="nv">triple</span> <span class="ss">&#39;37</span><span class="p">)</span>
</span><span class="out" >
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">triple</span>
</span><span class="out" >(37 2 3)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">setcdr</span> <span class="nv">triple</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span><span class="p">))</span>
</span><span class="out" >
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">triple</span>
</span><span class="out" >(37 &#34;foo&#34; &#34;bar&#34;)
</span></code></pre>
</dd>
<dt><code>progn</code></dt>
<dd>
<p>Evalúa cada argumento en secuencia y luego devuelve el valor del último.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">progn</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</span><span class="out" >4
</span></code></pre>
</dd>
<dt><code>save-restriction</code></dt>
<dd>
<p>Graba cualquier reduccion (<em>narrowing</em>) que esté en efecto en el búfer actual, si lo hay, y restablece esa reduccion despues de evaluar los argumentos.</p>
</dd>
<dt><code>search-forward</code></dt>
<dd>
<p>Busca una cadena y, si se encuentra, mueve el punto. De manera similar, para una expresión regular utiliza <code>re-search-forward</code>. (Véase Sección <a href="#búsqueda-de-expresiones-regulares" >Búsqueda de Expresiones Regulares</a>, para obtener una explicación de los patrones y busquedas de expresiones regulares.)</p>
<p><code>search-forward</code> y <code>re-search-forward</code> toman cuatro argumentos:</p>
<ol class="num" >
<li>
<p>La cadena o expresión regular a buscar.</p>
</li>
<li>
<p>Opcionalmente, el límite de la búsqueda.</p>
</li>
<li>
<p>Opcionalmente, que haces si la búsqueda falla, devuelve <code>nil</code> o un mensaje de error.</p>
</li>
<li>
<p>Opcionalmente, cuántas veces repetir la búsqueda; si es negativa, la búsqueda va hacia atrás.</p>
</li>
</ol>
</dd>
<dt><code>kill-region</code>, <code>delete-and-extract-region</code>, <code>copy-region-as-kill</code></dt>
<dd>
<p><code>kill-region</code> corta el texto entre el punto y la marca del búfer y almacena ese texto en el anillo de la muerte, para que puedas recuperarlo &#34;tirando&#34; de el.</p>
<p><code>copy-region-as-kill</code> copia el texto entre punto y marca dentro del anillo de la muerte. La función no corta ni elimina el texto del búfer.</p>
</dd>
</dl>
<p><code>delete-and-extract-region</code> elimina el texto entre el punto y la marca del búfer. No puede recuperarse. (Este no es un comando interactivo.)</p>
</div>
<h3 id="ejercicios-de-busqueda" >Ejercicios de Busqueda</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función interactiva que busque una cadena de texto. Si la búsqueda encuentra la cadena, deja el punto después de ella y muestra un mensaje que diga “¡Encontrado!”. (No uses <code>search-forward</code> para el nombre de esta función; si se haces, se sobreescribirá la versión existente de <code>search-forward</code> que viene con Emacs. En su lugar utiliza un nombre como, por ejemplo, <code>test-search</code>.</p>
</li>
<li>
<p>Escribe una función que imprima el tercer elemento del anillo de la muerte en el área de eco, si lo hay; si el anillo de la muerte no contiene un tercer elemento, imprime un mensaje apropiado.</p>
</li>
</ul>
</div>
<h2 id="cómo-se-implementan-las-listas" >Cómo se implementan las listas</h2>
<div class="hBody-2" >
<p>En Lisp, los átomos se registran de manera sencilla, si la implementación no es sencilla en la práctica, es, sin embargo, sencilla en teoría. El átomo <samp>rosa</samp>, por ejemplo, se graba como las cuatro letras contiguas <samp>r</samp>, <samp>o</samp>, <samp>s</samp>, <samp>a</samp>. Una lista, por otro lado, se guarda de manera diferente. El mecanismo es igualmente simple, pero toma un momento acostumbrarse a la idea. Una lista se guarda usando una serie de pares de punteros. En las serie, el primer puntero de cada par apunta a un átomo o a otra lista, y el segundo puntero de cada par apunta al siguiente par, o al símbolo <code>nil</code>, que marca el final de la lista.</p>
<p>Un puntero por sí mismo es simplemente la dirección electrónica de lo que apunta. Por lo tanto, una lista se guarda como una serie de direcciones electrónicas.</p>
<p>Por ejemplo, la lista <code>(rosa violeta tulipan)</code> tiene tres elementos, <samp>rosa</samp>, <samp>violeta</samp>, y <samp>tulipan</samp>. En el ordenador, la dirección electrónica de <samp>rosa</samp> se registra en un segmento de memoria del ordenador a través de la dirección que da la dirección electrónica de donde el átomo <samp>violeta</samp> está localizado; y esta dirección (la que dice donde se localiza <samp>violeta</samp>) se guarda junto con una dirección que dice donde se localiza la dirección para el átomo <samp>tulipan</samp>.</p>
<p>Esto parece más complicado de lo que es y es más fácil visto en un diagrama:</p>
<div class="art-block" >
<pre class="art" > ___ ___      ___ ___      ___ ___
|___|___|--&gt; |___|___|--&gt; |___|___|--&gt; nil
  |            |            |
  |            |            |
  ---&gt; rosa    ---&gt; violeta ---&gt; tulipan
</pre>
</div>
<p>En el diagrama, cada caja representa una palabra de la memoria del ordenador que contiene un objeto Lisp, normalmente en forma de una dirección de memoria. Las cajas, es decir, las direcciones, están en pares. Cada flecha apunta a la dirección de un átomo u otro par de direcciones. La primer caja es la dirección electrónica de <samp>rosa</samp> y la flecha apunta a <samp>rosa</samp>; la segunda caja es la dirección del siguiente par de cajas, la primera parte de las cuales que es la dirección de <samp>violeta</samp> y la segunda parte es la dirección del siguiente par. La última caja apunta al símbolo <code>nil</code>, que marca el fin de la la lista.</p>
<p>Cuando una variable se establece en una lista con una función como <code>setq</code>, almacena la dirección de la primera caja en la variable. Asi pues, la evaluación de la expresión</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">ramo</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>crea una situación como esta:</p>
<div class="art-block" >
<pre class="art" >ramo
  |
  |     ___ ___      ___ ___      ___ ___
   --&gt; |___|___|--&gt; |___|___|--&gt; |___|___|--&gt; nil
         |            |            |
         |            |            |
          --&gt; rosa     --&gt; violeta   --&gt; tulipan
</pre>
</div>
<p>En este ejemplo, el símbolo <code>ramo</code> contiene la dirección del primer par de cajas.</p>
<p>Esta misma lista puede ser ilustrada en un tipo diferente de notación de cajas como este:</p>
<div class="art-block" >
<pre class="art" >ramo
  |
  |    --------------       ----------------       --------------------
  |   | car   | cdr  |     | car     | cdr  |     | car         | cdr  |
   --&gt;| rosa  |   o-------&gt;| violeta |   o-------&gt;| tulipan     | nil  |
      |       |      |     |         |      |     |             |      |
       --------------       ----------------       --------------------
</pre>
</div>
<p>(Los símbolos consisten en más de un par de direcciones, pero la estructura de un símbolo esta formado por direcciones. En efecto, el símbolo <code>ramo</code> consiste de un grupo de cajas-de-direcciones, una de las cuales es la dirección de la palabra impresa <samp>ramo</samp>, la segunda es la dirección de una definición de función adjunta al símbolo, si la hubiera, una tercera parte la cual es la dirección del primer par de cajas-de-direccion para la lista <code>(rosa violeta tulipan)</code>, y así sucesivamente. Aquí mostraremos que la tercera caja de direcciónes del símbolo apunta al primer par de cajas-de-direccion para la lista.)</p>
<p>Si un símbolo se asigna al <code>cdr</code> de una lista, la lista en sí no cambia; el símbolo simplemente tiene una dirección mas abajo en la lista. (En la jerga, <code>car</code> y <code>cdr</code> son ‘no destructivos’.) De este modo, la evaluacion de la siguiente expresión</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">flores</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">ramo</span><span class="p">))</span>
</code></pre>
<p>produce esto:</p>
<div class="art-block" >
<pre class="art" >ramo        flores
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --&gt; |   |   |  --&gt; |   |   |    |   |   |
       |___|___|----&gt; |___|___|--&gt; |___|___|--&gt; nil
         |              |            |
         |              |            |
          --&gt; rosa       --&gt; violeta  --&gt; tulipan
</pre>
</div>
<p>El valor de <code>flores</code> es <code>(violeta tulipan)</code>, es decir, el símbolo <code>flores</code> contiene la dirección del par de cajas-de-direcciones, la primera de las cuales contiene la dirección de <code>violeta</code>, y la segunda contiene la dirección de <code>tulipan</code>.</p>
<p>Un par de cajas-de-direcciones se denomina una <dfn>cons cell</dfn> o <dfn>par de puntos</dfn>. Consulte la Seccion <a href="info:elisp#Cons-Cell-Type" >Cons Cell y Tipos de Lista</a> en <em>El Manual de Referencia de Emacs Lisp</em>, y <a href="info:elisp#Dotted-Pair-Notation" >Notación de Pares de Puntos</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información acerca las celdas cons y pares de puntos.</p>
<p>La función <code>cons</code> añade un nuevo par de direcciones al frente de una serie de direcciones como la que se muestra a continuacion. Por ejemplo, evaluar la expresión</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">ramo</span> <span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;lila</span> <span class="nv">ramo</span><span class="p">))</span>
</code></pre>
<p>produce:</p>
<div class="art-block" >
<pre class="art" >ramo                       flores
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --&gt; |   |   |      |   |   |  --&gt; |   |   |     |   |   |
       |___|___|----&gt; |___|___|----&gt; |___|___|----&gt;|___|___|--&gt; nil
         |              |              |             |
         |              |              |             |
          --&gt; lila      --&gt; rosa       --&gt; violeta    --&gt; tulipan
</pre>
</div>
<p>Sin embargo, esto no cambia el valor del símbolo <code>flores</code>, como puedes ver evaluando lo siguiente,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">eq</span> <span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">ramo</span><span class="p">))</span> <span class="nv">flores</span><span class="p">)</span>
</code></pre>
<p>que devuelve <code>t</code> para verdadero.</p>
<p>Hasta que se reinicia, <code>flores</code> todavía tiene el valor <code>(violeta tulipan)</code>; es decir, tiene la dirección de la celda cons cuya primer dirección es <code>violeta</code>. Ademas, esto no altera ninguna de las celdas cons preexistentes; todas ellas todavía están allí.</p>
<p>De este modo, en Lisp, para obtener el <code>cdr</code> de una lista, solo tienes que obtener la dirección del siguiente celda cons de la serie; al obtener el <code>car</code> de una lista, se obtiene la dirección del primer elemento de la lista; al agregar (<code>cons</code>) un nuevo elemento en una lista, se añade una nueva celda cons al frente de la lista. ¡Esto es todo lo que hay! ¡La estructura subyacente de Lisp es brillantemente simple!</p>
<p>¿Y a que se refiere la última dirección en una serie de celda cons? A la direccion de la lista vacía, de <code>nil</code>.</p>
<p>En resumen, cuando una variable Lisp se establece a un valor, se proporciona la dirección de la lista a la que se refiere la variable.</p>
</div>
<h3 id="símbolos-como-una-caja-con-cajones" >Símbolos como una caja con cajones</h3>
<div class="hBody-3" >
<p>En una sección anterior, sugeri que se podría imaginar un símbolo como una caja con cajones. La definición de función se coloca en un cajón, el valor en otro, y así sucesivamente. Lo que se pone en el cajón que contiene el valor puede cambiarse sin afectar el contenido del cajón que contiene la definicion de función, y viceversa.</p>
<p>En realidad, lo que se pone en la caja es la dirección del valor o definición de función. Es como si encontraras un viejo cofre en el ático, y en uno de sus compartimentos hallaras un mapa con la direccion de donde se encuentra el tesoro enterrado.</p>
<p>(Además de su nombre, la definición del símbolo, y un valor de variable, un símbolo tiene un ‘cajón’ para una <dfn>lista de propiedades</dfn> que puede utilizar para registrar otra información. Las listas de propiedades no se discuten aquí; ver la seccion <a href="info:elisp#Property-Lists" >Listas de Propiedades</a> en <em>El Manual de Referencia de Emacs Lisp</em>.)</p>
<p>Aquí hay una representación imaginaria:</p>
<div class="art-block" >
<pre class="art" >            Caja de Cajones            Contenidos de los Cajones

            __   o0O0o   __
          /                 \
         ---------------------
        |    direcciones al   |            [asignar a]
        | nombre del simbolo  |            ramo
        |                     |
        +---------------------+
        |  direcciones a la   |
        |   definición del    |            [nada]
        |    simbolo          |
        +---------------------+
        |    direcciones al   |            [asignar a]
        |   valor de variable |            (rosa violeta tulipan)
        |                     |
        +---------------------+
        |    direcciones a la |
        |lista de propiedades |            [no descrito aquí]
        |                     |
        +---------------------+
        |/                   \|
</pre>
</div>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Asignar <code>flores</code> a <code>violeta</code> y <code>tulipan</code>. Asignar dos flores más en esta lista y asignarla a <code>mas-flores</code>. Asigna+ el <code>car</code> de <code>flores</code> a un pez. ¿Qué lista contiene ahora <code>mas-flores</code>?</p>
</div>
<h2 id="pegando-texto" >Pegando texto</h2>
<div class="hBody-2" >
<p>Siempre que cortes texto de un búfer con un comando ‘kill’, puede traerse de vuelta con un comando ‘yank’. El texto cortado del búfer es puesto en el anillo de la muerte y los comandos yank insertan el contenido apropiado del anillo de la muerte en un búfer (no necesariamente el búfer original).</p>
<p>Un simple comando <kbd>C-y</kbd> (<code>yank</code>) inserta el primer elemento del anillo de la muerte dentro en el búfer actual. Si el comando <kbd>C-y</kbd> es seguido inmediatamente por <kbd>M-y</kbd>, el primer elemento se reemplaza por el segundo elemento. Los sucesivos comandos <kbd>M-y</kbd> reemplazan el segundo elemento con el tercer, cuarto, o quinto elemento, y así sucesivamente. Cuando se alcanza el último elemento del anillo de la muerte, se reemplaza por el primer elemento y el ciclo se repite. (Por la tanto, el anillo de la muerte se llama un ‘anillo’ en lugar de solo una ‘lista’. Sin embargo, la estructura de de datos real que contiene el texto es una lista. Vea la Seccion <a href="#apéndice-b-manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</a>, para los detalles de cómo se maneja la lista como un anillo.)</p>
</div>
<h3 id="resumen-del-anillo-de-la-muerte" >Resumen del anillo de la muerte</h3>
<div class="hBody-3" >
<p>El anillo de la muerte es una lista de cadenas de texto. Esto es lo que se ve:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;algún texto&#34;</span> <span class="s">&#34;un texto diferente&#34;</span> <span class="s">&#34;aún más texto&#34;</span><span class="p">)</span>
</code></pre>
<p>Si este fuera el contenido de mi anillo de la muerte y pulsara <kbd>C-y</kbd>, la cadena de caracteres que dice <samp>algún texto</samp> seria insertada en este búfer donde se encuentra mi cursor.</p>
<p>El comando <code>yank</code> también se utiliza para duplicar texto copiándolo. El texto copiado no se corta del el búfer, sino que se coloca una copia del mismo en el anillo de la muerte y se insarta trayendolo de vuelta.</p>
<p>Se utulizan tres funciones para devolver el texto del anillo de la muerte: <code>yank</code>, que normalmente se asocia a <kbd>C-y</kbd>; <code>yank-pop</code>, que normalmente se asocia a <kbd>M-y</kbd>; y <code>rotate-yank-pointer</code>, que se utiliza por las otras dos funciones.</p>
<p>Estas funciones se refieren al anillo de la muerte a través de una variable llamada <code>kill-ring-yank-pointer</code>. De hecho, el codigo de inserción para ambas funciones <code>yank</code> y <code>yank-pop</code> es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring-yank-pointer</span><span class="p">))</span>
</code></pre>
<p>(Bueno, no más. En GNU Emacs 22, la función ha sido reemplazada por <code>insert-for-yank</code> que llama repetidamente a <code>insert-for-yank-1</code> para cada segmento a <code>yank-handler</code>. A su vez, <code>insert-for-yank-1</code> elimina las propiedades del texto insertado de acuerdo a <code>yank-excluded-properties</code>. De otro modo, seria como <code>insert</code>. Nosotros pegaremos con un <code>insert</code> plano puesto que es mas fácil de comprender.)</p>
<p>Para empezar a comprender cómo funcionan <code>yank</code> y <code>yank-pop</code>, primero hay que mirar la variable <code>kill-ring-yank-pointer</code>.</p>
</div>
<h3 id="la-variable-kill-ring-yank-pointer" >La variable <code>kill-ring-yank-pointer</code></h3>
<div class="hBody-3" >
<p><code>kill-ring-yank-pointer</code> es una variable, de la misma forma que <code>kill-ring</code> es una variable. Esta apunta a alguna cosa siendo asignada al valor de lo que apunta, como cualquier otra variable Lisp.</p>
<p>De este modo, si el valor del anillo de la muerte es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;algún texto&#34;</span> <span class="s">&#34;un texto diferente&#34;</span> <span class="s">&#34;aún más texto&#34;</span><span class="p">)</span>
</code></pre>
<p>y <code>kill-ring-yank-pointer</code> apunta a la segunda oracion, el valor de <code>kill-ring-yank-pointer</code> es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;un texto diferente&#34;</span> <span class="s">&#34;aún más texto&#34;</span><span class="p">)</span>
</code></pre>
<p>Como se explico en el capítulo anterior (Vea la Seccion <a href="#cómo-se-implementan-las-listas" >Cómo se implementan las listas</a>), el ordenador no guarda dos copias diferentes del texto apuntadas tanto por <code>kill-ring</code> como por <code>kill-ring-yank-pointer</code>. Las palabras “un texto diferente” y “aún más texto” no están duplicadas. En su lugar, las dos variables apuntan a las mismas piezas de texto. Aquí hay un diagrama:</p>
<div class="art-block" >
<pre class="art" >kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---&gt; |   |   |  --&gt; |   |   |    |   |   |
          |___|___|----&gt; |___|___|--&gt; |___|___|--&gt; nil
            |              |            |
            |              |            |
            |              |             --&gt; &#34;aún más texto&#34;
            |              |
            |               --&gt; &#34;un texto diferente&#34;
            |
             --&gt; &#34;algún texto&#34;
</pre>
</div>
<p>Tanto la variable <code>kill-ring</code> y como <code>kill-ring-yank-pointer</code> son punteros. Pero el anillo de la muerte en sí normalmente se describe como si fuera realmente lo que lo compone. Se habla de <code>kill-ring</code> como si fuera la lista en lugar de ser un puntero a la lista. Por el contrario, se dice que <code>kill-ring-yank-pointer</code> apunta a una lista.</p>
<p>Estas dos formas de hablar sobre la misma cosa suenan confusas al principio pero tienen sentido tras reflexionar. El anillo de la muerte se piensa generalmente como la estructura completa de datos que contiene la información de lo que se ha cortado reciéntemente de los búfers de Emacs. Por otra parte, <code>kill-ring-yank-pointer</code>, sirve para indicar––es decir, para ‘apuntar a’––esa parte del anillo de la muerte de la cual se inserta el primer elemento (el <code>car</code>).</p>
</div>
<h3 id="ejercicios-con-yank-y-nthcdr" >Ejercicios con <code>yank</code> y <code>nthcdr</code></h3>
<div class="hBody-3" >
<ul>
<li>
<p>Usando <kbd>C-h v</kbd> (<code>describe-variable</code>), mira en el valor de tu anillo de la muerte. Añade varios elementos a tu anillo de la muerte; mira su valor de nuevo. Usando <kbd>M-y</kbd> (<code>yank-pop</code>), muevete alrededor del anillo de la muerte. ¿Cuántos elementos habia en tu anillo de la muerte? Encuentra el valor de <code>kill-ring-max</code>. ¿Estaba lleno tu anillo de la muerte, o podrías haber guardado más bloques de texto dentro en el?</p>
</li>
<li>
<p>Usando <code>nthcrd</code> y <code>car</code>, construye una serie de expresiones para devolver el primer, segundo, tercer y cuarto elemento de una lista.</p>
</li>
</ul>
</div>
<h2 id="bucles-y-recursión" >Bucles y recursión</h2>
<div class="hBody-2" >
<p>Emacs Lisp tiene dos formas principales para hacer que una expresión, o una serie de expresiones, sea evaluada repetidamente: una usa un bucle <code>while</code>, y la otra <dfn>recursión</dfn>.</p>
<p>La repetición puede ser muy valiosa. Por ejemplo, para avanzar cuatro oraciones, solo necesitas escribir un programa que avance una oracion y luego repetir el proceso cuatro veces. Ya que un ordenador no se aburre o se cansa, tal acción repetitiva no tiene los efectos nocivos (como un monton de errores) que puede tener en los humanos.</p>
<p>La mayoria de personas escriben sus funciones de Emacs Lisp usando bucles <code>while</code> y sus parientes; pero se puede usar recursión, que provee un una manera muy poderosa de pensar para resolver problemas<span class="note" ><sup><a href="#11" >11</a></sup></span>.</p>
</div>
<h3 id="while" ><code>while</code></h3>
<div class="hBody-3" >
<p>La forma especial <code>while</code> prueba si el valor devuelto tras evaluar su primer argumento es verdadero o falso. Esto es parecido a lo que el intérprete Lisp hace con un <code>if</code>; el intérprete hace lo siguiente, sin embargo, lo que el interprete hace despues es diferente.</p>
<p>En una expresión <code>while</code>, si el valor devuelto por evaluar el primer argumento es falso, el intérprete Lisp omite el resto de la expresión (el <dfn>cuerpo</dfn> de la expresión) y no la evalúa. Sin embargo, si el valor es verdadero, el intérprete evalúa el cuerpo de la expresión y luego prueba nuevamente si el primer argumento de <code>while</code> es verdadero o falso. Si el valor devuelto al evaluar el primer argumento vuelve a ser verdadero, el intérprete Lisp vuelve a evaluar el cuerpo de la expresión.</p>
<p>La plantilla para una expresión <code>while</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">prueba-verdadero-o-falso</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Siempre que la evaluacion de <code>prueba-verdadero-o-falso</code> en la expresion <code>while</code> devuelva un valor verdadero, el cuerpo sera evaluado repetidamente. Este proceso se llama bucle porque el intérprete Lisp repite lo mismo una y otra vez, como un avión que hace un bucle. Cuando el resultado de evaluar <code>prueba-verdadero-o-falso</code> es falso, el intérprete no evalúa el resto de la expresión <code>while</code> y ‘sale del bucle’.</p>
<p>Claramente, si el valor devuelto evaluando el primer argumento de <code>while</code> es siempre cierto, el cuerpo siguiente será evaluado una y otra vez … y otra vez … por siempre. Por el contrario, si el valor devuelto nunca es verdadero, las expresiones en el cuerpo nunca serán evaluadas. El arte de escribir un bucle <code>while</code> consiste en elegir un mecanismo tal que <code>prueba-verdadero-o-falso</code> devuelva verdadero solo el número de veces que requiere evaluar las subsiguientes expresiones, y luego hacer que la prueba devuelva falso.</p>
<p>El valor devuelto evaluando un <code>while</code> es el valor de <code>prueba-verdadero-o-falso</code>. Una consecuencia interesante de esto es que un bucle <code>while</code> que se evalúa sin errores devolverá <code>nil</code> o falso independientemen de si ha hecho el bucle 1 o 100 veces o ninguna. ¿Una expresión <code>while</code> que se evalúa con exito nunca devuelve un valor verdadero! Lo que esto significa es que <code>while</code> siempre se evalua por sus efectos secundarios, es decir, las consecuencias de evaluar las expresiones dentro del cuerpo del bucle. Esto tiene sentido. No es el mero acto del bucle lo que se desea, sino las consecuencias de lo que ocurre cuando las expresiones en el bucle se evaluan repetidamente.</p>
</div>
<h4 id="un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</h4>
<div class="hBody-4" >
<p>Un forma común para controlar un bucle <code>while</code> es probar si una lista tiene algun elemento. Si es haci, el bucle se repite; pero si no, la repetición finaliza. Como esta es una tecnica importante, crearemos un ejemplo breve para ilustrarla.</p>
<p>Un manera sencilla de comprobar si una lista tiene elementos es evaluar la lista: si no tiene elementos, se trata de una lista vacía y devuelve la lista vacía, <code>()</code>, que es un sinónimo de <code>nil</code> o falso. Por otro lado, una lista con elementos devolverá estos elementos cuando se evalúe. Ya que Emacs Lisp considera como verdadero cualquier valor que no sea <code>nil</code>, una lista que devuelve elementos sera verdadero en un bucle <code>while</code>.</p>
<p>Por ejemplo, se puede asignar la variable <code>lista-vacia</code> a <code>nil</code> para evaluar la siguiente expresión <code>setq</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-vacia</span> <span class="p">())</span>
</code></pre>
<p>Después de evaluar la expresión <code>setq</code>, se puede evaluar la variable <code>lista-vacia</code> de la manera habitual, colocando el cursor después del símbolo y escribiendo <kbd>C-x C-e</kbd>; aparecerá <code>nil</code> en tu área de eco:</p>
<pre class="code" ><code class="chroma" ><span class="nv">lista-vacia</span>
</code></pre>
<p>Por otro lado, si se asigna una variable como una lista con elementos, la lista aparecerá cuando se evalúe la variable, como se puede ver al evaluar las dos expresiones siguientes:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="nv">animales</span>
</code></pre>
<p>De este modo, para crear un bucle <code>while</code> que pruebe si hay algun elemento en la lista <code>animales</code>, la primera parte del bucle se escribira así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">animales</span>
       <span class="err">…</span>
</code></pre>
<p>Cuando <code>while</code> prueba su primer argumento, la evaluacion de la variable <code>animales</code> devuelve una lista. Mientras la lista tenga elementos, el <code>while</code> considera que el resultado de la prueba es verdadero; pero cuando la lista esta vacía, se considera que el resultado de la prueba es falso.</p>
<p>Para prevenir que el bucle <code>while</code> se ejecute para siempre, es necesario proporcionar algún mecanismo para vaciar la lista. Una técnica usada con frecuencia es tener una de las expresiones en el cuerpo de <code>while</code> que asigne el valor del <code>cdr</code> de la lista a la lista. Cada vez que se evalua la función <code>cdr</code>, la lista se va reduciendo, hasta que finalmente solo queda la lista vacía. En este punto, la prueba del bucle <code>while</code> devolverá falso, y al mismo tiempo los argumentos ya no se evaluarán.</p>
<p>Por ejemplo, la lista de animales asociada a la variable <code>animals</code> puede asignarse a el <code>cdr</code> de la lista original con la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">animales</span><span class="p">))</span>
</code></pre>
<p>Si has evaluado las expresiones anteriores y luego evaluas esta expresión, veras aparecer <code>(jirafa leon tigre)</code> en el área de eco. Si evalúas la expresión de nuevo, aparecera <code>(leon tigre)</code>. Si lo evalúas de nuevo una y otra vez, veras <code>(tigre)</code> y despues la lista vacía, mostrada como <code>nil</code>.</p>
<p>Una plantilla para un bucle <code>while</code> usa la función <code>cdr</code> repetidamente para hacer que <code>prueba-verdadero-o-falso</code> eventualmente evalue a falso como se muesta a continuacion:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">prueba-si-la-lista-esta-vacia</span>
  <span class="nv">cuerpo</span><span class="err">…</span>
  <span class="nv">establece-lista-al-cdr-de-la-lista</span><span class="p">)</span>
</code></pre>
<p>Esto prueba y uso de <code>cdr</code> puede colocarse en una funcion a la que se pase una lista e imprima cada elemento de esta en una línea propia.</p>
</div>
<h4 id="un-ejemplo:-imprimir-elementos-de-la-lista" >Un ejemplo: <code>imprimir-elementos-de-la-lista</code></h4>
<div class="hBody-4" >
<p>La función <code>imprimir-elementos-de-la-lista</code> ilustra un bucle <code>while</code> con una lista.</p>
<p>La función requiere varias líneas para su salida. Si estás leyendo esto en una instancia reciente de GNU Emacs, puedes evaluarlo de la forma habitual.</p>
<p>Si estas usando una versión antigua de Emacs, es necesario copiar las expresiones necesarias en el búfer <span class="file" >*scratch*</span> y evaluarlas allí. Esto se debe a que el área de eco solo tenía una línea en las versiones antiguas.</p>
<p>Puedes copiar las expresiones marcando el principio de la región con <kbd>C-SPC</kbd> (<code>set-mark-command</code>), moviendo el cursor al final de la región y luego copiar la región usando <kbd>M-w</kbd> (<code>kill-ring-save</code>, que llama a <code>copy-region-as-kill</code> y proporciona la realimentación visual). En el búfer <span class="file" >*scratch*</span>, puedes copiar las expresiones con <kbd>C-y</kbd> (<code>yank</code>).</p>
<p>Después de haber copiado las expresiones al búfer <span class="file" >*scratch*</span>, evalúa cada expresión en orden. Asegúrate de evaluar la última expresión, <code>(imprimir-elementos-de-la-lista animales)</code>, presionando <kbd>C-u C-x C-e</kbd>, es decir, pasando un argumento a <code>eval-last-sexp</code>. Esto hara que el resultado de la evaluación se imprima en el búfer <span class="file" >*scratch*</span> en lugar de imprimirse en el área de eco. (De lo contrario, veras algo como esto en tu área de eco: <code>^Jgacela^J^Jjirafa^J^Jleon^J^Jtigre^Jnil</code>, en la que cada <samp>^J</samp> seria una ‘nueva línea’.)</p>
<p>En una instancia de GNU Emacs reciente, podria evaluar estas expresiones directamente, y el área de eco crecerá para mostrar los resultados.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-elementos-de-la-lista</span> <span class="p">(</span><span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Imprime cada elemento de LIST en una línea.&#34;</span>
  <span class="p">(</span><span class="nb">while</span> <span class="nf">list</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">list</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nf">list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">list</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">imprimir-elementos-de-la-lista</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>Cuando evalúes las tres expresiones en secuencia, verás esto:</p>
<div class="example-block" >
<pre class="example" >gacela

jirafa

leon

tigre
nil
</pre>
</div>
<p>Cada elemento de la lista se imprime en una línea propia (que es lo que hace la función <code>print</code>) y luego se imprime el valor devuelto por la función. Como la última expresión de la función es el bucle <code>while</code>, y como los bucles <code>while</code> siempre devuelven <code>nil</code>, se imprime un <code>nil</code> después del último elemento de la lista.</p>
</div>
<h4 id="un-bucle-con-un-contador-incremental" >Un bucle con un contador incremental</h4>
<div class="hBody-4" >
<p>Un bucle no es útil a menos que pare cuando debe. Ademas de controlar un bucle con una lista, una forma comun de detener un bucle es escribir el primer argumento como una prueba que devuelve falso cuando el número correcto de repeticiones esta completo. Esto significa que el bucle debe tener un contador––una expresión que cuenta cuántas veces el bucle se repite a sí mismo.</p>
<p>La prueba para un bucle con un contador incremental puede ser una expresión como <code>(&lt; contador numero-deseado)</code> que devuelve <code>t</code> para verdadero si el valor de <code>contador</code> es menor que el <code>numero-deseado</code> de repeticiones y <code>nil</code> para falso si el valor de <code>contador</code> es igual o mayor al <code>numero-deseado</code>. La expresión que incrementa el contador puede ser un simple <code>setq</code> como <code>(setq contador (1+ contador))</code>, donde <code>1+</code> es una función nativa de Emacs Lisp que añade 1 a su argumento. (La expresión <code>(1+ contador)</code> tiene el mismo resultado que <code>(+ contador 1)</code>, pero es mas facil de leer para un humano.)</p>
<p>La plantilla para un bucle <code>while</code> controlado por un contador que se incrementa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="nv">asignar-un-valor-inicial-al-contador</span>
<span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">contador</span> <span class="nv">numero-deseado</span><span class="p">)</span>         <span class="c1">; prueba-verdadero-o-falso</span>
  <span class="nv">cuerpo</span><span class="err">…</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">contador</span><span class="p">)))</span>           <span class="c1">; incremento</span>
</code></pre>
<p>Ten en cuenta que se necesita asignar el valor inicial de <code>contador</code>; por lo general se asigna en 1.</p>
</div>
<h5 id="ejemplo-con-contador-incremental" >Ejemplo con contador incremental</h5>
<div class="hBody-5" >
<p>Supón que estás jugando en la playa y decides crear un triángulo de guijarros, poniendo uno en la primera fila, dos en la segunda fila, tres en la tercera fila y así sucesivamente:</p>
<div class="example-block" >
<pre class="example" >   •
  • •
 • • •
• • • •
</pre>
</div>
<p>(Hace 2500 años, Pitágoras y otros desarrollaron los principios de la teoría de números al considerar preguntas como esta.)</p>
<p>Supón que quieres saber cuántos guijarros necesitarás para hacer un triángulo con 7 filas</p>
<p>Claramente, lo que necesitas hacer es sumar los números de 1 a 7. Hay dos maneras de hacer esto; se puede comenzar con el numero más pequeño, uno, y sumar la lista en secuencia, 1, 2, 3, 4 y así sucesivamente; o empezar con el número más grande y sumar la lista hacia abajo: 7, 6, 5, 4 y así sucesivamente. Debido a que ambos mecanismos ilustran formas comunes de escribir el bucle <code>while</code>, crearemos dos ejemplos, uno contando hacia arriba y el otro contando hacia abajo. En este primer ejemplo, empezaremos con 1 y sumaremos 2, 3, 4, etc.</p>
<p>Si quieres sumar toda una lista de números, el camino más fácil de hacerlo es sumar todos los números a la vez. Sin embargo, si no se sabe de antemano cuántos números tendrá la lista, o si se requiere estar preparado para una lista muy larga, entonces se necesita diseñar la suma, a modo de , repetir un proceso simple muchas veces en vez de hacer un proceso más complejo una y otra vez.</p>
<p>Por ejemplo, en lugar de sumar todos los guijaros a la vez, lo que se puede hacer es sumar el número de guijarros en la primera fila, 1, al número en la segunda fila, 2, y entonces añadir el total de estas dos filas a la tercera fila, 3. Luego se puede sumar el número en la cuarta fila, 4, al total de las primeras tres filas; y así sucesivamente.</p>
<p>La característica crítica del proceso es que cada acción repetitiva sea simple. En este caso, en cada paso se suman solo dos números, el número de guijarros en la fila y el total ya encontrado. Este proceso de sumar dos números se repite una y otra vez hasta que la última fila ha sido añadida al total de todas las filas precedentes. En un bucle más complejo la acción repetitiva podría no ser tan sencilla, pero será mas simple que hacerlo todo de una sola vez.</p>
</div>
<h5 id="las-partes-de-la-definición-de-función" >Las partes de la definición de función</h5>
<div class="hBody-5" >
<p>El análisis anterior nos da los huesos de nuestra definición de función: primero, necesitaremos una variable que podemos llamar <code>total</code> que será el número total de guijarros. Este será el valor devuelto por la función.</p>
<p>En segundo lugar, sabemos que la función requerirá un argumento: este argumento será el número total de filas del triángulo. Puede llamarse <code>numero-de-filas</code>.</p>
<p>Finalmente, necesitamos una variable para usar como contador. Podriamos llamar a esta variable <code>contador</code>, pero un mejor nombre es <code>numero-de-fila</code>. Esto se debe a que lo que hace el contador en esta función es contar filas, y un programa debería escribirse para ser lo mas comprensible posible.</p>
<p>Cuando el intérprete Lisp comience a evaluar las expresiones de la función, el valor de <code>total</code> deberia ser cero, ya que no hemos sumado nada al mismo. Entonces la función debe sumar el número de guijarros en la primera fila al total, y luego sumar el número de guijarros en la segunda al total, y luego sumar el número de guijarros en la tercera fila al total, y así sucesivamente, hasta que no queden más filas por sumar.</p>
<p>Tanto <code>total</code> como <code>numero-de-fila</code> se usan solo dentro de la función, por lo que pueden ser declarados como variables locales con <code>let</code> dando sus valores iniciales. Evidentemente, el valor inicial para total sera 0. El valor inicial de <code>numero-de-fila</code> sera 1, ya que comenzaremos con la primera fila. Esto significa que la declaracion <code>let</code> se vera asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">numero-de-fila</span> <span class="mi">1</span><span class="p">))</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Después de declarar y asignar las variables internas, podemos comenzar el bucle <code>while</code>. La expresión que sirve como prueba deberia devolver un valor de <code>t</code> para verdadero siempre que el <code>numero-de-fila</code> sea menor o igual al <code>numero-de-filas</code>. (Si la prueba devuelve verdadero solo si el número de fila es menor que el número de filas en el triángulo, la última fila nunca se sumara al total; por lo tanto, el número de fila tiene que ser menor o igual al número de filas.)</p>
<p>Lisp proporciona la función <code>&lt;=</code> que devuelve verdadero si el valor de su primer argumento es menor o igual al valor de su segundo argumento y falso de otro modo. Así que la expresión que el <code>while</code> evaluará como su prueba deveria verse asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">numero-de-fila</span> <span class="nv">numero-de-filas</span><span class="p">)</span>
</code></pre>
<p>El número total de guijarros se puede encontrar sumando repetidamente el número de guijarros en una fila al total ya encontrado. Puesto que el número de guijarros en la fila es igual al número de la fila, el total puede encontrarse añadiendo el número de filas al total. (Claramente, en una situación más compleja, el número de guijarros en la fila podría estar relacionado con el número de la fila de una manera más complicada; si este fuera el caso, el número de la fila sería reemplazado por la expresión apropiada.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">numero-de-fila</span><span class="p">))</span>
</code></pre>
<p>Lo que esto hace es asignar el nuevo valor de <code>total</code> para que sea igual a la suma del número de guijarros en la fila al total anterior.</p>
<p>Después de establecer el valor de <code>total</code>, se deben establecer las condiciones para la siguiente repetición del bucle, si hay alguna. Esto se hace incrementando el valor de la variable <code>numero-de-fila</code>, que sirve como contador. Después de incrementar la variable <code>numero-de-fila</code>, la prueba-verdodero-o-falso al principio del bucle <code>while</code> prueba si su valor aun es menor o igual al valor del <code>numero-de-filas</code> y, si lo es, suma el nuevo valor de la variable <code>numero-de-fila</code> al <code>total</code> de la repetición previa.</p>
<p>La función nativa <code>1+</code> en Emacs Lisp añade 1 a un número, por lo que la variable <code>numero-de-fila</code> puede incrementarse con esta expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-fila</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero-de-fila</span><span class="p">))</span>
</code></pre>
</div>
<h5 id="juntando-la-definición-de-función" >Juntando la definición de función</h5>
<div class="hBody-5" >
<p>Hemos creado las partes para la definición de la función; ahora necesitamos juntarlas.</p>
<p>Primero, el contenido de la expresión <code>while</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">numero-de-fila</span> <span class="nv">numero-de-filas</span><span class="p">)</span>    <span class="c1">; prueva-verdadero-o-falso</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">numero-de-fila</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-fila</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero-de-fila</span><span class="p">)))</span>  <span class="c1">; incremento</span>
</code></pre>
<p>Junto con la expresión <code>let</code> de la varlist, casi completan el cuerpo de la definición de función. Sin embargo, se requiere un ultimo elemento, cuya necesidad es algo sutil.</p>
<p>El toque final es colocar la variable <code>total</code> en una línea por sí misma después de la expresión <code>while</code>. De lo contrario, el valor devuelto por la función completa sera el valor de la última expresión en evaluarse dentro del cuerpo del <code>let</code>, y este es el valor devuelto por el <code>while</code> que es siempre <code>nil</code>.</p>
<p>Esto puede no ser evidente a primera vista. Casi parece como si la expresión de incremento fuera la última expresión de la función completa. Pero esa expresión es parte del cuerpo del <code>while</code>; es el último elemento de la lista que empieza con el símbolo <code>while</code>. Ademas, todo el bucle <code>while</code> es una lista dentro del cuerpo del <code>let</code>.</p>
<p>En el esquema, la función tendra este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-la-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">varlist</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nv">prueba-verdadero-o-falso</span><span class="p">)</span>
      <span class="nv">cuerpo-de-while</span><span class="err">…</span> <span class="p">)</span>
    <span class="err">…</span> <span class="p">))</span>                    <span class="c1">; aqui necesita la expresión final.</span>
</code></pre>
<p>El resultado de evaluar el <code>let</code> es lo que va a ser devuelto por <code>defun</code> ya que <code>let</code> no está embebidob dentro de ninguna lista que contenga, excepto por el <code>defun</code> como un todo. Sin embargo, si el <code>while</code> es el último elemento de la expresión <code>let</code>, la función siempre devolverá <code>nil</code>. ¡Esto no es lo que queremos! En vez de eso, queremos el valor de la variable <code>total</code>. Esto se devuelve simplemente colocando el símbolo como el último elemento de la lista empezanda por <code>let</code>. Eso se evalúa después de evaluar los elementos precedentes, lo que significa que se evaluó después de que se le ha asignado el valor correcto para el total.</p>
<p>Puede ser mas fácil ver esto imprimiendo la lista iniciada por <code>let</code> en una línea. Este formato hace evidente que las expresiones <code>varlist</code> y <code>while</code> son el segundo y tercer elementos de la lista iniciado por <code>let</code>, y <code>total</code> es el último elemento:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">varlist</span><span class="p">)</span> <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nv">prueba-verdadero-o-falso</span><span class="p">)</span> <span class="nv">cuerpo-de-while</span><span class="err">…</span> <span class="p">)</span> <span class="nv">total</span><span class="p">)</span>
</code></pre>
<p>Poniendo todo junto, la definición de la función <code>triangulo</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo</span> <span class="p">(</span><span class="nv">numero-de-filas</span><span class="p">)</span>  <span class="c1">; Versión con</span>
                                    <span class="c1">; contador de incremento.</span>
  <span class="s">&#34;Suma el número de guijarros en un triángulo.
</span><span class="s">La primera fila tiene un guijarro, la segunda fila dos guijarros,
</span><span class="s">la tercera fila tres guijarros, y así sucesivamente.
</span><span class="s">El argumento es NUMERO-DE-FILAS.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">numero-de-fila</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">numero-de-fila</span> <span class="nv">numero-de-filas</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">numero-de-fila</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-fila</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero-de-fila</span><span class="p">)))</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>Después de haber instalado <code>triangulo</code> al evaluar la función, puede probarlo. Aquí hay dos ejemplos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo</span> <span class="mi">4</span><span class="p">)</span>

<span class="p">(</span><span class="nv">triangulo</span> <span class="mi">7</span><span class="p">)</span>
</code></pre>
<p>La suma de los primeros cuatro números es 10 y la suma de los primeros siete números es 28.</p>
</div>
<h4 id="bucle-con-contador-decreciente" >Bucle con contador decreciente</h4>
<div class="hBody-4" >
<p>Otra manera común de escribir un bucle <code>while</code> es con una prueba que determine si un contador es mayor que cero. Mientras el contador sea mayor que cero, el bucle se repite. Pero cuando el contador es igual o menor que cero, el bucle se detiene. Para que esto funcione, el contador tiene que empezar por encima de cero y luego hacerse mas y mas pequeño por una forma que se evalua repetidamente.</p>
<p>La prueba será una expresión como <code>(&gt; contador 0)</code> que devuelve <code>t</code> para verdadero si el valor del <code>contador</code> es mayor que cero, y <code>nil</code> para falso si el valor del <code>contador</code> es igual a o menor que cero. La expresión que hace que el número menor sea cada vez mas pequeño puede ser un simple <code>setq</code> como <code>(setq contador (1- contador)</code>, donde <code>1-</code> es una función nativa en Emacs Lisp que resta 1 de su argumento.</p>
<p>La plantilla para un bucle <code>while</code> decreciente se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">contador</span> <span class="mi">0</span><span class="p">)</span>                   <span class="c1">; prueba-verdadero-o-falso</span>
  <span class="nv">cuerpo</span><span class="err">…</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">contador</span><span class="p">)))</span>        <span class="c1">; decremento</span>
</code></pre>
</div>
<h5 id="ejemplo-con-contador-decreciente" >Ejemplo con contador decreciente</h5>
<div class="hBody-5" >
<p>Para ilustrar un bucle con un contador decreciente, reescribiremos la función <code>triangulo</code> para que el contador disminuya a cero.</p>
<p>Esto es lo inverso de la versión anterior de la función. En este caso, para saber cuantos guijarros se necesitan para crear un triángulo con 3 filas, se suma el número de guijarros en la tercera fila, 3, al numero en la fila anterior, 2, y luego se suman el total de esas dos filas a la fila que lo precede, que es 1.</p>
<p>Del mismo modo, para encontrar el número de guijarros en un triángulo con 7 filas, se suma el número de guijarros en la fila siete, 7, al número en la fila anterior, que es 6, y luego se suma el total de estas dos filas a la fila que las precede, que es 5, y así sucesivamente. Como en el ejemplo previo, cada suma solo implica sumar dos números, el total de las filas ya sumadas y el número de guijarros en la fila que se suma al total. Este proceso de sumar dos números se repite una y otra vez hasta que no haya más guijarros que agregar.</p>
<p>Sabemos con cuántos guijarros empezar: el número de guijarros en la última fila es igual al número de filas. Si el triángulo tiene siete filas, el número de guijarros en la última fila es 7. Del mismo modo, sabemos cuántos guijarros hay en la fila anterior: uno menos que el número en la fila actual.</p>
</div>
<h5 id="las-partes-de-la-definición-de-función" >Las partes de la definición de función</h5>
<div class="hBody-5" >
<p>Empezamos con tres variables: el número total de filas en el triángulo; el número de guijarros en una fila; y el número total de guijarros, que es lo que queremos calcular. Estas variables pueden llamarse <code>numero-de-filas</code>, <code>numero-de-guijarros-en-fila</code>, y <code>total</code>, respectivamente.</p>
<p>Tanto <code>total</code> como <code>numero-de-guijarros-en-fila</code> se usan solo dentro de la función y se declaran con <code>let</code>. El valor inicial de <code>total</code> deberia ser cero. Sin embargo, el valor inicial de <code>numero-de-guijarros-en-fila</code> deberia ser igual al número de filas en el triángulo, ya que la suma comenzara con la fila más larga.</p>
<p>Esto significa que el principio de la expresión <code>let</code> se verá así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">numero-de-guijarros-en-fila</span> <span class="nv">numero-de-filas</span><span class="p">))</span>
  <span class="nv">body</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>El número total de guijarros se puede encontrar sumando repetidamente el número de guijarros en una fila al total ya encontrado, es decir, evaluando repetidamente la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">numero-de-guijarros-en-fila</span><span class="p">))</span>
</code></pre>
<p>Después de sumar <code>numero-de-guijarros-en-fila</code> al <code>total</code>, el <code>numero-de-guijarros-en-fila</code> debe decrecer por uno, ya que la siguiente vez que el bucle se repita, la fila anterior se sumara al total.</p>
<p>El número de guijarros en una fila anterior es uno menos que el número de guijarros en la fila actual, por lo que se utilizara la función nativa <code>1-</code> de Emacs para calcular el número de guijarros de la fila anterior. Esto se puede hacer con la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-guijarros-en-fila</span>
      <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero-de-guijarros-en-fila</span><span class="p">))</span>
</code></pre>
<p>Finalmente, sabemos que el bucle <code>while</code> deberia detenerse cuando no halla guijarros en una fila. Así que la prueba en el bucle <code>while</code> es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">numero-de-guijarros-en-fila</span> <span class="mi">0</span><span class="p">)</span>
</code></pre>
</div>
<h5 id="juntando-la-definición-de-función" >Juntando la definición de función</h5>
<div class="hBody-5" >
<p>Podemos juntar estas expresiones para crear una definición de función que funcione. Sin embargo, al examinarlas, encontraremos que una de la variables locales ¡es innecesaria!</p>
<p>La definición de función tiene este aspeto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Primer version decreciente.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo</span> <span class="p">(</span><span class="nv">numero-de-filas</span><span class="p">)</span>
  <span class="s">&#34;Suma el número de guijarros en un triángulo.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">numero-de-guijarros-en-fila</span> <span class="nv">numero-de-filas</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">numero-de-guijarros-en-fila</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">numero-de-guijarros-en-fila</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-guijarros-en-fila</span>
            <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero-de-guijarros-en-fila</span><span class="p">)))</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>Como esta escrita, esta función funciona.</p>
<p>Sin embargo, no se necesita <code>numero-de-guijarros-en-fila</code>.</p>
<p>Cuando se evalua la función <code>triangle</code>, el símbolo <code>numero-de-filas</code> se vinculara a un número, dandole un valor inicial. Ese número puede ser modificado en el cuerpo de la función como si fuera una variable local, sin temor a que tal cambio afecte el valor de la variable fuera de la función. Esta es una característica muy útil de Lisp; significa que la variable <code>numero-de-filas</code> se puede utilizar en cualquier lugar de la función donde se utilice <code>numero-de-guijarros-en-fila</code>.</p>
<p>Aquí hay una segunda versión de la función escrita un poco más limpiamente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>                <span class="c1">; Segunda versión.</span>
  <span class="s">&#34;Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">numero</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">numero</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero</span><span class="p">)))</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>En resumen, un bucle <code>while</code> escrito apropiadamente constará de tres partes:</p>
<ol class="num" >
<li>
<p>Una prueba que devuelva falso después de que el bucle se ha repetido el número de veces correcto.</p>
</li>
<li>
<p>Una expresión cuya evaluación repetida devolverá el valor deseado.</p>
</li>
<li>
<p>Una expresión para cambiar el valor pasado a la prueba-verdadero-o-falso para que esta devuelva falso después de que el bucle se haya repetido el numero de veces correcto.</p>
</li>
</ol>
</div>
<h3 id="ahorra-tu-tiempo:-dolist-y-dotimes" >Ahorra tu tiempo: <code>dolist</code> y <code>dotimes</code></h3>
<div class="hBody-3" >
<p>Además de <code>while</code>, tanto <code>dolist</code> como <code>dotimes</code> proveen un bucle. Algunas veces estos son mas rápidos de escribir el bucle <code>while</code> equivalente. Ambos son macros Lisp. (Vea la Seccion <a href="info:elisp#Macros" >Macros</a> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p><code>dolist</code> funciona como un bucle <code>while</code> con ‘<code>cdr</code>s que bajan la lista’: <code>dolist</code> acorta automáticamente con cada bucle––toma el <code>cdr</code> de la lista––y liga el <code>car</code> de cada versión mas corta al primero de sus argumentos.</p>
<p><code>dotimes</code> repite el bucle un número específico de veces: tu especificas el número.</p>
</div>
<h4 id="la-macro-dolist" >La macro <code>dolist</code></h4>
<div class="hBody-4" >
<p>Supón, por ejemplo, que quieres invertir una lista, para que “primero”, “segundo”, “tercero” se convierta en “tercero”, “segundo”, “primero”.</p>
<p>En la práctica, usarías la función <code>reverse</code>, como aqui:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nf">reverse</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>A continuacion se muestra como se podría invertir la lista usando un bucle <code>while</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">invertir-lista-con-while</span> <span class="p">(</span><span class="nv">lista</span><span class="p">)</span>
  <span class="s">&#34;Usando while, invierte el orden de LISTA.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">valor</span><span class="p">)</span>  <span class="c1">; asegura que la lista comienza vacía</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">lista</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">valor</span> <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista</span><span class="p">)</span> <span class="nv">valor</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista</span><span class="p">)))</span>
    <span class="nv">valor</span><span class="p">))</span>

<span class="p">(</span><span class="nv">invertir-lista-con-while</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>Y aquí se ve cómo puedes usar la macro <code>dolist</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">invertir-lista-con-dolist</span> <span class="p">(</span><span class="nv">lista</span><span class="p">)</span>
  <span class="s">&#34;Usando dolist, invierte el orden de LISTA.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">valor</span><span class="p">)</span>  <span class="c1">; asegura que la lista empieza vacía</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">elemento</span> <span class="nv">lista</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">valor</span> <span class="p">(</span><span class="nf">cons</span> <span class="nv">elemento</span> <span class="nv">valor</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">invertir-lista-con-dolist</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>Puedes colocar el cursor después del parentesis de cierre de cada expresión y pulsar <kbd>C-x C-e</kbd>; en cualquier caso, deberias ver</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">tigre</span> <span class="nv">leon</span> <span class="nv">jirafa</span> <span class="nv">gacela</span><span class="p">)</span>
</code></pre>
<p>en el área de eco.</p>
<p>Para este ejemplo, la función <code>reverse</code> obviamente es la mejor opcion. El bucle <code>while</code> es como nuestro primer ejemplo (ver Seccion <a href="#un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a>). <code>while</code> comprueba si la lista tiene elementos; si es así, construye una nueva lista añadiendo el primer elemento de la lista a la lista existente (que en la primer iteración del bucle es <code>nil</code>). Puesto que el segundo elemento se asigna delante del primero, y el tercero delante del segundo, la lista se invierte.</p>
<p>En la expresión que usa un bucle <code>while</code>, la expresión <code>(setq lista (cdr lista))</code> acorta la lista, por lo que el bucle <code>while</code> termina deteniendose. Además, se proporciona la expresión <code>cons</code> con un nuevo primer elemento creando una nueva lista en cada repetición del bucle.</p>
<p>La expresión <code>dolist</code> hace lo mismo que la expresión <code>while</code>, excepto que la macro <code>dolist</code> hace algo del trabajo que tienes que hacer cuando se escribe una expresión <code>while</code>.</p>
<p>Como un bucle <code>while</code>, <code>dolist</code> hace un bucle. Lo que es diferente es que (<code>dolist</code>) acorta automáticamente la lista con cada repeticion––con ‘<code>cdr</code>s que bajan la lista’ por su cuenta––y asocia automáticamente el <code>car</code> de cada versión acortada de la lista al primero de sus argumentos.</p>
<p>En el ejemplo, el <code>car</code> de cada versión reducida de la lista se vincula al símbolo <samp>elemento</samp>, la lista en sí se llama <samp>lista</samp>, y el valor devuelto se llama <samp>valor</samp>. El resto de la expresión <code>dolist</code> es el cuerpo.</p>
<p>La expresión <code>dolist</code> asocia el <code>car</code> de cada versión reducida de la lista a <code>elemento</code> y luego evalúa el cuerpo de la expresión y repite el bucle. El resultado es devuelto en <code>valor</code>.</p>
</div>
<h4 id="la-macro-dotimes" >La macro <code>dotimes</code></h4>
<div class="hBody-4" >
<p>La macro <code>dotimes</code> es similar a <code>dolist</code>, excepto que el bucle se repite un número específico de veces.</p>
<p>Al primer argumento de <code>dotimes</code> se le asignan los números 0, 1, 2 y así sucesivamente cada iteracion, y se devuelve el valor del tercer. Se necesita proveer el valor del segundo argumento, que es el numero de veces que la macro se repite.</p>
<p>Por ejemplo, lo siguiente asocia al primer argumento <code>numero</code> los números de 0 en adelante, pero no incluye, el número 3, y luego construye una lista de los tres números. (El primer número es 0, el segundo es 1, y el tercero es 2; esto hace un total de tres, comenzando con cero como el primer número.)</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">valor</span><span class="p">)</span>      <span class="c1">; de otro modo, &#34;valor&#34; es una variable vacia</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">numero</span> <span class="mi">3</span> <span class="nv">valor</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">valor</span> <span class="p">(</span><span class="nf">cons</span> <span class="nv">numero</span> <span class="nv">valor</span><span class="p">))))</span>
</span><span class="out" >(2 1 0)
</span></code></pre>
<p><code>dotimes</code> devuelve <code>valor</code>, así que la forma de usar <code>dotimes</code> es operar sobre alguna expresión <code>numero</code> un numero veces y luego devolver el resultado, como una lista o un átomo.</p>
<p>Aquí hay un ejemplo de un <code>defun</code> que usa <code>dotimes</code> para sumar el número de guijarros en un triángulo.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-utilizando-dotimes</span> <span class="p">(</span><span class="nv">numero-de-filas</span><span class="p">)</span>
  <span class="s">&#34;Usando dotimes, suma el número de guijarros en un triángulo.&#34;</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1">; de otro modo total es una variable vacía</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">numero</span> <span class="nv">numero-de-filas</span> <span class="nv">total</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero</span><span class="p">))))))</span>

<span class="p">(</span><span class="nv">triangulo-utilizando-dotimes</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="recursividad" >Recursividad</h3>
<div class="hBody-3" >
<p>Una función recursiva contiene código que indica al intérprete Lisp que llame a un programa que se ejecuta exactamente como el mismo, pero con argumentos ligeramente diferentes. El código funciona exactamente igual porque tiene el mismo nombre. Sin embargo, aunque el programa tenga el mismo nombre, no es la misma entidad. Eso es diferente. En la jerga, se dice es una ‘instancia’ diferente.</p>
<p>Eventualmente, si el programa se escribe correctamente, los ‘argumentos ligeramente diferentes’ llegan a ser suficientemente diferentes de los primeros argumentos para que se detenga la instancia final.</p>
</div>
<h4 id="construyendo-robots:-extendiendo-la-metáfora" >Construyendo robots: Extendiendo la metáfora</h4>
<div class="hBody-4" >
<p>Algunas veces es útil pensar en un programa en ejecución como un robot que hace un trabajo. Al hacer su trabajo, una función recursiva llama a un segundo robot para que le ayude. El segundo robot es idéntico al primero en todos los sentidos, excepto que el segundo robot ayuda al primero y ha recibido argumentos diferentes al primero.</p>
<p>En una función recursiva, el segundo robot puede llamar a un tercero; y el tercero puede llamar a un cuarto, y así sucesivamente. Cada uno de ellos es una entidad diferente; pero todos son clones.</p>
<p>Dado que cada robot tiene instrucciones ligeramente diferentes––los argumentos difieren de un robot a otro––el último robot deberia saber cuando detenerse.</p>
<p>Expandamos la metáfora en la que un programa de ordenador es un robot.</p>
<p>Una definición de función proporciona los panos para un robot. Cuando se instala una definición de función, que es, cuando se evalúa una forma especial <code>defun</code>, se instala el equipo necesario para construir robots. Es como si estuvieras en una fábrica, construyendo una línea de montaje. Los robots con el mismo nombre se construyen segun los mismos planos. Así que tienen, por asi decirlo, el mismo ‘número de modelo’, pero un ‘número de serie’ diferente.</p>
<p>A menudo decimos que una función recursiva ‘se llama así misma’. Lo que queremos decir es que las instrucciones en una función recursiva hacen que el intérprete Lisp ejecute una función diferente que tiene el mismo nombre y hace el mismo trabajo que la primera, pero con argumentos diferentes.</p>
<p>Es importante que los argumentos difieran de una instancia a la siguiente; de otro modo, el proceso nunca se detendra.</p>
</div>
<h4 id="las-partes-de-una-definición-recursiva" >Las partes de una definición recursiva</h4>
<div class="hBody-4" >
<p>Una función recursiva típicamente contiene una expresión condicional que tiene tres partes:</p>
<ol class="num" >
<li>
<p>Una prueva-verdadero-o-falso que determina si la función se vuelve a llamar, aquí se llamara <dfn>prueba-hazlo-de-nuevo</dfn>.</p>
</li>
<li>
<p>El nombre de la función. Cuando este nombre se llama, se crea una nueva instancia de la función––un nuevo robot, por asi decirlo––y se le dice qué hacer.</p>
</li>
<li>
<p>Una expresión que devuelve un valor diferente cada vez que se llama a la función, aquí se llamara <dfn>expresion-del-siguiente-paso</dfn>. Consecuentemente, el argumento (o argumentos) pasados a la nueva instancia de la función será diferente del argumento (o argumentos) pasados a la instancia previa. Esto hace que la expresión condicional, la <dfn>prueba-hazlo-de-nuevo</dfn>, devuelva falso después del número correcto de repeticiones.</p>
</li>
</ol>
<p>Las funciones recursivas pueden ser mucho más simples que cualquier otro tipo de funcion. De hecho, cuando las personas comienzan a usarlas, con frecuencia se ven tan misteriosamente simples como para ser incomprensibles. Al igual que montar en bicicleta, leer la definicion de una función recursiva requiere una cierta habilidad, es dificil al principio, pero después parece facil.</p>
<p>Hay varios patrones recursivos diferentes. Un patrón muy simple se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion-recursiva</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentation…&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-hazlo-de-nuevo</span>
    <span class="nv">cuerpo</span><span class="err">…</span>
    <span class="p">(</span><span class="nv">nombre-de-funcion-recursiva</span> <span class="nv">expresion-del-siguiente-paso</span><span class="p">)))</span>
</code></pre>
<p>Cada vez que se evalua una función recursiva, se crea una nueva instancia y se le dice qué hacer. Los argumentos le dicen a la instancia qué hacer.</p>
<p>Un argumento es ligado al valor de la expresion-del-siguiente-paso. Cada instancia se ejecuta con un valor de la expresion-del-siguiente-paso diferente.</p>
<p>El valor en la expresion-del-siguiente-paso se utiliza en la prueba-hazlo-de-nuevo.</p>
<p>El valor devuelto por la expresion-del-siguiente-paso se pasada a la nueva instancia de la función, que lo evalúa para determinar si continua o se detiene. La expresion-del-siguiente-paso está diseñada para que la prueba-hazlo-de-nuevo devuelva falso cuando la función ya no deba repetirse.</p>
<p>La prueba-hazlo-de-nuevo a veces se denomina <dfn>condición de parada</dfn>, ya que detiene las repeticiones cuando la prueba falla.</p>
</div>
<h4 id="recursividad-con-una-lista" >Recursividad con una lista</h4>
<div class="hBody-4" >
<p>El ejemplo de un bucle <code>while</code> que imprimia los elementos de una lista de números puede escribirse recursivamente. Aquí está el código, incluyendo una expresión para asignar el valor de la variable <code>animales</code> a una lista.</p>
<p>Si estás leyendo esto dentro de Emacs, puedes evaluar esta expresión directamente. De lo contrario, debes copiar el ejemplo al búfer <span class="file" >*scratch*</span> y evalúar cada expresión alli. Utiliza <kbd>C-u C-x C-e</kbd> para evaluar la expresión <code>(imprimir-elementos-recursivamente animales)</code> de manera que se imprima el resultado en el búfer; de otro modo el intérprete Lisp colocara los resultados en la línea del área de eco.</p>
<p>También, coloca el  cursor inmediatamente después del último paréntesis de cierre de la función <code>imprimir-elementos-recursivamente</code>, antes del comentario. De lo contrario, el intérprete Lisp intentará evaluar el comentario.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-elementos-recursivamente</span> <span class="p">(</span><span class="nv">lista</span><span class="p">)</span>
  <span class="s">&#34;Imprime cada elemento de LISTA en una línea propia.
</span><span class="s">Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">lista</span>                               <span class="c1">; prueba-hazlo-de-nuevo</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista</span><span class="p">))</span>                 <span class="c1">; cuerpo</span>
        <span class="p">(</span><span class="nv">imprimir-elementos-recursivamente</span>  <span class="c1">; llamada recursiva</span>
         <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista</span><span class="p">))))</span>                     <span class="c1">; expresion-del-siguiente-paso</span>

<span class="p">(</span><span class="nv">imprimir-elementos-recursivamente</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>La función <code>imprimir-elementos-recursivamente</code> primero prueba si hay algun contenido en la lista; si lo hay, la función imprime el primer elemento de la lista, el <code>car</code> de la lista. Entonces la función se ‘invoca en sí misma’, pero se da como su argumento, no la lista completa, pero el segundo y subsiguientes elementos de esta, es decir, el <code>cdr</code> de la lista.</p>
<p>Dicho de otro modo, si la lista no está vacía, la función invoca otra instancia de código que es similar al código inicial, pero es un hilo de ejecución diferente, con argumentos diferentes o los de la primera instancia.</p>
<p>Dicho de otro modo más, si la lista no está vacía, el primer robot ensambla un segundo robot y le dice qué hacer; el segundo robot es un individuo diferente del primero, pero es del mismo modelo.</p>
<p>Cuando se produce la segunda evaluación, se evalua la expresión <code>when</code> y si es verdadera, imprime el primer elemento de la lista que recibe como argumento (que es el segundo elemento de la lista original). A continuacion la función ‘se llama a sí misma’ (la segunda vez) con el <code>cdr</code> del <code>cdr</code> de la lista original.</p>
<p>Ten en cuenta que aunque decimos que la función ‘se llama a sí misma’, lo que queremos decir es que el intérprete Lisp ensambla e instruye una nueva instancia del programa. La nueva instancia es un clon del primero, pero es un individuo separado.</p>
<p>Cada vez que la función ‘se invoca a sí misma’, se invoca con una versión mas corta de la lista original. Crea una nueva instancia que funciona en una lista mas corta.</p>
<p>Eventualmente, la función se invoca a sí misma con una lista vacía. Crea una nueva instancia cuyo argumento es <code>nil</code>. La expresión condicional prueba el valor de <code>lista</code>. Ya que el valor de la <code>lista</code> es <code>nil</code>, la expresión <code>when</code> devuelve falso así la parte-then no sera evaluada. La función como un todo entonces devuelve <code>nil</code>.</p>
<p>Cuando se evalúa la expresión <code>(imprimir-elementos-recursivamente animales)</code> en el búfer <span class="file" >*scratch*</span>, se ve este resultado:</p>
<div class="example-block" >
<pre class="example" >gacela

jirafa

leon

tigre
nil
</pre>
</div>
</div>
<h4 id="recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</h4>
<div class="hBody-4" >
<p>La función <code>triangulo</code> descrita en una sección anterior tambien se puede escribir recursivamente. Se vera así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-recursivo</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.
</span><span class="s">Usa recursion.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">numero</span> <span class="mi">1</span><span class="p">)</span>                    <span class="c1">; prueba-hazlo-de-nuevo</span>
      <span class="mi">1</span>                               <span class="c1">; parte-then</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span>                         <span class="c1">; parte-else</span>
       <span class="p">(</span><span class="nv">triangulo-recursivo</span>           <span class="c1">; llamada recursiva</span>
        <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero</span><span class="p">)))))</span>               <span class="c1">; expresion-del-siguiente-paso</span>

<span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="mi">7</span><span class="p">)</span>
</code></pre>
<p>Puedes instalar esta función evaluandola y luego probarla evaluando <code>(triangulo-recursivo 7)</code>. (Recuerda colocar tu cursor inmediatamente después del último paréntesis de la definición de la función, antes del comentario.) La función se evalúa a 28.</p>
<p>Para comprender cómo funciona esta función, hay que considerar qué ocurre en varios casos cuando la función pasa 1, 2, 3, o 4 como el valor de su argumento.</p>
<p>Primero, ¿que sucede si el valor del argumento es 1?</p>
<p>La función tiene una expresión <code>if</code> después de la cadena de documentación. Prueba si el valor de <code>numero</code> es igual a 1; si es así, Emacs evalúa la parte-then de la expresión <code>if</code>, que devuelve el número 1 como el valor de la función. (Un triángulo con una fila tiene un guijarro dentro.)</p>
<p>Supón, sin embargo, que el valor del argumento es 2. En este caso, Emacs evalúa la parte-else de la expresión <code>if</code>.</p>
<p>La parte-else consiste de una suma, la llamada recursiva a <code>triangulo-recursivo</code> y una acción de decremento; y se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span> <span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero</span><span class="p">)))</span>
</code></pre>
<p>Cuando Emacs evalúa esta expresión, la expresión interna se evalua primero; luego las otras partes en secuencia. Aquí están los pasos en detalle:</p>
<dl>
<dt>Paso 1 Evalúar la expresión interna.</dt>
<dd>
<p>La expresión mas interna es <code>(1- numero)</code> por lo que Emacs decrementa el valor de <code>numero</code> de 2 a 1.</p>
</dd>
</dl>
<ul>
<li>
<p>Paso 2 Evalúar la función <code>triangulo-recursivo</code>.</p>
<p>El intérprete Lisp crea una instancia individual de <code>triangulo-recursivo</code>. No importa que esta función este contenida dentro de sí misma. Emacs pasa el resultado del Paso 1 como el argumento usado por esta instancia de la función <code>triangulo-recursivo</code></p>
<p>En este caso, Emacs evalúa <code>triangulo-recursivo</code> con un argumento de 1. Esto significa que esta evaluación de <code>triangulo-recursivo</code> devuelve 1.</p>
</li>
</ul>
<dl>
<dt>Paso 3 Evalúar el valor de <code>numero</code>.</dt>
<dd>
<p>La variable <code>numero</code> es el segundo elemento de la lista que empieza con <code>+</code>; su valor es 2.</p>
</dd>
<dt>Paso 4 Evalúar la expresión <code>+</code>.</dt>
<dd>
<p>La expresión <code>+</code> recibe dos argumentos, el primero viene de la evaluación del <code>numero</code> (Paso 3) y el segundo de la evaluación de <code>triangulo-recursivo</code> (Paso 2).</p>
<p>El resultado de la operacion es la suma de 2 + 1, y se devuelve el número 3, que es correcto. Un triángulo con dos filas tiene tres guijarros.</p>
</dd>
</dl>
</div>
<h5 id="un-argumento-de-3-o-4" >Un argumento de 3 o 4</h5>
<div class="hBody-5" >
<p>Supón que <code>triangulo-recursivo</code> se llama con un argumento de 3.</p>
<dl>
<dt>Paso 1 Evalúa la prueba-hazlo-de-nuevo.</dt>
<dd>
<p>La expresión <code>if</code> se evalúa primero. Esto es la prueba-hazlo-de-nuevo y devuelve falso, así que se evalua la parte-else de la expresión <code>if</code>. (Tenga en cuenta que en este ejemplo, la prueba-hazlo-de-nuevo hace que la función se llame a sí misma cuando la prueba es falsa, no cuando es verdadera.)</p>
</dd>
<dt>Paso 2 Evalúar la expresión mas profunda de la parte-else.</dt>
<dd>
<p>Se evalua la expresión mas interna de la parte-else, que decrementa 3 a 2. Esta la expresion-del-siguiente-paso.</p>
</dd>
<dt>Paso 3 Evalúar la función <code>triangulo-recursivo</code>.</dt>
<dd>
<p>El número 2 se pasa a la función <code>triangulo-recursivo</code>.</p>
<p>Nosotros ya sabemos lo que ocurre cuando Emacs evalúa <code>triangulo-recursivo</code> con un argumento de 2. Después de pasar a través de la secuencia de acciones descritas anteriormente, devuelve un valor de 3. Así que eso es lo que ocurrirá aquí.</p>
</dd>
<dt>Paso 4 Evalúar la suma.</dt>
<dd>
<p>3 será pasado como argumento a la suma y se sumara al número con el que se ha llamado a la función, que es 3.</p>
</dd>
</dl>
<p>El valor devuelto por la función en su conjunto será 6.</p>
<p>Ahora que sabemos qué ocurrirá cuando se llame a <code>triangulo-recursivo</code> con un argumento de 3, es evidente lo que ocurrirá si se llama con un argumento de 4:</p>
<div class="tab" >
<p>En la llamada recursiva, la evaluación de</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="p">(</span><span class="nf">1-</span> <span class="mi">4</span><span class="p">))</span>
</code></pre>
<p>devolvera el valor de evaluar</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>que es 6 y este valor se sumara a 4 mediante la suma en la tercera línea.</p>
</div>
<p>El valor devuelto por la función en su conjunto será 10.</p>
<p>Cada vez que se evalua <code>triangulo-recursivo</code>, se evalua una versión de sí mismo––una instancia diferente en sí––con un argumento mas pequeño, hasta que el argumento es lo suficientemente pequeño para que no se evalue a si mismo.</p>
<p>Ten en cuenta que este particular diseño de una función recursiva requiere que las operaciones sean diferidas.</p>
<p>Antes de que <code>(triangulo-recursivo 7)</code> pueda calcular su respuesta, debe llamar a <code>(triangulo-recursivo 6)</code>; y antes de que <code>(triangulo-recursivo 6)</code> pueda calcular su respuesta debe llamar a <code>(triangulo-recursivo 5)</code>; y así sucesivamente. Esto decir, el cálculo que hace <code>(triangulo-recursivo 7)</code> debe ser pospuesto hasta que <code>(triangulo-recursivo 6)</code> haga su cálculo; y <code>(triangulo-recursivo 6)</code> debe posponerse hasta que <code>(triangulo-recursivo 5)</code> se complete; y así sucesivamente.</p>
<p>Si se piensa que cada una de estas instancias de <code>triangulo-recursivo</code> son robots diferentes, el primer robot debe esperar al segundo para completar su trabajo, que debe esperar hasta que el tercero se complete, y así sucesivamente.</p>
<p>Hay un camino alrededor de este tipo de espera, que se discutirá en la Seccion <a href="#recursividad-sin-deferencias" >Recursividad sin deferencias</a>.</p>
</div>
<h4 id="ejemplo-de-recursión-usando-cond" >Ejemplo de recursión usando <code>cond</code></h4>
<div class="hBody-4" >
<p>La versión de <code>triangulo-recursivo</code> descrita anteriormente se escribió con la forma especial <code>if</code>. También se puede escribir usando otra forma especial llamada <code>cond</code>. El nombre de la forma especial <code>cond</code> es una abreviación de la palabra <samp>conditional</samp>.</p>
<p>Aunque la forma especial <code>cond</code> no se usa tan a menudo en las fuentes de Emacs como <code>if</code>, se usa con bastante frecuencia para justificar su explicacion.</p>
<p>La plantilla de una expresión <code>cond</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">cond</span>
 <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>donde el <code>cuerpo</code> es una serie de listas.</p>
<p>Escrito de forma más completa, la plantilla se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">cond</span>
 <span class="p">(</span><span class="nv">primera-prueba-verdadero-o-falso</span> <span class="nv">primera-consequencia</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">segunda-prueba-verdadero-o-falso</span> <span class="nv">segunda-consequencia</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">tercera-prueba-verdadero-o-falso</span> <span class="nv">tercera-consequencia</span><span class="p">)</span>
  <span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Cuando el intérprete Lisp evalúa la expresión <code>cond</code>, evalúa el primer elemento (el <code>car</code> o prueba-verdadero-o-falso) de la primer expresión en una serie de expresiones dentro del cuerpo del <code>cond</code>.</p>
<p>Si la prueba-verdadero-o-falso devuelve <code>nil</code> el resto de esa expresión se descarta y se evalua la prueba-verdadero-o-falso de la siguiente expresión. Cuando se encuentra una expresión cuya prueba-verdadero-o-falso devuelve un valor que no es <code>nil</code>, se evalua el resto de esa expresión. El resto puede ser una o más expresiones. Si el resto consiste de más de una expresión, las expresiones se evaluan en secuencia y se devuelve el valor de la última. Si la expresión no tiene un resto, se devuelve el valor de la prueba-verdadero-o-falso.</p>
<p>Si ninguna de las pruebas prueba-verdadero-o-falso es verdadera, la expresión <code>cond</code> devuelve <code>nil</code>.</p>
<p>Asi se ve la función <code>triangle</code>, usando <code>cond</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-usando-cond</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nf">&lt;=</span> <span class="nv">numero</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">=</span> <span class="nv">numero</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">&gt;</span> <span class="nv">numero</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span> <span class="p">(</span><span class="nv">triangulo-usando-cond</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero</span><span class="p">))))))</span>
</code></pre>
<p>En este ejemplo, el <code>cond</code> devuelve 0 si el número es menor o igual a 0, devuelve 1 si el número es 1 y evalúa <code>(+ numero (triangulo-usando-cond (1- numero)))</code> si el número es mayor a 1.</p>
</div>
<h4 id="patrones-recursivos" >Patrones recursivos</h4>
<div class="hBody-4" >
<p>Aquí hay tres patrones recursivos comunes. Cada uno implica una lista. La recursión no necesita involucrar listas, pero Lisp esta diseñado para listas y esto proporciona una idea de sus capacidades primarias.</p>
</div>
<h5 id="patrón-recursivo:-every" >Patrón recursivo: <em>every</em></h5>
<div class="hBody-5" >
<p>En el patrón recursivo <code>every</code>, se desarrolla una acción en cada elemento de una lista.</p>
<p>El patrón básico es:</p>
<ul>
<li>
<p>Si una lista esta vacía, devuelve <code>nil</code>.</p>
</li>
<li>
<p>Si no, actua al principio de la lista (el <code>car</code> de la lista)</p>
<ul>
<li>
<p>a través de una llamada recursiva por la función en el resto (el <code>cdr</code>) de la lista,</p>
</li>
<li>
<p>y, opcionalmente, combina el elemento sobre el que actúa, usando <code>cons</code>, con los resultados de actuar sobre el resto.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí está el ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">cuadrar-cada-uno</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;El cuadrado de cada LISTA DE NUMEROS, recursivamente.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">lista-de-numeros</span><span class="p">)</span>          <span class="c1">; prueba-hazlo-de-nuevo</span>
      <span class="no">nil</span>
    <span class="p">(</span><span class="nf">cons</span>
     <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-numeros</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-numeros</span><span class="p">))</span>
     <span class="p">(</span><span class="nv">cuadrar-cada-uno</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-numeros</span><span class="p">)))))</span> <span class="c1">; expresion-del-siguiente-paso</span>
</code></pre>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">cuadrar-cada-uno</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span><span class="out" >(1 4 9)
</span></code></pre>
<p>Si <code>lista-de-numeros</code> está vacía, no hay que hacer nada. Pero si tiene contenido, se construye una lista combinando el cuadrado del primer número en la lista con el resultado de la llamada recursiva.</p>
<p>(El ejemplo sigue el patrón exactamente: se devuelve <code>nil</code> si la lista de números es vacía. En la práctica, se escribiría el condicional, para que lleve a cabo la acción cuando la lista de números no es vacía.)</p>
<p>La función <code>imprimir-elementos-recursivamente</code> (Ver Sección <a href="#recursividad-con-una-lista" >Recursividad con una Lista</a>) es otro ejemplo de un patrón <code>every</code>, excepto en este caso, en vez de juntar los resultados usando <code>cons</code>, se imprime cada elemento de salida.</p>
<p>La función <code>imprimir-elementos-recursivamente</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-elementos-recursivamente</span> <span class="p">(</span><span class="nv">lista</span><span class="p">)</span>
  <span class="s">&#34;Imprime cada elemento de LISTA en una línea propia.
</span><span class="s">Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nv">lista</span>                               <span class="c1">; prueba-hazlo-de-nuevo</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista</span><span class="p">))</span>                 <span class="c1">; cuerpo</span>
        <span class="p">(</span><span class="nv">imprimir-elementos-recursivamente</span>  <span class="c1">; llamada recursiva</span>
         <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista</span><span class="p">))))</span>                     <span class="c1">; expresion-del-siguiente-paso</span>

<span class="p">(</span><span class="nv">imprimir-elementos-recursivamente</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>El patrón para <code>imprimir-elementos-recursivamente</code> es:</p>
<ul>
<li>
<p>Cuando la lista está vacía, no hacer nada.</p>
</li>
<li>
<p>Pero cuando la lista tiene al menos un elemento,</p>
<ul>
<li>
<p>actúa al principio de la lista (el <code>car</code> de la lista),</p>
</li>
<li>
<p>y hacer una llamada recursiva en el resto (el <code>cdr</code> de la lista).</p>
</li>
</ul>
</li>
</ul>
</div>
<h5 id="patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></h5>
<div class="hBody-5" >
<p>Otro patrón recursivo se llama patrón <code>accumulate</code>. En el patrón recursivo <code>accumulate</code>, se realiza una acción en cada elemento de una lista y el resultado de esta acción se acumula con los resultados de realizar la acción en los otros elementos.</p>
<p>Esto es muy parecido al patron ‘every’ usando <code>cons</code>, excepto que este <code>cons</code> no se utiliza, pero se usa algun otro combinador.</p>
<p>El patrón es:</p>
<ul>
<li>
<p>Si una lista está vacía, devuelve cero u otra constante.</p>
</li>
<li>
<p>De lo contrario, actúa al principio de la lista (el <code>car</code> de la lista),</p>
<ul>
<li>
<p>y combina ese elemento actual, utilizando <code>+</code> o alguna otra función de combinación, con</p>
</li>
<li>
<p>una llamada recursiva a la función con el resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí hay un ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">sumar-elementos</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;Suma los elementos de LISTA-DE-NUMEROS.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">lista-de-numeros</span><span class="p">)</span>
      <span class="mi">0</span>
    <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-numeros</span><span class="p">)</span> <span class="p">(</span><span class="nv">sumar-elementos</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-numeros</span><span class="p">)))))</span>
</code></pre>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">sumar-elementos</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="out" >10
</span></code></pre>
<p>Consulta la Seccion <a href="#creando-una-lista-de-ficheros" >Creando una lista de ficheros</a>, para un ejemplo del patrón accumulate.</p>
</div>
<h5 id="patrón-recursivo:-keep" >Patrón recursivo: <em>keep</em></h5>
<div class="hBody-5" >
<p>Un tercer patrón se llama el patrón <code>keep</code>. En el patrón recursivo <code>keep</code>, se comprueba cada elemento de una lista; se actúa sobre el elemento y los resultados solo se conservan si el elemento cumple un criterio.</p>
<p>De nuevo, esto es muy parecido al patrón ‘every’, excepto que el elemento se descarta a menos que cumpla un criterio.</p>
<p>El patrón tiene tres partes:</p>
<ul>
<li>
<p>Si una lista esta vacía, devuelve <code>nil</code>.</p>
</li>
<li>
<p>De lo contrario, si el inicio de la lista (el <code>car</code>) pasa una prueba</p>
<ul>
<li>
<p>actuar sobre ese elemento y combinarlo, utilizando <code>cons</code> con</p>
</li>
<li>
<p>una llamada recursiva a la función con el resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
<li>
<p>De lo contrario, si el inicio de la lista (el <code>car</code>) falla la prueba</p>
<ul>
<li>
<p>saltar ese elemento,</p>
</li>
<li>
<p>y, recursivamente llamar a la función sobre el resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí hay un ejemplo que usa <code>cond</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">guardar-palabras-de-tres-letras</span> <span class="p">(</span><span class="nv">lista-palabras</span><span class="p">)</span>
  <span class="s">&#34;De la LISTA-PALABRAS, guarda las palabras de 3 letras.&#34;</span>
  <span class="p">(</span><span class="nb">cond</span>
   <span class="c1">;; Primera prueba-hazlo-de-nuevo: condicion-de-parada</span>
   <span class="p">((</span><span class="nv">not</span> <span class="nv">lista-palabras</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>

   <span class="c1">;; Segunda prueba-hazlo-de-nuevo: cuando actuar</span>
   <span class="p">((</span><span class="nf">eq</span> <span class="mi">3</span> <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">symbol-name</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-palabras</span><span class="p">))))</span>
    <span class="c1">;; combina el elemento actual con la llamada recursiva en</span>
    <span class="c1">;; una lista mas corta</span>
    <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-palabras</span><span class="p">)</span> <span class="p">(</span><span class="nv">guardar-palabras-de-tres-letras</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-palabras</span><span class="p">))))</span>

   <span class="c1">;; Tercera prueba-hazlo-de-nuevo: cuando saltar el elemento;</span>
   <span class="c1">;; llamada recursiva con una lista mas corta con la</span>
   <span class="c1">;; expresion-del-siguiente-paso</span>
   <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">guardar-palabras-de-tres-letras</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-palabras</span><span class="p">)))))</span>
</code></pre>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">guardar-palabras-de-tres-letras</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">uno</span> <span class="nv">dos</span> <span class="nv">tres</span> <span class="nv">cuatro</span> <span class="nv">cinco</span> <span class="nv">seis</span><span class="p">))</span>
</span><span class="out" >(uno dos)
</span></code></pre>
<p>No hace falta decir que no es necesario utilizar <code>nil</code> como la prueba para detenerse; y, por su puesto, se pueden combinar estos patrones.</p>
</div>
<h4 id="recursividad-sin-deferencias" >Recursividad sin deferencias</h4>
<div class="hBody-4" >
<p>Consideremos de nuevo lo que sucede con la función <code>triangulo-recursivo</code>. Encontraremos que los cálculos intermedios se postergan hasta que se puede hacer todo.</p>
<p>Aquí está la definición de función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-recursivo</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.
</span><span class="s">Usa recursion.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">numero</span> <span class="mi">1</span><span class="p">)</span>                    <span class="c1">; prueba-hazlo-de-nuevo</span>
      <span class="mi">1</span>                               <span class="c1">; parte-then</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span>                         <span class="c1">; parte-else</span>
       <span class="p">(</span><span class="nv">triangulo-recursivo</span>           <span class="c1">; llamada recursiva</span>
        <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero</span><span class="p">)))))</span>               <span class="c1">; expresion-del-siguiente-paso</span>
</code></pre>
<p>¿Qué ocurre cuando llamamos a esta función con un argumento de 7?</p>
<p>La primera instancia de la función <code>triangulo-recursivo</code> suma el número 7 al valor devuelto por una segunda instancia de <code>triangulo-recursivo</code>, una instancia a la que se ha pasado un argumento de 6. Es decir, el primer cálculo es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="mi">6</span><span class="p">))</span>
</code></pre>
<p>La primera instancia de <code>triangulo-recursivo</code>––tal vez quieres pensar en ella como un pequeño robot––no puede completar su trabajo. Debe pasar el cálculo a <code>(triangulo-recursivo 6)</code> una segunda instancia del programa, a un segundo robot. Este segundo individuo es completamente diferente del primero; en la jerga, una ‘diferente instancia’. O, dicho de otro modo, es un robot diferente. Es del mismo modelo que el primero; calcula números de triángulo recursivamente; pero tiene un número de serie diferente.</p>
<p>¿Y qué devuelve <code>(triangulo-recursivo 6)</code>? Devuelve el número 6 sumado al valor devuelto de evaluar <code>triangulo-recursivo</code> con un argumento de 5. Usando la metáfora del robot, le pide a otro robot que lo ayude.</p>
<p>Ahora el total es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="mi">6</span> <span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>¿Y qué sucede después?</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="p">(</span><span class="nv">triangulo-recursivo</span> <span class="mi">4</span><span class="p">))</span>
</code></pre>
<p>Cada vez que se llama a <code>triangulo-recursivo</code>, excepto por la última vez, se crea otra instancia del programa––otro robot––y le pide que haga un cálculo.</p>
<p>Eventualmente, se establece y realiza la suma completa:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>Este diseño de la función difiere el cálculo del primer paso hasta que se puede hacer el segundo, y difiere este hasta que se puede hacer el tercero, y así sucesivamente. Cada aplazamiento significa el ordenador debe recordar que se está esperado. Esto no es un problema cuando solo hay unos pocos pasos, como en este ejemplo. Pero puede ser un problema cuando hay más pasos.</p>
</div>
<h4 id="solucion-sin-deferencia" >Solucion sin Deferencia</h4>
<div class="hBody-4" >
<p>La solución al problema de deferir operaciones es escribir de una manera que no se pospongan las operaciones<span class="note" ><sup><a href="#12" >12</a></sup></span>. Esto requiere escribir en un patrón diferente, con frecuencia uno que implica escribir dos definiciones de función, una función de ‘inicialización’ y una función ‘auxiliar’.</p>
<p>La función de ‘inicializacion’ configura el trabajo; la función ‘auxiliar’ hace el trabajo.</p>
<p>Aquí estan las dos definiciones de funcion para sumar números. Son tan simples, que me cuesta entenderlas.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-inicializacion</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma de números desde el 1 hasta e incluyendo a NUMERO.
</span><span class="s">Este es el componente de ‘inicialización’ de una función doble
</span><span class="s">que utiliza recursión&#34;</span>
  <span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span> <span class="mi">0</span> <span class="mi">0</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-recursivo-auxiliar</span> <span class="p">(</span><span class="nv">suma</span> <span class="nv">contador</span> <span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la SUMA, usando CONTADOR, hasta e incluyendo NUMERO.
</span><span class="s">Este es el componente ‘auxiliar’ de una funcion doble que
</span><span class="s">utiliza recursión.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">contador</span> <span class="nv">numero</span><span class="p">)</span>
      <span class="nv">suma</span>
    <span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">suma</span> <span class="nv">contador</span><span class="p">)</span>  <span class="c1">; suma</span>
                                  <span class="p">(</span><span class="nf">1+</span> <span class="nv">contador</span><span class="p">)</span>      <span class="c1">; contador</span>
                                  <span class="nv">numero</span><span class="p">)))</span>          <span class="c1">; número</span>
</code></pre>
<p>Instala ambas definiciones de función evaluandolas, luego llama a <code>triangulo-inicializacion</code> con 2 filas:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">triangulo-inicializacion</span> <span class="mi">2</span><span class="p">)</span>
</span><span class="out" >3
</span></code></pre>
<p>La función de ‘inicialización’ llama a la primera instancia de la función ‘auxiliar’ con tres argumentos: cero, cero, y un número que es el número de filas en el triángulo.</p>
<p>Los dos primeros argumentos que se pasan a la función ‘auxiliar’ son valores de inicialización. Estos valores cambian cuando <code>triangulo-recursivo-auxiliar</code> invoca nuevas instancias.<span class="note" ><sup><a href="#13" >13</a></sup></span></p>
<p>Veamos que pasa cuando tenemos un triángulo que tiene una fila. (¡Este triángulo tendrá un guijarro en el!)</p>
<p><code>triangulo-inicializacion</code> llamará a su auxiliar con los argumentos <code>0 0 1</code>. Esta función ejecutará la prueba condicional si <code>(&gt; contador numero)</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>y encontrara que el resultado es falso, por lo que  invocara la parte-else de la clausula <code>if</code>:</p>
<pre class="code" ><code class="chroma" >    <span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span>
     <span class="p">(</span><span class="nf">+</span> <span class="nv">suma</span> <span class="nv">contador</span><span class="p">)</span>  <span class="c1">; suma más contador ⇒ suma</span>
     <span class="p">(</span><span class="nf">1+</span> <span class="nv">contador</span><span class="p">)</span>      <span class="c1">; incrementa contador ⇒ contador</span>
     <span class="nv">numero</span><span class="p">)</span>            <span class="c1">; numero se mentiene igual</span>
</code></pre>
<p>que al inicio calcula:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">; suma</span>
                              <span class="p">(</span><span class="nf">1+</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">; contador</span>
                              <span class="mi">1</span><span class="p">)</span>       <span class="c1">; numero</span>
</code></pre>
<p>que es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>Una vez mas, <code>(&gt; contador numero)</code> será falso, por lo que de nuevo, el intérprete Lisp evaluará <code>triangulo-recursivo-auxiliar</code>, creando una nueva instancia con nuevos argumentos.</p>
<p>Esta nueva instancia será;</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span>
 <span class="p">(</span><span class="nf">+</span> <span class="nv">suma</span> <span class="nv">contador</span><span class="p">)</span>  <span class="c1">; suma más contador ⇒ suma</span>
 <span class="p">(</span><span class="nf">1+</span> <span class="nv">contador</span><span class="p">)</span>      <span class="c1">; incrementa contador ⇒ contador</span>
<span class="nv">numero</span><span class="p">)</span>             <span class="c1">; numero se mentiene igual</span>
</code></pre>
<p>que es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo-auxiliar</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>En este caso, la prueba <code>(&gt; contador numero)</code> ¡será verdadera!  Así que la instancia devolverá el valor de la suma, que es 1, como se esperaba.</p>
<p>Ahora, vamos a pasar a <code>triangulo-inicializacion</code> un argumento de 2, para encontrar cuántos guijarros hay en un triángulo con dos filas.</p>
<p>Esta función se llamaria <code>(triangulo-recursivo-auxiliar 0 0 2)</code>.</p>
<p>En etapas, las instancias llamadas serán:</p>
<div class="example-block" >
<pre class="example" >                            suma contador número
(triangulo-recursivo-auxiliar 0    1       2)

(triangulo-recursivo-auxiliar 1    2       2)

(triangulo-recursivo-auxiliar 3    3       2)
</pre>
</div>
<p>Cuando se llama a la última instancia, la prueba <code>(&gt; contador numero)</code> será verdadera, por lo que la instancia devolverá el valor de <code>suma</code>, que será 3.</p>
<p>Este tipo de patrón ayuda cuando estás escribiendo funciones que pueden usar muchos recursos en un ordenador.</p>
</div>
<h3 id="ejercicio-de-bucles" >Ejercicio de bucles</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función similar a <code>triangulo</code> en la que cada fila tiene un valor que es el cuadrado del número de la fila. Usa un bucle <code>while</code>.</p>
</li>
<li>
<p>Escribe una función similar a <code>triangulo</code> que multiplique en lugar de sumar los valores.</p>
</li>
<li>
<p>Reescribe estas dos funciones recursivamente. Reescribe estas funciones usando <code>cond</code>.</p>
</li>
<li>
<p>Escribe una función para el modo Texinfo que crea una entrada índice al principio de un párrafo para cada <samp>@dfn</samp> dentro del mismo. (En un fichero Texinfo, <samp>@dfn</samp> marca una definición.)</p>
<p>Muchas de las funciones que necesitaras se describen en los dos capitulos anteriores, Secciones <a href="#corte-y-almacenamiento-de-texto" >Corte y Almacenamiento de Texto</a> y <a href="#pegando-texto" >Pegando texto</a>. Si usas <code>forward-paragraph</code> para poner la entrada de índice al principio del párrafo, tendrás que usar <kbd>C-h f</kbd> (<code>describe-function</code>) para averiguar como hacer que el comando vaya hacia atrás.</p>
</li>
</ul>
<p>Para obtener más información, consulta la Seccion <a href="info:texinfo#Indicating" >Indicando Definiciones, Comandos, etc.</a>  en el <em>Manual de Texinfo</em> dentro de Emacs. O, tambien puedes consultarlo en internet en <a href="http://www.gnu.org/software/texinfo/manual/texinfo/" >http://www.gnu.org/software/texinfo/manual/texinfo/</a></p>
</div>
<h2 id="búsqueda-de-expresiones-regulares" >Búsqueda de expresiones regulares</h2>
<div class="hBody-2" >
<p>Las búsquedas de expresiones regulares se utilizan extensivamente en GNU Emacs. Las dos funciones <code>forward-sentence</code> y <code>forward-paragraph</code>, ilustran bien estas búsquedas. Usan expresiones regulares para encontrar donde mover el punto. La frase ‘expresión regular’ se escribe con frecuencia como ‘regexp’.</p>
<p>Las búsquedas de expresiones regulares se describen en la Seccion <a href="info:emacs#Regexp-Search" >Búsqueda de Expresiónes Regulares</a> en <em>El Manual de GNU Emacs</em>, asi como en la Seccion <a href="info:elisp#Regular-Expressions" >Expresiones Regulares</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>. Al escribir este capítulo, estoy suponiendo que tienes al menos un leve conocimiento de esto. El punto principal a recordar es que que las expresiones regulares te permiten buscar patrones, asi como cadenas literales de caracteres. Por ejemplo, el código en <code>forward-sentence</code> busca el patrón de posibles caracteres que podrían marcar el final de una oracion, y mueve el punto a ese lugar.</p>
<p>Antes de mirar el código de la función <code>forward-sentence</code>, vale la pena considerar cual debe ser el patrón que marca el final de una oracion. El patrón se discute en la siguiente sección; a continuacion se describe la funcion de busqueda de expresiónes regulares, <code>re-search-forward</code>. La función <code>forward-sentence</code> se describe en la sección siguiente. Finalmente, la función <code>forward-paragraph</code> se describe en la última sección de este capítulo. <code>forward-paragraph</code> es una función compleja que introduce varias caracteristicas nuevas.</p>
</div>
<h3 id="la-expresión-regular-de-sentence-end" >La expresión regular de <code>sentence-end</code></h3>
<div class="hBody-3" >
<p>El símbolo <code>sentence-end</code> esta ligado al patrón que marca el fin de una oracion. ¿Cuál deberia ser esta expresión regular?</p>
<p>Claramente, una oracion puede terminarse por un punto, una signo de interrogación, o un signo de exclamación. De hecho, en inglés, solo las oraciones que terminan con uno de estos tres caracteres deberían considerse como el final de una oracion. Esto significa que el patrón debe incluir el conjunto de caracteres:</p>
<div class="example-block" >
<pre class="example" >[.?!]
</pre>
</div>
<p>Sin embargo, no queremos que <code>forward-sentence</code> salte simplemente a un punto, a un signo de interrogacion o a un signo de exclamación, porque tal carácter podría utilizarse en medio de una oracion. Un punto, por ejemplo, se usa después de abreviaturas. Así, que se necesita otra información.</p>
<p>Segun la convención, escribes dos espacios despues de cada oracion, pero solo un espacio después de un punto, un signo de interrogacion o un signo de exclamación en el cuerpo de una oracion. Asi que un punto, un signo de interrogacion o de exclamacion seguido por dos espacios es un buen indicador de un final de oracion. Sin embargo, en un archivo, los dos espacios pueden ser un tabulador o el fin de una línea. Esto significa que la expresión regular incluiría estos tres elementos como alternativas.</p>
<p>Este grupo de alternativas se vera asi:</p>
<div class="example-block" >
<pre class="example" >\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
</pre>
</div>
<p>Aquí, <samp>$</samp> indica el fin de la línea, ademas he señalado en la expresión donde se inserta el tabulador y los dos espacios. Ambos se insertan poniendo los caracteres reales en la expresión.</p>
<p>Antes de los parentesis y las barras verticales, se requiere dos barras invertidas <samp>\\</samp>: la primera barra invertida cita la siguiente barra invertida en Emacs; y la segunda indica que el siguiente caracter, el paréntesis o la barra vertical, es especial.</p>
<p>También, una oracion puede ser seguida por uno o más retornos de carro, como aqui:</p>
<div class="example-block" >
<pre class="example" >[
]*
</pre>
</div>
<p>Al igual que los tabuladores y espacios, un retorno de carro se inserta en una expresión regular insertándolo literalmente. El asterisco indica que el <kbd>RET</kbd> se repite cero o más veces.</p>
<p>Pero una oracion no consiste solo en un punto, o un signo de interrogacion o de exclamación seguido de un espacio apropiado: una cita de cierre o una llave de cierre  de algún tipo puede preceder al espacio. De hecho, más de una marca o paréntesis pueden preceder el espacio. Estas requieren una expresión parecida a esta:</p>
<div class="example-block" >
<pre class="example" >[]\&#34;&#39;)}]*
</pre>
</div>
<p>En esta expresión, el primer <samp>]</samp> es el primer caracter en la expresión; el segundo caracter es <samp>&#34;</samp>, que está precedido por un <samp>\</samp> para decirle a Emacs que el <samp>&#34;</samp> <em>no</em> es especial. Los últimos tres caracteres son <samp>&#39;</samp>, <samp>)</samp>, y <samp>}</samp>.</p>
<p>Todo esto sugiere cual deberia ser el patrón de la expresión regular para que coincida con el final de una oracion; y, de hecho, si evaluamos <code>sentence-end</code> encontraremos que devuelve el siguiente valor:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">sentence-end</span>
</span><span class="out" >&#34;[.?!][]\&#34;&#39;)}]*\\($\\|     \\|  \\)[
]*&#34;
</span></code></pre>
<p>(Bieno, no en GNU Emacs 22; eso se debe a un esfuerzo por hacer el proceso simple y manejar más símbolos y lenguajes. Cuando el valor de <code>sentence-end</code> es <code>nil</code>, entonces utiliza el valor definido por la función <code>sentence-end</code>. (Aquí se utiliza la diferencia entre un valor y una función en Emacs Lisp.) La función devuelve un valor construido a partir de las variables <code>sentence-end-base</code>, <code>sentence-end-double-space</code>, <code>sentence-end-without-period</code>, y <code>sentence-end-without-space</code>. La variable crítica es <code>sentence-end-base</code>; su valor global es similar al descrito anteriormente, pero también contiene dos marcas de cita adicionales. Estas tienen diferentes grados de curvatura. La variable <code>sentence-end-without-period</code>, cuando es verdad, le dice a Emacs que una oracion puede finalizar sin un punto, como en texto en Tailandés.)</p>
</div>
<h3 id="la-función-re-search-forward" >La Función <code>re-search-forward</code></h3>
<div class="hBody-3" >
<p>La función <code>re-search-forward</code> es similar a la función <code>search-forward</code>. (Vea la Seccion <a href="#la-función-search-forward" >La Función <code>search-forward</code></a>.)</p>
<p><code>re-search-forward</code> busca una expresión regular. Si la búsqueda es exitosa, deja el punto inmediatamente después del último caracter en el objetivo. Si la búsqueda es hacia atrás, deja el punto antes del primer caracter en el objetivo. Puede decirle a <code>re-search-forward</code> que regrese <code>t</code> por verdadero. (El movimiento del punto es por la tanto un ‘efecto secundario’.)</p>
<p>Al igual que <code>search-forward</code>, la función <code>re-search-forward</code> toma cuatro argumentos:</p>
<ol class="num" >
<li>
<p>El primer argumento es la expresión regular que busca la función. La expresión regular será una cadena entre comillas.</p>
</li>
<li>
<p>El segundo argumento opcional limita el grado de busqueda de la función; es un valor ligado con una posición especifica en el búfer.</p>
</li>
<li>
<p>El tercer argumento opcional especifica cómo la función responde al fallo: <code>nil</code> como tercer argumento hace que la función señale un error (e imprima un mensaje) cuando la búsqueda falla; cualquier otro valor hace que se devuelva <code>nil</code> si la búsqueda falla y <code>t</code> si la búsqueda tiene éxito.</p>
</li>
<li>
<p>El cuarto argumento opcional es el contador de repeticiones. Un conteo negativo hace que <code>re-search-forward</code> busque hacia atrás.</p>
</li>
</ol>
<p>La plantilla para <code>re-search-forward</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;expresion-regular&#34;</span>
                   <span class="nv">limite-de-busqueda</span>
                   <span class="nv">que-hacer-si-falla-la-busqueda</span>
                   <span class="nv">contador-de-repeticiones</span><span class="p">)</span>
</code></pre>
<p>El segundo, tercer, y cuarto argumentos son opcionales. Sin embargo, si se quiere pasar un valor a uno o ambos de los últimos dos argumentos, se debe también pasar un valor a todos los argumentos precedentes. De otro modo, el intérprete Lisp confundira el argumento al que estás pasando el valor.</p>
<p>En la función <code>forward-sentence</code>, la expresión regular será el valor de la variable <code>sentence-end</code>. En forma simple, esto es:</p>
<div class="example-block" >
<pre class="example" >&#34;[.?!][]\&#34;&#39;)}]*\\($\\|  \\|  \\)[
]*&#34;
</pre>
</div>
<p>El límite de la búsqueda será el fin del párrafo (ya que una oracion no puede ir mas alla de un párrafo). Si la búsqueda falla, la función devuelve <code>nil</code>, y el argumento del contador de repeticion será pasado a la función <code>forward-sentence</code>.</p>
</div>
<h3 id="la-función-forward-sentence" >La Función <code>forward-sentence</code></h3>
<div class="hBody-3" >
<p>El comando para mover el cursor hacia adelante de una oracion es una ilustración directa de cómo usar búsqueda de expresiones regulares en Emacs Lisp. De hecho, la función parece más larga y más complicada de lo que es; esto se debe a que la función está diseñada para ir hacia atrás y hacia adelante; y, opcionalmente, mas de una oracion. La función normalmente está asociada al comando <kbd>M-e</kbd>.</p>
<p>Aquí está la código de <code>forward-sentence</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">forward-sentence</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;Avansa al siguiente ‘sentence-end’. Con un argumento, se repite.
</span><span class="s">Con un argumento negativo, avanza hacia atras repetidamente al ‘sentence-beginning’.
</span><span class="s">
</span><span class="s">La variable ‘sentence-end’ es una expresión regular que corresponde a el
</span><span class="s">fin de las oraciones. Ademas, cada limite de párrafo tambien termina oraciones.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">opoint</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">sentence-end</span> <span class="p">(</span><span class="nv">sentence-end</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">pos</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">par-beg</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">start-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
       <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">re-search-backward</span> <span class="nv">sentence-end</span> <span class="nv">par-beg</span> <span class="no">t</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">match-end</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">pos</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">re-search-backward</span> <span class="nv">sentence-end</span> <span class="nv">par-beg</span> <span class="no">t</span><span class="p">)))</span>
           <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">match-end</span> <span class="mi">0</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">par-beg</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">arg</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">par-end</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
       <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sentence-end</span> <span class="nv">par-end</span> <span class="no">t</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">skip-chars-backward</span> <span class="s">&#34; \t\n&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">par-end</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">constrain-to-field</span> <span class="no">nil</span> <span class="nv">opoint</span> <span class="no">t</span><span class="p">)))</span>
</code></pre>
<p>La función parece larga a primera vista y es mejor mirar primero su esqueleto, y luego su músculo. La forma de ver el esqueleto es mirar las expresiones que comienzan en las columnas de la izquierda:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">forward-sentence</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">opoint</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span> <span class="p">(</span><span class="nv">sentence-end</span> <span class="p">(</span><span class="nv">sentence-end</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">pos</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">par-beg</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">start-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
       <span class="nv">resto-del-cuerpo-del-bucle-while-cuando-va-hacia-atras</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">par-end</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
       <span class="nv">resto-del-cuerpo-del-bucle-while-cuando-va-hacia-adelante</span>
    <span class="nv">manejar-formularios-y-equivalentes</span>
</code></pre>
<p>¡Esto parece mucho mas simple! La definición de la función consiste en la documentación, una expresión <code>interactive</code>, una expresión <code>or</code>, una expresión <code>let</code>, y bucles <code>while</code>.</p>
<p>Veamos cada una de estas partes por separado.</p>
<p>Observamos que la documentación es completa y comprensible.</p>
<p>La función tiene una declaración <code>interactive &#34;p&#34;</code>. Esto signifca que el argumento prefijo procesado, si lo hay, pasa a la función como su argumento. (Este será un número.) Si no se pasa un argumento a la función (es opcional) entonces el argumento <code>arg</code> será vinculara a 1.</p>
<p>Cuando <code>forward-sentence</code> se llama no interactivamente sin un argumento, <code>arg</code> está vinculado a <code>nil</code>. La expresión <code>or</code> maneja esto. Lo que hace es dejar el valor de <code>arg</code> como esta, pero solo si <code>arg</code> está ligado a un valor; de otro modo asigna el valor de <code>arg</code> a 1, en el caso de <code>arg</code> está ligado a <code>nil</code>.</p>
<p>Lo siguiente es un <code>let</code>. Especifica los valores de dos variables locales <code>point</code> y <code>sentence-end</code>. El valor local de punto, desde antes de la búsqueda, se utiliza en la función <code>constrain-to-field</code> que maneja formularios y equivalentes. La variable <code>sentence-end</code> se establece por la función <code>sentence-end</code>.</p>
</div>
<h4 id="los-bucles-while" >Los bucles <code>while</code></h4>
<div class="hBody-4" >
<p>Siguen dos bucles <code>while</code>. El primer <code>while</code> tiene una prueba-verdadero-o-falso que es verdadero si el argumento prefijo de <code>forward-sentence</code> es un número negativo. Esto es para retroceder. El cuerpo de este bucle es similar al cuerpo del segundo <code>while</code>, pero no es exactamente el mismo. Pasaremos de este bucle <code>while</code> y nos centraremos en el segundo <code>while</code>.</p>
<p>El segundo bucle <code>while</code> es para mover el punto hacia adelante. Su esqueleto se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>            <span class="c1">; prueba-verdadero-o-falso</span>
  <span class="p">(</span><span class="nb">let</span> <span class="nv">varlist</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">prueba-verdadero-o-falso</span><span class="p">)</span>
        <span class="nv">parte-then</span>
      <span class="nv">parte-else</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">))))</span>     <span class="c1">; decremento del bucle while</span>
</code></pre>
<p>El bucle <code>while</code> es de tipo decreciente. (Vea la Seccion <a href="#bucle-con-contador-decreciente" >Bucle con contador decreciente</a>.) Tiene una prueba-verdadero-o-falso que regresa verdadero siempre y cuando el contador (en este caso, la variable <code>arg</code>) sea mayor que cero; y tiene un decremento que resta 1 del valor del contador cada vez que el bucle se repite.</p>
<p>Si no se da un argumento prefijo a <code>forward-sentece</code>, que es lo mas habitual, este bucle <code>while</code> se ejecutará una vez, ya que el valor de <code>arg</code> será 1.</p>
<p>El cuerpo del cuerpo <code>while</code> consite en una expresión <code>let</code>, que crea y vincula una variable local, y tiene, como su cuerpo, una expresión <code>if</code>.</p>
<p>El cuerpo del bucle <code>while</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">par-end</span>
       <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sentence-end</span> <span class="nv">par-end</span> <span class="no">t</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">skip-chars-backward</span> <span class="s">&#34; \t\n&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">par-end</span><span class="p">)))</span>
</code></pre>
<p>La expresión <code>let</code> crea y liga la variable local <code>par-end</code>. Como veremos, esta variable local está diseñada para proporcionar un limite a la búsqueda de la expresiónes regulares. Si la búsqueda falla no encuentra una oracion apropiada que termine en el párrafo, se detendra al llegar al final del párrafo.</p>
<p>Pero primero, examinaremos cómo <code>par-end</code> se liga al valor del fin del párrafo. Lo que ocurre es que el <code>let</code> asigna el valor de <code>par-end</code> al valor devuelto cuando el intérprete evalúa la expresión.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
</code></pre>
<p>En esta expresión, <code>(end-of-paragraph-text)</code> mueve el punto al fin del párrafo, <code>(point)</code> devuelve el valor del punto, y luego <code>save-excursion</code> restaura el punto a su posición original. De este modo, el <code>let</code> liga <code>par-end</code> al valor devuelto por la expresión <code>save-excursion</code>, que es la posición del fin del párrafo.  (La función <code>end-of-paragraph-text</code> utiliza <code>forward-paragraph</code>, que discutiremos en breve.)</p>
<p>A continuacion Emacs evalúa el cuerpo del <code>let</code>, que es una expresión <code>if</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sentence-end</span> <span class="nv">par-end</span> <span class="no">t</span><span class="p">)</span> <span class="c1">; parte-if</span>
    <span class="p">(</span><span class="nf">skip-chars-backward</span> <span class="s">&#34; \t\n&#34;</span><span class="p">)</span>              <span class="c1">; parte-then</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">par-end</span><span class="p">)))</span>                        <span class="c1">; parte-else</span>
</code></pre>
<p>El <code>if</code> comprueba si su primer argumento es verdadero y es así, evalúa su parte then; de lo contrario, el intérprete Emacs Lisp evalúa la parte else. La prueba-verdadero-o-falso de la expresión <code>if</code> es la búsqueda de la expresión regular.</p>
<p>Puede parecer extraño tener lo que parece ser ‘trabajo real’ de la función <code>forward-sentence</code> enterrado aqui, pero esta es una forma común de realizar este tipo de operaciónes en Lisp.</p>
</div>
<h4 id="la-búsqueda-de-expresiones-regulares" >La búsqueda de expresiones regulares</h4>
<div class="hBody-4" >
<p>La función <code>re-search-forward</code> busca el fin de la oracion, es decir, el patrón definido por la expresión regular <code>sentence-end</code>. Si el patrón es encontrado––si se encuentra el fin de la oracion––entonces la función <code>re-search-forward</code> hace dos cosas:</p>
<ol class="num" >
<li>
<p>La función <code>re-search-forward</code> realiza un efecto secundario, que es mover el punto al final de la ocurrencia encontrada.</p>
</li>
<li>
<p>La función <code>re-search-forward</code> devuelve un valor verdadero. Este es el valor recibido por el <code>if</code>, y significa que la búsqueda fué exitosa.</p>
</li>
</ol>
<p>El efecto secundario, el movimiento del punto se completa antes de que la función <code>if</code> reciva el valor devuelto por la conclusión exitosa de la búsqueda.</p>
<p>Cuando la función <code>if</code> recibe el valor verdadero desde una llamada exitosa a <code>re-search-forward</code>, el <code>if</code> evalúa la parte-then que es la expresión <code>(skip-chars-backward &#34;\t\n&#34;)</code>. Esta expresión se mueve hacia atrás a través de cualquier espacio en blanco, tabulador o retorno de carro hasta encontrar un caracter imprimible y deja el punto después del caracter. Como el punto ya se ha movido al final del patron que marca el final de la oracion, esta accion deja el punto justo despues del caracter imprimible de cierre de la oracion, que suele ser un punto.</p>
<p>Por otro lado, si la función <code>re-search-forward</code> no encuentra un patrón que marque el fin de la oracion, la función devuelve falso. El falso provoca que <code>if</code> evalue su tercer argumento, que es <code>(goto-char par-end)</code>: esto mueve el punto al final del párrafo.</p>
<p>(Y si el texto está en una forma o equivalente, y el punto puede que no se mueva completamente, entonces entra en juego la función <code>constrain-to-field</code>.)</p>
<p>La búsqueda de expresiones regulares son excepcionalmente útiles y el patrón ilustrado por <code>re-search-forward</code>, en el que la búsqueda es la prueba de una expresión <code>if</code>, es facil de manejar. Veras o escribirás código incorporando este patrón con frecuencia.</p>
</div>
<h3 id="forward-paragraph:-una-mina-de-oro-de-funciones" ><code>forward-paragraph</code>: una mina de oro de funciones</h3>
<div class="hBody-3" >
<p>La función <code>forward-paragraph</code> mueve el punto al fin del párrafo. Por lo general esta asociado a <kbd>M-}</kbd> y hace uso de un número de funciones que son importantes en sí mismas, incluyendo <code>let*</code>, <code>match-beginning</code>, y <code>looking-at</code>.</p>
<p>La definición de función de <code>forward-paragraph</code> es considerablemente mas extensa que la definición de función de <code>forward-sentence</code> porque trabaja con un párrafo, cada línea de la cual puede empezar con un prefijo de relleno.</p>
<p>Un prefijo de relleno consiste en una cadena de caracteres que se repite al principio de cada línea. Por ejemplo, en el código Lisp, es una convención empezar cada línea de un comentario de un párrafo extenso con <samp>;;; </samp>. En el modo Texto, cuatro espacios en blanco forman otro prefijo común de relleno, creando un párrafo indentado. (Véa la Sección <a href="info:emacs#Fill-Prefix" >info:emacs#Fill Prefix</a> en <em>El Manual de GNU Emacs</em> para más información acerca de los prefijos de relleno.)</p>
<p>La existencia de un prefijo de relleno significa que, además de poder encontrar el fin de un párrafo cuyas líneas empiezan en la columna más a la izquierda, la función <code>forward-paragraph</code> debe ser capaz de encontrar el final de un párrafo cuando todas o muchas de las líneas en el búfer empiezan con el prefijo de relleno.</p>
<p>Ademas, a veces es práctico ignorar un prefijo de relleno que existe, como lo pueden ser las líneas en blanco que separan los párrafos. Esto es una complicación añadida.</p>
<p>En vez de imprimir toda la función <code>forward-paragraph</code>, solo imprimiremos partes de la misma. ¡Leer sin preparación, la función puede ser desalentador!</p>
<p>En general, la función tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">forward-paragraph</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let*</span>
      <span class="nv">varlist</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bobp</span><span class="p">)))</span>     <span class="c1">; codigo-de-movimiento-hacia-atras</span>
      <span class="err">…</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>     <span class="c1">; codigo-de-movimiento-hacia-adelante</span>
      <span class="err">…</span>
</code></pre>
<p>Las primeras partes de la función son rutinarias: la  lista de argumentos de la función consiste en un argumento opcional. Luego se presenta la documentación.</p>
<p>La letra minúscula <samp><code>p</code></samp> en la declaración <code>interactive</code> significa que el argumento prefijo se procesa, si lo hay, pasa a la función. Este será un número, y es el contador de repeticion de cuántos párrafos se moverá el punto. La expresión <code>or</code> en la siguiente línea maneja el caso común cuando no se pasa ningun argumento a la función, esto ocurre si la función se llama desde otro código en lugar de interactivamente. Este caso fue descrito anteriormente. (Vea la Seccion <a href="#la-función-forward-sentence" >La Función <code>forward-sentence</code></a>.) Ahora llegamos al final de la parte familiar de esta función.</p>
</div>
<h4 id="la-expresión-let*" >La expresión <code>let*</code></h4>
<div class="hBody-4" >
<p>La siguiente línea en la función <code>forward-paragraph</code> empieza con una expresión <code>let*</code>. Esto es diferente a <code>let</code>. El símbolo es <code>let*</code> no <code>let</code>.</p>
<p>La forma especial <code>let*</code> es como <code>let</code> excepto que Emacs establece cada variable en secuencia, una después de otra, y las variables en la última parte de la varlist pueden hacen uso de los valores a los que Emacs asignó las variables al principio la varlist.</p>
<p>(Seccion <a href="save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></a>.)</p>
<p>En la expresión <code>let*</code> en esta función, Emacs asigna un total de siete variables: <code>opoint</code>, <code>fill-prefix-regexp</code>, <code>parstart</code>, <code>parsep</code>, <code>sp-parstart</code>, <code>start</code>, y <code>found-start</code>.</p>
<p>La variable <code>parsep</code> aparece dos veces, primero, para eliminar instancias de <samp>^</samp>, y segundo, para manejar prefijos de relleno.</p>
<p>La variable <code>opoint</code> es solo el valor de <code>point</code>. Como se puede adivinar, se usa en una expresión <code>constrain-to-field</code>, igual que en <code>forward-sentence</code>.</p>
<p>La variable <code>fill-prefix-regexp</code> se establece con el valor devuelto de evaluar la siguiente lista:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="nv">fill-prefix</span>
     <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">fill-prefix</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
     <span class="p">(</span><span class="nv">not</span> <span class="nv">paragraph-ignore-fill-prefix</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">regexp-quote</span> <span class="nv">fill-prefix</span><span class="p">))</span>
</code></pre>
<p>Esta es una expresión cuyo primer elemento es la forma especial <code>and</code>.</p>
<p>Como aprendimos anteriormente (Sección <a href="#la-función-kill-new" >La función <code>kill-new</code></a>), la forma especial <code>and</code> evalúa cada uno de sus argumentos hasta uno de los argumentos devuelve un valor <code>nil</code>, en cuyo caso la expresión <code>and</code> devuelve <code>nil</code>; sin embargo, si ninguno de los argumentos devuelve un valor <code>nil</code>, se devuelve el valor resultante de evaluar el último argumento. (Puesto que tal valor no es <code>nil</code>, se considera verdadero en Lisp.) En otras palabras, una expresión <code>and</code> devuelve un valor verdadero solo si todos sus argumentos son verdaderos.</p>
<p>En este caso, la variable <code>fill-prefix-regexp</code> se vincula a un valor no <code>nil</code> solo si las cuatro expresiones siguientes producen un valor verdadero (es decir, un valor no <code>nil</code>) cuando se evalúan; de lo contrario, la variable <code>fill-prefix-regexp</code> se vincula a <code>nil</code>.</p>
<dl>
<dt><code>fill-prefix</code></dt>
<dd>
<p>Cuando se evalua esta variable, se devuelve el valor del prefijo de relleno, si lo hay. Si no hay prefijo relleno, esta variable devuelve <code>nil</code>.</p>
</dd>
<dt><code>(not (equal fill-prefix &#34;&#34;)</code></dt>
<dd>
<p>Esta expresión comprueba si un prefijo de relleno existente es una cadena vacía, es decir, una cadena sin caracteres. Una cadena vacía no es un prefijo de relleno útil.</p>
</dd>
<dt><code>(not paragraph-ignore-fill-prefix)</code></dt>
<dd>
<p>Esta expresión devuelve <code>nil</code> si la variable <code>paragraph-ignore-fill-prefix</code> ha sido activada al asignarle un valor verdadero como <code>t</code>.</p>
</dd>
<dt><code>(regexp-quote fill-prefix)</code></dt>
<dd>
<p>Este es el último argumento pasado a la forma especial <code>and</code>. Si todos los argumentos de <code>and</code> son verdaderos, el valor resultante de evaluar esta expresión será devuelto por la expresión <code>and</code> y asociado a la variable <code>fill-prefix-regexp</code>,</p>
</dd>
</dl>
<p>El resultado de evaluar esta expresión <code>and</code> con éxito es que <code>fill-prefix-regexp</code> sera ligada al valor de <code>fill-prefix</code> como fué modificado por la función <code>regexp-quote</code>. Lo que <code>regexp-quote</code> hace es leer una cadena y devolver la expresión regular que coincida exactamente con la cadena y nada más. Esto significa que el valor de <code>fill-prefix-regexp</code> será asignado a un valor que coincida exactamente con el prefijo si existe. De lo contrario, la variable sera ligada a <code>nil</code>.</p>
<p>Las siguientes dos variables locales en la expresión <code>let*</code> están diseñadas para eliminar instancias de <samp>^</samp> de <code>parstart</code> y <code>parsep</code>, las variables locales que indican el inicio del párrafo y el separador de párrafos. La siguiente expresión establece <code>parsep</code> de nuevo. Esto es para manejar prefijos de relleno.</p>
<p>Esta es el ajuste que requiere la llamada de la definición <code>let*</code> en lugar de <code>let</code>. La prueba-verdadero-o-falso del <code>if</code> depende de si la variable <code>fill-prefix-regexp</code> evalúa a <code>nil</code> o algún otro valor.</p>
<p>Si <code>fill-prefix-regexp</code> no tiene un valor, Emacs evalúa la parte else de la expresión <code>if</code> y vinculara <code>parsep</code> a su valor local. (<code>parsep</code> es una expresión regular que coincide con la separacion de párrafos.)</p>
<p>Pero si <code>fill-prefix-regexp</code> tiene un valor, Emacs evalúa la parte-then de la expresión <code>if</code> y enlaza <code>parsep</code> a una expresión regular que incluye <code>fill-prefix-regexp</code> como parte del patrón.</p>
<p>Específicamente, <code>parsep</code> se asigna al valor original del separador del párrafo, la expresión regular concatenada con una expresión alternativa que consiste en <code>fill-prefix-regexp</code> seguido por espacios en blanco opcionales halta el fin de la línea. (El espacio en blanco se define con <q><code>[ \t]*$</code></q>.) El <samp>\\|</samp> define esta porción del regexp como una alternativa a <code>parsep</code>.</p>
<p>De acuerdo a un comentario en el código, la siguiente variable local, <code>sp-parstart</code>, se utiliza para la busqueda, y luego los dos finales, <code>start</code> y <code>found-start</code>, se asignan a <code>nil</code>.</p>
<p>Ahora entramos en el cuerpo del <code>let*</code>. La primera parte del cuerpo del <code>let*</code> trata el caso cuando la función recibe un argumento negativo y por lo tanto se mueve hacia atrás. Omitiremos esta sección.</p>
</div>
<h4 id="el-bucle-while-hacia-adelante" >El bucle <code>while</code> hacia adelante</h4>
<div class="hBody-4" >
<p>La segunda parte del cuerpo del <code>let*</code> maneja el movimiento hacia adelante. Es un bucle <code>while</code> que se repite mientras el valor de <code>arg</code> es mayor a cero. En el uso más común de la función el valor del argumento es 1, por lo que el cuerpo del bucle <code>while</code> se evalúa exactamente una vez, y el cursor avanza hacia adelante un párrafo.</p>
<p>Esta parte maneja tres situaciones: cuando el punto está entre párrafos, cuando hay un prefijo de relleno y cuando no hay un prefijo de relleno.</p>
<p>El bucle <code>while</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; avanza hacia adelante y no al final del búfer</span>
<span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>

  <span class="c1">;; entre párrafos</span>
  <span class="c1">;; Avanzar sobre linesa de separacion...</span>
  <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
              <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c1">;;  Esto decrementa el bucle</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">)))</span>
  <span class="c1">;; ... y una línea más</span>
  <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)</span>

  <span class="p">(</span><span class="nb">if</span> <span class="nv">fill-prefix-regexp</span>
      <span class="c1">;; Hay un prefijo de relleno; sobreescribe parstart;</span>
      <span class="c1">;; avanzamos línea a línea</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">))</span>
                  <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
                  <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">))</span>
                  <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">fill-prefix-regexp</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1">;; No hay prefijo de relleno;</span>
    <span class="c1">;; avanzamos caracter por caracter</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sp-parstart</span> <span class="no">nil</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parstart</span><span class="p">))</span>
                    <span class="p">(</span><span class="nb">and</span> <span class="nv">use-hard-newlines</span>
                         <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">get-text-property</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">start</span><span class="p">)</span> <span class="ss">&#39;hard</span><span class="p">)))))</span>
      <span class="p">(</span><span class="nf">forward-char</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1">;; y si no hay prefijo de relleno y si no estamos al final</span>
    <span class="c1">;; ir a lo que fué encontrado en la búsqueda de expresiones regulares</span>
    <span class="c1">;; para sp-parstart</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">))))</span>
</code></pre>
<p>Se puede ver que esto es un contador de decremento <code>while</code>, usando la expresión <code>(setq arg (1- arg))</code> como decremento. Esta expresión no está lejos del <code>while</code>, pero está oculta en otra macro Lisp, una macro <code>unless</code>. A menos que estemos al final del búfer––eso es lo que la función <code>eobp</code> determina; es una abreviación de <samp>End of Buffer P</samp>––disminuimos el valor de <code>arg</code> por uno.</p>
<p>(Si estamos al fin del búfer, ya no podemos avanzar mas y el siguiente bucle de la expresión <code>while</code> sera falso ya que la prueba es un <code>and</code> con <code>(not (eobp))</code>. La función <code>not</code> significa exactamente lo que se espera; es otro nombre para <code>null</code>, una función que devuelve verdadero cuando su argumento es falso.)</p>
<p>Curiosamento, el contador del bucle no disminuye hasta que dejamos el espacio entre párrafos, a menos que lleguemos al fin del búfer o dejemos de ver el valor local del separador del párrafo.</p>
<p>El segundo <code>while</code> también tiene una expresión <code>(move-to-left-margin)</code>. La función es autoexplicativa. Está dentro de una expresión <code>progn</code> y no el último elemento de su cuerpo, por lo que solo se invoca por su efecto secundario, que es mover el punto al margen izquierdo de la línea actual.</p>
<p>La función <code>looking-at</code> también es auto-explicativa; devuelve verdadero si el texto después del punto coincide con la expresión regular dada como su argumento.</p>
<p>El resto del cuerpo del bucle parece complejo al principio, pero tiene sentido cuando llegas a entenderlo.</p>
<p>Primero considera lo que sucede si hay un prefijo de relleno:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">fill-prefix-regexp</span>
    <span class="c1">;; Hay un prefijo de relleno; sobreescribe parstart;</span>
    <span class="c1">;; avanzamos línea a línea</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
                <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">fill-prefix-regexp</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<p>Esta expresión mueve el punto hacia adelante línea por línea siempre y cuando se cumplan las cuatro condiciones:</p>
<ol class="num" >
<li>
<p>El punto no está al final del búfer.</p>
</li>
<li>
<p>Podemos movernos al margen izquierdo del texto y no estamos al fin del búfer.</p>
</li>
<li>
<p>El siguiente punto no separa los párrafos.</p>
</li>
<li>
<p>El patrón que sigue al punto es la expresión regular del prefijo de relleno.</p>
</li>
</ol>
<p>La última condición puede ser un puzzle, hasta que se recuerde qué el punto fue movido al principio de la línea anteriormente en la función <code>forward-paragraph</code>. Esto significa que si el texto tiene un prefijo de relleno, la función <code>looking-at</code> se verá.</p>
<p>Considera qué ocurre cuando no hay un prefijo lleno.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sp-parstart</span> <span class="no">nil</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parstart</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">and</span> <span class="nv">use-hard-newlines</span>
                     <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">get-text-property</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">start</span><span class="p">)</span> <span class="ss">&#39;hard</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">forward-char</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<p>El bucle <code>while</code> nos lleva a la busqueda de <code>sp-parstart</code>, que es la combinación de posibles espacios en blanco con el valor local del inicio de un párrafo o de un separador de párrafos. (Los dos últimos se encuentran dentro de una expresión que comienza con <code>\(?:</code> así que no están referenciadas por la función <code>match-beginning</code>.)</p>
<p>Las dos expresiones,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
</code></pre>
<p>significan ir al comienzo del texto localizado con la expresión regular.</p>
<p>La expresión <code>(match-beginning 0)</code> es nueva. Devuelve un número que especifica la ubicacion del inicio del texto que coincidio con la última búsqueda.</p>
<p>La función <code>match-beginning</code> se utiliza aquí debido a una característica de la búsqueda hacia adelante: una búsqueda exitosa hacia adelante, independientemente de si se trata de una búsqueda simple o una expresión regular, mueve el punto al fin del texto encontrado. En este caso, una búsqueda exitosa mueve el punto al fin del patrón de <code>sp-parstart</code>.</p>
<p>Sin embargo, queremos poner el punto al fin del actual párrafo, no en algún otro lugar. De hecho, dado que la búsqueda posiblemente incluye el separador de párrafos, el punto puede finalizar al principio del siguiente a menos que utilicemos una expresión que incluya <code>match-beginning</code>.</p>
<p>Cuando se le da un argumento de 0, <code>match-beginning</code> devuelve la posición de inicio del texto coincidente con la búsqueda más reciente. En este caso, la búsqueda más reciente de <code>sp-parstart</code>. La expresión <code>(match-beginning 0)</code> devuelve la posición del comienzo de ese patrón, en lugar de la posición final de este patrón.</p>
<p>(Incidentalmente, cuando se pasa un número positivo como un argumento, la función <code>match-beginning</code> devuelve la localización de punto de la expresión con paréntesis en la última búsqueda a menos que la expresión con paréntesis empiece con <code>\(?:</code>. No sé porque <code>\(?:</code> aparece aquí, ya que el argumento es 0.)</p>
<p>La última expresión cuando no hay prefijo de relleno es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">))))</span>
</code></pre>
<p>Esto dice que si no hay prefijo lleno y no estamos al final, el punto deberia moverse al principio de lo que sea que sea haya encontrado al buscar la expresión regular de <code>sp-parstart</code>.</p>
<p>La definición completa de la función <code>forward-paragraph</code> no solo incluye código para avanzar, también código para retroceder.</p>
<p>Si estás leyendo esto dentro de GNU Emacs y quieres ver la función completa, puedes escribir <kbd>C-h f</kbd> (<code>describe-function</code>) y el nombre de la función. Esto proporciona la documentación de función y el nombre de la librería que contiene el codigo fuente de la función. Coloca el punto sobre el nombre de la librería y presionar la tecla <kbd>RET</kbd>; serás llevado directamente al codigo fuente. (¡Asegúrate de instalar las fuentes! ¡Sin eso, eres como una persona que intenta conducir un coche con los ojos cerrados!)</p>
</div>
<h3 id="crea-tu-propio-fichero-tags" >Crea tu propio fichero <span class="file" >TAGS</span></h3>
<div class="hBody-3" >
<p>Ademas de <kbd>C-h f</kbd> (<code>describe-function</code>), otra forma de ver el codigo de una función es escribir <kbd>M-.</kbd> (<code>find-tag</code>) y el nombre de la función cuando se solicite. Es un buen hábito para obtenerlo. El comando <kbd>M-.</kbd> (<code>find-tag</code>) te lleva directamente al codigo de una función, variable, o nodo. La función depende de tablas de etiquetas para saber donde ir.</p>
<p>Si la función <code>find-tag</code> pregunta primero por el nombre de una tabla <span class="file" >TAGS</span>, dale el nombre de un fichero <span class="file" >TAGS</span> como <span class="file" >/usr/local/src/emacs/src/TAGS</span>. (La ruta exacta a tu fichero <span class="file" >TAGS</span> depende de cómo instalaste tu copia de Emacs. Yo he provisto la localización tanto de mi codigo fuente de C, como de Emacs Lisp.)</p>
<p>Tambien puedes crear tu propio fichero <span class="file" >TAGS</span> para directorios que carecen de uno.</p>
<p>Con frecuencia se necesita construir e instalar tablas de etiquetas por uno mismo. Estas no son construidas automáticamente. Una tabla de etiquetas nombra como un fichero <span class="file" >TAGS</span>; el nombre va en letras mayúsculas.</p>
<p>Puedes crear un fichero <span class="file" >TAGS</span> llamando al programa <code>etags</code> que viene como parte de la distribución de Emacs. Por lo general, <code>etags</code> se compila e instala cuando se construye Emacs. (<code>etags</code> no es una función Lisp o una parte de Emacs; es un programa C.)</p>
<p>Para crear el fichero <span class="file" >TAGS</span>, primero cambia al directorio en el que se quiera crear el fichero. En Emacs se puede hacer esto con el comando <kbd>M-x cd</kbd>, o visitando un fichero en el directorio, o listando el directorio con <kbd>C-x d</kbd> (<code>dired</code>). A continuacion, ejecute el comando  de compilacion, con <code>etags *.el</code> como el comando a ejecutar</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags *.el RET
</pre>
</div>
<p>para crear un fichero <span class="file" >TAGS</span> para Emacs Lisp.</p>
<p>Por ejemplo, si se tiene un gran número de ficheros en el directorio <span class="file" >~/emacs</span>, como en mi caso––yo tengo 137 ficheros <span class="file" >.el</span>, de los cuales cargo 12––se puede crear un fichero <span class="file" >TAGS</span> para los ficheros Emacs Lisp en ese directorio.</p>
<p>El programa <code class="command" >etags</code> recive todos los ‘comodines’ usuales del shell. Por ejemplo, si tienes dos directorios para los que deseas un unico fichero <span class="file" >TAGS</span>, ingresa <code>etags *.el ../elisp/*.el</code>, donde <span class="file" >../elisp/</span> es el segundo directorio:</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags *.el ../elisp/*.el RET
</pre>
</div>
<p>Ingresa</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags --help RET
</pre>
</div>
<p>para ver una lista de las opciones aceptadas por <code class="command" >etags</code> asi como una lista de lenguajes soportados.</p>
<p>El programa <code class="command" >etags</code> maneja más de 20 lenguajes, incluyendo Emacs Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java, LaTeX, Pascal, Perl, Postscript, Python, TeX, Texinfo, makefiles, y la mayoría de ensambladores. El programa no tiene interruptores para especificar el lenguaje; reconoce el lenguaje en un fichero de entrada segun su nombre y contenido.</p>
<p><span class="file" >etags</span> es muy útil cuando estas escribiendo código y quieres referirse a funciones que ya has escrito. Simplemente ejecuta de nuevo <code class="command" >etags</code> a medida que escribas nuevas funciones, para que formen parte del fichero <span class="file" >TAGS</span>.</p>
<p>Si crees que ya existe un fichero <span class="file" >TAGS</span> apropiado para lo que buscas, pero no conoces donde está, puedes usar el programa <code class="command" >locate</code> para intentar encontrarlo.</p>
<p>Escribe <kbd>M-x locate RET TAGS RET</kbd> y Emacs listará los nombres de rutas completos de todos tus ficheros <span class="file" >TAGS</span>. En mi sistema, este comando muestra 34 fichero <span class="file" >TAGS</span>. Por otra parte, un sistema ‘vainilla’ instalado recientemente no contenía ningun fichero <span class="file" >TAGS</span>.</p>
<p>Si la tabla de etiquetas que buscas ya ha sido creada, puedes utilizar el comando <code>M-x visit-tags-table</code> para especificarlo. De lo contrario, tendras que crear la tabla de etiquetas por tí mismo y luego utilizar <code>M-x visit-tags-table</code>.</p>
</div>
<h4 id="construyendo-etiquetas-en-el-codigo-de-emacs" >Construyendo Etiquetas en el codigo de Emacs</h4>
<div class="hBody-4" >
<p>El codigo fuente de GNU Emacs vienen con un <span class="file" >Makefile</span> que contiene un comando <code class="command" >etags</code> sofisticado que crea, recoge, y une tablas de etiquetas con todo el codigo de Emacs y coloca la información dentro de un fichero <span class="file" >TAGS</span> en el directorio <span class="file" >src/</span>. (El directorio <span class="file" >src/</span> está debajo del nivel superior de tu directorio Emacs.)</p>
<p>Para construir este fichero <span class="file" >TAGS</span>, debes ir nivel superior de directorio con el codigo fuente de Emacs y ejecutar el comando de compilacion <code class="command" >make tags</code>:</p>
<div class="example-block" >
<pre class="example" >M-x compile RET make tags RET
</pre>
</div>
<p>(El comando <code class="command" >make tags</code> trabaja bien con las fuentes de GNU Emacs, tan bien como con otros paquetes de codigo fuente.)</p>
<p>Para más información, mira <a href="info:emacs#Tags" >Tablas de Etiquetas</a> en <em>El Manual de GNU Emacs</em>.</p>
</div>
<h3 id="repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí hay un breve resumen de algunas funciones recientemente introducidas.</p>
<dl>
<dt><code>while</code></dt>
<dd>
<p>Evalúa repetidamente el cuerpo de la expresión simpre y cuando el primer elemento del cuerpo se evalue como verdadero. Entonces devuelve <code>nil</code>. (La expresión se evalua solo por sus efectos secundarios.)</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">foo</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">foo</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;foo es %d.\n&#34;</span> <span class="nv">foo</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">foo</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">foo</span><span class="p">))))</span>
</span><span class="out" >foo es 2.
foo es 1.
nil
</span></code></pre>
<p>(La función <code>insert</code> inserta sus argumentos en el punto; la función <code>format</code> devuelve una cadena formateada a partir de sus argumentos de la forma que <code>message</code> formatea sus argumentos; <code>\n</code> produce una nueva línea.)</p>
</dd>
<dt><code>re-search-forward</code></dt>
<dd>
<p>Busca un patrón, y si se encuentra, mueve el punto al final de la coincidencia.</p>
<p>Igual que <code>search-forward</code>, toma cuatro argumentos:</p>
<ol class="num" >
<li>
<p>Una expresión regular que especifica el patrón a buscar. (¡Recuerda poner comillas alrededor de este argumento!)</p>
</li>
<li>
<p>Opcionalmente, el límite de la búsqueda.</p>
</li>
<li>
<p>Opcionalmente, que hacer si la búsqueda falla, devuelve <code>nil</code> o un mensaje de error.</p>
</li>
<li>
<p>Opcionalmente, cuántas veces se puede repetir la búsqueda; si es negativa, la búsqueda va hacia atrás.</p>
</li>
</ol>
</dd>
<dt><code>let*</code></dt>
<dd>
<p>Asocia algunas variables localmente a valores particulares, y luego evalúa los argumentos restantes, devolviendo el valor del último. Al asociar las variables locales, se pueden usan los valores locales de variables declaradas anteriormente.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">foo</span> <span class="mi">7</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">bar</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">3</span> <span class="nv">foo</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;</span><span class="ss">`bar&#39;</span><span class="s"> es %d.&#34;</span> <span class="nv">bar</span><span class="p">))</span>
</span><span class="out" >‘bar’ es 21.
</span></code></pre>
</dd>
<dt><code>match-beginning</code></dt>
<dd>
<p>Devuelve la posición del inicio del texto encontrado por la última búsqueda de una expresión regular.</p>
</dd>
<dt><code>looking-at</code></dt>
<dd>
<p>Devuelve <code>t</code> por verdadero si el texto después del punto coincide con el argumento, que debería ser una expresión regular.</p>
</dd>
<dt><code>eobp</code></dt>
<dd>
<p>Devuelve <code>t</code> por verdadero si el punto está al final de la parte accesible de un búfer. El final de la parte accesible es el final del búfer sin reduccion; es el final de la parte reducida en un búfer reducido.</p>
</dd>
</dl>
</div>
<h3 id="ejercicios-con-re-search-forward" >Ejercicios con <code>re-search-forward</code></h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función para buscar para una expresión que coincida con dos o más líneas en blanco consecutivas.</p>
</li>
<li>
<p>Escribe una función para buscar palabras duplicadas, como ‘el el’. Vea la Seccion <a href="info:emacs#Regexps" >info:emacs#Regexps</a> en <em>El Manual de GNU Emacs</em>, para obtener información de cómo escribir una regexp (una expresión regular) para que coincida con una cadena compuesta de dos mitades idénticas. Puedes idear varias regexps; algunos son mejores que otras. La función que yo utilizo se describe en un apéndice, junto con varias regexps. Vea la Seccion <a href="#apéndice-a-la-función-the-the" >Apéndice A La función <code>the-the</code></a>.</p>
</li>
</ul>
</div>
<h2 id="conteo:-repetición-y-regexps" >Conteo: repetición y regexps</h2>
<div class="hBody-2" >
<p>La repetición y la búsqueda de expresiones regulares son poderosas herramientas que con frecuencia se usan al escribir código en Emacs Lisp. Este capítulo ilustra el uso de búsqueda de expresiones regulares a través de la construcción de comandos de conteo de palabras usando bucles <code>while</code> y recursión.</p>
<p>La distribución de Emacs estándar contiene una función para contar el número de líneas dentro de una región.</p>
<p>Ciertos tipos de escritura piden el conteo de palabras. Por lo tanto, si escribes un ensayo, puedes limitarte a 800 palabras; si escribes una novela, puedes disciplinarte a escribir 1000 palabras al día. Parece extraño, pero durante mucho tiempo, a Emacs le faltó un comando para contar palabras. Quizás la gente usaba Emacs mayoritariamente para codificar o documentar cosas que no requieren contar palabras, o quizás se limitaban al comando de conteo de palabras del sistema operativo, <code class="command" >wc</code>. Alternativamente, las personas pueden haber seguido la convención de las editoriales y calcular un conteo de palabras dividiendo el número de caracteres en un documento por cinco.</p>
<p>Hay muchas maneras de implementar un comando para contar palabras. Aquí hay algunos ejemplos, que puede comparar con el comando estándar de Emacs, <code>count-words-region</code>.</p>
</div>
<h3 id="la-función-count-words-example" >La función <code>count-words-example</code></h3>
<div class="hBody-3" >
<p>Un comando de conteo de palabras podría contar palabras en una línea, párrafo, región, o búfer. ¿Qué debe cubrir el comando? Se podría diseñar el comando para contar el número de palabras en un búfer completo. Sin embargo, la tradición en Emacs fomenta la flexibilidad––se puede querer contar solo las palabras en una sección, en lugar de en todo un búfer. Así que tiene más sentido diseñar el comando para contar el número de palabras en una región. Una vez tienes un comando <code>count-words-region</code>, puedes, si lo deseas, contar palabras en un búfer completo marcándolo con <kbd>C-x h</kbd> (<code>mark-whole-buffer</code>).</p>
<p>Claramente, contar palabras es un acto repetitivo: empezando desde el principio de la región, se cuenta la primer palabra, luego la segunda, despues la tercera, y así sucesivamente, hasta llegar al fin de la región. Esto significa el conteo de palabras se ajusta idealmente a la recursión o a un bucle <code>while</code>.</p>
<p>Primero, implementaremos el comando para contar palabras con un bucle <code>while</code>, luego con recursión. El comando sera, por supuesto, interactivo.</p>
<p>La plantilla para una definición de función interactiva es, como siempre:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nv">expresion-interactiva</span><span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Lo que tenemos que hacer es llenar los espacios.</p>
<p>El nombre de la función sería auto-explicativo y similar al nombre ya existente <code>count-lines-region</code>. Esto hace que el nombre sea fácil de recordar. <code>count-words-region</code> es una buena elección. Ya que ese nombre ahora se usa para el comando estándar de Emacs para contar palabras, nombraremos a nuestra implementación <code>count-words-example</code>.</p>
<p>La función cuenta palabras dentro de una región. Esto significa que la lista de argumentos debe contener símbolos que esten ligados a las dos posiciones, el principio y fin de la región. Estas dos posiciones se pueden llamar <samp>inicio</samp> y <samp>fin</samp> respectivamente. La primer línea de la documentación deberia ser una solo frase, ya que esto es todo lo que imprimen comandos como <code>apropos</code>. La expresión interactiva tendra la forma <samp>(interactive &#34;r&#34;)</samp>, puesto que esto provoca que Emacs pase el principio y fin de la región a la lista de argumentos de la función. Todo esto es rutinario.</p>
<p>El cuerpo de la función necesita ser escrita para hacer tres tareas: primero, configurar condiciones bajo las cuales el bucle <code>while</code> pueda contar palabras, segundo, ejecutar el bucle <code>while</code>, y tercero, enviar un mensaje al usuario.</p>
<p>Cuando un usuario llama a <code>count-words-example</code>, el punto puede estar al principio o fin de la región. Sin embargo, el proceso de conteo debe empezar al principio de la región. Esto significa que querremos poner el punto hay si es que no lo esta. Ejecutando <code>(goto-char beginning)</code> aseguramos esto. Por supuesto, querremos devolver el punto a su posición esperada cuando la función termine su trabajo. Por esta razón, el cuerpo debe estar encerrado en una expresión <code>save-excursion</code>.</p>
<p>La parte central del cuerpo de la función consiste en un bucle <code>while</code> en el que una expresión salta el punto hacia delante palabra por palabra, y otra expresión cuenta estos saltos. Si la prueba-verdadero-o-falso del bucle <code>while</code> es verdadera, el punto salta hacia adelante, y si es falsa el punto estaría al final de la región.</p>
<p>Podríamos usar <code>(forward-word 1)</code> como la expresión para mover el punto hacia adelante palabra por palabra, pero es mas fácil ver lo que Emacs identifica como una ‘palabra’ si usamos una búsqueda de expresión regular.</p>
<p>Una busqueda de expresión regular que localiza su patrón, deja el punto justo después del último carácter de la coincidencia. Esto significa que una sucesión de busqueda de palabras exitosa movera el punto hacia adelante palabra por palabra.</p>
<p>Como cuestion práctica, se desea que la busqueda de expresiónes regulares salta a través de los espacios en blanco y tambien sobre la puntuacion entre palabras. Una regexp no pueda saltar a través de espacios en blanco entre palabras ¡nunca saltara más de una palabra!. Esto significa que la regexp debe incluir el espacio en blanco y los signos de puntuación que siguen a una palabra, si la hay, asi como la palabra misma. (Una palabra puede terminar un búfer y no tener ninguna puntuacion o espacio en blanco, por lo que esa parte de la regexp debe ser opcional.)</p>
<p>Por lo tanto, queremos que el patron de la regexp defina uno o más caracteres constituyentes de la palabra, seguidos opcionalmente, por uno o más caracteres que no sean constituyentes de la palabra. La expresión regular para esto es:</p>
<div class="example-block" >
<pre class="example" >\w+\W*
</pre>
</div>
<p>La tabla sintactica del búfer determina qué caracteres son o no constituyentes de palabras. Para más información sobre la sintaxis, Vea la Sección <a href="info:elisp#Syntax-Tables" >Tablas de Sintaxis</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
<p>La expresión se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span><span class="p">)</span>
</code></pre>
<p>(Observa las barras invertidas que preceden a <samp>w</samp> y <samp>W</samp>. Una barra invertida tiene un significado especial para el intérprete Emacs Lisp. Indica que el siguiente caracter se interpreta de forma diferente a lo habitual. Por ejemplo, los dos caracteres, <samp>\n</samp>, representan una <samp>nueva línea</samp>, en lugar de una barra invertida seguida por <samp>\n</samp>. Dos barras invertidas consecutivas representan una ‘barra invertida ordinaria’, así que el interprete de Emacs Lisp termina viendo una sola barra invertida seguida de una letra. Así descubre que la letra que es especial.)</p>
<p>Necesitamon un contador para contar cuántas palabras hay; esta variable debe ponerse primero a 0 y luego incrementarse cada vez que Emacs recorra el bucle <code>while</code>. La expresión de incremento es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">cuenta</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">cuenta</span><span class="p">))</span>
</code></pre>
<p>Finalmente, necesitamos informar al usuario cuántas palabras hay en la región. La función <code>message</code> sirve para presentar este tipo de información al usuario. El mensaje tiene que estar redactado de manera que se lea correctamente independientemente de cuantas palabras haya en la región: no queremos decir que “hay 1 palabras en la región”. El conflicto entre singular y plural no es gramatical. Se puede resolver este problema usando una expresión condicional que evalue diferentes mensajes dependiendo del número de palabras en la región. Hay tres posibilidades: no palabras en la región, una palabra en la región, y más de una palabra. Esto significa que la forma especial <code>cond</code> es apropiada.</p>
<p>Todo esto lleva a la siguiente definición de función:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; ¡Primer versión; tiene errores!</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">inicio</span> <span class="nv">fin</span><span class="p">)</span>
  <span class="s">&#34;Imprime el número de palabras en la región.
</span><span class="s">Las palabras se definen como al menos un caracter
</span><span class="s">constituyente de palabras seguido por al menos un
</span><span class="s">caracter no constituyente de palabras. La tabla de
</span><span class="s">sintaxis del búfer determina qué caracteres son.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palaras en la región ... &#34;</span><span class="p">)</span>

<span class="c1">;;; 1. Establecer las condiciones apropiadas.</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">inicio</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;;; 2. Ejecutar el bucle while.</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">cuenta</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">cuenta</span><span class="p">)))</span>

<span class="c1">;;; 3. Enviar un mensaje al usuario.</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región NO tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">cuenta</span><span class="p">))))))</span>
</code></pre>
<p>Como esta escrito, la función funciona, pero no en todas las circunstancias.</p>
</div>
<h4 id="el-error-de-espacio-en-blanco-en-count-words-example" >El error de espacio en blanco en <code>count-words-example</code></h4>
<div class="hBody-4" >
<p>El comando <code>count-words-example</code> descrito en la sección anterior tiene dos errores, o mas bien, un error con dos manifestaciones. Primero, si se marca una región que contiene solo espacios en blanco en el medio de algún texto el comando <code>count-words-example</code> dira que la región contiene una palabra. Segundo, si se marca una región conteniendo solo espacios en blanco al final del búfer o la porción accesible de un búfer reducido, el comando muestra un mensaje de error que se ve asi:</p>
<pre class="srci" ><code class="elisp" ><span class="out" >Search failed: &#34;\\w+\\W*&#34;
</span></code></pre>
<p>Si estás leyendo esto en GNU Emacs, puedes probar estos errores por tí mismo.</p>
<p>Primero, evalúa la función de la manera habitual para instalarla.</p>
<p>Si quieres, también puedes vincular la funcion al atajo <kbd>C-c =</kbd> evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-c=&#34;</span> <span class="ss">&#39;count-words-example</span><span class="p">)</span>
</code></pre>
<p>Para realizar la primer prueba, establece la marca y punto al principio y fin de la siguiente línea y luego presiona <kbd>C-c =</kbd> (o <kbd>M-x count-words-example</kbd> si no se vinculo a <kbd>C-c =</kbd>):</p>
<div class="example-block" >
<pre class="example" >    uno   dos  tres
</pre>
</div>
<p>Emacs te dira, correctamente, que la región tiene tres palabras.</p>
<p>Repite la prueba, pero coloca la marca al principio de la línea y el punto justo <em>antes</em> de la palabra <samp>uno</samp>. De nuevo presiona <kbd>C-c =</kbd> (o <kbd>M-x count-words-example</kbd>). Emacs deberia decir que la región no tiene palabras, ya que está compuesta solo por espacios en blanco al inicio de la línea. ¡Pero en vez de que Emacs informa que la región tiene una palabra!</p>
<p>Para la tercer prueba, copia la línea de ejemplo al fin del búfer <span class="file" >*scratch*</span> y luego escribe varios espacios al fin de la línea. Coloca la marca justo después de la palabra <samp>tres</samp> y el punto al fin de la línea. (El fin de la línea será el fin del búfer.) Como anteriormente, pulsa <kbd>C-c =</kbd> (o <kbd>M-x count-words-example</kbd>). De nuevo, Emacs deberia decir que la región no tiene palabras, ya que está compuesta solo por espacios en blanco al final de la línea. En su lugar, Emacs muestra un mensaje de error diciendo <samp>Search failed</samp>.</p>
<p>Los dos errores provienen del mismo problema.</p>
<p>Considere la primer manifestación del error, en la que el comando informa que el espacio en blanco al principio de la línea contiene una palabra. Lo que ocurre es lo siguiente: El comando <code>M-x count-words-example</code> mueve el punto al principio de la región. La prueba de <code>while</code> que verifica que el valor del punto sea más pequeño que el valor de <code>fin</code>, es verdadera. En consecuencia, la busqueda regexp busca y encuentra la primera palabra. Eso deja el punto después de la palabra. <code>count</code> se establece a uno. El bucle <code>while</code> se repite; pero esta vez el valor del punto es mayor al valor de <code>fin</code>, el bucle termina; y la función muestra un mensaje diciendo el número de palabras en la región es uno. En resumen, la expresión regular busca y encuentra la palabra aunque esté fuera de la región marcada.</p>
<p>En la segunda manifestación del error, la región es un espacio en blanco al final del búfer. Emacs dice <samp>Search failed</samp>. Lo que ocurre es que prueba-verdadero-o-falso en el bucle <code>while</code> es verdadera, por lo que se ejecuta la expresión de búsqueda. Pero como no hay más palabras en el buffer, la búsqueda falla.</p>
<p>En ambas manifestaciones del error, la búsqueda se extiende o intenta extenderse fuera de la región.</p>
<p>La solución es limitar la búsqueda a la región––esta es una acción bastante simple, pero como se puede esperar, eso no es tan simple como se podría pensar.</p>
<p>Como hemos visto, la función <code>re-search-forward</code> toma un patrón de búsqueda como su primer argumento. Pero además de este primer, argumento obligatorio, acepta tres argumentos opcionales. El segundo argumento opcional limita la búsqueda. El tercer argumento opcional, si es <code>t</code>, hace que la función devuelva <code>nil</code> en lugar de la señal de error si la búsqueda falla. El cuarto argumento opcional es un contador de repeticiones. (En Emacs, se puede ver la documentación de una la función pulsando <kbd>C-h f</kbd>, seguido por el nombre de la función, y finalmente presionando <kbd>RET</kbd>.)</p>
<p>En la definición de <code>count-words-example</code>, el valor del fin de la región se almacena en la variable <code>fin</code> que se pasa como un argumento a la función. De este modo, podemos añadir <code>fin</code> como argumento en la búsqueda de la expresión regulares:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin</span><span class="p">)</span>
</code></pre>
<p>Sin embargo, con solo este cambio en la definición de <code>count-words-example</code> y luego de probar la nueva versión en una region de espacios en blanco, se recibirá un mensaje de error <samp>Search failed</samp>.</p>
<p>Lo que ocurre es esto: la búsqueda se limita a la región, y falla como se espera porque no hay caracteres constitutivos de palabras en la región. Puesto que falla, se recibe un mensaje de error. Pero no queremos recibir un mensaje de error en este caso; queremos recibir el mensaje de que &#34;La región no tiene palabras&#34;.</p>
<p>La solución a este problema es proveer un tercer argumento <code>t</code> a <code>re-search-forward</code>, haciendo que la función regrese <code>nil</code> en lugar de señalar un error si la búsqueda falla.</p>
<p>Sin embargo, aun con este cambio, veremos el mensaje “Contando palaras en la región ... ” y … lo seguiremos viendo …, hasta presionar <kbd>C-g</kbd> (<code>keyboard-quit</code>).</p>
<p>Esto es lo que ocurre: la búsqueda se limitada a la región, como antes, y falla porque no hay caracteres constituyentes de palabras en la región, como se esperaba. Por consiguiente, la expresión <code>re-search-forward</code> devuelve <code>nil</code>. No hace nada más. En particular, no mueve el punto, coso que hace como un efecto secundario si encuentra el objetivo de la búsqueda. Después de que la expresión <code>re-search-forward</code> devuelve <code>nil</code>, se evalua la siguiente expresión en el bucle <code>while</code>. Esta expresión incrementa el contador. Entonces el bucle se repite. La prueba prueba-verdadero-o-falso es verdadera porque el valor del punto aun es menor al valor del final, ya que la expresión <code>re-search-forward</code> no movio el punto. … y el ciclo repite …</p>
<p>La definición de <code>count-words-example</code> requiere otra modificación para hacer que la prueba-verdadero-o-falso del bucle <code>while</code> sea falsa si la búsqueda falla. Dicho de otra manera, hay dos condiciones que deben cumplirse en la prueba-verdadero-o-falso antes de incrementar la variable de conteo: el punto debe estar dentro de la región y la expresión de búsqueda debe haber encontrado una palabra para contar.</p>
<p>Dado que ambas condiciones deben ser ciertas a la vez, la prueba de la región y la expresión de búsqueda, pueden unirse con una forma especial <code>and</code> y empotrarse en el bucle <code>while</code> como la prueba-verdadero-o-falso, asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin</span><span class="p">)</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin</span> <span class="no">t</span><span class="p">))</span>
</code></pre>
<p>(Para obtener mas información sobre <code>and</code>, consulta la Seccion <a href="#la-función-kill-new" >La función <code>kill-new</code></a>.)</p>
<p>La expresión <code>re-search-forward</code> devuelve <code>t</code> si la búsqueda tiene exito y, como efecto secundario, mueve el punto. En consecuencia, a medida que se encuentran las palabras, el punto se mueve a través de la región. Cuando la expresion de búsqueda no encuentra otra palabra, o cuando el punto llega al final de la región, la prueba-verdadero-o-falso da falso, termina el bucle <code>while</code>, y la función <code>count-words-example</code> muestra uno u otro de sus mensajes.</p>
<p>Después de incorporar estos cambios finales, <code>count-words-example</code> funciona sin errores (¡o al menos, sin los errores que he encontrado!</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión final: while</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">inicio</span> <span class="nv">fin</span><span class="p">)</span>
  <span class="s">&#34;Imprime número de palabras en la región.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palabras en la región ... &#34;</span><span class="p">)</span>

<span class="c1">;;; 1. Establecer las condiciones apropiadas.</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">inicio</span><span class="p">)</span>

<span class="c1">;;; 2. Ejecutar el bucle while</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin</span> <span class="no">t</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">cuenta</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">cuenta</span><span class="p">)))</span>

<span class="c1">;;; 3. Enviar un mensaje al usuario.</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región NO tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">cuenta</span><span class="p">))))))</span>
</code></pre>
</div>
<h3 id="contar-palabras-recursivamente" >Contar Palabras Recursivamente</h3>
<div class="hBody-3" >
<p>Se puede escribir la función para contar palabras tanto de manera recursiva como con un bucle <code>while</code>. Veamos cómo se hace esto.</p>
<p>En primer lugar, debemos reconocer que la función <code>count-words-example</code> tiene tres trabajos: establecer las condiciones apropiadas para que ocurra el conteo; contar las palabras en la región; y enviar un mensaje al usuario diciendo cuántas palabras hay.</p>
<p>Si escribimos una sola función recursiva para hacer todo, recibiremos un mensaje por cada llamada recursiva. Si la región contiene 13 palabras, recibiremos trece mensajes, uno tras otro. ¡No queremos esto!. En su lugar, debemos escribir dos funciones para hacer el trabajo, una de las cuales (la función recursiva) será usada dentro de la otra. Una función configurará las condiciones y mostrara el mensaje; la otra devolverá el conteo de palabras.</p>
<p>Comencemos con la función que hace que se muestre el mensaje. Podemos continuar llamandola <code>count-words-example</code>.</p>
<p>Esta es la función que el usuario llamara. Será interactiva. De hecho, será similar a nuestras versiones previas de esta función, excepto que llamará a <code>contar-palabras-recursivamente</code> para determinar cuántas palabras hay en la región.</p>
<p>Podemos construir facilmente una plantilla para esta función, basada en versiones anteriores:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Versión Recursiva; usa búsqueda de la expresiónes regulares</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">inicio</span> <span class="nv">fin</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nv">expresion-interactiva</span><span class="err">…</span><span class="p">)</span>

<span class="c1">;;; 1. Establecer las condiciones apropiadas.</span>
  <span class="p">(</span><span class="nv">mensaje</span> <span class="nv">explicativo</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">funciones</span> <span class="nv">de</span> <span class="nv">configuracion</span><span class="err">…</span>

<span class="c1">;;; 2. Contar las palabras.</span>
    <span class="nv">llamada</span> <span class="nv">recursiva</span>

<span class="c1">;;; 3. Envía un mensaje al usuario.</span>
    <span class="nv">mensaje</span> <span class="nv">que</span> <span class="nv">proporciona</span> <span class="nv">el</span> <span class="nv">conteo</span> <span class="nv">de</span> <span class="nv">palabras</span><span class="p">))</span>
</code></pre>
<p>La definición parece sencilla, excepto que de alguna manera el conteo devuelto por la llamada recursiva debe ser pasado al mensaje que muestra el conteo de palabras. Un poco de reflexion sugiere que esto se puede hacer mediante una expresión <code>let</code>: podemos enlazar una variable en la lista de variables de la expresionlet con el número de palabras de la región, tal y como lo devuelve la llamada recursiva; y entonces la expresión <code>cond</code>, podra mostrar el valor al usuario.</p>
<p>Con frecuencia, uno piensa que el enlace dentro de una expresión <code>let</code> es algo secundario al trabajo ‘primario’ de una función. Pero en este caso, se podría considerar que el trabajo ‘primario’ de la función (contar palabras), ocurre dentro de la expresión <code>let</code>.</p>
<p>Usando <code>let</code>, la definición de función se veria asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">inicio</span> <span class="nv">fin</span><span class="p">)</span>
  <span class="s">&#34;Imprime número de palabras en la región.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>

<span class="c1">;;; 1. Establecer las condiciones apropiadas.</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palabras en la región ... &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">inicio</span><span class="p">)</span>

<span class="c1">;;; 2. Contar las palabras.</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="p">(</span><span class="nv">contar-palabras-recursivamente</span> <span class="nv">fin</span><span class="p">)))</span>

<span class="c1">;;; 3. Enviar un mensaje al usuario.</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región NO tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">cuenta</span><span class="p">))))))</span>
</code></pre>
<p>A continuacion, tenemos que escribir la función de conteo recursivo.</p>
<p>Una función recursiva tiene al menos tres partes: el ‘prueba-hazlo-de-nuevo’, la ‘expresion-del-siguiente-paso’, y la llamada recursiva.</p>
<p>La prueba-hazlo-de-nuevo determina si la función será o no llamada de nuevo. Ya que estamos contando palabras en una región y podemos usar una función que mueve el punto hacia delante para cada palabra, la prueba-hazlo-de-nuevo puede evaluar si el punto todavía está dentro de la región. La prueba-hazlo-de-nuevo debe encontrar el valor del punto y determina si el punto está antes, en, o después del valor del final de la región.  Podemos usar la función <code>point</code> para localizar el punto. Claramente, se debe pasar el valor del final de la región como un argumento a la función de conteo recursivo.</p>
<p>Además, la prueba-hazlo-de-nuevo también tiene que probar si la búsqueda encuentra una palabra. Si no lo hace, la función no deberia llamarse de nuevo.</p>
<p>La expresion-del-siguiente-paso cambia un valor de modo que cuando cuando se supone que la función recursiva deja de llamarse así misma, se detiene. Más precisamente, la expresion-del-siguiente-paso cambia un valor en el momento adecuado, la prueba-hazlo-de-nuevo detiene la función recursiva de llamarse a si misma otra vez. En este caso, la expresion-del-siguiente-paso puede ser la expresión que mueve el punto hacia adelante, palabra por palabra.</p>
<p>La tercera parte de una función recursiva es la llamada recursiva.</p>
<p>En algún lugar, también, se necesita una parte que haga el ‘trabajo’ de la función, una parte que es el conteo. ¡Una parte vital!</p>
<p>Pero ya, tenemos un esquema de la función de conteo recursivo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">contar-palabras-recursivamente</span> <span class="p">(</span><span class="nv">fin-de-region</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
   <span class="nv">prueba-hazlo-de-nuevo</span>
   <span class="nv">expresion-del-siguiente-paso</span>
   <span class="nv">llamada</span> <span class="nv">recursiva</span><span class="p">)</span>
</code></pre>
<p>Ahora se necesita rellenar los huecos. Comencemos con los casos más simples: si el punto esta en o mas alla del fin de la región, no puede haber ninguna palabra en la región, así que la función deberia regresar cero. Del mismo modo, si la búsqueda falla no hay mas palabras a contar, así la función tambien deberia regresar cero.</p>
<p>Por otro lado, si el punto esta dentro de la región y la búsqueda tiene éxito, la función deberia volver a llamarse a si misma.</p>
<p>Por lo tanto, la prueba-hazlo-de-nuevo se vería así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin-de-region</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin-de-region</span> <span class="no">t</span><span class="p">))</span>
</code></pre>
<p>Ten en cuenta que la expresión de búsqueda es parte de la prueba-hazlo-de-nuevo––la función devuelve <code>t</code> si su búsqueda tiene éxito y <code>nil</code> si falla. (Vea la Seccion <a href="#el-error-de-espacio-en-blanco-en-count-words-example" >El error de espacio en blanco en <code>count-words-example</code></a>, para una explicación de cómo funciona <code>re-search-forward</code>.)</p>
<p>La prueba-hazlo-de-nuevo es la prueba verdadero-o-falso de una cláusula <code>if</code>. Claramente si la prueba-hazlo-de-nuevo tiene éxito, la parte-then de la cláusula <code>if</code> llamaría a la función de nuevo; pero si falla, la parte-else deveria regresar cero ya que el está fuera de la región o la búsqueda falló porque no había palabras a encontrar.</p>
<p>Pero antes de considerar la llamada recursiva, se necesita considerar la expresion-del-siguiente-paso. ¿Qué es eso? Curiosamente, es la parte de la búsqueda de la prueba-hazlo-de-nuevo.</p>
<p>Además de regresar <code>t</code> o <code>nil</code> en la prueba-hazlo-de-nuevo, <code>re-search-forward</code> mueve el punto hacia adelante como un efecto secundario de una búsqueda exitosa. Esta es la acción que cambia el valor de punto para que la función recursiva deje de llamarse a sí misma cuando el punto complete su movimiento a través de la región. Por consiguiente, la expresión <code>re-search-forward</code> es la expresion-del-siguiente-paso.</p>
<p>Entonces, en el esquema, el cuerpo de la función <code>contar-palabras-recursivamente</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-hazlo-de-nuevo-y-del-siguiente-paso-combinadas</span>
    <span class="c1">;; then</span>
    <span class="nv">llamada-recursiva-regresando-la-cuenta</span>
  <span class="c1">;; else</span>
  <span class="nv">regresar-cero</span><span class="p">)</span>
</code></pre>
<p>¿Cómo incorporar el mecanismo que cuenta?</p>
<p>Si no estás acostumbrado a escribir funciones recursivas, una pregunta como esta puede ser un problema. Pero puede y debe abordarse sistemáticamente.</p>
<p>Sabemos que el mecanismo de conteo debe estar asociado en algúna manera con la llamada recursiva. De hecho, dado que la expresion-del-siguiente-paso mueve el punto hacia adelante en una palabra, y dado que se hace una llamada recursiva para cada palabra, el mecanismo de conteo debe ser una expresión que agregue uno al valor devuelto en una llamada a <code>contar-palabras-recursivamente</code></p>
<p>Considera varios casos:</p>
<ul>
<li>
<p>Si hay dos palabras en la región, la función debe devolver un valor resultante de sumar uno al valor devuelto al contar la primera palabra, más el número devuelto al contar las palabras restantes en la región, que en este caso es uno.</p>
</li>
<li>
<p>Si hay una palabra en la región, la función devolvería un valor que resulte de sumar uno al valor devuelto cuando cuenta esa palabra, más el número devuelto cuando cuenta las palabras restantes en la región, que en este caso es cero.</p>
</li>
<li>
<p>Si no hay palabras en la región, la función deberia regresar cero.</p>
</li>
</ul>
<p>En el esquema podemos ver que la parte-else del <code>if</code> devuelve cero para el caso en el que no hay palabras. Esto significa que la parte-then del <code>if</code> debe devolver un valor resultante de sumar uno al valor devuelto por el conteo las palabras restantes.</p>
<p>La expresión se vera asi, donde <code>1+</code> es una función que añade uno a su argumento.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">contar-palabras-recursivamente</span> <span class="nv">fin-de-region</span><span class="p">))</span>
</code></pre>
<p>La función <code>contar-palabras-recursivamente</code> completa se vera asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">contar-palabras-recursivamente</span> <span class="p">(</span><span class="nv">fin-de-region</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>

<span class="c1">;;; 1. prueba-hazlo-de-nuevo</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin-de-region</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin-de-region</span> <span class="no">t</span><span class="p">))</span>

<span class="c1">;;; 2. parte-then: la llamada recursiva</span>
      <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">contar-palabras-recursivamente</span> <span class="nv">fin-de-region</span><span class="p">))</span>

<span class="c1">;;; 3. parte-else</span>
    <span class="mi">0</span><span class="p">))</span>
</code></pre>
<p>Examinemos como funciona esto:</p>
<p>Si no hay palabras en la región, la parte else de la expresión <code>if</code> es evaluada y, por tanto, la función devuelve cero.</p>
<p>Si hay una palabra en la región, el valor del punto es menor que el valor de <code>fin-de-region</code> y la búsqueda tiene éxito. En este caso, la prueba-verdadero-o-falso de la expresión <code>if</code> es verdadera, y la parte-then de la expresión <code>if</code> es evaluada. Se evalua la expresión de conteo. Esta expresión devuelve un valor (que será el valor devuelto por toda la función) que es la suma de uno añadida al valor devuelto por una llamada recursiva.</p>
<p>Mientras tanto, la expresion-del-siguiente-paso ha hecho que punto salte sobre la primera (y en este caso única) palabra en la región. Esto significa que cuando <code>(contar-palabras-recursivamente fin-de-region)</code> se evalua una segunda vez, como resultado de la llamada recursiva, el valor del punto será igual o mayor que el valor del fin de región. Así que esta vez, <code>contar-palabras-recursivamente</code> devolverá cero. El cero se sumara a uno, y la evaluación original de <code>contar-palabras-recursivamente</code> devolverá uno más cero, que es uno y es la cantidad correcta.</p>
<p>Claramente, si hay dos palabras en la región, la primera llamada a <code>contar-palabras-recursivamente</code> devuelve uno mas el valor devuelto por por <code>contar-palabras-recursivamente</code> en una región que contiene la palabra restante––es decir, suma uno a uno, produciendo dos, que es la cantidad correcta.</p>
<p>De manera similar, si hay tres palabras en la región, la primera llamada <code>contar-palabras-recursivamente</code> devuelve uno mas el valor devuelto de <code>contar-palabras-recursivamente</code> en una región que contiene las dos palabras restantes––y así sucesivamente.</p>
<p>Con la documentación completa las dos funciones serian asi:</p>
<p>La función recursiva:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">contar-palabras-recursivamente</span> <span class="p">(</span><span class="nv">fin-de-region</span><span class="p">)</span>
  <span class="s">&#34;Número de palabras entre punto y FIN-DE-REGION.&#34;</span>

<span class="c1">;;; 1. prueba-hazlo-de-nuevo</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin-de-region</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin-de-region</span> <span class="no">t</span><span class="p">))</span>

<span class="c1">;;; 2. parte-then: la llamada recursiva</span>
      <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">contar-palabras-recursivamente</span> <span class="nv">fin-de-region</span><span class="p">))</span>

<span class="c1">;;; 3. else-part</span>
    <span class="mi">0</span><span class="p">))</span>
</code></pre>
<p>El envoltorio:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Recursiva</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">inicio</span> <span class="nv">fin</span><span class="p">)</span>
  <span class="s">&#34;Imprime número de palabras en la región.
</span><span class="s">
</span><span class="s">Las palabras se definen como al menos un caracter
</span><span class="s">constituyente de palabras seguido por al menos un
</span><span class="s">caracter no constituyente de palabras. La tabla de
</span><span class="s">sintaxis del búfer determina qué caracteres son.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palabras en la región ... &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">inicio</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="p">(</span><span class="nv">contar-palabras-recursivamente</span> <span class="nv">fin</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región NO tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">cuenta</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">cuenta</span><span class="p">))))))</span>
</code></pre>
</div>
<h3 id="ejercicio:-conteo-de-signos-de-puntuación" >Ejercicio: Conteo de signos de puntuación</h3>
<div class="hBody-3" >
<p>Usando un bucle <code>while</code>, escriba una función para contar el número de signos de puntuación en una región––punto, coma, punto y coma, dos puntos, signos de interrogacion y exclamación. Haga lo mismo usando recursión.</p>
</div>
<h2 id="contando-palabras-en-una-defun" >Contando palabras en una <code>defun</code></h2>
<div class="hBody-2" >
<p>Nuestro siguiente proyecto es contar el número de palabras en una definición de función. Claramente, esto se puede hacer usando alguna variante de <code>count-words-example</code>. Vea la Seccion <a href="#conteo:-repetición-y-regexps" >Conteo: repetición y regexps</a>. Si solo vamos a contar las palabras en una definición, es bastante fácil marcar la definición con el comando <kbd>C-M-h</kbd> (<code>mark-defun</code>), y luego llamar a <code>count-words-example</code>.</p>
<p>Sin embargo, soy más ambicioso: quiero contar las palabras y símbolos en todas las definiciónes del codigo de Emacs y despues imprimir un grafico que muestre cuántas funciones hay de cada tamaño: cuántas contienen de 40 a 49 palabras o símbolos, cuántas contienen de 50 a 59 palabras o símbolos, y así sucesivamente. A menudo he tenido curiosidad por saber cuanto abarca una función típica, y esto lo dira.</p>
<p>Descrito en una frase, el proyecto del histograma desanima; pero dividido dentro de muchos pequeños pasos, tomando uno a uno, el proyecto se vuelve menos atemorizante. Consideremos cuales deberian ser los pasos a seguir:</p>
<ul>
<li>
<p>Primero, escribir una función para contar las palabras en una definición. Esto incluye el problema de manejar tanto símbolos como palabras.</p>
</li>
<li>
<p>Segundo, escribir una función para listar el número de palabras de cada función en un fichero. Esta función puede usar la función <code>count-words-in-defun</code>.</p>
</li>
<li>
<p>Tercero, escribir una función para listar el número de palabras en cada función en cada uno de los ficheros. Esto implica encontrar automáticamente ficheros diferentes, cambiar entre ellos, y contar las palabras en las definiciones dentro de cada uno.</p>
</li>
<li>
<p>Cuarto, escribir una función para convertir la lista de números que creamos en el paso tres a un formulario que sea adecuado para imprimir en forma de grafico.</p>
</li>
<li>
<p>Quinto, escribir una función para imprimir los resultados como un grafico.</p>
</li>
</ul>
<p>¡Este es un gran proyecto! Pero si tomamos cada paso lentamente, no será difícil.</p>
</div>
<h3 id="¿qué-contar?" >¿Qué contar?</h3>
<div class="hBody-3" >
<p>Cuando empezamos a pensar en como contar las palabras en una definición de función, la primera pregunta es (o deberia ser) ¿qué vamos a contar?  Cuando hablamos de ‘palabras’ con repecto a una definición de función Lisp, en realidad estamos hablando, en gran parte, de ‘símbolos’. Por ejemplo, la siguiente función <code>multiplicar-por-siete</code> contiene los cinco símbolos <code>defun</code>, <code>multiplicar-por-siete</code>, <code>numero</code>, <code>*</code>, y <code>7</code>. Además, en la cadena de documentación, contiene cuatro palabras <samp>Multiplicar</samp>, <samp>NUMERO</samp>, <samp>por</samp>, y <samp>siete</samp>. El símbolo <samp>número</samp> se repite, por lo que la definición contiene un total de diez palabras y símbolos.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Sin embargo, si marcamos la definición <code>multiplicar-por-siete</code> con <kbd>C-M-h</kbd> (<code>mark-defun</code>), y luego llamamos a <code>count-words-example</code> en ella, se encontrará que <code>count-words-example</code> ¡afirma que la definición tiene once palabras, no diez! ¡Alguna cosa está mal!</p>
<p>El problema es doble: <code>count-words-example</code> no cuenta el <samp>*</samp> como una palabra, y cuenta el símbolo unico, <code>multiplicar-por-siete</code>, conteniendo tres palabras. Los guines se tratan como si fueran espacios entre palabras en lugar de conectores entre palabras <samp>multiplicar-por-siete</samp> se cuenta como si fuese escrito <samp>multiplicar por siete</samp>.</p>
<p>La causa de esta confusión es la expresión regular que busca la definición <code>count-words-example</code> que mueve el punto hacia adelante palabra por palabra. En la versión canónica de <code>count-words-example</code>, la regexp es:</p>
<div class="example-block" >
<pre class="example" >&#34;\\w+\\W*&#34;
</pre>
</div>
<p>Esta expresión regular es un patrón que define uno o más caracteres constituyentes de la palabra, posiblemente seguidos por uno o más caracteres que no son constituyentes de palabras. Lo que se entiende por ‘caracteres que constituyen palabras’ nos lleva a la cuestión de la sintaxis, que merece una sección en por sí misma.</p>
</div>
<h3 id="¿qué-constituye-una-palabra-o-símbolo?" >¿Qué constituye una palabra o símbolo?</h3>
<div class="hBody-3" >
<p>Emacs trata diferentes caracteres como perteneciendo a diferentes <dfn>categorías sintacticas</dfn>. Por ejemplo, la expresión regular, <samp>\\w+</samp>, es un patrón que especifica uno o más caracteres <em>constituyentes de palabras</em>. Los caracteres constituyentes de palabras son miembros de una categoría sintactica. Otras categoría sintactica incluye la clase de caracteres de puntuación, como el punto y la coma, y la clase de caracteres de espacio en blanco, como el espacio en blanco o el tabulador. (Para más información, vea la Seccion <q>La Tabla de Sintaxis</q> en <em>El Manual GNU Emacs</em>, y Seccion <a href="info:emacs#Syntax-Tables" >Tablas de Sintaxis</a> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p>Las tablas de sintaxis especifican qué caracteres pertenecen a qué categorías. Normalmente un guión no está especificado como un ‘caracter constiyente de una palabra’. En su lugar, se especifica como perteneciente a la ‘clase de caracteres que son parte de los nombres de símbolos, pero no de las palabras.’  Esto significa que la función <code>count-words-example</code> la trata del mismo modo que trata un espacio en blanco entre palabras, por lo qué la funcion <code>count-words-example</code> cuenta a <samp>multiplicar-por-siete</samp> como tres palabras.</p>
<p>Hay dos maneras de hacer que Emacs cuente <samp>multiplicar-por-siete</samp> como un símbolo: modificar la tabla sintactica o modificar la expresión regular.</p>
<p>Se podría redefinir un guión como un caracter constituyente de una palabra modificando la tabla de sintaxis que Emacs guarda para cada modo. Esta acción serviría a nuestro propósito, excepto que un guion es meramente el caracter más común dentro de los símbolos que no es son un típico caracter constituyente de una palabra; hay otros, también.</p>
<p>Alternativamente, podemos redefinir la regexp usada en la definición de <code>count-words-example</code> para incluir símbolos. Este procedimiento tiene el mérito de la claridad, pero la tarea es un poco dificil.</p>
<p>La primera parte es bastante simple: el patrón debe coincidir con “al menos un carácter sea una palabra o símbolo constituyente”. Asi:</p>
<div class="example-block" >
<pre class="example" >&#34;\\(\\w\\|\\s_\\)+&#34;
</pre>
</div>
<p>El <samp>\\(</samp> es la primera parte del constructor de agrupacion que incluye el <samp>\\w</samp> y el <samp>\\s_</samp> como alternativas, separadas por <samp>\\|</samp>. El <samp>\\w</samp> coincide con cualquier caracter forme parte una palabra y <samp>\\s_</samp> con cualquier caracter que forme parte de un símbolo no constituyente de palabras. El <samp>+</samp> a continuacion del grupo indica que los caracteres que componen la palabra o el símbolo deben coincidir al menos una vez.</p>
<p>Sin embargo, la segunda parte de la regexp es más difícil de diseñar. Lo que queremos es seguir la primera parte con “opcionalmente uno o más caracteres que no constituyen una palabra o símbolo”. Al principio, pense que se podría definir esto con lo siguiente:</p>
<div class="example-block" >
<pre class="example" >&#34;\\(\\W\\|\\S_\\)*&#34;
</pre>
</div>
<p>Las mayúsculas <samp>W</samp> y <samp>S</samp> coinciden con caracteres que <em>no</em> son parte de palabras o símbolos. Desafortunadamente, esta expresión coincide con cualquier caracter que no sea parte de una palabra o simbolo. ¡Esto coincide con cualquier caracter!</p>
<p>Entonces note que cada palabra o símbolo en mi región de prueba iba seguida de un espacio en blanco (espacio en blanco, tabulador, o línea nueva). Así que colocar un patrón para que coincidiese con uno o más espacios en blanco después del patrón para una o más palabras o símbolos constituyentes. Esto tambien falló. Las palabras y los símbolos suelen estar separados por espacios en blanco, pero en el código real los paréntesis pueden ir despues de los símbolos y la puntuación puede seguir las palabras. Así que finalmente, diseñe un patrón en el que los componentes de la palabra o simbolo van seguidos opcionalmente por caracteres que no son espacios en blanco, seguidos a su vez por espacios en blanco opcionales.</p>
<p>Aquí está la expresión regular completa:</p>
<div class="example-block" >
<pre class="example" >&#34;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&#34;
</pre>
</div>
</div>
<h3 id="la-función-contar-palabras-en-definicion" >La función <code>contar-palabras-en-definicion</code></h3>
<div class="hBody-3" >
<p>Hemos visto que hay varias maneras de escribir la función <code>count-word-region</code>. Para escribir <code>contar-palabras-en-definicion</code>, basta con adaptar una de estas versiones.</p>
<p>La versión que utiliza un bucle <code>while</code> es fácil de comprender, así que voy a adaptarla. Debido a que <code>contar-palabras-en-definicion</code> formara parte de un programa más complejo, no necesita ser interactivo y ni mostrar un mensaje, solamente devolver el conteo. Estas consideraciones simplifican un poco la definición.</p>
<p>Por otro lado, <code>contar-palabras-en-definicion</code> se utilizara dentro de un buffer que contiene definiciones de función. Por consiguiente, es razonable pedir que la función determina si se llama cuando el punto está dentro de una definición de función, y si lo esta, que devuelva el conteo para esa definición. Esto añade complejidad a la definición, pero nos ahorra la necesidad de pasar argumentos a la función.</p>
<p>Estas consideraciones nos llevan a preparar la siguiente plantilla:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">contar-palabras-en-definicion</span> <span class="p">()</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nv">configuracion</span><span class="err">…</span>
     <span class="p">(</span><span class="nv">bucle</span> <span class="nb">while</span><span class="err">…</span><span class="p">)</span>
   <span class="nv">regresar</span> <span class="nv">conteo</span><span class="p">)</span>
</code></pre>
<p>Como de costumbre, nuestro trabajo es rellenar los huecos.</p>
<p>Primero, la configuración.</p>
<p>Suponemos que esta función sera llamada dentro de un búfer que contiene definiciones de función. El punto estara o no dentro de una definición de función. Para que <code>contar-palabras-en-definicion</code> funcione, el punto debe moverse al principio de la definición, un contador debe empezar en cero, y el bucle de conteo debe parar cuando el punto alcance el final de la definición.</p>
<p>La función <code>beginning-of-defun</code> busca hacia atrás un delimitador de apertura como <samp>(</samp> al principio de una línea, y mueve el punto a esa posición, o sino al límite de la búsqueda. En la práctica, esto significa que <code>beginning-of-defun</code> mueve el punto al principio de la funcion que lo rodea o a la anterior función, o bien al principio del buffer.</p>
<p>El bucle <code>while</code> requiere un contador para registrar las palabras o símbolos que se estan contando. Una expresión <code>let</code> puede ser usada para crear una variable local para este propósito, y vincularse a un valor inicial de cero.</p>
<p>La función <code>end-of-defun</code> opera como <code>beginning-of-defun</code> excepto que mueve el punto al fin de la definición. <code>end-of-defun</code> puede usarse como parte de una expresión que determina la posición del fin de la definición.</p>
<p>La configuración para <code>contar-palabras-en-definicion</code> toma forma rápidamente: primero movemos el punto al principio de la definición, luego cremos una variable local para almacenar el conteo, y finalmente, registramos la posición del final de la definición para que el bucle <code>while</code> sepa cuando terminar.</p>
<p>El código es asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">beginning-of-defun</span><span class="p">)</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">fin</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-defun</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</code></pre>
<p>El código es simple. Es probable que la única pequeña complicación este en <code>fin</code>, que se vincula a la posición del fin de la definición con una expresión <code>save-excursion</code> que devuelve el valor de <code>end-of-defun</code> que a su vez mueve temporalmente el punto al final de la definición.</p>
<p>La segunda parte del <code>contar-palabras-en-definicion</code>, después de la configuración, es el bucle <code>while</code>.</p>
<p>El bucle debe contener una expresión que mueva el punto hacia adelante palabra por palabra y símbolo por símbolo, y otra expresión que cuente los saltos. La prueba-verdadero-o-falso del bucle <code>while</code> debe ser verdadero siempre y cuando el punto salte hacia adelante, y falso si el punto esta al final de la definición. Ya hemos redefinido la expresión regular para esto, así que el bucle es sencillo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">re-search-forward</span>
             <span class="s">&#34;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&#34;</span> <span class="nv">fin</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">cuenta</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">cuenta</span><span class="p">)))</span>
</code></pre>
<p>La tercera parte de la definición devuelve el numero de palabras y símbolos. Esta parte es la última expresión dentro del cuerpo de la expresión <code>let</code>, y puede ser, simplemente la variable local <code>cuenta</code>, que al ser evalúada devuelve el conteo.</p>
<p>En conjunto, la definición <code>contar-palabras-en-definicion</code> luce así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">contar-palabras-en-definicion</span> <span class="p">()</span>
  <span class="s">&#34;Devuelve el número de palabras y símbolos en una defun.&#34;</span>
  <span class="p">(</span><span class="nv">beginning-of-defun</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">fin</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-defun</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">while</span>
        <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">fin</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">re-search-forward</span>
              <span class="s">&#34;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&#34;</span>
              <span class="nv">fin</span> <span class="no">t</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">cuenta</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">cuenta</span><span class="p">)))</span>
    <span class="nv">cuenta</span><span class="p">))</span>
</code></pre>
<p>¿Cómo probar esto? La función no es interactiva, pero es fácil poner un envoltorio alrededor de la función para hacerla interactiva; podemos usar casi el mismo código que el de la versión recursiva de <code>count-words-example</code>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Interactiva.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">contar-palabras-en-defun</span> <span class="p">()</span>
  <span class="s">&#34;Número de palabras y símbolos en una definición de función.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&#34;Contando palabras y símbolos en la definición de función ... &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cuenta</span> <span class="p">(</span><span class="nv">contar-palabras-en-definicion</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">cond</span>
     <span class="p">((</span><span class="nv">zerop</span> <span class="nv">cuenta</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span>
       <span class="s">&#34;La definición NO tiene palabras o símbolos.&#34;</span><span class="p">))</span>
     <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">cuenta</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span>
       <span class="s">&#34;La definición tiene 1 palabra o símbolo.&#34;</span><span class="p">))</span>
     <span class="p">(</span><span class="no">t</span>
      <span class="p">(</span><span class="nf">message</span>
       <span class="s">&#34;La definición tiene %d palabras o símbolos.&#34;</span> <span class="nv">cuenta</span><span class="p">)))))</span>
</code></pre>
<p>Reutilicemos <kbd>C-c =</kbd> como un conveniente atajo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-c=&#34;</span> <span class="ss">&#39;contar-palabras-en-defun</span><span class="p">)</span>
</code></pre>
<p>Ahora podemos probar <code>contar-palabras-en-defun</code>: instala ambas funciones <code>contar-palabras-en-definicion</code> y <code>contar-palabras-en-defun</code>, y asigna el atajo, luego coloca el cursor con la siguiente definición:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Multiplicar NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>¡Éxito! La definición tiene 10 palabras y símbolos.</p>
<p>El siguiente problema es contar el numero de palabras y símbolos en varias definiciones con un mismo fichero.</p>
</div>
<h3 id="contar-varias-defuns-dentro-de-un-fichero" >Contar varias <code>defuns</code> dentro de un fichero</h3>
<div class="hBody-3" >
<p>Un fichero como <span class="file" >simple.el</span> puede tener cientos o más definiciones dentro de el. Nuestro objetivo a largo plazo es recopilar estadísticas sobre muchos ficheros, pero como primer paso, nuestro objetivo inmediato es recoger estadísticas sobre un fichero.</p>
<p>La información será una serie de números, siendo cada número la longitud de una definición de función. Podemos almacenar los números en una lista.</p>
<p>Sabemos que querremos incorporar la información relativa a un fichero con información sobre de muchos otros ficheros; esto significa que la función para contar la longitudes de las definiciones solo necesita devolver la lista de longitudes. No necesita ni debe mostrar ningun mensaje.</p>
<p>Los comando de conteo de palabras contienen una expresión para mover el punto palabra a palabra y otra expresión para contar los saltos. La función para devolver la longitud de las definiciones puede ser diseñada para trabajar del mismo modo, con una expresión para mover el punto hacia adelante definición por definición y otra expresión para construir la lista de longitudes.</p>
<p>Esta afirmacion del problema hace que sea elemental escribir la definición de función. Claramente, empezaremos el conteo al principio del fichero, por lo que el primer comando será <code>(goto-char (point-min))</code>. Lo siguiente, es iniciar el bucle <code>while</code>; y la puerba verdadero-o-falso del bucle puede ser una regexp para la siguiente definición de función––siempre y cuando la búsqueda tenga éxito, el punto se movera hacia adelante y entonces se evalua el cuerpo del bucle. El cuerpo necesita una expresión que construya la lista de longitudes. <code>cons</code>, el comando de construccion de listas, puede utilizarce para crear la lista. Esto es casi todo lo que hay.</p>
<p>Este fragmento de código tendria el siguiente aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
<span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;^(defun&#34;</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-longitudes</span>
        <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">contar-palabras-en-definicion</span><span class="p">)</span> <span class="nv">lista-de-longitudes</span><span class="p">)))</span>
</code></pre>
<p>Dejamos fuera el mecanismo para encontrar el fichero que contiene las definiciones de función.</p>
<p>En ejemplos anteriores, usabamos est fichero, o el fichero Info, o cambiamos de un búfer a otro, como el búfer <span class="file" >*scratch*</span>.</p>
<p>Encontrar un fichero es un nuevo proceso que aun no hemos discutido.</p>
</div>
<h3 id="encontrar-un-fichero" >Encontrar un fichero</h3>
<div class="hBody-3" >
<p>Para encontrar un fichero en Emacs, se usa el comando <kbd>C-x C-f</kbd> (<code>find-file</code>). Este comando es casi, pero no del todo adecuado para el problema de las longitudes.</p>
<p>Veamos el codigo fuente de <code>find-file</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">find-file</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="s">&#34;Edita el fichero FILENAME.
</span><span class="s">Cambia a un búfer visitando el fichero FILENAME,
</span><span class="s">creando uno si no existe ya.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;FFind file: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nv">find-file-noselect</span> <span class="nv">filename</span><span class="p">)))</span>
</code></pre>
<p>(La definición de la versión más reciente de <code>find-file</code> permite especificar comodines especiales para visitar múltiples ficheros; que hacen la definición más compleja y no la discutiremos aquí, ya que no es relevante. Se puede ver el codigo usando <kbd>M-.</kbd> (<code>find-tag</code>) o <kbd>C-h f</kbd> (<code>describe-function</code>).)</p>
<p>La definición que estoy mostrando posee una documentación corta, pero completa y una expresion interactiva que pide un nombre de fichero cuando se usa el comando interactivamente. El cuerpo de la definición contiene dos funciones, <code>find-file-noselect</code> y <code>switch-to-buffer</code>.</p>
<p>De acuerdo con su documentación, tal y como se muestra con <kbd>C-h f</kbd> (el comando <code>describe-function</code>), la función <code>find-file-noselect</code> lee el fichero nombrado en un búfer y devuelve el búfer. (Su versión más reciente incluye un argumento comodín opcional, así como otro para leer un fichero literalmente y otro para suprimir mensajes de advertencia. Estos argumentos opcionales son irrelevantes.)</p>
<p>Sin embargo, la función <code>find-file-noselect</code> no selecciona el búfer en el que se pone el fichero. Emacs no cambia su atención (o la tuya si estás usas <code>find-file-noselect</code>) al búfer seleccionado. Esto es lo que hace <code>switch-to-buffer</code>: cambia el búfer al que se dirige la atención de Emacs; y cambia el búfer mostrado en la ventana al nuevo búfer. Hemos discutido el cambiando de búfer en otra parte. (Vea la Seccion <a href="#cambiando-búfers" >Cambiando búfers</a>.)</p>
<p>En este proyecto de histograma, no necesitamos mostrar cada fichero en la pantalla ya que el programa determina el tamaño de cada definición dentro de el. En lugar de emplear <code>switch-to-buffer</code>, podemos trabajar con <code>set-buffer</code>, que redirige la atención del programa a un búfer diferente, pero no lo muestra en pantalla. Así en vez llamar a <code>find-file</code> para hacer el trabajo, debemos escribir nuestra propia expresión.</p>
<p>La tarea es fácil: usar <code>find-file-noselect</code> y <code>set-buffer</code>.</p>
</div>
<h3 id="lista-de-longitudes-en-fichero-en-detalle" ><code>lista-de-longitudes-en-fichero</code> en detalle</h3>
<div class="hBody-3" >
<p>El núcleo de la función <code>lista-de-longitudes-en-fichero</code> es un bucle <code>while</code> que contiene una función para mover el punto hacia delante ‘defun a defun’ y una función para contar el número de palabras y símbolos en cada funcion. Este núcleo debe ser rodeado por funciones que realizan otras tareas varias, incluyendo encontrar el fichero, y asegurando que el punto empieza al principio del fichero. La definición de la función se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">lista-de-longitudes-en-fichero</span> <span class="p">(</span><span class="nv">nombre-de-fichero</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de longitudes de las definiciones dentro de NOMBRE-DE-FICHERO.
</span><span class="s">La lista devuelta es una lista de números.
</span><span class="s">Cada número es el número de palabras o
</span><span class="s">símbolos en una definición.&#34;</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Trabajando en </span><span class="ss">`%s&#39;</span><span class="s"> ... &#34;</span> <span class="nv">nombre-de-fichero</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">buffer</span> <span class="p">(</span><span class="nv">find-file-noselect</span> <span class="nv">nombre-de-fichero</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">lista-de-longitudes</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer-read-only</span> <span class="no">t</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;^(defun&#34;</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-longitudes</span>
              <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">contar-palabras-en-definicion</span><span class="p">)</span> <span class="nv">lista-de-longitudes</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">kill-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="nv">lista-de-longitudes</span><span class="p">)))</span>
</code></pre>
<p>Se pasa un argumento a la función, el nombre del fichero en el que se trabajará. Tiene cuatro líneas de documentación, pero sin especificaciónes interactivas. Ya que a la gente le preocupa que un ordenador se estropeado si no ven nada, la primera línea del cuerpo es un mensaje de aviso.</p>
<p>La siguiente línea contiene un <code>save-excursion</code> que devuelve la atencion de Emacs al búfer actual cuando la función se completa. Esto es útil en caso de incorporar esta función dentro de otra función que suponga que el punto se restaura el búfer original.</p>
<p>En la varlist de la expresión <code>let</code>, Emacs busca el fichero y enlaza la variable local <code>buffer</code> al búfer que contiene el fichero. Al mismo tiempo, Emacs crea <code>lista-de-longitudes</code> como una variable local.</p>
<p>A continuacion, Emacs cambia su atención al búfer.</p>
<p>En la siguiente línea, Emacs hace que el búfer sea de solo lectura. Idealmente, esta línea no es necesaria. Ninguna de las funciones para contar palabras y símbolos en una definición de función debe cambiar el búfer. Ademas, el búfer no va a guardarse, incluso si se ha modificado. Esta línea es enteramente la consecuencia de una gran cautela, quizás excesiva. La razón de la precaución es que esta función y aquellas a las que llama trabajaran en el codigo fuente de Emacs y eso es un inconveniente si son modificadas de forma inadvertida. No hace falta decir que no me di cuenta de la necesidad de esta línea hasta que un experimento salio mal y empezó a modificar mis ficheros…</p>
<p>Luego viene una llamada para extender el búfer si esta reducido. Esta función normalmente es innecesaria––Emacs crea un búfer nuevo si no existe ninguno; pero si hay un búfer visitando el fichero, Emacs devuelve ese búfer. En este caso, el búfer puede estar reducido y debe extenderse. Si quisieramos ser completamente ‘amigables con el usuario’, nos encargariamos de guardar la restricción y la ubicacion del punto, pero no lo haremos.</p>
<p>La expresión <code>(goto-char (point-min))</code> mueve el punto al principio del búfer.</p>
<p>Luego viene un bucle <code>while</code> en el que se realiza el ‘trabajo’ de la función. En el bucle, Emacs determina la longitud de cada definición y construye una lista de longitudes que contiene la información.</p>
<p>Emacs mata el búfer después de trabajar a través de el. Esto es para ahorrar espacio dentro de Emacs. Mi versión de GNU Emacs 19 contenía 300 ficheros de codigo fuente de interés; GNU Emacs 22 contiene mas de mil ficheros de codigo fuente. Otra función aplicará <code>lista-de-longitudes-en-fichero</code> a cada uno de los ficheros.</p>
<p>Finalmente, la última expresión dentro de la expresión <code>let</code> es la variable <code>lista-de-longitudes</code>; su valor se devuelve como el valor de toda la función.</p>
<p>Se puede probar esta función instalándolo de la forma habitual. A continuacion coloca tu cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>).</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">lista-de-longitudes-en-fichero</span>
 <span class="s">&#34;/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el&#34;</span><span class="p">)</span>
</code></pre>
<p>Puene que necesites cambiar la ruta del fichero; la de aqui es para GNU Emacs versión 22.1.1. Para cambiar la expresión, cópiala al búfer <span class="file" >*scratch*</span> y edítala.</p>
<p>Ademas, para ver el la longitud completa de la lista, en lugar de una versión truncada es posible tener que evaluar lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">custom-set-variables</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">eval-expression-print-length</span> <span class="no">nil</span><span class="p">))</span>
</code></pre>
<p>(Vea la Seccion <a href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>. A contituacion evalúa la expresión <code>lista-de-longitudes-en-fichero</code>.)</p>
<p>La lista de longitudes para <span class="file" >debug.el</span> tarda menos de un segundo en producirse y se ve asi en GNU Emacs 22:</p>
<pre class="srci" ><code class="elisp" ><span class="out" >(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
</span></code></pre>
<p>Usando mi vieja máquina, con la versión 19 tambien con <span class="file" >debug.el</span> demora siete segundos en producir esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">75</span> <span class="mi">41</span> <span class="mi">80</span> <span class="mi">62</span> <span class="mi">20</span> <span class="mi">45</span> <span class="mi">44</span> <span class="mi">68</span> <span class="mi">45</span> <span class="mi">12</span> <span class="mi">34</span> <span class="mi">235</span><span class="p">)</span>
</code></pre>
<p>La versión nueva de <span class="file" >debug.el</span> contiene más defuns que la anterior; y mi nueva máquina es mucho más rápida que la vieja.</p>
<p>Tenga en cuenta que el tamaño de la última definición en el fichero es la primera de la lista.</p>
</div>
<h3 id="contar-palabras-en-defuns-en-diferentes-ficheros" >Contar palabras en <code>defuns</code> en diferentes ficheros</h3>
<div class="hBody-3" >
<p>En la sección anterior, creamos una función que devuelve una lista de las longitudes de cada definición en un fichero. Ahora, queremos definir una función para devolver una lista maestra de las longitudes de las definiciones en una lista de ficheros.</p>
<p>Trabajar en cada una de las listas de ficheros es es un acto repetitivo, por lo que podemos usar un bucle <code>while</code> o recursión.</p>
<p>El diseño utilizando un bucle <code>while</code> es rutinario. El argumento que se pasaba a la función es una lista de ficheros. Como vimos anteriormente (Ver Sección <a href="#un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a>), se puede escribir un bucle <code>while</code> de un modo que el cuerpo del bucle sea evaluado si tal lista contiene elementos, pero que deba salir del sale del bucle si la lista está vacía. Para que este diseño funcione, el cuerpo del bucle debe contener una expresión que acorte la lista con cada evaluacion del cuerpo, de modo que finalmente la lista esté vacía. La técnica usual es asignar el valor de la lista al valor del <code>cdr</code> de la lista cada vez que se evalua el cuerpo.</p>
<p>La plantilla se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">comprobar-si-la-lista-esta-vacia</span>
  <span class="nv">cuerpo</span><span class="err">…</span>
  <span class="nv">asignar-lista-al-cdr-de-la-lista</span><span class="p">)</span>
</code></pre>
<p>Ademas, recordamos que un bucle <code>while</code> devuelve <code>nil</code> (el resultado de evaluar la prueba-verdadero-o-falso), no el resultado de ninguna evaluación dentro de su cuerpo. (Las evaluaciones dentro del cuerpo del bucle se hacen por sus efectos secundarios.) Sin embargo, la expresión que establece la lista de longitudes es parte del cuerpo––y ese el valor que queremos que devuelva la función como un todo. Para hacer esto, rodeamos el bucle <code>while</code> con una expresión <code>let</code>, y arreglamos que el último elemento de la expresión <code>let</code> contiene el valor de lista de longitudes. (Vea la Seccion <a href="#ejemplo-con-contador-incremental" >Ejemplo con contador incremental</a>.)</p>
<p>Estas consideraciones nos llevan directamente a la función en sí:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Usar bucle while.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">lista-de-longitudes-de-muchos-ficheros</span> <span class="p">(</span><span class="nv">lista-de-ficheros</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de longitudes de defuns en LISTA-DE-FICHEROS.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">lista-de-longitudes</span><span class="p">)</span>

<span class="c1">;;; prueba-verdadero-o-falso</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">lista-de-ficheros</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-longitudes</span>
            <span class="p">(</span><span class="nf">append</span>
             <span class="nv">lista-de-longitudes</span>

<span class="c1">;;; Genera una lista de longitudes.</span>
             <span class="p">(</span><span class="nv">lista-de-longitudes-en-fichero</span>
              <span class="p">(</span><span class="nf">expand-file-name</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-ficheros</span><span class="p">)))))</span>

<span class="c1">;;; Reducir la lista de ficheros.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-ficheros</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-ficheros</span><span class="p">)))</span>

<span class="c1">;;; Devuelve el valor final de la lista de longitudes.</span>
    <span class="nv">lista-de-longitudes</span><span class="p">))</span>
</code></pre>
<p><code>expand-file-name</code> es una función nativa que convierte el nombre de fichero a su nombre de ruta absoluto. La función emplea el nombre del directorio en el que se llama la función.</p>
<p>De este modo, si se llama a <code>expand-file-name</code> dentro de <code>debug.el</code> cuando Emacs está visitando el directorio <span class="file" >/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/</span></p>
<div class="example-block" >
<pre class="example" >debug.el
</pre>
</div>
<p>se convierte en</p>
<div class="example-block" >
<pre class="example" >/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
</pre>
</div>
<p>El único otro nuevo elemento de esta definición de función es la todavía no estudiada función <code>append</code>, que merece una breve sección.</p>
</div>
<h4 id="la-función-append" >La función <code>append</code></h4>
<div class="hBody-4" >
<p>La función <code>append</code> une una lista a otra. De este modo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">append</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
</code></pre>
<p>produce la lista</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">)</span>
</code></pre>
<p>Asi es exactamente cómo queremos unir dos listas de longitudes producidas por <code>lista-de-longitudes-en-fichero</code> entre si. Los resultados contrastan con <code>cons</code>,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cons</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
</code></pre>
<p>que construye una nueva lista en la que el primer argumento de <code>cons</code> se convierte en el primer elemento de la nueva lista:</p>
<pre class="code" ><code class="chroma" ><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="contar-palabras-recursivamente-en-diferentes-ficheros" >Contar palabras recursivamente en diferentes ficheros</h3>
<div class="hBody-3" >
<p>Ademas de un bucle <code>while</code>, podemos trabajar en cada lista de ficheros con recursión. Una versión recursiva de <code>lista-de-longitudes-de-muchos-ficheros</code> es corta y simple.</p>
<p>La función recursiva tiene las partes usuales: la ‘prueba-hazlo-de-nuevo’, la ‘expresion-del-siguiente-paso’, y la llamada recursiva. La ‘prueba-hazlo-de-nuevo’ determina si la función debe volver a llamarse a si misma, lo que hará si la <code>lista-de-ficheros</code> contiene cualquier elemento restante; la ‘expresion-del-siguiente-paso’ reasigna la <code>lista-de-ficheros</code> con su mismo <code>cdr</code>, por lo que eventualmente la lista estara vacía; y la llamada recursiva se llamara a si misma en la lista mas corta. ¡La función completa es mas corta que esta descripción!</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">lista-de-longitudes-de-muchos-ficheros-recursiva</span> <span class="p">(</span><span class="nv">lista-de-ficheros</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de longitudes de cada defun en LISTA-DE-FICHEROS.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">lista-de-ficheros</span>                      <span class="c1">; prueba-hazlo-de-nuevo</span>
      <span class="p">(</span><span class="nf">append</span>
       <span class="p">(</span><span class="nv">lista-de-longitudes-en-fichero</span>
        <span class="p">(</span><span class="nf">expand-file-name</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-ficheros</span><span class="p">)))</span>
       <span class="p">(</span><span class="nv">lista-de-longitudes-de-muchos-ficheros-recursiva</span>
        <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-ficheros</span><span class="p">)))))</span>
</code></pre>
<p>En una frase, la función devuelve la lista de longitudes para la primer <code>lista-de-ficheros</code> adjunta al resultado de llamarse así misma al resto de la <code>lista-de-ficheros</code>.</p>
<p>Aquí hay una prueba de <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code>, junto con los resultados de ejecutar <code>lista-de-longitudes-en-fichero</code> en cada uno de los ficheros individualmente.</p>
<p>Instala <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> y <code>lista-de-longitudes-en-fichero</code>, y luego evalúa las siguientes expresiones. Es posible que necesites cambiar las rutas a los ficheros; las que aquí se incluyen funcionan cuando las fuentes de Emacs se encuentran en sus lugares habituales. Para cambiar las expresiones, cópialas al búfer <span class="file" >*scratch*</span>, edítalas y evalualas.</p>
<p>(Estos resultados son para ficheros de la versión 22.1.1; los ficheros de otras versiones puede producir resultados diferentes.)</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">cd</span> <span class="s">&#34;/usr/local/share/emacs/22.1.1/&#34;</span><span class="p">)</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">lista-de-longitudes-en-fichero</span> <span class="s">&#34;./lisp/macros.el&#34;</span><span class="p">)</span>
</span><span class="out" >(283 263 480 90)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">lista-de-longitudes-en-fichero</span> <span class="s">&#34;./lisp/mail/mailalias.el&#34;</span><span class="p">)</span>
</span><span class="out" >(38 32 29 95 178 180 321 218 324)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">lista-de-longitudes-en-fichero</span> <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">)</span>
</span><span class="out" >(85 181)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nv">lista-de-longitudes-de-muchos-ficheros-recursiva</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;./lisp/macros.el&#34;</span>
   <span class="s">&#34;./lisp/mail/mailalias.el&#34;</span>
   <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">))</span>
</span><span class="out" >(283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)
</span></code></pre>
<p>La función <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> produce la salida que queremos.</p>
<p>El siguiente paso es preparar los datos de la lista para visualizarlos en un grafico.</p>
</div>
<h3 id="preparar-los-datos-para-visualizarlos-en-un-grafico" >Preparar los datos para visualizarlos en un grafico</h3>
<div class="hBody-3" >
<p>La función <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> devuelve una lista de números. Cada número registra la longitud de una definición de función. Lo que que tenemos que hacer ahora es transformar estos datos en una lista de números adecuados para generar un grafico. La nueva lista dira cuántas definiciones de funcion contienen menos de 10 palabras y símbolos, cuantas entre 10 y 19, cuántas entre 20 y 29, y así sucesivamente.</p>
<p>En resumen, necesitamos revisar la lista de longitudes producida por la función <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> y contar el número de definiciones dentro de cada rango, y producir una lista de esos números.</p>
<p>Basado en lo que hemos hecho antes, podemos preveer que no sera demaciado difícil escribir una función que redusca la lista de longitudes con ‘<code>cdr</code>s’, mire cada elemento, determine en que rango de longitud esta, e incremente un contador para ese rango.</p>
<p>Sin embargo, antes de empezar a escribir tal función, debemos considerar las ventajas de primero ordenar la lista de longitudes, de modo que los números se ordenen del más pequeño al más grande. En primer lugar, la ordenacion facilitara el conteo de los números en el mismo rango, ya que dos números adyacentes estaran en el mismo rango de longitud o en rangos adyacentes. Segundo, inspeccionando una lista ordenada, podemos descubrir el número mas alto y el mas bajo, y asi determinar el rango de longitud mas grande y mas pequeño que necesitaremos.</p>
</div>
<h4 id="ordenando-listas" >Ordenando listas</h4>
<div class="hBody-4" >
<p>Emacs contiene una función para ordenar listas, llamada (como se podría adivinar) <code>sort</code>. La función <code>sort</code> toma dos argumentos, la lista a ordenar, y un predicado que determina si el primero de dos elementos de lista es “menor” que el segundo.</p>
<p>Como vimos anteriormente (Ver Sección <a href="Usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a>), un predicado es una función que determina si alguna propiedad es verdadera o falsa. La función <code>sort</code> reordenará una lista de acuerdo a cualquier propiedad que use el predicado; esto significa que <code>sort</code> puede usarse para ordenar listas no numéricas por un criterio no numérico––puede, por ejemplo, ordenar la lista alfabeticamente.</p>
<p>La función <code>&lt;</code> se utiliza para ordena una lista numérica. Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">sort</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">8</span> <span class="mi">21</span> <span class="mi">17</span> <span class="mi">33</span> <span class="mi">7</span> <span class="mi">21</span> <span class="mi">7</span><span class="p">)</span> <span class="ss">&#39;&lt;</span><span class="p">)</span>
</code></pre>
<p>produce esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">4</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">17</span> <span class="mi">21</span> <span class="mi">21</span> <span class="mi">33</span><span class="p">)</span>
</code></pre>
<p>(Ten en cuenta que en este ejemplo, ambos argumentos se citan para que no se evaluen los símbolos antes de pasarlos a <code>sort</code> como argumentos.)</p>
<p>Ordenar la lista devuelta por la función <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> es sencillo; utilizando la función <code>&lt;</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">sort</span>
 <span class="p">(</span><span class="nv">lista-de-longitudes-de-muchos-ficheros-recursiva</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;./lisp/macros.el&#34;</span>
    <span class="s">&#34;./lisp/mailalias.el&#34;</span>
    <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">))</span>
 <span class="ss">&#39;&lt;</span><span class="p">)</span>
</code></pre>
<p>que produce:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">29</span> <span class="mi">32</span> <span class="mi">38</span> <span class="mi">85</span> <span class="mi">90</span> <span class="mi">95</span> <span class="mi">178</span> <span class="mi">180</span> <span class="mi">181</span> <span class="mi">218</span> <span class="mi">263</span> <span class="mi">283</span> <span class="mi">321</span> <span class="mi">324</span> <span class="mi">480</span><span class="p">)</span>
</code></pre>
<p>(Nota que en este ejemplo, el primer argumento para <code>sort</code> no se cita, ya que la expresión debe ser evaluada para producir la lista que se pasada para <code>sort</code>.)</p>
</div>
<h4 id="creando-una-lista-de-ficheros" >Creando una lista de ficheros</h4>
<div class="hBody-4" >
<p>La función <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> requiere una lista de ficheros como argumento. Para nuestros ejemplos de prueba, hemos construido una lista de este tipo a mano; pero el directorio fuente de Emacs Lisp es demasiado grande para que podamos hacerlo. En su lugar, escribiremos una función para hacer el trabajo por nosotros. En esta función, usaremos tanto un bucle <code>while</code> como una llamada recursiva.</p>
<p>En las viejas versiones de GNU Emacs no hacia falta escribir esta función, ya que todos los ficheros <samp>.el</samp> estaban colocados en un directorio. En su lugar, pudimos usar la función <code>directory-files</code>, que lista los nombres de los ficheros que coinciden con un patron especifico dentro de un solo directorio.</p>
<p>Sin embargo, las versiones reciente de Emacs colocan los ficheros de Emacs Lisp en subdirectorios del directorio <span class="file" >lisp</span> de nivel superior. Esta reorganizacion facilita la navegación. Por ejemplo, todos los ficheros relacionados con el correo están en el subdirectorio <span class="file" >mail</span>. Pero al mismo tiempo, esta estructura nos obliga a crear una funcion de listado de ficheros que desciende dentro de los subdirectorios.</p>
<p>Podemos crear esta función, llamada <code>ficheros-en-el-siguiente-directorio</code>, usando funciones familiares como <code>car</code>, <code>nthcdr</code>, y <code>substring</code> en conjunción con una función existente llamada <code>directory-files-and-attributes</code>. Esta última función no solo listas todos los ficheros en un directorio, incluyendo los nombres de los subdirectorios, también sus atributos.</p>
<p>Repitamos nuestro objetivo: crear una función que nos permita alimentar a <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> con nombres de fichero en una lista parecida a esta (pero con más elementos):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;./lisp/macros.el&#34;</span>
 <span class="s">&#34;./lisp/mail/rmail.el&#34;</span>
 <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">)</span>
</code></pre>
<p>La función <code>directory-files-and-attributes</code> devuelve una lista de listas. Cada una de las listas de la lista principal consiste de 13 elementos. El primer elemento es una cadena que contiene el nombre del fichero––que, en GNU/Linux, puede ser un ‘fichero de directorio’, es decir, un fichero con los atributos especiales de un directorio. El segundo elemento de la lista es <code>t</code> para un directorio, una cadena para el enlace simbólico (la cadena es el nombre al que enlaza), o <code>nil</code>.</p>
<p>Por ejemplo, el primer fichero <samp>.el</samp> en el directorio <span class="file" >abbrev.el</span> es <span class="file" >abbrev.el</span>. Su nombre es <span class="file" >/usr/local/share/emacs/22.1.1/lisp/abbrev.el</span> y no es un directorio o un enlace simbólico.</p>
<p>Asi es cómo <code>directory-files-and-attributes</code> lista este fichero y sus atributos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;abbrev.el&#34;</span>
 <span class="no">nil</span>
 <span class="mi">1</span>
 <span class="mi">1000</span>
 <span class="mi">100</span>
 <span class="p">(</span><span class="mi">20615</span> <span class="mi">27034</span> <span class="mi">579989</span> <span class="mi">697000</span><span class="p">)</span>
 <span class="p">(</span><span class="mi">17905</span> <span class="mi">55681</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
 <span class="p">(</span><span class="mi">20615</span> <span class="mi">26327</span> <span class="mi">734791</span> <span class="mi">805000</span><span class="p">)</span>
 <span class="mi">13188</span>
 <span class="s">&#34;-rw-r--r--&#34;</span>
 <span class="no">nil</span>
 <span class="mi">2971624</span>
 <span class="mi">773</span><span class="p">)</span>
</code></pre>
<p>Por otro lado, <span class="file" >mail/</span> es un directorio dentro del directorio <span class="file" >lisp/</span>. El inicio del listado se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;mail&#34;</span>
 <span class="no">t</span>
 <span class="err">…</span>
 <span class="p">)</span>
</code></pre>
<p>(Para conocer los diferentes atributos, mira en la documentación de <code>file-attributes</code>. Ten en mente que la función <code>file-attributes</code> no lista el nombre del fichero, por lo que el primer elemento es el segundo elemento de <code>directory-files-and-attributes</code>.)</p>
<p>Quisieramos que nuestra nueva funcion, <code>ficheros-bajo-el-dirirectorio</code>, listara los ficheros <samp>.el</samp> en el directorio que le pedimos inspeccionar, y en cualquier directorio debajo de ese directorio.</p>
<p>Esto nos da una pista de como construir <code>ficheros-bajo-el-dirirectorio</code>: dentro de un directorio, la función deberia añadir los ficheros <samp>.el</samp> a una lista; y si, dentro de un directorio, la función se encuentra con un subdirectorio, ir dentro de este subdirectorio y repetir sus acciones.</p>
<p>Sin embargo, debemos tener en cuenta que cada directorio contiene un nombre que hace referencia a sí mismo, llamado <span class="file" >.</span>, (“punto”) y un nombre que hace referencia a su directorio padre, llamado <span class="file" >..</span> (“doble punto”). (En <span class="file" >/</span>, el directorio raíz, <span class="file" >..</span> se refiere así mismo, ya que <span class="file" >/</span> no tiene padre.) Claramente, no queremos que nuestra función <code>ficheros-bajo-el-dirirectorio</code> ingrese a estos directorio, puesto que nos llevaran directamente o indirectamente, al directorio actual.</p>
<p>Por consiguiente, nuestra función <code>ficheros-bajo-el-dirirectorio</code> debe realizar varias tareas:</p>
<ul>
<li>
<p>Probar si se está mirando un nombre de fichero que finaliza en <samp>.el</samp> y si es así, añadir su nombre a una lista.</p>
</li>
<li>
<p>Probar si está mirando en un nombre de fichero que es el nombre de un directorio; y si es así,</p>
<ul>
<li>
<p>Probar si está mirando en <span class="file" >.</span> o <span class="file" >..</span>; y si es así omitirlo.</p>
</li>
<li>
<p>Si no, ir dentro de ese directorio y repetir el proceso.</p>
</li>
</ul>
</li>
</ul>
<p>Escribamos una definición de función para realizar estas tareas. Usaremos un bucle <code>while</code> para movernos de un nombre de fichero a otro con un directorio comprobando lo que hay que hacer; y usaremos una llamada recursiva para repetir las acciones en cada subdirectorio. El patrón recursivo es ‘acumular’ (Vease Sección <a href="#patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></a>) usando <code>append</code> como combinador.</p>
<p>Aquí está la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">ficheros-bajo-el-dirirectorio</span> <span class="p">(</span><span class="nv">directorio</span><span class="p">)</span>
  <span class="s">&#34;Lista los ficheros .el en DIRECTORIO y en sus subdirectorios.&#34;</span>
  <span class="c1">;; Aunque la función se utilizara no interactivamente,</span>
  <span class="c1">;; será mas fácil de probar si la hacemos interactiva.</span>
  <span class="c1">;; El directorio tendrá un nombre como</span>
  <span class="c1">;;  &#34;/usr/local/share/emacs/22.1.1/lisp/&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;DNombre del Directorio: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">lista-de-ficheros-el</span>
        <span class="p">(</span><span class="nv">lista-del-directorio-actual</span>
         <span class="p">(</span><span class="nf">directory-files-and-attributes</span> <span class="nv">directorio</span> <span class="no">t</span><span class="p">)))</span>
    <span class="c1">;; mientras estamos en el directorio actual</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">lista-del-directorio-actual</span>
      <span class="p">(</span><span class="nb">cond</span>
       <span class="c1">;; realiza una prueba para ver si el nombre del fichero termina</span>
       <span class="c1">;; en ‘.el’ y si es así, añade su nombre a una lista.</span>
       <span class="p">((</span><span class="nf">equal</span> <span class="s">&#34;.el&#34;</span> <span class="p">(</span><span class="nf">substring</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-del-directorio-actual</span><span class="p">))</span> <span class="mi">-3</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-ficheros-el</span>
              <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-del-directorio-actual</span><span class="p">))</span> <span class="nv">lista-de-ficheros-el</span><span class="p">)))</span>
       <span class="c1">;; prueba si el nombre del fichero es un directorio</span>
       <span class="p">((</span><span class="nf">eq</span> <span class="no">t</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-del-directorio-actual</span><span class="p">))))</span>
        <span class="c1">;; decide si ignorarlo o hacer recursión</span>
        <span class="p">(</span><span class="nb">if</span>
            <span class="p">(</span><span class="nf">equal</span> <span class="s">&#34;.&#34;</span>
                   <span class="p">(</span><span class="nf">substring</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-del-directorio-actual</span><span class="p">))</span> <span class="mi">-1</span><span class="p">))</span>
            <span class="c1">;; entonces no hacer nada puesto que el nombre del fichero es</span>
            <span class="c1">;; el directorio actual o el padre, &#34;.&#34; o &#34;..&#34;</span>
            <span class="p">()</span>
          <span class="c1">;; de otra forma, desciende dentro del directorio y repite el proceso</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-ficheros-el</span>
                <span class="p">(</span><span class="nf">append</span>
                 <span class="p">(</span><span class="nv">ficheros-bajo-el-dirirectorio</span>
                  <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-del-directorio-actual</span><span class="p">)))</span>
                 <span class="nv">lista-de-ficheros-el</span><span class="p">)))))</span>
      <span class="c1">;; move al siguiente fichero en la lista; esto también acorta</span>
      <span class="c1">;; la lista para que el bucle while eventualmente llegue a su fin</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-del-directorio-actual</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-del-directorio-actual</span><span class="p">)))</span>
    <span class="c1">;; devuelve los ficheros</span>
    <span class="nv">lista-de-ficheros-el</span><span class="p">))</span>
</code></pre>
<p>La funcion <code>ficheros-bajo-el-dirirectorio</code> toma un argumento, el nombre de un directorio.</p>
<p>Por eso, en mi sistema,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span>
 <span class="p">(</span><span class="nv">ficheros-bajo-el-dirirectorio</span> <span class="s">&#34;/usr/local/share/emacs/22.1.1/lisp/&#34;</span><span class="p">))</span>
</code></pre>
<p>me dice que en y debajo de mi directorio de codigo fuente Lisp hay 1031 ficheros <samp><span class="file" >.el</span></samp></p>
<p><code>ficheros-bajo-el-dirirectorio</code> devuelve una lista en orden alfabético inverso. Una expresión para ordenar la lista en orden alfabetico tiene el siguiente aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">sort</span>
 <span class="p">(</span><span class="nv">ficheros-bajo-el-dirirectorio</span> <span class="s">&#34;/usr/local/share/emacs/22.1.1/lisp/&#34;</span><span class="p">)</span>
 <span class="ss">&#39;string-lessp</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="contando-definiciones-de-función" >Contando definiciones de función</h4>
<div class="hBody-4" >
<p>Nuestro objetivo inmediato es generar una lista que nos diga cuantas definiciones de funcion contienen menos de 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuantas entre 20 y 29, y así sucesivamente.</p>
<p>Con una lista ordenada de números, es fácil: se cuentan cuantos elementos de la lista son más pequeños de 10, luego, luego, despues de de haber pasado los numeros que se acaban de contar, se cuenta cuantos son más pequeños de 20, luego, despues de haber pasado los numeros que se acaban de contar, los que son más pequeños de 30, y así sucesivamente. Cada uno de los números, 10, 20, 30, 40, y similares, es uno más grande que la parte superior de ese rango. Podemos llamar a la lista de estos numeros, la lista <code>cima-de-rangos</code>.</p>
<p>Si quisieramos, podriamos generar esta lista automáticamente, pero es más sencillo escribir una lista manualmente. Aquí está:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">cima-de-rangos</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span>  <span class="mi">20</span>  <span class="mi">30</span>  <span class="mi">40</span>  <span class="mi">50</span>
   <span class="mi">60</span>  <span class="mi">70</span>  <span class="mi">80</span>  <span class="mi">90</span> <span class="mi">100</span>
  <span class="mi">110</span> <span class="mi">120</span> <span class="mi">130</span> <span class="mi">140</span> <span class="mi">150</span>
  <span class="mi">160</span> <span class="mi">170</span> <span class="mi">180</span> <span class="mi">190</span> <span class="mi">200</span>
  <span class="mi">210</span> <span class="mi">220</span> <span class="mi">230</span> <span class="mi">240</span> <span class="mi">250</span>
  <span class="mi">260</span> <span class="mi">270</span> <span class="mi">280</span> <span class="mi">290</span> <span class="mi">300</span><span class="p">)</span>
 <span class="s">&#34;Listar especificando rangos para ‘definiciones-por-rango’.&#34;</span><span class="p">)</span>
</code></pre>
<p>Para cambiar los rangos, editamos esta lista.</p>
<p>A continuacion, necesitamos escribir la función que crea la lista del número de definiciones con cada rango. Evidentemente, esta función debe tomar las listas <code>longitudes-ordenadas</code> y <code>cima-de-rangos</code> como argumentos.</p>
<p>La función <code>definiciones-por-rango</code> debe hacer dos cosas una y otra vez: debe contar el número de definiciones con un rango específicado por el valor superior actual del rango; y debe pasar al siguiente valor superior en la lista <code>cima-de-rangos</code> después de contar el número de definiciones en el rango actual. Dado que cada una de estas acciones es repetitiva, se pueden utilizar bucles <code>while</code> para el trabajo. Un bucle cuenta el número de definiciones en el rango definido por el valor superior actual del rango, y el otro bucle a su vez selecciona cada uno de los valores del valor del superior del rango.</p>
<p>Se cuentan varias entradas de la lista de <code>longitudes-ordenadas</code> para cada rango; esto significa que el bucle para la lista de <code>longitudes-ordenadas</code> estara dentro del bucle para la lista de <code>cima-de-rangos</code>, como un pequeño engrane dentro de un gran mecanismo.</p>
<p>El bucle interno cuenta el número de definiciones dentro del rango. Es un simple bucle conteo del tipo que hemos visto antes. (Ver la Seccion <a href="#un-bucle-con-un-contador-incremental" >Un bucle con un contador incremental</a>). La prueba verdadero-o-falso del bucle comprueba si el valor de la lista <code>longitudes-ordenadas</code> es menor que el valor actual de la cima del rango. Si es así, la función incrementa el contador y prueba el siguiente valor de la lista <code>longitudes-ordenadas</code>.</p>
<p>El bucle interno se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">elemento-de-longitud-menor-que-el-de-la-cima-de-rango</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-dentro-del-rango</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero-dentro-del-rango</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">longitudes-ordenadas</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">longitudes-ordenadas</span><span class="p">)))</span>
</code></pre>
<p>El bucle exterior debe empezar con el valor más bajo de la lista <code>cima-de-rangos</code>, y acontinuacion, ajustarse a cada uno de los valores superiores sucesivos. Esto puede ser hecho con un bucle como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">cima-de-rangos</span>
  <span class="nv">cuerpo-del-bucle</span><span class="err">…</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">cima-de-rangos</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">cima-de-rangos</span><span class="p">)))</span>
</code></pre>
<p>Puestos juntos, los dos bucles se ven asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">cima-de-rangos</span>

  <span class="c1">;; Contar el número de elementos dentro del rango actual.</span>
  <span class="p">(</span><span class="nb">while</span> <span class="nv">elemento-de-longitud-menor-que-el-de-la-cima-de-rango</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-dentro-del-rango</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero-dentro-del-rango</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">longitudes-ordenadas</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">longitudes-ordenadas</span><span class="p">)))</span>

  <span class="c1">;; Mover al siguiente rango.</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">cima-de-rangos</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">cima-de-rangos</span><span class="p">)))</span>
</code></pre>
<p>Además, en cada iteracion del bucle exterior, Emacs debe registrar el número de definiciones dentro de ese rango (el valor de <code>numero-dentro-del-rango</code>) en una lista. Podemos usar <code>cons</code> para este propósito. (Vea la Seccion <a href="#cons" ><code>cons</code></a>.)</p>
<p>La función <code>cons</code> trabaja bien, excepto que la lista que construye contendrá el número de definiciones para el rango mas alto y el número de definiciones para el más rango bajo al final. Esto se debe a que <code>cons</code> adjunta nuevos elementos de la lista al principio de la lista, y ya que los dos bucles hacen cálculos a través de la lista de longitudes desde el extremo inferior en primer lugar, la <code>lista-de-definiciones-por-rango</code> terminara con el numero mayor al pricipio. Pero querremos imprimir nuestro grafo con los valores pequeños primero y los más grandes después. La solución es invertir el orden de la <code>lista-de-definiciones-por-rango</code>. Podemos hacer esto usando la función <code>nreverse</code>, que invierte el orden de una lista.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">nreverse</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</code></pre>
<p>produce:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>Note que la función <code>nreverse</code> es “destructiva”––es decir, cambiar la lista a la que se aplica; esto contrasta con las funciones <code>car</code> y <code>cdr</code>, que no son destructivas. En este caso, no queremos la <code>lista-de-definiciones-por-rango</code> original, asi que no importa que sea destruida. (La función <code>reverse</code> proporciona un copia inversa de una lista, dejando la lista original tal cual.)</p>
<p>En conjunto, la funcion <code>definiciones-por-rango</code> se ven asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">definiciones-por-rango</span> <span class="p">(</span><span class="nv">longitudes-ordenadas</span> <span class="nv">cima-de-rangos</span><span class="p">)</span>
  <span class="s">&#34;defuns de LONGITUDES-ORDENADAS en cada CIMA-DE-RANGOS.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cima-de-rango</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">cima-de-rangos</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">numero-dentro-del-rango</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nv">lista-de-definiciones-por-rango</span><span class="p">)</span>

    <span class="c1">;; Bucle Externo.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">cima-de-rangos</span>

      <span class="c1">;; Bucle Interno.</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span>
              <span class="c1">;; Necesita el número para la prueba numérica.</span>
              <span class="p">(</span><span class="nf">car</span> <span class="nv">longitudes-ordenadas</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">longitudes-ordenadas</span><span class="p">)</span> <span class="nv">cima-de-rango</span><span class="p">))</span>

        <span class="c1">;; Cuenta el número de definiciones dentro del rango actual.</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-dentro-del-rango</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">numero-dentro-del-rango</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">longitudes-ordenadas</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">longitudes-ordenadas</span><span class="p">)))</span>

      <span class="c1">;; Sale del bucle interno pero permanece dentro del bucle externo.</span>

      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-definiciones-por-rango</span>
            <span class="p">(</span><span class="nf">cons</span> <span class="nv">numero-dentro-del-rango</span> <span class="nv">lista-de-definiciones-por-rango</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-dentro-del-rango</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1">; Restablece el conteo a cero.</span>

      <span class="c1">;; Mover al siguiente rango.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">cima-de-rangos</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">cima-de-rangos</span><span class="p">))</span>
      <span class="c1">;; Designa el siguiente valor superior del rango.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">cima-de-rango</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">cima-de-rangos</span><span class="p">)))</span>
    <span class="c1">;; Sale del bucle externo y cuenta el número de defuns mayor que</span>
    <span class="c1">;; el valor mas alto de cima-de-rango.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-definiciones-por-rango</span>
          <span class="p">(</span><span class="nf">cons</span>
           <span class="p">(</span><span class="nf">length</span> <span class="nv">longitudes-ordenadas</span><span class="p">)</span>
           <span class="nv">lista-de-definiciones-por-rango</span><span class="p">))</span>

    <span class="c1">;; Devuelve una lista del número de definiciones dentro de cada rango,</span>
    <span class="c1">;;  del menor al mayor.</span>
    <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">lista-de-definiciones-por-rango</span><span class="p">)))</span>
</code></pre>
<p>La función es sencilla, excepto por una caracteristica sutil. La prueba verdadero-o-falso del bucle interno es asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">longitudes-ordenadas</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">longitudes-ordenadas</span><span class="p">)</span> <span class="nv">cima-de-rango</span><span class="p">))</span>
</code></pre>
<p>en lugar de asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">longitudes-ordenadas</span><span class="p">)</span> <span class="nv">cima-de-rango</span><span class="p">)</span>
</code></pre>
<p>El propósito de la prueba es determinar si el primer elemento de la lista de <code>longitudes-ordenadas</code> es inferior al valor de la parte superior del rango.</p>
<p>La versión simple de la prueba funciona bien a menos que la lista <code>longitudes-ordenadas</code> tenga un valor <code>nil</code>. En este caso, la expresión <code>(car longitudes-ordenadas)</code> devuelve <code>nil</code>. La función <code>&lt;</code> no puede compara un número con <code>nil</code>, que es una lista vacía, por lo que Emacs indica un error e impide que la función siga ejecutandose.</p>
<p>La lista de <code>longitudes-ordenadas</code> siempre se convierte en <code>nil</code> cuando el contador llega al fin de la lista. Esto significa que cualquier intento de usar la función <code>definiciones-por-rango</code> con la versión simple de la prueba fallará.</p>
<p>Resolvemos el problema usando la expresion <code>(car longitudes-ordenadas)</code> junto con la expresión <code>and</code>. La expresión <code>(car longitudes-ordenadas)</code> devuelve un valor no <code>nil</code> siempre y cuando la lista contenga al menos un número, pero devuelve <code>nil</code> si la lista está vacía. La expresión <code>and</code> primero evalúa <code>(car longitudes-ordenadas)</code>, y si es <code>nil</code>, devuelve falso <em>sin</em> evaluar la expresión <code>&lt;</code> y devuelve este valor como el valor de la expresión <code>and</code>.</p>
<p>De esta manera, evitamos un error.  (Para información acerca de <code>and</code>, consulta la Seccion <a href="#la-función-kill-new" >La función <code>kill-new</code></a></p>
<p>He aqui una breve prueba de la función <code>definiciones-por-rango</code>. Primero, evalúa la expresión que enlaza la lista (ordenada) <code>cima-de-rangos</code> a la lista de valores, luego evalúa la expresión que enlaza la lista <code>longitudes-ordenadas</code>, y despues evalúa la función <code>definiciones-por-rango</code>.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; (La lista ordenada que usaremos después.)</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">cima-de-rangos</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="mi">110</span> <span class="mi">120</span> <span class="mi">130</span> <span class="mi">140</span> <span class="mi">150</span>
   <span class="mi">160</span> <span class="mi">170</span> <span class="mi">180</span> <span class="mi">190</span> <span class="mi">200</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setq</span> <span class="nv">longitudes-ordenadas</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="mi">85</span> <span class="mi">86</span> <span class="mi">110</span> <span class="mi">116</span> <span class="mi">122</span> <span class="mi">129</span> <span class="mi">154</span> <span class="mi">176</span> <span class="mi">179</span> <span class="mi">200</span> <span class="mi">265</span> <span class="mi">300</span> <span class="mi">300</span><span class="p">))</span>

<span class="p">(</span><span class="nv">definiciones-por-rango</span> <span class="nv">longitudes-ordenadas</span> <span class="nv">cima-de-rangos</span><span class="p">)</span>
</code></pre>
<p>Esta es la lista que devuelve:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>De hecho, hay dos elementos de la lista <code>longitudes-ordenadas</code> menores a 110, dos elementos entre 110 y 119, dos elementos entre 120 y 129, etcetera. Hay cuatro elementos con un valor de 200 o superior.</p>
</div>
<h2 id="preparar-un-grafico" >Preparar un grafico</h2>
<div class="hBody-2" >
<p>Nuestro objetivo es construir un grafo que muestre el numero de definiciones de función de varios tamaños en el codigo fuente de Emacs lisp.</p>
<p>Como cuestion práctica, si estuvieras creando un grafico, probablemente usarías un programa como <code class="command" >gnuplot</code> para hacer el trabajo. (<code class="command" >gnuplot</code> está bien integrado dentro de GNU Emacs.) En este caso, sin embargo, creamos uno desde cero, y en el proceso volveremos a familiarizarnos con algo que de lo que aprendimos antes y aprenderemos más.</p>
<p>En este capítulo, primero escribiremos una simple funcion de impresion de graficos. Esta primera definición será un <dfn>prototipo</dfn>, una función escrita rápidamente que nos permita reconocer este territorio desconocido en la creacion de graficos. Descubriremos dragones, o descubriremos que son mitos. Después de explorar el terreno, nos sentiremos más seguros y mejoraremos la función para etiquetar las coordenadas automáticamente.</p>
<p>Dado que Emacs está diseñado para ser flexible y funcionar con todo tipo de terminales, incluyendo los terminales de solo caracteres, el grafico debera realizarse a partir de simbolos de ‘maquina de escribir’. Un asterisco servira; a medida que mejoremos la función de impresión del grafico, podremos hacer que el simbolo a usar sea una elección del usuario.</p>
<p>Podemos llamar a esta función <code>imprimir-cuerpo-grafico</code>; tomará como unico argumento una <code>lista-de-numeros</code>. En esta etapa, no etiquetaremos el grafico, sino que solo imprimiremos su cuerpo.</p>
<p>La función <code>imprimir-cuerpo-grafico</code> inserta una columna vertical de asteriscos para cada elemento en la lista <code>lista-de-numeros</code>. La altura de cada línea está determinada por el valor de ese elemento de la <code>lista-de-numeros</code>.</p>
<p>Insertar columnas es un acto repetitivo; esto significa que esta función puede escribirse con un bucle <code>while</code> o recursivamente.</p>
<p>Nuestro primer reto es descubrir como imprimir una columna de asteriscos. Normalmente, en Emacs, se imprimen caracteres dentro de una pantalla horizontalmente, escribiendo línea a línea. Tenemos dos rutas a seguir: escribir nuestra propia función de insercion-de-columnas o descubrir si ya existe una en Emacs.</p>
<p>Para ver si hay una en Emacs, podemos usar el comando <kbd>M-x apropos</kbd>. Este comando es como el comando <kbd>C-h a</kbd> (<code>command-apropos</code>), excepto que este último solo encuentra aquellas funciones que son comandos. El comando <kbd>M-x apropos</kbd> lista todos los símbolos que coinciden con una expresión regular, incluyendo funciones que no son interactivas.</p>
<p>Lo que queremos buscar es algún comando que imprima o inserte columnas. Muy probablemente, el nombre de la función contendrá la palabra ‘print’ o la palabra ‘insert’ o la palabra ‘column’. Por esta razón, podemos simplemente escribir <kbd>M-x apropos RET print\|insert\|column RET</kbd> y ver el resultado. En mi sistema, este comando demoro bastante tiempo, y luego produjo una lista de 79 funciones y variables. Ahora no demora mucho y produce una lista de 211 funciones y variables. Explorando la lista, la única función que parece puede hacer el trabajo es <code>insert-rectangle</code>.</p>
<p>De hecho, esta es la función que queremos; su documentación dice:</p>
<div class="example-block" >
<pre class="example" >insert-rectangle:
Insertar texto de RECTANGLE con la esquina superior izquierda en el punto
La primera línea de RECTANGLE se inserta en el punto
la segunda línea se inserta en un punto verticalmente debajo del punto, etc
RECTANGLE debe ser una lista de cadenas.
Después de este comando, la marca está en la esquina izquierda
superior y el punto en la esquina inferior derecha.
</pre>
</div>
<p>Podemos ejecutar una prueba rápida, para asegurarnos que hace lo que se espera.</p>
<p>Este es el resultado de colocar el cursor después de la expresión <code>insert-rectangle</code> y presionar <kbd>C-u C-x C-e</kbd> (<code>eval-last-sexp</code>). La función inserta las cadenas <code>&#34;primero&#34;</code>, <code>&#34;segundo&#34;</code>, y <code>&#34;tercero&#34;</code> debajo del punto. También la función devuelve <code>nil</code>.</p>
<div class="example-block" >
<pre class="example" >(insert-rectangle &#39;(&#34;primero&#34; &#34;segundo&#34; &#34;tercer&#34;))primero
                                                  segundo
                                                  tercernil
</pre>
</div>
<p>Por supuesto, no insertaremos el texto de la expresión <code>insert-rectangle</code> en el búfer en el que estamos haciendo el grafico, sino qque llamaremos a la función desde nuestro programa. Sin embargo, tendremos que asegurarnos de que el punto está en el búfer en el lugar donde la función <code>insert-rectangle</code> insertará la columna de cadenas.</p>
<p>Si se está leyendo esto en Emacs, puedes ver como funciona cambiando a otro búfer, como el búfer <span class="file" >*scratch*</span>, colocar el punto a algún lugar del búfer, escribiendo <kbd>M-:</kbd>, luego escribir la expresión <code>insert-rectangle</code> dentro del minibúfer en la consola, y presionar <kbd>RET</kbd>. Esto hace que Emacs evalúe la expresión en el minibúfer, pero utilice como el valor del punto la posición del punto en el búfer <span class="file" >*scratch*</span>. (<kbd>M-:</kbd> es el atajo para <code>eval-expression</code>. Tampoco aparece <code>nil</code> en el búfer <span class="file" >*scratch*</span>, ya que la expresión se evalúa en el minibúfer.)</p>
<p>Cuando hacemos esto, encontraremos que el punto termina al final de la última línea insertada––es decir, esta función mueve el punto como un efecto secundario. Si repitieramos el comando, con el punto en esta posición, la siguiente inserción estaria debajo y a la derecha de la inserción anterior. ¡No queremos esto!. Si vamos a crear un gráfico de barras, las columnas deben estar una al lado de la otra.</p>
<p>Así descubrimos que cada ciclo del bucle <code>while</code> de insercion de corumnas debe reposicionar el punto al lugar que queremos, y ese lugar estará en la parte superior, no en la inferior de la columna. Ademas, recordamos que cuando imprimimos un grafico, no se espera que todas las columnas tengan la misma altura. Esto significa que la parte superior de cada columna puede estar a una altura diferente de la anterior. No podemos simplemente reposicionar el punto en la misma línea cada vez, sino movernos hacia la derecha––o tal vez podamos…</p>
<p>Estamos planeando crear las columnas del grafico de barras con asteriscos. El número de asteriscos en la columna es el número específicado por el elemento actual de la <code>lista-de-numeros</code>. Necesitamos construir una lista de asteriscos de la longitud correcta para cada llamada a <code>insert-rectangle</code>. Si esta lista consiste únicamente del número requerido de asteriscos, entonces tendremos la posición de punto el número correcto de líneas sobre la base del gráfico para imprimirse correctamente. Esto podría ser difícil.</p>
<p>Alternativamente, si podemos encotrar alguna manear de pasar a <code>insert-rectangle</code> una lista de la misma longitud cada vez, entonces podemos posicionar el punto en la misma línea cada vez, pero moverlo una columna a la derecha para cada nueva columna. Si hacemos esto, sin embargo, algunas de las entradas en la lista pasaba a <code>insert-rectangle</code> deben ser espacios en blanco en vez de asteriscos. Por ejemplo, si la altura máxima del grafico es 5, pero la altura de la columna es 3, entonces <code>insert-rectangle</code> requiere un argumento como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34; &#34;</span> <span class="s">&#34; &#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span><span class="p">)</span>
</code></pre>
<p>Esta última propuesta no es tan difícil, siempre y cuando podamos determinar la altura de la columna. Hay dos maneras de especificar la altura de la columna: podemos indicar arbitrariamente cual sera, lo que funcionaría bien para gráficos de esta altura; o podemos buscar a través de la lista de números y usar la altura máxima de la lista como la altura máxima del grafico. Si la segunda operación fuera difícil, entonces el procedimiento anterior seria mas fácil, pero hay una función nativa en Emacs para determinar el máximo de sus argumentos. Podemos usar esta función. La función se llamaba <code>max</code> y devuelve el mayor de todos sus argumentos, que deben ser números. Asi, por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">max</span>  <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>devuelve 7. (Una función correspondiente llamada <code>min</code> devuelve el más pequeño de todos sus argumentos.)</p>
<p>Sin embargo, no podemos simplemente llama a <code>max</code> sobre la <code>lista-de-numeros</code>; la función <code>max</code> espera números como su argumento, no una lista de números. De este modo, la siguiente expresión,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">max</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<p>produce el siguiente mensaje error;</p>
<div class="example-block" >
<pre class="example" >Tipo incorrecto de argumento: number-or-marker-p, (3 4 6 5 7 3)
</pre>
</div>
<p>Necesitamos una función que pase una lista de argumentos a una función. Esa función es <code>apply</code>. Esta función ‘aplica’ su primer argumento (una función) a los argumentos restantes, el último puede ser una lista.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">7</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">8</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>devuelve 8</p>
<p>(Por cierto, no cómo aprenderias sobre esta función sin un libro como este. Es posible descubrir otras funciones, como <code>search-forward</code> o <code>insert-rectangle</code>, adivinando una parte de sus nombres y luego usando <code>apropos</code>. Aunque su base metafórica es clara––‘apply’ (aplicar) su primer argumento al resto––dudo que a un novato se le ocurra esa palabra en particular usando <code>apropos</code> u otra ayuda. Por supuesto, podría estar equivocado; después de todo, la función fué nombrada por primera vez por alguien que la tuvo que inventar.</p>
<p>El segundo y siguientes argumentos de <code>apply</code> son opcionales, por lo que podemos usar <code>apply</code> para llamar a una función y pasarle los elementos de una lista, de la siguiente manera, que también devuelve 8:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">8</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>Este ultima forma es la que usaremos para <code>apply</code>. La función <code>lista-de-longitudes-de-muchos-ficheros-recursiva</code> devuelve una lista de números a la que podemos aplicar <code>max</code> (tambien podriamos aplicar <code>max</code> a la lista de números ordenados; no importa si la lista está ordenada o no).</p>
<p>Por lo tanto, la operación para encontrar la altura máxima del grafico es esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">altura-maxima-del-grafico</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">lista-de-numeros</span><span class="p">))</span>
</code></pre>
<p>Ahora podemos volver a la pregunta de como crear una lista de cadenas para una columna del grafico. Indicando la máxima altura del grafico y el número de asteriscos que aparecerían en la columna, la función devolverá una lista de cadenas para el comando <code>insert-rectangle</code>.</p>
<p>Cada columna se compone de asteriscos o espacios en blanco. Puesto que pasamos a la función la altura de la columna y el número de asteriscos en ella, el número de espacios en blanco se puede encontrar restando los asteriscos de la altura. Dado el número de espacios en blanco y el número de asteriscos, podemos usar dos bucles <code>while</code> para construir la lista:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Primera versión.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">columna-del-grafico</span> <span class="p">(</span><span class="nv">altura-maxima-del-grafico</span> <span class="nv">altura-real</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de cadenas que es una columna de un grafico.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">lista-de-insercion</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">numero-de-espacios</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">altura-maxima-del-grafico</span> <span class="nv">altura-real</span><span class="p">)))</span>

    <span class="c1">;; Rellenar los asteriscos.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">altura-real</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-insercion</span> <span class="p">(</span><span class="nf">cons</span> <span class="s">&#34;*&#34;</span> <span class="nv">lista-de-insercion</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">altura-real</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">altura-real</span><span class="p">)))</span>

    <span class="c1">;; Rellena los espacios.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">numero-de-espacios</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-insercion</span> <span class="p">(</span><span class="nf">cons</span> <span class="s">&#34; &#34;</span> <span class="nv">lista-de-insercion</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-espacios</span>
            <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero-de-espacios</span><span class="p">)))</span>

    <span class="c1">;; Devuelve la lista completa.</span>
    <span class="nv">lista-de-insercion</span><span class="p">))</span>
</code></pre>
<p>Si instalas esta función y luego evaluas  la siguiente expresión, veras que devuelve la lista que se espera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">columna-del-grafico</span> <span class="mi">5</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>devuelve</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34; &#34;</span> <span class="s">&#34; &#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span><span class="p">)</span>
</code></pre>
<p>Como está escrito, <code>columna-del-grafico</code> contiene una defecto importante: los símbolos usados para el espacio y las entradas marcadas en la columna estan ‘incrustados en el codigo’ como un espacio y un asterisco. Esto está bien para un prototipo, pero tu, u otro usuario, pueden querer usar otros símbolos. Por ejemplo, al probar la función del grafico, podrias querer usar un punto en vez del espacio, para asegurar que el punto que está recolocando apropiadamente cada vez que se llama a la función <code>insert-rectangle</code>; o tal vez quieras sustituir un signo de asterisco por <samp>+</samp>. Incluso es posible querer crear un grafico de columna que tenga mas de una columna de visualizacion. El programa debería ser más flexible. La forma de hacerlo es reemplazar el espacio en blanco y el asterisco con dos variables que podemos llamar <code>simbolo-en-blanco</code> y <code>simbolo-grafico</code> y definir esa variables por separado.</p>
<p>Ademas, la documentación no está bien escrita. Estas consideraciones nos llevan a la segunda versión de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">simbolo-grafico</span> <span class="s">&#34;*&#34;</span>
  <span class="s">&#34;Cadena utilizada como símbolo en el grafico, normalmente un asterisco.&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="nv">simbolo-en-blanco</span> <span class="s">&#34; &#34;</span>
  <span class="s">&#34;Cadena utilizada como un espacio en blanco en el grafico, normalmente un espacio en blanco.
</span><span class="s">simbolo-en-blanco debe tener el mismo número de columnas de ancho que simbolo-grafico.&#34;</span><span class="p">)</span>
</code></pre>
<p>(Para una explicación de <code>defvar</code>, vera la seccion <a href="#inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></a>.)</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Segunda versión.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">columna-del-grafico</span> <span class="p">(</span><span class="nv">altura-maxima-del-grafico</span> <span class="nv">altura-real</span><span class="p">)</span>
  <span class="s">&#34;Devuelve cadenas con la ALTURA-MAXIMA-DEL-GRAFICO; ALTURA-REAL son símbolos graficos.
</span><span class="s">
</span><span class="s">Los simbolo-graficos son entradas contiguas al final de la lista.
</span><span class="s">La lista se insertara como una columna de un grafico.
</span><span class="s">Las cadenas contienen tanto simbolos en blanco o simbolos graficos.&#34;</span>

  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">lista-de-insercion</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">numero-de-espacios</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">altura-maxima-del-grafico</span> <span class="nv">altura-real</span><span class="p">)))</span>

    <span class="c1">;; Rellena con simbolo-grafico.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">altura-real</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-insercion</span> <span class="p">(</span><span class="nf">cons</span> <span class="nv">simbolo-grafico</span> <span class="nv">lista-de-insercion</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">altura-real</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">altura-real</span><span class="p">)))</span>

    <span class="c1">;; Rellena con simbolo-en-blanco.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">numero-de-espacios</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-insercion</span> <span class="p">(</span><span class="nf">cons</span> <span class="nv">simbolo-en-blanco</span> <span class="nv">lista-de-insercion</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numero-de-espacios</span>
            <span class="p">(</span><span class="nf">1-</span> <span class="nv">numero-de-espacios</span><span class="p">)))</span>

    <span class="c1">;; Devuelve la lista completa.</span>
    <span class="nv">lista-de-insercion</span><span class="p">))</span>
</code></pre>
<p>Si quisieramos, podríamos reescribir <code>columna-del-grafico</code> una tercera vez para proporcionar opcionalmente un gráfico de líneas, asi como gráfico de barras. Esto no sería dificil de hacer. Una manera de pensar en un grafico de líneas es que no es más que un grafico de barras en el que la parte de cada barra que está debajo la parte superior esta en blanco. Para construir una columna para gráfico de líneas, la función primero construyen una lista de espacios en blanco que más que mas pequeñå que el valor en uno, luego usa <code>cons</code> para adjuntar un símbolo gráfico a la lista; despues usa <code>cons</code> de nuevo para adjuntar el ‘alto de espacios en blanco’ a la lista.</p>
<p>Es fácil ver como escribir una función de este tipo, pero puesto que no la necesitamos, no se hará. Pero el trabajo podría hacerse, y si se hiciera, se haría con <code>columna-del-grafico</code>. Y lo que es más importante, señalar que pocos cambios que tendrían que realizarce en otra lugar. La mejora, si alguna vez la hacemos, es simple.</p>
<p>Ahora, finalmente, llegamos a nuestra primera función real de impresion de graficos. Esta imprime el cuerpo de un grafico, no las etiquetas para los ejes horizontal y vertical, así que podemos nombrarla como <code>imprimir-cuerpo-grafico</code>.</p>
</div>
<h3 id="la-función-imprimir-cuerpo-grafico" >La función <code>imprimir-cuerpo-grafico</code></h3>
<div class="hBody-3" >
<p>Después de nuestra preparación en la sección anterior, la función <code>imprimir-cuerpo-grafico</code> es sencilla. La función imprimirá columna tras columna de de asteriscos y espacios en blanco, usando los elementos de la lista de números para especificar el número de asteriscos en cada columna. Este es un acto repetitivo, lo que significa que podemos utilizar un bucle <code>while</code> decreciente o una función recursiva para el trabajo. En esta sección, escribiremos la definición usando un bucle <code>while</code>.</p>
<p>La función <code>columna-del-grafico</code> requiere como argumento la altura del grafico, por lo que debemos determinar y registrarla como una variable local.</p>
<p>Esto nos lleva a la siguiente plantilla para la funcion con el bucle <code>while</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-cuerpo-grafico</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">altura</span>  <span class="err">…</span>
         <span class="err">…</span><span class="p">))</span>

    <span class="p">(</span><span class="nb">while</span> <span class="nv">lista-de-numeros</span>
      <span class="nv">insertar-columna-y-reposicionar-punto</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-numeros</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-numeros</span><span class="p">)))))</span>
</code></pre>
<p>Necesitamos completar los espacios de la plantilla.</p>
<p>Claramente, podemos usar la expresión <code>(apply &#39;max lista-de-numeros)</code> para determinar la altura del grafico.</p>
<p>El bucle <code>while</code> recorrera la <code>lista-de-numeros</code> un elemento a la vez. A medida que se acorta la lista por la expresión <code>(setq lista-de-numeros (cdr lista-de-numeros))</code>, el <code>car</code> de cada instancia de la lista es el valor del argumento para <code>columna-del-grafico</code>.</p>
<p>En cada ciclo del bucle <code>while</code>, la función <code>insert-rectangle</code> inserta la lista devuelta por <code>columna-del-grafico</code>. Dado que la función <code>insert-rectangle</code>, mueve el punto a la parte inferior derecha del rectangulo insertado, necesitamos guardar la ubicacion del punto en el momento que se inserta el rectángulo, volver a esta posición después de insertar el rectángulo, y despues moverlo horizontalmente al siguiente lugar donde se llamo a <code>insert-rectangle</code>.</p>
<p>Si las columnas insertadas tienen un carácter de ancho, como será si se utilizan espacios y asteriscos unicos, el comando de reposicionamiento consiste solamente en <code>(forward-char 1)</code>; sin embargo, el ancho de una columna puede ser mayor que uno. Esto significa que el comando de reposicionamiento debe escribirse <code>(forward-char ancho-del-simbolo)</code>. El ancho del simbolo en si es la longitud de un grafico en blanco y se puede encontrar usando la expresion <code>(length graph-blank)</code>. El mejor lugar para asociar la variable <code>ancho-del-simbolo</code> al valor de la columna de grafico está en la varlist de la expresión <code>let</code>.</p>
<p>Estas consideraciones conducen a la siguiente definición de función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-cuerpo-grafico</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;Imprime un gráfico de barras de la LISTA-DE-NUMEROS.
</span><span class="s">La lista-de-numeros esta formada por los valores del eje Y.&#34;</span>

  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">altura</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">lista-de-numeros</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">ancho-del-simbolo</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">simbolo-en-blanco</span><span class="p">))</span>
        <span class="nv">desde-la-posicion</span><span class="p">)</span>

    <span class="p">(</span><span class="nb">while</span> <span class="nv">lista-de-numeros</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">desde-la-posicion</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">insert-rectangle</span>
       <span class="p">(</span><span class="nv">columna-del-grafico</span> <span class="nv">altura</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-numeros</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">desde-la-posicion</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">ancho-del-simbolo</span><span class="p">)</span>
      <span class="c1">;; Dibuja el grafico columna por columna.</span>
      <span class="p">(</span><span class="nv">sit-for</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-numeros</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-numeros</span><span class="p">)))</span>
    <span class="c1">;; Coloca el punto para las etiquetas del eje X.</span>
    <span class="p">(</span><span class="nf">forward-line</span> <span class="nv">altura</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
<span class="p">))</span>
</code></pre>
<p>La unica expresión inesperada en esta función es <code>(sit-for 0)</code> dentro del bucle <code>while</code>. Esta expresión hace que la operacion de impresion de graficos sea más de lo que sería de otro modo. La expresión hace que Emacs <samp>pare</samp> <em>(sit)</em> o no haga nada un periodo de tiempo cero y luego vuelva a dibujar la pantalla. Puesto aquí, hace que Emacs redibuje la pantalla columna por columna. Sin ella, Emacs no redibujaría la pantalla hasta que la función termine.</p>
<p>Podemos probar <code>imprimir-cuerpo-grafico</code> con una pequeña lista de números.</p>
<ol class="num" >
<li>
<p>Instala <code>simbolo-grafico</code>, <code>simbolo-en-blanco</code>, <code>columna-del-grafico</code>, que están en las Secciones <a href="#preparar-un-grafico" >Preparar un grafico</a>, y <code>#La función <code>imprimir-cuerpo-grafico</code></code>.</p>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">imprimir-cuerpo-grafico</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y coloca el cursor donde quieras que empiece el grafico.</p>
</li>
<li>
<p>Pulsa <kbd>M-:</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pega la expresión <code>imprimir-cuerpo-grafico</code> dentro del minibúfer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión <code>imprimir-cuerpo-grafico</code>.</p>
</li>
</ol>
<p>Emacs imprimirá un grafico como este:</p>
<div class="example-block" >
<pre class="example" >        *
    *   **
    *  ****
   *** ****
  ********* *
 ************
*************
</pre>
</div>
</div>
<h3 id="la-función-imprimir-cuerpo-grafico-con-recursividad" >La función <code>imprimir-cuerpo-grafico-con-recursividad</code></h3>
<div class="hBody-3" >
<p>La función <code>imprimir-cuerpo-grafico</code> también puede escribirse recursivamente. La solución recursiva se divide en dos partes: una <samp>envoltura</samp> externa que utiliza una expresión <code>let</code> para determinar los valores de varias variables que solo necesitan encontrarse una vez, como la altura máxima del grafico, y una función interna que se llama recursivamente para imprimir el grafico.</p>
<p>La ‘envoltura’ no es complicada:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-cuerpo-grafico-con-recursividad</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;Imprime un gráfico de barras de la LISTA-DE-NUMEROS.
</span><span class="s">La lista-de-numeros esta formada por los valores del eje Y.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">altura</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">lista-de-numeros</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">ancho-del-simbolo</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">simbolo-en-blanco</span><span class="p">))</span>
        <span class="nv">desde-la-posicion</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">imprimir-cuerpo-grafico-con-recursividad-interna</span>
     <span class="nv">lista-de-numeros</span>
     <span class="nv">altura</span>
     <span class="nv">ancho-del-simbolo</span><span class="p">)))</span>
</code></pre>
<p>La función recursiva es un poco más difícil. Tiene cuatro partes: la ‘prueba-hazlo-de-nuevo’, el código de impresion, la llamada recursiva, y la ‘expresion-del-siguiente-paso’. La ‘prueba-hazlo-de-nuevo’ es una expresión <code>when</code> que determina si la <code>lista-de-numeros</code> contiene algun elemento restante; si lo tiene, la función imprime una columna del grafico usando el código de impresion y se vuelve a llamar asi misma. La función se llama así misma de acuerdo al valor producido por la ‘expresion-del-siguiente-paso’ le que hace que la llamada actue sobre una versión mas corta de la <code>lista-de-numeros</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-cuerpo-grafico-con-recursividad-interna</span>
  <span class="p">(</span><span class="nv">lista-de-numeros</span> <span class="nv">altura</span> <span class="nv">ancho-del-simbolo</span><span class="p">)</span>
  <span class="s">&#34;Imprime un gráfico de barras.
</span><span class="s">Se utiliza dentro del cuerpo de la función imprimir-cuerpo-grafico-con-recursividad.&#34;</span>

  <span class="p">(</span><span class="nb">when</span> <span class="nv">lista-de-numeros</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">desde-la-posicion</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">insert-rectangle</span>
         <span class="p">(</span><span class="nv">columna-del-grafico</span> <span class="nv">altura</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-numeros</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">desde-la-posicion</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">ancho-del-simbolo</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">sit-for</span> <span class="mi">0</span><span class="p">)</span>     <span class="c1">; Dibuja el gráfico columna por columna.</span>
        <span class="p">(</span><span class="nv">imprimir-cuerpo-grafico-con-recursividad-interna</span>
         <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-numeros</span><span class="p">)</span> <span class="nv">altura</span> <span class="nv">ancho-del-simbolo</span><span class="p">)))</span>
</code></pre>
<p>Podemos probar esta expresión después de instalarla; aquí hay un ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">imprimir-cuerpo-grafico-con-recursividad</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<p>Aquí está el resultado:</p>
<div class="example-block" >
<pre class="example" >    *
   **   *
  ****  *
  **** ***
* *********
************
*************
</pre>
</div>
<p>Cada una de estas dos funciones, <code>imprimir-cuerpo-grafico</code> o <code>imprimir-cuerpo-grafico-con-recursividad</code>, crea el cuerpo de un grafico.</p>
</div>
<h3 id="necesidad-de-ejes-de-impresion" >Necesidad de Ejes de impresion</h3>
<div class="hBody-3" >
<p>Un grafico necesita ejes impresos para poder orientarse. Para un proyecto de usar una vez, puede ser razonable dibujar los ejes a mano usando el modo Picture de emacs, pero una funcion de dibujo de graficos puede usarse más de una vez.</p>
<p>Por esta razón, he escrito mejoras a la función básica <code>print-graph-body</code> que imprime automáticamente etiquetas para los ejes horizontal y vertical. Como las funciones de impresion de etiquetas no contiene mucho material nuevo, se puesto su descripción en un apéndice. Ver Seccion <a href="#Apéndice-C" >Apéndice C Un grafico con ejes etiquetados</a>.</p>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Escribe una versión de grafico de lineas de las funciones de impresión del graficos.</p>
</div>
<h2 id="tu-fichero-.emacs" >Tu fichero <span class="file" >.emacs</span></h2>
<div class="hBody-2" >
<p>“No te tiene que gustar Emacs para lo que te gusta”––esto que parece una frase paradójica es el secreto de GNU Emacs. En realidad, Emacs es una herramienta genérica. La mayoría de la gente que usa Emacs, lo personaliza para ajustarlo a sus necesidades.</p>
<p>GNU Emacs está mayoritariamente escrito en Emacs Lisp; esto significa que escribiendo expresiones en Emacs Lisp se puede modificar o extender Emacs.</p>
<p>Hay quien aprecia la configuración por defecto de Emacs. Después de todo, Emacs empieza en modo C cuando se edita un fichero C, empieza en modo Fortran cuando se edita un fichero Fortran, y empieza en modo Fundamental cuando se edita un fichero no adornado. Esto tiene sentido, si no sabes quien está yendo a usar Emacs. ¿Quién sabe lo que una persona espera hacer con un fichero no adornado? El modo fundamental es el modo correcto por defecto para tal fichero, tal como el modo C es lo correcto para editar código C. (Suficientes lenguajes de programación tienen sintaxis que permiten compartir funcionalidades, tal como el modo C es ahora proporcionado por el modo CC, la ‘Colección C’.)</p>
<p>Pero cuando se conoce quien está yendo a usar Emacs––tu, tu mismo––entonces eso tiene sentido para personalizar Emacs.</p>
<p>Por ejemplo, yo raramente quiero el modo Fundamental cuando edito un fichero de otro modo no distinguido; yo quiero el modo Texto. Esto es por lo que yo personalizo Emacs: así eso se ajusta a mí.</p>
<p>Se puede personalizar y extender Emacs escribiendo o adaptando un fichero <span class="file" >~/.emacs</span>. Esto es un fichero de inicialización personal; sus contenidos, escritos en Emacs Lisp, cuentan a Emacs qué hacer.<span class="note" ><sup><a href="#14" >14</a></sup></span></p>
<p>Un fichero <span class="file" >~/.emacs</span> contiene código Emacs Lisp. Se puede escribir este código por uno mismo; o se puede usar la funcionalidad <code>customize</code> para escribir el código para ti. Se puede combinar tus propias expresiones y expresiones auto-escritas personalizadas en tu fichero <span class="file" >.emacs</span>.</p>
<p>(Yo prefiero por mí mismo escribir mis propias expresiones, excepto para estas, fuentes particularmente, que se encuentran fáciles de manipular usando el comando <code>customize</code>. Yo combino los dos métodos.)</p>
<p>La mayoría de este capítulo es acerca de escribir expresiones por uno mismo. Eso describe un fichero <span class="file" >.emacs</span> simple; para más información, mira <q>El Fichero de Inicio</q> en <em>El Manual GNU Emacs</em>, y la Seccion <q>El Fichero de Inicio</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
</div>
<h3 id="fichero-de-inicialización-site-wide" >Fichero de inicialización site-wide</h3>
<div class="hBody-3" >
<p>Además de tu fichero de inicialización personal, Emacs automáticamente carga varios ficheros de inicialización amplios, si existen. Tienen la misma forma que tu fichero <span class="file" >.emacs</span>, pero se cargan por cualquiera.</p>
<p>Dos ficheros de incialización, <span class="file" >site-load.el</span> y <span class="file" >site-init.el</span>, están cargados dentro de Emacs y volcados <em>dumped</em> sin una versión dumped de Emacs se creó, como es más común. (Las copias dumped de Emacs cargan más rápidamente. Sin embargo, puesto que un fichero se carga y compila, un cambio no llega a ser un cambio en Emacs a menos que se cargue por uno mismo o se recompile Emacs. Vea la Seccion <q>Construyendo Emacs</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, y el fichero <span class="file" >INSTALL</span>)</p>
<p>Los otros tres ficheros de inicialización se cargan automáticamente cada vez que se inicia Emacs, si existen. Son <span class="file" >site-start.el</span>, que se carga <em>antes</em> que tu fichero <span class="file" >.emacs</span>, y <span class="file" >default.el</span>, y el tipo de fichero terminal, que se cargan <em>después</em> de tu fichero <span class="file" >.emacs</span>.</p>
<p>Las configuraciones y definiciones en tu fichero <span class="file" >.emacs</span> sobreescribirán las configuraciones en conflicto y definiciones en un fichero <span class="file" >site-start.el</span>, si eso existe; pero las configuraciones y definiciones en un <span class="file" >default.el</span> o el tipo de fichero terminal sobreescribirá estos en tu fichero <span class="file" >.emacs</span>. (Se pueden prevenir interferencias desde un tipo de fichero terminal configurando <code>term-file-prefix</code> para <code>nil</code>. Vea la Seccion <a href="Una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></a>.)</p>
<p>El fichero <span class="file" >INSTALL</span> que viene en la distribución contiene descripciones de los fichero <span class="file" >site-init.el</span> y <span class="file" >site-load.el</span>.</p>
<p>Los ficheros <span class="file" >loadup.el</span>, <span class="file" >startup.el</span>, y <span class="file" >loaddefs.el</span> controlan la carga. Estos ficheros están en el directorio <span class="file" >lisp</span> de la distribución Emacs y tiene valor de uso.</p>
<p>El fichero <span class="file" >loaddefs.el</span> contiene buenas sugerencias como las que poner dentro de tu propio fichero <span class="file" >.emacs</span>, o dentro de un fichero de inicialización amplio.</p>
</div>
<h3 id="especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></h3>
<div class="hBody-3" >
<p>Se pueden especificar variables usando <code>defcustom</code> así que la gente pueda usar la funcionalidad de Emacs <code>customize</code> para asignar sus valores. (No se puede usar <code>customize</code> para escribir definiciones de función; pero se pueden escribir <code>defuns</code> en tu fichero <span class="file" >.emacs</span>. En vez de eso, se puede escribir cualquier expresión Lisp en tu fichero <span class="file" >.emacs</span>).</p>
<p>La funcionalidad <code>customize</code> depende de la forma especial <code>defcustom</code>. Aunque se puede usar <code>defvar</code> o <code>setq</code> para las variables que los usuarios asignan, la forma especial <code>defcustom</code> está diseñada para el trabajo.</p>
<p>Se puede usar tu conocimiento de <code>defvar</code> para escribir los primeros tres argumentos para <code>defcustom</code>. El primer argumento para <code>defcustom</code> es el nombre de la variable. El segundo argumento es el valor inicial de la variable, cualquiera; y este valor es asignado solo si el valor no ha sido ya asignado. El tercer argumento es la documentación.</p>
<p>El cuarto y subsiguientes argumentos para <code>defcustom</code> especifican los tipos y opciones; estos no son funcionales en <code>defvar</code>. (Estos argumentos son opcionales.)</p>
<p>Cada uno de estos argumentos consiste de una palabra seguido de una palabra por un valor. Cada palabra clave empieza con los dos puntos <samp>:</samp>.</p>
<p>Por ejemplo, la variable de opciones personalizable <code>text-mode-hook</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defcustom</span> <span class="nv">text-mode-hook</span> <span class="no">nil</span>
  <span class="s">&#34;El hook normal se ejecuta cuando se introduce en modo texto y
</span><span class="s">  muchos modos relacionados.&#34;</span>
  <span class="nb">:type</span> <span class="ss">&#39;hook</span>
  <span class="nb">:options</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">turn-on-auto-fill</span> <span class="nv">flyspell-mode</span><span class="p">)</span>
  <span class="nb">:group</span> <span class="ss">&#39;data</span><span class="p">)</span>
</code></pre>
<p>El nombre de la variable es <code>text-mode-hook</code>; no tiene valor por defecto; y su cadena de documentación cuenta lo que hace.</p>
<p>La palabra clave <code>:type</code> le cuenta a Emacs el tipo de datos para los que <code>text-mode-hook</code> sería asignado y como muestra el valor en un búfer de Personalización.</p>
<p>La palabra clave <code>:options</code> especifica una lista sugerida de valores para la variable. Normalmente, <code>:options</code> se asocia a un gancho (<em>hook</em>. La lista es solo una sugerencia; esa no es exclusiva; una persona quien asigna la variable puede asignarse a otros valores; la lista mostrada siguiendo la palabra clave <code>:options</code> se pretende ofrecer elecciones convenientes a un usuario.</p>
<p>Finalmente, la palabra clave <code>:group</code> cuenta el comando de Personalización de Emacs en el que el grupo de la variable está localizado. Esto cuenta dónde encontralo.</p>
<p>La función <code>defcustom</code> reconoce más de una docena de palabras clave. Para más información, mire <q>Escribiendo las Definiciones de Personalización</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
<p>Considere <code>text-mode-hook</code> como un ejemplo.</p>
<p>Hay dos caminos para personalizar esta variable. Se puede usar el comando de personalización o escribir las expresiones apropiadas por uno mismo.</p>
<p>Usando el comando de personalización, se puede escribir:</p>
<div class="example-block" >
<pre class="example" >M-x customize
</pre>
</div>
<p>y encuentre que el grupo para editar ficheros de datos se llama ‘datos’. Introduzca este grupo. El Hook <em>Disparador</em> es el primer miembro. Se puede hacer click en sus opciones varias, tal como <code>turn-on-auto-fill</code>, para asignar los valores. Después de hacer click en el botón.</p>
<div class="example-block" >
<pre class="example" >Guárdalo para Futuras Sesiones
</pre>
</div>
<p>Emacs escribirá una expresión en tu fichero <span class="file" >.emacs</span>. Se parecerá a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">custom-set-variables</span>
  <span class="c1">;; custom-set-variables fué añadido por Custom.</span>
  <span class="c1">;; Si se edita a mano, tu podrías liarte,</span>
  <span class="c1">;; así que ten cuidado.</span>
  <span class="c1">;; Tu fichero init contendría solo esta instancia.</span>
  <span class="c1">;; Si hay más de uno, ellos no quieren trabajar.</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="nv">text-mode-hook</span> <span class="p">(</span><span class="nb">quote</span> <span class="p">(</span><span class="nv">turn-on-auto-fill</span> <span class="nv">text-mode-hook-identify</span><span class="p">))))</span>
</code></pre>
<p>(La función <code>text-mode-hook-identify</code> cuenta <code>toggle-text-mode-auto-fill</code> que buffers hay en modo Texto. Eso viene automáticamente)</p>
<p>La función <code>custom-set-variables</code> funciona de alguna manera diferente más de un <code>setq</code>. Mientras yo nunca he aprendido las diferencias, yo modifico las expresiones <code>custom-set-variable</code> en mi fichero <span class="file" >.emacs</span> a mano: yo creo los cambios en los que aparecen a mi para ser una manera razonable y no tener problemas. Otros prefieren usar el comando de Personalización y permitir a Emacs hacer el trabajo para ellos.</p>
<p>Otra función <code>custom-set-…</code> es <code>custom-set-faces</code>. Esta función asigna varios tipos de fuentes. A través del tiempo, yo he asignado un considerable número de tipos. Algo de tiempo, yo las reseteo usando <code>customize</code>; otras veces, simplemente edito la expresión <code>custom-set-faces</code> en mi fichero <span class="file" >.emacs</span> en sí.</p>
<p>El segundo modo de personalizar tu <code>text-mode-hook</code> es asignarte a tí mismo en tu fichero <span class="file" >.emacs</span> usando código que no tiene nada que hacer con las funciones <code>custom-set-…</code>.</p>
<p>Cuando se hace esto, y después usa <code>customize</code>, se verá un mensaje que dice:</p>
<div class="example-block" >
<pre class="example" >CHANGED fuera de Personalizar; operando dentro aquí
puede ser no confiable.
</pre>
</div>
<p>Este mensaje es solo un aviso. Si se puede cliquear en el botón a</p>
<div class="example-block" >
<pre class="example" >Guárdalo para Futuras Sesiones
</pre>
</div>
<p>Emacs escribirá una expresión <code>custom-set-…</code> cerca del fin de tu fichero <span class="file" >.emacs</span> que será evaluado después de que tu expresión sea escrita a mano. Por esta razón, se sobreescribirá tu expresión escrita a mano. Ningún daño será hecho. Cuando se haga esto, sin embargo, ten cuidado para recordar que expresión está activa; si olvidas, puedes confundirte por tí mismo.</p>
<p>Tan largo como se recuerda donde los valores son configurados, no habrá problemas. En cualquier eventos, los valores son siempre configurados en tu fichero de inicialización, que es normalmente llamado <span class="file" >.emacs</span>.</p>
<p>Yo mismo hago un <code>customize</code> para cualquier cosa. Mayoritariamente, escribo expresiones por mí mismo.</p>
<p>Incidentalmente, para ser una definición concerniente más completa: <code>defsubst</code> define una función inline. La sintaxis es solo como esta de <code>defun</code>. <code>defconst</code> define un símbolo como una constante. El intento es que ningún programa o usuario cambiarían un valor asignado por <code>defconst</code>. (Se puede cambiar; el valor asignado es una variable; pero por favor no lo haga.)</p>
</div>
<h3 id="empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></h3>
<div class="hBody-3" >
<p>Cuando se abre Emacs, se carga tu fichero <span class="file" >.emacs</span> a menos que se cuente que no se especifique <samp>-q</samp> en la línea de comandos. (El comando <code>emacs -q</code> tu da un Emacs plano, fuera.)</p>
<p>Un fichero <span class="file" >.emacs</span> contiene expresiones Lisp. Con frecuencia, no hay más expresiones para configura valores; algunas veces esas son definiciones de funciones.</p>
<p>Vea la Seccion <a href="info:emacs#Init-File" >El Fichero de Inicio</a> <span class="file" >~/.emacs</span> en <em>El Manual GNU Emacs</em>, para una corta descripción de fichero de inicialización.</p>
<p>Este capítulo cubre algo del mismo suelo, pero es un paseo entre extractos desde un completo, largamente usado fichero <span class="file" >.emacs</span>––por mí.</p>
<p>La primera parte del fichero consiste en comentario: me recuerdo a mí mismo. Por ahora, yo recuerdo estas cosas, pero cuando empecé, no.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;;; fichero .emacs de Bob</span>
<span class="c1">; Robert J. Chassell</span>
<span class="c1">; 26 de Septiembre de 1985</span>
</code></pre>
<p>¡Mira en esta fecha! Yo empecé este fichero hace mucho tiempo. Yo he estado añadiendo cosas desde siempre.</p>
<pre class="code" ><code class="chroma" ><span class="c1">; Cada sección en este fichero es introducido por una</span>
<span class="c1">; línea empezando con cuatro puntos y comas y cada</span>
<span class="c1">; entrada es introducida por una línea empezando con</span>
<span class="c1">; tres puntos y comas.</span>
</code></pre>
<p>Esto describe las convenciones usuales para comentarios en Emacs Lisp. Cada cosa en una línea que sigue un punto y coma es un comentario. Dos, tres, y cuatro puntos y coma son usados como subsección y marcas de sección. (Vea la Seccion <q>Comentarios</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más comentarios.)</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;;; La Tecla de Ayuda</span>
<span class="c1">; Control-h es la tecla de ayuda;</span>
<span class="c1">; después escribiendo control-h, escribe una letra a</span>
<span class="c1">; indica el asunto acerca del que quieres ayuda.</span>
<span class="c1">; Para una explicación de la facilidad de ayuda,</span>
<span class="c1">; escribe control-h dos veces en una fila.</span>
</code></pre>
<p>Solo recuerda: escribe <kbd>C-h</kbd> dos veces para ayudar.</p>
<pre class="code" ><code class="chroma" ><span class="c1">; Para informarse acerca de cualquier modo, escribe control-h m</span>
<span class="c1">; mientras esté en este modo. Por ejemplo, para encontrar</span>
<span class="c1">; acerca del modo correo, introduce el modo correo y entonces</span>
<span class="c1">; escribe control-h m.</span>
</code></pre>
<p>‘Modo ayuda’, como yo llamo a esto, es muy útil. Usualmente, se cuenta todo lo que se necesita saber.</p>
<p>De acuerdo, no se necesitan incluir comentarios y ficheros como estos <span class="file" >.emacs</span>. Yo los incluí en el mío porque se olvida el Modo ayuda o las convenciones para comentarios––pero era capaz de recordar ver aquí recordármelo a mí mismo.</p>
</div>
<h3 id="modo-texto-y-auto-relleno" >Modo texto y auto relleno</h3>
<div class="hBody-3" >
<p>Ahora regresa a la parte que ‘vuelve’ al modo Texto y modo Auto Relleno.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Modo texto modo Auto Fill</span>
<span class="c1">;; Las siguiente dos líneas puestas en Emacs dentro de</span>
<span class="c1">;; modo Texto y en el modo Auto Fill, son para escritores que</span>
<span class="c1">;; quieren empezar a escribir prosa en vez de código.</span>
<span class="p">(</span><span class="nb">setq-default</span> <span class="nv">major-mode</span> <span class="ss">&#39;text-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;text-mode-hook</span> <span class="ss">&#39;turn-on-auto-fill</span><span class="p">)</span>
</code></pre>
<p>¡Aquí está la primera parte de este fichero <span class="file" >.emacs</span> que hace alguna cosa bajo recuerdo de un humano olvidado!</p>
<p>La primera de las dos líneas entre paréntesis cuentan a Emacs a cambiar al modo Texto que se encuentra un fichero, <em>a menos que</em> el fichero iría dentro de algún otro modo, tal como el modo C.</p>
<p>Cuando Emacs lee un fichero, eso parece la extensión al nombre del fichero. (La extensión es la parte que viene después de un <samp>.</samp>.) Si el fichero finaliza con una extensión <samp>.c</samp> o <samp>.h</samp> entonces Emacs cambia al modo C. También, Emacs parece al principio una línea no blanca del fichero; si la línea dice <samp>-*- C -*-</samp>, Emacs cambia al modo C. Emacs posee una lista de extensiones y especificaciones que usa automáticamente. Además, Emacs se ve cerca de la última página por buffer, “lista variables locales”.</p>
<p>Mira las secciones “Cómo los Modos Mayores son Elegidos” y “Variables Locales en Fichero” en <em>El Manual GNU Emacs</em>.</p>
<p>Ahora, regresa al fichero <span class="file" >.emacs</span>.</p>
<p>Aquí está la línea de nuevo; ¿cómo funciona?</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">major-mode</span> <span class="ss">&#39;text-mode</span><span class="p">)</span>
</code></pre>
<p>Esta línea es un resumen, pero completa la expresión Emacs Lisp.</p>
<p>Ya estamos familiarizados con <code>setq</code>. Eso asigna la siguiente variable, <code>major-mode</code>, al subsiguiente valor, que es <code>text-mode</code>. La marca de cita simple antes de <code>text-mode</code> cuenta a Emacs como tratar directamente con el símbolo, no con cualquier cosa que pudiera existir. Vea la Seccion <a href="Configurando-el-Valor-de-una-Variable" >Configurando el Valor de una Variable</a>, por un recuerdo de como <code>setq</code> funciona. El principal punto es que no hay diferencia entre el procedimiento que se usa para asignar un valor en su fichero <span class="file" >.emacs</span> y el procedimiento que se usa en cualquier lugar más en Emacs.</p>
<p>Aquí está la siguiente línea:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;text-mode-hook</span> <span class="ss">&#39;turn-on-auto-fill</span><span class="p">)</span>
</code></pre>
<p>En esta línea, el comando <code>add-hook</code> añade <code>turn-on-auto-fill</code> para la variable.</p>
<p>¡<code>turn-on-auto-fill</code> es el nombre de un programa, que se adivina!, cambia al modo Auto Fill.</p>
<p>Cada vez que Emacs cambia al modo texto, Emacs ejecuta el comando ‘hooked’ dentro de modo Texto. Así que cada vez que Emacs cambia al modo Texto, Emacs también cambia al modo de autoajuste.</p>
<p>En breve, la primera línea causa a Emacs a entrar en modo Texto cuando se edite un fichero, a menos que la extensión del nombre del fichero, una línea no en blanco, variables locales para contar a Emacs de otro modo.</p>
<p>El modo texto entre otras acciones, asigna la tabla de sintaxis para trabajar adecuadamente a escritores. En modo texto, Emacs considera un apóstrofe como parte de una palabra como una letra; pero Emacs no considera un período o un espacio como parte de una palabra. De este modo, <kbd>M-f</kbd> se mueve hacia tí a través de <samp>eso</samp>. Por otro lado, en modo C, <kbd>M-f</kbd> para solo después del <samp>t</samp> de <samp>eso</samp>.</p>
<p>La segunda línea causa que Emacs active el modo Auto Fill cuando cambia al modo Texto. En modo Auto Fill, Emacs automáticamente rompe una línea que es demasiado amplio y trae la parte excesivamente amplia de la línea de debajo a la siguiente línea. Emacs rompe líneas entre palabras con ellas.</p>
<p>Cuando el modo Auto Fill está desactivado, las líneas continúan a la derecha como se escriben. Dependiendo de como configuras el valor de <code>truncate-lines</code>, las palabras que se escribe si desaparecen al lado derecho de la pantalla, o lo demás son mostradas, en un modo feo e ilegible, como una línea de continuación en la pantalla.</p>
<p>Además, en esta parte de mi fichero <span class="file" >.emacs</span>, yo cuento a Emacs el ajuste de comandos para insertar dos espacios después de dos puntos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">colon-double-space</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="alias-de-correo" >Alias de correo</h3>
<div class="hBody-3" >
<p>Aquí hay un <code>setq</code> que ‘activa’ el alias de correo, para más ocasiones.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Modo Correo</span>
<span class="c1">; Para entrar en el modo correo, escribe ‘C-x m’</span>
<span class="c1">; Para introducir RMAIL (para leer el correo),</span>
<span class="c1">; escribe ‘M-x rmail’</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">mail-aliases</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>Este comando <code>setq</code> asigna el valor de la variable <code>mail-aliases</code> al <code>t</code>. Desde que <code>t</code> significa verdadero, la línea dice, en efecto, “Sí uso alias de correo.”</p>
<p>Los alias de correo son nombres cortos convenientes para largas direcciones de correo o para listas de direcciones de correo. El fichero donde guardar tus ‘aliases’ es <span class="file" >~/.mailrc</span>. Se escribe un alias como este:</p>
<div class="example-block" >
<pre class="example" >alias geo george@@foobar.wiz.edu
</pre>
</div>
<p>Cuando se escribe un mensaje a Jorge, la dirección a <samp>geo</samp>; el correo automáticamente expandirá <samp>geo</samp> a la dirección completa.</p>
</div>
<h3 id="indentar-modo-de-tabulaciones" >Indentar modo de tabulaciones</h3>
<div class="hBody-3" >
<p>Por defecto, Emacs inserta tabulaciones en lugar en múltiples espacios cuando se formatea una región. (Por ejemplo, se podrían indentar muchas líneas de texto todo a la vez con el comando <code>indent-region</code>.) Los tabuladores se ven bien en un terminal o con impresión ordinaria, pero ellos producen mala salida de indentación cuando se usa T<sub>E</sub>X o Texinfo puesto que T<sub>E</sub>X ignora tabuladores.</p>
<p>Lo siguiente desactiva el modo de Indentar Tabulaciones:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Prevenir Tabulaciones Extrañas</span>
<span class="p">(</span><span class="nb">setq-default</span> <span class="nv">indent-tabs-mode</span> <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>Note que esta línea usa <code>setq-default</code> en vez de el comando <code>setq</code> que hemos visto antes. El comando <code>setq-default</code> asigna valores solo en búfers que no tienen sus propios valores locales para la variable.</p>
<p>Ver secciones “Tabuladores versus Espacios” y “Variables Locales en Ficheros” en <em>El Manual de GNU Emacs</em>.</p>
</div>
<h3 id="atajos-de-teclado" >Atajos de teclado</h3>
<div class="hBody-3" >
<p>Ahora para algunos atajos personales:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Compara ventanas</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-cw&#34;</span> <span class="ss">&#39;compare-windows</span><span class="p">)</span>
</code></pre>
<p><code>compare-windows</code> es un comando excelente que compara el texto en tu ventana actual con texto de la siguiente ventana. Eso hace la comparación empezando al punto en cada ventana, moviendo a través del texto en cada ventana tan lejos como ellos asocian. Yo uso este comando todo el tiempo.</p>
<p>Esto también muestra como configurar una tecla globalmente, para todo los modos</p>
<p>El comando es <code>global-set-key</code>. Es seguido por el atajo. En un fichero <span class="file" >.emacs</span>, el atajo es escrito como se ve: <code>\C-c</code> que se asocia a ‘control-c’, que significa ‘presionar la tecla de control y la tecla <kbd>c</kbd> al mismo tiempo’. La <code>w</code> significa ‘presionar la tecla <kbd>w</kbd>’. El atajo es rodeado por dobles comillas. En la documentación, se escribiría esto como <kbd>C-c w</kbd>. (Si estuviera asociando una tecla <kbd>META</kbd>, tal como <kbd>M-c</kbd>, en vez de una tecla de <kbd>CTRL</kbd>, se escribiría <code>\M-c</code> en su fichero <span class="file" >.emacs</span>. Vea la Seccion <q>Reasociando Teclas en Su Fichero Init</q> en <em>El Manual de GNU Emacs</em>, para más detalles.)</p>
<p>El comando invocado por las teclas es <code>compare-windows</code>. Note que <code>compare-windows</code> es precedido por una comilla simple; de otro modo, Emacs primero intentaría evaluar el símbolo para determinar su valor.</p>
<p>Estas tres cosas, las marcas de dobles comillas, la barra invertida antes de la <samp>C</samp>, y la marca de comilla simple son partes necesarias de atajos de teclado que tiendo a olvidar. Afortunadamente, he llegado a recordar que miraría mi fichero <span class="file" >.emacs</span> existente, y lo adaptaría a lo que hay.</p>
<p>Como para el atajo en sí: <kbd>C-c w</kbd>, combina la tecla prefija, <kbd>C-c</kbd>, con un caracter simple, en este caso, <kbd>w</kbd>. Este conjunto de teclas, <kbd>C-c</kbd> seguido por un caracter simple, es estrictamente reservado para un uso propio individual. (Esto se llama teclas ‘propias’, puesto que estas son para su propio uso). Siempre sería capaz de crear tal atajo para el uso propio sin pisar fuerte en algún atajo más. Si siempre se escribe una extensión a Emacs, por favor, evite tomar cualquiera de estas teclas para uso público. Se cree que una tecla como <kbd>C-c C-w</kbd> en vez de eso. De otra manera, ejecutará sin sus ‘propias’ teclas.</p>
<p>Aquí hay otro atajo, con un comentario:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Atajo para ‘occur’</span>
<span class="c1">; Yo uso mucho occur, así permite asignarlo a una tecla:</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-co&#34;</span> <span class="ss">&#39;occur</span><span class="p">)</span>
</code></pre>
<p>El comando <code>occur</code> muestra todas las líneas en el buffer actual que contiene un emparejamiento para una expresión regular. Asociar las líneas que se muestran en un búfer llamado <span class="file" >*Occur*</span>. Este buffer sirve como un menu para saltar a ocurrencias.</p>
<p>Aquí se muestra como desasignar una tecla, así no funciona:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Desasociar ‘C-x f’</span>
<span class="p">(</span><span class="nv">global-unset-key</span> <span class="s">&#34;\C-xf&#34;</span><span class="p">)</span>
</code></pre>
<p>Hay una razón para esta no asociación: Yo encontré inadvertidamente escrito <kbd>C-x f</kbd> cuando significó escribir <kbd>C-x C-f</kbd>. En vez de encontrar un fichero, como se pretende, accidentalmente asigna el ancho para el fichero lleno, casi siempre a un tamaño que no quería. Puesto que duramente se reseteó mi ancho por defecto, yo simplemente disocié la tecla.</p>
<p>Lo siguiente reasocia una tecla existente:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Reasocia ‘C-x C-b’ al ‘buffer-menu’</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-x\C-b&#34;</span> <span class="ss">&#39;buffer-menu</span><span class="p">)</span>
</code></pre>
<p>Por defecto, <kbd>C-x C-b</kbd> ejecute el comando <code>list-buffers</code>. Este comando lista sus buffers en <em>otra</em> ventana. Desde que casi siempre se quiere hacer alguna cosa en esta ventana, se prefiere el comando <code>buffer-menu</code>, que no solo lista los buffers, pero mueve el punto dentro de esta ventana.</p>
</div>
<h3 id="mapas-de-teclado" >Mapas de teclado</h3>
<div class="hBody-3" >
<p>Emacs usa <dfn>keymaps</dfn> para grabar qué teclas llaman a qué comandos. Cuando se use <code>global-set-key</code> para asignar los atajos de teclados a un simple comando en todo <code>current-global-map</code>.</p>
<p>Modos específicos, tales como modo C o modo Texto, tiene sus propios mapas de teclado; mapas de teclado de modo específico sobreescribe el mapa global que es compartido por todos los buffers.</p>
<p>La función <code>global-set-key</code> asocia, o reasocia, el mapa de teclado global. Por ejemplo, las siguientes asociaciones la tecla <kbd>C-x C-b</kbd> a la función <code>buffer-menu</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-x\C-b&#34;</span> <span class="ss">&#39;buffer-menu</span><span class="p">)</span>
</code></pre>
<p>Mapas de teclado específico de modo son asociados usando la función <code>define-key</code>, que toma un mapa de teclado específico como un argumento, tan bien como la tecla y el comando. Por ejemplo, mi fichero <span class="file" >.emacs</span> contiene la siguiente expresión asociada al comando <code>texinfo-insert-@group</code> comando a <kbd>C-c C-c g</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">define-key</span> <span class="nv">texinfo-mode-map</span> <span class="s">&#34;\C-c\C-cg&#34;</span> <span class="ss">&#39;texinfo-insert-@@group</span><span class="p">)</span>
</code></pre>
<p>La función <code>texinfo-insert-@group</code> en sí es una pequeña extensión del modo Texinfo que inserta <samp>@group</samp> dentro de un fichero Texinfo. Se usa este comando todo el tiempo y se prefieren escribir los tres atajos <kbd>C-c C-c g</kbd> en vez de los seis atajos <kbd>@ g r o u p</kbd>. (<samp>@group</samp> y su asociación <samp>@end group</samp> son comandos que guarda todo el texto cerrado junto a una página; muchos ejemplos multi-línea en este libro están rodeados por <samp>@group … @end group</samp>.)</p>
<p>Aquí está la definición de función <code>texinfo-insert-@group</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">texinfo-insert-@@group</span> <span class="p">()</span>
  <span class="s">&#34;Inserta la cadena @@group en un búfer Texinfo.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">beginning-of-line</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;@@group\n&#34;</span><span class="p">))</span>
</code></pre>
<p>(De acuerdo, podría haber usado el modo Abbrev para dejar de escribir, en vez de escribir una función para insertar una palabra; pero prefiero atajos de teclado consitentes con otro modo Texinfo para atajos de teclado.)</p>
<p>Verá numerosas expresiones <code>define-key</code> en <span class="file" >loaddefs.el</span> tan bien como en varios modos de librerías, tal como <span class="file" >cc-mode.el</span> y <span class="file" >lisp-mode.el</span>.</p>
<p>Vea la Seccion <q>Personalizando Atajos de Teclado</q> en <em>El Manual GNU Emacs</em>, y <q>Mapas de Teclado</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más información acerca de mapas de teclado.</p>
</div>
<h3 id="cargando-ficheros" >Cargando ficheros</h3>
<div class="hBody-3" >
<p>Muchas personas en la comunidad de GNU Emacs han escrito extensiones a Emacs. Hace tiempo, que estas extensiones son con frecuencia incluidas en las nuevas entregas <em>releases</em>. Por ejemplo, los paquetes Calendario y Diario son ahora parte del estándar GNU Emacs, como es Calc.</p>
<p>Se puede usar un comando <code>load</code> para evaluar un fichero completo que significa instalar todas las funciones y variables en el fichero Emacs. Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">load</span> <span class="s">&#34;~/emacs/slowsplit&#34;</span><span class="p">)</span>
</code></pre>
<p>Esto evalúa, es decir, carga, el fichero <span class="file" >slowsplit.el</span> o si eso existe, lo más rápido, el fichero compilado <span class="file" >slowsplit.elc</span> desde el subdirectorio <span class="file" >emacs</span> del directorio home. El fichero contiene la función <code>split-window-quietly</code>, que John Robinson escribió en 1989.</p>
<p>La función <code>split-window-quietly</code> divide una ventana con el mínimo de redisplay. Yo lo instalé en 1989 porque trabajó bien con los terminales de 1200 baudios que entonces estaba usando. Ahora, ocasionalmente vengo a través de una conexión lenta, pero continúa usando la función porque me gusta el camino que deja arriba del búfer en el bajo de las nuevas ventanas y arriba en la ventana superior.</p>
<p>Para reemplazar el atajo de teclado por defecto <code>split-window-vertically</code>, se debe también desasignar esta tecla y asociar las teclas a <code>split-window-quietly</code>, como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-unset-key</span> <span class="s">&#34;\C-x2&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-x2&#34;</span> <span class="ss">&#39;split-window-quietly</span><span class="p">)</span>
</code></pre>
<p>Si se cargan muchas extensiones, como yo hago, entonces en vez de especificar la posición exacta del fichero, como se muestra arriba, se puede especificar que directorio como parte del <code>load-path</code> de Emacs. Entonces, cuando Emacs carga un fichero, buscará que directorio tan bien como su lista por defecto de directorios. (La lista por defecto es especificada en <span class="file" >paths.h</span> cuando Emacs se construye.)</p>
<p>El comando siguiente añade tu directorio <span class="file" >~/emacs</span> a la ruta existente:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Ruta Emacs</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">load-path</span> <span class="p">(</span><span class="nf">cons</span> <span class="s">&#34;~/emacs&#34;</span> <span class="nv">load-path</span><span class="p">))</span>
</code></pre>
<p>Incidentalmente, <code>load-library</code> es un interfaz interactivo a la función <code>load</code>. La función se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">load-library</span> <span class="p">(</span><span class="nv">library</span><span class="p">)</span>
  <span class="s">&#34;Carga la librería llamada LIBRARY.
</span><span class="s">Esto es una interfaz a la función ‘load’.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span>
   <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">completing-read</span> <span class="s">&#34;Carga la librería: &#34;</span>
                          <span class="p">(</span><span class="nv">apply-partially</span> <span class="ss">&#39;locate-file-completion-table</span>
                                           <span class="nv">load-path</span>
                                           <span class="p">(</span><span class="nf">get-load-suffixes</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">load</span> <span class="nv">library</span><span class="p">))</span>
</code></pre>
<p>El nombre de la función, <code>load-libray</code>, viene desde el uso de ‘library’ como un sinónimo para ‘file’. La fuente para el comando <code>load-library</code> está en la librería <span class="file" >files.el</span>.</p>
<p>Otro comando interactivo que hace un trabajo ligeramente diferente es <code>load-file</code>. Vea la Seccion <q>Librerías de Código Lisp para Emacs</q> en <em>El Manual GNU Emacs</em>, para información en la distinción entre <code>load-library</code> y este comando.</p>
</div>
<h3 id="autoloading" >Autoloading</h3>
<div class="hBody-3" >
<p>En vez de instalar una función cargando el fichero que lo contiene, o evaluando la definición de función, se puede hacer la función disponible pero actualmente no se instala hasta la primera vez llamada. Este proceso se llama <dfn>autocarga</dfn> (<em>autoloading</em>).</p>
<p>Cuando se ejecuta una función de autocarga, Emacs automáticamente evalúa el fichero que contiene la definición, y entonces llama a la función.</p>
<p>Emacs empieza rápido con funciones de autocarga, puesto que sus librerías no se cargan bien; pero si necesita esperar un momento cuando su primer uso tal como una función, mientras que el fichero que lo contiene se evalúa.</p>
<p>Raramente las funciones usadas son frecuentemente autocargadas. La librería <span class="file" >loaddefs.el</span> coniene cientos de funciones autocargadas, desde <code>bookmark-set</code> a <code>wordstar-mode</code>. Si se usa una función ‘rara’ frecuentemente, se debería cargar este fichero de función con una expresión de <code>load</code> en tu fichero <span class="file" >.emacs</span>.</p>
<p>En mi fichero <span class="file" >.emacs</span>, se cargan 14 librerías que contienen funciones que de otro modo serían autocargadas. (Actualmente, eso habría sido mejor para incluir estos ficheros en mi Emacs ‘volcado’, pero se olvida. Véase Sección <q>Construyendo Emacs</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, y el fichero <span class="file" >INSTALL</span> para más acerca de volcados.)</p>
<p>Se puede también querer incluir expresiones autocargadas en tu fichero <span class="file" >.emacs</span>. <code>autoload</code> es una función construida que toma cinco argumento, los tres finales de los que son opcionales. El primer argumento es el nombre de la función para ser autocargada. El segundo es el nombre del fichero para ser cargado. El tercer argumento es documentación para la función, y el cuarto cuenta si la función puede ser llamada interactivmente. El quinto argumento cuenta que tipo de objeto––<code>autoload</code> puede manejar un mapa de teclado o macro tan bien como una función (por defecto es una función).</p>
<p>Aquí hay un ejemplo típico:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">autoload</span> <span class="ss">&#39;html-helper-mode</span>
  <span class="s">&#34;html-helper-mode&#34;</span> <span class="s">&#34;Editar documentos HTML&#34;</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>(<code>html-helper-mode</code> es una vieja alternativa a <code>html-mode</code>, que es una parte estándar de la distribución.)</p>
<p>Esta expresión autocarga la función <code>html-helper-mode</code>. Esto se toma desde el fichero <span class="file" >html-helper-mode-el</span> (o desde la versión compilada <span class="file" >html-helper-mode.elc</span>, si eso existe). El fichero debe ser localizado en un directorio específico por <code>load-path</code>. La documentación dice que esto es un modo para ayudar a editar documentos escritos en Lenguaje de Marcas de Hiper Texto. Se puede llamar este modo interactivamente escribiendo <kbd>M-x html-helper-mode</kbd>. (Se necesitan duplicar las funciones regulares de documentación en la expresión de autocarga porque la función regular no está todavía cargada, así su documentación no está disponible.)</p>
<p>Vea la Seccion <q>Autocarga</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.</p>
</div>
<h3 id="una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></h3>
<div class="hBody-3" >
<p>Aquí hay una simple extensión a Emacs que mueve el punto de línea arriba de la ventana. Yo uso esto todo el tiempo, para hacer fácil de leer el texto.</p>
<p>Se puede poner el siguiente código dentro de un fichero separado y entonce cargarlo desde tu fichero <span class="file" >.emacs</span>, o se puede incluir con tu fichero <span class="file" >.emacs</span>.</p>
<p>Aquí está la definición</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Línea a lo alto de la ventana;</span>
<span class="c1">;;; reemplaza tres secuencias de atajos de teclado  C-u 0 C-l</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">line-to-top-of-window</span> <span class="p">()</span>
  <span class="s">&#34;Mueve la línea que apunta a lo alto de la ventana.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">recenter</span> <span class="mi">0</span><span class="p">))</span>
</code></pre>
<p>Ahora el atajo.</p>
<p>En estos días, las teclas de función así como los eventos del ratón y caracteres no <code>ascii</code> son escritos con corchetes, sin marcas de citas. (En Emacs versión 18 y anteriores, se tenía que escribir diferentes teclas de función asignadas por cada diferente creación del terminal.)</p>
<p>Se puede asociar <code>line-to-top-of-window</code> a la tecla de función <kbd>F6</kbd> así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">[</span><span class="nv">f6</span><span class="p">]</span> <span class="ss">&#39;line-to-top-of-window</span><span class="p">)</span>
</code></pre>
<p>Para más información, mira <q>Reasociando Teclas en tu fichero init</q> en <em>El Manual GNU Emacs</em>.</p>
<p>Si ejecutas dos versiones de GNU Emacs, tal como las versiones 22 y 23, y usas un fichero <span class="file" >.emacs</span>, se puede seleccionar qué código evalúa el siguiente condicional:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">cond</span>
 <span class="p">((</span><span class="nf">=</span> <span class="mi">22</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
  <span class="c1">;; evalúa la version 22</span>
  <span class="p">(</span> <span class="err">…</span> <span class="p">))</span>
 <span class="p">((</span><span class="nf">=</span> <span class="mi">23</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
  <span class="c1">;; evalúa la version 23</span>
  <span class="p">(</span> <span class="err">…</span> <span class="p">)))</span>
</code></pre>
<p>Por ejemplo, en versiones más recientes se ocultan los cursores por defecto. Si se odia tal ocultación se escribe lo siguiente en mi fichero <span class="file" >.emacs</span><span class="note" ><sup><a href="#15" >15</a></sup></span>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">emacs-major-version</span> <span class="mi">21</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">blink-cursor-mode</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1">;; Inserta la nueva línea cuando se presiona ‘C-n’ (next-line)</span>
  <span class="c1">;; al fin del búfer</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">next-line-add-newlines</span> <span class="no">t</span><span class="p">)</span>
  <span class="c1">;; Cambia la imagen viendo</span>
  <span class="p">(</span><span class="nv">auto-image-file-mode</span> <span class="no">t</span><span class="p">)</span>
  <span class="c1">;; Activa la barra de menu (esta barra tiene texto)</span>
  <span class="c1">;; (Usa un argumento numérico para activarlo)</span>
  <span class="p">(</span><span class="nv">menu-bar-mode</span> <span class="mi">1</span><span class="p">)</span>
   <span class="c1">;; Desactiva la barra de herramientas (esta barra tiene iconos)</span>
   <span class="c1">;; (Usa argumentos numéricos para activarlo)</span>
   <span class="p">(</span><span class="nv">tool-bar-mode</span> <span class="no">nil</span><span class="p">)</span>
  <span class="c1">;; Desactiva el modo tooltip para la tool bar</span>
  <span class="c1">;; (Este modo causa explicaciones de iconos al pop up)</span>
  <span class="c1">;; (Usa el argumento numérico para activarlo)</span>
  <span class="p">(</span><span class="nv">tooltip-mode</span> <span class="no">nil</span><span class="p">)</span>
  <span class="c1">;; Si los tooltips activados, crea consejos aparecen en el prompt</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">tooltip-delay</span> <span class="mf">0.1</span><span class="p">)</span>  <span class="c1">; por defecto es de 0.7 segundos</span>
   <span class="p">)</span>
</code></pre>
</div>
<h3 id="colores-x11" >Colores X11</h3>
<div class="hBody-3" >
<p>Se pueden especificar colores cuando se usa Emacs con el Sistema de Ventanas X del MIT.</p>
<p>Si disgustan los colores por defecto y especifica unos propios.</p>
<p>Aquí están las expresiones en un fichero <span class="file" >.emacs</span> que establecen los valores:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Asigna el color del cursor</span>
<span class="p">(</span><span class="nv">set-cursor-color</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>

<span class="c1">;; Asigna el color del ratón</span>
<span class="p">(</span><span class="nv">set-mouse-color</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>

<span class="c1">;; Asigna foreground y background</span>
<span class="p">(</span><span class="nv">set-foreground-color</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-background-color</span> <span class="s">&#34;darkblue&#34;</span><span class="p">)</span>

<span class="c1">;;; Asigna colores para isearch y drag</span>
<span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;highlight</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;highlight</span> <span class="s">&#34;blue&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;region</span> <span class="s">&#34;cyan&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;region</span> <span class="s">&#34;blue&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;secondary-selection</span> <span class="s">&#34;skyblue&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;secondary-selection</span> <span class="s">&#34;darkblue&#34;</span><span class="p">)</span>

<span class="c1">;; Asigna colores al calendario</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">calendar-load-hook</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span>
         <span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;diary-face</span>   <span class="s">&#34;skyblue&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;holiday-face</span> <span class="s">&#34;slate blue&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;holiday-face</span> <span class="s">&#34;white&#34;</span><span class="p">)))</span>
</code></pre>
<p>Las varias sombras de azul disparan mi ojo y me preveen de ver la ventana desplegada.</p>
<p>Alternativamente, se podrían haber configurado mis especificaciones en varios ficheros inicialización de X. Por ejemplo, se podría asignar el foreground, background, cursor y puntero (por ej., ratón) colores en mi fichero <span class="file" >~/.Xresources</span> como esto:</p>
<div class="example-block" >
<pre class="example" >Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
</pre>
</div>
<p>En cualquier evento que no es parte de Emacs, se asigna el color raíz de mi ventana X en mi fichero <span class="file" >~/.xinitrc</span>, como este<span class="note" ><sup><a href="#16" >16</a></sup></span></p>
<div class="example-block" >
<pre class="example" >xsetroot -solid Navy -fg white &amp;
</pre>
</div>
</div>
<h3 id="configuraciones-misceláneas-para-un-fichero-.emacs" >Configuraciones misceláneas para un fichero <span class="file" >.emacs</span></h3>
<div class="hBody-3" >
<p>Aquí hay unas pocas configuraciones misceláneas:</p>
<ul>
<li>
<p>Asigna la forma y color del ratón del cursor:</p>
<pre class="code" ><code class="chroma" ><span class="c1">; Formas de Cursor están definidas en</span>
<span class="c1">; ‘/usr/include/X11/cursorfont.h’;</span>
<span class="c1">; por ejemplo, el cursor ‘objetivo’ es número 128;</span>
<span class="c1">; el cursor ‘top_left_arrow’ es el número 132.</span>

<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">mpointer</span> <span class="p">(</span><span class="nf">x-get-resource</span> <span class="s">&#34;*mpointer&#34;</span>
                                <span class="s">&#34;*emacs*mpointer&#34;</span><span class="p">)))</span>
  <span class="c1">;; Si no se ha asignado tu puntero de ratón</span>
  <span class="c1">;; entonces asignalo, de otro modo, déjalo así:</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">mpointer</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">mpointer</span> <span class="s">&#34;132&#34;</span><span class="p">))</span> <span class="c1">; top_left_arrow</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">x-pointer-shape</span> <span class="p">(</span><span class="nv">string-to-int</span> <span class="nv">mpointer</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">set-mouse-color</span> <span class="s">&#34;white&#34;</span><span class="p">))</span>
</code></pre>
</li>
<li>
<p>O se pueden asignar los valores de una variedad de funcionalidades en una alist, como esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq-default</span>
 <span class="nv">default-frame-alist</span>
 <span class="o">&#39;</span><span class="p">((</span><span class="nv">cursor-color</span> <span class="o">.</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">mouse-color</span> <span class="o">.</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">foreground-color</span> <span class="o">.</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">background-color</span> <span class="o">.</span> <span class="s">&#34;DodgerBlue4&#34;</span><span class="p">)</span>
   <span class="c1">;; (cursor-type . bar)</span>
   <span class="p">(</span><span class="nv">cursor-type</span> <span class="o">.</span> <span class="nv">box</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">tool-bar-lines</span> <span class="o">.</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">menu-bar-lines</span> <span class="o">.</span> <span class="mi">1</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">width</span> <span class="o">.</span> <span class="mi">80</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">height</span> <span class="o">.</span> <span class="mi">58</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">font</span> <span class="o">.</span>
         <span class="s">&#34;-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1&#34;</span><span class="p">)</span>
   <span class="p">))</span>
</code></pre>
</li>
<li>
<p>Convierte <kbd><kbd>CTRL</kbd>-h</kbd> dentro <kbd>DEL</kbd> y <kbd>DEL</kbd> dentro de <kbd><kbd>CTRL</kbd>-h</kbd>.</p>
<p>(Algunos viejos teclados lo necesitan, aunque yo no he visto el problema recientemente.)</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Traducir ‘C-h’ a &lt;DEL&gt;.</span>
<span class="c1">; (keyboard-translate ?\C-h ?\C-?)</span>

<span class="c1">;; Traducir &lt;DEL&gt; a ‘C-h’.</span>
<span class="p">(</span><span class="nv">keyboard-translate</span> <span class="sc">?\C</span><span class="nv">-?</span> <span class="sc">?\C</span><span class="nv">-h</span><span class="p">)</span>
</code></pre>
</li>
<li>
<p>¡Desactiva un cursor oculto!</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;blink-cursor-mode</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">blink-cursor-mode</span> <span class="mi">-1</span><span class="p">))</span>
</code></pre>
<p>o empieza GNU Emacs con el comando <code>emacs -nbc</code>.</p>
</li>
<li>
<p>Cuando se usa ‘grep’</p>
<dl>
<dt><samp>-i</samp></dt>
<dd>
<p>Ignore distinciones de letras</p>
</dd>
<dt><samp>-n</samp></dt>
<dd>
<p>El prefijo de cada línea de la salida con el número de líneas</p>
</dd>
<dt><samp>-H</samp></dt>
<dd>
<p>Imprime el nombre de fichero para cada cadena encontrada.</p>
</dd>
<dt><samp>-e</samp></dt>
<dd>
<p>Protege patrones empezando con un caracter de guión, <samp>-</samp></p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">grep-command</span> <span class="s">&#34;grep -i -nH -e &#34;</span><span class="p">)</span>
</code></pre>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Encuentra un búfer existente, incluso si eso tiene un nombre diferente</dt>
<dd>
<p>Esto evita problemas con enlaces simbólicos.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">find-file-existing-other-name</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
</dd>
</dl>
<ul>
<li>
<p>Configura tu entorno de lenguaje y el método de entrada por defecto</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">set-language-environment</span> <span class="s">&#34;latin-1&#34;</span><span class="p">)</span>
<span class="c1">;; Recuerda que se puede habilitar o deshabilitar el texto de lenguaje</span>
<span class="c1">;; multilingüe con el comando @c{toggle-input-method&#39;} (@k{C-\})</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">default-input-method</span> <span class="s">&#34;latin-1-prefix&#34;</span><span class="p">)</span>
</code></pre>
<p>Si se quiere escribir con el caracter Chino ‘GB’, asigna esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">set-language-environment</span> <span class="s">&#34;Chinese-GB&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">default-input-method</span> <span class="s">&#34;chinese-tonepy&#34;</span><span class="p">)</span>
</code></pre>
</li>
</ul>
</div>
<h4 id="arreglando-atajos-de-teclados" >Arreglando Atajos de Teclados</h4>
<div class="hBody-4" >
<p>Algunos sistemas asocian teclas de maneras no agradables. Algunas veces, por ejemplo, la tecla <kbd>CTRL</kbd> en un modo perverso en vez de la lejanía a la izquierda de la fila.</p>
<p>Normalmente, cuando las personas arreglan estos atajos de teclado, no se cambia su fichero <span class="file" >~/.emacs</span>. En vez de eso, se asocian las teclas apropiadas en sus consolas con los comandos <code>loadkeys</code> o <code>install-keymap</code> en su script de inicio y entonces incluyen comandos <code>xmodmap</code> en su fichero <span class="file" >.xinitrc</span> o <span class="file" >.Xsession</span> para X Windows.</p>
<p>Para un script de inicio:</p>
<div class="example-block" >
<pre class="example" >loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

or

install-keymap emacs2
</pre>
</div>
<p>Para un fichero <span class="file" >.xinitrc</span> o un fichero <span class="file" >.Xsession</span> cuando la tecla <kbd>Caps Lock</kbd> es que tan lejos de la fila del home:</p>
<div class="example-block" >
<pre class="example" ># Asocia la tecla etiquetada ‘Caps Lock’ a ‘Control’
# (Tal como un interfaz de usuario roto sugiere que el teclado hecho
# piensa que los ordenadores son máquinas de escribir desde 1885.)

xmodmap -e &#34;clear Lock&#34;
xmodmap -e &#34;add Control = Caps_Lock&#34;
</pre>
</div>
<p>En un <span class="file" >.xinitrc</span> o <span class="file" >.Xsession</span>, para convertir una tecla <kbd>ALT</kbd> a una tecla <kbd>META</kbd>:</p>
<div class="example-block" >
<pre class="example" ># Algunos teclados mal diseñados tienen una tecla etiquetada ALT y no Meta
xmodmap -e &#34;keysym Alt_L = Meta_L Alt_L&#34;
</pre>
</div>
</div>
<h3 id="una-línea-modificada" >Una línea modificada</h3>
<div class="hBody-3" >
<p>Finalmente, una funcionalidad que realmente me gusta: un mode line modificado.</p>
<p>Cuando se trabaja a través de una red, se olvida que máquina se está usando. También, se tiende a perder la traza de donde se está, y a qué línea se apunta.</p>
<p>Así se resetea mi mode line para que se parezca a esto:</p>
<div class="example-block" >
<pre class="example" >::-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
</pre>
</div>
<p>Estoy visitando un fichero llamado <span class="file" >foo.texi</span>, en mi máquina <span class="file" >rattlesnake</span> en mi búfer <span class="file" >/home/bob</span>. Yo estoy en la línea 1, en modo Texinfo, y estoy arriba del búfer.</p>
<p>Mi fichero <span class="file" >.emacs</span> tiene una sección que se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Asigna un Mode Line que nos cuente que máquina, que directorio,</span>
<span class="c1">;; y que línea estoy on, más la información de client.</span>
<span class="p">(</span><span class="nb">setq-default</span> <span class="nv">mode-line-format</span>
 <span class="p">(</span><span class="nb">quote</span>
  <span class="p">(</span><span class="o">#(</span><span class="s">&#34;-&#34;</span> <span class="mi">0</span> <span class="mi">1</span>
     <span class="p">(</span><span class="nv">help-echo</span>
      <span class="s">&#34;mouse-1: select window, mouse-2: delete others ...&#34;</span><span class="p">))</span>
   <span class="nv">mode-line-mule-info</span>
   <span class="nv">mode-line-modified</span>
   <span class="nv">mode-line-frame-identification</span>
   <span class="s">&#34;    &#34;</span>
   <span class="nv">mode-line-buffer-identification</span>
   <span class="s">&#34;    &#34;</span>
   <span class="p">(</span><span class="nb">:eval</span> <span class="p">(</span><span class="nf">substring</span>
           <span class="p">(</span><span class="nf">system-name</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">string-match</span> <span class="s">&#34;\\..+&#34;</span> <span class="p">(</span><span class="nf">system-name</span><span class="p">))))</span>
   <span class="s">&#34;:&#34;</span>
   <span class="nv">default-directory</span>
   <span class="o">#(</span><span class="s">&#34; &#34;</span> <span class="mi">0</span> <span class="mi">1</span>
     <span class="p">(</span><span class="nv">help-echo</span>
      <span class="s">&#34;mouse-1: select window, mouse-2: delete others ...&#34;</span><span class="p">))</span>
   <span class="p">(</span><span class="nv">line-number-mode</span> <span class="s">&#34; Line %l &#34;</span><span class="p">)</span>
   <span class="nv">global-mode-string</span>
   <span class="o">#(</span><span class="s">&#34;   %[(&#34;</span> <span class="mi">0</span> <span class="mi">6</span>
     <span class="p">(</span><span class="nv">help-echo</span>
      <span class="s">&#34;mouse-1: select window, mouse-2: delete others ...&#34;</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">:eval</span> <span class="p">(</span><span class="nv">mode-line-mode-name</span><span class="p">))</span>
   <span class="nv">mode-line-process</span>
   <span class="nv">minor-mode-alist</span>
   <span class="o">#(</span><span class="s">&#34;%n&#34;</span> <span class="mi">0</span> <span class="mi">2</span> <span class="p">(</span><span class="nv">help-echo</span> <span class="s">&#34;mouse-2: widen&#34;</span> <span class="nv">local-map</span> <span class="p">(</span><span class="nv">keymap</span> <span class="o">...</span><span class="p">)))</span>
   <span class="s">&#34;)%] &#34;</span>
   <span class="p">(</span><span class="mi">-3</span> <span class="o">.</span> <span class="s">&#34;%P&#34;</span><span class="p">)</span>
   <span class="c1">;;   &#34;-%-&#34;</span>
   <span class="p">)))</span>
</code></pre>
<p>Aquí, se redefine el mode line por defecto. La mayoría de las partes son desde el original; pero yo creo unos pocos cambios. Yo asigno el formato de mode line <em>default</em> así como permitir varios modos, tales como Info, para sobreescribirlo.</p>
<p>Muchos elementos en la lista son auto-explicativos: <code>mode-line-modified</code> es una variable que cuenta si el búfer ha sido modificado, <code>mode-name</code> cuenta el nombre del modo, y así sucesivamente. Sin embargo, el formato parece complicado porque las dos funcionalidades no han sido discutidas.</p>
<p>La nueva cadena de formato tiene una sintaxis especial:</p>
<pre class="code" ><code class="chroma" ><span class="o">#(</span><span class="s">&#34;-&#34;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="nv">help-echo</span> <span class="s">&#34;mouse-1: select window, ...&#34;</span><span class="p">))</span>
</code></pre>
<p>El <code>#(</code> empieza una lista. El primer elemento de la lista es la cadena en sí, solo un <samp>-</samp>. El segundo y tercer elemento especifica el rango a través del cuarto elemento aplicado. Un rango empieza <em>después</em> un carácter, así un cero significa el rango que empieza solo después del primer caracter; un 1 significa que el rango finaliza solo después del primer caracter. El tercer elemento es la propiedad para el rango. Eso consiste en una lista de propiedades, un nombre de propiedad, en este caso, <samp>help-echo</samp>, seguido por un valor, en este caso, una cadena. El segundo, tercer y cuarto elemento de este nuevo formato de cadena puede ser repetido.</p>
<p>Vea la Seccion <q>Propiedades de Texto</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, y ver <q>Formato Mode Line</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.</p>
<p><code>mode-line-buffer-identification</code> muestra el nombre del buffer. Eso es una lista empezando por <code>(#(&#34;%12b&#34; 0 4 …</code>. El <code>#(</code> empieza la lista.</p>
<p>El <samp>&#34;%12b&#34;</samp> muestra el nombre del actual búfer, usando la función <code>buffer-name</code> con la que estamos familiarizados; el ‘12’ especifica el número máximo de caracteres que serán mostrados. Cuando un nombre tiene pocos caracteres, el espacio en blanco se añade para rellenar este número. (Los nombres del búfer puede y con frecuencia serán más largos de 12 caracteres; esta longitud funciona bien en la típica ventana de 80 columnas de ancho.)</p>
<p><code>:eval</code> dice evaluar la siguiente forma y usa el resultado como una cadena para mostrarse. En este caso, la expresión muestra el primer componente del sistema completo. El fin del primer componente es un <samp>.</samp> (‘periodo’), así se usa la función <code>string-match</code> para contar el tamaño del primer componente. La subcadena desde el caracter cero a este tamaño del primer componente. La subcadena desde el caracter cero a este tamaño es el nombre de la máquina.</p>
<p>Esta es la expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">:eval</span> <span class="p">(</span><span class="nf">substring</span>
        <span class="p">(</span><span class="nf">system-name</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">string-match</span> <span class="s">&#34;\\..+&#34;</span> <span class="p">(</span><span class="nf">system-name</span><span class="p">))))</span>
</code></pre>
<p><samp>%[</samp> y <samp>%]</samp> causa un par de corchetes que aparezcan por cada edición nivel de edición recursiva editando el nivel. <samp>%n</samp> dice ‘Encoger’ cuando esto puede hacerse. <samp>%P</samp> te cuenta el porcentaje del búfer que está debajo de la ventana, o ‘arriba’, ‘abajo’, o ‘todo’. (Una minúscula <samp>p</samp> cuenta el porcentaje bajo el alto de la ventana.) <samp>%-</samp> inserta suficientes guiones para rellenar la línea.</p>
<p>Recuerda, “No tiene que gustarte Emacs para que le gustes”––Emacs puede tener diferentes colores, diferentes comandos, y diferentes teclas que un Emacs por defecto.</p>
<p>Por otro lado, si se quiere traer un plano ‘fuera de la caja’ Emacs, sin personalización, escribe:</p>
<div class="example-block" >
<pre class="example" >emacs -q
</pre>
</div>
<p>Esto inicializará un Emacs que <em>no</em> cargue tu <span class="file" >~/.emacs</span> fichero de inicialización. Uno plano, el que trae Emacs por defecto. Nada más.</p>
</div>
<h2 id="depurando" >Depurando</h2>
<div class="hBody-2" >
<p>GNU Emacs tiene dos depuradores, <code>debug</code> y <code>edebug</code>. El primero es construido dentro de las tripas de Emacs y está siempre contigo; el segundo requiere que exista una función antes de que se pueda usar.</p>
<p>Ambos depuradores son descritos extensivamente en Seccion <q>Depurando</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>. En este capítulo, se explicará un breve ejemplo de esto.</p>
</div>
<h3 id="depurar" ><code>depurar</code></h3>
<div class="hBody-3" >
<p>Supón que se ha escrito una definición de función que se pretende devolver la suma de los números 1 a través de un número dado. (Esta es la función <code>triangle</code> discutida pronto. Vea la Seccion <a href="Ejemplo-de-Decremento,-,-Ejemplo-con-Contador-de-Decremento" >Ejemplo de Decremento, , Ejemplo con Contador de Decremento</a>, para una discusión.)</p>
<p>Sin embargo, tu definición de función tiene un error. Se ha malescrito <samp>1=</samp> por <samp>1-</samp>. Aquí está la definición rota:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-bugged</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve suma de números 1 a través de NUMBER inclusive.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)))</span>      <span class="c1">; Error aquí.</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>Si se está leyendo esto en Info, se puede evaluar esta definición en el modo normal. Se verá que <code>triangle-bugged</code> aparece en el área de eco.</p>
<p>Ahora evalúa la función <code>triangle-bugged</code> con un argumento de 4:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-bugged</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>En un GNU Emacs reciente, se creará e introducirá un búfer <span class="file" >*Backtrace*</span> que dice:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (&gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (&gt; number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>(Se ha reformateado este ejemplo ligeramente; el depurador no contiene muchas líneas. Así, se puede salir del depurador escribiendo <kbd>q</kbd> en el buffer <span class="file" >*Backtrace*</span>.)</p>
<p>En la práctica, debido a un error tan simple como este, la línea de ‘error Lisp’ explica lo que se necesita saber para corregir la definición. La función <code>1=</code> está ‘vacía’.</p>
<p>Sin embargo, si no se conoce con bastante certeza lo que está pasando, se puede leer la traza completa.</p>
<p>En este caso, se necesita ejecutar una versión reciente de GNU Emacs, que automáticamente empieza el depurador que pone en el búfer <span class="file" >*Backtrace*</span>; o además, se necesita para empezar el depurador manualmente como se describe debajo.</p>
<p>Lee el búfer <span class="file" >*Backtrace*</span> de abajo a arriba; eso cuenta lo que le hizo a Emacs tener un error. Emacs hace una llamada interactiva a <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>), que lleva a la evaluación de la expresión <code>triangle-bugged</code>. Cada línea de debajo cuenta lo que el intérprete Lisp evaluó.</p>
<p>La tercera línea desde lo alto del búfer es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">))</span>
</code></pre>
<p>Emacs intentó evaluar esta expresión; para hacerlo así, se intentó evaluar la expresión interna para ser mostrada en la segunda línea desde arriba:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)</span>
</code></pre>
<p>Aquí es donde el error ocurre; como se dice en la línea de arriba:</p>
<div class="example-block" >
<pre class="example" >Debugger entered--Lisp error: (void-function 1=)
</pre>
</div>
<p>Se puede corregir el error, reevalúa la definición de función, y entonces se puede testear de nuevo.</p>
</div>
<h3 id="debug-on-entry" ><code>debug-on-entry</code></h3>
<div class="hBody-3" >
<p>Un GNU Emacs actual abre el depurador automáticamente cuando la función tiene un error.</p>
<p>Incidentalmente, se puede empezar el depurador manualmente para todas las versiones de Emacs; la ventaja es que el depurador se ejecuta incluso si no se tiene un error en su código. Algunas veces, ¡su código estará libre de errores!</p>
<p>Se puede introducir el depurador cuando se llama a la función llamando <code>debug-on-entry</code>.</p>
<p>Tipo:</p>
<div class="example-block" >
<pre class="example" >M-x debug-on-entry RET triangle-bugged RET
</pre>
</div>
<p>Ahora, evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-bugged</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>Todas las versiones de Emacs crearán un búfer <span class="file" >*Backtrace*</span> y cuenta tu que eso es el principio para evaluar la función <code>triangle-bugged</code>:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>En el búfer <span class="file" >*Backtrace*</span>, escribe <kbd>d</kbd>. Emacs evaluará la primera expresión en <code>triangle-bugged</code>; el búfer se parece a esto:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (&gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Ahora, escribe <kbd>d</kbd> de nuevo, ocho veces, lentamente. Cada vez que se escribe <kbd>d</kbd> Emacs evaluará otra expresión en la definición de función.</p>
<p>Eventualmente, el búfer se parece a esto:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (&gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
* (let ((total 0)) (while (&gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Finalmente, después se escribe <kbd>d</kbd> dos veces más, Emacs logrará el error y las dos líneas superiores del buffer <span class="file" >*Backtrace*</span> se ve así:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
…
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Escribiendo <kbd>d</kbd>, sería capaz de pasear a través de la función.</p>
<p>Se puede salir de un buffer <span class="file" >*Backtrace*</span> escribiendo <kbd>q</kbd>; esto se sale de la traza, pero no cancela <code>debug-on-entry</code>.</p>
<p>Para cancelar el efecto de <code>debug-on-entry</code>, llama a <code>cancel-debug-on-entry</code> y el nombre de la función, como esto:</p>
<div class="example-block" >
<pre class="example" >M-x cancel-debug-on-entry RET triangle-bugged RET
</pre>
</div>
<p>(Si está leyendo esto en Info, cancela <code>debug-on-entry</code> ahora.)</p>
</div>
<h3 id="debug-on-quit-y-(debug)" ><code>debug-on-quit</code> y <code>(debug)</code></h3>
<div class="hBody-3" >
<p>Adición a la configuración <code>debug-on-error</code> o llamando <code>debug-on-entry</code>, hay otros dos caminos para empezar <code>debug</code>.</p>
<p>Se puede empezar <code>debug</code> siempre y cuando se escribe <kbd>C-g</kbd> (<code>keyboard-quit</code>) se configura la variable <code>debug-on-quit</code> para <code>t</code>. Esto es útil para depurar bucles infinitos.</p>
<p>O, se puede insertar un línea que dice <code>(debug)</code> dentro de tu código donde se quiere que el depurador empiece, así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-bugged</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve suma de números 1 a través de NUMERO inclusive.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">debug</span><span class="p">)</span>                         <span class="c1">; Empieza el depurador.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)))</span>      <span class="c1">; Error aquí.</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>La función <code>debug</code> se describe en detalle en <q>El Depurador Lisp</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
</div>
<h3 id="el-depurador-de-nivel-de-fuentes-edebug" >El depurador de nivel de fuentes <code>edebug</code></h3>
<div class="hBody-3" >
<p>Edebug es un depurador a nivel de fuentes Edebug que normalmente muestra las fuentes del código que se está depurando, con una flecha a la izquierda que muestra que línea se está actualmente ejecutando.</p>
<p>Se puede pasear a través de la ejecución de una función, línea a línea, o ejecutarse rápidamente hasta lograr un <dfn>punto de ruptura</dfn> donde la ejecución pare.</p>
<p>Edebug se describe en Seccion <q>edebug</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
<p>Aquí hay una función con errores para <code>triangulo-recursivo</code>. Véase Sección <a href="Recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</a>, para una revisión de eso.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangulo-recursivo-bugged</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma of números 1 a través de NUMBER inclusive.
</span><span class="s">Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">number</span> <span class="mi">1</span><span class="p">)</span>
      <span class="mi">1</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span>
       <span class="p">(</span><span class="nv">triangulo-recursivo-bugged</span>
        <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)))))</span>               <span class="c1">; Error aquí.</span>
</code></pre>
<p>Normalmente, se instalaría esta definición colocando su cursor después de la función cerrando paréntesis y escribiendo <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>) o lo demás colocando tu cursor con la definición y escribiendo <kbd>C-M-x</kbd> (<code>eval-defun</code>). (Por defecto, el comando <code>eval-defun</code> funciona solo en modo Emacs Lisp o en el modo de interacción de Lisp.)</p>
<p>Sin embargo, para preparar esta definición de función para Edebug, se debe primero <dfn>instrumentar</dfn> el código usando un comando diferente. Se puede hacer esto coloca el cursor dentro o después de la definición y escribiendo</p>
<div class="example-block" >
<pre class="example" >M-x edebug-defun RET
</pre>
</div>
<p>Esto causará que Emacs cargue Edebug automáticamente si eso no está ya cargado y, apropiadamente prepara la función.</p>
<p>Después de preparar la función, emplaza tu cursor después de la siguiente expresión y escribe <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangulo-recursivo-bugged</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>Se vuelve a las fuentes de <code>triangulo-recursivo-bugged</code> y el cursor se posiciona al principio del <code>if</code> de la línea de la función. También, se verá una flecha en la mano izquierda al lado de esta línea donde la función se está ejecutando. (En los siguientes ejemplos, se muestra la flecha con <samp>=&gt;</samp>; en un sistema de ventanas, se puede ver la flecha como un triángulo sólido en el ‘borde’ de la ventana.)</p>
<div class="example-block" >
<pre class="example" >=&gt;★(if (= number 1)
</pre>
</div>
<p>En el ejemplo, la posición del punto es mostrado con una estrella, <samp>★</samp> (en Info, eso es mostrado como <samp>-!-</samp>).</p>
<p>Si ahora se presiona <kbd>SPC</kbd>, el punto se moverá a la siguiente expresión para ejecutarse; la línea se parece a esto:</p>
<div class="example-block" >
<pre class="example" >=&gt;(if ★(= number 1)
</pre>
</div>
<p>Como se continua presionando <kbd>SPC</kbd>, el puntero se moverá desde la expresión a la expresión. Al mismo tiempo, siempre y cuando una expresión devuelva un valor, este valor será mostrado en el área de eco. Por ejemplo, después de mover el punto pasado <code>number</code>, se verá lo siguiente:</p>
<div class="example-block" >
<pre class="example" >Resultado: 3 (#o3, #x3, ?\C-c)
</pre>
</div>
<p>Esto significa el valor de <code>number</code> es 3, que son tres octales, tres hexadecimales, y <code>ascii</code> ‘control-c’ (la tercera letra del alfabeto, en caso de que se necesite conocer esta información).</p>
<p>Uno puede continuar moviéndose a través del código hasta que logre la línea con el error. Antes de la evaluación, esta línea se parece a esto:</p>
<div class="example-block" >
<pre class="example" >=&gt;        ★(1= number)))))               ; Error aquí.
</pre>
</div>
<p>Cuando se presiona <kbd>SPC</kbd> una vez de nuevo, se producirá un mensaje de error que dice:</p>
<div class="example-block" >
<pre class="example" >La definición de la función está vacío: 1=
</pre>
</div>
<p>Este es el error.</p>
<p>Presiona <kbd>q</kbd> para salir de Edebug.</p>
<p>Para eliminar la instrumentación desde una definición de función, simplemente se reevalúa con un comando que no lo instrumente. Por ejemplo, se podría posicionar su cursor después de la definición cerrando paréntesis y escribiendo <kbd>C-x C-e</kbd>.</p>
<p>Edebug hace un gran trato antes de entrar en una función. Se puede dirigir así mismo, parando solo en un error o en puntos específicos, se puede causar para mostrar los valores cambiantes de varias expresiones; se puede encontrar cuantas veces una función se llama, y más.</p>
<p>Edebug se describe en <q>edebug</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
</div>
<h3 id="ejercicios-de-depuración" >Ejercicios de depuración</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Instale la función <code>count-words-example</code> y provoque que se introduzca el depurador construido cuando se llame. Ejecute el comando en una región conteniendo dos palabras. Se necesitará presionar <kbd>d</kbd> un número remarcable de veces. En el sistema, es un ‘hook’ llamado después que el comando se finaliza. (Para información sobre hooks, mira Seccion <q>Resumen del Comando Bucle</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
</li>
<li>
<p>Copie <code>count-words-example</code> dentro del búfer <span class="file" >*scratch*</span>, instrumente la función para Edebug, y navegue a través de su ejecución. La función no necesita tener un error, aunque se puede introducir uno si se desea. Si a la función le falta un error, el paseo se completa sin problemas.</p>
</li>
<li>
<p>Mientras se ejecuta Edebug, escriba <kbd>?</kbd> para ver una lista de todos los comandos Edebug. (El <code>global-edebug-prefix</code> normalmente es <kbd>C-x X</kbd>, por ej: <kbd>CTRL-x</kbd> seguido por una tecla mayúscula <kbd>X</kbd>; use este prefijo para comandos hechos fuera del búfer de depuración Edebug.)</p>
</li>
<li>
<p>En el búfer de depuración Edebug, usa el comando <kbd>p</kbd> (<code>edebug-bounce-point</code>) para ver si <code>count-words-example</code> está funcionando.</p>
</li>
<li>
<p>Mueve el punto a algún sitio debajo de la función y entonces escribe el comando <kbd>h</kbd> (<code>edebug-goto-here</code>) para saltar a esta localización.</p>
</li>
<li>
<p>Usa el comando <kbd>t</kbd> (<code>edebug-trace-mode</code>) para causar que Edebug pasee a través de la función en sí; usa una letra mayúscula <kbd>T</kbd> para <code>edebug-Trace-fast-mode</code>.</p>
</li>
<li>
<p>Asigna un punto de ruptura, entonces ejecuta Edebug en modo Traza hasta que se logre el punto de parada.</p>
</li>
</ul>
</div>
<h2 id="conclusión" >Conclusión</h2>
<div class="hBody-2" >
<p>Ahora se ha llegado al fin de esta Introducción. Se ha aprendido lo suficiente acerca de programación en Emacs Lisp para asignar valores, para escribir ficheros <span class="file" >.emacs</span> para tí mismo y tus amigos, y escribir personalizaciones simples y extensiones a Emacs.</p>
<p>Este es un lugar para parar. O, si se desea, se puede ir adelante, y aprender más por uno mismo.</p>
<p>Se han aprendido algunas bases de programación. Pero solo algunas. Todavía hay muchas cosas que son fáciles de usar que no se han tocado.</p>
<p>Otra idea para seguir es leer las fuentes de Emacs y en <em>El Manual de Referencia de GNU Emacs</em>.</p>
<p>Las fuentes de Emacs Lisp son una aventura. Cuando se leen las fuentes vienen a través de una función o expresión que nos es familiar, se necesita imaginar o encontrar qué se hace.</p>
<p>Ir al Manual de Referencia. Eso está a través del completo, limpio y fácil de leer descripción de Emacs Lisp. Está escrito no solo para expertos, pero sí para gente que conoce lo que usted conoce. (El <em>Manual de Referencia</em> viene con la distribución de GNU Emacs. Como esta introducción, viene como un fichero fuente Texinfo, así se puede leer on-line como un libro impreso.)</p>
<p>Ir a otra ayuda on-line que sea parte de GNU Emacs: la documentación on-line para todas las funciones y variables, y <code>find-tag</code>, el programa que va a las fuentes.</p>
<p>Aquí hay un ejemplo de cómo explorar las fuentes. Porque su nombre, <span class="file" >simple.el</span> es el fichero que se vió primero, hace tiempo. Como eso ocurre alguna de las funciones en <span class="file" >simple.el</span> son complicadas, o al menos parece complicado a primera vista. La función <code>open-line</code>, por ejemplo, parece complicada.</p>
<p>Se puede querer pasear a través de esta función lentamente, como nosotros hicimos la función <code>forward-sentence</code>. (Vea la Seccion <a href="La-función-forward-sentence" >La función <code>forward-sentence</code></a>.) O se puede querer salir de esta función y mirar en otra, tal como <code>split-line</code>. No se necesita leer todas las funciones. De acuerdo a <code>contar-palabras-en-definicion</code>, la función <code>split-line</code> contiene 102 palabras y símbolos.</p>
<p>Incluso aunque sean pocas, <code>split-line</code> contiene expresiones que no se han estudiado: <code>skip-chars-forward</code>, <code>indent-to</code>, <code>current-column</code> y <code>insert-and-inherit</code>.</p>
<p>Considera la función <code>skip-chars-forward</code>. (Eso es parte de la definición de función para <code>back-to-indentation</code>, que muestra la <a href="Repaso:-Cómo-escribir-definiciones-de-funciones" >Repaso</a>.)</p>
<p>En GNU Emacs, se puede encontrar más acerca de <code>skip-chars-forward</code> escribiendo <kbd>C-h f</kbd> (<code>describe-function</code>) y el nombre de la función. Esto te da la documentación de función.</p>
<p>Se puede ser capaz de adivinar que se hace por una función bien llamada tal como <code>indent-to</code>; o se puede buscar, también. Incidentalmente, la función <code>describe-function</code> en sí está en <span class="file" >help.el</span>; esta es una de estas largas, pero descifrables funciones. ¡Se puede buscar <code>describe-function</code> usando el comando <kbd>C-h f</kbd>!</p>
<p>En esta instancia, desde el código es Lisp, el búfer <span class="file" >*Help*</span> contiene el nombre de la librería conteniendo las fuentes de la función. Se puede poner el punto a través del nombre de la librería y presiona la tecla RET, que está en esta situación está asociado a <code>help-follow</code>, y se toma directamente de las fuentes, en el mismo camino que <kbd>M-.</kbd> (<code>find-tag</code>).</p>
<p>La definición para <code>describe-function</code> ilustra como personalizar las expresiones <code>interactive</code> sin usar los códigos de caracter estándar y eso muestra como crear un búfer temporal.</p>
<p>(La función <code>indent-to</code> es escrita en C en vez de Emacs Lisp; eso es una función ‘construida’. <code>help-follow</code> toma su fuente como <code>find-tag</code>, cuando se configura apropiadamente.)</p>
<p>Se puede mirar en las fuentes de la función usando <code>find-tag</code>, que está asociado a <kbd>M-.</kbd>. Finalmente, se puede encontrar que el Manual de Referencia tiene que decir visitando el manual en Info, y escribiendo <kbd>i</kbd> (<code>Info-index</code>) y el nombre de la función, o buscando la función en el índice a una copia impresa del manual.</p>
<p>Similarmente, se puede encontrar que significa por <code>insert-and-inherit</code>.</p>
<p>Otros ficheros fuente interesantes incluyen <span class="file" >paragraphs.el</span>, <span class="file" >loaddefs.el</span> y <span class="file" >loadup.el</span>. El fichero <span class="file" >paragraphs.el</span> incluye ordenar, funciones fácilmente comprendidas tan bien como las largas. El fichero <span class="file" >loaddefs.el</span> contiene muchos autoloads estándar y muchos mapas de teclado. Nunca se ha buscado en todo; solo en las partes. <span class="file" >loadup.el</span> es el fichero que carga las partes estándar de Emacs; eso cuenta un gran trato acerca de cómo Emacs está construido. (Vea la Seccion <q>Construyendo Emacs</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más acerca de construcción.)</p>
<p>Como dije, se han aprendido algunas cosas; sin embargo, y de manera muy importante, se han tocado fuertes aspectos de la programación; no se ha dicho nada acerca de como ordenar la información, excepto para usar la función predefinida <code>sort</code>; no se ha dicho nada acerca de cómo almacenar la información, excepto para usar variables y listas; no se ha dicho nada acerca de como escribir programas que escriben programas. Esto son asuntos para otro tipo diferente de libro, un diferente tipo de aprendizaje.</p>
<p>Lo que se ha hecho es aprender lo suficiente para hacer mucho trabajo práctico con GNU Emacs. Lo que se ha hecho es comenzar. Este es el fin del principio de una gran amistad.</p>
</div>
<h3 id="apéndice-a-la-función-the-the" >Apéndice A La función <code>the-the</code></h3>
<div class="hBody-3" >
<p>Algunas veces cuando se se escribe texto, se duplican palabras––como con “se se” cerca del principio de esta frase. Se encuentra que lo más frecuente, es duplicar “el”; aquí, se llama a la función para detectar las palabras duplicadas, <code>the-the</code>.</p>
<p>Como primer paso, se podrían usar las siguientes expresiones regulares para buscar duplicados:</p>
<div class="example-block" >
<pre class="example" >\\(\\w+[ \t\n]+\\)\\1
</pre>
</div>
<p>Este regexp asocia uno o más caracteres que constituyen palabras seguidas por uno o más espacios, tabuladores, o nuevas líneas. Sin embargo, eso no detecta palabras duplicadas en diferentes líneas, desde la finalización de la primera palabra, el fin de la línea, es diferente desde el fin de la segunda palabra, un espacio. (Para más información acerca de expresiones regulares, mira el Capitulo 12 <a href="Búsqueda-de-Expresiones-Regulares" >Búsqueda de Expresiones Regulares</a>, tan bien como la Seccion <q>Sintaxis de Expresiones Regulares</q> en <em>El Manual de GNU Emacs</em>, y la Seccion <q>Expresiones Regulares</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p>Se podrían intentar buscar caracteres duplicados pero no si el patrón detecta dobles tales como las dos ocurrencias de ‘th’ en ‘with the’.</p>
<p>Otro posible regexp busca caracteres constituyentes de palabras seguidos por caracteres de no palabras constituyentes, reduplicadas. Aquí, <samp>\\w+</samp> asocia a una o más caracteres de palabras constituyente y <samp>\\W*</samp> asocia cero o más caracteres que no constituyen palabras.</p>
<div class="example-block" >
<pre class="example" >\\(\\(\\w+\\)\\W*\\)\\1
</pre>
</div>
<p>De nuevo, no útil.</p>
<p>Aquí está el patrón que uso. No es perfecto, pero suficientemente bueno. <samp>\\b</samp> asocia la cadena vacía provista al principio o fin de una palabra; <samp>[^@ \n\t]+</samp> asocia una o más ocurrencias de qué caracteres que <em>no</em> son un @-signo, espacio, nueva línea, o tabulador.</p>
<div class="example-block" >
<pre class="example" >\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
</pre>
</div>
<p>Uno puede escribir expresiones más complicadas, pero esta expresión es suficientemente buena así.</p>
<p>Aquí está la función <code>the-the</code>, como se incluye en mi fichero <span class="file" >.emacs</span>, a lo largo de un atajo global manejable:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">the-the</span> <span class="p">()</span>
  <span class="s">&#34;Busca hacia adelante para una palabra duplicada.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Buscando palabras duplicadas ...&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
  <span class="c1">;; Este regexp no es perfecto</span>
  <span class="c1">;; pero es limpiamente bueno a pesar de todo:</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span>
       <span class="s">&#34;\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b&#34;</span> <span class="no">nil</span> <span class="ss">&#39;move</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Palabra encontrada duplicada.&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Fin de búfer&#34;</span><span class="p">)))</span>

<span class="c1">;; Asocia ‘the-the’ a  C-c \</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-c\\&#34;</span> <span class="ss">&#39;the-the</span><span class="p">)</span>
</code></pre>
<p>Aquí está la prueba del texto:</p>
<div class="example-block" >
<pre class="example" >uno dos tres cuatro cinco
cinco seis siete
</pre>
</div>
<p>Se pueden sustituir las otras expresiones regulares mostradas debajo en la definición de función y se prueba cada una de ellas en esta lista.</p>
</div>
<h3 id="apéndice-b-manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</h3>
<div class="hBody-3" >
<p>El anillo de la muerte es una lista que es transformada dentro de un anillo que trabaja con la función <code>current-kill</code>. Los comandos <code>yank</code> y <code>yank-pop</code> usan la función <code>current-kill</code>.</p>
<p>Este apéndice describe la función <code>current-kill</code> y los comandos <code>yank</code> y <code>yank-pop</code>, pero primero, considere los trabajo del kill ring.</p>
<p>El anillo de la muerte tiene el tamaño máximo de sesenta elementos; hacer una explicación con este número máximo quedaría demasiado larga. En vez de eso, pensemos qué ocurre si se asígna a cuatro. Por favor, evalúe lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">old-kill-ring-max</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-max</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Entonces, por favor, copie cada línea del siguiente ejemplo indentado dentro del anillo de la muerte. Se puede cortar cada línea con <kbd>C-k</kbd> o marcarla y copiarla con <kbd>M-w</kbd>.</p>
<p>(En un búfer de solo lectura, tal como el búfer <span class="file" >*info*</span>, el comando kill, <kbd>C-k</kbd> (<code>kill-line</code>), no eliminará el texto, solamente lo mueve al anillo de la muerte. Sin embargo, el ordenador puede avisar con un beep. Alternativamente, para silenciar, se puede copiar la región de cada línea con el comando <kbd>M-w</kbd> (<code>kill-ring-save</code>). Se debe marcar cada línea de este comando para tener éxito, pero no importa si al final se posiciona en el punto o la marca).</p>
<p>Por favor, invoque las llamadas en orden, de modo que los cinco elementos rellenen el anillo de la muerte.</p>
<div class="example-block" >
<pre class="example" >primero algo de texto
segunda pieza de texto
tercera línea
cuarta línea de texto
quinto bit de texto
</pre>
</div>
<p>Entonces encuentra el valor de <code>kill-ring</code> evaluando</p>
<div class="example-block" >
<pre class="example" >kill-ring
</pre>
</div>
<p>Eso es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;quinto bit de texto&#34;</span> <span class="s">&#34;cuarta línea de texto&#34;</span>
<span class="s">&#34;tercera línea&#34;</span> <span class="s">&#34;segunda pieza de texto&#34;</span><span class="p">)</span>
</code></pre>
<p>El primer elemento, <samp>primero algo de texto</samp>, fué borrado.</p>
<p>Para devolver el viejo valor para el tamaño del kill ring, evalúe:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-max</span> <span class="nv">old-kill-ring-max</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="la-función-current-kill" >La función <code>current-kill</code></h4>
<div class="hBody-4" >
<p>La función <code>current-kill</code> cambia el elemento en el anillo de la muerte <em>kill ring</em> para el que el <code>kill-ring-yank-pointer</code> apunta. (También, la función <code>kill-new</code> asigna <code>kill-ring-yank-pointer</code> para apuntar al último elemento del anillo de la muerte. La función <code>kill-new</code> se usa directamente o indirectamente por <code>kill-append</code>, <code>copy-region-as-kill</code>, <code>kill-ring-save</code>, <code>kill-line</code>, y <code>kill-region</code>.)</p>
<p>La función <code>current-kill</code> es usada por <code>yank</code> y por <code>yank-pop</code>. Aquí está el código para <code>current-kill</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">current-kill</span> <span class="p">(</span><span class="nv">n</span> <span class="kp">&amp;optional</span> <span class="nv">do-not-move</span><span class="p">)</span>
<span class="s">&#34;Rota el punto de pegue por N lugares, y entonces devuelve lo cortado.
</span><span class="s">Si N es cero, ‘interprogram-paste-function’ se asigna, y si se llama
</span><span class="s">devuelve una cadena, entonces esta cadena se añade al frente del
</span><span class="s">anillo de la muerte y devuelve el último corte.
</span><span class="s">Si el argumento opcional DO-NOT-MOVE es no nulo, entonces no muevas el
</span><span class="s">punto de pegue; solo devuelve el Nth corte hacia adelante.
</span><span class="s">   (let ((interprogram-paste (and (= n 0)
</span><span class="s">                                  interprogram-paste-function
</span><span class="s">                                  (funcall interprogram-paste-function)))))
</span><span class="s">    (if interprogram-paste
</span><span class="s">        (progn
</span><span class="s">          ;; Deshabilita el programa de la función de corte cuando se
</span><span class="s">          ;; añade el nuevo texto al anillo de la muerte,
</span><span class="s">          ;; así Emacs no intenta poseer la selección
</span><span class="s">          ;; con idéntico texto.
</span><span class="s">          (let ((interprogram-cut-function nil))
</span><span class="s">            (kill-new interprogram-paste))
</span><span class="s">          interprogram-paste)
</span><span class="s">      (or kill-ring (error &#34;</span><span class="nv">Kill</span> <span class="nv">ring</span> <span class="nv">is</span> <span class="nv">empty</span><span class="s">&#34;))
</span><span class="s">      (let ((ARGth-kill-element
</span><span class="s">             (nthcdr (mod (- n (length kill-ring-yank-pointer))
</span><span class="s">                          (length kill-ring))
</span><span class="s">                     kill-ring)))
</span><span class="s">        (or do-not-move
</span><span class="s">            (setq kill-ring-yank-pointer ARGth-kill-element))
</span><span class="s">        (car ARGth-kill-element)))))
</span><span class="s"></span></code></pre>
<p>Recuerde también que la función <code>kill-new</code> asigna <code>kill-ring-yank-pointer</code> al último elemento del anillo de la muerte <em>kill ring</em>, que significa que todas las funciones lo llaman y asigna el valor de manera indirecta: <code>kill-append</code>, <code>copy-region-as-kill</code>, <code>kill-ring-save</code>, <code>kill-line</code> y <code>kill-region</code>.</p>
<p>Aquí está la línea en <code>kill-new</code>, que se explica en la <a href="La-función-kill-new" >La función <code>kill-new</code></a>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
</code></pre>
<p>La función <code>current-kill</code> parece compleja, pero usual, eso puede ser comprendido tomándolo aparte pieza por pieza. Primero míralo en la forma esquelética:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">current-kill</span> <span class="p">(</span><span class="nv">n</span> <span class="kp">&amp;optional</span> <span class="nv">do-not-move</span><span class="p">)</span>
  <span class="s">&#34;Rota el punto a pegar por N lugares, y entonces devuelve el texto cortado.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="nv">varlist</span>
    <span class="nv">body</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Esta función tiene dos argumentos, uno es opcional. Hay una cadena de documentación. <em>No</em> es una función interactiva.</p>
<p>El cuerpo de la definición de función es una expresión <code>let</code>, que por sí misma tiene tanto un cuerpo como una varlist.</p>
<p>La expresión <code>let</code> declara una variable que será solo usable con las asociaciones de esta función. Esta variable se llama <code>interprogram-paste</code> y se copia a otro programa. No se copia con esta instancia de GNU Emacs. La mayoría de los sistemas de ventanas proveen una facilidad para pegar el interprograma. Tristemente, esta facilidad normalmente provee solo el último elemento. La mayoría de los sistemas de ventanas no han adoptado un anillo de muchas posibilidades, incluso aunque Emacs haya provisto esto durante décadas.</p>
<p>La expresión <code>if</code> tiene dos partes, una si existe <code>interprogram-paste</code> y otra si no.</p>
<p>Permítenos considerar el ‘si no’ o la parte else de la función <code>current-kill</code>. (La parte then usa la función <code>kill-new</code>, que ya hemos descrito. Vea la Seccion <a href="La-función-kill-new." >La función <code>kill-new</code>.</a>)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">or</span> <span class="nv">kill-ring</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;El Kill ring está vacío&#34;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">ARGth-kill-element</span>
       <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring-yank-pointer</span><span class="p">))</span>
                    <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">))</span>
               <span class="nv">kill-ring</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">do-not-move</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">ARGth-kill-element</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">car</span> <span class="nv">ARGth-kill-element</span><span class="p">))</span>
</code></pre>
<p>El código primero chequea si el anillo de la muerte tiene contenido; de otro modo señala un error.</p>
<p>Note que la expresión <code>or</code> es muy similar para testear el tamaño con un <code>if</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">))</span>          <span class="c1">; parte-si</span>
    <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;Anillo de la muerte vacío&#34;</span><span class="p">))</span>       <span class="c1">; parte-entonces</span>
  <span class="c1">;; No hay parte-resto</span>
</code></pre>
<p>Si no hay nada en el anillo de la muerte, su tamaño debe ser cero y un mensaje de error se envía al usuario: <samp>El kill ring está vacío</samp>. La función <code>current-kill</code> usa una expresión <code>or</code> que es simple. Pero una expresión <code>if</code> recuerda lo que lleva.</p>
<p>Esta expresión <code>if</code> usa la función <code>zerop</code> que devuelve verdadero si el valor que se chequea es cero. Cuando <code>zerop</code> chequea verdadero, la parte then del <code>if</code> se evalúa. La parte then es una lista empezando con la función <code>error</code>, que es una función que es similar a la función <code>message</code> (Vease Sección <a href="message,-,-La-Función-message" >message, , La Función <code>message</code></a>) que imprime un mensaje de una línea en el área de eco. Sin embargo, además de imprimir un mensaje, <code>error</code> también evalúa la función que está embebida. Esto significa que el resto de la función no será evaluada si el tamaño del anillo de la muerte es cero.</p>
<p>Entonces la función <code>current-kill</code> selecciona el elemento a devolver. La selección depende del número de lugares que <code>current-kill</code> rota y donde <code>kill-ring-yank-pointer</code> apunta.</p>
<p>Lo siguiente, si el argumento <code>do-not-move</code> opcional es verdadero o el actual valor de <code>kill-ring-yank-pointer</code> se establece al punto de la lista. Finalmente, otra expresión devuelve el primer elemento de la lista incluso si el argumento <code>do-not-move</code> es verdadero.</p>
<p>En mi opinión, es ligeramente erróneo, al menos para humanos, usar el término ‘error’ como el nombre de la función <code>error</code>. Un término mejor sería ‘cancelar’. Estrictamente hablando, de acuerdo, no se puede apuntar, mucho menos rotar un puntero a una lista que no tiene tamaño, así desde el punto de vista del ordenador, la palabra ‘error’ es correcta. Pero un humano espera intentar algo, si solo si se encuentra el anillo de la muerte esté lleno o vacío. Esto es un acto de exploración.</p>
<p>Desde el punto de vista humano, el acto de exploración y descubrimiento no es necesariamente un error, y por esta razón no sería etiquetado como tal, incluso las vocales de un ordenador. Como tal, el código en Emacs implica que un humano que está actuando virtuosamente, explorando su entorno, está teniendo un error. Esto está mal. Incluso aunque el ordenador tome los mismos pasos como cuando hay ‘error’, un término tal como ‘cancelar’ tendría una clara connotación.</p>
<p>Entre otras acciones, la else-part de la expresión <code>if</code> asigna el valor de <code>kill-ring-yank-pointer</code> a <code>ARGth-kill-element</code> cuando el kill ring <em>anillo de la muerte</em> tiene alguna cosa dentro y el valor de <code>do-not-move</code> es <code>nil</code>.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring-yank-pointer</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">))</span>
        <span class="nv">kill-ring</span><span class="p">)))</span>
</code></pre>
<p>Esto necesita algún examen. A menos que no se suponga mover el puntero, la función <code>current-kill</code> cambia donde <code>kill-ring-yank-pointer</code> apunta. Esto es lo que la expresión <code>(setq kill-ring-yank-pointer ARGth-kill-element)</code> hace. También, claramente, <code>ARGth-kill-element</code> está siendo asignado para ser igual a algún <code>cdr</code> del anillo de la muerte, usando la función <code>nthcdr</code> que está descrita en una sección temprana. (Vea la Seccion <a href="copy-region-as-kill" >copy-region-as-kill</a>.)  ¿Cómo se hace?</p>
<p>Como se ha visto antes (Vease Sección <a href="nthcdr" >nthcdr</a>), la función <code>nthcdr</code> funciona repetidamente tomando el <code>cdr</code> de una lista––eso toma el <code>cdr</code>, del <code>cdr</code>, del <code>cdr</code>, …</p>
<p>Las siguientes dos expresiones producen el mismo resultado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">kill-ring</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="nv">kill-ring</span><span class="p">))</span>
</code></pre>
<p>Sin embargo, la expresión <code>nthcdr</code> es más complicada. Usa la función <code>mod</code> para determinar que <code>cdr</code> para seleccionar.</p>
<p>(Se recordará buscar funciones propias primero, en vez de esto, tendremos que ir dentro del <code>mod</code>.)</p>
<p>La función <code>mod</code> devuelve el valor de su primer argumento módulo el segundo; que es decir, eso devuelve el resto después de dividir el primer argumento por el segundo. El valor devuelto tiene el mismo signo que el segundo argumento.</p>
<p>De este modo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mod</span> <span class="mi">12</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">0</span>  <span class="c1">;; porque no hay resto</span>
<span class="p">(</span><span class="nf">mod</span> <span class="mi">13</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">1</span>
</code></pre>
<p>En este caso, el primer argumento es con frecuencia pequeño que el segundo. Que está bien.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mod</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">0</span>
<span class="p">(</span><span class="nf">mod</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">1</span>
</code></pre>
<p>Se puede adivinar lo que la función <code>-</code> hace. Eso es como <code>+</code> pero sustrae en vez de añadir; la función <code>-</code> sustrae su segundo argumento desde el primero. También, ya se sabe que la función <code>length</code> hace (Vease Sección <a href="#descubrir-la-longitud-de-una-lista:-length" >Descubrir la longitud de una lista: <code>length</code></a>). Eso devuelve el tamaño de una lista.</p>
<p>Y <code>n</code> es el nombre del argumento requerido a la función <code>current-kill</code>.</p>
<p>Así cuando el primer argumento a <code>nthcdr</code> es cero, la expresión <code>nthcdr</code> devuelve la lista entera, como se puede ver evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; kill-ring-yank-pointer and kill-ring tener un tamaño de cuatro</span>
<span class="c1">;; and (mod (- 0 4) 4) ⇒ 0</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;cuarta línea de texto&#34;</span>
          <span class="s">&#34;tercera línea&#34;</span>
          <span class="s">&#34;segunda pieza de texto&#34;</span>
          <span class="s">&#34;primero algo de texto&#34;</span><span class="p">))</span>
</code></pre>
<p>Cuando el primer argumento a la función <code>current-kill</code> es uno, la expresión <code>nthcdr</code> devuelve la lista sin su primer elemento.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;cuarta línea de texto&#34;</span>
          <span class="s">&#34;tercera línea&#34;</span>
          <span class="s">&#34;segunda pieza de texto&#34;</span>
          <span class="s">&#34;primero algo de texto&#34;</span><span class="p">))</span>
</code></pre>
<p>Incidentalmente, tanto <code>kill-ring</code> y <code>kill-ring-yank-pointer</code> son <dfn>variables globales</dfn>. Esto significa que cualquier expresión en Emacs Lisp puede acceder a ellas. Ellas no son como las variables locales asignadas por <code>let</code> o como los símbolos en una lista de argumentos. Las variables locales pueden solo ser accedidas con el <code>let</code> que los define o la función que los especifica en una lista de argumentos (y con expresiones llamadas por ellos).</p>
</div>
<h4 id="pegar" ><code>pegar</code></h4>
<div class="hBody-4" >
<p>Después de aprender acerca de <code>current-kill</code>, el código para la función <code>yank</code> es casi fácil.</p>
<p>La función <code>yank</code> no usa la variable <code>kill-ring-yank-pointer</code> directamente. Eso llama a <code>insert-for-yank</code> que llama a <code>current-kill</code> que asigna la variable <code>kill-ring-yank-pointer</code>.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">yank</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;Reinserta (\&#34;pega\&#34;) el último logro del texto cortado.
</span><span class="s">Más precisamente, reinserta el texto cortado más recientemente.
</span><span class="s">Pon el punto al final, y asigna la marca al principio.
</span><span class="s">Solo con \\[universal-argument] como argumento, lo mismo pero pon el
</span><span class="s">punto al principio (y la marca al final). Con el argumento N, reinserta
</span><span class="s">el N más recientemente cortado.
</span><span class="s">Cuando este comando inserta texto cortado dentro del búfer, eso
</span><span class="s">honra a ‘yank-excluded-properties’ y ‘yank-handler’ como se describe
</span><span class="s">la cadena de documentación para ‘insert-for-yank-1’, que se ve.
</span><span class="s">Ver también el comando \\[yank-pop].&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*P&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">yank-window-start</span> <span class="p">(</span><span class="nf">window-start</span><span class="p">))</span>
  <span class="c1">;; Si no tenemos todo el camino a través, crea last-command que</span>
  <span class="c1">;; indique esto para el siguiente comando.</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">insert-for-yank</span> <span class="p">(</span><span class="nv">current-kill</span> <span class="p">(</span><span class="nb">cond</span>
                                  <span class="p">((</span><span class="nf">listp</span> <span class="nv">arg</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                                  <span class="p">((</span><span class="nf">eq</span> <span class="nv">arg</span> <span class="ss">&#39;-</span><span class="p">)</span> <span class="mi">-2</span><span class="p">)</span>
                                  <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)</span>
      <span class="c1">;; Esto es como like exchange-point-and-mark,</span>
      <span class="c1">;;     pero no activa la marca.</span>
      <span class="c1">;; Es limpio evitar la activación, incluso aunque el comando</span>
      <span class="c1">;; loop would desactivaría la marca porque se</span>
      <span class="c1">;; insertara el texto.</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">set-marker</span> <span class="p">(</span><span class="nf">mark-marker</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))))</span>
  <span class="c1">;; Si tenemos todo el camino, haz que this-command lo indique.</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">this-command</span> <span class="no">t</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;yank</span><span class="p">))</span>
  <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>La expresión clave es <code>insert-for-yank</code>, que inserta la cadena devuelta por <code>current-kill</code>, pero elimina algo de propiedades de texto desde eso.</p>
<p>Sin embargo, antes de tener esta expresión, la función asigna el valor de <code>yank-window-start</code> a la posición devuelta por la expresión <code>(window-start)</code>, la posición que muestra lo que actualmente empieza. La función <code>yank</code> también asigna <code>this-command</code> y empuja la marca.</p>
<p>Después de pegar el elemento apropiado, si el argumento opcional es un <code>cons</code> en vez de un número o nada, se pone el punto al principio del texto pegado y se marca al final.</p>
<p>(La función <code>prog1</code> es como <code>progn</code> pero devuelve el valor de su primer argumento en vez del valor de su último argumento. Su primer argumento fuerza devolver la marca del búfer como un entero. Se puede ver la documentación para estas funciones emplazando el punto a través de ellas en este búfer y entonces escribiendo <kbd>C-h f</kbd> (<code>describe-function</code>) seguido por un <kbd>RET</kbd>; por defecto es la función.)</p>
<p>La última parte de la función cuenta que hacer cuando eso sucede.</p>
</div>
<h4 id="yank-pop" ><code>yank-pop</code></h4>
<div class="hBody-4" >
<p>Después de comprender <code>yank</code> y <code>current-kill</code>, se conoce como enfocar la función <code>yank-pop</code>. Dejando fuera la documentación para guardar el espacio, se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">yank-pop</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;yank</span><span class="p">))</span>
      <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;El comando previo no fué un corte&#34;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;yank</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">inhibit-read-only</span> <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">before</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">if</span> <span class="nv">before</span>
        <span class="p">(</span><span class="nf">funcall</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">yank-undo-function</span> <span class="ss">&#39;delete-region</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">yank-undo-function</span> <span class="ss">&#39;delete-region</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">yank-undo-function</span> <span class="no">nil</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">set-marker</span> <span class="p">(</span><span class="nf">mark-marker</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">insert-for-yank</span> <span class="p">(</span><span class="nv">current-kill</span> <span class="nv">arg</span><span class="p">))</span>
    <span class="c1">;; Asigna la ventana a volver donde estaba el comando yank,</span>
    <span class="c1">;; si es posible</span>
    <span class="p">(</span><span class="nf">set-window-start</span> <span class="p">(</span><span class="nf">selected-window</span><span class="p">)</span> <span class="nv">yank-window-start</span> <span class="no">t</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">if</span> <span class="nv">before</span>
        <span class="c1">;; Esto es como exchange-point-and-mark,</span>
        <span class="c1">;; pero no activa la marca.</span>
        <span class="c1">;; Es limpio evitar la activación, incluso aunque el comando</span>
        <span class="c1">;; desactivase la marca porque se insertara el texto.</span>
        <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">set-marker</span> <span class="p">(</span><span class="nf">mark-marker</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nf">point</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))))))</span>
  <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>La función es interactive con una pequeña <samp>p</samp> así el argumento prefijo es procesado y pasado a la función. El comando puede solo ser usado después del yank previo; de otro modo un mensaje de error se envía. Este chequeo usa la variable <code>last-command</code> que se asigna por <code>yank</code> y discutida de algún modo. (Vea la Seccion <a href="copy-region-as-kill" >copy-region-as-kill</a>.)</p>
<p>La cláusula <code>let</code> asigna la variable <code>before</code> a verdadero o falso dependiendo de si el punto está antes o después de la marca y entonce la región entre punto y marca se borra. Esta es la región que fué insertada por el yank previo y eso es este texto que será reemplazado.</p>
<p><code>funcall</code> llama a su primer argumento como una función, pasando los argumentos restantes. El primer argumento es el que la expresión <code>or</code> devuelve. Los dos argumentos restantes son las posiciones de punto y marca asignadas por el comando <code>yank</code> precedente.</p>
<p>Hay más, pero esta es la parte más dura.</p>
</div>
<h4 id="el-fichero-ring.el" >El fichero <span class="file" >ring.el</span></h4>
<div class="hBody-4" >
<p>De manera interesante, GNU Emacs posee un fichero llamado <span class="file" >ring.el</span> que provee muchas de las funcionalidades que ahora se discuten. Pero las funciones tales como <code>kill-ring-yank-pointer</code> no usan esta librería, posiblemente porque fueron escritas pronto.</p>
</div>
<h2 id="apéndice-c" >Apéndice C Un grafico con ejes etiquetados</h2>
<div class="hBody-2" >
<p>Los ejes impresos ayudan a comprender un grafico. Para crear escalas. En un capítulo anterior (Vease Sección <a href="Preparar-un-grafico,-,-Leyendo-un-grafico" >Preparar un grafico, , Leyendo un grafico</a>), se escribió el código para imprimir el cuerpo de un grafico. Aquí se escribe el código para imprimir y etiquetar ejes horizontales y verticales, a lo largo del cuerpo en sí.</p>
<p>Puesto que las inserciones rellenan un búfer a la derecha y debajo del punto, el nuevo grafico imprime la función que primero imprimiría el eje vertical Y, después el cuerpo del grafico, y finalmente el eje horizontal X. Esta secuencia nos da los contenidos de la función:</p>
<ol class="num" >
<li>
<p>Configura código.</p>
</li>
<li>
<p>Imprime el eje Y.</p>
</li>
<li>
<p>Imprime el cuerpo del grafico.</p>
</li>
<li>
<p>Imprime el eje X.</p>
</li>
</ol>
<p>Aquí hay un ejemplo de como se ve un grafico finalizado:</p>
<div class="example-block" >
<pre class="example" >0 -
             *
             *  *
             *  **
             *  ***
5 -      *   *******
       * *** *******
       *************
     ***************
1 - ****************
    |   |    |    |
    1   5   10   15
</pre>
</div>
<p>En este grafico, en ambos ejes vertical y horizontal se etiquetan con números. Sin embargo, en algunos graficos, el eje horizontal es tiempo y estaría mejor etiquetarlo con meses, así:</p>
<div class="example-block" >
<pre class="example" >5 -      *
       * ** *
       *******
     ********** **
1 - **************
    |    ^      |
  Enero Junio Enero
</pre>
</div>
<p>Dentro, con un pequeño pensamiento, se puede fácilmente venir con una variedad de esquemas de etiquetado verticales y horizontales. Nuestra tarea podría llegar a ser complicada. Pero las complicaciones generan confusión. En vez de permitir esto, es mejor elegir un simple esquema de etiquetado para nuestro primer esfuerzo, y modificarlo o reemplazarlo después.</p>
<p>Estas consideraciones sugieren el siguiente outline para la función <code>print-graph</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span>  <span class="err">…</span>
        <span class="err">…</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-Y-axis</span> <span class="nv">height</span> <span class="err">…</span> <span class="p">)</span>
    <span class="p">(</span><span class="nv">imprimir-cuerpo-grafico</span> <span class="nv">lista-de-numeros</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">print-X-axis</span> <span class="err">…</span> <span class="p">)))</span>
</code></pre>
<p>Nosotros podemos trabajar en cada parte de la definición de función <code>print-graph</code>.</p>
</div>
<h3 id="la-varlist-print-graph" >La varlist <code>print-graph</code></h3>
<div class="hBody-3" >
<p>Para escribir la función <code>print-graph</code>, la primera tarea es escribir la varlist en la expresión <code>let</code>. (Nosotros dejaremos por ahora cualquier pensamiento acerca de hacer la función interactive o acerca de los contenidos de su cadena de documentación.)</p>
<p>La varlist asignaría varios valores. Claramente, la etiqueta superior del eje vertical debe ser al menos la altura del grafico, que significa que debe obtener esta información aquí. Note que la función <code>print-graph-body</code> también requiere esta información. No hay razón para calcular la altura del grafico en dos lugares diferentes, así cambiaría <code>print-graph-body</code> desde el camino que definimos pronto para tomar ventaja del cálculo.</p>
<p>De manera similar, tanto la función para imprimir la etiqueta del eje X y la función <code>print-graph-body</code> se necesita aprender el valor del ancho de cada símbolo. Se puede desarrollar el cálculo aquí y cambiar la definición para <code>print-graph-body</code> desde el camino que se definió en el capítulo previo.</p>
<p>El tamaño de la etiqueta para el eje horizontal debe ser al menos tan largo como el grafico. Sin embargo, esta información es usada solo en la función que imprime el eje horizontal, así no necesita calcularse aquí.</p>
<p>Estos pensamientos nos llevan directamente a la siguiente forma para la varlist en el <code>let</code> para <code>print-graph</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">lista-de-numeros</span><span class="p">))</span> <span class="c1">; Primera versión.</span>
      <span class="p">(</span><span class="nv">ancho-del-simbolo</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">simbolo-en-blanco</span><span class="p">)))</span>
</code></pre>
<p>Como se verá, esta expresión no es bastante correcta.</p>
</div>
<h3 id="la-función-print-y-axis" >La función <code>print-Y-axis</code></h3>
<div class="hBody-3" >
<p>El trabajo de la función <code>print-Y-axis</code> es imprimir una etiqueta para el eje vertical que se parece a esto:</p>
<div class="example-block" >
<pre class="example" >    10 -




     5 -



     1 -
</pre>
</div>
<p>La función se pasaría a lo alto del grafico, y así construyen e insertan los números y marcas apropiados.</p>
<p>Es suficientemente fácil ver en la figura que la etiqueta del eje Y pero se puede decir en palabras, y entonces escribir una definición de función para hacer el trabajo es otra materia. No es bastante verdad decir que se quiere un número y un tic cada cinco líneas: solo hay tres líneas entre el <samp>1</samp> y el <samp>5</samp> (líneas 2, 3 y 4), pero cuatro líneas entre el <samp>5</samp> y el <samp>10</samp> (líneas 6, 7, 8 y 9). Es mejor decir que se quiere un número y un tic en la quinta línea desde abajo a cada línea que es un múltiplo de cinco.</p>
<p>La siguiente cuestión es a que altura se etiquetaría. Supón que la máxima altura de la columna mayor del grafico es siete. La etiqueta superior en el eje Y sería <samp>5 -</samp>, ¿y el grafico se pegaría debajo de la etiqueta?, ¿o la etiqueta superior sería <samp>7 -</samp>, y marcar la vertical del grafico? ¿o sería la etiqueta superior <code>10 -</code>, que es múltiplo de cinco, y es superior al valor más alto del grafico?</p>
<p>La última forma es preferida. La mayoría de los graficos son rectángulos cuyos lados son un número integral de pasos a lo largo––5, 10, 15, y así para un paso a distancia de cinco. Pero tan pronto se decide usar un paso alto para el eje vertical, se descubre que la expresión simple en la varlist para la altura de la computación es errónea. La expresión es <code>(apply &#39;max lista-de-numeros)</code>. Esto devuelve la altura precisa, no la altura máxima más de lo que es necesario para redondear el múltiplo de cinco. Una expresión más compleja es requerida.</p>
<p>Como es normal en casos como este, un problema complejo llega a ser simple si está dividido en varios problemas pequeños.</p>
<p>Primero, considere el caso cuando el valor superior del grafico es un múltiplo integral de cinco––cuando eso es 5, 10, 15, o algún múltiplo de cinco. Se puede usar este valor como la altura del eje Y.</p>
<p>Un camino simple y limpio para determinar si un número es múltiplo de cinco se divide por cinco y mira si la división devuelve resto. Si no hay resto, el número es un múltiplo de cinco. De este modo, siete dividido tiene un resto de dos, y siete no es un entero múltiplo de cinco. Dicho de otra manera, recordando la escuela, cinco entre siete es uno y me llevo dos. Sin embargo, diez entre dos, no tiene resto: diez es un múltiplo entero de cinco.</p>
</div>
<h4 id="viaje-lateral:-calcula-un-resto" >Viaje lateral: Calcula un resto</h4>
<div class="hBody-4" >
<p>En Lisp, la función para calcular un resto es <code>%</code>. La función devuelve el resto de su primer argumento dividido por su segundo argumento. Como ocurre, <code>%</code> es una función en Emacs Lisp que no se puede implementar usando <code>apropos</code>: no se puede encontrar nada si se escribe <kbd>M-x apropos <kbd>RET</kbd> resto <kbd>RET</kbd></kbd>. El único camino para aprender la existencia de <code>%</code> es leer acerca de eso en un libro tal como este o en las fuentes de Emacs Lisp.</p>
<p>Se puede probar la función <code>%</code> evaluando las siguientes dos expresiones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">%</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="nf">%</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>La primera expresión devuelve 2 y la segunda expresión devuelve 0.</p>
<p>Para probar si el valor devuelto es cero o algún otro número, se puede usar la función <code>zerop</code>. Esta función devuelve <code>t</code> si su argumento debe ser un número, es cero.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">nil</span>

<span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">t</span>
</code></pre>
<p>De este modo, la siguiente expresión devolverá <code>t</code> si la altura del grafico es divisible por cinco:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>(El valor de <code>height</code>, de acuerdo, puede ser encontrado desde <code>(apply &#39;max lista-de-numeros)</code>.)</p>
<p>Por otro lado, si el valor de <code>height</code> no es un múltiplo de cinco, nosotros queremos resetear el valor al siguiente múltiplo de cinco. Esta es la aritmética sencilla usando funciones con las que ya se está familiarizado. Primero, se divide el valor de <code>height</code> por cinco para determinar cuantas veces cinco va dentro del número. De este modo, cinco va dentro doce veces. Si se añade uno a este cociente y se multiplica por cinco, obtendremos el valor del siguiente múltiplo de cinco que es más largo que el mayor. Cinco va dentro de doce dos veces. Añade uno a dos, y multiplica por cinco; el resultado es quince, que es el siguiente múltiplo de cinco que es mayor de doce. La expresión Lisp para esto es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">height</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>Por ejemplo, si se evalúa lo siguiente, el resultado es 15:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="mi">12</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>Todo a través de esta discusión, se ha estado usando ‘cinco’ como el valor para las etiquetas espaciadas en el eje Y; pero se puede querer usar algún otro valor. Generalmente, reemplazaría ‘cinco’ con una variable a la que poder asignar un valor. El mejor nombre que puedo pensar para esta variable es <code>Y-axis-label-spacing</code>.</p>
<p>Usando este término, y una expresión <code>if</code>, se produce lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
    <span class="nv">height</span>
  <span class="c1">;; else</span>
  <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
     <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
</code></pre>
<p>Esta expresión devuelve el valor de <code>height</code> en sí si la altura es incluso un múltiplo del valor del <code>Y-axis-label-spacing</code> o lo demás computa y devuelve un valor de <code>height</code> que es igual al siguiente múltiplo mayor del valor del <code>Y-axis-label-spacing</code>.</p>
<p>Se puede ahora incluir esta expresión en la expresión <code>let</code> de la función <code>print-graph</code> (después de la primera configuración del valor de <code>Y-axis-label-spacing</code>):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">Y-axis-label-spacing</span> <span class="mi">5</span>
  <span class="s">&#34;Número de líneas desde una etiqueta del eje Y al siguiente.&#34;</span><span class="p">)</span>

<span class="err">…</span>
<span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">lista-de-numeros</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">height-of-top-line</span>
        <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
            <span class="nv">height</span>
          <span class="c1">;; else</span>
          <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
             <span class="nv">Y-axis-label-spacing</span><span class="p">)))</span>
       <span class="p">(</span><span class="nv">ancho-del-simbolo</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">simbolo-en-blanco</span><span class="p">))))</span>
<span class="err">…</span>
</code></pre>
<p>(Note que el uso de la función <code>let*</code>: el valor inicial de la altura es calculada una vez por la expresión <code>(apply &#39;max lista-de-numeros)</code> y entonces el valor resultado de <code>height</code> es usado para computar su valor final. Vea la Seccion <a href="La-expresión-let*" >La expresión <code>let*</code></a>, para más acerca de <code>let*</code>.)</p>
</div>
<h4 id="construye-un-elemento-del-eje-y" >Construye un elemento del eje Y</h4>
<div class="hBody-4" >
<p>Cuando se imprime el eje vertical, se quieren insertar cadenas tales como <samp>5 -</samp> y <samp>10 - </samp> cada cinco líneas. Más allá, se quieren los números agitados para alinear, así pocos números deben ser acuñados con espacios de guía. Si alguna de las cadenas usan dos dígitos, las cadenas con un simple dígito deben incluir una guía en blanco antes del número.</p>
<p>Para figurarse el tamaño del número, se usa la función <code>length</code>. Pero la función <code>length</code> funciona solo con una cadena, no con un número. Así el número tiene que ser convertido desde un número a una cadena. Esto se hace con la función <code>number-to-string</code>. Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="mi">35</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">2</span>

<span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="mi">100</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">3</span>
</code></pre>
<p>(<code>number-to-string</code> se llama <code>int-to-string</code>; se verá este nombre alternativo en varias fuentes.)</p>
<p>Además, en cada etiqueta, cada número es seguido por una cadena tal como <samp> - </samp>, que llamará al marcador <code>Y-axis-tic</code>. Esta variable está definida con <code>defvar</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">Y-axis-tic</span> <span class="s">&#34; - &#34;</span>
   <span class="s">&#34;La Cadena que sigue el número en una etiqueta del eje Y.&#34;</span><span class="p">)</span>
</code></pre>
<p>El tamaño de la etiqueta Y es la suma del tamaño del eje Y y el tamaño del número del alto del grafico.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">height</span><span class="p">)</span> <span class="nv">Y-axis-tic</span><span class="p">)))</span>
</code></pre>
<p>Este valor será calculado por la función <code>print-graph</code> en su varlist como <code>full-Y-label-width</code> y se pasa dentro. (Note que no se pensaba en incluir esto en el varlist cuando se propuso.)</p>
<p>Para crear un eje vertical completo, una marca de tic es concatenada con un número; y los dos juntos pueden ser precedidos por uno o más espacios dependiendo de cómo de largo es el número. La etiqueta consiste de tres partes: los espacios que se lideran (opcional), el número, y la marca tic. La función se pasa al valor del número para la fila específica, y el valor del ancho de la línea de arriba, que es calculada (solo una vez) por <code>print-graph</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">Y-axis-element</span> <span class="p">(</span><span class="nv">number</span> <span class="nv">full-Y-label-width</span><span class="p">)</span>
  <span class="s">&#34;Construye una etiqueta NUMERADA
</span><span class="s">Un elemento numerado se parece a esto ‘ 5 - ’,
</span><span class="s">y está tan acuñado como se necesita así todo se
</span><span class="s">alinea con el elemento para el número mayor.&#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">leading-spaces</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">full-Y-label-width</span>
            <span class="p">(</span><span class="nf">length</span>
             <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)</span>
                     <span class="nv">Y-axis-tic</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">concat</span>
     <span class="p">(</span><span class="nf">make-string</span> <span class="nv">leading-spaces</span> <span class="sc">? </span><span class="p">)</span>
     <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)</span>
     <span class="nv">Y-axis-tic</span><span class="p">)))</span>
</code></pre>
<p>La función <code>Y-axis-element</code> concatena junto los espacios que se lideran si cualquiera; el número, como una cadena; y la marca tic.</p>
<p>Para imaginarnos cuantos espacios guía la etiqueta necesita, la función sustrae el tamaño de la etiqueta––el tamaño del número más el tamaño de la marca tic––desde el ancho de la etiqueta deseada.</p>
<p>Los espacios en blanco se insertan usando la función <code>make-string</code>. Esta función tiene dos argumentos: lo primero cuenta como de larga será a cadena y el segundo es un símbolo para el caracter a insertar, en un formato espcial. El formato es una marca de pregunta seguida por un espacio en blanco, como este, <samp>?</samp>. Vea la Seccion <q>Tipo de Caracter</q> en <em>El Manual de Referencia Emacs Lisp</em>, para una descripción de la sintaxis para caracteres. (De acuerdo, se podría querer reemplazar el espacio en blanco por algún otro caracter …. Tu sabes qué hacer.)</p>
<p>La función <code>number-to-string</code> es usada en la expresión de concatenación, para convertir el número a una cadena que es concatenada con los espacios que se lideran y la marca de tic.</p>
</div>
<h4 id="crea-un-eje-de-la-columna-y" >Crea un eje de la columna Y</h4>
<div class="hBody-4" >
<p>Las funciones precedentes proporcionan todas las herramientas necesarias para construir una función que genera una lista de cadenas enumeradas y en blanco para inserta como la etiqueta para el eje vertical:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">Y-axis-column</span> <span class="p">(</span><span class="nv">height</span> <span class="nv">width-of-label</span><span class="p">)</span>
  <span class="s">&#34;Construye la lista de ejes Y etiquetadas y cadenas en blanco.
</span><span class="s">Para height la altura de la línea de debajo y width-of-label.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">Y-axis</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">height</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
          <span class="c1">;; Insertar etiqueta.</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
                <span class="p">(</span><span class="nf">cons</span>
                 <span class="p">(</span><span class="nv">Y-axis-element</span> <span class="nv">height</span> <span class="nv">width-of-label</span><span class="p">)</span>
                 <span class="nv">Y-axis</span><span class="p">))</span>
        <span class="c1">;; Else, insertar blancos.</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
              <span class="p">(</span><span class="nf">cons</span>
               <span class="p">(</span><span class="nf">make-string</span> <span class="nv">width-of-label</span> <span class="sc">? </span><span class="p">)</span>
               <span class="nv">Y-axis</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">height</span><span class="p">)))</span>
    <span class="c1">;; Insertar la línea base.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
          <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">Y-axis-element</span> <span class="mi">1</span> <span class="nv">width-of-label</span><span class="p">)</span> <span class="nv">Y-axis</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">Y-axis</span><span class="p">)))</span>
</code></pre>
<p>En esta función, nosotros empezamos con el valor de <code>height</code> y repetitivamente sustrae uno desde su valor. Después de cada sustración, se chequea para ver si el valor es una integral múltiple del <code>Y-axis-label-spacing</code>. Si eso es, se construye una etiqueta numerada usando la función <code>Y-axis-element</code>; si no, se construye una etiqueta blanca usando la función <code>make-string</code>. La línea base consiste del número uno seguido por una marca tic.</p>
</div>
<h4 id="la-versión-no-demasiado-final-de-print-y-axis" >La versión no demasiado final de <code>print-Y-axis</code></h4>
<div class="hBody-4" >
<p>La lista construida por la función <code>Y-axis-column</code> está pasada a la función <code>print-Y-axis</code>, que inserta la lista como una columna.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-Y-axis</span> <span class="p">(</span><span class="nv">height</span> <span class="nv">full-Y-label-width</span><span class="p">)</span>
  <span class="s">&#34;Inserta el eje Y usando HEIGHT y FULL-Y-LABEL-WIDTH.
</span><span class="s">La altura debe ser la máxima altura del grafico.
</span><span class="s">El ancho completo es el ancho del mayor elemento de la
</span><span class="s">etiqueta&#34;</span>
<span class="c1">;; El valor del alto y full-Y-label-width</span>
<span class="c1">;; son pasadas por ‘print-graph’.</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">start</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">insert-rectangle</span>
     <span class="p">(</span><span class="nv">Y-axis-column</span> <span class="nv">height</span> <span class="nv">full-Y-label-width</span><span class="p">))</span>
    <span class="c1">;; Posiciona el punto listo para inserta el grafico.</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
    <span class="c1">;; Mueve el punto hacia adelante por valor de full-Y-label-width</span>
    <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">full-Y-label-width</span><span class="p">)))</span>
</code></pre>
<p>El <code>print-Y-axis</code> usa la función <code>insert-rectangle</code> para inserta el eje Y creado por la función <code>Y-axis-column</code>. Además, eso emplaza el punto en la posición correcta para imprimir el cuerpo del grafico.</p>
<p>Se puede probar <code>print-Y-axis</code>:</p>
<ul>
<li>
<p>Instalar</p>
<div class="example-block" >
<pre class="example" >Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
</pre>
</div>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-Y-axis</span> <span class="mi">12</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li>
<p>Escribe <kbd>M-:</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pega la expresión <code>imprimir-cuerpo-grafico</code> dentro del minibúfer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá etiquetas verticalmente, el primero siendo <samp>10 - </samp>. (La función <code>print-graph</code> pasará el valor de <code>height-of-top-line</code>, que en este caso finalizará en 15, por esto lo que se obtiene podría aparecer como un error.)</p>
</div>
<h3 id="la-función-print-x-axis" >La función <code>print-X-axis</code></h3>
<div class="hBody-3" >
<p>Las etiquetas del eje X son como las etiquetas del eje Y, excepto que los ticks son un línea debajo de los números. Las etiquetas se parece como esto:</p>
<div class="example-block" >
<pre class="example" >|   |    |    |
1   5   10   15
</pre>
</div>
<p>El primer tic está bajo la primera columna del grafico y está precedido por varios espacios en blanco. Estos espacios proporcionan la habitación en filas de debajo para las etiquetas del eje Y. El segundo, tercer, cuarto, y subsiguientes ticks son todos espaciados igualmente, de acuerdo al valor de <code>X-axis-label-spacing</code>.</p>
<p>La segunda fila del eje X consiste de números, precedidos por varios espacios en blanco y también separado de acuerdo al valor de la variable <code>X-axis-label-spacing</code>.</p>
<p>El valor de la variable <code>X-axis-label-spacing</code> sería medido en unidades de <code>ancho-del-simbolo</code>, puesto que se puede querer cambiar el ancho de los símbolos que estás usando para imprimir el cuerpo del grafico sin cambiar los caminos del grafico que está etiquetado.</p>
<p>La función <code>print-X-axis</code> está construida más o menos del mismo modo como que la función <code>print-Y-axis</code> excepto que tiene dos líneas: la línea de marcas tic y los números. Nosotros escribiremos una función separado a imprimir cada línea y entonces combinarlo con la función <code>print-X-axis</code>.</p>
<p>Esto es un proceso de tres pasos:</p>
<ol class="num" >
<li>
<p>Escribe una función para imprimir el eje X marca tic, <code>print-X-axis-tic-line</code>.</p>
</li>
<li>
<p>Escribe una función imprime los números X, <code>print-X-axis-numbered-line</code>.</p>
</li>
<li>
<p>Escribe una función para imprimir ambas líneas, la función <code>print-X-axis</code>, usando <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>.</p>
</li>
</ol>
</div>
<h4 id="eje-x-marca-tic" >Eje X marca tic</h4>
<div class="hBody-4" >
<p>La primera función imprimiría las marcas de tic del eje X. Se deben especificar las marcas en sí y su espacio:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">X-axis-label-spacing</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">boundp</span> <span class="ss">&#39;simbolo-en-blanco</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">*</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">simbolo-en-blanco</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
  <span class="s">&#34;Números de unidades desde un eje X al siguiente.&#34;</span><span class="p">)</span>
</code></pre>
<p>(Note que el valor de <code>simbolo-en-blanco</code> est&#39;a asignado por otro <code>defvar</code>. El predicado <code>boundp</code> chequea si ya ha sido asignado; <code>boundp</code> devuelve <code>nil</code> si no lo tiene. Si <code>simbolo-en-blanco</code> fuera disociado y no usara esta construcción condicional, en un GNU Emacs reciente, se introduciría el depurador y mirará un mensaje de error diciendo <samp>Debugger entered--Lisp error: (void-variable simbolo-en-blanco)</samp></p>
<p>Aquí está el <code>defvar</code> para <code>X-axis-tic-symbol</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">X-axis-tic-symbol</span> <span class="s">&#34;|&#34;</span>
  <span class="s">&#34;Cadena para insertar para apuntar a una columna en el eje X.&#34;</span><span class="p">)</span>
</code></pre>
<p>El objetivo es crear una línea que se parece a esto:</p>
<div class="example-block" >
<pre class="example" >|   |    |    |
</pre>
</div>
<p>El primer tic es indentado así que está bajo la primera columna, que es indentado para proveer espacio para las etiquetas del eje Y.</p>
<p>Un elemento tic consiste en espacios en blanco que se extienden desde un tic al siguiente más un símbolo tic. El número de espacios en blanco se determinan por el ancho del símbolo tic y el <code>X-axis-label-spacing</code>.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; X-axis-tic-element</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">concat</span>
 <span class="p">(</span><span class="nf">make-string</span>
  <span class="c1">;; Crea una cadena de blancos.</span>
  <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">length</span> <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
  <span class="sc">? </span><span class="p">)</span>
 <span class="c1">;; Concatena blancos con símbolos.</span>
 <span class="nv">X-axis-tic-symbol</span><span class="p">)</span>
<span class="err">…</span>
</code></pre>
<p>Lo siguiente, determina cuantos espacios en blanco son necesarios para indentar la primera marca tic a la primera del grafico. Esto usa el valor de <code>full-Y-label-width</code> pasaba por la función <code>print-graph</code>.</p>
<p>El código para crear <code>X-axis-leading-spaces</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; X-axis-leading-spaces</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">make-string</span> <span class="nv">full-Y-label-width</span> <span class="sc">? </span><span class="p">)</span>
<span class="err">…</span>
</code></pre>
<p>También necesita determinar el tamaño del eje horizontal, que es el tamaño de la lista de números, y el número de ticks en el eje horizontal:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; X-length</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">length</span> <span class="nv">lista-de-numeros</span><span class="p">)</span>

<span class="c1">;; tic-width</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>

<span class="c1">;; number-of-X-ticks</span>
<span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="p">(</span><span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">))))</span>
</code></pre>
<p>Todo esto lidera directamente a la función para imprimir el eje X:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis-tic-line</span>
  <span class="p">(</span><span class="nv">number-of-X-tics</span> <span class="nv">X-axis-leading-spaces</span> <span class="nv">X-axis-tic-element</span><span class="p">)</span>
  <span class="s">&#34;Imprime ticks para el eje X.&#34;</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-tic-symbol</span><span class="p">)</span>  <span class="c1">; En la primera columna.</span>
    <span class="c1">;; Inserta el segundo tic en el lugar adecuado.</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">concat</span>
             <span class="p">(</span><span class="nf">make-string</span>
              <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
                  <span class="c1">;; Inserta el espacio en blanco al segundo símbolo tic.</span>
                  <span class="p">(</span><span class="nf">*</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">X-axis-tic-symbol</span><span class="p">)))</span>
              <span class="sc">? </span><span class="p">)</span>
             <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
    <span class="c1">;; Inserta los ticks restantes.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-X-tics</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-tic-element</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-X-tics</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-X-tics</span><span class="p">))))</span>
</code></pre>
<p>La línea de números es igualmente simple:</p>
<p>Primero, creamos un elemento numerado con espacios en blanco antes de cada número:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">X-axis-element</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Construye un elemento del eje X numerado.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">leading-spaces</span>
         <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">make-string</span> <span class="nv">leading-spaces</span> <span class="sc">? </span><span class="p">)</span>
            <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">))))</span>
</code></pre>
<p>Lo siguiente, se crea la función para imprimir la línea numerada, empezando con el número “1” para la primera columna:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis-numbered-line</span>
  <span class="p">(</span><span class="nv">number-of-X-tics</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
  <span class="s">&#34;Imprime la líneas de números del eje X&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;1&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">concat</span>
             <span class="p">(</span><span class="nf">make-string</span>
              <span class="c1">;; Inserta espacios en blanco al siguiente número.</span>
              <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
              <span class="sc">? </span><span class="p">)</span>
             <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)))</span>
    <span class="c1">;; Insertar números.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-X-tics</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nv">X-axis-element</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-X-tics</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-X-tics</span><span class="p">)))))</span>
</code></pre>
<p>Finalmente, se necesita escribir lo que <code>print-X-axis</code> que usa <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>.</p>
<p>La función debe determinar los valores locales de las variables usadas por <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>, y entonces eso debe llamarlas. También, debe imprimir el retorno de carro que separe las dos líneas.</p>
<p>La función consiste de una varlist que especifica cinco variables locales, y llama cada una de las dos líneas imprimiendo funciones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;Imprime el eje X etique al tamaño de LISTA-DE-NUMEROS.&#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">leading-spaces</span>
          <span class="p">(</span><span class="nf">make-string</span> <span class="nv">full-Y-label-width</span> <span class="sc">? </span><span class="p">))</span>
       <span class="c1">;; ancho-del-simbolo se provee por imprimir-cuerpo-grafico</span>
       <span class="p">(</span><span class="nv">tic-width</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">X-length</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">lista-de-numeros</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">X-tic</span>
        <span class="p">(</span><span class="nf">concat</span>
         <span class="p">(</span><span class="nf">make-string</span>
          <span class="c1">;; Crea una cadena de espacios en blanco.</span>
          <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">length</span> <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
          <span class="sc">? </span><span class="p">)</span>
         <span class="c1">;; Concatena espacio en blanco con símbolos</span>
         <span class="nv">tic.</span>
         <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">tic-number</span>
        <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">/</span> <span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nv">print-X-axis-tic-line</span> <span class="nv">tic-number</span> <span class="nv">leading-spaces</span> <span class="nv">X-tic</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">print-X-axis-numbered-line</span> <span class="nv">tic-number</span> <span class="nv">leading-spaces</span><span class="p">)))</span>
</code></pre>
<p>Se puede testear <code>print-X-axis</code>:</p>
<ul>
<li>
<p>Instale <code>X-axis-tic-symbol</code>, <code>X-axis-label-spacing</code>, <code>print-X-axis-tic-line</code>, tanto como <code>X-axis-element</code>, <code>print-X-axis-numbered-line</code>, y <code>print-X-axis</code>.</p>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">progn</span>
 <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">full-Y-label-width</span> <span class="mi">5</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ancho-del-simbolo</span> <span class="mi">1</span><span class="p">))</span>
   <span class="p">(</span><span class="nv">print-X-axis</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span><span class="p">))))</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li>
<p>Escribe <kbd>M-:</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pegue la expresión de test dentro del minibuffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá el eje horizontal así</p>
<div class="example-block" >
<pre class="example" >|   |    |    |    |
1   5   10   15   20
</pre>
</div>
</div>
<h3 id="imprimiendo-el-grafico-completo" >Imprimiendo el grafico completo</h3>
<div class="hBody-3" >
<p>Ahora estamos listos para imprimir el grafico completo.</p>
<p>La función para imprimir el grafico con las etiquetas apropiadas sigue el esquema que creamos antes (Vease Sección <a href="Un-Grafico-con-Ejes-Etiquetados" >Un Grafico con Ejes Etiquetados</a>), pero con adiciones.</p>
<p>Aquí está el esquema:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span> <span class="p">(</span><span class="nv">lista-de-numeros</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span>  <span class="err">…</span>
        <span class="err">…</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-Y-axis</span> <span class="nv">height</span> <span class="err">…</span> <span class="p">)</span>
    <span class="p">(</span><span class="nv">imprimir-cuerpo-grafico</span> <span class="nv">lista-de-numeros</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">print-X-axis</span> <span class="err">…</span> <span class="p">)))</span>
</code></pre>
<p>La versión final es diferente desde que se planea en dos caminos: primero, contiene los valores adicionales calculadas una vez que en la varlist; segundo, eso trae una opción para específicar las etiquetas se incrementa la fila. Esta última funcionalidad cambia a ser esencial; de otro modo, un grafico puede tener más filas que ajustarse en una muestra o en una hoja de papel.</p>
<p>Esta nueva funcionalidad requiere un cambio a la función <code>Y-axis-column</code>, para añadir <code>vertical-step</code> para eso. Esta función es parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Final.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">Y-axis-column</span>
  <span class="p">(</span><span class="nv">height</span> <span class="nv">width-of-label</span> <span class="kp">&amp;optional</span> <span class="nv">vertical-step</span><span class="p">)</span>
  <span class="s">&#34;Construye una lista de etiquetas para el eje Y.
</span><span class="s">HEIGHT es la máxima altura del grafico.
</span><span class="s">WIDTH-OF-LABEL es el máximo ancho de la etiqueta.
</span><span class="s">VERTICAL-STEP, una opción, es un entero positivo
</span><span class="s">que especifica cuanto una etiqueta de eje Y incrementa
</span><span class="s">cada línea. Por ejemplo, un paso de 5
</span><span class="s">significa que cada línea es cinco unidades
</span><span class="s">del grafico.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">Y-axis</span>
        <span class="p">(</span><span class="nv">number-per-line</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">vertical-step</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">height</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
          <span class="c1">;; Inserta etiqueta.</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
                <span class="p">(</span><span class="nf">cons</span>
                 <span class="p">(</span><span class="nv">Y-axis-element</span>
                  <span class="p">(</span><span class="nf">*</span> <span class="nv">height</span> <span class="nv">number-per-line</span><span class="p">)</span>
                  <span class="nv">width-of-label</span><span class="p">)</span>
                 <span class="nv">Y-axis</span><span class="p">))</span>
        <span class="c1">;; Else, inserta espacios en blanco.</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
              <span class="p">(</span><span class="nf">cons</span>
               <span class="p">(</span><span class="nf">make-string</span> <span class="nv">width-of-label</span> <span class="sc">? </span><span class="p">)</span>
               <span class="nv">Y-axis</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">height</span><span class="p">)))</span>
    <span class="c1">;; Inserta línea base.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span> <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">Y-axis-element</span>
                        <span class="p">(</span><span class="nb">or</span> <span class="nv">vertical-step</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="nv">width-of-label</span><span class="p">)</span>
                       <span class="nv">Y-axis</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">Y-axis</span><span class="p">)))</span>
</code></pre>
<p>Los valores para la máxima altura del grafico y el ancho de un símbolo se computan por <code>print-graph</code> es su expresión <code>let</code>; así <code>imprimir-cuerpo-grafico</code> debe ser cambiado para aceptarlos.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Final.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-cuerpo-grafico</span> <span class="p">(</span><span class="nv">lista-de-numeros</span> <span class="nv">height</span> <span class="nv">ancho-del-simbolo</span><span class="p">)</span>
  <span class="s">&#34;Imprime una gráfica de barras del LISTA-DE-NUMEROS.
</span><span class="s">El lista-de-numeros consiste en los valores del eje Y.
</span><span class="s">HEIGHT es la máxisma altura del grafico.
</span><span class="s">ANCHO-DEL-SIMBOLO es el número de cada columna.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">desde-la-posicion</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">lista-de-numeros</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">desde-la-posicion</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">insert-rectangle</span>
       <span class="p">(</span><span class="nv">columna-del-grafico</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-de-numeros</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">desde-la-posicion</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">ancho-del-simbolo</span><span class="p">)</span>
      <span class="c1">;; Dibuja el grafico columna por columna.</span>
      <span class="p">(</span><span class="nv">sit-for</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-numeros</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-de-numeros</span><span class="p">)))</span>
    <span class="c1">;; Posiciona el punto para las etiquetas del eje X.</span>
    <span class="p">(</span><span class="nf">forward-line</span> <span class="nv">height</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;\n&#34;</span><span class="p">)))</span>
</code></pre>
<p>Finalmente, el código para la función <code>print-graph</code>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Final.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span>
  <span class="p">(</span><span class="nv">lista-de-numeros</span> <span class="kp">&amp;optional</span> <span class="nv">vertical-step</span><span class="p">)</span>
  <span class="s">&#34;El gráfico de barras etiquetadas del LISTA-DE-NUMEROS.
</span><span class="s">El lista-de-numeros consiste en los valores de eje Y.
</span><span class="s">
</span><span class="s">Opcionalmente, VERTICAL-STEP, un entero positivo, especifica cuanto el
</span><span class="s">eje Y incrementa cada línea. Por ejemplo, un paso de 5
</span><span class="s">significa que cada fila es de cinco unidades.
</span><span class="s">  (let* ((ancho-del-simbolo (length simbolo-en-blanco))
</span><span class="s">         ;; @c{height} en ambos es el número más largo
</span><span class="s">         ;; y el número con la mayoría de los digitos.
</span><span class="s">         (height (apply &#39;max lista-de-numeros))
</span><span class="s">         (height-of-top-line
</span><span class="s">          (if (zerop (% height Y-axis-label-spacing))
</span><span class="s">              height
</span><span class="s">            ;; else
</span><span class="s">            (* (1+ (/ height Y-axis-label-spacing))
</span><span class="s">               Y-axis-label-spacing)))
</span><span class="s">         (vertical-step (or vertical-step 1))
</span><span class="s">         (full-Y-label-width
</span><span class="s">          (length
</span><span class="s">           (concat
</span><span class="s">            (number-to-string
</span><span class="s">             (* height-of-top-line vertical-step))
</span><span class="s">            Y-axis-tic))))
</span><span class="s">
</span><span class="s">    (print-Y-axis
</span><span class="s">     height-of-top-line full-Y-label-width vertical-step)
</span><span class="s">    (imprimir-cuerpo-grafico
</span><span class="s">     lista-de-numeros height-of-top-line ancho-del-simbolo)
</span><span class="s">    (print-X-axis lista-de-numeros)))
</span><span class="s"></span></code></pre>
</div>
<h4 id="testeando-print-graph" >Testeando <code>print-graph</code></h4>
<div class="hBody-4" >
<p>Se puede probar la función <code>print-graph</code> con una lista ordenada de números:</p>
<ul>
<li>
<p>Instala las versiones finales de <code>Y-axis-column</code>, <code>imprimir-cuerpo-grafico</code>, y <code>print-graph</code> (además del resto del código.)</p>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-graph</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li>
<p>Escribe <kbd>M-:</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pegue la expresión de test dentro del minibuffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá un grafico que se parece a:</p>
<div class="example-block" >
<pre class="example" >10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
</pre>
</div>
<p>Por otro lado, si se pasa a <code>print-graph</code> un <code>vertical-step</code> valor de 2, evaluando esta expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-graph</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>El grafico se parece a esto:</p>
<div class="example-block" >
<pre class="example" >20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
</pre>
</div>
<p>(Una pregunta: ¿es el ‘2’ debajo del eje vertical un error o una funcionalidad? Si se piensa que es un error, y sería un ‘1’, (o incluso un ‘0’), se pueden modificar las fuentes.)</p>
</div>
<h4 id="creando-gráficas-de-números-de-palabras-y-símbolos" >Creando gráficas de números de palabras y símbolos</h4>
<div class="hBody-4" >
<p>Ahora para el gráfico para el que todo este código fué escrito: un gráfico que muestra cuantas definiciones de función contienen unas pocas 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuantos contienen entre 20 y 29 palabras y símbolos, y así sucesivamente.</p>
<p>Esto es un proceso de múltiples pasos. Primero asegúrate que has cargado todo el requisito del código.</p>
<p>Eso es una buena idea para eliminar el valor de <code>cima-de-rangos</code> en caso de que has asignado a algún valor diferente. Se puede evaluar lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">cima-de-rangos</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span>  <span class="mi">20</span>  <span class="mi">30</span>  <span class="mi">40</span>  <span class="mi">50</span>
   <span class="mi">60</span>  <span class="mi">70</span>  <span class="mi">80</span>  <span class="mi">90</span> <span class="mi">100</span>
  <span class="mi">110</span> <span class="mi">120</span> <span class="mi">130</span> <span class="mi">140</span> <span class="mi">150</span>
  <span class="mi">160</span> <span class="mi">170</span> <span class="mi">180</span> <span class="mi">190</span> <span class="mi">200</span>
  <span class="mi">210</span> <span class="mi">220</span> <span class="mi">230</span> <span class="mi">240</span> <span class="mi">250</span>
  <span class="mi">260</span> <span class="mi">270</span> <span class="mi">280</span> <span class="mi">290</span> <span class="mi">300</span><span class="p">)</span>
</code></pre>
<p>Lo siguiente crea una lista del número de palabras y símbolos en cada rango.</p>
<p>Evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">list-for-graph</span>
       <span class="p">(</span><span class="nv">definiciones-por-rango</span>
         <span class="p">(</span><span class="nf">sort</span>
          <span class="p">(</span><span class="nv">lista-de-longitudes-de-muchos-ficheros-recursiva</span>
           <span class="p">(</span><span class="nf">directory-files</span> <span class="s">&#34;/usr/local/emacs/lisp&#34;</span>
                            <span class="no">t</span> <span class="s">&#34;.+el$&#34;</span><span class="p">))</span>
          <span class="ss">&#39;&lt;</span><span class="p">)</span>
         <span class="nv">cima-de-rangos</span><span class="p">))</span>
</code></pre>
<p>En mi vieja máquina, esto lleva como una hora. Se parece a 303 ficheros Lisp en mi copia de Emacs version 19.23. Después de toda esta computación, el <code>list-for-graph</code> tenía este valor:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">537</span> <span class="mi">1027</span> <span class="mi">955</span> <span class="mi">785</span> <span class="mi">594</span> <span class="mi">483</span> <span class="mi">349</span> <span class="mi">292</span> <span class="mi">224</span> <span class="mi">199</span> <span class="mi">166</span> <span class="mi">120</span> <span class="mi">116</span> <span class="mi">99</span>
<span class="mi">90</span> <span class="mi">80</span> <span class="mi">67</span> <span class="mi">48</span> <span class="mi">52</span> <span class="mi">45</span> <span class="mi">41</span> <span class="mi">33</span> <span class="mi">28</span> <span class="mi">26</span> <span class="mi">25</span> <span class="mi">20</span> <span class="mi">12</span> <span class="mi">28</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">220</span><span class="p">)</span>
</code></pre>
<p>Esto significa que mi copia de Emacs tiene 537 definiciones de funciones con poco menos de 10 palabras o símbolos en sí, 1027 definiciones de función con 10 a 19 palabras o símbolos dentro, 955 definiciones de función con 20 a 29 palabras o símbolos dentro, y así sucesivamente.</p>
<p>Claramente, solo buscando esta lista se puede ver que la mayoría de definiciones de función contienen de diez a treinta palabras y símbolos.</p>
<p>Ahora para imprimir. Nosotros no queremos imprimir un grafico que es de 1030 líneas de alto …. En vez de eso, imprimiría un grafico que es mejor que venticinco líneas de alto. Un grafico cuya altura puede ser mostrada en casi cualquier monitor, y fácilmente impreso en una hoja de papel.</p>
<p>Esto significa que cada valor en <code>list-for-graph</code> debe ser reducido a un quinceavo de su valor presente.</p>
<p>Aquí hay una corta función para hacer esto, usando dos funciones que no se han visto todavía, <code>mapcar</code> y <code>lambda</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">one-fiftieth</span> <span class="p">(</span><span class="nv">full-range</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista, con el cincuenteavo de cada elemento.&#34;</span>
 <span class="p">(</span><span class="nf">mapcar</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span> <span class="nv">full-range</span><span class="p">))</span>
</code></pre>
</div>
<h4 id="una-expresión-lambda:-anonimicidad-útil" >Una expresión <code>lambda</code>: Anonimicidad útil</h4>
<div class="hBody-4" >
<p><code>lambda</code> es el símbolo para una función anónima, una función sin un nombre. Cada vez que se use una función anónima, se necesita incluir su cuerpo completo.</p>
<p>De este modo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span>
</code></pre>
<p>es una definición de función que dice ‘devuelve el valor resultante de dividir cualquier cosa que es pasada como <code>arg</code> por 50’.</p>
<p>Pronto, por ejemplo, se tenía una función <code>multiplicar-por-siete</code>; se multiplica su argumento por 7. Esta función es similar, excepto que divide su argumento por 50; y, no tiene nombre. El equivalente anónimo de <code>multiplicar-por-siete</code> es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">number</span><span class="p">))</span>
</code></pre>
<p>(Vea la Seccion <a href="La-forma-especial-defun" >La forma especial <code>defun</code></a>.)</p>
<p>Si queremos multiplicar 3 por 7, podemos escribir:</p>
<div class="art-block" >
<pre class="art" >(multiplicar-por-siete 3)
 \_______________/ ^
         |         |
      función  argumento
</pre>
</div>
<p>Esta expresión devuelve 21.</p>
<p>De manera similar, se puede escribir:</p>
<div class="art-block" >
<pre class="art" >((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      función anónima     argumento
</pre>
</div>
<p>Si queremos dividir 100 por 50, se puede escribir:</p>
<div class="art-block" >
<pre class="art" >((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
     función anónima   argumento
</pre>
</div>
<p>Esta expresión devuelve 2. El 100 es pasado para la función, que divide este número por 50.</p>
<p>Vea la Seccion <q>Expresiones Lambda</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más acerca de <code>lambda</code>. Lisp y expresiones Lambda se derivan del Cálculo Lambda.</p>
</div>
<h3 id="la-función-mapcar" >La función <code>mapcar</code></h3>
<div class="hBody-3" >
<p><code>mapcar</code> es una función que llama a su primer argumento con cada elemento de su segundo argumento. El segundo argumento debe ser una secuencia.</p>
<p>La parte <samp>map</samp> del nombre viene de la frase matemática, ‘mapeando a través de un dominio’, significa hace apply a una función a cada uno de los elementos en un dominio. La frase matemática está basada en la metáfora de un superviviente paseando, un paso en un momento, a través de un área él está mapeando. Y <samp>car</samp>, de acuerdo, viene desde la noción Lisp del primero de una lista.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mapcar</span> <span class="ss">&#39;1+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">)</span>
</code></pre>
<p>La función <code>1+</code> añade uno a su argumento, es ejecutada en <em>each</em> de la lista, y una nueva lista es devuelta.</p>
<p>En contraste con esto <code>apply</code>, se aplica su primer argumento a todo lo que permanece. (Vea la Seccion <a href="Preparar-un-grafico" >Preparar un grafico</a>, para una explicación de <code>apply</code>.)</p>
<p>En la definición de <code>one-fiftieth</code>, el primer argumento es la función anónima:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span>
</code></pre>
<p>y el segundo argumento es <code>full-range</code>, que será asociado para <code>list-for-graph</code>.</p>
<p>La expresión completa se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mapcar</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span> <span class="nv">full-range</span><span class="p">))</span>
</code></pre>
<p>Vea la Seccion <q>Mapeando Funciones</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más acerca de <code>mapcar</code>.</p>
<p>Usando la función <code>one-fiftieth</code>, se puede generar una lista en el que cada elemento es un cincuenteavo del tamaño del correspondiente elemento en <code>list-for-graph</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">fiftieth-list-for-graph</span>
      <span class="p">(</span><span class="nv">one-fiftieth</span> <span class="nv">list-for-graph</span><span class="p">))</span>
</code></pre>
<p>La lista resultante se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">19</span> <span class="mi">15</span> <span class="mi">11</span> <span class="mi">9</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Así, ¡ya estamos casi listos para imprimir!  (También se notifica la pérdida de información: muchos de los rangos superiores son 0, esto significa que menos de 50 funciones tenían muchas palabras o símbolos––pero no necesariamente significando que niguna tenía muchas palabras o símbolos.)</p>
</div>
<h4 id="otro-error-…-más-insidioso" >Otro error … más insidioso</h4>
<div class="hBody-4" >
<p>¡Se dijo ‘casi listo para imprimir’! De acuerdo, hay un error en la función <code>print-graph</code> …. Esta tiene una opción <code>vertical-step</code>, pero no una opción <code>horizontal-step</code>. La escala <code>cima-de-rango</code> va desde 10 a 300 por decenas. Pero la función <code>print-graph</code> imprimirá solo uno por uno.</p>
<p>Esto es un ejemplo clásico de lo que algunos consideramos el tipo más insidioso de error, el error de omisión. Este no es el tipo de error que se puede encontrar estudiando el código, para eso no es el código; es una funcionalidad omitida. Tus mejores acciones son probar tu programa pronto y con frecuencia; e intentar poner en orden, tanto como se pueda, escribir código que sea fácil de comprender y fácil de cambiar. Intenta ser consciente, siempre y cuando se pueda, esto es siempre que tengas que escribir, <em>será</em> reescrito, si no pronto, eventualmente. Un máximo duro de seguir.</p>
<p>Esta es la función <code>print-X-axis-numbered-line</code> que necesita el trabajo; y entonces el <code>print-X-axis</code> y la función <code>print-graph</code> necesita ser adaptada. No se necesita mucho para ser hecho; hay uno simpático: los números podrían alinearse con marcas de tic. Esto toma un pequeño pensamiento.</p>
<p>Aquí está el <code>print-X-axis-numbered-line</code> corregido:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis-numbered-line</span>
  <span class="p">(</span><span class="nv">number-of-X-tics</span> <span class="nv">X-axis-leading-spaces</span>
   <span class="kp">&amp;optional</span> <span class="nv">horizontal-step</span><span class="p">)</span>
  <span class="s">&#34;Imprime la líneas de números X-axis&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">horizontal-step</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">horizontal-step</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
    <span class="c1">;; Elimina espacios extra de guía.</span>
    <span class="p">(</span><span class="nf">delete-char</span>
     <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">1-</span>
         <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">horizontal-step</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">concat</span>
             <span class="p">(</span><span class="nf">make-string</span>
              <span class="c1">;; Inserta espacio en blanco.</span>
              <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">ancho-del-simbolo</span>
                     <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">1-</span>
                   <span class="p">(</span><span class="nf">length</span>
                    <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">horizontal-step</span><span class="p">)))</span>
                  <span class="mi">2</span><span class="p">)</span>
              <span class="sc">? </span><span class="p">)</span>
             <span class="p">(</span><span class="nf">number-to-string</span>
              <span class="p">(</span><span class="nf">*</span> <span class="nv">number</span> <span class="nv">horizontal-step</span><span class="p">))))</span>
    <span class="c1">;; Insertar los números restantes.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-X-tics</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nv">X-axis-element</span>
               <span class="p">(</span><span class="nf">*</span> <span class="nv">number</span> <span class="nv">horizontal-step</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-X-tics</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-X-tics</span><span class="p">)))))</span>
</code></pre>
<p>Si se está leyendo esto en Info, se pueden ver las nuevas versiones <code>print-X-axis</code> y <code>print-graph</code> y los evaluarlas. Si se está leyendo esto en un libro impreso, se pueden ver las líneas cambiadas aquí (el texto completo es mucho para imprimir).</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis</span> <span class="p">(</span><span class="nv">lista-de-numeros</span> <span class="nv">horizontal-step</span><span class="p">)</span>
  <span class="err">…</span>
    <span class="p">(</span><span class="nv">print-X-axis-numbered-line</span>
     <span class="nv">tic-number</span> <span class="nv">leading-spaces</span> <span class="nv">horizontal-step</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span>
  <span class="p">(</span><span class="nv">lista-de-numeros</span>
   <span class="kp">&amp;optional</span> <span class="nv">vertical-step</span> <span class="nv">horizontal-step</span><span class="p">)</span>
  <span class="err">…</span>
    <span class="p">(</span><span class="nv">print-X-axis</span> <span class="nv">lista-de-numeros</span> <span class="nv">horizontal-step</span><span class="p">))</span>
</code></pre>
</div>
<h4 id="el-gráfico-impreso" >El gráfico impreso</h4>
<div class="hBody-4" >
<p>Cuando esté hecho e instalado, se puede llamar al comando <code>print-graph</code> como esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-graph</span> <span class="nv">fiftieth-list-for-graph</span> <span class="mi">50</span> <span class="mi">10</span><span class="p">)</span>
</code></pre>
<p>Aquí está el gráfico:</p>
<div class="example-block" >
<pre class="example" >1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
</pre>
</div>
<p>El grupo largo de funciones contienen de 10 a 19 palabras y símbolos.</p>
</div>
<h2 id="apéndice-d-software-libre-y-manuales-libres-por-richard-m.-stallman" >Apéndice D Software Libre y Manuales Libres (<b>por Richard M. Stallman</b>)</h2>
<div class="hBody-2" >
<p>La mayor deficiencia en sistemas operativos libres no está en el software––es la falta de buenos manuales libres que se puedan incluir en estos sistemas. Muchos de nuestros programas más importantes no vienen con manuales completos. La documentación es una parte esencial de cualquier paquete de software; cuando un paquete de software libre no viene con un manual libre, es una brecha mayor. Nosotros tenemos muchas brechas hoy.</p>
<p>Érase una vez, hace muchos años, se piensa que aprendería Perl. Se tiene una copia de un manual libre, pero se encontró difícil de leer. Cuando pregunto a los usuarios de Perl acerca de alternativas, me contaron que serían mejor los manuales introductorios––pero estos no eran libres.</p>
<p>¿Por qué era esto? Los autores de los buenos manuales los habían escrito para O&#39;Reilly Associates, que los publicaron con términos restrictivos––no copiando, no modificando, los ficheros fuentes están disponibles––que los excluyen desde la comunidad de software libre.</p>
<p>No era la primera vez que esto ocurría, y (para nuestra comunidad es una gran pérdida) eso está lejos desde el último. Las editoriales de manuales privativos han logrado que muchos autores restrinjan sus manuales desde entonces. Muchas veces se ha oido que un usuario de GNU hábil me cuente que un manual que está escribiendo, con el que él espera ayudar al proyecto GNU––y entonces tenía mis esperanzas frustradas, como se ha procedió a explicar que él tenía que haber firmado un contrato con una editorial que restringiría eso, así que no puede usarlo.</p>
<p>Debido a que escribir buen inglés es una habilidad rara entre programadores, se pueden perder manuales por este motivo.</p>
<p>La documentación, como el software, es una cuestión de libertad, no de precio. El problema con estos manuales no eran que O&#39;Reilly Associates impusiera un precio por las copias impresas––que en sí estaban bien. La Free Software Foundation <em>Fundación por el Software Libre</em> <a href="http://shop.fsf.org,-vende-copias-impresas" >http://shop.fsf.org, vende copias impresas</a> de <a href="http://www.gnu.org/doc/doc.html,-manuales-libres-de-GNU" >http://www.gnu.org/doc/doc.html, manuales libres de GNU</a>, también. Pero los manuales de GNU están disponibles en forma de código fuente, mientras que estos manuales están disponibles solo en papel. Los manuales de GNU vienen con permiso para copiar y modificar; los manuales de Perl no. Estas restricciones son un problema.</p>
<p>El criterio para un manual libre es parecido al del software libre: es una cuestión de dar a todos los usuarios ciertas libertades. La redistribución (incluyendo redistribución comercial) debe ser permitida, así el manual puede acompañar cada copia del programa, en líne o en papel. El permiso para modificar es crucial también.</p>
<p>Como regla general, no se cree que sea esencial para la gente tener permisos para modificar todas las partes de artículos y libro. Las cuestiones para escritos no son necesariamente las mismas como estas para el software. Por ejemplo, no se sabe si se está obligado a dar permisos para modificar artículos como este, que describen nuestras acciones y nuestras vistas.</p>
<p>Pero hay una razón particular de por qué la libertad de modificar es crucial para la documentación de software libre. Cuando las personas ejercita su derecho a modificar el software, y añadir o cambiar sus funcionalidades, si son consciente ellos cambiarán el manual también––así se puede proveer documentación usable y cuidada con el programa modificado. Un manual que prohibe a los programadores ser consciente y finalizar el trabajo, o más precisamente requiere escribir un nuevo manual desde cero si ellos cambian el programa, no se ajusta a las necesidades de nuestra comunidad.</p>
<p>Mientras una serie de prohibiciones en la modificación es inaceptable, algunos tipos de límites en el método de modificar no tiene tanto problema. Por ejemplo, los requisitos para preservar la noticia de autores del copyright, los términos de distribución, o la lista de autores, estén ok. Eso es también no da problemas para requerir versiones modificadas para incluir notificar que fueron modificadas, incluso tienen secciones enteras que puede no ser eliminadas o cambiadas, tan largo como estas secciones tratan con asuntos no técnicos. (Algunos manuales de GNU los tienen).</p>
<p>Estos tipos de restricciones no son un problema porque, como materia práctica, no para al programador consciente desde la adaptación del manual para ajustar el programa modificado. En otras palabras, no se bloquea la comunidad del software libre haciendo el uso completo del manual.</p>
<p>Sin embargo, debe ser posible modificar todo el contenido técnico del manual, y entonces se distribuye el resultado en todos los medios usuales, a través de todos los canales usuales; de otro modo, las restricciones bloquean la comunidad, el manual no es libre, y así no se necesita otro manual.</p>
<p>Desafortunadamente, con frecuencia es duro encontrar a alguien a escribir otro manual cuando un manual privativo. El obstáculo es que muchos usuario piensan que un manual privativo es suficientemente bueno––así ellos no ven la necesidad de escribir un manual libre. Ellos no ven que el sistema operativo tiene un gazapo que necesita se rellenado.</p>
<p>¿Por qué los usuarios piensan que los manuales privativos son suficientemente buenos? Algunos no han considerado la cuestión. Espero que este artículo hará alguna cosa para cambiar esto.</p>
<p>Otros usuarios considera manuales privativos aceptables para la misma razón así muchas personas software privativo aceptable: ellos judgan en términos puramente prácticos, no usando la liberta como un criterio. Estas personas son tituladas a sus opiniones, pero desde que estas opciones crezcan desde valores que no incluyen libertad, ellas no están guiadas por esto quienes valoran la libertad.</p>
<p>Por favor, populariza esta cuestión. Se continúa a perder manuales para publicación privativa. Si se populariza que los manuales privativos no son suficientes, quizás la siguiente persona que quiere ayudar a GNU escribiendo documentación realizará, antes de que sea demasiado tarde, lo que él debe que todo sea libre.</p>
<p>Se puede también animar editoriales comerciales a vender manuales libres o con copyleft en vez de uno privativo. Un camino que se puede ayudar esto chequea los términos de la distribución de un manual antes de que se compre, y preferimos manuales copyleft a los no copyleft.</p>
<p>Note: La Fundación para el Software Libre mantiene una página en su sitio Web que liste libros libres disponibles desde otras editoriales: <a href="http://www.gnu.org/doc/other-free-books.html" >http://www.gnu.org/doc/other-free-books.html</a></p>
</div>
<h2 id="appendix-e-gnu-free-documentation-license" >Appendix E GNU Free Documentation License</h2>
<div class="hBody-2" >
<div class="center" >
<p>Version 1.3, 3 November 2008</p>
</div>
<p>Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</p>
<p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>
</div>
<h3 id="0.-preamble" >0. PREAMBLE</h3>
<div class="hBody-3" >
<p>The purpose of this License is to make a manual, textbook, or other functional and useful document &#34;free&#34; in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</p>
<p>This License is a kind of &#34;copyleft&#34;, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.</p>
<p>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.</p>
</div>
<h3 id="1.-applicability-and-definitions" >1. APPLICABILITY AND DEFINITIONS</h3>
<div class="hBody-3" >
<p>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The &#34;Document&#34;, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as &#34;you&#34;. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</p>
<p>A &#34;Modified Version&#34; of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</p>
<p>A &#34;Secondary Section&#34; is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document&#39;s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject.  (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.)  The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</p>
<p>The &#34;Invariant Sections&#34; are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.</p>
<p>The &#34;Cover Texts&#34; are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</p>
<p>A &#34;Transparent&#34; copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not &#34;Transparent&#34; is called &#34;Opaque&#34;.</p>
<p>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.</p>
<p>The &#34;Title Page&#34; means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, &#34;Title Page&#34; means the text near the most prominent appearance of the work&#39;s title, preceding the beginning of the body of the text.</p>
<p>The &#34;publisher&#34; means any person or entity that distributes copies of the Document to the public.</p>
<p>A section &#34;Entitled XYZ&#34; means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language.  (Here XYZ stands for a specific section name mentioned below, such as &#34;Acknowledgements&#34;, &#34;Dedications&#34;, &#34;Endorsements&#34;, or &#34;History&#34;.)  To &#34;Preserve the Title&#34; of such a section when you modify the Document means that it remains a section &#34;Entitled XYZ&#34; according to this definition.</p>
<p>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</p>
</div>
<h3 id="2.-verbatim-copying" >2. VERBATIM COPYING</h3>
<div class="hBody-3" >
<p>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.</p>
<p>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</p>
</div>
<h3 id="3.-copying-in-quantity" >3. COPYING IN QUANTITY</h3>
<div class="hBody-3" >
<p>If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document&#39;s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</p>
<p>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</p>
<p>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</p>
<p>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</p>
</div>
<h3 id="4.-modifications" >4. MODIFICATIONS</h3>
<div class="hBody-3" >
<p>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:</p>
<ol class="alpha" >
<li>
<p>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.</p>
</li>
<li>
<p>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.</p>
</li>
<li>
<p>State on the Title page the name of the publisher of the Modified Version, as the publisher.</p>
</li>
<li>
<p>Preserve all the copyright notices of the Document.</p>
</li>
<li>
<p>Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.</p>
</li>
<li>
<p>Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.</p>
</li>
<li>
<p>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document&#39;s license notice.</p>
</li>
<li>
<p>Include an unaltered copy of this License.</p>
</li>
<li>
<p>Preserve the section Entitled &#34;History&#34;, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled &#34;History&#34; in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.</p>
</li>
<li>
<p>Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the &#34;History&#34; section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.</p>
</li>
<li>
<p>For any section Entitled &#34;Acknowledgements&#34; or &#34;Dedications&#34;, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.</p>
</li>
<li>
<p>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.</p>
</li>
<li>
<p>Delete any section Entitled &#34;Endorsements&#34;. Such a section may not be included in the Modified Version.</p>
</li>
<li>
<p>Do not retitle any existing section to be Entitled &#34;Endorsements&#34; or to conflict in title with any Invariant Section.</p>
</li>
<li>
<p>Preserve any Warranty Disclaimers.</p>
</li>
</ol>
<p>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version&#39;s license notice. These titles must be distinct from any other section titles.</p>
<p>You may add a section Entitled &#34;Endorsements&#34;, provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</p>
<p>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</p>
</div>
<h3 id="5.-combining-documents" >5. COMBINING DOCUMENTS</h3>
<div class="hBody-3" >
<p>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</p>
<p>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</p>
<p>In the combination, you must combine any sections Entitled &#34;History&#34; in the various original documents, forming one section Entitled &#34;History&#34;; likewise combine any sections Entitled &#34;Acknowledgements&#34;, and any sections Entitled &#34;Dedications&#34;. You must delete all sections Entitled &#34;Endorsements&#34;.</p>
</div>
<h3 id="6.-collections-of-documents" >6. COLLECTIONS OF DOCUMENTS</h3>
<div class="hBody-3" >
<p>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</p>
<p>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</p>
</div>
<h3 id="7.-aggregation-with-independent-works" >7. AGGREGATION WITH INDEPENDENT WORKS</h3>
<div class="hBody-3" >
<p>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an &#34;aggregate&#34; if the copyright resulting from the compilation is not used to limit the legal rights of the compilation&#39;s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.</p>
<p>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document&#39;s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.</p>
</div>
<h3 id="8.-translation" >8. TRANSLATION</h3>
<div class="hBody-3" >
<p>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</p>
<p>If a section in the Document is Entitled &#34;Acknowledgements&#34;, &#34;Dedications&#34;, or &#34;History&#34;, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.</p>
</div>
<h3 id="9.-termination" >9. TERMINATION</h3>
<div class="hBody-3" >
<p>You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.</p>
<p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p>
<p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p>
<p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.</p>
</div>
<h3 id="10.-future-revisions-of-this-license" >10. FUTURE REVISIONS OF THIS LICENSE</h3>
<div class="hBody-3" >
<p>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.</p>
<p>Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License &#34;or any later version&#34; applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy&#39;s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.</p>
</div>
<h3 id="11.-relicensing" >11. RELICENSING</h3>
<div class="hBody-3" >
<p>&#34;Massive Multiauthor Collaboration Site&#34; (or &#34;MMC Site&#34;) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A &#34;Massive Multiauthor Collaboration&#34; (or &#34;MMC&#34;) contained in the site means any set of copyrightable works thus published on the MMC site.</p>
<p>&#34;CC-BY-SA&#34; means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.</p>
<p>&#34;Incorporate&#34; means to publish or republish a Document, in whole or in part, as part of another Document.</p>
<p>An MMC is &#34;eligible for relicensing&#34; if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.</p>
<p>The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.</p>
</div>
<h2 id="addendum:-how-to-use-this-license-for-your-documents" >ADDENDUM: How to use this License for your documents</h2>
<div class="hBody-2" >
<p>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</p>
<div class="pre-block" >
<pre class="pre" >Copyright (c)  YEAR  YOUR NAME.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled &#34;GNU
Free Documentation License&#34;.
</pre>
</div>
<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the &#34;with...Texts.&#34; line with this:</p>
<div class="pre-block" >
<pre class="pre" >with the Invariant Sections being LIST THEIR TITLES, with the
Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
</pre>
</div>
<p>If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.</p>
<p>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</p>
</div>
<h3 id="acerca-del-autor" >Acerca del Autor</h3>
<div class="hBody-3" >
<p>Robert J. Chassell ha trabajado con GNU Emacs desde 1985. Él escribe, edita y enseña Emacs y Emacs Lisp, y habla alrededor del mundo acerca de la libertad del software. Chassell es Director fundador y Tesorero de la Fundación por el Software Libre (FSF). Él se graduó la Universidad de Cambridge, en Inglaterra. Él tiene un interés contínuo en historia económica y social y vuela su propio aeroplano</p>
</div>
<h2 id="footnotes" >footnotes</h2>
<div class="hBody-2" >
<div class="about" >
<div class="about-dt" ><span class="defnote" id="1" >1</span></div>
<div class="about-dd" >
<p>El apóstrofo o comilla es una abreviación para la función <code>quote</code>; no es necesario pensar en las funciones ahora; las funciones se definen en la Seccion <a href="Generar-un-mensaje-de-error" >Generar un mensaje de error</a>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="2" >2</span></div>
<div class="about-dd" >
<p>Es curioso seguir el camino por el que la palabra ‘argumento’ llego a tener dos significados distintos, uno en matemáticas y otro en el inglés cotidiano. De acuerdo al <em>Oxford English Dictionary</em>, la palabra deriva del Latín para <samp>dejar claro, probar</samp>; por lo tanto, paso a significar, por un hilo de derivación, ‘la evidencia ofrecida como prueba’, es decir ‘la informacion que se ofrece’, que conduce a su significado en Lisp. Pero en el otro hilo de la derivación, paso a significar ‘afirmar de una manera contra la cual otros pueden hacer afirmaciones contrarias’, lo que llevó al significado de la palabra como disputa. (Tenga en cuenta que la palabra Inglésa tiene dos definiciones distintas al mismo tiempo. En contraste, en Emacs Lisp, un símbolo no puede tener dos definiciones de funcion diferentes al mismo tiempo.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="3" >3</span></div>
<div class="about-dd" >
<p><code>(quote hola)</code> es una expansión de la abreviatura <code>&#39;hola</code>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="4" >4</span></div>
<div class="about-dd" >
<p>En realidad, puede utilizar <code>%s</code> para imprimir un número. No es específico. <code>%d</code> solo imprime la parte de un número a la izquierda del punto decimal, excluyendo cualquier cosa que no sea un número.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="5" >5</span></div>
<div class="about-dd" >
<p>En realidad, por defecto, si el búfer desde el que acabas de cambiar es visible por tí en otra ventana, <code>other-buffer</code> elegirá el búfer más reciente que no puedas ver; esta es una sutileza que a menudo olvido.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="6" >6</span></div>
<div class="about-dd" >
<p>O mejor dicho, para evitar escribir, probablemente solo necesites pulsar <kbd>RET</kbd> si <span class="file" >*scratch*</span> es el buffer por defecto, de ser diferente, solo escribe parte del nombre, por ejemplo <code>*sc</code>, luego presiona la tecla <kbd>TAB</kbd> para hacer que se expanda el nombre completo, y finalmente pulsa <kbd>RET</kbd>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="7" >7</span></div>
<div class="about-dd" >
<p>Recuerda, esta expresión te desplaza al buffer diferente más reciente que no puedas ver. Si realmente quieres ir al ultimo búfer seleccionado, incluso si es visible, es necesario evaluar la siguiente expresión más compleja:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
</code></pre>
<p>En este caso, el primer argumento de <code>other-buffer</code> le dice a que búfer saltar––el actual––y el segundo argumento <code>other-buffer</code> le indica que esta BIEN cambiar a un búfer visible. La utilidad de <code>switch-to-buffer</code> es llevarte a una ventana invisible ya que probablemente usarias <kbd>C-x o</kbd> (<code>other-window</code>) para ir a otro búfer visible.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="8" >8</span></div>
<div class="about-dd" >
<p>Segun Jared Diamond en <em>Guns, Germs, and Steel</em>, “… las cebras se vuelven increiblemente peligrosas a medida que envejecen” pero la afirmacion aquí es que no llegan a ser feroces como un tigre. (1997, W. W. Norton and Co., ISBN 0-393-03894-2, pagina 171)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="9" >9</span></div>
<div class="about-dd" >
<p>Actualmente, se puede <code>cons</code> un elemento para un átomo para producir a para punteado. Los pares punteados no se discuten aquí; ver Seccion &#34;Notación de Para Punteado&#34; en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="10" >10</span></div>
<div class="about-dd" >
<p>Más precisamente, y requiriendo conocimiento más experto para entender, los dos enteros son del tipo ‘Lisp_Object’, que también puede ser una unión C en lugar de un tipo entero.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="11" >11</span></div>
<div class="about-dd" >
<p>Puedes escribir funciones recursivas para ser frugales o derrochar recursos mentales o computacionales; como sucede, los métodos que la gente encuentra fáciles––que son frugales de ‘recursos mentales’––algunas veces usan considerables recursos del computador. Emacs fué diseñado para ejecutarse en máquinas que ahora consideramos limitadas y su configuracion por defecto es conservadora. Es posible que desees incrementar los valores de <code>max-specdl-size</code> y <code>max-lisp-eval-depth</code>. En mi fichero <span class="file" >.emacs</span>, yo los asigno a 15 o 30 veces su valor predeterminado.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="12" >12</span></div>
<div class="about-dd" >
<p>La frase <dfn>recursion de cola</dfn> se utiliza para describir tal proceso, uno que usa ‘espacio constante’.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="13" >13</span></div>
<div class="about-dd" >
<p>La jerga es ligeramente confusa: <code>triangulo-recursivo-auxiliar</code> usa un proceso que es iterativo en un procedimiento que es recursivo. El proceso se llama iterativo porque el ordenador necesita solo grabar los tres valores, <code>suma</code>, <code>contador</code>, y <code>número</code>: el procedimiento es recursivo porque la función ‘se llama a sí misma’. Por otra parte, tanto el proceso como el procedimiento usado por <code>triangulo-recursivo</code> se denominan recursivos. La palabra ‘recursivo’ tiene significados diferentes en los dos contextos.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="14" >14</span></div>
<div class="about-dd" >
<p>Tu puedes también añadir <span class="file" >.el</span> para <span class="file" >~/.emacs</span> y llama a un fichero <span class="file" >~/.emacs</span>. En el pasado, fué prohibido escribir los atajos de teclado extra que el nombre <span class="file" >~/.emacs.el</span> requiere, pero ahora puedes. El nuevo formato es consistente con las conveniciones de nombre del fichero Emacs Lisp; el viejo formato guarda la escritura.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="15" >15</span></div>
<div class="about-dd" >
<p>Cuando se empiezan las instancias de Emacs que no cargan mi fichero <span class="file" >.emacs</span> o cualquier fichero, también se puede deshabilitar la ocultación:</p>
<div class="example-block" >
<pre class="example" >emacs -q --no-site-file -eval
&#39;(blink-cursor-mode nil)&#39; @exdent O ahora, usando un conjunto más
sofisticado de opciones, emacs -Q - D
</pre>
</div>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="16" >16</span></div>
<div class="about-dd" >
<p>también se ejecutan gestores de ventanas más modernos, tales como Enlightenment, Gnome, o KDE; en estos casos, con frecuencia se especifica una imagen en vez de un color plano.</p>
</div>
</div>
</div>
</body>
</html>
