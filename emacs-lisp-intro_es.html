<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" />
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es" >
<head>
  <title>Una introducción a la programación en Emacs Lisp</title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="subtitle" content="Revisada la tercera edición" />
  <meta name="author" content="Robert J. Chassell" />
  <meta name="translator" content="David Arroyo Menéndez" />
  <meta name="translator" content="nasciiboy" />
  <link rel="stylesheet" type="text/css" href="worg-data/worg.css" />
</head>

<body>
<div id="toc">
  <p>index</p>
  <div id="toc-contents">
  <ul>
  <li><a class="h2" href="#prefacio" >Prefacio</a></li>
    <ul>
    <li><a class="h3" href="#sobre-la-lectura-de-este-texto" >Sobre la lectura de este texto</a></li>
    <li><a class="h3" href="#para-quien-está-escrito-esto" >Para quien está escrito esto</a></li>
    <li><a class="h3" href="#historia-de-lisp" >Historia de Lisp</a></li>
    <li><a class="h3" href="#nota-para-principiantes" >Nota para principiantes</a></li>
    <li><a class="h3" href="#agradecimientos" >Agradecimientos</a></li>
    </ul>
  <li><a class="h2" href="#procesamiento-de-listas" >Procesamiento de listas</a></li>
    <ul>
    <li><a class="h3" href="#listas-lisp" >Listas Lisp</a></li>
      <ul>
      <li><a class="h4" href="#átomos-lisp" >Átomos Lisp</a></li>
      <li><a class="h4" href="#espacios-en-blanco-en-listas" >Espacios en blanco en listas</a></li>
      <li><a class="h4" href="#gnu-emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</a></li>
      </ul>
    <li><a class="h3" href="#ejecutar-un-programa" >Ejecutar un programa</a></li>
    <li><a class="h3" href="#generar-un-mensaje-de-error" >Generar un mensaje de error</a></li>
    <li><a class="h3" href="#nombres-de-símbolos-y-definiciones-de-funciones" >Nombres de símbolos y definiciones de funciones</a></li>
    <li><a class="h3" href="#el-intérprete-lisp" >El intérprete Lisp</a></li>
      <ul>
      <li><a class="h4" href="#codigo-compilado" >Codigo Compilado</a></li>
      </ul>
    <li><a class="h3" href="#evaluación" >Evaluación</a></li>
      <ul>
      <li><a class="h4" href="#evaluación-de-listas-internas" >Evaluación de listas internas</a></li>
      </ul>
    <li><a class="h3" href="#variables" >Variables</a></li>
      <ul>
      <li><a class="h4" href="#mensaje-de-error-de-un-símbolo-sin-una-función" >Mensaje de error de un símbolo sin una función</a></li>
      <li><a class="h4" href="#mensaje-de-error-de-un-símbolo-sin-un-valor" >Mensaje de error de un símbolo sin un valor</a></li>
      </ul>
    <li><a class="h3" href="#argumentos" >Argumentos</a></li>
      <ul>
      <li><a class="h4" href="#tipos-de-datos-de-los-argumentos" >Tipos de datos de los argumentos</a></li>
      <li><a class="h4" href="#un-argumento-como-el-valor-de-una-variable-o-lista" >Un argumento como el valor de una variable o lista</a></li>
      <li><a class="h4" href="#número-variable-de-argumentos" >Número variable de argumentos</a></li>
      <li><a class="h4" href="#usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a></li>
      <li><a class="h4" href="#la-función-message" >La función <code>message</code></a></li>
      </ul>
    <li><a class="h3" href="#configurando-el-valor-de-una-variable" >Configurando el valor de una variable</a></li>
      <ul>
      <li><a class="h4" href="#usando-set" >Usando <code>set</code></a></li>
      <li><a class="h4" href="#usando-setq" >Usando <code>setq</code></a></li>
      <li><a class="h4" href="#conteo" >Conteo</a></li>
      </ul>
    <li><a class="h3" href="#resumen" >Resumen</a></li>
    <li><a class="h3" href="#ejercicios" >Ejercicios</a></li>
    </ul>
  <li><a class="h2" href="#practicando-la-evaluación" >Practicando la Evaluación</a></li>
    <ul>
    <li><a class="h3" href="#nombres-de-búfer" >Nombres de búfer</a></li>
    <li><a class="h3" href="#obtención-de-búfers" >Obtención de Búfers</a></li>
    <li><a class="h3" href="#cambiando-búfers" >Cambiando búfers</a></li>
    <li><a class="h3" href="#tamaño-del-búfer-y-la-ubicación-del-punto" >Tamaño del búfer y la ubicación del punto</a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#cómo-escribir-definiciones-de-funciones" >Cómo escribir definiciones de funciones</a></li>
    <ul>
    <li><a class="h3" href="#la-forma-especial-defun" >La forma especial <code>defun</code></a></li>
    <li><a class="h3" href="#instalar-una-definición-de-función" >Instalar una definición de función</a></li>
      <ul>
      <li><a class="h4" href="#cambiar-una-definición-de-función" >Cambiar una definición de función</a></li>
      </ul>
    <li><a class="h3" href="#crear-una-función-interactiva" >Crear una función interactiva</a></li>
      <ul>
      <li><a class="h4" href="#multiplicar-por-siete-interactivo" ><code>multiplicar-por-siete</code> interactivo</a></li>
      </ul>
    <li><a class="h3" href="#diferentes-opciones-para-interactive" >Diferentes opciones para <code>interactive</code></a></li>
    <li><a class="h3" href="#instalar-código-permanentemente" >Instalar Código Permanentemente</a></li>
    <li><a class="h3" href="#let" ><code>let</code></a></li>
      <ul>
      <li><a class="h4" href="#partes-de-una-expresión-let" >Partes de una expresión <code>let</code></a></li>
      <li><a class="h4" href="#ejemplo-de-expresión-let" >Ejemplo de Expresión <code>let</code></a></li>
      <li><a class="h4" href="#variables-sin-inicializar-en-un-sentencia-let" >Variables sin inicializar en un sentencia <code>let</code></a></li>
      </ul>
    <li><a class="h3" href="#la-forma-especial-if" >La forma especial <code>if</code></a></li>
      <ul>
      <li><a class="h4" href="#la-función-tipo-de-animal-en-detalle" >La función <code>tipo-de-animal</code> en detalle</a></li>
      </ul>
    <li><a class="h3" href="#expresiones-if–then–else" >Expresiones if–then–else</a></li>
    <li><a class="h3" href="#verdad-y-falsedad-en-emacs-lisp" >Verdad y Falsedad en Emacs Lisp</a></li>
    <li><a class="h3" href="#save-excursion" ><code>save-excursion</code></a></li>
      <ul>
      <li><a class="h4" href="#plantilla-para-una-expresión-save-excursion" >Plantilla para una Expresión <code>save-excursion</code></a></li>
      </ul>
    <li><a class="h3" href="#repaso:-cómo-escribir-definiciones-de-funciones" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios" >Ejercicios</a></li>
    </ul>
  <li><a class="h2" href="#algunas-funciones-relacionadas-al-bufer" >Algunas funciones relacionadas al bufer</a></li>
    <ul>
    <li><a class="h3" href="#encontrar-más-información" >Encontrar Más información</a></li>
    <li><a class="h3" href="#una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></a></li>
    <li><a class="h3" href="#la-definición-de-mark-whole-buffer" >La definición de <code>mark-whole-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#cuerpo-de-mark-whole-buffer" >Cuerpo de <code>mark-whole-buffer</code></a></li>
      </ul>
    <li><a class="h3" href="#la-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-interactiva-append-to-buffer" >La expresión interactiva <code>append-to-buffer</code></a></li>
      <li><a class="h4" href="#el-cuerpo-de-append-to-buffer" >El cuerpo de <code>append-to-buffer</code></a></li>
      <li><a class="h4" href="#save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></a></li>
      </ul>
    <li><a class="h3" href="#repaso" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios" >Ejercicios</a></li>
    </ul>
  <li><a class="h2" href="#algunas-funciones-más-complejas" >Algunas Funciones Más Complejas</a></li>
    <ul>
    <li><a class="h3" href="#la-definición-de-copy-to-buffer" >La definición de <code>copy-to-buffer</code></a></li>
    <li><a class="h3" href="#la-definición-de-insert-buffer" >La definición de <code>insert-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-interactiva-en-insert-buffer" >La expresión interactiva en <code>insert-buffer</code></a></li>
        <ul>
        <li><a class="h5" href="#un-búfer-de-solo-lectura" >Un búfer de solo lectura</a></li>
        <li><a class="h5" href="#b-en-una-expresión-interactiva" ><samp>b</samp> en una expresión interactiva</a></li>
        </ul>
      <li><a class="h4" href="#el-cuerpo-de-la-función-insert-buffer" >El cuerpo de la función <code>insert-buffer</code></a></li>
      <li><a class="h4" href="#insert-buffer-con-un-if-en-lugar-de-un-or" ><code>insert-buffer</code> con un <code>if</code> en lugar de un <code>or</code></a></li>
      <li><a class="h4" href="#el-or-en-el-cuerpo" >El <code>or</code> en el cuerpo</a></li>
      <li><a class="h4" href="#la-expresión-let-en-insert-buffer" >La expresión <code>let</code> en <code>insert-buffer</code></a></li>
      <li><a class="h4" href="#nuevo-cuerpo-para-insert-buffer" >Nuevo cuerpo para <code>insert-buffer</code></a></li>
      </ul>
    <li><a class="h3" href="#definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></a></li>
      <ul>
      <li><a class="h4" href="#argumentos-opcionales" >Argumentos opcionales</a></li>
      <li><a class="h4" href="#beginning-of-buffer-con-un-argumento" ><code>beginning-of-buffer</code> con un argumento</a></li>
        <ul>
        <li><a class="h5" href="#qué-ocurre-en-un-búfer-de-gran-tamaño" >Qué ocurre en un búfer de gran tamaño</a></li>
        <li><a class="h5" href="#lo-que-sucede-en-un-búfer-pequeño" >Lo que sucede en un búfer pequeño</a></li>
        </ul>
      <li><a class="h4" href="#funcion-beginning-of-buffer-completa" >Funcion <code>beginning-of-buffer</code> Completa</a></li>
      </ul>
    <li><a class="h3" href="#repaso:-algunas-funciones-más-complejas" >Repaso</a></li>
    <li><a class="h3" href="#ejercicio-con-el-argumento-opcional" >Ejercicio con el argumento <code>opcional</code></a></li>
    </ul>
  <li><a class="h2" href="#reducir-y-extender" >Reducir y Extender</a></li>
    <ul>
    <li><a class="h3" href="#la-forma-especial-save-restriction" >La forma especial <code>save-restriction</code></a></li>
    <li><a class="h3" href="#what-line" ><code>what-line</code></a></li>
    <li><a class="h3" href="#ejercicio-con-reduccion" >Ejercicio con Reduccion</a></li>
    </ul>
  <li><a class="h2" href="#car,-cdr,-cons:-funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</a></li>
    <ul>
    <li><a class="h3" href="#car-y-cdr" ><code>car</code> y <code>cdr</code></a></li>
    <li><a class="h3" href="#cons" ><code>cons</code></a></li>
      <ul>
      <li><a class="h4" href="#descubrir-la-longitud-de-una-lista:-length" >Descubrir la longitud de una lista: <code>length</code></a></li>
      </ul>
    <li><a class="h3" href="#nthcdr" ><code>nthcdr</code></a></li>
    <li><a class="h3" href="#nth" ><code>nth</code></a></li>
    <li><a class="h3" href="#setcar" ><code>setcar</code></a></li>
    <li><a class="h3" href="#setcdr" ><code>setcdr</code></a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#corte-y-almacenamiento-de-texto" >Corte y Almacenamiento de Texto</a></li>
    <ul>
    <li><a class="h3" href="#zap-to-char" ><code>zap-to-char</code></a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-interactive" >La expresión <code>interactive</code></a></li>
      <li><a class="h4" href="#el-cuerpo-de-zap-to-char" >El cuerpo de <code>zap-to-char</code></a></li>
      <li><a class="h4" href="#la-función-search-forward" >La función <code>search-forward</code></a></li>
      <li><a class="h4" href="#la-forma-especial-progn" >La forma especial <code>progn</code></a></li>
      <li><a class="h4" href="#resumiendo-zap-to-char" >Resumiendo <code>zap-to-char</code></a></li>
      </ul>
    <li><a class="h3" href="#kill-region" ><code>kill-region</code></a></li>
      <ul>
      <li><a class="h4" href="#condition-case" ><code>condition-case</code></a></li>
      <li><a class="h4" href="#macro-lisp" >Macro Lisp</a></li>
      </ul>
    <li><a class="h3" href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a></li>
      <ul>
      <li><a class="h4" href="#el-cuerpo-de-copy-region-as-kill" >El cuerpo de <code>copy-region-as-kill</code></a></li>
        <ul>
        <li><a class="h5" href="#la-función-kill-append" >La función <code>kill-append</code></a></li>
        <li><a class="h5" href="#la-función-kill-new" >La función <code>kill-new</code></a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#disgresión-dentro-de-c" >Disgresión dentro de C</a></li>
    <li><a class="h3" href="#inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></a></li>
      <ul>
      <li><a class="h4" href="#defvar-y-un-asterisco" ><code>defvar</code> y un asterisco</a></li>
      </ul>
    <li><a class="h3" href="#repaso" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios-de-busqueda" >Ejercicios de Busqueda</a></li>
    </ul>
  <li><a class="h2" href="#cómo-se-implementan-las-listas" >Cómo se implementan las listas</a></li>
    <ul>
    <li><a class="h3" href="#símbolos-como-una-caja-con-cajones" >Símbolos como una caja con cajones</a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#pegando-texto" >Pegando texto</a></li>
    <ul>
    <li><a class="h3" href="#resumen-del-anillo-de-la-muerte" >Resumen del anillo de la muerte</a></li>
    <li><a class="h3" href="#la-variable-kill-ring-yank-pointer" >La variable <code>kill-ring-yank-pointer</code></a></li>
    <li><a class="h3" href="#ejercicios-con-yank-y-nthcdr" >Ejercicios con <code>yank</code> y <code>nthcdr</code></a></li>
    </ul>
  <li><a class="h2" href="#bucles-y-recursión" >Bucles y recursión</a></li>
    <ul>
    <li><a class="h3" href="#while" ><code>while</code></a></li>
      <ul>
      <li><a class="h4" href="#un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a></li>
      <li><a class="h4" href="#un-ejemplo:-imprimir-elementos-de-la-lista" >Un ejemplo: <code>imprimir-elementos-de-la-lista</code></a></li>
      <li><a class="h4" href="#un-bucle-con-un-contaje-incremental" >Un bucle con un contaje incremental</a></li>
        <ul>
        <li><a class="h5" href="#ejemplo-con-contador-incremental" >Ejemplo con contador incremental</a></li>
        <li><a class="h5" href="#las-partes-de-la-definición-de-función" >Las partes de la definición de función</a></li>
        <li><a class="h5" href="#poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</a></li>
        </ul>
      <li><a class="h4" href="#bucle-que-se-decrementa" >Bucle que se decrementa</a></li>
        <ul>
        <li><a class="h5" href="#ejemplo-con-el-contador-que-se-decrementa" >Ejemplo con el contador que se decrementa</a></li>
        <li><a class="h5" href="#las-partes-de-la-definición-de-función" >Las partes de la definición de función</a></li>
        <li><a class="h5" href="#poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#ahorra-tiempo:-dolist-y-dotimes" >Ahorra tiempo: <code>dolist</code> y <code>dotimes</code></a></li>
      <ul>
      <li><a class="h4" href="#la-macro-dolist" >La macro <code>dolist</code></a></li>
      <li><a class="h4" href="#la-macro-dotimes" >La macro <code>dotimes</code></a></li>
      </ul>
    <li><a class="h3" href="#recursión" >Recursión</a></li>
      <ul>
      <li><a class="h4" href="#construyendo-robots:-extendiendo-la-metáfora" >Construyendo robots: Extendiendo la metáfora</a></li>
      <li><a class="h4" href="#las-partes-de-una-definición-recursiva" >Las partes de una definición recursiva</a></li>
      <li><a class="h4" href="#recursión-con-una-lista" >Recursión con una lista</a></li>
      <li><a class="h4" href="#recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</a></li>
        <ul>
        <li><a class="h5" href="#un-argumento-de-3-o-4" >Un argumento de 3 o 4</a></li>
        </ul>
      <li><a class="h4" href="#ejemplo-de-recursión-usando-cond" >Ejemplo de recursión usando <code>cond</code></a></li>
      <li><a class="h4" href="#patrones-recursivos" >Patrones recursivos</a></li>
        <ul>
        <li><a class="h5" href="#patrón-recursivo:-every" >Patrón recursivo: <em>every</em></a></li>
        <li><a class="h5" href="#patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></a></li>
        <li><a class="h5" href="#patrón-recursivo:-keep" >Patrón recursivo: <em>keep</em></a></li>
        </ul>
      <li><a class="h4" href="#recursión-sin-diferir" >Recursión sin diferir</a></li>
      <li><a class="h4" href="#no-hay-solución-pospuesta" >No hay solución pospuesta</a></li>
      </ul>
    <li><a class="h3" href="#ejercicio-de-bucles" >Ejercicio de bucles</a></li>
    </ul>
  <li><a class="h2" href="#búsqueda-de-expresiones-regulares" >Búsqueda de expresiones regulares</a></li>
    <ul>
    <li><a class="h3" href="#la-expresión-regular-para-sentence-end" >La expresión regular para <code>sentence-end</code></a></li>
    <li><a class="h3" href="#la-función-re-search-forward" >La función <code>re-search-forward</code></a></li>
    <li><a class="h3" href="#la-función-forward-sentence" >La función <code>forward-sentence</code></a></li>
      <ul>
      <li><a class="h4" href="#los-bucles-while" >Los bucles <code>while</code></a></li>
      <li><a class="h4" href="#la-búsqueda-de-expresiones-regulares" >La búsqueda de expresiones regulares</a></li>
      </ul>
    <li><a class="h3" href="#forward-paragraph:-una-mina-de-oro-de-funciones" ><code>forward-paragraph</code>: una mina de oro de funciones</a></li>
      <ul>
      <li><a class="h4" href="#la-expresión-let*" >La expresión <code>let*</code></a></li>
      <li><a class="h4" href="#el-bucle-while-hacia-adelante" >El bucle <code>while</code> hacia adelante</a></li>
      </ul>
    <li><a class="h3" href="#crea-tu-propio-fichero-tags" >Crea tu propio fichero <span class="file" >TAGS</span></a></li>
      <ul>
      <li><a class="h4" href="#construyendo-etiquetas-en-las-fuentes-emacs" >Construyendo Etiquetas en las fuentes Emacs</a></li>
      </ul>
    <li><a class="h3" href="#repaso" >Repaso</a></li>
    <li><a class="h3" href="#ejercicios-con-re-search-forward" >Ejercicios con <code>re-search-forward</code></a></li>
    </ul>
  <li><a class="h2" href="#contando:-repetición-y-regexps" >Contando: repetición y regexps</a></li>
    <ul>
    <li><a class="h3" href="#la-función-count-words-example" >La función <code>count-words-example</code></a></li>
      <ul>
      <li><a class="h4" href="#el-error-de-espacio-en-blanco-en-count-words-example" >El error de espacio en blanco en <code>count-words-example</code></a></li>
      </ul>
    <li><a class="h3" href="#cuenta-palabras-recursivamente" >Cuenta palabras recursivamente</a></li>
    <li><a class="h3" href="#ejercicio:-contando-puntuación" >Ejercicio: contando puntuación</a></li>
    </ul>
  <li><a class="h2" href="#contando-palabras-en-una-defun" >Contando palabras en una <code>defun</code></a></li>
    <ul>
    <li><a class="h3" href="#¿qué-contar?" >¿Qué contar?</a></li>
    <li><a class="h3" href="#¿qué-constituye-una-palabra-o-símbolo?" >¿Qué constituye una palabra o símbolo?</a></li>
    <li><a class="h3" href="#la-función-count-words-in-defun" >La función <code>count-words-in-defun</code></a></li>
    <li><a class="h3" href="#contar-varias-defuns-en-un-fichero" >Contar varias <code>defuns</code> en un fichero</a></li>
    <li><a class="h3" href="#encontrar-un-fichero" >Encontrar un fichero</a></li>
    <li><a class="h3" href="#lengths-list-file-en-detalle" ><code>lengths-list-file</code> en detalle</a></li>
    <li><a class="h3" href="#contar-palabras-en-defuns-en-diferentes-ficheros" >Contar palabras en <code>defuns</code> en diferentes ficheros</a></li>
      <ul>
      <li><a class="h4" href="#la-función-append" >La función <code>append</code></a></li>
      </ul>
    <li><a class="h3" href="#recursivamente-cuenta-palabras-en-diferentes-ficheros" >Recursivamente cuenta palabras en diferentes ficheros</a></li>
    <li><a class="h3" href="#preparar-los-datos-para-mostrarlos-en-un-grafo" >Preparar los datos para mostrarlos en un grafo</a></li>
      <ul>
      <li><a class="h4" href="#ordenando-listas" >Ordenando listas</a></li>
      <li><a class="h4" href="#creando-una-lista-de-ficheros" >Creando una lista de ficheros</a></li>
      <li><a class="h4" href="#contando-definiciones-de-función" >Contando definiciones de función</a></li>
      </ul>
    </ul>
  <li><a class="h2" href="#leyendo-un-grafo" >Leyendo un grafo</a></li>
    <ul>
    <li><a class="h3" href="#la-función-graph-body-print" >La función <code>graph-body-print</code></a></li>
    <li><a class="h3" href="#la-función-recursive-graph-body-print" >La función <code>recursive-graph-body-print</code></a></li>
    <li><a class="h3" href="#necesidad-para-ejes-impresos" >Necesidad para ejes impresos</a></li>
    <li><a class="h3" href="#ejercicio" >Ejercicio</a></li>
    </ul>
  <li><a class="h2" href="#tu-fichero-.emacs" >Tu fichero <span class="file" >.emacs</span></a></li>
    <ul>
    <li><a class="h3" href="#fichero-de-inicialización-site-wide" >Fichero de inicialización site-wide</a></li>
    <li><a class="h3" href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a></li>
    <li><a class="h3" href="#empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></a></li>
    <li><a class="h3" href="#modo-texto-y-auto-relleno" >Modo texto y auto relleno</a></li>
    <li><a class="h3" href="#alias-de-correo" >Alias de correo</a></li>
    <li><a class="h3" href="#indentar-modo-de-tabulaciones" >Indentar modo de tabulaciones</a></li>
    <li><a class="h3" href="#atajos-de-teclado" >Atajos de teclado</a></li>
    <li><a class="h3" href="#mapas-de-teclado" >Mapas de teclado</a></li>
    <li><a class="h3" href="#cargando-ficheros" >Cargando ficheros</a></li>
    <li><a class="h3" href="#autoloading" >Autoloading</a></li>
    <li><a class="h3" href="#una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></a></li>
    <li><a class="h3" href="#colores-x11" >Colores X11</a></li>
    <li><a class="h3" href="#configuraciones-misceláneas-para-un-fichero-.emacs" >Configuraciones misceláneas para un fichero <span class="file" >.emacs</span></a></li>
      <ul>
      <li><a class="h4" href="#arreglando-atajos-de-teclados" >Arreglando Atajos de Teclados</a></li>
      </ul>
    <li><a class="h3" href="#una-línea-modificada" >Una línea modificada</a></li>
    </ul>
  <li><a class="h2" href="#depurando" >Depurando</a></li>
    <ul>
    <li><a class="h3" href="#depurar" ><code>depurar</code></a></li>
    <li><a class="h3" href="#debug-on-entry" ><code>debug-on-entry</code></a></li>
    <li><a class="h3" href="#debug-on-quit-y-(debug)" ><code>debug-on-quit</code> y <code>(debug)</code></a></li>
    <li><a class="h3" href="#el-depurador-de-nivel-de-fuentes-edebug" >El depurador de nivel de fuentes <code>edebug</code></a></li>
    <li><a class="h3" href="#ejercicios-de-depuración" >Ejercicios de depuración</a></li>
    </ul>
  <li><a class="h2" href="#conclusión" >Conclusión</a></li>
    <ul>
    <li><a class="h3" href="#apéndice-a-la-función-the-the" >Apéndice A La función <code>the-the</code></a></li>
    <li><a class="h3" href="#apéndice-b-manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</a></li>
      <ul>
      <li><a class="h4" href="#la-función-current-kill" >La función <code>current-kill</code></a></li>
      <li><a class="h4" href="#pegar" ><code>pegar</code></a></li>
      <li><a class="h4" href="#yank-pop" ><code>yank-pop</code></a></li>
      <li><a class="h4" href="#el-fichero-ring.el" >El fichero <span class="file" >ring.el</span></a></li>
      </ul>
    <li><a class="h3" href="#apéndice-c-un-grafo-con-ejes-etiquetados" >Apéndice C <span id="Un-grafo-con-ejes-etiquetados" >Un grafo con ejes etiquetados</span></a></li>
      <ul>
      <li><a class="h4" href="#la-varlist-print-graph" >La varlist <code>print-graph</code></a></li>
      <li><a class="h4" href="#la-función-print-y-axis" >La función <code>print-Y-axis</code></a></li>
        <ul>
        <li><a class="h5" href="#viaje-lateral:-calcula-un-resto" >Viaje lateral: Calcula un resto</a></li>
        <li><a class="h5" href="#construye-un-elemento-del-eje-y" >Construye un elemento del eje Y</a></li>
        <li><a class="h5" href="#crea-un-eje-de-la-columna-y" >Crea un eje de la columna Y</a></li>
        <li><a class="h5" href="#la-versión-no-demasiado-final-de-print-y-axis" >La versión no demasiado final de <code>print-Y-axis</code></a></li>
        </ul>
      <li><a class="h4" href="#la-función-print-x-axis" >La función <code>print-X-axis</code></a></li>
        <ul>
        <li><a class="h5" href="#eje-x-marca-tic" >Eje X marca tic</a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#imprimiendo-el-grafo-completo" >Imprimiendo el grafo completo</a></li>
      <ul>
        <ul>
        <li><a class="h5" href="#testeando-print-graph" >Testeando <code>print-graph</code></a></li>
        <li><a class="h5" href="#creando-gráficas-de-números-de-palabras-y-símbolos" >Creando gráficas de números de palabras y símbolos</a></li>
        <li><a class="h5" href="#una-expresión-lambda:-anonimicidad-útil" >Una expresión <code>lambda</code>: Anonimicidad útil</a></li>
        </ul>
      <li><a class="h4" href="#la-función-mapcar" >La función <code>mapcar</code></a></li>
        <ul>
        <li><a class="h5" href="#otro-error-…-más-insidioso" >Otro error … más insidioso</a></li>
        <li><a class="h5" href="#el-gráfico-impreso" >El gráfico impreso</a></li>
        </ul>
      </ul>
    <li><a class="h3" href="#apéndice-d-software-libre-y-manuales-libres-por-richard-m.-stallman" >Apéndice D Software Libre y Manuales Libres (<b>por Richard M. Stallman</b>)</a></li>
    </ul>
  <li><a class="h2" href="#appendix-e-gnu-free-documentation-license" >Appendix E GNU Free Documentation License</a></li>
    <ul>
    <li><a class="h3" href="#0.-preamble" >0. PREAMBLE</a></li>
    <li><a class="h3" href="#1.-applicability-and-definitions" >1. APPLICABILITY AND DEFINITIONS</a></li>
    <li><a class="h3" href="#2.-verbatim-copying" >2. VERBATIM COPYING</a></li>
    <li><a class="h3" href="#3.-copying-in-quantity" >3. COPYING IN QUANTITY</a></li>
    <li><a class="h3" href="#4.-modifications" >4. MODIFICATIONS</a></li>
    <li><a class="h3" href="#5.-combining-documents" >5. COMBINING DOCUMENTS</a></li>
    <li><a class="h3" href="#6.-collections-of-documents" >6. COLLECTIONS OF DOCUMENTS</a></li>
    <li><a class="h3" href="#7.-aggregation-with-independent-works" >7. AGGREGATION WITH INDEPENDENT WORKS</a></li>
    <li><a class="h3" href="#8.-translation" >8. TRANSLATION</a></li>
    <li><a class="h3" href="#9.-termination" >9. TERMINATION</a></li>
    <li><a class="h3" href="#10.-future-revisions-of-this-license" >10. FUTURE REVISIONS OF THIS LICENSE</a></li>
    <li><a class="h3" href="#11.-relicensing" >11. RELICENSING</a></li>
    </ul>
  <li><a class="h2" href="#addendum:-how-to-use-this-license-for-your-documents" >ADDENDUM: How to use this License for your documents</a></li>
    <ul>
    <li><a class="h3" href="#acerca-del-autor" >Acerca del Autor</a></li>
    </ul>
  <li><a class="h2" href="#footnotes" >footnotes</a></li>
  </ul>
  </div>
</div>

<h1>Una introducción a la programación en Emacs Lisp</h1>
<div class="hBody-1" >
<p>Esto es una <em>Introducción a la Programación en Emacs Lisp</em>, para personas que no son programadoras.</p>
<p>Traducido desde la edición 3.10</p>
<p>Copyright ® 1990–1995, 1997, 2001–2013 Free Software Foundation, Inc.</p>
<p>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; there being no Invariant Section, with the Front-Cover Texts being “A GNU Manual”, and with the Back-Cover Texts as in (a) below. A copy of the license is included in the section entitled “GNU Free Documentation License”.</p>
<p>(a) The FSF&#39;s Back-Cover Text is: “You have the freedom to copy and modify this GNU manual. Buying copies from the FSF supports it in developing GNU and promoting software freedom.”</p>
</div>
<h2 id="prefacio" >Prefacio</h2>
<div class="hBody-2" >
<p>La mayoría del entorno integrado GNU Emacs está escrito en el lenguaje de programación llamado Emacs Lisp. El código escrito en este lenguaje de programación es el software––el conjunto de instrucciones––que le indican al ordenador qué hacer cuando se le dan comandos. Emacs está diseñado de forma que se puede escribir nuevo código en Emacs Lisp e instalarlo fácilmente como una extensión al editor.</p>
<p>(GNU Emacs se define muchas veces como un “editor extensible”, pero hace mucho más que proporcionar capacidad de edición. Es mejor referirse a Emacs como un “entorno de computación extensible”. Sin embargo, esta frase es un poco pretenciosa. Es más fácil referirse a Emacs simplemente como un editor. De hecho, cada cosa que se hace en Emacs––encontrar la fecha Maya y fases de la luna, simplificar polinomios, depurar código, administrar ficheros, leer cartas, escribir libros––todas estas actividades son maneras de editar en un sentido amplio de la palabra.)</p>
<p>Aunque Emacs Lisp normalmente se asocia solo con Emacs, es un lenguaje de programación completo. Se puede usar Emacs Lisp del mismo modo que con cualquier otro lenguaje de programación.</p>
<p>Quizás quiera comprender la programación; quizás quiera extender Emacs; o quizás quiera llegar a ser un programador. Esta introducción a Emacs Lisp está diseñada para que empieces: para guiarte en el aprendizaje de los fundamentos de la programación y, lo que es más importante, para mostrarte como puedes aprender a ir mas más allá.</p>
</div>
<h3 id="sobre-la-lectura-de-este-texto" >Sobre la lectura de este texto</h3>
<div class="hBody-3" >
<p>A lo largo de este documento, verá pequeños programas de ejemplo que se pueden ejecutar dentro de Emacs. Si se lee este documento dentro de GNU Emacs, puede ejecutar los programas tal y como aparecen. (Esto es fácil de hacer y se explica cuando se presentan los ejemplos). Alternativamente, puede leer esta introducción como un libro impreso mientras se está sentando con un ordenador ejecutando Emacs. (Esto es lo que me gusta hacer; me gustan los libros impresos.) Si usted no se está ejecutando Emacs, todavía se puede leer este libro, pero en este caso, lo mejor es tratarlo como una novela, o como una guía de viaje a un país que aún no visitado: interesante, pero no es lo mismo que estar allí.</p>
<p>Gran parte de esta introducción se dedica a paseos guiados de código usado en GNU Emacs. Estos paseos están diseñados para dos propósitos: primero, familiarizarse con código real que funciona (código que se usa cada día); y, segundo, familiarizarse con cómo funciona Emacs. Es interesante ver cómo se implementa un entorno completamente operativo. También, espero que aprenda el hábito de navegar a través del código fuente. Puedes aprender mucho comparando código de otros con el propio y extraer nuevas ideas. Tener GNU Emacs es como tener la cueva del dragón de los tesoros.</p>
<p>Además de aprender sobre Emacs como editor y Emacs Lisp como lenguaje de programación, los ejemplos y visitas guiadas le darán una oportunidad para familiarizarse con Emacs como un entorno de programación Lisp. GNU Emacs soporta programación y provee herramientas que llegara a sentirse comodo usando, como <kbd>M-.</kbd> (el atajo que invoca el comando <code>find-tag</code>). También aprendera sobre búfers y otros objetos que forman parte del entorno. Aprender estas funcionalidades de Emacs es como aprender nuevas rutas alrededor de tu ciudad natal.</p>
<p>Finalmente, espero poder transmitir algunas habilidades para utilizar Emacs para aprender aspectos de programación que no conoces. Con frecuencia se puede usar Emacs para ayudarte a entender un rompecabezas o para encontrar la manera de hacer algo nuevo. Este auto-descubrimiento no es solo un placer, también es una ventaja.</p>
</div>
<h3 id="para-quien-está-escrito-esto" >Para quien está escrito esto</h3>
<div class="hBody-3" >
<p>Este texto está escrito como una introducción elemental para personas que no son programadoras. Si usted es un programador, es posible que no este satisfecho con este manual. La razón es que un programador puede tener que convertirse en experto leyendo manuales de referencia y este texto no está organizado como un manual de referencia.</p>
<p>Un programador experto que revisó este texto me dijo:</p>
<blockquote>
<p>Prefiero aprender desde manuales de referencia. Me “zambullo” en cada párrafo y “subo a tomar aire” entre párrafos.</p>
<p>Cuando llego al fin de un párrafo, asumo que este asunto está hecho, terminado, que sé todo lo que necesito (con la posible excepción del caso cuando el siguiente párrafo empiece a hablar de el con más detalle). Espero que un manual de referencia bien escrito no tenga mucha redundancia, y que tenga excelentes indicadores del (unico) lugar donde está la información que quiero.</p>
</blockquote>
<p>¡Esta introducción no está escrita para esta persona!</p>
<p>En primer lugar, intento decir cada cosa al menos tres veces: primero, para introducirlo; segundo, para mostrarlo en contexto; y tercero, para mostrarlo en un contexto diferente, o para revisarlo.</p>
<p>En segundo lugar, casi nunca pongo toda la información sobre un tema en un solo lugar, y mucho menos en un párrafo. A mi manera de pensar, eso impone una carga bastante pesada al lector. En vez de eso intento explicarte solo lo que se necesitas saber en ese momento. (Algunas veces incluyo una pequeña información extra, para que no haya sorpresas más tarde cuando la información adicional sea introducida formalmente.)</p>
<p>Cuando usted lee este texto, no espera aprender todo la primera vez. Frecuentemente, solo necesita hacer, por asi decirlo, un ‘reconocimiento’ con alguno de los articulos mencionados. Mi esperanza es haber estructurado el texto y dar suficientes pistas para indicar lo que es importante y concentrarse en ello.</p>
<p>Necesitaras “sumergirte” en algunos párrafos; no hay otro modo de leerlos. Pero he intentado reducir el número de esos párrafos. Este libro pretende ser como una colina accesible, mas que una montaña abrumadora.</p>
<p>Esta introducción a <em>Programación en Emacs Lisp</em> viene acompañada de un documento complementario. <em>El Manual de Referencia de GNU Emacs Lisp</em>. El manual de referencia tiene más detalles que esta introducción. En el manual de referencia, toda la información sobre un asunto está concentrada en un solo lugar. Usted debe recurrir a ella si es como el programador citado anteriormente. Y, por supuesto, después de haber leido esta <em>Introducción</em>, encontrara el <em>Manual de Referencia</em> util cuando este escribiendo sus propios programas.</p>
</div>
<h3 id="historia-de-lisp" >Historia de Lisp</h3>
<div class="hBody-3" >
<p>Lisp fué originariamente desarrollado a finales de los años 50 en el Instituto Tecnológico de Massachusetts para la investigacion en inteligencia artificial. El gran poder del lenguaje Lisp lo hace superior para otros propósitos también, como la escritura de comandos de edición y entornos integrados.</p>
<p>GNU Emacs Lisp está fuertemente inspirado en Maclisp, que fue escrito en el MIT en la decada de 1960. Está en cierto modo inspirado en Common Lisp, que se convirtio en un estándar en los 80. Sin embargo, Emacs Lisp es mucho más simple que Common Lisp. (La distribución estándar de Emacs contiene un fichero de extensiones opcional, <span class="file" >cl.el</span>, que añade muchas caracteristicas de Common Lisp a Emacs Lisp.)</p>
</div>
<h3 id="nota-para-principiantes" >Nota para principiantes</h3>
<div class="hBody-3" >
<p>Si usted no conoce GNU Emacs, todavia puede leer este documento provechosamente. Sin embargo, te recomiendo que aprendas Emacs, al menos aprender a moverse alrededor de la pantalla del ordenador. Uno puede aprender de manera autodidacta cómo usar Emacs con el tutorial incluido. Para usarlo, escriba <kbd>C-h t</kbd>. (Esto significa que debe presionar la tecla <kbd>CTRL</kbd> y la <kbd>h</kbd> al mismo tiempo, y luego presionar y soltar <kbd>t</kbd>).</p>
<p>Con frecuencia, también me refiero a uno de los comandos estándar de Emacs listando las teclas que se presionan para invocar el comando y, luego doi el nombre del comando entre paréntesis, de la siguiente manera: <kbd>M-C-\</kbd> (<code>indent-region</code>). Esto significa invocar el comando <code>indent-region</code> presionando <kbd>M-C-\</kbd>. (Puede, Si lo desea, cambiar las teclas que se presionan para invocar el comando; esto se denomina <dfn>rebinding</dfn>. Véa la Sección <a href="#mapas-de-teclado" >Mapas de teclado</a>.)  La abreviatura <kbd>M-C-\</kbd> significa que usted presiona la tecla <kbd>META</kbd>, <kbd>CTRL</kbd>, y <kbd>\</kbd> todo al mismo tiempo. (En muchos teclados modernos la tecla <kbd>META</kbd> es etiquetada con <kbd>ALT</kbd>.) Algunas veces una combinación como esta se llama <em>keychord</em>, puesto que es similar a tocar un acorde en un piano. Si el teclado no tiene una tecla <kbd>META</kbd>, en su lugar se usa la tecla <kbd>ESC</kbd> como prefijo. En este caso <kbd>M-C-\</kbd> significa que se presiona y libera <kbd>ESC</kbd> y luego presiona la tecla <kbd>CTRL</kbd> y la tecla <kbd>\</kbd> al mismo tiempo. Pero normalmente <kbd>M-C-\</kbd> significa presionar la tecla <kbd>CTRL</kbd> junto a la tecla que está marcada como <kbd>ALT</kbd> y, al mismo tiempo, presionar la tecla <kbd>\</kbd>.</p>
<p>Además de pulsar una sola combinación de teclas, se puede prefijar lo que se escribe con <kbd>C-u</kbd>, que es llamado el ‘argumento universal’. El atajo <kbd>C-u</kbd> pasa a ser un argumento para el comando subsiguiente. Asi, para indentar una región de texto plano a 6 espacios, se marca la región, y entonces presione <kbd>C-u 6 M-C-\</kbd>. (Si no se especifica un número, Emacs pasa el número 4 al comando o ejecuta el comando de forma diferente). Véa la Sección <a href="info:emacs#Arguments" >Argumentos Numéricos</a> en <em>El Manual de GNU Emacs</em>.</p>
<p>Si se está leyendo esto en Info usando GNU Emacs, puedes avanzar a través de todo este documento presionando la barra de espacio, <kbd>SPC</kbd>. (Para aprender acerca de Info, presiona <kbd>C-h i</kbd> y luego selecciona Info.)</p>
<p>Una nota sobre terminología: cuando uso la palabra Lisp sola, con frecuencia me estoy refiriendo a los diversos dialectos de Lisp en general, pero cuando hablo de Emacs Lisp, me estoy refiriendo a GNU Emacs Lisp en particular.</p>
</div>
<h3 id="agradecimientos" >Agradecimientos</h3>
<div class="hBody-3" >
<p>Estoy agradecido a todos los que me ayudaron con este libro. Mi agradecimiento especial a Jim Blandy, Noah Friedman, Jim Kingdon, Roland McGrath, Frank Ritter, Randy Smith, Richard M. Stallman, y Melissa Weisshaus. Gracias también a Philip Johnson y David Stampe por su ánimo paciente. Mis errores son míos.</p>
<div class="right" >
<p>Robert J. Chassell <a href="mailto:bob@gnu.org" >mailto:bob@gnu.org</a></p>
</div>
</div>
<h2 id="procesamiento-de-listas" >Procesamiento de listas</h2>
<div class="hBody-2" >
<p>Para el ojo inexperto, Lisp es un lenguaje de programación extraño. En código Lisp hay paréntesis por todas partes. Algunas personas incluso afirman que el nombre signfica ‘Lots of Isolated Silly Parentheses’ (‘Montones de Paréntesis Aislados Estúpidos’). Pero la protesta no tiene fundamento. Lisp significa LISt Processing, y el lenguaje de programación maneja <em>listas</em> (y listas de listas) poniéndolas entre paréntesis. Los paréntesis marcan los límites de la lista. Algunas veces una lista va precedida por un apóstrofe simple o una marca de cita, <samp>&#39;</samp><span class="note" ><sup><a href="#1" >1</a></sup></span> Las listas son el fundamento de Lisp.</p>
</div>
<h3 id="listas-lisp" >Listas Lisp</h3>
<div class="hBody-3" >
<p>En Lisp, una lista tiene el siguiente aspecto: <code>&#39;(rosa violeta margarita tulipan)</code>. Esta lista es precedida por una comilla. Bien, podría estar escrita de la siguiende manera, que se parece mas al tipo de lista con la que se está familiarizado:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span>
  <span class="nv">violeta</span>
  <span class="nv">margarita</span>
  <span class="nv">tulipan</span><span class="p">)</span>
</code></pre>
<p>Los elementos de esta lista son los nombres de 4 flores diferentes, separados por espacios en blanco y rodeados de paréntesis, como flores en un campo con un muro de piedras alrededor de ellas.</p>
<p>Las listas pueden también tener números dentro, como en esta lista: <code>(+ 2 2)</code>. Esta lista tiene un signo más, <samp>+</samp>, seguido por dos <samp>2</samp>, cada uno separado por espacios en blanco.</p>
<p>En Lisp, tanto datos como programas se representan de la misma manera; es decir, son a la vez listas de palabras, números, u otras listas, separadas por espacios en blanco y rodeadas de paréntesis. (Puesto que un programa son datos, un programa puede servir fácilmente como datos para otros; esta es un caracteristica muy poderosa de Lisp.)  (A proposito, estas dos marcas de paréntesis <em>no</em> son listas Lisp, porque contienen <samp>;</samp> y <samp>.</samp> como marcas de puntuación.)</p>
<p>Aquí hay otra lista, esta vez con una lista dentro:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">tiene</span> <span class="p">(</span><span class="nv">una</span> <span class="nv">lista</span> <span class="nv">dentro</span> <span class="nv">de</span> <span class="nv">ella</span><span class="p">))</span>
</code></pre>
<p>Los componentes de esta lista son las palabras <samp>esta</samp>, <samp>lista</samp>, <samp>tiene</samp>, y la lista <samp>(una lista dentro de ella)</samp>. La lista interior se construye con las palabras <samp>una</samp>, <samp>lista</samp>, <samp>dentro</samp>, <samp>de</samp>, <samp>ella</samp>.</p>
</div>
<h4 id="átomos-lisp" >Átomos Lisp</h4>
<div class="hBody-4" >
<p>En Lisp, lo que hemos estado llamando palabras son en realidad <dfn>átomos</dfn>. Este término proviene del significado historico de la palabra átomo, que significa ‘indivisible’. En lo que a Lisp concierne, las palabras que hemos estado usando en las listas no se pueden dividir en partes mas pequeñas, sin perder su significado dentro del programa; lo mismo ocurre con números y símbolos de un caracterer como <samp>+</samp>. Por otro lado, a diferencia de un átomo antiguo, una lista puede dividirse en partes. Vea la seccion <a href="#car,-cdr,-cons:-funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</a>.</p>
<p>En una lista, los átomos se separan unos de otros por espacios en blanco. Pueden ir pegados a un paréntesis.</p>
<p>Técnicamente hablando, una lista en Lisp consiste en paréntesis que rodean átomos separados por espacios en blanco o alrededor de otras lista o alrededor de ambos átomos y otras listas. Una lista puede tener solo un átomo o no tener absolutamente nada en ella. Una lista con nada dentro se ve así: <code>()</code>, y se llama <dfn>lista vacía</dfn>. A diferencia de cualquier otra cosa, una lista vacía es tanto un átomo, como una lista al mismo tiempo.</p>
<p>La representación impresa de átomos y listas se llaman <dfn>expresiones simbólicas</dfn> o, más concisamente, <dfn>expresiones-s</dfn>. La palabra <dfn>expresión</dfn> por sí misma puede referir o bien a la representación impresa, o al átomo o a la lista tal como se encuentra internamente en el ordenador. Con frecuencia, las personas usan el término <dfn>expresión</dfn> indiscriminadamente. (También, en muchos textos, la palabra <dfn>forma</dfn> se usa como un sinónimo de expresión.)</p>
<p>Por cierto, los átomos que componen nuestro universo fueron nombrados asi cuando se pensaba que eran indivisibles; pero se ha encontrado que los átomos fisicos no son indivisibles. Las partes pueden dividir un átomo o puede fisionarse en 2 partes de igual tamaño. Los átomos físicos se nombraron prematuramente, antes de que su verdadera naturaleza fuese encontrada. En Lisp, ciertos tipos de átomos, como un array, pueden ser separados en partes; pero el mecanismo de hacer esto es diferente del mecanismo para dividir una lista. En lo que se refiere a las operaciones de lista, los átomos de una lista son indivisibles.</p>
<p>Al igual que en el español, el significado de las letras que componen un átomo Lisp difieren del significado de las letras compuestas como una palabra. Por ejemplo, la expresión <samp>ay</samp>, es completamente diferente de las dos palabras <samp>a</samp>, e <samp>y</samp>.</p>
<p>Hay muchos tipos de átomos en la naturaleza, pero solo unos pocos en Lisp: por ejemplo, los <dfn>números</dfn>, como 37, 511, o 1729, y los <dfn>símbolos</dfn>, como <samp>+</samp>, <samp>foo</samp>, o <samp>forward-line</samp>. Las palabras que hemos listado en los ejemplos anteriores son todos símbolos. En una conversacion cotidiana de Lisp, la palabra “átomo” no se usa con frecuencia, porque los programadores normalmente intentan ser más específicos acerca del tipo de átomo que están tratando. La programación Lisp es mayormente sobre símbolos (y algunas veces números) dentro de listas. (De ese modo, tres palabras rodeadas de paréntesis son una lista apropiada en Lisp, ya que consiste de átomos, que en este caso son símbolos, separados por espacios en blanco y encerrados entre paréntesis, sin ninguna puntuacion ajena a Lisp.)</p>
<p>El texto entre comillas––incluso oraciones o párrafos––son también un átomo. Aquí hay un ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">incluye</span> <span class="s">&#34;texto entre comillas.&#34;</span><span class="p">)</span>
</code></pre>
<p>En Lisp, todo el texto citado incluyendo la marca de puntuación y los espacios en blanco son un solo átomo. Este tipo de átomo es llamado <dfn>string</dfn> (<em>cadena</em>, por ‘cadena de caracteres’) y es el tipo de cosa que se utiliza para los mensajes que un ordenador puede imprimir para que un humano lea. Las cadenas son un tipo de átomo diferente a los números, o símbolos y se utilizan de manera diferente.</p>
</div>
<h4 id="espacios-en-blanco-en-listas" >Espacios en blanco en listas</h4>
<div class="hBody-4" >
<p>La cantidad de espacios en blanco en una lista no importa. Desde el punto de vista del lenguaje Lisp,</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span>
   <span class="nv">se</span> <span class="nv">ve</span> <span class="nv">asi</span><span class="p">)</span>
</code></pre>
<p>es exactamente lo mismo que esto:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esta</span> <span class="nv">lista</span> <span class="nv">se</span> <span class="nv">ve</span> <span class="nv">asi</span><span class="p">)</span>
</code></pre>
<p>Ambos ejemplos muestran que en Lisp es la misma lista, la lista hecha de los símbolos <samp>esta</samp>, <samp>lista</samp>, <samp>se</samp>, <samp>ve</samp>, y <samp>asi</samp> en ese orden.</p>
<p>Los espacios en blanco adicionales y los saltos de línea están diseñados para crear una lista más legible para los humanos. Cuando Lisp lee la expresión, se deshace de los espacios en blanco extra (pero necesita tener al menos un espacio entre los átomos para distinguirlos.)</p>
<p>Aunque parezca raro, los ejemplos que hemos visto cubren casi todas las listas en Lisp. Cualquier otra lista en Lisp se ve más o menos igual a uno de estos ejemplos, excepto que la lista puede ser más larga y compleja. En resumen, una lista está entre paréntesis, una cadena está entre comillas, un símbolo se parece a una palabra, y un número a un número. (Para ciertas situaciones, es pueden utilizar corchetes, puntos y otros caracteres especiales; sin embargo; iremos bastante lejos sin ellos.)</p>
</div>
<h4 id="gnu-emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</h4>
<div class="hBody-4" >
<p>Cuando se escribe una expresión Lisp en GNU Emacs usando el modo de Interacción Lisp o el modo Emacs Lisp, están disponibles varios comandos para formatear la expresión Lisp, de modo que sea fácil de leer. Por ejemplo, presionando la tecla <kbd>TAB</kbd> automáticamente se indenta la línea donde se encuetra el cursor a la cantidad correcta. Un comando para indentar apropiadamente el código en una región está asociado a <kbd>M-C-\</kbd>. La indentación está diseñada de modo que se pueda ver qué elementos percecen a cada lista––los elementos de una sublista están más indentados que los elementos de la lista adjunta.</p>
<p>Además, cuando escribes un paréntesis de cierre, Emacs mueve momentáneamente el cursor hacia el parentesis de apertura correspondiente, para que puedas ver cual es. Esto es muy útil, ya que cada lista que se escribe en Lisp debe tener sus paréntesis emparejados con sus paréntesis de apertura. (Vea la Seccion <a href="info:emacs#Major-Modes" >Modos Mayores</a> en <em>El Manual de GNU Emacs</em>, para más información sobre los modos de Emacs.)</p>
</div>
<h3 id="ejecutar-un-programa" >Ejecutar un programa</h3>
<div class="hBody-3" >
<p>Una lista en Lisp––cualquier lista––es un programa listo para ejecutarse. Si lo ejecutas (lo que la jerga Lisp llama <dfn>evaluar</dfn>), el ordenador hará una de tres cosas: nada excepto devolverte la lista misma; enviar un mensaje de error; o, tomar el primer símbolo en la lista como un comando para hacer alguna cosa. (¡Normalmente, por supuesto, es la última de estas tres cosas lo que realmente quieres!).</p>
<p>El apóstrofe, <code>&#39;</code>, que pongo delante de algunas de las listas de ejemplo en las secciones anteriores se llama <dfn>quote</dfn> (citar); cuando precede a una lista, le dice a Lisp que no haga nada con la lista, ademas de tomarla tal como está escrita. Pero si no hay una cita precediendo la lista, el primer elemento de la lista es especial: es un comando que el ordenador debe obedecer. (En Lisp, estos comandos se llaman <em>funciones</em>.) La lista <code>(+ 2 2)</code> montrada a continuación no tiene una cita delante de ella, por lo que Lisp comprende que <code>+</code> es una instrucción para hacer alguna cosa con el resto de la lista: sumar los números que siguen.</p>
<p>Si estás leyendo esto dentro de GNU Emacs, aquí está como puedes evaluar tal lista: coloca tu cursor justo después del paréntesis derecho de la siguiente lista y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>Verás que el número <code>4</code> aparece en el área eco. (En la jerga, lo que acabas de hacer es “evaluar la lista.” El área de eco es la línea en la parte inferior de la pantalla que muestra o hace “eco” del texto.) Ahora intenta lo mismo con una lista citada: posiciona el cursor justo después de la siguiente lista y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="o">&#39;</span><span class="p">(</span><span class="nv">esto</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nv">citada</span><span class="p">)</span>
</code></pre>
<p>Verás aparecer <code>(esto es una lista citada)</code> en el área eco.</p>
<p>En ambos casos, lo que estás haciendo es dar un comando al programa dentro de GNU Emacs llamado <dfn>intérprete Lisp</dfn>––dando al intérprete un comando para evaluar la expresión. El nombre del intérprete Lisp viene de la palabra para la tarea hecha por un humano que viene con el significado de una expresión––quien lo “interpreta”.</p>
<p>También se puede evaluar un átomo que no es parte de una lista––uno que no está rodeado por paréntesis; de nuevo, el intérprete Lisp traduce desde la expresión legible humanamente al lenguaje del ordenador. Pero antes de discutir esto (vea la Seccion <a href="#variables" >Variables</a>), vamos a discutir lo que el intérprete de Lisp hace cuando cometes un el error.</p>
</div>
<h3 id="generar-un-mensaje-de-error" >Generar un mensaje de error</h3>
<div class="hBody-3" >
<p>No te preocupes si generas un mensaje de error de manera accidental, ahora daremos un comando al intérprete de Lisp que genara un mensaje de error. Esta es una accion inofensiva; y de hecho, a menudo se intenta generar mensajes de error de manera intencional. Una vez se comprende la jerga, los mensajes de error pueden ser informativos. En vez de ser llamados mensajes de “error”, deberían ser llamados mensajes de “ayuda”. Son como letreros para un viajero en un país extraño; descifrarlos puede ser duro, pero una vez comprendidos, pueden señalar el camino.</p>
<p>El mensaje de error es generado por un depurador de codigo incorporado dentro de GNU Emacs. Vamos a ‘entrar al depurador’. Se sale del depurador pulsando <code>q</code>.</p>
<p>Lo que vamos a hacer es evaluar una lista que no tiene cita y ni un comando con significado como su primer elemento. Aquí hay una lista casi exactamente igual a la que acabamos de usar, pero sin la cita al inicio. Coloque el cursor a la derecha donde esta finaliza y presione <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">esto</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nf">sin</span> <span class="nv">cita</span><span class="p">)</span>
</code></pre>
<p>Se abrirá una ventana <span class="file" >*Backtrace*</span> y se verá lo siguiente:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function esto)
  (esto es una lista sin cita)
  eval((esto es una lista sin cita) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Tu cursor estará en esta ventana (es posible que tenga que esperar unos pocos segundos antes de que sea visible). Para salir del depurador y de su ventana, presione:</p>
<div class="example-block" >
<pre class="example" >q
</pre>
</div>
<p>Por favor, ahora presiona <kbd><b>q</b></kbd>, para que puedas comprobar que se puede salir del depurador. A continuacion, presiona {C-x C-e} una vez mas para re-entrar.</p>
<p>Basandones en lo que ya sabemos, casi podemos leer este mensaje de error.</p>
<p>Lees el búfer <span class="file" >*Backtrace*</span> desde abajo hacia arriba; te dice lo que hizo Emacs. Cuando se presionaste <kbd>C-x C-e</kbd>, se hace una llamada interactiva al comando <code>eval-last-sexp</code>. <code>eval</code> es una abreviatura para ‘evaluar’ y <code>sexp</code> es una abreviatura para ‘expresión simbólica’. El comando significa ‘evalúa la última expresión simbólica’, que es la expresión inmediatamente anterior al cursor.</p>
<p>Cada linea sober esta cuenta lo que el intérprete Lisp evaluo después. La acción más reciente está en la parte superior. El búfer se llama <span class="file" >*Backtrace*</span> ya que permite realizar un seguimiento de Emacs hacia atrás.</p>
<p>En la parte superior del búfer <span class="file" >*Backtrace*</span>, verá la línea:</p>
<div class="example-block" >
<pre class="example" >Debugger entered--Lisp error: (void-function esto)
</pre>
</div>
<p>El intérprete Lisp intentó evaluar el primer átomo de la lista, la palabra <samp>esto</samp>. Esta es la acción que ha generado el mensaje de error <samp>void-function esto</samp>.</p>
<p>El mensaje contiene las palabras <samp>void-function</samp> y <samp>esto</samp>.</p>
<p>La palabra <samp>function</samp> fué mencionada antes. Es una palabra muy importante. Para nuestros propósitos, podemos definirla diciendo que una <dfn>función</dfn> (<em>function</em>) es un conjunto de instrucciones para decirle al ordenador que haga alguna cosa.</p>
<p>Ahora podemos empezar a entender el mensaje de error: <samp>void-function esto</samp>. La función (es decir, la palabra <samp>esto</samp>) no tiene una definición de ningun conjunto de instrucciones que el ordenador pueda realizar.</p>
<p>La palabra ligeramente extraña, <samp>void-function</samp>, está diseñada para cubrir la forma en que Emacs Lisp lo implementa, que es cuando un símbolo no tiene una definición de función adjunta, el sitio que contiene la instruccion esta ‘vacio’ (<samp>void</samp>).</p>
<p>Por otro lado, ya que fuimos capaces de sumar 2 más 2 de manera exitosa, evaluando <code>(+ 2 2)</code>, se puede inferir que el símbolo <code>+</code> debe tener un conjunto de instrucciones que el ordenador ejecuta y estas instrucciones deben ser para sumar los números despues del <code>+</code>.</p>
<p>Es posible evitar que Emacs entre en el depurador en casos como este. No se explicará cómo hacer esto aquí, pero se mencionará como se ve el resultado, porque puede que te encuentres con una situación similar si hay un error en algún código de Emacs que estes usando. En tales casos, solo verá una línea de mensaje de error; aparecer en el área eco con el siguente aspecto:</p>
<div class="example-block" >
<pre class="example" >Symbol&#39;s function definition is void: esto
</pre>
</div>
<p>El mensaje desaparece tan pronto se presione una tecla, aunque sólo sea para mover el cursor.</p>
<p>Conocemos el significado de la palabra <samp>Symbol</samp>. Se refiere al primer átomo de la lista, la palabra <samp>este</samp>. La palabra <samp>function</samp> se refiere a las instrucciones que indican al ordenador que hacer. (Técnicamente, el símbolo le indica al ordenador donde encontrar las instrucciones, pero esta es una complicación que podemos ignorar por el momento.)</p>
<p>El mensaje de error es comprensible: <samp>La definición del símbolo está vacía: este</samp>. El símbolo (que es, la palabra <samp>este</samp>) carece de instrucciones para que el ordenador lo lleve a cabo.</p>
</div>
<h3 id="nombres-de-símbolos-y-definiciones-de-funciones" >Nombres de símbolos y definiciones de funciones</h3>
<div class="hBody-3" >
<p>Se puede articular otra característica de Lisp basada en lo que hemos discutido hasta ahora––una característica importante: un símbolo, como <code>+</code>, no es en sí mismo el conjunto de instrucciones que el ordenador lleva a cabo. En su lugar, el símbolo se utiliza, quizás temporalmente, como una forma de localizar la definición o conjunto de instrucciones. Lo que vemos es el nombre con el cual se pueden encontrar las instrucciones. Los nombres de las personas funcionan de la misma manera. Por ejemplo puede referirse a mi como <samp>Bob</samp>; sin embargo, no soy las letras <samp>B</samp>, <samp>o</samp>, <samp>b</samp> pero soy, o fuí, conscientemente asociado con una forma de vida particular. El nombre no soy yo, pero puede ser usado para referirse a mi.</p>
<p>En Lisp, un conjunto de instrucciones puede ligarse a varios nombres. Por ejemplo, las instrucciones para sumar números pueden ligarse al símbolo <code>mas</code> asi como a el símbolo <code>+</code> (y se encuentran en algunos dialectos de Lisp). Entre los humanos, puede referirse a <samp>Robert</samp> tan bien como <samp>Bob</samp> y con otras palabras también.</p>
<p>Por otra parte, un símbolo solo puede estar ligado con una función a la vez. De lo contrario, el ordenador estaría confundido acerca de qué definición usar. Si este fuera el caso entre las gente, solo una persona en el mundo podría llamarse <samp>Bob</samp>. Sin embargo, la definición de función a la que el nombre hace referencia puede cambiarse fácilmente. (Vea la Sección <a href="#instalar-una-definición-de-función" >Instalar una Definición de Función</a>.)</p>
<p>Ya que Emacs Lisp es extenso, se acostumbra nombrar los símbolos de una manera que identifique la parte de Emacs a la que pertenece la función. En consecuencia, todos los nombres de funciones relacionadas con Texinfo comienzan con <samp>texinfo-</samp> y aquellas relacionadas con la lectura de correo empiezan con <samp>rmail-</samp>.</p>
</div>
<h3 id="el-intérprete-lisp" >El intérprete Lisp</h3>
<div class="hBody-3" >
<p>Basado en lo que hemos visto, ahora podemos empezar a entender lo que hace el intéprete Lisp cuando le ordenamos que evalue una lista. Primero, examina si hay un símbolo cita antes de la lista; si lo hay, el intérprete solo nos da la lista. Por otra parte, si no hay cita, el intéprete mira si el primer elemento de la lista tiene una definición de función. De lo contrario, el intérprete imprime un mensaje de error.</p>
<p>Así es como funciona Lisp. Simple. Hay complicaciones añadidas a las que llegaremos en un minuto, pero estos son los fundamentos. Claro está, para escribir programas Lisp, se necesita saber como escribir definiciones de función y vincularlas a nombres, y como hacer esto sin confundirnos a nosotros mismos o al ordenador.</p>
<p>Ahora, una primera complicación. Además de las listas, el intérprete Lisp puede evaluar un símbolo no citado y sin paréntesis en torno a el. El intérprete intentará determinar el valor del símbolo como una <dfn>variable</dfn>. Esta situación se descrita en el apartado de las variables. (Vea la Seccion <a href="#variables" >Variables</a>.)</p>
<p>La segunda complicación ocurre debido a que algunas funciones son inusuales y no funcionan de la manera habitual. Estas son llamadas <dfn>formas especiales</dfn> (<em>special forms</em>). Son usadas para trabajos especiales, como definir una función, y no son muchas de ellas. En los siguientes capítulos, se presentaran varias de las formas especiales más importantes.</p>
<p>La tercera y ultima complicación es la siguiente: si la función que el intérprete Lisp está examinando no es una forma especial, y si es parte de una lista, el intérprete Lisp mira si la lista tiene una lista dentro de ella. Si hay una lista interna, el intérprete Lisp primero calcula lo qué debe hacer con la lista interna, y luego trabaja en la lista externa. Si hay otra lista embebida dentro de la lista interna, trabaja en esta primero, y así. Siempre se trabaja en la lista mas interna primero. El interprete trabaja primero en la lista más interana, para evaluar el resultado de esta lista. El resultado puede ser usado por la expresión entre paréntesis.</p>
<p>Por lo demas, el intérprete trabaja de izquierda a derecha, de una expresión a la siguiente.</p>
</div>
<h4 id="codigo-compilado" >Codigo Compilado</h4>
<div class="hBody-4" >
<p>Otro aspecto de la interpretación: el intérprete Lisp es capaz de interpretar dos tipos de entidades: código legible humanamente, en el que nos centraremos exclusivamente, y código especialmente procesado, llamado <dfn>compilado</dfn>, que no es humanamente legible. El código máquina compilado se ejecuta más rápido que el código humanamente legible.</p>
<p>Tu puedes transformar código legible por humanos en código compilado ejecutando uno de los comandos de compilación como <code>byte-compile-file</code>. El código compilado se almacena normalmente en un fichero que finaliza con una extensión <span class="file" >.elc</span> en vez de una extensión <span class="file" >.el</span>. Verás ambos tipos de ficheros en el directorio <span class="file" >emacs/lisp</span>; los ficheros para leer estos tinen la extensión <span class="file" >.el</span>.</p>
<p>Como una cuestión práctica, para hacer la mayoría de las cosas como personalizar o extender Emacs, no necesitas compilar codigo; y no comentare el asunto aquí. Vea la Seccion <a href="info:emacs#Byte-Compilation" >Código Compilado</a> en <em>El Manual de Referencia de GNU Emacs</em>, para una descripción completa de la compilacion de código.</p>
</div>
<h3 id="evaluación" >Evaluación</h3>
<div class="hBody-3" >
<p>Cuando el intérprete Lisp trabaja en una expresión, el término para la actividad es llamada <dfn>evaluación</dfn>. Decimos que el intérprete ‘evalúa la expresión’. Yo he usado este término varias veces antes. La palabra proviene de su uso en el lenguaje cotidiano, ‘para determinar el valor o la cantidad de; para estimar’ segun el <em>Webster&#39;s New Collegiate Dictionary</em>.</p>
<p>Después de evaluar una expresión, lo mas probable es que el intérprete Lisp <dfn>devuelva</dfn> el valor que el ordenador produce al ejecutar las instrucciones que encuentra en la definición de la función, o quizás se de por vencido con en esa función y produzca un mensaje de error. (El intérprete también puede quedarse colgado, por así decirlo, a una función diferente o puede intentar repetir continuamente lo que está haciendo por siempre  en lo que se llama un ‘bucle infinito’. Estas acciones son menos comunes; y podemos ignorarlas). Con mayor frecuencia, el intérprete devuelve un valor.</p>
<p>Al mismo tiempo que el intérprete devuelve un valor, también puede realizar cualquier otra cosa, como mover un cursor o copiar un fichero; este otro tipo de acción se denomina <dfn>efecto secundario</dfn>. Acciones que los humanos pensamos que son importantes, como imprimir resultados, con frecuencia son, “efectos secundarios” del intérprete Lisp. La jerga puede sonar peculiar, pero resulta que es bastante fácil aprender a utilizar los efectos secundarios.</p>
<p>En resumen, la evaluacion de una expresión simbólica normalmente causa que el intérprete devuelva un valor y tal vez lleve a cabo un efecto secundario; o al menos produca un error.</p>
</div>
<h4 id="evaluación-de-listas-internas" >Evaluación de listas internas</h4>
<div class="hBody-4" >
<p>Si la evaluación se aplica a una lista que está dentro de otra lista, la lista externa puede usar el valor devuelto por la primer evaluación como información cuando se evalua la lista externa. Esto explica por qué las expresiones internas se evaluan primero: los valores devueltos son usados por las expresiones externas.</p>
<p>Podemos investigar este proceso evaluando otro ejemplo de sumas. Coloca tu cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<p>El número 8 aparecerá en el área de eco.</p>
<p>Lo que ocurre es que el intérprete Lisp primero evalúa la expresión interna, <code>(+ 3 3)</code>, para lo cual se devuelve el valor 6; luego evalúa la expresión externa como si fuera escrita <code>(+ 2 6)</code>, que devuelve el valor 8. Puesto que no hay más expresiones adjuntas a evaluar el intérprete imprime este valor en el área de eco.</p>
<p>Ahora es fácil comprender el nombre del comando invocado por el atajo <kbd>C-x C-e</kbd>: el nombre es <code>eval-last-sexp</code>. Las letras <code>sexp</code> son una abreviatura para ‘expresión simbólica’, y <code>eval</code> es una abreviatura para ‘evaluar’ (<em>evaluate</em>). El comando significa ‘evaluar la última expresión simbólica’.</p>
<p>Como un experimento, puedes intentar evaluar la expresión poniendo el cursor al principio de la siguiente línea inmediatamente después de la expresión, o dentro de la expresión.</p>
<p>Aquí hay otra copia de la expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<p>Si colocas el cursor al principio de la línea en blanco que sigue inmediatamente a la expresión y presionas <kbd>C-x C-e</kbd>, aún se obtendrá el valor 8 impreso en el área eco. Ahora coloca el cursor dentro de la expresión. Si lo pones justo después del penúltimo paréntesis (de modo que parezca estar sobre el último paréntesis), ¡obtendrá un 6 impreso en el área de eco! Esto es porque el comando evalúa la expresión <code>(+ 3 3)</code>.</p>
<p>Ahora coloca el cursor inmediatamente después de un número. Presiona <kbd>C-x C-e</kbd> y obtendras el número en sí. En Lisp, si evalúas un número, obtienes el número en sí––así es cómo los números difieren de los símbolos. Si se evalúa una lista que inicia con un símbolo como <code>+</code>, se optiene un valor devuelto que es el resultado del ordenador tras ejecutar las instrucciones que aparecen en la definición de la función ligada a ese nombre. Si se evalua un símbolo por sí mismo, sucede algo diferente, como veremos en la siguiente sección.</p>
</div>
<h3 id="variables" >Variables</h3>
<div class="hBody-3" >
<p>En Emacs Lisp, un símbolo puede estar ligado a un valor como a una definición de función. Las dos son diferentes. La definición de función es un conjunto de instrucciones que el ordenador ejecuta. Por otro lado, un valor, es algo, como un número o un nombre, que puede variar (es por ello, que tal símbolo se llama variable). El valor de un símbolo puede ser cualquier expresión en Lisp, por ejemplo un símbolo, número, lista, o cadena. Un símbolo que tiene un valor con frecuencia se llama <dfn>variable</dfn>.</p>
<p>Un símbolo puede tanto una definición de función como un valor asociado a el al mismo tiempo. O puede tener solo uno u otro. Los dos son independientes. Esto es algo similar a la forma en que el nombre Cambridge puede referirse a la ciudad en Massachusetts y tener alguna información ligada al nombre, por ejemplo, un “gran centro de programación”.</p>
<p>Otra forma de pensar en esto es imaginar un símbolo como un mueble con cajones. La definición de función se pone en un cajón, el valor en otro, y asi sucesivamente. Lo que se pone en el cajón que contiene el valor se puede cambiar sin afectar los contenidos del cajón que almacena la definición de función, y viceversa.</p>
<p>La variable <code>fill-column</code> ilustra un símbolo con un valor adjunto: en cada buffer de GNU Emacs, este símbolo se establece en algún valor, normalmente 72 o 70, pero algunas veces en algún otro valor. Para encontrar el valor de este símbolo, evalúalo por sí mismo. Si estás leyendo esto dentro de GNU Emacs, puedes hacerlo poniendo el cursor después del símbolo y pulsar <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="nv">fill-column</span>
</code></pre>
<p>Después de presionar <kbd>C-x C-e</kbd>, Emacs imprimió el número 72 en mi área de eco. Este es el valor que he establecido para <code>fill-column</code> mientras escribo esto. Puede ser diferente en tu búfer. Observa que el valor devuelto como una variable se imprime exactamente de la misma forma que el valor devuelto por una función tras ejecutar sus instrucciones. Desde el punto de vista del intérprete Lisp, un valor devuelto es un valor devuelto. La clase de expresion de la que proviene deja de importar una vez que se conoce el valor.</p>
<p>Un símbolo puede tener cualquier valor ligado a él o, siendo tecnicos, se puede <dfn>enlazar</dfn> la variable a un valor: a un número, por ejemplo 72; a una cadena, <code>&#34;como esta&#34;</code>; a una lista, como <code>(abeto pino roble)</code>; podemos incluso asociar una variable a una definición de función.</p>
<p>Un símbolo puede vincularse a un valor de varias maneras. Vea la Sección <a href="#configurando-el-valor-de-una-variable" >Configurando el valor de una variable</a>, para obtener información sobre como hacerlo.</p>
</div>
<h4 id="mensaje-de-error-de-un-símbolo-sin-una-función" >Mensaje de error de un símbolo sin una función</h4>
<div class="hBody-4" >
<p>Cuando evaluamos <code>fill-column</code> para encontrar su valor como una variable, no pusimos paréntesis alrededor de la palabra. Esto se debe a que no pretendiamos usarla como un nombre de función.</p>
<p>Si <code>fill-column</code> fuese el primer o único elemento de una lista, el intérprete Lisp intentaría encontrar la definición de función adjunta. Pero <code>fill-column</code> no tiene una definición de función. Trata de evaluar esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">fill-column</span><span class="p">)</span>
</code></pre>
<p>Se creará un buffer <span class="file" >*Backtrace*</span> que dice:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>(Recuerda, para salir del depurador y hacer que la ventana del depurador desaparezca, presiona <kbd>q</kbd> en el buffer <span class="file" >*Backtrace*</span>.)</p>
</div>
<h4 id="mensaje-de-error-de-un-símbolo-sin-un-valor" >Mensaje de error de un símbolo sin un valor</h4>
<div class="hBody-4" >
<p>Si intenta evaluar un símbolo que no tiene un valor asociado, recibirá un mensaje de error. Esto se puede ver experimentando con nuestra suma 2 más 2. En la siguiente expresión, pon el cursor justo después del <code>+</code>, antes del primer número 2, presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>En GNU Emacs 22, se creará un buffer <span class="file" >*Backtrace*</span> que dice:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+ nil)
  elisp--eval-last-sexp(nil)
  eval-last-sexp(nil)
  funcall-interactively(eval-last-sexp nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>(De nuevo, puedes salir del depurador pulsando <kbd>q</kbd> en el búfer <span class="file" >*Backtrace*</span>.)</p>
<p>Esta traza inversa es diferente del primer mensaje de error que vimos, que decia, <samp>Debugger entered--Lisp error: (void-function esto)</samp>. En este caso, la función no tiene una valor como variable; mientras en el otro mensaje de error, la función (la palabra ‘esto’) no tuvo una definición.</p>
<p>En este experimento con el <code>+</code>, lo que hicimos fué hacer que el intérprete Lisp evalúe el <code>+</code> y busque el valor de la variable en lugar de la definición de la función. Hicimos esto colocando el cursor justo después del símbolo en lugar de ponerlo al final de los parentesis que cierran la lista como hicimos antes. Como consecuencia, el intérprete Lisp evaluó la expresión-s anterior, que en este caso fué el <code>+</code> en sí.</p>
<p>Ya que <code>+</code> no tiene un valor asociado, solo la definición de función, el mensaje de error informaba que el valor del símbolo como una variable estaba vacío.</p>
</div>
<h3 id="argumentos" >Argumentos</h3>
<div class="hBody-3" >
<p>Para ver cómo la información se pasa a las funciones, veamos de nuevo nuestro viejo recurso, la suma de dos más dos. En Lisp, esto se escribe de la siguiente manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>Si evalúas esta expresión, el número 4 aparecerá en el área de eco. Lo que el intérprete de Lisp hace es sumar los números despues del <code>+</code>.</p>
<p>Los números sumados por <code>+</code> se llaman <dfn>argumentos</dfn> de la función <code>+</code>. Estos números son la información que se da o <dfn>pasa</dfn> a la función.</p>
<p>La palabra ‘argumento’ proviene de la forma en que se usa en matemáticas y no se refiere a una disputa entre 2 personas, En su lugar, se refiere a la información entregada a la función, en este caso, al <code>+</code>. En Lisp, los argumentos de una función son los átomos o listas que siguen a la función. Los valores devueltos por la evaluación de estos átomos o listas se transfieren a la función. Funciones diferentes requieren diferentes números de argumentos; algunas funciones no requieren ninguno en absoluto.<span class="note" ><sup><a href="#2" >2</a></sup></span></p>
</div>
<h4 id="tipos-de-datos-de-los-argumentos" >Tipos de datos de los argumentos</h4>
<div class="hBody-4" >
<p>El tipo de dato que deben transmitirse a una función dependen de que tipo de información se utilice. Los argumentos de una función como <code>+</code> deben tener valores númericos, ya que <code>+</code> suma números. Otras funciones utilizan diferentes tipos de datos para sus argumentos.</p>
<p>Por ejemplo, la función <code>concat</code> concatena o une dos o más cadenas de texto para producir una cadena. Los argumentos son cadenas. Concatenar las cadenas de caracteres <code>abc</code>, <code>def</code> produce una cadena <code>abcdef</code>. Esto puede verse evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;abc&#34;</span> <span class="s">&#34;def&#34;</span><span class="p">)</span>
</code></pre>
<p>El valor producido al evaluar esta expresión es <code>&#34;abcdef&#34;</code>.</p>
<p>Una función como <code>substring</code> utiliza una cadena y numeros como argumentos. La función devuelve una parte de la cadena, una subcadena del primer argumento. Esta función toma tres argumentos. Su primer argumento es la cadena de caracteres, el segundo y tercer argumento son números que indican el principio y el fin de la subcadena. Los números son un conteo del número de caracteres (incluyendo espacios y puntuaciones) desde el principio de la cadena.</p>
<p>Por ejemplo, si evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">substring</span> <span class="s">&#34;El rápido zorro marrón saltó.&#34;</span> <span class="mi">10</span> <span class="mi">15</span><span class="p">)</span>
</code></pre>
<p>Verá aparecer <code>&#34;zorro&#34;</code> en el área de eco. Los argumentos son la cadena y los dos números.</p>
<p>Tenga en cuenta que la cadena pasada a <code>substring</code> es un solo átomo a pesar de estar compuesto de varias palabras separadas por espacios. Lisp considera todo entre las dos comillas como parte de la cadena, incluyendo los espacios. Se puede pensar en la función <code>substring</code> como una especie de ‘acelerador de particulas’ ya que toma un átomo de otro modo indivisible y extrae una parte. Sin embargo, <code>substring</code> solo es capaz de extraer una subcadena de un argumento que es una cadena, no de otro tipo de átomo por ejemplo un número o símbolo.</p>
</div>
<h4 id="un-argumento-como-el-valor-de-una-variable-o-lista" >Un argumento como el valor de una variable o lista</h4>
<div class="hBody-4" >
<p>Un argumento puede ser un símbolo que devuelve un valor cuando se evalua. Por ejemplo, evaluar el símbolo <code>fill-column</code> en si, devuelve un número. Este número se puede utilizar en una suma.</p>
<p>Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="nv">fill-column</span><span class="p">)</span>
</code></pre>
<p>El valor será dos, mas el número que se obtiene al evaluar solamente <code>fill-column</code>. En mí caso, es 74, porque mi valor de <code>fill-column</code> es 72.</p>
<p>Como acabamos de ver, un argumento puede ser un símbolo que devuelve un valor cuando se evalúa. Además, un argumento puede ser una lista que devuelve un valor cuando se evalúa. Por ejemplo, en la siguiente expresión, los argumentos de la función <code>concat</code> son las cadenas <code>&#34;Los &#34;</code> y <code>&#34; zorros rojos.&#34;</code> y la lista <code>(number-to-string (+ 2 fill-column))</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;Los &#34;</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="nv">fill-column</span><span class="p">))</span> <span class="s">&#34; zorros rojos.&#34;</span><span class="p">)</span>
</code></pre>
<p>Si evaluas esta expresión––y si, como con mi Emacs, <code>fill-column</code> se evalúa a 72––aparecerá <code>&#34;Los 74 zorros rojos.&#34;</code> en el área de eco. (Ten en cuenta que debes poner espacios después de la palabra <samp>Los</samp> y antes de la palabra <samp>zorros</samp> que aparece en la cadena final. La función <code>number-to-string</code> convierte el entero que devuelve la función suma a una cadena. <code>number-to-string</code> también se conoce como <code>int-to-string</code>.)</p>
</div>
<h4 id="número-variable-de-argumentos" >Número variable de argumentos</h4>
<div class="hBody-4" >
<p>Algunas funciones, como <code>concat</code>, <code>+</code>, o <code>*</code>, toman cualquier número de argumentos. (<code>*</code> es el símbolo para la multiplicacion.) Esto puede verse evaluando cada una de las siguientes expresiones de la forma habitual.</p>
<p>En el primer conjunto, las funciones no tienen argumentos:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">+</span><span class="p">)</span>
</span><span class="out" >0
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">*</span><span class="p">)</span>
</span><span class="out" >1
</span></code></pre>
<p>En este conjunto, las funciones tienen un argumento cada una:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">+</span> <span class="mi">3</span><span class="p">)</span>
</span><span class="out" >3
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">*</span> <span class="mi">3</span><span class="p">)</span>
</span><span class="out" >3
</span></code></pre>
<p>En este conjunto, las funciones tienen tres argumentos cada una:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">+</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="out" >12
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">*</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="out" >60
</span></code></pre>
</div>
<h4 id="usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</h4>
<div class="hBody-4" >
<p>Cuando a una función se le pasa un argumento del tipo incorrecto, el interpréte Lisp genera un mensaje de error. Por ejemplo, la función <code>+</code> espera que los valores de sus argumentos sean números. Como un experimento podemos pasar el símbolo citado <code>hola</code> en lugar de un número. Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">2</span> <span class="ss">&#39;hola</span><span class="p">)</span>
</code></pre>
<p>Al hacer esto se generará un mensaje de error. Lo qué ha ocurrido es que <code>+</code> ha intentado sumar el 2 al valor devuelto por <code>&#39;hola</code>, pero el valor devuelto por <code>&#39;hola</code> es el símbolo <code>hola</code>, no un número. Solo los números se pueden sumar. Por tanto <code>+</code> no pudo llevar a cabo su suma.</p>
<p>Se creará e ingresara a un búfer <span class="file" >*Backtrace*</span> que diga:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p hola)
  +(2 hola)
  eval((+ 2 (quote hola)) nil)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp nil nil)
  command-execute(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Como de costumbre, el mensaje de error intenta ser útil y tiene sentido después de aprender cómo leerlo.<span class="note" ><sup><a href="#3" >3</a></sup></span></p>
<p>La primer parte del mensaje de error es sencilla; dice <samp>wrong type argument</samp> (tipo de argumento incorrecto). A continuación viene la misteriosa jerga tecnica <samp>number-or-marker-p</samp>. Esta palabra está intentando decirte qué tipo de argumento espera <code>+</code>.</p>
<p>El símbolo <code>number-or-marker-p</code> dice que el intérprete Lisp está intentando determinar si la información presentada (el valor del argumento) es un número o una marca (un objeto especial que representa una posición de buffer). Lo que hace es probar si se le estan dando numeros a sumar a <code>+</code>. También prueba si el argumento es algo llamado marcador, que es una caracteristica específica de Emacs Lisp. (En Emacs, las ubicaciones en un búfer se registran como marcadores. Cuando se establece la marca con el comando <kbd>C-@</kbd> o <kbd>C-SPC</kbd>, su posición se guarda como un marcador. La marca se puede consider un número––el número de caracteres es la ubicacion desde el comienzo del búfer.)  En Emacs Lisp, <code>+</code> se puede utilizar para sumar el valor numérico de los marcadores como números.</p>
<p>La <samp>p</samp> en <code>number-or-marker-p</code> es la encarnación de una práctica iniciada en los primeros días de la programación Lisp. La <samp>p</samp> significa ‘predicado’. En la jerga usada por los primeros investigadores de Lisp, un predicado se refiere a una función para determinar si alguna propiedad es verdadera o falsa. Entonces la <samp>p</samp> nos dice que <code>number-or-marker-p</code> es el nombre de una función que determina si el argumento dado es un número o una marca. Otros símbolos Lisp que finalizan en <samp>p</samp> incluyen <code>zerop</code>, una función que comprueba si su argumento tiene el valor de cero, y <code>listp</code>, una función que comprueba si su argumento es una lista.</p>
<p>Finalmente, la última parte del mensaje de error es el símbolo <code>hola</code>. Este es el valor del argumento que se paso a <code>+</code>. Si a la suma se le hubiese pasado el tipo de objeto correcto, el valor habría sido un número, como 37, en lugar de un símbolo como <code>hola</code>. Pero entonces no habrías obtenido el mensaje de error.</p>
</div>
<h4 id="la-función-message" >La función <code>message</code></h4>
<div class="hBody-4" >
<p>Al igual que <code>+</code>, la función <code>message</code> toma un número variable de argumentos. Se utiliza para enviar mensajes al usuario y es tan útil que vamos la describiremos aqui.</p>
<p>Se imprime un mensaje en el área de eco. Por ejemplo, puede imprimir un mensaje en su área de eco evaluando la siguiente lista:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Este mensaje aparece en el área de eco!&#34;</span><span class="p">)</span>
</code></pre>
<p>Toda la cadena entre comillas dobles es un unico argumento y se imprime <i>en su totalidad</i>. (Note que en este ejemplo, el mensaje en sí aparece en el área de eco entre comillas dobles; esto se debe a que ves el valor devuelto por la función <code>message</code>. En la mayoría de programas que escribiras, el texto se imprimira en el área de eco como un efecto secundario de <code>message</code>, sin las comillas. Vea la Sección <a href="#un-multiply-by-seven-interactivo" >Un <code>multiply-by-seven</code> interactivo</a> en detalle, para un ejemplo de esto.)</p>
<p>Sin embargo, si hay un <samp>%s</samp> en la cadena de caracteres citada, la función <code>message</code> no imprime el <samp>%s</samp> como tal, si no que busca el siguente argumento a continuacion de la cadena. Evalúa el segundo argumento e imprime el valor en la ubicación de la cadena donde está el <samp>%s</samp>.</p>
<p>Puede ver esto colocando el cursor después de la siguiente expresión y presionar <kbd>C-x C-e</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El nombre de este búfer es: %s.&#34;</span> <span class="p">(</span><span class="nf">buffer-name</span><span class="p">))</span>
</code></pre>
<p>En Info, <code>&#34;El nombre de este búfer es: *info*.&#34;</code> aparecerá en el área de eco. La función <code>buffer-name</code> devuelve el nombre del búfer como una cadena, que la función <code>message</code> inserta en lugar de <code>%s</code>.</p>
<p>Para imprimir un valor como un entero, utiliza <samp>%d</samp> de la misma forma que <samp>%s</samp>. Por ejemplo, para imprimir un mensaje en el área de eco que indique el valor de <code>fill-column</code>, evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El valor de fill-column es %d.&#34;</span> <span class="nv">fill-column</span><span class="p">)</span>
</code></pre>
<p>En mi sistema, cuando evalúo esta lista, <code>&#34;El valor de fill-column es 72&#34;</code> aparece en mi área de eco<span class="note" ><sup><a href="#4" >4</a></sup></span>.</p>
<p>Si hay más de un <samp>%s</samp> en la cadena citada, el valor del primer argumento después de la cadena citada se imprime en la posición del primer <samp>%s</samp> y el valor del segundo argumento se imprime en la posición del segundo <samp>%s</samp>, y así sucesivamente.</p>
<p>Por ejemplo, si evalúa lo siguiente,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Hay %d %s en la oficina!&#34;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">fill-column</span> <span class="mi">14</span><span class="p">)</span> <span class="s">&#34;elefantes rosas&#34;</span><span class="p">)</span>
</code></pre>
<p>Un mensaje un poco caprichoso aparecerán en el área de eco. En mi sistema dice <code>&#34;¿Hay 58 elefantes rosas en la oficina!&#34;</code></p>
<p>Se evalúa la expresión <code>(- fill-column 14)</code> y el número resultante se inserta en lugar del <samp>%d</samp>; y la cadena entre comillas dobles, <code>&#34;elefantes rosas&#34;</code>, se trata como un argumento unico y se inserta en lugar del <samp>%s</samp>. (Es decir, una cadena entre comillas dobles se evalúa así misma, como un número.)</p>
<p>Por último, aquí está un ejemplo algo complejo que no solo ilustra el cálculo de un número, también muestra como se puede usar una expresión dentro de una expresión para generar el texto que sustituira el <samp>%s</samp>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Él vió %d %s&#34;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">fill-column</span> <span class="mi">36</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;rojos &#34;</span>
                 <span class="p">(</span><span class="nf">substring</span>
                  <span class="s">&#34;Los rápidos zorros marrones saltaron.&#34;</span> <span class="mi">12</span> <span class="mi">18</span><span class="p">)</span>
                 <span class="s">&#34; saltando.&#34;</span><span class="p">))</span>
</code></pre>
<p>En este ejemplo, <code>message</code> tiene tres argumentos: la cadena, <code>&#34;Él vió %d %s&#34;</code>, la expresión, <code>(- fill-column 32)</code>, y la expresion que comienza con la función <code>concat</code>. El valor resultante de la evaluación de <code>(- fill-column 32)</code> se inserta en lugar del <samp>%d</samp>; y el valor devuelto por la expresión que inicia con <code>concat</code> se inserta en lugar del <samp>%s</samp>.</p>
<p>Cuando <code>fill-column</code> es 70 y evaluas la expresión, aparecera el mensaje <code>&#34;Él vió 38 rojos zorros saltando.&#34;</code> en tu área de eco.</p>
</div>
<h3 id="configurando-el-valor-de-una-variable" >Configurando el valor de una variable</h3>
<div class="hBody-3" >
<p>Hay varias formas de asignar un valor a una variable. Una de ellas es utilizar la función <code>set</code> o la función <code>setq</code>. Otra forma es utilizar <code>let</code> (Vea la Seccion <a href="#let" ><code>let</code></a>). (La jerga para este proceso es <dfn>ligar</dfn> (<em>bind</em>) una variable a un valor.)</p>
<p>Las siguientes secciones no solo describen cómo operan <code>set</code> y <code>setq</code>, también ilustran como se pasan los argumentos.</p>
</div>
<h4 id="usando-set" >Usando <code>set</code></h4>
<div class="hBody-4" >
<p>Para establecer el valor del símbolo <code>flores</code> a la lista <code>&#39;(rosa violeta margarita tulipan)</code>, evalúa la siguiente expresión colocando el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set</span> <span class="ss">&#39;flores</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>La lista <code>(rosa violeta margarita tulipan)</code> aparecerá en el área de eco. Esto es la que <em>devuelve</em> la función <code>set</code>. Como efecto secundario, el símbolo <code>flores</code> esta ligado a la lista; es decir, el símbolo <code>flores</code>, puede verse como una variable, que entrega la lista como su valor. (Por cierto, este proceso, ilustra como un efecto secundario al intérprete Lisp, estableciendo el valor, puede ser el principal efecto que nos interesa a los humanos. Esto se debe a que cada función Lisp debe devolver un valor si no obtiene un error, pero solo tendrá un efecto secundario si está diseñada para tener uno.)</p>
<p>Después de evaluar la expresión <code>set</code>, se puede evaluar el símbolo <code>flores</code> y ha de devolver el valor que acaba de establecer. Aquí está el símbolo. Coloca el cursor al final de este y presiona <kbd>C-x C-e</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="nv">flores</span>
</code></pre>
<p>Al evalúar <code>flores</code>, aparece la lista <code>(rosa violeta margarita tulipan)</code> en el área de eco.</p>
<p>Por cierto, si se evalúa <code>&#39;flores</code>, la variable con una cita frente a ella, lo que verá en el área de eco es el símbolo en sí mismo, <code>flores</code>. Aquí está el símbolo citado, asi que puedes intentarlo:</p>
<pre class="code" ><code class="chroma" ><span class="ss">&#39;flores</span>
</code></pre>
<p>Tenga en cuenta también, que cuando se utiliza <code>set</code>, es necesario citar ambos argumentos para <code>set</code>, a menos que los quiera evaluar. Puesto que no queremos evaluar, ni la variable <code>flores</code>, ni la lista <code>(rosa violeta margarita tulipan)</code>, ambos se citan. (Cuando se utiliza <code>set</code> sin citar su primer argumento, el primer argumento se evalúa antes de realizar cualquier otra cosa. Si hizo esto y <code>flores</code> no tenía ya un valor, otendria un mensaje de error con el <samp>Valor de símbolo como variable esta vacío</samp>; por otro lado, si <code>flores</code> regreso un valor después de ser evaluado, <code>set</code> intentaría establecer el valor que fue devuelto. Hay situaciones donde esto es justo lo que la función a de hacer, pero estas situaciones son poco frecuentes.)</p>
</div>
<h4 id="usando-setq" >Usando <code>setq</code></h4>
<div class="hBody-4" >
<p>Como una cuestión práctica, casi siempre se cita el primer argumento de <code>set</code>. La combinación de <code>set</code> y un primer argumento citado es tan común que tiene nombre propio: la forma especial <code>setq</code>. Esta forma especial es similar a <code>set</code> excepto que el primer argumento es citado automáticamente, por lo que no necesita escribir la marca de cita. También, para mayor comodidad, <code>setq</code> permite asignar varias variables diferentes a diferentes valores, todo en una sola expresión.</p>
<p>Para establecer el valor de la variable <code>carnívoros</code> a la lista <code>&#39;(leon tigre leopardo)</code> usando <code>setq</code>, se utiliza la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">carnivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">))</span>
</code></pre>
<p>Esto es exactamente igual que usar <code>set</code> excepto que el primer argumento es citado automáticamente por <code>setq</code>. (La <samp>q</samp> en <code>setq</code> significa <code>quote</code> (<em>cita</em>).)</p>
<p>Con <code>set</code>, la expresión que se vería es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set</span> <span class="ss">&#39;carnivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">))</span>
</code></pre>
<p>Además, <code>setq</code> se puede utilizar para asignar diferentes valores a diferentes variables. El primer argumento se une al valor del segundo argumento, el tercer argumento se une a al valor del cuarto argumento, y así sucesivamente. Por ejemplo, podría utilizar lo siguiente para asignar una lista de árboles al símbolo <code>arboles</code> y una lista de herbívoros al símbolo <code>herbivoros</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">arboles</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
      <span class="nv">herbivoros</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">))</span>
</code></pre>
<p>(La expresión podría también haber estado en una sola línea, pero podría no caber en una página; y a los humanos les resulta más fácil leer listas con un formato agradable.)</p>
<p>Aunque he estado usando el término ‘asignar’, hay otra forma de pensar respecto a el funcionamiento de <code>set</code> y <code>setq</code>; y consiste en decir que <code>set</code> y <code>setq</code> crean un símbolo que <em>apunta</em> a la lista. Esta ultima forma de pensar es muy común y en los proximos capítulos encontraremos por lo menos un símbolo con un ‘puntero’ como parte de su nombre. El nombre se elige porque el símbolo tiene un valor, específicamente una lista, unida a el; o, expresado de otra manera, el símbolo se fija para “apuntar” a la lista.</p>
</div>
<h4 id="conteo" >Conteo</h4>
<div class="hBody-4" >
<p>He aquí un ejemplo que muestra cómo utilizar <code>setq</code> en un contador. Es posible usar esto para contar cuantas veces una parte de un programa se repite. En primer lugar establesca una variable a cero; luego sume uno al número cada vez que el programa se repita. Para ello, se necesita una variable que sirva como un contador, y dos expresiones: una expresión <code>setq</code> inicial que asigna la variable contador a cero; y una segunda expresión <code>setq</code> que incrementa el contador cada vez se evalue.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="mi">0</span><span class="p">)</span>                <span class="c1">; Llamemos a esto el inicializador.</span>

<span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">contador</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">; Este es el incremento.</span>

<span class="nv">contador</span>                         <span class="c1">; Este es el contador.</span>
</code></pre>
<p>(El texto que sigue al <samp>;</samp> son los comentarios. Vea la Seccion <a href="#cambiar-una-definición-de-función" >Cambiar una definición de función</a>.)</p>
<p>Si evalúas la primera de estas expresiones, el inicializador, <code>(setq contador 0)</code>, y luego evalúas la tercera expresión, <code>contador</code>, el número <code>0</code> aparecerá en el área de eco. Si a continuación se evalúa la segunda expresión, el incremento, <code>(setq contador (+ contador 1))</code>, el contador tendrá el valor 1. Así que si evalúas de nuevo <code>contador</code>, el número <code>1</code> aparecerá en el área de eco. Cada vez que se evalúa la segunda expresión, el valor del contador se incrementara.</p>
<p>Al evalúar el incremento, <code>(setq contador (+ contador 1))</code>, el intérprete Lisp evalúa en primer lugar la lista interna; esta es la suma. Para evaluar esta lista, se debe evaluar la variable <code>contador</code> y el número <code>1</code>. Cuando evalúa la variable <code>contador</code>, recibe su valor actual. Se pasa este valor y el número <code>1</code> a <code>+</code> que los suma. La suma se devuelve como el valor de la list interior y pasa a <code>setq</code> que establece la variable <code>contador</code> a este nuevo valor. Por lo tanto, el valor de la variable <code>contador</code>, cambia.</p>
</div>
<h3 id="resumen" >Resumen</h3>
<div class="hBody-3" >
<p>Aprender Lisp es como subir una colina en la que la primera parte es la mas empinada. Ahora has subido la parte más difícil; lo que queda se vuelve más fácil a medida que avanzas hacia adelante.</p>
<p>En resumen,</p>
<ul>
<li>
<p>Los programas Lisp se componen de expresiones, que son listas o átomos individuales.</p>
</li>
<li>
<p>La listas se componen de cero o más átomos o listas internas, separadas por espacios en blanco y rodeadas por paréntesis. Una lista puede estar vacía.</p>
</li>
<li>
<p>Los átomos son símbolos de varios caracteres, como <code>forward-paragraph</code>, símbolos de un solo caracter como <code>+</code>, cadenas de caracteres entre comillas dobles, o números.</p>
</li>
<li>
<p>Un número se evalúa a sí mismo.</p>
</li>
<li>
<p>Una cadena entre comillas dobles también se evalúa a sí misma.</p>
</li>
<li>
<p>Cuando se evalúa un símbolo a sí mismo, se devuelve su valor.</p>
</li>
<li>
<p>Cuando se evalúa una lista, el intérprete Lisp mira el primer símbolo en la lista y luego la definición de función asociada a ese símbolo. A continuación se ejecutan las instrucciones en la definición de la función.</p>
</li>
<li>
<p>Una marca de cita, <code>&#39;</code>, le indica al intérprete Lisp que devuelva la siguiente expresión tal como esta escrita, y no la evalúa como lo haria si la cita no estuviera alli.</p>
</li>
<li>
<p>Los argumentos son la información que se pasa a una función. Los argumentos de una función se calculan evaluando el resto de los elementos de la lista de los cuales la función es el primer elemento.</p>
</li>
<li>
<p>Una función siempre devuelve un valor cuando se evalúa (a menos que obtenga un error); además, también se puede llevar a cabo alguna acción llamada “efecto secundario”. En muchos casos, el propósito principal de una función es crear un efecto secundario.</p>
</li>
</ul>
</div>
<h3 id="ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<p>Unos pocos ejercicios simples:</p>
<ul>
<li>
<p>Generar un mensaje de error evaluando un símbolo apropiado que no este entre paréntesis.</p>
</li>
<li>
<p>Generar un mensaje de error evaluando un símbolo apropiado situado entre paréntesis.</p>
</li>
<li>
<p>Crear un contador que se incrementa en dos en lugar de uno.</p>
</li>
<li>
<p>Escribe una expresión que imprima un mensaje en el área de eco cuando se evalue.</p>
</li>
</ul>
</div>
<h2 id="practicando-la-evaluación" >Practicando la Evaluación</h2>
<div class="hBody-2" >
<p>Antes de aprender como escribir una definición de función en Emacs Lisp, es útil pasar un poco de tiempo evaluando varias expresiones que ya han sido escritas. Estas expresiones serán listas con funciones como su primer (y con frecuencia único) elemento. Dado que algunas de las funciones asociadas con búfers son a la vez simples e interesantes, empezaremos por ellas. En esta sección, vamos a evaluar algunas. En otra sección, estudiaremos el código de varias otras funciones relacionadas con búfers, para ver la forma cómo fueron escritas.</p>
<p><i>Siempre que proporciona un comando de edición</i> a Emacs Lisp, como el comando para mover el cursor o para desplazar por la pantalla, <i>se está evaluando una expresión</i>, cuyo primer elemento es una función. <i>Así es cómo funciona Emacs</i>.</p>
<p>Al presionar las teclas, haces que el interprete Lisp evalue una expresion y asi es como obtienes tus resultados. Incluso escribir texto plano implica evalúar una función de Emacs Lisp, en este caso, se utiliza <code>self-insert-command</code>, que simplemente inserta el caracter que escribiste. Las funciones que se evalúan presionando atajos de teclado se llaman funciones <dfn>interactivas</dfn>, o <dfn>comandos</dfn>; la forma de hacer que una funcion sea interactiva se ilustrara en el capítulo sobre cómo escribir definiciones de funciones. Vea la Seccion <a href="#crear-una-función-interactiva" >Crear una Función Interactiva</a>.</p>
<p>Además de presionar comandos de teclado, hemos visto una segunda manera de evaluar una expresión: colocar el cursor después de una lista y presionar <kbd>C-x C-e</kbd>. Esto es lo que haremos en el resto de esta sección. Hay otras maneras de evaluar una expresión; que serán descritas a medida que llegemos a ellas.</p>
<p>Ademas de utilizarce para prácticar la evaluación, las funciones que se muestran en las siguientes secciones son importantes por derecho propio. Un estudio de estas funciones deja claro la distinción entre búfers y ficheros, cómo cambiar a un búfer, y como determinar una ubicación dentro de el.</p>
</div>
<h3 id="nombres-de-búfer" >Nombres de búfer</h3>
<div class="hBody-3" >
<p>Las dos funciones, <code>buffer-name</code> y <code>buffer-file-name</code>, muestran la diferencia entre un fichero y un búfer. Cuando se evalúa la siguiente expresión, <code>(buffer-name)</code>, el nombre del buffer aparece en el area eco. Al evaluar <code>(buffer-file-name)</code>, el nombre del fichero al que se relaciona el búfer aparece en el área de eco. Por lo general, el nombre devuelto por <code>(buffer-name)</code> es el mismo que el nombre del fichero al que hace referencia, y el nombre devuelto por <code>(buffer-file-name)</code> es la ruta completa del fichero.</p>
<p>Un fichero y un búfer son dos entidades diferentes. Un fichero es la información grabada de manera permanente en el ordenador (a menos que se elimine). Un búfer, por otro lado, es la información dentro de Emacs que desaparecerá al final de la sesión de edición (o cuando matas el búfer). Por lo general, un búfer contiene información que se ha copiado desde un fichero; decimos que el búfer está <dfn>visitando</dfn> ese fichero. Esta copia es en la que se trabaja y modifica. Los cambios al búfer no cambian el fichero, hasta ser guardados. Al guardar el búfer, el búfer se copia en el fichero y por lo tanto se guarda de forma permanente.</p>
<p>Si está leyendo esto dentro de GNU Emacs, puede evaluar cada una de las siguientes expresiones colocando el cursor después de estas y pulsando <kbd>C-x C-e</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">buffer-name</span><span class="p">)</span>

<span class="p">(</span><span class="nf">buffer-file-name</span><span class="p">)</span>
</code></pre>
<p>Cuando hago esto en el búfer <span class="file" >*info*</span>, el valor devuelto evaluando <code>(buffer-name)</code> es <span class="file" >&#34;*info*&#34;</span>, y el valor devuelto evaluando <code>(buffer-file-name)</code> es <span class="file" >nil</span>.</p>
<p>Por otro lado, mientras escribo este documento, el valor devuelto por la evaluación de <code>(buffer-name)</code> es <code>&#34;introduction.texinfo&#34;</code>, y el valor devuelto por la evaluación de <code>(buffer-file-name)</code> es <code>&#34;/gnu/work/intro/introduction.texinfo&#34;</code>.</p>
<p>El primero es el nombre del búfer y el segundo es el nombre del fichero. En Info, el nombre del búfer es <span class="file" >&#34;*info*&#34;</span>. Info no apunta a ningún fichero, por lo que el resultado de evaluar <code>(buffer-file-name)</code>] es <span class="file" >nil</span>. El símbolo <code>nil</code> proviene del latin, significa ‘nada’; en este caso, significa que el búfer no está asociado con ningun fichero. (En Lisp, <code>nil</code> también se utiliza con el significado de ‘falso’ y es sinómino para la lista vacía, <code>()</code>.)</p>
<p>Al escribir esto, el nombre de mi búfer es <code>&#34;introduction.texinfo&#34;</code>. El nombre del fichero al que apunta es <code>&#34;/gnu/work/intro/introduction.texinfo&#34;</code>.</p>
<p>(En las expresiones, los paréntesis le indican al intérprete Lisp que trate a <code>buffer-name</code> y <code>buffer-file-name</code> como funciones; sin los paréntesis, el intérprete intentaría evaluar los símbolos como variables. Vea la Sección <a href="#variables" >Variables</a>.)</p>
<p>A pesar de la distinción entre ficheros y búfers, con frecuencia encontrara personas referirse a un fichero cuando quieren un búfer y viceversa. De hecho, la mayoría de la gente dice, “Estoy editando un fichero”, en lugar de decir, “Estoy editando un búfer que pronto voy a guardar en un fichero”. Esto casi siempre queda claro a partir del contexto de lo que la gente dice. No obstante, Al tratar con programas de ordenador, es importante mantener la distinción en mente, ya que el ordenador no es tan inteligente como una persona.</p>
<p>Por cierto, la palabra ‘búfer’, viene del significado de la palabra como un cojín que amortigua la fuerza de una colisión. En los primeros ordenadores, un búfer amortiguaba la interacción entre los ficheros y la unidad central de procesamiento del ordenador. Los tambores o cintas que contenian un fichero y la unidad de procesamiento eran piezas de equipamiento muy diferentes entre si, que trabajaban a sus propias velocidades, por rafagas. El búfer hizo posible que ambos trabajaran juntos de manera efectiva. Con el tiempo, el búfer pasó de ser un intermediario, un lugar de almacenamiento temporal, a ser el lugar donde se realiza el trabajo. Esta transformación se parace bastante a la de un pequeño puerto que se convierte en una gran ciudad: una vez fué simplemente el lugar donde la carga era depositada temporalmente antes de ser cargada en los barcos; despues se convirtio en un centro comercial y cultural por derecho propio.</p>
<p>No todos los búfers están asociados con ficheros. Por ejemplo, el búfer <span class="file" >*scratch*</span> no visita ningun fichero. Del mismo modo, un búfer <span class="file" >*Help*</span> no está asociado a ningun fichero.</p>
<p>En los viejos tiempos, cuando se carecia de un fichero <span class="file" >~/.emacs</span> y se iniciava una sesión Emacs escribiendo unicamente el comando <code>emacs</code>, sin nombrar ningun fichero, Emacs iniciaba con el búfer <span class="file" >*scratch*</span> visible. Hoy en día, vera una pantalla de bienvenida. Puede seguir uno de los comandos sugeridos en dicha pantalla, visitar un fichero, o presionar la barra espaciadora para acceder al búfer <span class="file" >*scratch*</span>.</p>
<p>Si cambias al búfer <span class="file" >*scratch*</span>, escribe <code>(buffer-name)</code>, coloca el cursor al final de la expresión, y presiona <kbd>C-x C-e</kbd> para evaluar la expresión. El nombre <code>*scratch*</code> será devuelto y aparecerá en el área de eco. <code>*scratch*</code> es el nombre del búfer. Al escribir y evaluar <code>(buffer-file-name)</code> en el búfer <span class="file" >*scratch*</span>, aparecerá <code>nil</code> en el área de eco, igual que cuando evalúas <code>(buffer-file-name)</code> en Info.</p>
<p>Por cierto, si estas en el búfer <span class="file" >*scratch*</span> y quieres que el valor devuelto por una expresión aparezca en el búfer en sí y no en el área de eco, presiona <kbd>C-u C-x C-e</kbd> en lugar de <kbd>C-x C-e</kbd>. Esto hace que el valor devuelto aparezca después de la expresión. El búfer se verá así:</p>
<div class="example-block" >
<pre class="example" >(buffer-name)&#34;*scratch*&#34;
</pre>
</div>
<p>No se puede hacer esto en Info ya que Info es de solo lectura y no se permitirá cambiar el contenido del búfer. Pero puedes hacer esto en cualquier búfer que puedas editar; y cuando escribes código o documentación (como este libro), esta caracteristica es muy útil.</p>
</div>
<h3 id="obtención-de-búfers" >Obtención de Búfers</h3>
<div class="hBody-3" >
<p>La función <code>buffer-name</code> devuelve el <em>nombre</em> del búfer; para obtener el búfer <em>en sí</em>, se necesita una función diferente: la función <code>current-buffer</code>. Si utiliza esta función en el código, lo que se obtiene es el búfer en sí.</p>
<p>Un nombre y el objeto o entidad al que se refiere el nombre son diferentes entre si. Tu no eres tu nombre, eres una persona a la que se refieren los demas por tu nombre. Si pides hablar con Jorge y alguien te entrega una tarjeta con las letras <samp>J</samp>, <samp>o</samp>, <samp>r</samp>, <samp>g</samp>, y <samp>e</samp> estritas, podrias divertirte, pero no estarías satisfecho. No quieres hablar con el nombre, sino con la persona a la que se refiere el nombre. Un búfer es similar: el nombre del búfer scratch es <span class="file" >*scratch*</span>, pero el nombre no es el búfer. Para obtener un búfer en sí, es necesario utilizar una función como <code>current-buffer</code>.</p>
<p>Sin embargo, hay una ligera complicación: si evalúas <code>current-buffer</code> en una expresión por sí sola, como haremos aquí, lo que se ve es una representación impresa del nombre del búfer sin el contenido del búfer. Emacs funciona de esta forma por dos razones: el búfer puede contener miles de líneas––demasiado largo para ser mostrado convenientemente; y, otro búfer puede tener el mismo contenido pero un nombre diferente, y es importante distinguir entre ellos.</p>
<p>Aquí hay una expresión que contiene la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span>
</code></pre>
<p>Si evalúa esta expresión en Info de la manera habitual, aparecerá <span class="file" >#&lt;buffer *info*&gt;</span> en el área de eco. El formato especial indica que el búfer en sí está siendo devuelto, en lugar de solo su nombre.</p>
<p>Por cierto, si bien puedes escribir un número o símbolo en un programa, no se puede hacer esto con la representación impresa del búfer: la única manera de optener un búfer en sí mismo es con una función como <code>current-buffer</code>.</p>
<p>Un función relacionada es <code>other-buffer</code>. Esta devuelve el último bufer seleccionado distinto al que te encuentras actualmente, no una representación impresa de su nombre. Si recientemente has ido y vuelto del búfer <span class="file" >*scratch*</span>, <code>other-buffer</code> devolverá ese búfer.</p>
<p>Puedes ver esto evaluando la expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">other-buffer</span><span class="p">)</span>
</code></pre>
<p>Verás que <code>#&lt;buffer *scratch*&gt;</code> aparece en el área de eco, o el nombre de cualquier otro búfer al que allas cambiado anteriormente a partir del más reciente<span class="note" ><sup><a href="#5" >5</a></sup></span></p>
</div>
<h3 id="cambiando-búfers" >Cambiando búfers</h3>
<div class="hBody-3" >
<p>La función <code>other-buffer</code> realmente proporciona un búfer cuando se utiliza como argumento de una función que requiera uno. Podemos ver esto usando <code>other-buffer</code> y <code>switch-to-buffer</code> para cambiar a un búfer diferente.</p>
<p>Pero primero, una breve introducción a la función <code>switch-to-buffer</code>. Cuando cambias de ida y vuelta de Info al búfer <span class="file" >*scratch*</span> para evaluar <code>(buffer-name)</code>, normalmente se presiona <kbd>C-x b</kbd> y luego se pasa <span class="file" >*scratch*</span><span class="note" ><sup><a href="#6" >6</a></sup></span> en el minibuffer cuando se le solicita el nombre del buffer al que quieres cambiar. El atajo, <kbd>C-x b</kbd>, hace que el intérprete Lisp evalúe la función interactiva <code>switch-to-buffer</code>. Como hemos dicho anteriormente, así es como funciona Emacs: diferentes atajos de teclado llaman o ejecutan diferentes funciones. Por ejemplo, <kbd>C-f</kbd> llama a <code>forward-char</code>, <kbd>M-e</kbd> llama a <code>forward-sentence</code>, etcétera.</p>
<p>Al escribir <code>switch-to-buffer</code> en una expresión, y darle un búfer al que cambiar, podemos cambiar de búfer tal y como hace <kbd>C-x b</kbd>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nf">other-buffer</span><span class="p">))</span>
</code></pre>
<p>El símbolo <code>switch-to-buffer</code> es el primer elemento de la lista, por lo que el intérprete Lisp lo tratará como una función y llevara a cabo las instrucciones adjuntas al mismo. Pero antes de hacer esto, el intérprete observara que <code>other-buffer</code> está dentro de paréntesis y trabajara en este símbolo primero. <code>other-buffer</code> es el primer (y en este caso, el único) elemento de esta lista, por lo que el intérprete llama o ejecuta la función. Esto devuelve un búfer distinto al actual. A continuación, el intérprete ejecuta <code>switch-to-buffer</code>, pasando, como argumento, el búfer devuelto, que es al que Emacs cambiara. Si estás leyendo esto en Emacs, prueba ahora. Evalúa la expresión. (Para regresar, presiona <kbd>C-x b RET</kbd>.)<span class="note" ><sup><a href="#7" >7</a></sup></span></p>
<p>En los ejemplos de las secciones siguentes, veras con más frecuencia la función <code>set-buffer</code> que <code>switch-to-buffer</code>. Esto se debe a la diferencia entre programas de ordenador y los humanos: los humanos tienen ojos y esperan ver el búfer en el que están trabajando en la terminal de su ordenador. Esto es tan evidente, que se sobreentiende. Sin embargo, los programas no tienen ojos. Cuando un programa de ordenador trabaja en un búfer, el búfer no necesita ser visible en la pantalla.</p>
<p><code>switch-to-buffer</code> está diseñado para los humanos y hace dos cosas diferentes: cambia el búfer a el que Emacs dirige la atención; y cambia el búfer mostrado en la ventana al nuevo búfer. <code>set-buffer</code>, por otro lado, solo hace una cosa: cambia la atención del programa del ordenador a un búfer diferente. El búfer en la pantalla permanece sin cambios (por supuesto, normalmente no pasa nada hasta que el comando termina de ejecutarse).</p>
<p>Además, acabamos introduciendo otro termino tecnico, la palabra <dfn>llamada</dfn>. Cuando se evalúa una lista en la que el primer símbolo es una función, se llama a esa función. El uso del término viene de la noción de la función como una entidad que puede algo hacer por ti cuando la ‘llamas’––al igual que un fontanero es una entidad que puede arreglar una fuga si lo llamas.</p>
</div>
<h3 id="tamaño-del-búfer-y-la-ubicación-del-punto" >Tamaño del búfer y la ubicación del punto</h3>
<div class="hBody-3" >
<p>Por último, vamos a ver varias funciones bastante sencillas, <code>buffer-size</code>, <code>point</code>, <code>point-min</code>, y <code>point-max</code>. Estas proporcionan información sobre el tamaño de un búfer y la ubicación del punto dentro de el.</p>
<p>La función <code>buffer-size</code> te dice el tamaño del búfer actual; es decir, la función devuelve un conteo del número de caracteres en el buffer.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">buffer-size</span><span class="p">)</span>
</code></pre>
<p>Puedes evaluar esto de la forma habitual, coloca el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>.</p>
<p>En Emacs, la posición actual del cursor se denomina <dfn>punto</dfn>. La expresión <code>(point)</code> devuelve un número que indica donde esta situado el cursor como un conteo del número de caracteres desde el principio del búfer hasta el punto.</p>
<p>Puedes ver el conteo de caracteres del punto para este búfer evaluando la siguiente expresión de la forma habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">point</span><span class="p">)</span>
</code></pre>
<p>Mientras escribo esto, el valor de <code>point</code> es 65724. La función <code>point</code> se utiliza con frecuencia en algunos de los ejemplos mas adelante en este libro.</p>
<p>El valor del punto depende, por supuesto, de su ubicacion dentro del búfer. Si evaluas el punto en este lugar, el número será mayor:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">point</span><span class="p">)</span>
</code></pre>
<p>Para mí, el valor del punto en esta posición es 66043, lo que significa que hay 319 caracteres (incluyendo espacios) entre las dos expresiones.  (Sin duda, verás números diferentes, ya que lo habré editado desde que evalue el punto por primera vez.)</p>
<p>La función <code>point-min</code> es similar a <code>point</code>, pero devuelve el valor mínimo permisible del punto en el búfer actual. Este es el numero 1 a menos que <dfn>narrowing</dfn> esté en efecto. (Narrowing (<em>Reduccion</em>) es un mecanismo mediante el cual puedes restringirte a ti mismo, o un programa, a operar solo en un parte de un búfer. Vea la Sección <a href="#reducir-y-extender" >Reducir y Extender</a>.)  Del mismo modo, la función <code>point-max</code> devuelve el valor máximo permisible del punto en el búfer actual.</p>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Busca un fichero en el que trabarjar y avanza hasta la mitad. Encuentra el nombre de búfer, el nombre del fichero, su tamaño, y la posición en el fichero.</p>
</div>
<h2 id="cómo-escribir-definiciones-de-funciones" >Cómo escribir definiciones de funciones</h2>
<div class="hBody-2" >
<p>Cuando el intérprete Lisp evalúa una lista, mira si el primer símbolo tiene una definición de funcion adjunta; o, dicho de otro modo, si el símbolo apunta a una definición de función. Si lo hace, el ordenador lleva a cabo las instrucciones que aparecen en la definición. Un símbolo que tiene una definición de función se llamada, simplemente, una función (aunque hablando con propiedad, la definición es la función y el símbolo se refiere a ella.)</p>
<p>Todas las funciones se defininen en términos de otras funciones, a excepción de algunas <dfn>primitivas</dfn> que estan escritas en el lenguaje de programación C. Cuando escribas definiciones de funciones, debes escribirlas en Emacs Lisp y utilizar otras funciones como bloques de construcción. Algunas de las funciones a utilizar estaran a su vez escritas en Emacs Lisp (quizás por tí) y otras serán primitivas escritas en C. Las funciones primitivas se usan exactamente igual que las escritas en Emacs Lisp y se comportan de igual forma. Están escritas en C para que podamos ejecutar facilmente GNU Emacs en cualquier ordenador que tenga la potencia suficiente y pueda ejecutar C.</p>
<p>Permíteme volver a enfatizar esto: cuando se escribe código en Emacs Lisp, no se distinge entre el uso de funciones escritas en C y el uso de funciones escritas en Emacs Lisp. La diferencia es irrevelante. Mencioné la distinción solo porque es interesante conocerla. De hecho, a menos de que investigues, no sabras si una función ya estrita esta en Emacs Lisp o en C.</p>
</div>
<h3 id="la-forma-especial-defun" >La forma especial <code>defun</code></h3>
<div class="hBody-3" >
<p>En Lisp, un símbolo como <code>mark-whole-buffer</code> tiene un código adjunto que le dice al ordenador que hacer cuando se invoca la función. Este código se denomina la <dfn>definición de función</dfn> y se crea evaluando una expresión Lisp que comienza con el símbolo <code>defun</code> (que es una abreviatura para <em>define function</em> (<em>definir función</em>)). Debido a que <code>defun</code> no evalúa sus argumentos en la manera habitual, se le llama una <dfn>forma especial</dfn>.</p>
<p>En las siguientes secciones, vamos a ver las definiciones de función partiendo del código fuente de Emacs, como <code>mark-whole-buffer</code>. En esta sección, describiremos una definición de función sencilla para que puedas ver su aspecto. Esta definición de función usa aritmética porque es un ejemplo simple. A algunas personas les disgustan los ejemplos que usan aritmética; sin embargo, si usted es tal persona, no se desespere. Casi ningun codigo a estudiar en el resto de esta introducción implica aritmética o matemáticas. Los ejemplos involucran principalmente texto en una forma u otra.</p>
<p>Una definición de función tiene un máximo de cinco partes despues de la palabra <code>defun</code>:</p>
<ol class="num" >
<li>
<p>El nombre del símbolo al que debe vincularse la definición de función.</p>
</li>
<li>
<p>Una lista de los argumentos que se pasan a la función. Si no hay argumentos que pasar a la función, tendremos una lista vacía, <code>()</code>.</p>
</li>
<li>
<p>Documentación que describe la función. (Técnicamente opcional, pero muy recomendable.)</p>
</li>
<li>
<p>Opcionalmente, una expresión para hacer que la función sea interactiva, de manera que puede utilizarla presionando <kbd>M-x</kbd> seguido del nombre de la función; o pulsando una tecla o atajo de teclado.</p>
</li>
<li>
<p>El código que indica a el ordenador qué hacer: el <dfn>cuerpo</dfn> de la definición de función.</p>
</li>
</ol>
<p>Es útil pensar que las cinco partes de una definición de función estan organizadas como en una plantilla, con ranuras para cada parte:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-función</span> <span class="p">(</span><span class="nv">argumentos</span><span class="err">…</span><span class="p">)</span>
  <span class="s">&#34;documentación-opcional…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="nv">argument-passing-info</span><span class="p">)</span>     <span class="c1">; opcional</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>A modo de ejemplo, aquí está el código de una función que multiplica su argumento por 7. (Este ejemplo no es interactivo. Vea la Sección <a href="#crear-una-función-interactiva" >Crear una Función Interactiva</a>, para obtener esa información.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Esta definición comienza con un paréntesis y el símbolo <code>defun</code> seguido por el nombre de la función.</p>
<p>El nombre de la función es seguido por una lista que contiene los argumentos que se pasaran a la función. Esta lista se llama <dfn>lista de argumentos</dfn>. En este ejemplo, la lista solo tiene un elemento, el símbolo <code>numero</code>. Cuando se utiliza la función, el símbolo sera asociado al valor que se utiliza como argumento de la función.</p>
<p>En lugar de elegir la palabra <code>numero</code> para el nombre del argumento, podría haber escogido cualquier otro nombre. Por ejemplo, la palabra <code>multiplicando</code>. Escogi la palabra ‘numero’ porque indica qué tipo de valor se pretende para este espacio; pero podría haber elegido ‘multiplicando’ para indicar el papel que jugara el valor en el funcionamiento de la función. Podría haberlo llamado <code>foogle</code>, pero habría sido una mala elección, ya que no comunicaria a los humanos qué significa. La elección del nombre es responsabilidad del programador y debe elegirse para hacer que el significado de la función quede claro.</p>
<p>De hecho, puedes elegir cualquier nombre que desees para un símbolo en una lista de argumentos, incluso el nombre de un símbolo utilizado en alguna otra función: el nombre que utilices en una lista de argumentos es privado para esta definición particular. En esta definición, el nombre hace referenecia a una entidad diferente a cualquiera que utilice el mismo nombre fuera de la definición de función. Supón que tu familia te apoda ‘Enano’; cuando tus familiares digan ‘Enano’, queren hacer referencia a ti. Pero fuera de tu familia, en una película, por ejemplo, el nombre ‘Enano’ se refiere a alguien más. Debido a que el nombre en una lista de argumentos es privado para la definición de la función, se puede cambiar el valor de un símbolo dentro del cuerpo de una función sin cambiar su valor fuera de la función. El efecto es similar al producido por la expresión <code>let</code>. (Vea la sección <a href="#let" ><code>let</code></a>.)</p>
<p>La lista de argumentos es seguida por la cadena de documentación que describe la función. Esto es lo ves cuando presionas <kbd>C-h f</kbd> y escribes el nombre de una función. Por cierto, cuando escribas una cadena de documentación como esta, debes confeccionar la primera linea como una frace completa ya que algunos comandos, como <code>apropos</code>, solo imprimen la primera línea de una cadena de documentación de varias líneas. Ademas, no debes indentar la segunda línea de la cadena de documentación, si tienes una, porque se ve extraño al utilizar <kbd>C-h f</kbd> (<code>describe-function</code>). La cadena de documentación es opcional, pero es tan útil, que debería incluirse en casi cualquier función que escribas.</p>
<p>La tercera línea del ejemplo consiste en el cuerpo de la definición de función. (La mayoría de las definiciones de funcion, claro esta, son más extensas que esta.) En esta función, el cuerpo es la lista, <code>(* 7 numero)</code>, que indica multiplicar el valor de <code>numero</code> por 7. (En Emacs Lisp, <code>*</code> es la función para la multiplicación, al igual que <code>+</code> es la función de suma.</p>
<p>Cuando se utiliza la función <code>multiplicar-por-siete</code>, el argumento <code>numero</code> se evalúa al número que desees usar. He aquí un ejemplo que muestra como utilizar <code>multiplicar-por-siete</code>; pero ¡no intentes evaluar esto primero!.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">multiplicar-por-siete</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>El símbolo <code>numero</code>, especificado en la definición de función en la siguiente sección, se da o “une a” el valor 3 en el actual uso de la función. Note que aunque <code>numero</code> estaba dentro de paréntesis en la definición de función, el argumento pasado a la función <code>multiplicar-por-siete</code> no está entre paréntesis. Los paréntesis se escriben en la definición de función para que el ordenador pueda averiguar donde termina la lista de argumentos e inicia el resto de la definición de función.</p>
<p>Si evalúas este ejemplo, es probable que obtengas un mensaje de error. (¡adelante, intentalo!) Esto se debe a que hemos escrito la definición de función, pero aún no se ha comunicado al ordenador sobre la definición––no hemos instalado (o ‘cargado’) la definición de función en Emacs. Instalar una función es el proceso de comunicar al intérprete Lisp la definición de la función. La instalación se describe en la siguiente sección.</p>
</div>
<h3 id="instalar-una-definición-de-función" >Instalar una definición de función</h3>
<div class="hBody-3" >
<p>Si estás leyendo esto dentro en Emacs, puedes probar la función <code>multiplicar-por-siete</code> evaluando en primer lugar la definición de función y luego evaluando <code>(multiplicar-por-siete 3)</code>. Hay una copia de la definición a continuación. Coloca el cursor después del último paréntesis de la definición de función y presiona <kbd>C-x C-e</kbd>. Al hacer esto, <code>multiplicar-por-siete</code> aparecerá en el área de eco. (Esto significa que cuando una se evalua una definición de función, el valor devuelto es el nombre de la función definida.) Al mismo tiempo, esta acción instala la definición de función.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Al evaluar este <code>defun</code>, estas instanlado <code>multiplicar-por-siete</code> en Emacs. La función ahora es una parte de Emacs tanto como <code>forward-word</code> o cualquier otra función de edición que utilices. (<code>multiplicar-por-siete</code> permanecera instalado hasta que salgas de Emacs. Para volver a cargar el código automáticamente cada vez que Emacs inicie, revisa la sección <a href="#instalar-código-permanentemente" >Instalar Código Permanentemente</a>.)</p>
<p>Puedes ver el efecto de instalar <code>multiplicar-por-siete</code> evaluando el siguiente ejemplo. Coloca el cursor después de la siguiente expresión y presiona <kbd>C-x C-e</kbd>. Aparacerá el número 21 en el área de eco.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">multiplicar-por-siete</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>Si lo deseas, puedes leer la documentación de la función presiona <kbd>C-h f</kbd> (<code>describe-function</code>) y luego escribe el nombre de la función, <code>multiplicar-por-siete</code>. Al hacer esto, una ventana <span class="file" >*Help*</span> aparecerá en tu pantalla diciendo:</p>
<div class="example-block" >
<pre class="example" >multiplicar-por-siete is a Lisp function.
(multiplicar-por-siete NUMERO)

Multiplica NUMERO por siete.
</pre>
</div>
<p>(Para volver a una unica ventana en la pantalla, presiona <kbd>C-x 1</kbd>.)</p>
</div>
<h4 id="cambiar-una-definición-de-función" >Cambiar una definición de función</h4>
<div class="hBody-4" >
<p>Si deseas modificar el código de <code>multiplicar-por-siete</code>, simplemente vuelve a escribirlo. Para instalar la nueva versión en lugar de la anterior, evalúa nuevamente la definición de la función. Esta, es la forma de modificar el código en Emacs. Es muy simple,</p>
<p>A modo de ejemplo, puedes cambiar la función <code>multiplicar-por-siete</code> para sumar el número a sí mismo siete veces en lugar de multiplicar el número por siete. Esto produce el mismo resultado, pero por una ruta diferente. Al mismo tiempo, añadiremos un comentario al codigo; un comentario es texto que el intérprete Lisp ignora, pero un lector humano puede encontrar útil o esclarecedor. El comentario es, que esta es la “segunda versión”.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Segunda versión.</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nf">+</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>El comentario sigue a un punto y coma, <samp>;</samp>. En Lisp cualquier cosa en una línea despues de un punto y coma es un comentario. El fin de la línea es el fin del comentario. Para extender un comentario por dos o más líneas, inicia cada línea con un punto y coma.</p>
<p>Vé las Secciónes <a href="#empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></a> y <a href="info:emacs#Comments" >Comentarios</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más informacion sobre los comentarios.</p>
<p>Puedes instalar esta versión de <code>multiplicar-por-siete</code> evaluándo esta del misma modo en que evaluaste la primer función: coloca el cursor después del último paréntesis y presiona <kbd>C-x C-e</kbd>.</p>
<p>En resumen, asi es como puedes escribir código en Emacs Lisp: escribes una función; la instalas; la pruebas; luego haces correcciones o mejoras y la vuelves a instalar.</p>
</div>
<h3 id="crear-una-función-interactiva" >Crear una función interactiva</h3>
<div class="hBody-3" >
<p>Puedes hacer a una función interactiva colocando una lista que inicia con la forma especial <code>interactive</code> inmediatamente después de la documentación. Un usuario puede invocar una función interactiva con <kbd>M-x</kbd> seguido del nombre de la función; o con un atajo de teclado ligado a esta, por ejemplo, presionando <kbd>C-n</kbd> para <code>next-line</code> o <kbd>C-x h</kbd> para <code>mark-whole-buffer</code>.</p>
<p>Cusionamente, cuando llamas a una función interactiva interactivamente, el valor devuelto no se muestra automáticamente en el área de eco. Esto se debe a que a menudo se llama a una función interactiva por sus efectos secundarios, como avanzar hacia adelante una palabra o una línea, y no por el valor devuelto. Si el valor devuelto se mostrara en el área de eco cada vez que presionas una tecla, seria muy molesto.</p>
<p>Tanto el uso de la forma especial <code>interactive</code> y la forma de mostrar un valor en el área de eco pueden ilustrarse creando una versión interactiva de <code>multiplicar-por-siete</code>.</p>
<p>Aquí está el código:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Versión Interactiva.</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">)))</span>
</code></pre>
<p>Para instalar este código coloca el cursor después del ultimo parentesis y presiona <kbd>C-x C-e</kbd>. El nombre de la función aparecerá en el área de eco. Despues, puedes utilizar este código al presionar <kbd>C-u</kbd> segudo de un número, luego <kbd>M-x multiplicar-por-siete</kbd> y finalmente <kbd>RET</kbd>. La frase <samp>El resultado es …</samp> seguida por el producto, aparecerá en el área de eco.</p>
<p>Hablando en terminos mas generales, puedes invocar una función como ésta de dos maneras:</p>
<ol class="num" >
<li>
<p>Al escribir un argumento prefijo que contiene el número a pasar, y a continuación presionar <kbd>M-x</kbd> y escribir el nombre de la función, como ocurre con <kbd>C-u 3 M-x forward-sentence</kbd>; o,</p>
</li>
<li>
<p>Escribir cualquier tecla o atajo de teclado ligado a la función, como ocurre con <kbd>C-u 3 M-e</kbd>.</p>
</li>
</ol>
<p>Ambos ejemplos operan de forma identica moviendo el punto hacia adelante tres oraciones. (Ya que <code>multiply-by-seven</code> no esta ligado a un atajo, no se puede utilizar como ejemplo.)</p>
<p>(Vea la Seccion <a href="#atajos-de-teclado" >Atajos de teclado</a>, para aprender como vincular un comando a una atajo.)</p>
<p>Un argumento prefijo se pasa a una función interactiva pulsando la tecla <kbd>META</kbd> seguida de un número, por ejemplo, <kbd>M-3 M-e</kbd>, o con <kbd>C-u</kbd> y luego un número, por ejemplo, <kbd>C-u 3 M-e</kbd> (si presionas <kbd>C-u</kbd> sin ningun número, el valor por defecto es 4).</p>
</div>
<h4 id="multiplicar-por-siete-interactivo" ><code>multiplicar-por-siete</code> interactivo</h4>
<div class="hBody-4" >
<p>Veamos es uso de la forma especial <code>interactive</code> y luego la función <code>message</code> en la versión interactiva de <code>multiplicar-por-siete</code>. Recordaras que la definición de función tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiplicar-por-siete</span> <span class="p">(</span><span class="nv">numero</span><span class="p">)</span>       <span class="c1">; Versión Interactiva.</span>
  <span class="s">&#34;Multiplica NUMERO por siete.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">)))</span>
</code></pre>
<p>En esta función, la expresión, <code>(interactive &#34;p&#34;)</code>, es una lista de dos elementos. La <code>&#34;p&#34;</code> le indica a Emacs que debe pasar el argumento prefijo a la función y utilizar este valor para el argumento de la función.</p>
<p>El argumento debe ser un número. Esto significa que el símbolo <code>numero</code> estara asociado a un número en la línea:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">numero</span><span class="p">))</span>
</code></pre>
<p>Por ejemplo, si tu argumento prefijo es 5, el intérprete Lisp evaluará la línea como si fuera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;El resultado es %d&#34;</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>(Si estás leyendo esto en GNU Emacs, puedes evaluar esta expresión por ti mismo.) Primero, el intérprete evaluará la lista interna, que es <code>(* 7 5)</code>. Esto devuelve un valor de 35. A continuación, se evaluará la lista externa, pasando los valores del segundo y posteriores elementos de la lista a la función <code>message</code>.</p>
<p>Como hemos visto, <code>message</code> es una función Emacs Lisp especialmente diseñada para enviar un mensaje de una línea al usuario. (Vea la Seccion <a href="#la-función-message" >La función <code>message</code></a>.) En resumen, la función <code>message</code> imprime su primer argumento en el área de eco tal cual, excepto para las apariciones de <samp>%d</samp>, o <samp>%s</samp> (y varias otras secuencias de control que no hemos mencionado). Cuando aparece una secuencia de control, la función busca el segundo o posteriores argumentos e imprime el valor del argumento en la ubicación donde se encuartra la secuencia de control.</p>
<p>En la función interactiva <code>multiplicar-por-siete</code>, la cadena de control es <samp>%d</samp>, que requiere un número, y el valor devuelto por la evaluación de <code>(* 7 5)</code> es el número 35. Por consiguiente, el número 35 se imprime en lugar de <samp>%d</samp> y el mensaje es <samp>El resultado es 35</samp>.</p>
<p>(Observa que cuando llamas a la función <code>multiplicar-por-siete</code>, el mensaje se imprime sin comillas, pero cuando llamas a <code>message</code>, el texto se imprime entre comillas. Esto se debe a que el valor devuelto por <code>message</code> aparece en el área de eco cuando evalúas una expresión cuyo primer elemento es <code>message</code>; pero si se integra en una función, <code>message</code> imprime el texto como un efecto secundario sin comillas.)</p>
</div>
<h3 id="diferentes-opciones-para-interactive" >Diferentes opciones para <code>interactive</code></h3>
<div class="hBody-3" >
<p>En el ejemplo, <code>multiplicar-por-siete</code> utilizo <code>&#34;p&#34;</code> como el argumento para <code>interactive</code>. Este argumento indica a Emacs que interprete cualquer cosa que escriba despues de <kbd>C-u</kbd> o del comando <kbd>META</kbd> como un numero que sera el argumento a pasar a la funcion. Emacs tiene más de veinte caracteres predefinidos para usar con <code>interactive</code>. En casi todos los casos, una de estas opciones te permitira pasar la información correcta de forma interactiva a una función. (Vea la Seccion <a href="info:elisp#Interactive" >Codigo de Caracteres para <code>interactive</code></a> en <em>El Manual de Referencia GNU Emacs Lisp</em>).</p>
<p>Considera la función <code>zap-to-char</code>. Su expresión interactiva es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
</code></pre>
<p>La primer parte del argumento de <code>interactive</code> es <samp>p</samp>, con el que ya estás familiarizado. Este argumento le indica a Emacs intepretar un ‘prefijo’, como un número que se pasa a la función. Puedes especificar un prefijo presionando <kbd>C-u</kbd> seguido de un número o igualmente con <kbd>META</kbd> seguido por un número. El prefijo es un número de caracteres especifico. De este modo, si el prefijo es tres y el caracter especificado es <samp>x</samp>, entonces se borrará todo el texto hasta e incluido el tercer <samp>x</samp> siguiente. Si no se establece un prefijo, entonces borras todo el texto hasta e incluido el carácter establecido, pero no más.</p>
<p>La <samp>c</samp> indica a la función el nombre del carácter que va a eliminar.</p>
<p>Más formalmente, una función con dos o más argumentos puede tener información que pasa a cada argumento añadiendo partes en la cadena que a continuacion de <code>interactive</code>. Al hacer esto, la información se pasa a cada argumento en el mismo orden que se especifica en la lista <code>interactive</code>. En la cadena, cada parte está separada de la siguente parte por un <samp>\n</samp>, que significa nueva línea. Por ejemplo, a <samp>p</samp> puede continuar un <samp>\n</samp> y un <samp>cZap to char: </samp>. Esto hace que Emacs pase el valor del argumento prefijo (si lo hay) y el carácter.</p>
<p>En este caso, la definición de función se parece a la siguiente, donde <code>arg</code> y <code>char</code> son los símbolos que <code>interactive</code> vincula el argumento prefijo y el caracter especificado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">arg</span> <span class="nv">char</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
  <span class="nv">cuerpo-de-funcion</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>(El espacio después de los dos puntos en el prompt hace que se vea mejor. Vea la Seccion <a href="#la-definición-de-copy-to-buffer" >La Definición de <code>copy-to-buffer</code></a>, para un ejemplo.)</p>
<p>Cuando una función no toma argumentos, <code>interactive</code> no requiere ninguno. Una función asi contiene unicamente la expresión <code>(interactive)</code>. La función <code>mark-whole-buffer</code> es asi.</p>
<p>Alternativamente, si los códigos especiales de letras no son adecuados para su aplicación, puedes pasar tus propios propios argumentos a <code>interactive</code> como una lista.</p>
<p>Vea la Seccion <a href="#la-definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>, para un ejemplo. Vea la Sección <a href="info:elisp#Using-Interactive" >Usando <code>interactive</code></a> en <em>El Manual de GNU Emacs Lisp</em>, para una explicación más completa sobre esta técnica.</p>
</div>
<h3 id="instalar-código-permanentemente" >Instalar Código Permanentemente</h3>
<div class="hBody-3" >
<p>Cuando instalas una definición de función evaluandola, permanecera instalada hasta que salgas de Emacs. La proxima vez que inicies una nueva sesión de Emacs, la función no sera instalada a menos que evalúes la definición de nuevo.</p>
<p>En algún momento, podrias necesitar que el código se instale automáticamente cada vez que inicies una nueva sesión de Emacs. Hay varias formas de hacer esto:</p>
<ul>
<li>
<p>Si tienes código solo para tu uso, puedes poner el código de la definición de función en el fichero de inicialización <span class="file" >.emacs</span>. Cuando se inicia Emacs, el fichero <span class="file" >.emacs</span> se evalúa automática y se instalan todas sus definiciones de función. Vér la Sección <a href="#tu-fichero-.emacs" >Tu Fichero <span class="file" >.emacs</span></a>.</p>
</li>
<li>
<p>Como Alternativa, puedes poner las definiciones de función en uno o más ficheros y usar la función <code>load</code> para hacer que Emacs evalue y con ello instale cada una de las funciones en los ficheros. Vea la Seccion <a href="#cargando-ficheros" >Cargando ficheros</a>.</p>
</li>
<li>
<p>En Tercer lugar, si tienes código que todo tu sitio va a utilizar, es normal ponerlo en un fichero llamado <span class="file" >site-init.el</span> que se carga cuando se construye Emacs. Esto hace que el código este disponible para todos los usuarios de tu máquina. (Mira el fichero <span class="file" >INSTALL</span> que forma parte de la distribución Emacs.)</p>
</li>
</ul>
<p>Finalmente, si tienes código que cualquier usuario de Emacs pueda querer, puedes publicarlo en una red de informatica o enviar una copia a la Free Software Foundation. (Al hacer esto, por favor licencia el código y su documentación bajo una licencia que permita a otras personas ejecutar, copiar, estudiar, modificar, y redistribuir el código y te protege de quien tome tu trabajo.) Si envias una copia de tu código a la Free Software Foundation, y lo proteges apropiadamente de ti mismo y otros, puede ser incluido en la siguiente version de Emacs. En gran parte, esta es la forma como ha crecido Emacs a través de los años, a traves de donaciones.</p>
</div>
<h3 id="let" ><code>let</code></h3>
<div class="hBody-3" >
<p>La expresión <code>let</code> es una forma especial en Lisp que tendras que utilizar en la mayoría de las definiciones de función.</p>
<p><code>let</code> se utiliza para unir o enlazar un símbolo a un valor de tal manera que el intérprete no confunda la variable con otra variable del mismo nombre que no forme parte de la función.</p>
<p>Para entender por qué la forma especial <code>let</code> es necesaria, considera la situación donde eres dueño de una casa que generalmente vinculas con ‘la casa’, como en la frase, “La casa necesita pintura”. Si visitas a un amigo y tu anfitrion hace referencia a ‘la casa’, es probable que se refiera a <em>su</em> casa, no a la tuya, es decir, a una casa diferente.</p>
<p>Si tu amigo se refiere a su casa y tu crees que el se esta refiriendo a tu casa, puedes tener cierta confusión. Lo mismo podría suceder en Lisp si una variable que se usa dentro de una función tiene el mismo nombre que una variable usada dentro de otra función, y las dos no tienen la intencion de referirse al mismo valor. La forma especial <code>let</code> permite evitar este tipo de confusión.</p>
<p>La forma especial <code>let</code> evita confusiones. <code>let</code> crea un nombre para una <dfn>variable local</dfn> que eclipsa cualquier uso del mismo nombre fuera de la expresión <code>let</code>. Esto es como entender que cuando tu anfitrion se refiera a ‘la casa’, el quiere decir su casa, no la tuya. (Los símbolos usados en las listas de argumentos funcionan de la misma manera. Véa la Sección <a href="#la-forma-especial-defun" >La Forma Especial <code>defun</code></a>.)</p>
<p>Las variable locales creadas por una expresión <code>let</code> retienen su valor <em>solo</em> dentro de la expresión <code>let</code> (y dentro de expresiones llamadas dentro de la expresión <code>let</code>); las variables locales no tiene efecto fuera de la expresión <code>let</code>.</p>
<p>Otra forma de persar sobre <code>let</code> es que es como un <code>setq</code> que es temporal y local. Los valores establecidos por <code>let</code> se deshacen automáticamente cuando <code>let</code> finaliza. La configuración solo afecta a las expresiones que se encuentran dentro de los limites de la expresión <code>let</code>. En jerga informatica, diríamos que “la union de un simbolo es visible solo en las funciones llamadas en la forma <code>let</code>; en Emacs Lisp, el alcance es dinámico, no léxico.”</p>
<p><code>let</code> puede crear más de una variable a la vez. Ademas, <code>let</code> da a cada variable que crea un valor inicial, ya sea un valor especificado por tí, o <code>nil</code>. (En la jerga, eso se llama ‘enlazar la variable al valor’.)  Después de que <code>let</code> ha creado y enlazado las variables, ejecuta el código en el cuerpo del <code>let</code> y devuelve el valor de la última expresión en el cuerpo, como el valor de toda la expresión <code>let</code>. (‘Ejecutar’ es un término tecnico que significa evaluar una lista; proviene del significando de la palabra ‘llevar a la practica’ (<em>Oxford English Dictionary</em>). Ya que evalúas una expresión para realizar una acción, ‘ejecutar’ ha evolucionado como un sinónimo para ‘evaluar’.)</p>
</div>
<h4 id="partes-de-una-expresión-let" >Partes de una expresión <code>let</code></h4>
<div class="hBody-4" >
<p>Una expresión <code>let</code> es una lista de tres partes. La primer parte es el símbolo <code>let</code>. La segunda parte es una lista, llamada <dfn>varlist</dfn> (lista de variables), cada uno de cuyos elementos es un símbolo por sí mismo o una lista de dos elementos, cuyo primer elemento es un símbolo. La tercera parte de la expresión <code>let</code> es el cuerpo de <code>let</code>. El cuerpo normalmente consiste de una o más listas.</p>
<p>Una plantilla para una expresión <code>let</code> tiene el siguente aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="nv">varlist</span> <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Los símbolos de la lista de varibles (<code>varlist</code>) son las variables a las que la forma especial <code>let</code> da valores de inicio. Los símbolos por si solos reciven el valor de inicio <code>nil</code>; y cada símbolo que sea el primer elemento de una lista de dos elementos se vincula al valor que se devuelve cuando el interprete Lisp evalúa el segundo elemento.</p>
<p>Por lo tanto, una varlist podria verse asi: <code>(thread (needles 3))</code>. En este caso, en una expresión <code>let</code>, Emacs une el símbolo <code>thread</code> a un valor inicial de <code>nil</code>, y une el símbolo <code>needles</code> a un valor inicial de 3.</p>
<p>Cuando escribes una expresión <code>let</code>, lo que haces es poner las expresiones apropiadas en los espacios de la plantilla de expresión <code>let</code>.</p>
<p>Si la varlist está compuesta de listas de 2 elementos, como suele ser el caso, la plantilla de la expresión <code>let</code> es la sigiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">)</span>
      <span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="ejemplo-de-expresión-let" >Ejemplo de Expresión <code>let</code></h4>
<div class="hBody-4" >
<p>La siguiente expresión crea y da valores los iniciales a las dos variables <code>cebra</code> y <code>tigre</code>. El cuerpo de la expresión <code>let</code> es una lista que llama a la función <code>message</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">cebra</span> <span class="ss">&#39;rayas</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">tigre</span> <span class="ss">&#39;fiero</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Un tipo de animal tiene %s y otro es %s.&#34;</span>
           <span class="nv">cebra</span> <span class="nv">tigre</span><span class="p">))</span>
</code></pre>
<p>Aquí, la varlist es <code>((cebra &#39;rayas) (tigre &#39;fiero))</code>.</p>
<p>Las dos variables son <code>cebra</code> y <code>tigre</code>. Cada variable es el primer elemento de una lista de dos elementos y cada valor es el segundo elemento de su lista de dos elementos. En la varlist, Emacs une la variable <code>cebra</code> al valor <code>rayas</code><span class="note" ><sup><a href="#8" >8</a></sup></span>, y la variable <code>tigre</code> al valor <code>fiero</code>. En este ejemplo, ambos valores son símbolos precedidos por una cita. Los valores podrían muy bien haber sido otra lista o una cadena. El cuerpo de <code>let</code> sigue después de la lista que contiene las variables. En este ejemplo, el cuerpo es una lista que usa la función <code>message</code> para imprimir una cadena en el área de eco.</p>
<p>Puedes evaluar el ejemplo de la forma habitual, coloca el cursor después del último paréntesis y presiona <kbd>C-x C-e</kbd>. Al hacer esto, aparecerá lo siguiente en el área de eco:</p>
<pre class="code" ><code class="chroma" ><span class="s">&#34;Un tipo de animal tiene rayas y otro es fiero.&#34;</span>
</code></pre>
<p>Como hemos visto anteriormente, la función <code>message</code> imprime su primer argumento, excepto <samp>%s</samp>. En este ejemplo, el valor de la variable <code>cebra</code> se imprime en la ubicacion del primer <samp>%s</samp> y el valor de la variable <code>tigre</code> se imprime en la ubicacion del segundo <samp>%s</samp>.</p>
</div>
<h4 id="variables-sin-inicializar-en-un-sentencia-let" >Variables sin inicializar en un sentencia <code>let</code></h4>
<div class="hBody-4" >
<p>Si no se unen las variables en una sentencia <code>let</code> con valores de inicio específicos, automáticamente seran unidos a un valor de inicio <code>nil</code>, como en la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">abedul</span> <span class="mi">3</span><span class="p">)</span>
      <span class="nv">pino</span>
      <span class="nv">abeto</span>
      <span class="p">(</span><span class="nv">roble</span> <span class="ss">&#39;algunos</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&#34;Aquí están %d variables con %s, %s, y el valor %s.&#34;</span>
   <span class="nv">abedul</span> <span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span><span class="p">))</span>
</code></pre>
<p>Aquí, la varlist es <code>((abedul 3) pino abeto (roble &#39;algunos))</code>.</p>
<p>Si evalúas esta expresión de la forma habitual, aparecerá lo siguiente en el área de eco:</p>
<div class="example-block" >
<pre class="example" >&#34;Aquí están 3 variables con nil, nil, y el valor algunos.&#34;
</pre>
</div>
<p>En este ejemplo, Emacs une el símbolo <code>abedul</code> al número 3, une los símbolos <code>pino</code> y <code>abeto</code> a <code>nil</code>, y el símbolo <code>roble</code> al valor <code>algunos</code>.</p>
<p>Observe que en la primera parte de <code>let</code>, las variables <code>pino</code> y <code>abeto</code> son unicamente átomos que no están rodeados por paréntesis; esto es porque estan siendo unidos a <code>nil</code>, la lista vacía. Pero <code>roble</code> su une a <code>algunos</code> por que es parte de la lista <code>(roble &#39;algunos)</code>. De manera similar, <code>abedul</code> se une al número 3 en una lista con este número. (Ya que un número se evalúa a sí mismo, el número no necesita ser citado. Ademas, el número se imprime en el mensaje utilizando un <samp>%d</samp> en lugar de un <samp>%s</samp>.) Las cuatro variables como grupo son puestas dentro de una lista para delimitarla del cuerpo de <code>let</code>.</p>
</div>
<h3 id="la-forma-especial-if" >La forma especial <code>if</code></h3>
<div class="hBody-3" >
<p>Además de <code>let</code> y <code>defun</code>, esta la forma especial condicional <code>if</code>. Esta forma se utiliza para indicar al ordenador que tome decisiones. Puedes escribir definiciones de función sin necesidad de utilizar <code>if</code>, pero se usa con bastante frecuencia, y es lo suficientemente importante como para incluirse aquí. Se utiliza, por ejemplo, en el código de la función <code>beginning-of-buffer</code>.</p>
<p>La idea básica detras de <code>if</code>, es que “<em>si</em> (<em>if</em>) una prueba es verdadera <em>entonces</em> se evalua la expresión”. Si la prueba no es verdadera, la expresión no se evalua. Por ejemplo, podría tomar una decisión como, “si hace sol y calor, ve a la playa!”</p>
<p>Al escribir una expresión <code>if</code> en Lisp no se utiliza la palabra ‘then’; la prueba y la acción son los elementos segundo y tercero de la lista cuyo primer elemento es <code>if</code>. No obstante, la parte de la prueba en una expresión <code>if</code> a menudo se llamada <dfn>parte-si</dfn> (if-part) y el segundo argumento a menudo se llamada <dfn>parte-entonces</dfn> (then-part).</p>
<p>Ademas, cuando se escribe una expresión <code>if</code>, la prueba-verdadero-o-falso normalmente se escribe en la misma línea que el símbolo <code>if</code>, pero la acción a llevar a cabo si la prueba es verdadera, “parte-entonces”, se escribe en la segunda y suguientes líneas. Esto hace que la expresión <code>if</code> sea mas fácil de leer.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-el-test-es-cierto</span><span class="p">)</span>
</code></pre>
<p>La prueba-verdadero-o-falso es una expresión que evalua el intérprete Lisp.</p>
<p>Aquí hay un ejemplo que puedes evaluar. La prueba consiste en si el número 5 es mayor que el número 4. Ya que es asi, se imprime el mensaje <samp>¡5 es mayor que 4!</samp>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>                           <span class="c1">; parte-si</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡5 es mayor que 4!&#34;</span><span class="p">))</span>   <span class="c1">; parte-entonces</span>
</code></pre>
<p>(La función <code>&gt;</code> comprueba si su primer argumento es mayor que su segundo argumento y devuelve verdadero si lo es.)</p>
<p>Por supuesto, en un caso real, la prueba en una expresión <code>if</code> no será siempre la misma, como en la expresión <code>(&gt; 5 4)</code>. En su lugar, al menos una de las variables utilizadas en la prueba estara unida a un valor de antemano desconocido. (Si el valor se conociera de antemano, ¡no necesitariamos realizar la prueba!)</p>
<p>Por ejemplo, el valor puede estar unido a un argumento de una definición de función. En la siguiente definición de función, el tipo de animal es un valor que se pasa a la función. Si el valor unido a <code>caracteristica</code> es <code>fiero</code>, entonces se imprime el mensaje, <samp>¡Es un tigre!</samp>; de otro modo, se devolvera <code>nil</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&#34;Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
</span><span class="s">Si la CARACTERISTICA es el símbolo ‘fiero’,
</span><span class="s">entonces advierte que es un tigre.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Es un tigre!&#34;</span><span class="p">)))</span>
</code></pre>
<p>Si estás leyendo esto dentro de GNU Emacs, puedes evaluar la definición de función de la forma habitual para instalarlo en Emacs, y luego puedes evaluar las dos expresiones siguientes para ver los resultados:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;fiero</span><span class="p">)</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;cebra</span><span class="p">)</span>
</code></pre>
<p>Al evaluar <code>(tipo-de-animal &#39;fiero)</code>, veras el siguiente mensaje impreso en el área eco: <code>&#34;¡Es un tigre!&#34;</code>; y cuando se evalúa <code>(tipo-de-animal &#39;cebra)</code> verás <code>nil</code> impreso en el área de eco.</p>
</div>
<h4 id="la-función-tipo-de-animal-en-detalle" >La función <code>tipo-de-animal</code> en detalle</h4>
<div class="hBody-4" >
<p>Veamos la función <code>tipo-de-animal</code> en detalle.</p>
<p>La definición de función <code>tipo-de-animal</code> se escribio llenando los espacios de dos plantillas, la primera para la definición de función como un todo, y la segunda para una expresión <code>if</code>.</p>
<p>La plantilla para cada función no interactiva es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Las partes de la función que coinciden con esta plantilla tienen este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&#34;Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
</span><span class="s">     Si la CARACTERISTICA es el símbolo ‘fiero’,
</span><span class="s">     entonces advierte que es un tigre.&#34;</span>
  <span class="nv">cuerpo:</span> <span class="nv">la</span> <span class="nv">expresion</span> <span class="nb">if</span><span class="p">)</span>
</code></pre>
<p>El nombre de función es <code>tipo-de-animal</code>; se pasa al valor de un argumento. A la lista de argumentos le sigue una cadena de documentación multilínea. La cadena de documentación se incluiye en el ejemplo porque es un buen hábito escribir un cadena de documentación para cada definición de función. El cuerpo de la definición de función consiste en la expresión <code>if</code>.</p>
<p>La plantilla para una expresión <code>if</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-la-prueba-devuelve-verdadero</span><span class="p">)</span>
</code></pre>
<p>En la función <code>tipo-de-animal</code>, el código para <code>if</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Es un tigre!&#34;</span><span class="p">)))</span>
</code></pre>
<p>Aquí, está la expresión prueba-verdadero-o-falso</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
</code></pre>
<p>En Lisp, <code>equal</code> es una función que determina si su primer argumento es igual al segundo. El segundo argumento es el símbolo citado <code>&#39;fiero</code> y el primer argumento es el valor del símbolo <code>característica</code>––en otras palabras, el argumento pasado a esta función.</p>
<p>En la primer prueba de <code>tipo-de-animal</code>, el argumento <code>fiero</code> se pasa a <code>tipo-de-animal</code>. Ya que <code>fiero</code> es igual a <code>fiero</code>, la expresión, <code>(equal caracteristica &#39;fiero)</code>, devuelve el valor verdadero. Cuando esto sucede, <code>if</code> evalúa el segundo argumento o la parte-entonces del <code>if</code>: <code>(message &#34;¡Es un tigre!&#34;)</code>.</p>
<p>Por otro lado, en la segunda prueba de <code>tipo-de-animal</code>, se pasa el argumento <code>cebra</code> a <code>tipo-de-animal</code>. <code>cebra</code> no es igual a <code>fiero</code>, por lo que la parte-entonces no se evalua y la expresión <code>if</code> devuelve <code>nil</code>).</p>
</div>
<h3 id="expresiones-if–then–else" >Expresiones if–then–else</h3>
<div class="hBody-3" >
<p>Una expresión <code>if</code> puede tener un tercer argumento opcional, llamado <dfn>else-part</dfn> (parte-de-otro-modo), en caso de que la prueba-verdadero-o-falso devuelva falso. Cuando esto sucede, el segundo argumento o parte-entonces de la expresión <code>if</code> global <em>no</em> se evalúa, pero el tercer argumento o parte-de-otro-modo <em>se</em> evalúa. Podría pensar en esto como la alternativa del día nublado para la decisión “si es cálido y soleado, entonces ir a la playa!, de otro modo leer un libro!”</p>
<p>La palabra “else” (de otro modo) no se escribe en el código Lisp; la parte-de-otro-modo de una expresión <code>if</code> viene después de la parte-entonces. En Lisp, la parte-de-otro-modo suele escribirse al inicio de una nueva linea y se indenta menos que la parte-entonces:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">prueba-verdadero-o-falso</span>
    <span class="nv">accion-a-realizar-si-la-prueba-devuelve-verdadero</span>
  <span class="nv">accion-a-realizar-si-la-prueba-devuelve-falso</span><span class="p">)</span>
</code></pre>
<p>Por ejemplo, la siguiente expresión <code>if</code> imprime el mensaje <samp>¡4 no es mayor que 5!</samp> al evaluarse en la forma habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>                                   <span class="c1">; parte-if</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡4 falsamente es mayor que 5!&#34;</span><span class="p">)</span> <span class="c1">; parte-then</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡4 no es mayor que 5!&#34;</span><span class="p">))</span>          <span class="c1">; parte-else</span>
</code></pre>
<p>Tenga en cuenta que los diferentes niveles de indentación hacen fácil distinguir la parte-entonces de la parte-de-otro-modo. (GNU Emacs tiene varios comandos que indentan expresiones <code>if</code> automáticamente. Vea la Seccion <a href="#gnu-emacs-te-ayuda-a-escribir-listas" >GNU Emacs te ayuda a escribir listas</a>.)</p>
<p>Podemos ampliar la función <code>tipo-de-animal</code> para incluir una parte-else simplemente incorporando una parte adicional para la expresión <code>if</code>.</p>
<p>Puedes ver las consecuencias de hacer esto si evalúas la siguiente versión de la definición de función <code>tipo-de-animal</code> y luego evaluas las dos expresiones siguientes que pasan diferentes argumentos a la función.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">tipo-de-animal</span> <span class="p">(</span><span class="nv">caracteristica</span><span class="p">)</span>
  <span class="s">&#34;Imprime el mensaje en el área de eco dependiendo de CARACTERISTICA.
</span><span class="s">Si la CARACTERISTICA es el símbolo ‘fiero’,
</span><span class="s">entonces advierte que es un tigre.
</span><span class="s">de otro modo decir que no es fiero&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">caracteristica</span> <span class="ss">&#39;fiero</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;¡Es un tigre!&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;!No es feroz!&#34;</span><span class="p">)))</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;fiero</span><span class="p">)</span>

<span class="p">(</span><span class="nv">tipo-de-animal</span> <span class="ss">&#39;cebra</span><span class="p">)</span>
</code></pre>
<p>Al evalar <code>(tipo-de-animal &#39;fiero)</code>, verás el siguiente mensaje en el área de eco: <code>&#34;¡Es un tigre!&#34;</code>; pero cuando evalues <code>(tipo-de-animal &#39;cebra)</code>, verás <code>&#34;¡No es feroz!&#34;</code>.</p>
<p>(Por supuesto, si <code>característica</code> fuera <code>muy feroz</code>, se imprimiria el mensaje <code>&#34;¡No es feroz!&#34;</code>; ¡y sería un error!  Cuando escribas código, necesitas tener en cuenta la posibilidad de que algun argumento como este será puesto a prueba por <code>if</code> y acorde a ello escribir tu programa.</p>
</div>
<h3 id="verdad-y-falsedad-en-emacs-lisp" >Verdad y Falsedad en Emacs Lisp</h3>
<div class="hBody-3" >
<p>Hay un aspecto importante para la prueba verdadero en una expresión <code>if</code>. Hasta ahora, hemos hablado de ‘verdadero’ y ‘falso’ como valores de predicados como si fueran nuevos tipos de objetos Emacs Lisp. De hecho, solo nuestro viejo amigo <code>nil</code> es ‘falso’. Cualquier otra cosa––cualquiera en absoluto––es ‘verdadero’.</p>
<p>La expresión que prueba si es verdadero se interpreta como <dfn>true</dfn> (verdadero) si el resultado de la evaluacion es no <code>nil</code>. En otras palabras, el resultado de la prueba se considera verdadero si el valor devuelto es un número como 47, una cadena como <code>&#34;hola&#34;</code>, o un símbolo (distinto a <code>nil</code>) como <code>flores</code>, o una lista (siempre y cuando no este vacía) o incluso ¡un búfer!</p>
<p>Antes de ilustrar una prueba para verdadero, necesitamos una explicación de <code>nil</code>.</p>
<p>En Emacs Lisp, el símbolo <code>nil</code> tiene dos significados. En primer lugar, significa que la lista está vacía. En segundo lugar, significa falso y es el valor devuelto cuando una prueba-verdadero-o-falso obtiene falso. <code>nil</code> puede escribirse como una lista vacia, <code>()</code>, o como <code>nil</code>. En lo referente al interprete Lisp <code>()</code> y <code>nil</code> son lo mismo. Los humanos, sin embargo, tienden a usar <code>nil</code> para falso y <code>()</code> para lista vacía.</p>
<p>En Emacs Lisp, cualquier valor que no sea <code>nil</code>––no es una lista vacía––se considera verdadero. Esto significa que si una evaluación devuelve algo que no es una lista vacía, una expresión <code>if</code> pondra la prueba a verdadero. Por ejemplo, si un número se coloca en el lugar de la prueba, se evaluara y devolverá su valor, ya que eso es lo que hacen los números cuando se evalúan. En esta condicion, la expresión <code>if</code> devuelve verdadero. La expresión devuelve falso solo cuando <code>nil</code>, o una lista vacía, son devueltas al evaluar la expresión.</p>
<p>Puedes ver esto evaluando las dos expresiones en los ejemplos siguientes.</p>
<p>En el primer ejemplo, el número 4 se evalua como la prueba en la expresión <code>if</code> y devuelve el numero en si; en consecuencia, se evalua y devuelve la parte-then de la expresión: aparece <samp>verdadero</samp> en el área de eco. En el segundo ejemplo, <code>nil</code> indica falso; en consecuencia, se evalua y devuelve la parte-else de la expresión: aparece <samp>falso</samp> en el área de eco.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="mi">4</span>
    <span class="ss">&#39;verdadero</span>
  <span class="ss">&#39;falso</span><span class="p">)</span>

<span class="p">(</span><span class="nb">if</span> <span class="no">nil</span>
    <span class="ss">&#39;verdadero</span>
  <span class="ss">&#39;falso</span><span class="p">)</span>
</code></pre>
<p>Por cierto, si algún otro valor de utilidad no está disponible para una prueba que devuelve verdadero, entonces el intérprete Lisp devolvera el símbolo <code>t</code> para verdadero. Por ejemplo, la expresión <code>(&gt; 5 4)</code> devuelve <code>t</code> cuando se evalúa, como puedes comprobar si evaluas:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Por otra parte, esta función devuelve <code>nil</code> si la prueba es falsa.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="save-excursion" ><code>save-excursion</code></h3>
<div class="hBody-3" >
<p>La función <code>save-excursion</code> es la cuarta y última forma especial que discutiremos en este capítulo.</p>
<p>En los programas Emacs Lisp utilizados para la edición, la función <code>save-excursion</code> es muy común. Guarda la posición del punto y marca, ejecuta el cuerpo de la función, y luego restaura el punto y marca a sus posiciones previas si sus posiciones fueron cambiadas. Su objetivo principal es impedir que el usuario se sorprenda y perturbe por el movimiento inesperado del punto o marca.</p>
<p>Sin embargo, antes de hablar de <code>save-excursion</code>, puede ser útil examinar primero que son el punto y la marca en GNU Emacs. <dfn>Punto</dfn> es la posición actual del cursor. Donde sea que se encuentre el cursor, estara el punto. De forma más precisa, en los terminales donde el cursor aparece sobre un carácter, el punto está inmediatamente antes del carácter. En Emacs Lisp, el punto es un numero entero. El primer carácter en un búfer es el número uno, el segundo es el número dos, y así sucesivamente. La función <code>point</code> devuelve la posición actual del cursor como un número. Cada búfer tiene su propio valor para el punto.</p>
<p>La <dfn>marca</dfn> es otra posición en el búfer; su valor se puede establecer con un comando como <kbd>C-SPC</kbd> (<code>set-mark-command</code>). Si una marca se ha establecido, puede utilizar el comando <kbd>C-x C-x</kbd> (<code>exchange-point-and-mark</code>) para hacer que el cursor salte a la marca y establecer la marca como la posición anterior del punto. Además, si se establece otra marca, la posición de la marca anterior se guarda en el anillo de marcas. De este modo puede guardar varias posiciones de la marca. Se puede mover el cursor a una marca guardada presionando <kbd>C-u C-SPC</kbd> una o más veces.</p>
<p>La parte del búfer entre el punto y la marca se llamada <dfn>la región</dfn>. Numerosos comandos trabajan en la región, incluyendo <code>center-region</code>, <code>count-lines-region</code>, <code>kill-region</code> y <code>print-region</code>.</p>
<p>La forma especial <code>save-excursion</code> guarda la ubicacion del punto y la marca y restaura estas posiciones después de que el interprete Lisp evalua el código dentro del cuerpo de la forma especial. De este modo, si el punto se encontraba al inicio de un trozo de texto y algún código desplazo el punto al final del búfer, <code>save-excursion</code> volvera a poner el punto donde estaba antes, luego que las expresiones en el cuerpo de la funcion sean evaluadas.</p>
<p>En Emacs, con frecuencia una función mueve el punto como parte de su funcionamiento interno a pesar de que un usuario no espere esto. Por ejemplo, <code>count-lines-region</code> mueve el punto. Para evitar que el usuario sea molestado por saltos inesperados y (desde el punto de vista del usuario) innecesarios, <code>save-excursion</code> se utiliza a menudo para conservar el punto y la marca en la posición esperada por el usuario. El uso de <code>save-excursion</code> es bueno para mantener el orden.</p>
<p>Para asegurarse que la casa se mantiene limpia, <code>save-excursion</code> restaura los valores del punto y la marca incluso si algo va mal en el código interno (o, para ser más preciso y usar el lenguaje tecnico apropiado, “en caso de salida anormal”). Esta funcionalidad es muy útil.</p>
<p>Además de registrar los valores del punto y marca, <code>save-excursion</code> registra el buffer actual, y lo restaura. Esto significa que puedes escribir código que cambie de bufer y <code>save-excursion</code> debe volver al bufer original. Asi es como se utiliza <code>save-excursion</code> en <code>append-to-buffer</code>. (Vea la Seccion <a href="#la-definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>.)</p>
</div>
<h4 id="plantilla-para-una-expresión-save-excursion" >Plantilla para una Expresión <code>save-excursion</code></h4>
<div class="hBody-4" >
<p>La plantilla de código usando <code>save-excursion</code> es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>El cuerpo de la función es una o más expresiones que serán evaluadas de forma secuencial por el intérprete Lisp. Si hay más de una expresión en el cuerpo, el valor de la última será devuelto como el valor de la función <code>save-excursion</code>. Las otras expresiones en el cuerpo solo se evaluan por sus efectos secundarios; y <code>save-excursion</code> en sí, solo se utiliza por su efecto secundario (que es restaurar las posiciones del punto y la marca).</p>
<p>La siguiente plantilla explica <code>save-excursion</code>, con más detalle:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">primera-expresion-en-el-cuerpo</span>
  <span class="nv">segunda-expresion-en-el-cuerpo</span>
  <span class="nv">tercera-expresion-en-el-cuerpo</span>
   <span class="err">…</span>
  <span class="nv">ultima-expresion-en-el-cuerpo</span><span class="p">)</span>
</code></pre>
<p>Una expresión, por supuesto, puede ser un símbolo por sí mismo o una lista.</p>
<p>En el código Emacs Lisp, una expresión <code>save-excursion</code> a menudo ocurre dentro del cuerpo de una expresión <code>let</code>. Se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="nv">varlist</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</code></pre>
</div>
<h3 id="repaso:-cómo-escribir-definiciones-de-funciones" >Repaso</h3>
<div class="hBody-3" >
<p>En los últimos capítulos se han introducido un buen número de funciones y formas especiales. A continuacion se describen brevemente, junto con algunas funciones similares que aun no se han mencionado.</p>
<dl>
<dt><code>eval-last-sexp</code></dt>
<dd>
<p>Evalúar la última expresión simbólica antes de la posición actual del punto. El valor se imprime en el área de eco a menos que la función se invoque con un argumento; en este caso, la salida se imprime en el búfer actual. Este comando normalmente esta asociado a <kbd>C-x C-e</kbd>.</p>
</dd>
<dt><code>defun</code></dt>
<dd>
<p>Define una función. Esta forma especial consta de hasta cinco partes: el nombre, una plantilla para los argumentos que se pasan a la función, la documentacion, una declaración interactiva opcional, y el cuerpo de la definición.</p>
<p>Por ejemplo, en las primeras versiones de Emacs, la definición de la función <code>back-to-indentation</code> era como sigue. (Eso es ligeramente más complejo ahora que se busca el primer caracter que no es espacio en lugar del primer caracter visible.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">back-to-indentation</span> <span class="p">()</span>
  <span class="s">&#34;Mueve el punto al primer caracter visible de la linea.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">beginning-of-line</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">skip-chars-forward</span> <span class="s">&#34; \t&#34;</span><span class="p">))</span>
</code></pre>
</dd>
<dt><code>interactive</code></dt>
<dd>
<p>Anuncia al intérprete que la función se puede usar de forma interactiva. Esta forma especial puede ir seguida de una cadena con una o más partes que pasan la información a los argumentos de la función, de forma secuencial. Estas partes pueden también decir al intérprete que solicite información. Las partes de la cadena estan separadas por saltos de linea, <samp>\n</samp>.</p>
<p>Los codigos de caractere comúnes son:</p>
<dl>
<dt><code>b</code></dt>
<dd>
<p>El nombre de un búfer existente.</p>
</dd>
<dt><code>f</code></dt>
<dd>
<p>El nombre de un fichero existente</p>
</dd>
<dt><code>p</code></dt>
<dd>
<p>El argumento prefijo numérico. (Tenga en cuenta que esta ‘p’ es minúscula.)</p>
</dd>
<dt><code>r</code></dt>
<dd>
<p>Punto y marca, como dos argumentos numéricos, el más pequeño primero. Este es el unico codigo de una letra que especifica dos argumentos sucesivos en lugar de uno.</p>
</dd>
</dl>
<p>Vea la Seccion <a href="info:elips#Interactive-Codes" >Codigo de caracteres para <samp>interactive</samp></a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para obtener una lista completa de los codigos de caracteres.</p>
</dd>
<dt><code>let</code></dt>
<dd>
<p>Declara una lista de variables para utilizarla dentro del cuerpo de <code>let</code> y darle a cada variable un valor inicial, ya sea <code>nil</code> o un valor específico; luego evaluar el resto de las expresiones en el cuerpo del <code>let</code> y devuelve el valor de la última expresion. Dentro del cuerpo del <code>let</code>, el intérprete Lisp no ve los valores de variables con el mismos nombre fuera de <code>let</code>.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">foo</span> <span class="p">(</span><span class="nf">buffer-name</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">bar</span> <span class="p">(</span><span class="nf">buffer-size</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&#34;Este buffer es %s y tiene %d caracteres.&#34;</span>
   <span class="nv">foo</span> <span class="nv">bar</span><span class="p">))</span>
</code></pre>
</dd>
<dt><code>save-excursion</code></dt>
<dd>
<p>Registra los valores de punto, marca y el búfer actual antes de evaluar el cuerpo de esta forma especial. Restaura los valores de punto, marca y el búfer luego de esto.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Estamos %d caracteres dentro de este buffer.&#34;</span>
         <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">save-excursion</span>
              <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</code></pre>
</dd>
<dt><code>if</code></dt>
<dd>
<p>Evalúa el primer argumento de la función; si es verdadero, evalúa el segundo argumento; de otra forma evalúa el tercer argumento, si lo hay.</p>
<p>La forma especial <code>if</code> se llamada <dfn>condicional</dfn>. Hay otros condicionales en Emacs Lisp, pero <code>if</code> es quizás el más comúnmente usado.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="mi">24</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Esta es la version 24 de Emacs&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Esta no es la version 24 de Emacs&#34;</span><span class="p">))</span>
</code></pre>
</dd>
<dt><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></dt>
<dd>
<p>La función <code>&lt;</code> prueba si su primer argumento es menor que su segundo argumento. <code>&gt;</code>, prueba si el primer argumento es mayor que el segundo. Del mismo modo, <code>&lt;=</code> prueba si el primer argumento es menor o igual al segundo y <code>&gt;=</code> si el primer argumento es mayor o igual al segundo. En todos los casos, ambos argumentos deben ser números o marcadores (los marcadores indican posiciones en búfers).</p>
</dd>
<dt><code>=</code></dt>
<dd>
<p>La función <code>=</code> prueba si dos argumentos, ambos números o marcadores, son iguales.</p>
</dd>
<dt><code>equal</code>, <code>eq</code></dt>
<dd>
<p>Prueba si dos objetos son el mismo. <code>equal</code> utiliza un signicado de la palabra ‘mismo’ y <code>eq</code> utiliza otro: <code>equal</code> devuelve verdadero si los dos objetos tienen una estructura y contenidos similares, por ejemplo, dos copias del mismo libro. Por otro lado, <code>eq</code>, devuelve verdadero si ambos argumentos son realmente el mismo objeto.</p>
</dd>
<dt><code>string&lt;</code>, <code>string-lessp</code>, <code>string=</code>, <code>string-equal</code></dt>
<dd>
<p>La función <code>string-lessp</code> prueba si su primer argumento es menor que el segundo. Un nombre alternativo mas corto para la misma función (un <code>defalias</code>) es <code>string&lt;</code>.</p>
<p>Los argumentos para <code>string-lessp</code> deben ser cadenas o símbolos; la ordenación es lexicográfica, por lo que mayusculas o minusculas son significativas. Los nombres impresos de símbolos se utilizan en lugar de los símbolos mismos.</p>
<p>Una cadena vacía, <samp>&#34;&#34;</samp>, una cadena sin caracteres en ella, es más pequeña que cualquier cadena de caracteres.</p>
<p><code>string-equal</code> proporciona la prueba correpondiente para la igualdad. Su nombre alternativo es <code>string=</code>. No hay funciones de prueba que correspondan a <code>&gt;</code>, <code>&gt;=</code> o <code>&lt;=</code>.</p>
</dd>
<dt><code>message</code></dt>
<dd>
<p>Imprime un mensaje en el área de eco. El primer argumento es una cadena que puede contener, <samp>%s</samp>, <samp>%d</samp>, o <samp>%c</samp> para imprimir el valor de los argumentos que siguen a la la cadena. El argumento utilizado por <samp>%s</samp> debe ser una cadena o un simbolo, el argumeto utilizado por <samp>%d</samp> debe ser un número. El argumento usado por <samp>%c</samp> debe ser un codigo númerico <em>ASCII</em>; se imprimira como el caracter con este código <em>ASCII</em>. (No se han mencionado otras secuencias <q>porcentuales</q> <code>%-</code>).</p>
</dd>
<dt><code>setq</code>, <code>set</code></dt>
<dd>
<p>La función <code>setq</code> asigna al valor de su primer argumento el valor del segundo argumento. El primer argumento se cita automáticamente por <code>setq</code>. Hace lo mismo para los pares sucesisvos de argumentos. Otra función, <code>set</code>, toma solo dos argumentos y evalúa ambos antes de asignar el valor devuelto por su primer argumento al valor devuelto por el segundo argumento.</p>
</dd>
<dt><code>buffer-name</code></dt>
<dd>
<p>Sin un argumento, devuelve el nombre del búfer, como una cadena.</p>
</dd>
<dt><code>buffer-file-name</code></dt>
<dd>
<p>Sin un argumento, devuelve el nombre del fichero del búfer que se esta visitando.</p>
</dd>
<dt><code>current-buffer</code></dt>
<dd>
<p>Devuelve el búfer en el que Emacs se encuentra activo; Puede que no sea el búfer que es visible en la pantalla.</p>
</dd>
<dt><code>other-buffer</code></dt>
<dd>
<p>Devuelve el ultimo búfer seleccionado mas recientemente (distinto del buffer pasado a <code>other-buffer</code> como un argumento y distinto del búfer actual).</p>
</dd>
<dt><code>switch-to-buffer</code></dt>
<dd>
<p>Selecciona un búfer de Emacs para activarlo y mostralo en la ventana actual para que los usuarios puedan verlo. Normalmente ligado a <kbd>C-x b</kbd>.</p>
</dd>
<dt><code>set-buffer</code></dt>
<dd>
<p>Cambiar la atención de Emacs a un búfer en el que se ejecutaran programas. No altera lo que la ventana está mostrando.</p>
</dd>
<dt><code>buffer-size</code></dt>
<dd>
<p>Devuelve el número de caracteres en el búfer actual.</p>
</dd>
<dt><code>point</code></dt>
<dd>
<p>Devuelve el valor de la posicion actual del cursor, como un entero contando el número de caracteres desde el inicio del búfer.</p>
</dd>
<dt><code>point-min</code></dt>
<dd>
<p>Devuelve el valor mínimo admisible del punto en el búfer actual. Esto es 1, a menos que narrowing esté activo</p>
</dd>
<dt><code>point-max</code></dt>
<dd>
<p>Devuelve el valor máximo admisible del punto en el búfer actual. Este es el fin del búfer, a menos que narrowing este activo.</p>
</dd>
</dl>
</div>
<h3 id="ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función no interactiva que duplique el valor de su argumento, un número. Luego haz la función interactiva.</p>
</li>
<li>
<p>Escribe una función que compruebe si el valor actual de <code>fill-column</code> es mayor que el argumento pasado a la función, y si es así, imprime un mensaje apropiado.</p>
</li>
</ul>
</div>
<h2 id="algunas-funciones-relacionadas-al-bufer" >Algunas funciones relacionadas al bufer</h2>
<div class="hBody-2" >
<p>En este capítulo estudiamos en detalle varias de las funciones usadas en GNU Emacs. Esto se denomina un “recorrido” (visita o demostracion de un area o tarea). Estas funciones se utilizan como ejemplos de código Lisp, pero no son ejemplos imaginarios; con excepción del primero, con la definición de función simplificada, estas funciones muestran el código real usado en GNU Emacs. Se puede aprender mucho de estas definiciones. Las funciones descritas aquí están todas relacionadas a búfers. Mas tarde, estudiaremos otras funciones.</p>
</div>
<h3 id="encontrar-más-información" >Encontrar Más información</h3>
<div class="hBody-3" >
<p>En este recorrido, describire cada nueva función, algunas veces en detalle y algunas veces brevemente. Si estás interesado, puedes obtener la documentación completa de cualquier función de Emacs Lisp en cualquier momento presiona <kbd>C-h f</kbd> y luego escribe el nombre de la función (y luego <kbd>RET</kbd>). Del mismo modo, se puede obtener la documentación completa de una variable con <kbd>C-h v</kbd>, luego el nombre de la variable (y despues <kbd>RET</kbd>).</p>
<p>Ademas, <code>describe-function</code> te dira la ubicacion de la definición de la función.</p>
<p>Coloca el punto dentro del nombre del fichero que contiene la función y presiona la tecla <kbd>RET</kbd>. En este caso, <kbd>RET</kbd> significa <code>push-button</code> en lugar de ‘return’ o ‘enter’. Emacs te llevara directamente a la definición de la función.</p>
<p>De manera más general, si quieres ver una función en su fichero fuente original, puedes utilizar la función <code>find-tag</code> para saltar a la misma. <code>find-tag</code> trabaja con una amplia variedad de lenguajes, no solo Lisp, y C, y tambien funciona con texto en general. Por ejemplo, <code>find-tag</code> saltará a los distintos nodos del codigo fuente de este documento. La función <code>find-tag</code> depende de ‘tablas de etiquetas’ que registran las ubicaciones de las funciones, variables, y otros elementos a los que <code>find-tag</code> salta.</p>
<p>Para usar el comando <code>find-tag</code>, presiona <kbd>M-.</kbd> (es decir, presiona la tecla punto mientras presionas la tecla <kbd>META</kbd>, o presiona <kbd>ESC</kbd> y luego la tecla punto), a continuacion, en el prompt, escribe el nombre de la función para ver su código fuente, por ejemplo <code>mark-whole-buffer</code>, y luego pulsa <kbd>RET</kbd>. Emacs cambiará de búfer y mostrará el código fuente de la función en la pantalla. Para regresar a tu búfer actual, presiona <kbd>C-x b RET</kbd>. (En algunos teclados, la tecla <kbd>META</kbd> se etiqueta como <kbd>ALT</kbd>.)</p>
<p>Dependiendo de la configuracion de los valores iniciales por defecto de tu copia de Emacs, puede ser necesario especificar la posición de tu ‘tabla de etiquetas’, que es un fichero llamado <span class="file" >TAGS</span>. Por ejemplo, si estás interesado en el codigo fuente de Emacs, la tabla de etiquetas, si ya ha sido creada, estará en un subdirectorio del directorio <span class="file" >/usr/local/share/emacs</span>; de este modo se usaría el comando <code>M-x visit-tags-table</code> y se especifica una ruta como <span class="file" >/usr/local/share/emacs/24.1.1/lisp/TAGS</span>. Si la tabla de etiquetas no ha sido creada, tendrás que crearla por tí mismo. Estara en un fichero como <span class="file" >/usr/local/src/emacs/src/TAGS</span>.</p>
<p>Para crear un fichero <span class="file" >TAGS</span> en un directorio específico, cambia a ese directorio en Emacs mediante el comando <kbd>M-x cd</kbd>, o lista el directorio con <kbd>C-x d</kbd> (<code>dired</code>). A continuacion ejecuta el comando de compilacion, con <code>etags *.el</code> como:</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags *.el RET
</pre>
</div>
<p>Para más información, ver la Seccion <a href="#crea-tu-propio-fichero-tags" >Crea tu propio fichero <span class="file" >TAGS</span></a>.</p>
<p>Después de te familiarices con Emacs Lisp, te encontrarás con frecuencia utilizando <code>find-tag</code> como metodo de navegar atraves del código fuente; y crearás tus propias tablas <span class="file" >TAGS</span>.</p>
<p>Por cierto, los ficheros que contienen código Lisp son llamados convencionalmente <dfn>librerías</dfn>. La metáfora se deriva que una librería especializada, tal como una librería de leyes o una librería de ingeniería, en lugar de una librería general. Cada librería, o fichero, contiene funciones que se relacionan con un tema o actividad particular, por ejemplo <span class="file" >abbrev.el</span> para el manejo de abreviaturas y otros atajos, y <span class="file" >help.el</span> para ayuda en linea. (Algunas veces varias librerías proporcionan código para una sola actividad, como los distintos ficheros <span class="file" >rmail…</span>  que proporcionan codigo para leer correo electrónico.) En <em>El Manual de GNU Emacs</em>, verás varias frases como “El comando <kbd>C-h p</kbd> te permite buscar las librerias estándar de Emacs Lisp por la palabra clave del tema.</p>
</div>
<h3 id="una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></h3>
<div class="hBody-3" >
<p>El comando <code>beginning-of-buffer</code> es una buena función para empezar, ya que es probable que estes familiarizado con ella y es fácil de entender. Usado como un comando interactivo, <code>beginning-of-buffer</code> mueve el cursor al inicio del búfer, dejando la marca en la posición anterior. Esta generalmente unido a <kbd>M-&lt;</kbd>.</p>
<p>En esta sección, vamos a hablar de una versión reducida de la función que muestra como se utiliza con mayor frecuencia. Esta función reducida funciona como esta escrita, pero no contiene código para una opcion compleja. En otra sección, describiremos la función entera. (Vea la Seccion <a href="#definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></a>.</p>
<p>Antes de mirar el código, vamos a considerar lo que la definición de función tiene que contener: debe incluir una expresión que haga la función interactiva por lo que se puede llamar escribiendo <kbd>M-x beginning-of-buffer</kbd> o pulsando algun atajo como <kbd>M-&lt;</kbd>; debe incluir código para dejar una marca en la posición original del búfer; y debe incluir código para mover el cursor al inicio del búfer.</p>
<p>Aquí está el texto completo la versión reducida de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">simplified-beginning-of-buffer</span> <span class="p">()</span>
  <span class="s">&#34;Mover el punto al inicio del buffer;
</span><span class="s">deja la marca en la posicion anterior.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
</code></pre>
<p>Al igual que todas las definiciones de función, esta definición tiene cinco partes siguiendo la forma especial <code>defun</code>:</p>
<ol class="num" >
<li>
<p>El nombre: en este ejemplo, <code>simplified-beginning-of-buffer</code>.</p>
</li>
<li>
<p>Una lista de los argumentos: en este ejemplo, una lista vacía, <code>()</code>,</p>
</li>
<li>
<p>La cadena de documentación.</p>
</li>
<li>
<p>La expresión interactiva.</p>
</li>
<li>
<p>El cuerpo.</p>
</li>
</ol>
<p>En esta definición de función, la lista de argumentos está vacía; esto significa que esta función no requiere ningun argumento. (Cuando nos fijamos en la definición de la función completa, veremos que se puede pasar un argumento opcional.)</p>
<p>La expresión interactiva le informa a Emacs que se pretende utilizar la función de forma interactiva. En este ejemplo, <code>interactive</code> no tiene un argumento porque <code>simplified-beginning-of-buffer</code> no requiere uno.</p>
<p>El cuerpo de la función consiste de dos líneas:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
</code></pre>
<p>La primera de estas líneas es la expresión, <code>(push-mark)</code>. Cuando el interprete Lisp evalua esta expresión, se establece una marca en la posición actual del cursor, donde sea que este. La posición de esta marca se guarda en el anillo de marcas.</p>
<p>La siguiente línea es <code>(goto-char (point-min))</code>. Esta expresión hace saltar el cursor hasta el punto mínimo en el búfer, es decir, al inicio del búfer (o al inicio de la porción accesible del búfer si narrowed esta activo. Vea la Seccion <a href="#reducir-y-extender" >Reducir y Extender</a>.)</p>
<p>El comando <code>push-mark</code> establece una marca en el sitio donde se encontraba el cursor antes de que la expresion expresión <code>(goto-char (point-min))</code> lo moviera al principio del bufer. En consecuencia, puedes, si quieres, volver a donde estabas originalmente presionando <kbd>C-x C-x</kbd>.</p>
<p>¡Esto es todo lo que hay en la definición de función!</p>
<p>Cuando leas código como este y te encuentres con una función desconocida, como <code>goto-char</code>, puedes averiguar que es lo que hace mediante el comando <code>describe-function</code>. Para usar este comando, presiona <kbd>C-h f</kbd> y luego escribe el nombre de la función y presiona <kbd>RET</kbd>. El comando <code>describe-function</code> imprimirá la cadena de documentacion de la función en una ventana <span class="file" >*Help*</span>. Por ejemplo, la documentación de <code>goto-char</code> es:</p>
<div class="example-block" >
<pre class="example" >Establece el punto a POSICION, un numero o marcador.
El inicio del buffer es la posicion (point-min), el final es (point-max).
</pre>
</div>
<p>El argumento de la función es la posición deseada.</p>
<p>(En el caso de <code>describe-function</code> el prompt te facilita el símbolo adelante o anterior al cursor, lo que te puede evitar escribir el nombre de la funcion al colocar el cursor encima o después de la función y luego presionando <kbd>C-h f RET</kbd>.)</p>
<p>La definición de la función <code>end-of-buffer</code> se escribe de la misma forma que la definición <code>beginnig-of-buffer</code> excepto que el cuerpo de la función contiene la expresión <code>(goto-char (point-max))</code> en lugar de <code>(goto-char (point-min))</code></p>
</div>
<h3 id="la-definición-de-mark-whole-buffer" >La definición de <code>mark-whole-buffer</code></h3>
<div class="hBody-3" >
<p>La función <code>mark-whole-buffer</code> no es mas difícil de entender que la función <code>simplified-beginning-of-buffer</code>. En este caso, sin embargo, vamos a ver la función completa, no una versión reducida.</p>
<p>La función <code>mark-whole-buffer</code> no se utiliza tan comúnmente como la función <code>beginning-of-buffer</code>, pero no es menos útil: marca un búfer completo como una región colocando el punto al inicio y una marca al fin del búfer. Generalmente se enlaza a <kbd>C-x h</kbd>.</p>
<p>En GNU Emacs 22, el código de la función completa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">mark-whole-buffer</span> <span class="p">()</span>
  <span class="s">&#34;Coloca el punto al inicio y marca el fin del buffer.
</span><span class="s">Probablemente no deberias utilizar esta funcion en programas Lisp;
</span><span class="s">Por lo general es un error que una funcion Lisp utilice cualquier subrutina
</span><span class="s">que utiliza o establece la marca.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)))</span>
</code></pre>
<p>Al igual que todas las demas funciones, la función <code>mark-whole-buffer</code> encaja dentro de la plantilla de una definición de funcion. La plantilla luce asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">nombre-de-funcion</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nv">expresion-interactiva</span><span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Asi es cómo funciona la función: el nombre de la función es <code>mark-whole-buffer</code>; le sigue una lista de argumentos vacía, <samp>()</samp>, lo que significa que la función no requiere argumentos. La documentación viene despues.</p>
<p>La siguiente línea es una expresión <code>(interactive)</code> que indica a Emacs que la función se utilizara de forma interactiva. Estos detalles son similares a la función <code>simplified-beginning-of-buffer</code> descrita en la sección anterior</p>
</div>
<h4 id="cuerpo-de-mark-whole-buffer" >Cuerpo de <code>mark-whole-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>mark-whole-buffer</code> consiste en tres líneas de código:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
<span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
</code></pre>
<p>La primera de estas líneas es la expresión, <code>(push-mark (point))</code>.</p>
<p>Esta línea hace exactamente el mismo trabajo que la primera línea del cuerpo de la función <code>simplified-beginning-of-buffer</code>, en la que solo se escribe <code>(push-mark)</code>. En ambos casos, el intérprete Lisp coloca una marca en la posición actual del cursor.</p>
<p>No sé por qué en la expresión <code>mark-whole-buffer</code> se escribe <code>(push-mark (point))</code> y en la expresión <code>beginning-of-buffer</code> se escribe <code>(push-mark)</code>. Quizás quien escribió el código no conocia que los argumentos de <code>push-mark</code> son opcionales y que si no se pasa un argumento a <code>push-mark</code>, la función establece automáticamente la marca en la posicion del punto por defecto. O quizás la expresión fué escrita paralelamente a la estructura de la siguiente línea. En cualquier caso, la línea proboca que Emacs determine la posición del punto y coloque una marca allí.</p>
<p>En versiones anteriores de GNU Emacs, la siguiente línea de <code>mark-whole-buffer</code> era <code>(push-mark (point-max))</code>. Esta expresión establece una marca en el punto del búfer que tiene el número más alto. Este será el final del búfer (o, si el búfer tiene activo narrowing, el final de la porción accesible del búfer. Vea la Seccion <a href="#reducir-y-extender" >Reducir y Extender</a>, para más informacion sobre norrowing). Después de colocar esta marca, la marca anterior, la establecida en el punto, ya no esta configurada, pero Emacs recuerda su posición, al igual que todas las otras marcas recientes. Esto significa que, si lo deseas, puedes volver a esta posición presionando <kbd>C-u C-SPC</kbd> dos veces.</p>
<p>En GNU Emacs 22, <code>(point-max)</code> es ligeramente más complicado. La línea es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>La expresión funciona casi igual que antes. Se establece una marca en la posicion con el numero mas alto posible en el búfer. Sin embargo, en esta versión, <code>push-mark</code> tiene dos argumentos adicionales. El segundo argumento de <code>push-mark</code> es <code>nil</code>. Esto le indica a la función que debe <em>mostrar</em> un mensaje que dice ‘Mark set’ cuando se coloca la marca. El tercer argumento es <code>t</code>. Esto indica a <code>push-mark</code> que active la marca cuando el modo Transient Mark está activo. Transient Mark mode resalta la región activa. Con frecuencia esta desactivado.</p>
<p>Finalmente, la última línea de la función es <code>(goto-char (point-min))</code>. Esta escrito exactamente de la misma forma como está escrito <code>beginning-of-buffer</code>. La expresión mueve el cursor al punto mínimo en el búfer, es decir, al inicio del búferr (o al inicio de la porción accesible del búfer). Como resultado de esto, punto se coloca al inicio del búfer y la marca se encuentra al final del búfer. Por tanto, todo el búfer es la región.</p>
</div>
<h3 id="la-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></h3>
<div class="hBody-3" >
<p>El comando <code>append-to-buffer</code> es más complejo que el comando <code>mark-whole-buffer</code>. Lo que hace es copiar la región (es decir, la parte del búfer entre el punto y la marca) del buffer actual a un búfer específico.</p>
<p>El comando <code>append-to-buffer</code> utiliza la función <code>insert-buffer-substring</code> para copiar la región. <code>insert-buffer-substring</code> se describe por su nombre: toma una cadena de caracteres de una parte de un búfer, una “subcadena”, y la inserta en otro búfer.</p>
<p>La mayor parte de <code>append-to-buffer</code> tiene que ver con el establecimiento de las condiciones para que <code>insert-buffer-substring</code> funcione: el código debe especificar tanto el búfer al que ira el texto, la ventana fuente y destino, y la región que será copiada.</p>
<p>Aquí está el texto completo de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Agregar a un buffer especifico el texto de la region.
</span><span class="s">Este se inserta en ese buffer antes de su punto.
</span><span class="s">
</span><span class="s">Cuando se llama desde un programa, se pasan tres argumentes:
</span><span class="s">BUFFER (o nombre del buffer), START y END.
</span><span class="s">START y END especifican la porcion del buffer actual a copiar.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span>
   <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">read-buffer</span> <span class="s">&#34;Agregar al buffer: &#34;</span> <span class="p">(</span><span class="nf">other-buffer</span>
                                            <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
         <span class="p">(</span><span class="nf">region-beginning</span><span class="p">)</span> <span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">append-to</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">windows</span> <span class="p">(</span><span class="nv">get-buffer-window-list</span> <span class="nv">append-to</span> <span class="no">t</span> <span class="no">t</span><span class="p">))</span>
             <span class="nf">point</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">append-to</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nf">point</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">window</span> <span class="nv">windows</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">window-point</span> <span class="nv">window</span><span class="p">)</span> <span class="nf">point</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">set-window-point</span> <span class="nv">window</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))))))</span>
</code></pre>
<p>Se puede entender la función si se mira como una serie de plantillas rellenas.</p>
<p>La plantilla exterior es para la definición de función. Esta función, se ve como asi (con varios espacios ocupados):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="err">…</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>La primer línea de la función incluye su nombre y tres argumentos. Los argumentos son el <code>búfer</code> al cual copiar el texto, <code>start</code> y <code>end</code> que son el inicio y el fin de la región del buffer actual desde donde se va a copiar.</p>
<p>La siguiente parte de la función es la documentación, que es clara y completa. Como es convencional, los tres argumentos estan escritos en mayúsculas para que los notes con facilidad. Aun mejor, se describen en el mismo orden que en la lista de argumentos.</p>
<p>Observe que la documentación distingue entre un búfer y su nombre. (La función puede manejar cualquiera.)</p>
</div>
<h4 id="la-expresión-interactiva-append-to-buffer" >La expresión interactiva <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>Ya que la función <code>append-to-buffer</code> se puede utilizar de forma interactiva, la función debe tener una expresión <code>interactive</code>. (Para una analisis de <code>interactive</code>, ve la seccion <a href="#crear-una-función-interactiva" >Crear una función interactiva</a>.)  La expresión se lee de la siguiente manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span>
 <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">read-buffer</span>
        <span class="s">&#34;Agregar al buffer: &#34;</span>
        <span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">region-beginning</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">region-end</span><span class="p">)))</span>
</code></pre>
<p>Esta expresión no tiene letras para representar partes, como se describio anteriormente. En su lugar, inicia una lista con estas partes:</p>
<p>La primer parte de la lista es una expresión para leer el nombre de un búfer y devolverlo como una cadena. Es decir <code>read-buffer</code>. La función requiere un prompt como primer argumento, <samp>&#34;Agregar al buffer: &#34;</samp>. El segundo argumento le indica al comando que valor proporcionar si no se especifica nada.</p>
<p>En este caso este segundo argumento es una expresión que contiene la función <code>other-buffer</code>, una excepción, y una <samp>t</samp>, para representar verdadero.</p>
<p>El primer argumento de <code>other-buffer</code>, la excepción, es otra función, <code>current-buffer</code>. Esto no va a ser devuelto. El segundo argumento es el símbolo de verdadero, <code>t</code>. Que le dice a <code>other-buffer</code> que puede mostrar búfers visibles (excepto en este caso, no se mostrará el búfer actual, lo cual tiene sentido).</p>
<p>La expresión se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>El segundo y tercer argumento de la expresión <code>list</code> son <code>(region-beginning)</code> y <code>(region-end)</code>. Estas dos funciones especifican el inicio y el final del texto que se añade</p>
<p>Originalmente, el comando utilizaba las letras <samp>B</samp> y <samp>r</samp>. Toda la expresión <code>interactive</code> se veia así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;BAppend to buffer: \nr&#34;</span><span class="p">)</span>
</code></pre>
<p>Pero cuando se hacia esto, el valor por defecto del búfer de cambió era invisible. Esto no era lo que se queria.</p>
<p>(El prompt se separo del segundo argumento con una línea nueva, <samp>\n</samp>. Seguido por un <samp>r</samp> que le indica a Emacs unir los dos argumentos que siguen al símbolo <code>buffer</code> en la lista de argumentos de la función (es decir, <code>start</code> y <code>end</code>) a los valores del punto y marca. Este argumento funcionaba bien.)</p>
</div>
<h4 id="el-cuerpo-de-append-to-buffer" >El cuerpo de <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>append-to-buffer</code> inicia con <code>let</code>.</p>
<p>Como hemos visto antes (ver Seccion <a href="#let" ><code>let</code></a>), el propósito de una expresión <code>let</code> es crear y dar valores iniciales a una o más variables que solo se usaran dentro del cuerpo del <code>let</code>. Esto significa que esa variable no se debe confundir con cualquier variable del mismo nombre fuera de la expresión <code>let</code>.</p>
<p>Podemos ver como la expresión <code>let</code> encaja en la función como un todo mostrando una plantilla de <code>append-to-buffer</code> con la expresión <code>let</code> en general:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">append-to-buffer</span> <span class="p">(</span><span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="err">…</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">variable</span> <span class="nv">valor</span><span class="p">))</span>
        <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>La expresión <code>let</code> tiene tres elementos:</p>
<ol class="num" >
<li>
<p>El símbolo <code>let</code>;</p>
</li>
<li>
<p>Una varlist que contiene, en este caso, una unica lista de dos elementos, <code>(variable valor)</code>;</p>
</li>
<li>
<p>El cuerpo de la expresión <code>let</code>.</p>
</li>
</ol>
<p>En la función <code>append-to-buffer</code>, la varlist es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))</span>
</code></pre>
<p>En esta parte de la expresión <code>let</code>, la unica variable, <code>oldbuf</code> se une al valor devuelto por la expresión <code>(current-buffer)</code>. La variable, <code>oldbuf</code>, se utiliza para guardar un registro del búfer en el que estás trabajando y desde donde se copiara.</p>
<p>El elemento o elementos de una varlist esta rodeado por un conjunto de paréntesis por lo que el intérprete Lisp puede distinguir la varlist del cuerpo del <code>let</code>. Como consecuencia, la lista de dos elementos dentro de la varlist está rodeada por un conjunto circunscrito de paréntesis. La línea tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="err">…</span> <span class="p">)</span>
</code></pre>
<p>Los dos paréntesis antes de <code>oldbuf</code> podrían sorprenderte si no fuera porque el primer paréntesis marca el límite de la varlist y el segundo paréntesis marca el inicio de la lista de dos elementos, <code>(oldbuf (current-buffer))</code>.</p>
</div>
<h4 id="save-excursion-en-append-to-buffer" ><code>save-excursion</code> en <code>append-to-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la expresión <code>let</code> dentro de <code>append-to-buffer</code> consiste de una expresión <code>save-excursion</code>.</p>
<p>La función <code>save-excursion</code> guarda las posiciones de punto y marca, y restaura estas posiciones después de que las expresiones en el cuerpo de <code>save-excursion</code> completan su ejecución. Además, <code>save-excursion</code> no pierde de vista el búfer original, y lo restaura. Asi es como se utizia <code>save-excursion</code> en <code>append-to-buffer</code>.</p>
<p>Por cierto, vale la pena señalar que una función Lisp normalmente se formatea de modo que todo lo que esta encerrado en un conjunto de multiples lineas se indente más a la derecha que el primer símbolo. En esta definición de función, <code>let</code> se indenta más que <code>defun</code>, y <code>save-excursion</code> se indenta más que <code>let</code>, asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="err">…</span>
  <span class="err">…</span>
  <span class="err">…</span>
  <span class="p">(</span><span class="nb">let</span><span class="err">…</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="err">…</span>
</code></pre>
<p>Esta convención de formato hace que sea fácil de ver que líneas en el cuerpo de <code>save-excursion</code> estan rodeadas por los parentesis asociados con <code>save-excursion</code>, de igual forma el mismo <code>save-excursion</code> esta rodeado por los paréntesis asociados con <code>let</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="err">…</span>
    <span class="p">(</span><span class="nf">set-buffer</span> <span class="err">…</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
    <span class="err">…</span><span class="p">))</span>
</code></pre>
<p>El uso de la función <code>save-excursion</code> puede ser visto como el proceso de llenar ranuras de una plantilla:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">primer-expresion-en-el-cuerpo</span>
  <span class="nv">segunda-expresion-en-el-cuerpo</span>
   <span class="err">…</span>
  <span class="nv">ultima-expresion-en-el-cuerpo</span><span class="p">)</span>
</code></pre>
<p>En esta función, el cuerpo de <code>save-excursion</code> contiene solo una expresión, la expresión <code>let*</code>. Ya conoces la función <code>let</code>. La función <code>let*</code> es diferente. Posee un <samp>*</samp> en su nombre. Esto le permite a Emacs colocar cada variable de su varlist en secuencia, una después de otra.</p>
<p>Su caracteristica fundamental es que las siguientes variables en la varlist puedan hacer uso de los valores establecidos por Emacs antes en la varlist. Vea la Seccion <a href="#la-expresión-let*" >La expresión <code>let*</code></a>.</p>
<p>Vamos a omitir funciones como <code>let*</code> y nos centraremos en dos: la función <code>set-buffer</code> y la función <code>insert-buffer-substring</code>.</p>
<p>En los viejos tiempos, la expresión <code>set-buffer</code> era simplemente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">))</span>
</code></pre>
<p>pero ahora es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">append-to</span><span class="p">)</span>
</code></pre>
<p><code>append-to</code> esta unido al <code>(get-buffer-create-buffer)</code> anterior en la expresión <code>let*</code>. Esta union extra no sería necesaria excepto que <code>append-to</code> se utiliza despues en la varlist como un argumento para <code>get-buffer-window-list</code>.</p>
<p>La definición de la función <code>append-to-buffer</code> inserta texto desde el búfer en el que te encuentras actualmente al buffer que se indique. Sucede que <code>insert-buffer-substring</code> copia texto desde otro búfer al búfer actual, justo al reves––es por ello que la definición <code>append-to-buffer</code> inicia con un <code>let</code> que une el símbolo local <code>oldbuf</code> al valor devuelto por <code>current-buffer</code>.</p>
<p>La expresión <code>insert-buffer-substring</code> es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
</code></pre>
<p>La función <code>insert-buffer-substring</code> copia una cadena <em>desde</em> el búfer especificado como su primer argumento e inserta la cadena dentro del búfer actual. En este caso, el argumento de <code>insert-buffer-substring</code> es el valor de la variable creada y vinculada por <code>let</code>, es decir, el valor de <code>oldbuf</code>, que era el búfer actual cuando diste el comando <code>append-to-buffer</code>.</p>
<p>Después de que <code>insert-buffer-substring</code> ha hecho su trabajo, <code>save-excursion</code> restaurará la acción al búfer original y <code>append-to-buffer</code> habrá hecho su trabajo.</p>
<p>Escrito en forma de esqueletal, los funcionamientos del cuerpo se ven asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">unir-oldbuf-al-valor-del-buffer-actual</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>                       <span class="c1">; guarda un registro del buffer.</span>
    <span class="nv">cambio-de-buffer</span>
    <span class="nv">insertar-subcadena-desde-oldbuf-a-buffer</span><span class="p">)</span>

  <span class="nv">regresar-al-buffer-original-al-terminar</span>
<span class="nv">dejar-que-el-siginificado-local-de-oldbuf-desaparacesca-al-terminar</span>
</code></pre>
<p>En resumen, <code>append-to-buffer</code> funciona de la siguiente manera: guarda el valor del búfer actual en la variable <code>oldbuf</code>. Obtiene el nuevo búfer (creando uno si es necesario) y cambia la atención de Emacs a este. Usando el valor de <code>oldbuf</code>, inserta la región del texto desde el búfer antiguo dentro del nuevo búfer; y luego usando <code>save-excursion</code>, regresa al búfer original.</p>
<p>Al observar <code>append-to-buffer</code>, se ha explorado una función bastante compleja. Muestra como usar <code>let</code> y <code>save-excursion</code>, y como cambiar y volver desde otro buffer. Muchas definiciones de función usan <code>let</code>, <code>save-excursion</code>, y <code>set-buffer</code> de esta manera.</p>
</div>
<h3 id="repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí está un breve resumen de las diferentes funciones descritas en este capítulo.</p>
<dl>
<dt><code>describe-function</code>, <code>describe-variable</code></dt>
<dd>
<p>Imprime la documentación de una función o variable. Convencionalmente unidas a <kbd>C-h f</kbd> y <kbd>C-h v</kbd>.</p>
</dd>
<dt><code>find-tag</code></dt>
<dd>
<p>Encuentra el fichero que contiene el codigo de una función o variable y cambia a dicho buffer, colocando el punto al inicio del elemento. Convencionalmente ligado a <kbd>M-.</kbd> (esto es un punto luego de la tecla <kbd>META</kbd>).</p>
</dd>
<dt><code>save-excursion</code></dt>
<dd>
<p>Guarda la posicion de punto y marca y restaura sus valores tras evaluar los argumentos de <code>save-excursion</code>. Ademas, recuerda el buffer actual y regresa a el.</p>
</dd>
<dt><code>push-mark</code></dt>
<dd>
<p>Asigna la marca a una posicion y guarda el valor de la marca previa en el anillo de marcas. La marca es una ubicacion en el búfer que mantendra su posición relativa, incluso si se añade o borra texto del búfer.</p>
</dd>
<dt><code>goto-char</code></dt>
<dd>
<p>Establece el punto a la ubicacion especificada por el valor del argumento, que puede ser un número, una marca, o una expresión que devuelve el número de una posición, como <code>(point-min)</code>.</p>
</dd>
<dt><code>insert-buffer-substring</code></dt>
<dd>
<p>Copia una región de texto desde un búfer que se pasa a la función como un argumento e inserta la región dentro del búfer actual.</p>
</dd>
<dt><code>mark-whole-buffer</code></dt>
<dd>
<p>Marca el búfer completo como una región. Normalmente unido a <kbd>C-x h</kbd>.</p>
</dd>
<dt><code>set-buffer</code></dt>
<dd>
<p>Cambia la atención de Emacs a otro búfer, pero no se muestra el cambio en la ventana. Se utiliza cuando un programa y no humano trabaja en un búfer distinto.</p>
</dd>
<dt><code>get-buffer-create</code>, <code>get-buffer</code></dt>
<dd>
<p>Busca el búfer con nombre o crea uno si el búfer con ese nombre no existe. La función <code>get-buffer</code> devuelve <code>nil</code> si el nombre del búfer no existe.</p>
</dd>
</dl>
</div>
<h3 id="ejercicios" >Ejercicios</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe tu propia definición de la función <code>simplified-end-of-buffer</code>; luego pruebala para ver si funciona.</p>
</li>
<li>
<p>Utiliza <code>if</code> y <code>get-buffer</code> para escribir una función que imprima un mensaje que te diga si un buffer existe.</p>
</li>
<li>
<p>Usando <code>find-tag</code>, busca el codigo de la función <code>copy-to-buffer</code></p>
</li>
</ul>
</div>
<h2 id="algunas-funciones-más-complejas" >Algunas Funciones Más Complejas</h2>
<div class="hBody-2" >
<p>En este capítulo, nos basamos en lo que hemos aprendido en los capítulos anteriores examinando funciones más complejas. La función <code>copy-to-buffer</code> ilustra el uso de dos expresiones <code>save-excursion</code> en una definición, mientras que la función <code>insert-buffer</code> ilustra el uso de un asterisco en una expresión <code>interactive</code>, el uso de <code>or</code>, y la importante distinción entre un nombre y el objeto al que el nombre hace referencia.</p>
</div>
<h3 id="la-definición-de-copy-to-buffer" >La definición de <code>copy-to-buffer</code></h3>
<div class="hBody-3" >
<p>Después de comprender cómo trabaja <code>append-to-buffer</code>, es fácil entender <code>copy-to-buffer</code>. Esta función copia texto dentro de un búfer, pero en lugar de agregarlo al segundo búfer, sustituye todo el texto anterior en el segundo búfer.</p>
<p>El cuerpo de <code>copy-to-buffer</code> tiene este aspecto,</p>
<pre class="code" ><code class="chroma" ><span class="err">…</span>
<span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;BCopy to buffer: \nr&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">oldbuf</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">with-current-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">erase-buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">oldbuf</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)))))</span>
</code></pre>
<p>La función <code>copy-to-buffer</code> tiene una expresión <code>interactive</code> mas sencilla que <code>append-to-buffer</code>.</p>
<p>La definición dice:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">with-current-buffer</span> <span class="p">(</span><span class="nf">get-buffer-create</span> <span class="nv">buffer</span><span class="p">)</span> <span class="err">…</span>
</code></pre>
<p>En primer lugar, mira en la expresión más interna; que se evalua primero. Esta expresión inicia con <code>get-buffer-create buffer</code>. La función le indica al ordenador que utilice el búfer con el nombre específicado como aquel que quieres copiar, o si tal búfer no existe, que debe créarlo. Luego, la función <code>with-current-buffer</code> evalúa su cuerpo con este búfer temporal.</p>
<p>(Esto demuestra otra forma de cambiar la atención de la computadora pero no por parte del usuario. La función <code>append-to-buffer</code> muestro como hacer lo mismo con <code>save-excursion</code> y <code>set-buffer</code>. <code>with-current-buffer</code> es un nuevo mecanismo, posiblemente mas sencillo.)</p>
<p>La función <code>barf-if-buffer-read-only</code> envía un mensaje de error diciendo que el búfer es de solo lectura si no se puede modificar.</p>
<p>La siguiente línea tiene la función <code>erase-buffer</code> como su único contenido. Este función borra el búfer.</p>
<p>Finalmente, las últimas dos líneas contienen la expresión <code>save-excursion</code> con <code>insert-buffer-substring</code> como su cuerpo. La expresión <code>insert-buffer-substring</code> copia el texto desde el búfer en el que te encuentras (y no has visto que el computador cambie su atención, por lo que no sabes que ese búfer ahora se llama <code>oldbuf</code>).</p>
<p>Por cierto, esto es lo que se entiende por ‘reemplazo’. Para reemplazar el texto Emacs borra el texto anterior y luego inserta el texto nuevo.</p>
<p>A grandes rasgos, el cuerpo de <code>copy-to-buffer</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">enlazar-oldbuf-al-valor-del-bufer-actual</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">con-el-bufer-al-que-estas-copiando</span>
      <span class="p">(</span><span class="nv">pero-no-borrar-o-copiar-a-un-bufer-de-solo-lectura</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">erase-buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">save-excursion</span>
        <span class="nv">insertar-la-subcadena-de-oldbuf-en-el-bufer</span><span class="p">)))</span>
</code></pre>
</div>
<h3 id="la-definición-de-insert-buffer" >La definición de <code>insert-buffer</code></h3>
<div class="hBody-3" >
<p><code>insert-buffer</code> es otra función relacionada con búfers. Este comando copia otro búfer <em>dentro</em> del búfer actual. Es lo contrario a <code>append-to-buffer</code> o <code>copy-to-buffer</code>, dado que copia una región de texto <em>desde</em> el búfer actual a otro búfer.</p>
<p>Aquí examinamos en el código original. El código fue simplificado en 2003 y es mas dificil de entender.</p>
<p>(Vea la Seccion <a href="#nuevo-cuerpo-para-insert-buffer" >Nuevo Cuerpo para <code>insert-buffer</code></a>, para ver una discusión del nuevo cuerpo.)</p>
<p>Además, este código ilustra el uso de <code>interactive</code> con un búfer que podría ser <dfn>read-only</dfn> (de solo lectura) y la importante distinción entre el nombre de un objeto y el objeto al que realmente hace referencia.</p>
<p>Aquí está el código anterior:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&#34;Insertar despues del punto el contenido de BUFFER.
</span><span class="s">Coloca la marca despues del texto insertado.
</span><span class="s">BUFFER puede ser un buffer o el nombre de un buffer.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*bInsert buffer: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">newmark</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nb">save-excursion</span>
        <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">push-mark</span> <span class="nv">newmark</span><span class="p">)))</span>
</code></pre>
<p>Al igual que con otras definiciones de función, se puede usar una plantilla para ver un esquema de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*bInsert buffer: &#34;</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="la-expresión-interactiva-en-insert-buffer" >La expresión interactiva en <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>En <code>insert-buffer</code>, el argumento de la declaración <code>interactive</code> tiene dos partes, un asterisco, <samp>*</samp>, y <samp>bInsert buffer: </samp>.</p>
</div>
<h5 id="un-búfer-de-solo-lectura" >Un búfer de solo lectura</h5>
<div class="hBody-5" >
<p>El asterisco se utliza cuando el búfer actual es un búfer de solo lectura––un búfer que no puede ser modificado. Si se llama a <code>insert-buffer</code> cuando el búfer actual es de solo lectura, se imprime un mensaje en el area de eco y el terminal puede emitir un beep o parpadear; no se permitira insertar nada en el búfer actual. El asterisco no tiene que ser seguido por un salto de linea para separarlo del siguiente argumento.</p>
</div>
<h5 id="b-en-una-expresión-interactiva" ><samp>b</samp> en una expresión interactiva</h5>
<div class="hBody-5" >
<p>El siguiente argumento de la expresión interactiva inicia con una letra <samp>b</samp> minúscula. (Esto es diferente del código para <code>append-to-buffer</code>, que utiliza una <samp>B</samp> mayúscula. Vea la Seccion <a href="#la-definición-de-append-to-buffer" >La Definición de <code>append-to-buffer</code></a>.) La <samp>b</samp> minúscula le indica al intérprete Lisp que el argumento de <code>insert-buffer</code> debe ser un buffer existente o su nombre. (La opcion <samp>B</samp> mayúscula permite la posibilidad que el búfer no exista.)  Emacs te pedira el nombre del búfer, ofreciendo un búfer por defecto, con el autocompletado de nombre habilitado. Si el búfer no existe, recibiras un mensaje que dice “No match” (<q>no concuerda</q>); tu terminal tambien puede emitir un beep.</p>
<p>El nuevo código simplificado genera una lista <code>interactive</code>. Este utiliza las funciones <code>barf-if-buffer-read-only</code> y <code>read-buffer</code> con las que ya estamos familiarizados y la forma especial <code>progn</code> con la que no lo estamos. (Se describira mas adelaste).</p>
</div>
<h4 id="el-cuerpo-de-la-función-insert-buffer" >El cuerpo de la función <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>insert-buffer</code> tiene dos partes principales: una expresión <code>or</code> y una expresión <code>let</code>. El propósito de la expresión <code>or</code> es asegurar que el argumento <code>buffer</code> esta unido a un búfer y no es solo el nombre de un búfer. El cuerpo de la expresión <code>let</code> contiene el código que copia el otro búfer dentro del búfer actual.</p>
<p>A grades rasgos, las dos expresiones encajan asi en la función <code>insert-buffer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">insert-buffer</span> <span class="p">(</span><span class="nv">buffer</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*bInsert buffer: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="err">…</span>
      <span class="err">…</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">varlist</span><span class="p">)</span>
      <span class="nv">cuerpo-de-let</span><span class="err">…</span> <span class="p">)</span>
</code></pre>
<p>Para entender como la expresión <code>or</code> asegura que el argumento <code>buffer</code> esta unido a un buffer y no al nombre de un búfer, primero es necesario entender la función <code>or</code>.</p>
<p>Antes de hacer esto, permíteme reescribir esta parte de la función utilizando <code>if</code> de esta manera puedes ver como se hace de una manera que resulta familiar.</p>
</div>
<h4 id="insert-buffer-con-un-if-en-lugar-de-un-or" ><code>insert-buffer</code> con un <code>if</code> en lugar de un <code>or</code></h4>
<div class="hBody-4" >
<p>El trabajo a realizar es asegurarse de que el valor de <code>buffer</code> sea un búfer en sí mismo y no el nombre de un búfer. Si el valor es el nombre, entonces debe optenerse el búfer en sí.</p>
<p>Puedes imaginarte a tí mismo en una conferencia donde un acomodador está observando una lista con tu nombre en ella y mirándote: el acomodador sabe “asociar” tu nombre, no a tí; pero cuando el acomodador te encuentra y te toma el brazo, el acomodador llega a “asociarte” a tí.</p>
<p>En Lisp, se podría describir esta situación así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nv">tomar-al-invitado</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">encontrar-y-tomar-del-brazo-al-invitado</span><span class="p">))</span>
</code></pre>
<p>Queremos hacer lo mismo con un búfer––si no tenemos el búfer en sí, queremos conseguirlo.</p>
<p>Usando un predicado llamado <code>bufferp</code> que nos informa si tenemos un búfer (en lugar de su nombre), podemos escribir el código de esta manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">))</span>              <span class="c1">; parte-if</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>  <span class="c1">; parte-then</span>
</code></pre>
<p>Aquí, la prueba verdadero-o-falso de la expresión <code>if</code> es <code>(not (bufferp buffer))</code>; y la parte <em>then</em> es la expresión <code>(setq buffer (get-buffer buffer))</code>.</p>
<p>En la prueba, la función <code>bufferp</code> devuelve cierto si su argumento es un búfer––sino falso si el argumento es el nombre del búfer. (El último carácter del nombre de la función <code>bufferp</code> es el carácter <samp>p</samp>; como vimos anteriormente, tal uso de <samp>p</samp> es una convención que indica que la función es un predicado, que es un término que significa que la función determinará si alguna propiedad es verdadera o falsa. Vea la Seccion <a href="#usando-el-tipo-incorrecto-de-objeto-como-un-argumento" >Usando el tipo incorrecto de objeto como un argumento</a>.)</p>
<p>La función <code>not</code> precede la expresión <code>(bufferp buffer)</code>, así la prueba verdadero-o-falso es la siguente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">))</span>
</code></pre>
<p><code>not</code> es una función que devuelve verdadero si su argumento es falso y falso si su argumento es verdadero. Por lo que si <code>(bufferp buffer)</code> devuelve cierto, la expresión <code>not</code> devuelve falso y vice-versa: lo que es “no verdadero” es falso y lo que es “no falso” es verdadero.</p>
<p>Usando esta prueba, la expresión <code>if</code> funciona de la siguiente manera: cuando el valor de la variable <code>buffer</code> es en realidad un búfer en lugar de su nombre, la prueba verdadero-o-falso devuelve falso y la expresión <code>if</code> no evalúa la parte then. Esto está bien, ya que no tenemos que hacer nada para la variable <code>buffer</code> si realmente es un búfer.</p>
<p>Por otro lado, cuando el valor de <code>buffer</code> no es un buffer en sí, pero si el nombre de un buffer, la prueba verdadero-o-falso devuelve verdadero y se evalua la parte then de la expresión. En este caso, la parte then es <code>(setq buffer (get-buffer buffer))</code>. Esta expresión utiliza la función <code>get-buffer</code> para devolver un buffer en real, dado su nombre. Luego <code>setq</code> asigna la variable <code>buffer</code> reemplazando su valor anterior (que era el nombre del buffer).</p>
</div>
<h4 id="el-or-en-el-cuerpo" >El <code>or</code> en el cuerpo</h4>
<div class="hBody-4" >
<p>El propósito de la expresión <code>or</code> en la función <code>insert-buffer</code> es asegurar que el argumento <code>buffer</code> está asociado a un búfer y no solo al nombre de un búfer. La sección previa muestra como se podría haber hecho el trabajo usando una expresión <code>if</code>. Sin embargo, la función <code>insert-buffer</code> utiliza <code>or</code>. Para entender esto, es necesario entender como funciona <code>or</code>.</p>
<p>Una función <code>or</code> puede tener cualquier número de argumentos. Esta evalúa un argumento a la ves y devuelve el valor del primero de sus argumentos que no es <code>nil</code>. Ademas, y esta es una caracteristica crucial de <code>or</code>, es no evalúar los argumentos posteriores después de regresar el primer valor no-<code>nil</code>.</p>
<p>La expresión <code>or</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">bufferp</span> <span class="nv">buffer</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">)))</span>
</code></pre>
<p>El primer argumento de <code>or</code> es la expresión <code>(bufferp buffer)</code>. Esta expresión devuelve verdadero (un valor no-<code>nil</code>) si el búfer es realmente un búfer, y no solo el nombre de un búfer. En la expresión <code>or</code>, si este es el caso, la expresión <code>or</code> devuelve este valor verdadero y no evalúa la siguiente expresión––y esto es bueno para nosotros, ya que no queremos hacer nada al valor de <code>buffer</code> si realmente es un búfer.</p>
<p>Por otro lado, si el valor de <code>(bufferp buffer)</code> es <code>nil</code>, si el valor de <code>buffer</code> es el nombre de un buffer, el intérprete Lisp evalúa el siguiente elemento de la expresión. Esta es la expresión <code>(setq buffer (get-buffer buffer))</code>. Esta expresión devuelve un valor no-<code>nil</code>, que es el valor para el que asigna la variable <code>buffer</code>––y este valor es un búfer en sí, no el nombre de un búfer.</p>
<p>El resultado de todo esto es que el símbolo <code>buffer</code> siempre se enlaza a un búfer en sí en vez de al nombre de un búfer. Todo esto es necesario debido a que la función <code>set-buffer</code> en la línea siguiente solo funciona con un buffer en sí, no con el nombre de un búfer.</p>
<p>A proposito, usando <code>or</code>, la escena con el acomodador se escribiria así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">tomar-al-invitado</span><span class="p">)</span> <span class="p">(</span><span class="nv">encontrar-y-tomar-del-brazo-al-invitado</span><span class="p">))</span>
</code></pre>
</div>
<h4 id="la-expresión-let-en-insert-buffer" >La expresión <code>let</code> en <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>Después de asegurarse que la variable <code>buffer</code> se refiere a un buffer en sí y no solo al nombre de uno, la función <code>insert-buffer</code> continúa con una expresión <code>let</code>. Esta especifica tres variables locales, <code>start</code>, <code>end</code> y <code>newmark</code> y las une al valor inicial <code>nil</code>. Estas variables se utilizan dentro del resto de <code>let</code> y ocultan temporalmente cualquier otra ocurrencia de variables con el mismo nombre en Emacs hasta el final de <code>let</code>.</p>
<p>El cuerpo de <code>let</code> contiene dos expresiones <code>save-excursion</code>. Primero, veremos la expresión interna <code>save-excursion</code> en detalle. La expresión se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
</code></pre>
<p>La expresión <code>(set-buffer buffer)</code> cambia la atención de Emacs del búfer actual al buffer del que se copiara el texto. En ese búfer las variables <code>start</code> y <code>end</code> se asignan al inicio y al fin del búfer, usando los comandos <code>point-min</code> y <code>point-max</code>. Tenga en cuenta que aquí tenemos un ejemplo de cómo <code>setq</code> es capaz de asignar dos variables en la misma expresión. El primer argumento de <code>setq</code> se establece al valor del segundo, y su tercer argumento se establece al valor del cuarto.</p>
<p>Después de evaluar el interior del cuerpo de <code>save-excursion</code>, <code>save-excursion</code> restaura el búfer original, pero <code>start</code> y <code>end</code> retienen los valores del inicio y fin del búfer del que se copiara el texto.</p>
<p>La expresión extena de <code>save-excursion</code> luce asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="p">(</span><span class="nv">expresion-interior-de-save-excursion</span>
     <span class="p">(</span><span class="nv">ir-al-nuevo-bufer-y-establecer-start-y-end</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</code></pre>
<p>La función <code>insert-buffer-substring</code> copia el texto <em>dento</em> del búfer actual <em>desde</em> la región indicada por <code>start</code> y <code>end</code> en el <code>búfer</code>. Puesto que la totalidad del segundo búfer se encuentra entre <code>start</code> y <code>end</code>, todo dentro del segundo búfer se copia el el bufer que se esta editando. A continuacion, el valor del punto, que será al fin del texto insertado, se registra en la variable <code>newmark</code>.</p>
<p>Después evaluar el cuerpo del <code>save-excursion</code> externo, el punto y la marca se vuelven a colocar en su posicion original.</p>
<p>Sin embargo, es conveniente ubicar una marca al fin del texto recien insertado y ubicar el punto al principio. La variable <code>newmark</code> registra el fin del texto insertado. En la última línea de la expresión <code>let</code>, la expresión <code>(push-mark newmark)</code> asigna una marca a esta posición. (La posición anterior de la marca aun es accesible; está grabada en el anillo de marcas y puedes volver a ella con <kbd>C-u C-SPC</kbd>.) Mientras tanto, el punto se encuentra al principio del texto insertado, que es donde estaba antes de llamar a la función de insercion, cuya posición fue guardada por la primer <code>save-excursion</code>.</p>
<p>La expresión <code>let</code> completa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">newmark</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span> <span class="nv">end</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="nv">buffer</span> <span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">newmark</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="nv">newmark</span><span class="p">))</span>
</code></pre>
<p>Al igual que la función <code>append-to-buffer</code>, la función <code>insert-buffer</code> utiliza <code>let</code>, <code>save-excursion</code> y <code>set-buffer</code>. Además, la función ilustra una forma de utilizar <code>or</code>. Todas estas funciones son bloques de construccion que vamos a encontrar y utilizar una y otra vez.</p>
</div>
<h4 id="nuevo-cuerpo-para-insert-buffer" >Nuevo cuerpo para <code>insert-buffer</code></h4>
<div class="hBody-4" >
<p>El cuerpo en la versión 22 de GNU Emacs es más confuso que en el original.</p>
<p>Consta de dos expresiones</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nv">push-mark</span>
   <span class="p">(</span><span class="nb">save-excursion</span>
     <span class="p">(</span><span class="nf">insert-buffer-substring</span> <span class="p">(</span><span class="nf">get-buffer</span> <span class="nv">buffer</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>

   <span class="no">nil</span>
</code></pre>
<p>excepto que, y esto es lo que confunde a los principiantes, se hace un trabajo muy importante al interior de la expresión <code>push-mark</code>.</p>
<p>La función <code>get-buffer</code> devuelve un búfer con el nombre proporcionado. Notaras que la función <em>no</em> se llama <code>get-buffer-create</code>; esta no crea un búfer si uno no existe ya. El búfer devuelto por <code>get-buffer</code>, un búfer existente, se pasa a <code>insert-buffer-substring</code>, que inserta todo el búfer (ya que no se especifica ninguna cosa más).</p>
<p>La posición donde se inserta el buffer se registra por <code>push-mark</code>. Despues la función devuelve <code>nil</code>, el valor de su último comando. Dicho de otra manera, la función <code>insert-buffer</code> existe solo para producir un efecto secundario, insertando otro buffer, no para devolver ningun valor.</p>
</div>
<h3 id="definición-completa-de-beginning-of-buffer" >Definición completa de <code>beginning-of-buffer</code></h3>
<div class="hBody-3" >
<p>Ya se ha discutido la estructura básica de la función <code>beginning-of-buffer</code>. (Vea la Seccion <a href="#una-definición-simplificada-de-beginning-of-buffer" >Una definición simplificada de <code>beginning-of-buffer</code></a>). Esta sección describe la parte compleja de la definición.</p>
<p>Como se ha descrito anteriormente, cuando se invoca <code>beginning-of-buffer</code> sin argumento, mueve el cursor al inicio del búfer (en realidad, al inicio de la porción accesible del búfer), dejando la marca en la posición anterior. Sin embargo, cuando el comando se invoca con un número entre uno y diez, la función considera que ese número es una fracción del tamaño del búfer, medido en decenas, y Emacs mueve el cursor a dicha fracción del reccorrido desde el inicio del búfer. Por lo tanto, puedes llamar a esta función con el comando de teclado <kbd>M-&lt;</kbd>, que moverá el cursor al principio del búfer, o con un comando de teclado como <kbd>C-u 7 M-&lt;</kbd> que moverá el cursor a un 70% del recorrido a través del búfer. Si se utiliza un número mayor a diez como argumento, se movera al final del búfer.</p>
<p>La función <code>beginning-of-buffer</code> puede llamarse con o sin argumentos. El uso del argumento es opcional.</p>
</div>
<h4 id="argumentos-opcionales" >Argumentos opcionales</h4>
<div class="hBody-4" >
<p>A menos que se diga lo contrario, Lisp espera que una función con un argumento en su definición de función sea llamada con un valor para ese argumento. Si esto no ocurre, se obtiene un error y un mensaje que dice <samp>Wrong number of arguments</samp> (<q>Número de argumentos erróneo</q>).</p>
<p>Sin embargo, los argumentos opcionales son una caracteristica de Lisp: se utiliza una <dfn>palabra clave</dfn> en concreto para decirle al intérprete Lisp que un argumento es opcional. La palabra clave es <code>&amp;optional</code>. (El <samp>&amp;</samp> al frente de <samp>optional</samp> es parte de la palabra clave.) En una definición de función, si un argumento va despues de la palabra clave <code>&amp;optional</code>, no necesita pasar ningún valor para este argumento al llamar a la función.</p>
<p>Por lo tanto la primera línea de la definición de función de <code>beginning-of-buffer</code> tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
</code></pre>
<p>En lineas generales, toda la función se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;P&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">es-el-argumento-una-cons-cell</span> <span class="nv">argumento</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="nv">ambos-transient-mark-mode-y-mark-active-son-verdadero</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">push-mark</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">determina-el-tamano-y-lo-establece</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">goto-char</span>
    <span class="p">(</span><span class="nv">si-hay-un-argumento</span>
        <span class="nv">averigua-donde-ir</span>
      <span class="nv">de-otro-modo-va-a</span>
      <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
   <span class="nv">do-nicety</span>
</code></pre>
<p>La función es similar a la función <code>simplified-beginning-of-buffer</code> excepto que la expresión <code>interactive</code> tiene <code>&#34;P&#34;</code> como argumento y la función <code>goto-char</code> es seguida por una expresión if-then-else que calcula donde poner el cursor si hay un argumento que no es un cons cell.</p>
<p>(Puesto que no explico que es un <em>cons cell</em> en muchos capítulos, por favor, considera ignorar la función <code>consp</code>. Ve la Seccion <a href="#cómo-se-implementan-las-listas" >Cómo se implementan las listas</a>, y la Seccion <a href="info:elisp#Cons-Cell-Type" >&#34;Cons Cell y Tipos de Listas&#34;</a> en <em>El Manual de Referencia GNU Emacs Lisp</em>).</p>
<p>La <code>&#34;P&#34;</code> en la expresión <code>interactive</code> le indica a Emacs cómo pasar a la funcion argumento prefijo, si es que hay uno, en su forma <q>plana</q> sin procesar. Un argumento prefijo se crea presionando la tecla <kbd>META</kbd> seguida por un número, o pulsando <kbd>C-u</kbd> y luego un número. (Si no escribes un número, <kbd>C-u</kbd> por defecto pasa un cons cell con un 4. Una <code>&#34;p&#34;</code> minúscula en la expresión <code>interactive</code> hace que la función convierta un argumento prefijo a un número.)</p>
<p>La prueba verdadero-o-falso de la expresión <code>if</code> parace compleja, pero no lo es: se comprueba si <code>argumento</code> tiene un valor que no es <code>nil</code> y si es un cons cell. (Esto es lo que hace <code>consp</code>; comprueba si su argumento es un cons cell.) Si <code>argumento</code> tiene un valor distinto a <code>nil</code> (y no es un cons cell), que será el caso si <code>beginning-of-buffer</code> se llama con un argumento numerico, la prueba verdadero-o-falso devolverá verdadero y se evaluara la parte-then de la expresión <code>if</code>. Por otro lado, si <code>beginning-of-bufer</code> no se llama con un argumento, el valor de <code>argumento</code> será <code>nil</code> y se evaluara la parte-else de la expresión <code>if</code>. La parte-else es un simple <code>point-min</code>, y cuando este es el resultado, toda la expresión <code>goto-char</code> es <code>(goto-char (point-min))</code>, que es cómo vimos la función <code>beginning-of-buffer</code> en su forma simplificada.</p>
</div>
<h4 id="beginning-of-buffer-con-un-argumento" ><code>beginning-of-buffer</code> con un argumento</h4>
<div class="hBody-4" >
<p>Cuando se llama a <code>beginning-of-buffer</code> con un argumento, se evalua una expresión que calcula que valor pasar a <code>goto-char</code>. A primera vista esta expresion es bastante compleja. Incluye una expresión <code>if</code> y mucha aritmética. Se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">buffer-size</span><span class="p">)</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="c1">;; Evita el desbordamiento en buffers de gran tamaño!</span>
    <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span>
        <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
     <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Como otras expresiones que parecen complejas, la expresión condicional dentro de <code>beginning-of-buffer</code> se puede desenredar viendola como partes de una plantilla, en este caso, la plantilla para una expresión if-then-else. En forma esquelética, la expresión se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">si</span> <span class="p">(</span><span class="nv">buffer-es-grande</span>
    <span class="nv">divide-el-tamaño-del-buffer-por-10-y-multiplicalo-por-arg</span>
  <span class="nv">de-otra-forma-utiliza-el-calculo-alternativo</span>
</code></pre>
<p>La prueba verdadero-o-falso de la expresión <code>if</code> interna comprueba el tamaño del buffer. La razón de esto es que la vieja versión de Emacs 18 utilizaba números que no superaban los ocho millones y en el siguiente calculo, el programador temía que Emacs pudiera intentar usar numeros demasiado grandes si el búfer fuese extenso. El término ‘desbordamiento’, que se menciona en el comentario, significa que los números son demaciado grandes. Las versiones más recientes de Emacs utilizan números mas grandes, pero este código no ha sido tocado, aunque solo sea porque la gente ahora mira búfers que son mucho, mucho mas grandes que antes.</p>
<p>Hay dos casos: si el búfer es grande, o si no lo es.</p>
</div>
<h5 id="qué-ocurre-en-un-búfer-de-gran-tamaño" >Qué ocurre en un búfer de gran tamaño</h5>
<div class="hBody-5" >
<p>En <code>beginning-of-buffer</code>, la expresión <code>if</code> interna prueba si el tamaño del búfer es mayor a 10000 caracteres. Para hacer esto, se utiliza la función <code>&gt;</code> y el calculo de <code>size</code> que previene de la expresión <code>let</code>.</p>
<p>En los viejos tiempos, se utilizaba la función <code>buffer-size</code>. No solo se llamo varias ocaciones esa funcion, sino que die el tamaño completo del búfer, no la parte accesible. El calculo tiene mucho más sentido cuando se maneja solo la parte accesible. (Vea la Seccion <a href="#reducir-y-extender" >Reducir y Extender</a>, para obtener más información sobre como centrar la atención en una parte ‘accesible’.)</p>
<p>La linea se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">size</span> <span class="mi">10000</span><span class="p">)</span>
</code></pre>
<p>Cuando el búfer es grande, se evalua la parte <code>then</code> de la expresión <code>if</code>. Se lee así (después de formatearlo para facilitar la lectura):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span>
  <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Esta expresión es una multiplicación, con dos argumentos para la función <code>*</code>.</p>
<p>El primer argumento es <code>(prefix-numeric-value arg)</code>. Cuando se usa <code>&#34;P&#34;</code> como argumento para <code>interactive</code>, el valor pasado a la función como argumento es un “argumento prefijo en bruto”, y no un número. (Es un número en una lista). Para realizar el calculo, se necesita una conversión, y <code>prefix-numeric-value</code> hace el trabajo.</p>
<p>El segundo argumento es <code>(/ size 10)</code>. Esta expresión divide el valor numérico por diez––el valor numérico del tamaño de la porción accesible del búfer. Esto produce un número que indica cuántos caracteres componen una decena parte del tamaño del búfer. (En Lisp, <code>/</code> se utiliza para la división, igual que <code>*</code> se utiliza para la multiplicación.)</p>
<p>En la expresión de multiplicación como un todo, esta cantidad se multiplica por el valor del argumento prefijo––la multiplicación es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="nv">valor-numerico-del-argumento-prefijo-arg</span>
   <span class="nv">numero-de-caracteres-en-una-decima-parte-de-la-porcion-accesible-del-buffer</span><span class="p">)</span>
</code></pre>
<p>Por ejemplo, si el argumento prefijo es <samp>7</samp>, el valor de una decima parte será multiplicado por 7 para dar una posición al 70% del trayecto.</p>
<p>El resultado de todo esto es que si la porción accesible del búfer es grande, la expresión <code>goto-char</code> es la siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">)))</span>
</code></pre>
<p>Esto coloca el cursor donde lo queremos.</p>
</div>
<h5 id="lo-que-sucede-en-un-búfer-pequeño" >Lo que sucede en un búfer pequeño</h5>
<div class="hBody-5" >
<p>Si el búfer contiene menos de 10000 caracteres, se lleva a cabo un calculo ligeramente diferente. Podrías pensar que esto no es necesario, ya que el primer calculo podría hacer el trabajo. Sin embargo, en un búfer pequeño, el primer método puede no colocar el cursor exactamente en la línea deseada; el segundo método hace un mejor trabajo.</p>
<p>El código tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span> <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Para averiguar que ocure en este código debemos descubrir como se anidan las funciones entre paréntesis. Es mas fácil de leer si se reformate cada expresión, indentando la expresión que contiene:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nf">/</span>
   <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span>
      <span class="p">(</span><span class="nf">*</span>
       <span class="nv">size</span>
       <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
   <span class="mi">10</span><span class="p">))</span>
</code></pre>
<p>Observando los paréntesis, vemos que la operación mas profunda es <code>(prefix-numeric-value arg)</code>, que convierte el argumento prefijo en bruto a un número. En la siguiente expresión, este número se multiplica por el tamaño de la porción accesible del búfer:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">))</span>
</code></pre>
<p>Esta multiplicación crea un número que puede ser mayor al tamaño del buffer––siete veces mayor si el argumento es 7, por ejemplo. Luego se suma diez a éste numero y finalmente el número es dividido por 10 para proporcionar un valor que es un carácter más grande que la posición porcentual en el búfer.</p>
<p>El número que resulta de todo esto se pasa a <code>goto-char</code> y el cursor se mueve a ese punto.</p>
</div>
<h4 id="funcion-beginning-of-buffer-completa" >Funcion <code>beginning-of-buffer</code> Completa</h4>
<div class="hBody-4" >
<p>Aquí está el texto completo de la función <code>beginning-of-buffer</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">beginning-of-buffer</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;Mueve el punto al principio del bufer;
</span><span class="s">deja la marca en la posicion anterior.
</span><span class="s">Con el prefijo \\[universal-argument],
</span><span class="s">no pone la marca en la posicion anterior.
</span><span class="s">Con un argumento numerico N,
</span><span class="s">coloca el punto N/10 del camino desde el enicio.
</span><span class="s">
</span><span class="s">Si el bufer tiene activo narrowing,
</span><span class="s">este comando utiliza el principio y el tamaño
</span><span class="s">de la parte accesible del bufer.
</span><span class="s">
</span><span class="s">No use este comando en los programas Lisp!
</span><span class="s">\(goto-char (point-min)) es mas rapido y evita
</span><span class="s">tocar la marca.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;P&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="nv">transient-mark-mode</span> <span class="nv">mark-active</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">push-mark</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">size</span> <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">arg</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)))</span>
                   <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">)</span>
                      <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">size</span> <span class="mi">10000</span><span class="p">)</span>
                          <span class="c1">;; Avoid overflow for large buffer sizes!</span>
                          <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">/</span> <span class="nv">size</span> <span class="mi">10</span><span class="p">))</span>
                        <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">10</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">size</span> <span class="p">(</span><span class="nf">prefix-numeric-value</span> <span class="nv">arg</span><span class="p">)))</span>
                           <span class="mi">10</span><span class="p">)))</span>
                 <span class="p">(</span><span class="nf">point-min</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre>
<p>Excepto por dos pequeños puntos, la discusión anterior muestra cómo funciona esta función. El primer punto se refiere a un detalle en la cadena de documentación, y el segundo se refiere a la última línea de la función.</p>
<p>En la cadena de documentación, se hace referencia a una expresión:</p>
<div class="example-block" >
<pre class="example" >\\[universal-argument]
</pre>
</div>
<p>Se usa Un <samp>\\</samp> antes del primer corchete de esta expresión. Este <samp>\\</samp> le indica al intérprete Lisp que sustituya cualquier clave qué se encuentre dentro de <samp>[…]</samp> por su convinacion de teclado actual. En el caso de <code>universal-argument</code>, suele ser <kbd>C-u</kbd>, pero podría ser distinta. (Véa la Sección <a href="info:elisp#Documentation-Tips" >Consejos para Cadenas de Documentación</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.)</p>
<p>Finalmente, la última línea del comando <code>beginning-of-buffer</code> indica mover el punto al inicio de la siguiente línea si el comando se invoca con un argumento:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)))</span>
</code></pre>
<p>Esto pone el cursor al inicio de la primer línea despues de la posicion inidicada en decenas en el búfer. Esto significa que el cursor siempre se localiza <em>al menos</em> las decenas solicitadas del recorrido del búfer, esta es una sutiliza, quizás, no necesaria, pero que, si no ocurriera, seguro generaria quejas.</p>
<p>Por otro lado, tambien significa que si se especifica el comando con <kbd>C-u</kbd>, pero sin un número, es decir, si el ‘argumento prefijo en bruto’ simplemente es un cons cell, entonces el comando te coloca al inicio de la segunda línea … no sé si se pretende esto o si nadie ha tratado el código para evitar que esto suceda.</p>
</div>
<h3 id="repaso:-algunas-funciones-más-complejas" >Repaso</h3>
<div class="hBody-3" >
<p>He aquí un breve resumen de algunos de los temas cubiertos en este capítulo.</p>
<dl>
<dt><code>or</code></dt>
<dd>
<p>Evalúa cada argumento en secuencia, y devuelve el valor del primer argumento que no es <code>nil</code>, si ninguno devuelve un valor que no sea <code>nil</code>, devuelve <code>nil</code>. En resumen, devuelve el primer valor verdadero de los argumento; devuelve un valor verdadero si uno <em>o</em> cualquiera de los otros es verdadero.</p>
</dd>
<dt><code>and</code></dt>
<dd>
<p>Evalúa cada argumento en secuencia, y si alguno es <code>nil</code>, devuelve <code>nil</code>; si ninguno es <code>nil</code>, devuelve el valor del último argumento. En resumen, devuelve un valor verdadero solo si todos los argumentos son verdaderos; devuelve un valor verdadero si uno <em>y</em> cada uno de los otros son verdadero.</p>
</dd>
<dt>&amp;optional</dt>
<dd>
<p>Una palabra clave utilizada para indicar que un argumento en una definición de función es opcional; esto significa que la función se puede evaluar sin el argumento, si se desea.</p>
</dd>
<dt><code>prefix-numeric-value</code></dt>
<dd>
<p>Convierte el ‘argumento prefijo en bruto’ producido por <code>(interactive &#34;P&#34;)</code> en un valor numérico.</p>
</dd>
<dt><code>forward-line</code></dt>
<dd>
<p>Mueve el punto hacia adelante al principio de la siguiente línea, o si el argumento es mayor a uno, hacia delante varias líneas. Si no se puede mover tan lejos hacia delante como se supone, <code>forward-line</code> va hacia adelante tan lejos como pueda y luego devuelve un conteo del número de líneas adicionales que no se pudo mover.</p>
</dd>
<dt><code>erase-buffer</code></dt>
<dd>
<p>Elimina todo el contenido del búfer actual.</p>
</dd>
<dt><code>bufferp</code></dt>
<dd>
<p>Devuelve <code>t</code> si su argumento es un búfer; de otro modo devuelve <code>nil</code>.</p>
</dd>
</dl>
</div>
<h3 id="ejercicio-con-el-argumento-opcional" >Ejercicio con el argumento <code>opcional</code></h3>
<div class="hBody-3" >
<p>Escribe una función interactiva con un argumento opcional que comprueve si su argumento, un número, es mayor que o igual a, o de lo contrario, menor que el valor de <code>fill-column</code>, y lo informe, en un mensaje. Sin embargo, si no pasas un argumento a la función, utiliza 56 como valor por defecto.</p>
</div>
<h2 id="reducir-y-extender" >Reducir y Extender</h2>
<div class="hBody-2" >
<p>La reduccion es una funcionalidad de Emacs que hace posible que puedas focalizarte en una parte específica de un búfer, y trabajar sin cambiar accidentalmente otras partes. La reduccion normalmente se deshabilita ya que puede confundir a los principiantes.</p>
<p>Con la reduccion, el resto del búfer se hace invisible, como si no estuviera alli. Esto es una ventaja si, por ejemplo, se quiere reemplazar una palabra en una parte del búfer pero no en otra: limitas la parte que deseas y el reemplazo se lleva a cabo solo en esa sección, no en el resto del búfer. Las búsquedas solo funcionarán con la región reducida, no fuera de ella, de esta forma si estás reparando una parte de un documento, puedes mantener fuera la parte que no necesitas. (El atajo asociado a <code>narrow-to-region</code> es <kbd>C-x n n</kbd>.)</p>
<p>Sin embargo, la reduccion hace invisible el resto del búfer, lo que puede asustar a quien invoca inadvertidamente la reduccion y piensa que ha eliminado una parte de su fichero. Ademas, el comando <code>undo</code> (usualmente ligado a <kbd>C-x u</kbd>) no desactiva la reduccion (ni debe hacerlo), por lo que las personas pueden llegar a desesperarse si no saben que pueden devolver el resto del buffer visible cor el comando <code>widen</code> que es <kbd>C-x n w</kbd>.)</p>
<p>La reduccion es igual de util para el intérprete Lisp como para un humano. Con frecuencia, una función Emacs Lisp está diseñada para trabajar solo en parte de un búfer; o por el contrario, una función Emacs Lisp necesita trabajar en todo un búfer que ha sido reducido. La función <code>what-line</code>, por ejemplo, elimina la reduccion de un búfer, si este tiene alguna reduccion y al terminar su trabajo, restaura la reduccion. Por otro lado, la función <code>count-lines</code> utiliza la reduccion para restringirse a sí misma solo a la porción del búfer en la que se está interesado y luego restablece la situación anterior.</p>
</div>
<h3 id="la-forma-especial-save-restriction" >La forma especial <code>save-restriction</code></h3>
<div class="hBody-3" >
<p>En Emacs Lisp, se puede utilizar la forma especial <code>save-restriction</code> para llevar un registro de cualquier reduccion en efecto. Cuando el intérprete Lisp se encuentra con <code>save-restriction</code>, ejecuta el código en el cuerpo de la expresión <code>save-restriction</code>, y luego deshace cualquier cambio en la reduccion que el código proboco. Si, por ejemplo, el búfer es reducido y el código que sigue al comando <code>save-restriction</code> se deshace de la reduccion, <code>save-restriction</code> devuelve el búfer a su región reducida.  En el comando <code>what-line</code>, cualquier reduccion del búfer es deshecha por el comando <code>widen</code> inmediatamente despues del comando <code>save-restriction</code>. Se restaura cualquier reduccion original justo antes de finalizar la función.</p>
<p>La plantilla para una expresión <code>save-restriction</code> es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-restriction</span>
  <span class="nv">cuerpo</span><span class="err">…</span> <span class="p">)</span>
</code></pre>
<p>El cuerpo de <code>save-restriction</code> es una o más expresiones que seran evaluadas de forma secuencial por el intérprete Lisp.</p>
<p>Finalmente, un punto a tener en cuenta: cuando utilices <code>save-excursion</code> y <code>save-restriction</code> a la vez, una detras de la otra, debes utilizar <code>save-excursion</code> primero. Si lo escribes en el orden inverso, es posible que no registre la reduccion en el búfer al que emacs debe cambiar Emacs despues de llamar a <code>save-excursion</code>. Por lo tanto, cuando escribas a la vez <code>save-excursion</code> y <code>save-restriction</code> debe ser así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span>
  <span class="p">(</span><span class="nb">save-restriction</span>
    <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</code></pre>
<p>En otras circunstancias, cuando no se escriban a la vez, las formas especiales <code>save-excursion</code> y <code>save-restriction</code> deben escribirse en el orden adecuado para la función.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-restriction</span>
  <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">))</span>
</code></pre>
</div>
<h3 id="what-line" ><code>what-line</code></h3>
<div class="hBody-3" >
<p>El comando <code>what-line</code> informa el número de la línea en la que el cursor esta colocado. La función ilustra el uso de los comandos <code>save-restriction</code> y <code>save-excursion</code>. Aquí está el texto original de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">what-line</span> <span class="p">()</span>
  <span class="s">&#34;Imprime el numero de linea actual (en el bufer) del punto.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-restriction</span>
    <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">save-excursion</span>
      <span class="p">(</span><span class="nf">beginning-of-line</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Line %d&#34;</span>
               <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))))))</span>
</code></pre>
<p>(En versiones recientes de GNU Emacs, la función <code>what-line</code> se ha ampliado para informarte el numero de linea en un búfer reducido, asi como el número de línea en un búfer extendido. La versión reciente es más compleja que la versión que se muestra aqui. Si te sientes aventurero, puede que quieras verla despues de averiguar como funciona esta version. Probablemente necesites utilizar <kbd>C-h f</kbd> (<code>describe-function</code>). La nueva versión utiliza un condicional para determinar si se ha reducido el búfer.</p>
<p>(También, utiliza <code>line-number-at-pos</code>, que entre otras expresiones sencillas, como <code>(goto-char (point-min))</code>, mueve el punto al inicio de la línea actual con <code>(forward-line 0)</code> en lugar de <code>beginning-of-line</code>.)</p>
<p>La función <code>what-line</code> que se muestra aqui tiene una línea de documentación y es interactiva, como es de esperar. Las dos líneas siguientes utilizan las funciones <code>save-restriction</code> y <code>widen</code>.</p>
<p>La forma especial <code>save-restriction</code> observa cualquier reduccion activa, en el buffer actual y restaura la reduccion despues de evaluar el código de su cuerpo.</p>
<p>La forma especial <code>save-restriction</code> es seguida por <code>widen</code>. Esta función deshace cualquier reduccion que pudo haber tenido el búfer actual cuando se llama a <code>what-line</code>. (La reduccion que esta alli es la reduccion que <code>save-restriction</code> recuerda.) Esta ampliación hace posible que los comandos para el conteo de lineas cuenten desde el inicio del búfer. De lo contrario, se habría limitado a contar dentro de la región accesible. Cualquier reduccion original se restaura justo antes de completar la funcion por la forma especial <code>save-restriction</code>.</p>
<p>La llamada a <code>widen</code> va seguida por <code>save-excursion</code>, que guarda la posición del cursor (es decir, el punto) y la marca, y los restaura después despues de que el código en el cuerpo de <code>save-excursion</code> utiliza la función <code>beginning-of-line</code> para mover el punto.</p>
<p>(Ten en cuenta que la expresión <code>(widen)</code> ocurre entre las formas especiales <code>save-restriction</code> y <code>save-excursion</code>. Cuando escribas las dos expresiones <code>save-…</code> consecutivamente, escribe <code>save-excursion</code> primero.)</p>
<p>Las dos últimas líneas de la función <code>what-line</code> son funciones para contar el número de líneas en el búfer y luego imprimir el número en el área de eco.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Line %d&#34;</span>
         <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))))))</span>
</code></pre>
<p>La función <code>message</code> imprime un mensaje de una línea en la parte inferior de la pantalla de Emacs. El primer argumento esta dentro de comillas y se imprime como una cadena de caracteres. Sin embargo, contiene una expresión <samp>%d</samp> para imprimir el siguiente argumento. <samp>%d</samp> imprime el argumento como un decimal, por lo que el mensaje dirá algo como <samp>Línea 243</samp>.</p>
<p>El número que se imprime en lugar del <samp>%d</samp> se calcula por la última línea de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">count-lines</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</code></pre>
<p>Lo que esto hace es contar las líneas desde la primer posición del búfer indicada por el <code>1</code>, hasta <code>(point)</code>, y luego sumar uno a este número. (La función <code>1+</code> suma uno a su argumento.) Se suma uno porque la línea 2 tiene solo una línea antes de ella, y <code>count-lines</code> cuenta solo las líneas <em>antes</em> de la línea actual.</p>
<p>Después que <code>count-lines</code> termina su trabajo, y se imprime el mensaje en el área de eco, la función <code>save-excursion</code> restaura el punto y marca a sus posiciones originales; y <code>save-restriction</code> restaura la reduccion original, si la hubiera.</p>
</div>
<h3 id="ejercicio-con-reduccion" >Ejercicio con Reduccion</h3>
<div class="hBody-3" >
<p>Escribe una función que muestre los primeros 60 caracteres del búfer actual, incluso si has reducido el búfer a la mitad de modo que la primer línea sea inaccesible. Restaura el punto, marca y la reduccion. Para este ejercicio, necesitas utilizar todo un popurri de funciones, incluyendo <code>save-restriction</code>, <code>widen</code>, <code>goto-char</code>, <code>point-min</code>, <code>message</code>, y <code>buffer-substring</code>.</p>
<p>(<code>buffer-substring</code> es una función que no aun no se menciona, tendrás que investigarla por tu cuenta; o quizás tengas que utilizar <code>buffer-substring-no-properties</code> o <code>filter-buffer-substring</code> …, u otras funciones. Las propiedades de texto son una funcionalidad que no sera discutida aquí. Vea la Seccion <a href="info:elisp#Text-Properties" >Propiedades de Texto</a> en <em>El Manual de Referencia de Emacs Lisp</em>.)</p>
<p>Además, ¿realmente se necesita <code>goto-char</code> o <code>point-min</code>?  ¿O se puede escribir la función sin ellas?</p>
</div>
<h2 id="car,-cdr,-cons:-funciones-fundamentales" ><code>car</code>, <code>cdr</code>, <code>cons</code>: Funciones fundamentales</h2>
<div class="hBody-2" >
<p>En Lisp, <code>car</code>, <code>cdr</code>, y <code>cons</code> son funciones fundamentales. La función <code>cons</code> se utiliza para construir listas, y las funciones <code>car</code> y <code>cdr</code> se utilizan para desmontarlas.</p>
<p>En el recorrido a través de la función <code>copy-region-as-kill</code>, veremos <code>cons</code>, asi como dos variantes de <code>cdr</code>, llamadas <code>setcdr</code> y <code>nthcdr</code>. (Véa la Sección <a href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a>.)</p>
<p>El nombre de la función <code>cons</code> no es irazonable: es una abreviatura de la palabra ‘construct’ (<q>construir</q>). Por otra parte, el origen de los nombres <code>car</code> y <code>cdr</code>, es esoterico: <code>car</code> es un acrónimo de la frase ‘Contents of the Address part of the Register’ (<q>Contenidos de las Direcciónes parte del Registro</q>); y <code>cdr</code> (pronunciado ‘could-er’) es un acrónimo de la frase ‘Contents of the Decrement part of the Register’ (<q>Contenidos de la parte de Decremento del Registro</q>). Estas frases se refieren a piezas específicas de hardware en el ordenador en el que se desarrollo el Lisp original. Ademas de ser obsoletas, las frases han sido completamente irrelevantes por más de 25 años para cualquiera que piense en Lisp. No obstante, aunque algunos pocos académicos valientes han empezado a utilizar nombres más razonables para estas funciones, los viejos términos aun continuan en uso. En particular, porque los términos se utilizan en el código fuente de Emacs Lisp, los usaremos en esta introducción.</p>
</div>
<h3 id="car-y-cdr" ><code>car</code> y <code>cdr</code></h3>
<div class="hBody-3" >
<p>El <code>car</code> de una lista es sencillamente, el primer elemento de la lista. De este modo, el <code>car</code> de la lista <code>(rosa violeta margarita tulipan)</code> es <code>rosa</code>.</p>
<p>Si estás leyendo esto en GNU Emacs, puedes verlo evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>Después de evaluar la expresión, aparecerá <code>rosa</code> en el área de eco.</p>
<p>Claramente, un nombre más razonable para la función <code>car</code> sería <code>first</code> y esto es con frecuencia lo que se sugiere.</p>
<p><code>car</code> no elimina el primer elemento de la lista; solo informa de lo que es. Después de aplicar <code>car</code> a una lista, la lista sigue siendo la misma que antes. En la jerga, <code>car</code> es ‘no destructiva’. Esta caracteristica resulta ser importante.</p>
<p>El <code>cdr</code> de una lista es el resto de la lista, es decir, la función <code>cdr</code> devuelve la parte de la lista que sigue al primer elemento. Por lo tanto, mientras que el <code>car</code> de la lista <code>&#39;(rosa violeta margarita tulipan)</code> es <code>rosa</code>, el resto de la lista, el valor devuelto por la función <code>cdr</code>, es <code>(violeta margarita tulipan)</code>.</p>
<p>Puedes ver esto evaluando lo siguiente del modo habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>Al evaluar esto, aparece <code>(violeta margarita tulipan)</code> en el área de eco.</p>
<p>Al igual que <code>car</code>, <code>cdr</code> no elimina los elementos de la lista––simplemente devuelve un informe del segundo y los subsiguientes elementos presentes.</p>
<p>A propositio, en el ejemplo, se cita la lista de flores. De otra forma, el intérprete Lisp intentaría evaluar la lista llamando a <code>rosa</code> como una función. En este ejemplo, no queremos hacer esto.</p>
<p>Claramente, un nombre más razonable para <code>cdr</code> sería <code>rest</code> (<q>resto</q>).</p>
<p>(Hay una lección aquí: Cuando des nombre a nuevas funciones, considera muy cuidadosamente lo que estes haciendo, ya que puedes adherirte a los nombres mas tiempo del esperado. La razón por la que este documento perpetúa estos nombres se debe a que el código fuente de Emacs Lisp usa, y de no usarlos, tendrias dificultades para leer el codigo; por favor, intenta evitar usar estos términos por tu cuenta. Las personas que vengan después te lo agradecerán.</p>
<p>Cuando se aplican <code>car</code> y <code>cdr</code> a una lista compuesta por símbolos, como la lista <code>(pino abeto roble arce)</code>, el elemento de la lista devuelto por la función <code>car</code> es el símbolo <code>pino</code> sin ningun paréntesis alrededor. <code>pino</code> es el primer elemento en la lista. Sin embargo, el <code>cdr</code> de la lista es una lista en si misma, <code>(abeto roble arce)</code>, como puedes observar al evaluar las siguientes expresiones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>

<span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</code></pre>
<p>Por otro lado, en una lista de listas, el primer elemento es en sí mismo una lista. <code>car</code> devuelve este primer elemento como una lista. Por ejemplo, la siguiente lista contiene tres sub-listas, una lista de carnívoros, una lista de herbívoros y una lista de mamíferos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ballena</span> <span class="nv">delfin</span> <span class="nv">foca</span><span class="p">)))</span>
</code></pre>
<p>En este ejemplo, el primer elemento de <code>car</code> de la lista es la lista de carnívoros, <code>(leon tigre leopardo)</code>, y el resto de la lista es <code>((gacela antilope cebra) (ballena delfin foca))</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">leon</span> <span class="nv">tigre</span> <span class="nv">leopardo</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">gacela</span> <span class="nv">antilope</span> <span class="nv">cebra</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">ballena</span> <span class="nv">delfin</span> <span class="nv">foca</span><span class="p">)))</span>
</code></pre>
<p>vale la pena decir nuevamente que <code>car</code> y <code>cdr</code> son no destructivos––es dicir, no modifican ni cambian las listas a las que se aplican. Esto es muy importante para su uso.</p>
<p>En el primer capítulo, en la discusión sobre los átomos, dije que en Lisp, “ciertos tipos de átomos, como un arreglo, pueden ser separados en partes; pero el mecanismo para hacer esto es diferente del mecanismo para separar una lista. Para Lisp, los átomos de una lista son indivisibles.” (Vea la Seccion <a href="#átomos-lisp" >Átomos Lisp</a>.) Las funciones <code>car</code> y <code>cdr</code> se utilizan para dividir listas y se consideran fundamentales en Lisp. Ya que no se puede dividir o tener acceso a las partes de un arreglo, un arreglo se considera un átomo. Por otro lado, la otra función fundamental, <code>cons</code>, puede armar o construir una lista, pero no un arreglo. (Los arreglos se manejan mediante funciones especificas de arreglos. Vea la Seccion <a href="info:elisp#Arrays" >Arreglos</a> en el <em>El Manual de Referencia de GNU Emacs Lisp</em>.)</p>
</div>
<h3 id="cons" ><code>cons</code></h3>
<div class="hBody-3" >
<p>La función <code>cons</code> construye listas; que es lo opuesto a <code>car</code> y <code>cdr</code>. Por ejemplo, se puede utilizar <code>cons</code> para hacer una lista de cuatro elementos de la lista de tres elementos, <code>(abeto roble arce)</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;pino</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</code></pre>
<p>Después de evaluar esto, veras aparecer</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)</span>
</code></pre>
<p>en el área de eco. <code>cons</code> produce una nueva lista en la que el elemento es seguido por los elementos de la lista original.</p>
<p>Con frecuencia decimos que ‘<code>cons</code> coloca un nuevo elemento al principio de una lista; que agrega o empuja el elemento en la lista’, pero esta frase puede ser engañosa, ya que <code>cons</code> no modifica una lista existente, sino que crea una nueva.</p>
<p>Al igual que <code>car</code> y <code>cdr</code>, <code>cons</code> es no destructivo.</p>
<p><code>cons</code> debe tener una lista a unir.<span class="note" ><sup><a href="#9" >9</a></sup></span> No puedes iniciar de la nada absoluta. Si estás construyendo una lista, es necesario proporcionar al menos una lista vacía al inicio. Aquí hay una serie de expresiones <code>cons</code> que construyen una lista de flores. Si está leyendo esto en GNU Emacs, puedes evaluar cada una de las expresiones para corroborar el resultado.</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;tulipan</span> <span class="p">())</span>
</span><span class="out" >(tulipan)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;margarita</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >(margarita tulipan)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;violeta</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >(violeta margarita tulipan)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;rosa</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">violeta</span> <span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >(rosa violeta margarita tulipan)
</span></code></pre>
<p>En el primer ejemplo, la lista vacía se muestra como <code>()</code> y se construye una lista compuesta por <code>tulipan</code> seguida por la lista vacía. Como puedes ver, la lista vacía no se muestra en la lista que fué construida. Todo lo que ves es <code>(tulipan)</code>. La lista vacía no cuenta como un elemento de una lista porque no hay nada en una lista vacía. En terminos generales, una lista vacía es invisible.</p>
<p>El segundo ejemplo, <code>(cons &#39;margarita &#39;(tulipan))</code> construye una nueva lista de dos elemento colocando <code>margarita</code> delante de <code>tulipan</code>; y el tercer ejemplo construye una lista de tres elementos colocando <code>violeta</code> delante de <code>margarita</code> y <code>tulipan</code>.</p>
</div>
<h4 id="descubrir-la-longitud-de-una-lista:-length" >Descubrir la longitud de una lista: <code>length</code></h4>
<div class="hBody-4" >
<p>Pueden averiguar cuántos elementos hay en una lista utilizando la función Lisp <code>length</code>, como en los siguientes ejemplos:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >1
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">))</span>
</span><span class="out" >2
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;violeta</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">margarita</span> <span class="nv">tulipan</span><span class="p">)))</span>
</span><span class="out" >3
</span></code></pre>
<p>En el tercer ejemplo, la función <code>cons</code> se utiliza para construir una lista de tres elementos que se pasa como argumento a la función <code>length</code>.</p>
<p>También podemos utilizar <code>length</code> para contar el número de elementos en una lista vacía:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">length</span> <span class="p">())</span>
</span><span class="out" >0
</span></code></pre>
<p>Como era de esperar, el número de elementos en una lista vacía es cero.</p>
<p>Un experimento interesante es averiguar qué ocurre si se intenta encontrar la longitud de ninguna lista; es decir, si se intenta llamar a <code>length</code> sin darle un argumento, ni siquiera una lista vacía:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span> <span class="p">)</span>
</code></pre>
<p>La que se ve, si evalúas esto, es el mensaje de error</p>
<div class="example-block" >
<pre class="example" >Lisp error: (wrong-number-of-arguments length 0)
</pre>
</div>
<p>Esto significa que la función recibe un número incorrecto de argumentos, cero, cuando se espera algún otro número de argumentos. En este caso, se espera un argumento, el argumento es una lista cuya longitud mide la función. (Ten en cuenta que <em>una</em> lista es <em>un</em> argumento, incluso si la lista tiene muchos elementos en su interior.)</p>
<p>La parte del mensaje de error que dice <samp>length</samp> es el nombre de la función.</p>
</div>
<h3 id="nthcdr" ><code>nthcdr</code></h3>
<div class="hBody-3" >
<p>La función <code>nthcdr</code> se asocia con la función <code>cdr</code>. Lo que hace es tomar la <code>cdr</code> de una lista repetidamente.</p>
<p>Si tomas el <code>cdr</code> de la lista <code>(pino abeto roble arce)</code>, te devuelve la lista <code>(abeto roble arce)</code>. Si repites esto al retorno, devolverá la lista <code>(roble arce)</code>. (Por supuesto, repetir <code>cdr</code> en la lista original solo dará el <code>cdr</code> original, ya que la función no cambia la lista. Necesitas evaluar el <code>cdr</code> del <code>cdr</code> y así sucesivamente.) Si esto contiúa, finalmente se devuelve una lista vacía, que en este caso, en vez de mostrarse como <code>()</code> se muestra como <code>nil</code>.</p>
<p>Para comprovarlo, aquí hay una serie de <code>cdr</code>s repetidos.</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(abeto roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >nil
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="ss">&#39;nil</span><span class="p">)</span>
</span><span class="out" >nil
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="p">())</span>
</span><span class="out" >nil
</span></code></pre>
<p>También puedes hacer varios <code>cdr</code>s sin imprimir los valores intermedios, de esta forma:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">)))</span>
</span><span class="out" >(roble arce)
</span></code></pre>
<p>En este ejemplo, el intérprete Lisp primero evalúa la lista mas interna. La lista mas interna se cita, por lo que solo pasa la lista tal cual al <code>cdr</code> interno. Este <code>cdr</code> pasa una lista formada por el segundo y los subsiguientes elementos de la lista al <code>cdr</code> externo, que produce una lista compuesta del tercer y los subsiguientes elementos de la lista original. En este ejemplo, la función <code>cdr</code> se repite y devuelve una lista que consiste en la lista original sin sus primeros dos elementos.</p>
<p>La función <code>nthcdr</code> hace lo mismo que repetir la llamada a <code>cdr</code>. En el siguiente ejemplo, el argumento 2 se pasa a la función <code>nthcdr</code>, junto con la lista, y el valor devuelto es la lista sin sus dos primeros elementos, que es exactamente los mismos que repetir dos veces <code>cdr</code> en la lista:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(roble arce)
</span></code></pre>
<p>Utilizando la lista original de cuatro elementos, podemos ver qué ocurre cuando se pasan varios argumentos numéricos a <code>nthcdr</code>, incluyendo 0, 1, y 5:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Deja la lista como estaba.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(pino abeto roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia sin el primer elemento.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(abeto roble arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia de la lista sin tres elementos.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >(arce)
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia sin los cuatro elementos.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">4</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >nil
</span><span class="in" ><span class="prompt" >&gt; </span><span class="c1">;; Regresa una copia sin todos los elementos.</span>
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">5</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">pino</span> <span class="nv">abeto</span> <span class="nv">roble</span> <span class="nv">arce</span><span class="p">))</span>
</span><span class="out" >nil
</span></code></pre>
</div>
<h3 id="nth" ><code>nth</code></h3>
<div class="hBody-3" >
<p>La función <code>nthcdr</code> toma el <code>cdr</code> de una lista repetidamente. La función <code>nth</code> toma el <code>car</code> del resultado devuelto por <code>nthcdr</code>. Devuelve el enesimo elemento de la lista.</p>
<p>Por lo tanto, si <code>nth</code> no estubiera definido en C por velocidad, su definición sería:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nf">nth</span> <span class="p">(</span><span class="nv">n</span> <span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Devuelve el N-esimo elemento de la lista.
</span><span class="s">N cuenta apartir de cero. Si LIST no es tan largo, devuelve nil.&#34;</span>
  <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="nv">n</span> <span class="nf">list</span><span class="p">)))</span>
</code></pre>
<p>(Originalmente, <code>nth</code> se definio en Emacs Lisp dentro de <span class="file" >subr.el</span>, pero su definición fué rehecha en C en los 1980s.)</p>
<p>La función <code>nth</code> devuelve un solo elemento de una lista. Esto puede ser muy conveniente.</p>
<p>Toma en cuenta que los elementos estan numerados apartir del cero, no de uno. Es decir, el primer elemento de una lista, su <code>car</code> es el elemento cero. Esto se llama contar en ‘base a cero’ y con frecuencia molesta a las personas que estan acostumbradas a que el primer elemento en una lista sea el número uno, que es ‘basado en uno’.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nth</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;uno&#34;</span> <span class="s">&#34;dos&#34;</span> <span class="s">&#34;tres&#34;</span><span class="p">))</span>
</span><span class="out" >&#34;uno&#34;

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nth</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;uno&#34;</span> <span class="s">&#34;dos&#34;</span> <span class="s">&#34;tres&#34;</span><span class="p">))</span>
</span><span class="out" >&#34;dos&#34;
</span></code></pre>
<p>Vale la pena mencionar que <code>nth</code>, al igual que <code>nthcdr</code> y <code>cdr</code>, no modifica la lista original––la función es no destructiva. Esto contrasta fuertemente con las funciones <code>setcar</code> y <code>setcdr</code>.</p>
</div>
<h3 id="setcar" ><code>setcar</code></h3>
<div class="hBody-3" >
<p>Como podrías adivinar desde sus nombres, las funciones <code>setcar</code> y <code>setcdr</code> asignan el <code>car</code> o el <code>cdr</code> de una lista a un nuevo valor. Ambos cambian realmente la lista original, a diferencia de <code>car</code> y <code>cdr</code> que dejan la lista original como estaba. Una forma de averiguar cómo funcionan es experimentar. Vamos a empezar con la función <code>setcar</code>.</p>
<p>Primero, podemos crear una lista y luego asignar el valor de una variable a la lista, usando la función <code>setq</code>. Aquí hay una lista de animales:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">antilope</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>
</code></pre>
<p>Si estás leyendo esto dentro de GNU Emacs, puedes evaluar esta expresión de la forma habitual, coloca el cursor después de la expresión y presiona <kbd>C-x C-e</kbd>. (Estoy haciendo esto aqui mismo, mientras lo escribo. Esta es una de las ventajas de tener el intérprete construido dentro del entorno informatico. Por cierto, cuando no hay nada en la línea después del paréntesis final, como un comentario, el punto puede estar en la siguiente línea. De este modo, si tu cursor está en la primera columna de la siguiente línea, no es necesario moverlo. En realidad, Emacs permite cualquier cantidad de espacios en blanco después del paréntesis final.)</p>
<p>Cuando evaluamos la variable <code>animales</code>, vemos que está unida a la lista <code>(antilope jirafa leon tigre)</code>:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales</span>
</span><span class="out" >(antilope jirafa leon tigre)
</span></code></pre>
<p>Dicho de otro modo, la variable <code>animales</code> apunta a la lista <code>(antilope jirafa leon tigre)</code>.</p>
<p>A continuacion, evalua la función <code>setcar</code> mientras le pasas dos argumentos, la variable <code>animales</code> y el símbolo citado <code>hipopotamo</code>; esto se hace escribiendo la lista de tres elementos <code>(setcar animales &#39;hipopotamo)</code> y luego evaluandola de la forma habitual:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">setcar</span> <span class="nv">animales</span> <span class="ss">&#39;hipopotamo</span><span class="p">)</span>
</code></pre>
<p>Después de evaluar esta expresión, evalúa la variable <code>animales</code> de nuevo. Veras que la lista de animales ha cambiado:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales</span>
</span><span class="out" >(hipopótamo jirafa leon tigre)
</span></code></pre>
<p>El primer elemento de la lista, <code>antilope</code> es reemplazado por <code>hipopotamo</code>.</p>
<p>Así podemos ver que <code>setcar</code> no agrega un nuevo elemento a la lista como haria <code>cons</code>; Se reemplaza <code>antílope</code> con <code>hipopótamo</code>; esto <em>cambia</em> la lista.</p>
</div>
<h3 id="setcdr" ><code>setcdr</code></h3>
<div class="hBody-3" >
<p>La función <code>setcdr</code> es similar a la función <code>setcar</code>, excepto que la función reemplaza el segundo y subsiguientes elementos de una lista en lugar del primer elemento.</p>
<p>(Para ver cómo cambiar el último elemento de una lista, mira directamente en la Seccion <a href="#la-función-kill-new" >La función <code>kill-new</code></a>, que utiliza las funciones <code>nthcdr</code> y <code>setcdr</code>.)</p>
<p>Para ver cómo funciona esto, asigna el valor de la variable a una lista de animales domesticados evaluando la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales-domesticos</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">caballo</span> <span class="nv">vaca</span> <span class="nv">oveja</span> <span class="nv">cabra</span><span class="p">))</span>
</code></pre>
<p>Si evalúas la lista, debe devolverte la lista <code>(caballo vaca oveja cabra)</code>:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales-domesticos</span>
</span><span class="out" >(caballo vaca oveja cabra)
</span></code></pre>
<p>Luego, evalúa <code>setcdr</code> con dos argumentos, el nombre de la variable que tiene una lista como su valor, y la lista a la que se establecera el <code>cdr</code> de la primera lista;</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">setcdr</span> <span class="nv">animales-domesticos</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gato</span> <span class="nv">perro</span><span class="p">))</span>
</code></pre>
<p>Si evalúas esta expresión, la lista <code>(gato perro)</code> aparecerá en el área echo. Este es el valor devuelto por la función. El resultado que nos interesa es el “efecto secundario”, que podemos ver evaluando la variable <code>animales-domesticos</code>:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">animales-domesticos</span>
</span><span class="out" >(caballo gato perro)
</span></code></pre>
<p>En efecto, la lista cambia de <code>(caballo vaca oveja cabra)</code> a <code>(caballo gato perro)</code>. El <code>cdr</code> de la lista cambia de <code>(vaca oveja cabra)</code> a <code>(gato perro)</code>.</p>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Construye una lista de cuatro pájaros evaluando varias expresiones con <code>cons</code>. Descubre que ocurre cuando aplicas <code>cons</code> a una lista sobre si misma. Reemplaza el primer elemento de la lista de cuatro pájaros con un pez. Reemplaza el resto de esta lista con una lista de otros peces.</p>
</div>
<h2 id="corte-y-almacenamiento-de-texto" >Corte y Almacenamiento de Texto</h2>
<div class="hBody-2" >
<p>Siempre se corta o guarda texto de un búfer con un comando ‘kill’, se almacena en una lista y puedes traerlo de vuelta con un comando ‘yank’.</p>
<p>(El uso de la palabra ‘kill’ (<q>matar</q>) en Emacs para procesos que específicamente <em>no</em> destruyen los valores de las entidades es un accidente histórico desafortunado. Una palabra mucho más apropiada seria ‘clip’ (<q>cortar</q>) ya que eso es lo que hacen los comandos <samp>kill</samp>; recortan el texto de un búfer y lo guardan en un almacenamiento, donde puede traerse de vuelta. Con frecuencia me he sentido tentado a sustituir globalmente todas las apariciones de ‘kill’ en el codigo de Emacs con ‘clip’ y todas las apariciones de ‘killed’ (destruido) con ‘clipped’ (cortado).)</p>
<p>Cuando el texto se corta de un búfer, se almacena en una lista. Fragmentos de texto se almacenan en la lista sucesivamente, por lo que la lista podría verse así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;una pieza de texto&#34;</span> <span class="s">&#34;pieza anterior&#34;</span><span class="p">)</span>
</code></pre>
<p>La función <code>cons</code> se puede utilizar para crear una nueva lista a partir de un trozo de texto (un ‘átomo’, para usar la jerga) y una lista existente, como esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cons</span> <span class="s">&#34;otra pieza&#34;</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;una pieza de texto&#34;</span> <span class="s">&#34;pieza anterior&#34;</span><span class="p">))</span>
</code></pre>
<p>Si evaluas esta expresión, aparecera una lista de tres elementos en el área de eco:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;otra pieza&#34;</span> <span class="s">&#34;una pieza de texto&#34;</span> <span class="s">&#34;pieza anterior&#34;</span><span class="p">)</span>
</code></pre>
<p>Puedes recuperar cualquier pieza de texto que desees, con las funciones <code>car</code> y <code>nthcdr</code>. Por ejemplo, en el siguiente código, <code>nthcdr 1 …</code> devuelve la lista con el primer elemento eliminado; y <code>car</code> devuelve el primer elemento de ese resto––el segundo elemento de la lista original:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;otra pieza&#34;</span>
                 <span class="s">&#34;una pieza de texto&#34;</span>
                 <span class="s">&#34;pieza anterior&#34;</span><span class="p">)))</span>
</span><span class="out" >&#34;una pieza de texto&#34;
</span></code></pre>
<p>Por supuesto, las funciones reales en Emacs son más complejas que esto. El código para el corte y recuperarcion de texto tiene que ser escrito de modo que Emacs pueda determinar qué elemento en la lista se quiere––el primero, segundo, tercero o cualquier otro. Además, cuando se llega al final de la lista, Emacs deberia darte el primer elemento de la lista, en lugar de nada en absoluto.</p>
<p>La lista que contiene los trozos de texto se llama <dfn>kill ring</dfn> (<q>anillo de la muerte</q>). En este capítulo se hace una descripción del anillo de la muerte y como se utiliza para un primer rastreo en la función <code>zap-to-char</code>. Esta función utiliza (o ‘llama’) a una función que invoca a otra función que manipula el anillo de la muerte. Por la tanto, antes de llegar a las montañas, debemos escalar las colinas.</p>
<p>En un capítulo posterior se describe cómo se recupera el texto que se corta de un buffer. Ver Sección <a href="#pegando-texto" >Pegando texto</a>.</p>
</div>
<h3 id="zap-to-char" ><code>zap-to-char</code></h3>
<div class="hBody-3" >
<p>La función <code>zap-to-char</code> apenas ha variado entre la versión 19 y 22 de GNU Emacs. Sin embargo, <code>zap-to-char</code> llama a otra función, <code>kill-region</code>, que ha tenido una reescritura importante.</p>
<p>La función <code>kill-region</code> en Emacs 19 es compleja, pero no utiliza código que sea importante en este momento. Nos Lo saltaremos.</p>
<p>La función <code>kill-region</code> en Emacs 22 es más de fácil de leer que la misma función en Emacs 19 e introduce un concepto muy importante, la gestion de errores. Caminaremos a través de la función.</p>
<p>Pero primero, veamos la función interactiva <code>zap-to-char</code>.</p>
<p>La función <code>zap-to-char</code> elimina el texto en la región entre la ubicacion del cursor (es decir. del punto) hasta e incluyendo la siguiente aparicion de un caracter específicado. El texto que <code>zap-to-char</code> elimina se pone en el anillo de la muerte; y se puede recuperar escribiendo <kbd>C-y</kbd> (<code>yank</code>). Si el comando recive un argumento, elimina el texto a través de este número de ocurrencias. Por lo tanto, si el cursor estuviera al inicio de esta frase y el carácter fuera <samp>s</samp>, se eliminaria <samp>Por la tanto, </samp>. Si el argumento fueran dos, se eliminaria <samp>Por lo tanto, si el curs</samp>, hasta e incluiendo la <samp>s</samp> en <samp>cursor</samp>.</p>
<p>Si no se encuentra el carácter específicado <code>zap-to-char</code> dirá “Búsqueda fallida”, te indicaria el caracter que escribiste, y no eliminara ningun texto.</p>
<p>Para determinar la cantidad de texto a eliminar <code>zap-to-char</code> utiliza una función de búsqueda. Las búsquedas se utilizan ampliamente en código que manipula el texto, y vamos a centrar la atención en ellos, asi como en el comando de eliminacion.</p>
<p>Aquí está el texto completo de la función en la versión 22:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">zap-to-char</span> <span class="p">(</span><span class="nv">arg</span> <span class="nv">char</span><span class="p">)</span>
  <span class="s">&#34;Corta e incluye la aparicion de la enesima ocurrencia (ARG) del caracter CHAR.
</span><span class="s">Se ignora entre mayusculas y minusculas si ‘case-fold-search’ es no-nil en
</span><span class="s">el buffer actual.
</span><span class="s">Retrocede si ARG es negativo; error si CHAR no se encuentra.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">char-table-p</span> <span class="nv">translation-table-for-input</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">char</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">aref</span> <span class="nv">translation-table-for-input</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">char</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nb">progn</span>
                         <span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
                         <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</code></pre>
<p>La linea de documentacion esta traducida al español. En la version original no se utiliza la palabra ‘Corta’ en su lugar se utiliza ‘kill’.</p>
</div>
<h4 id="la-expresión-interactive" >La expresión <code>interactive</code></h4>
<div class="hBody-4" >
<p>La expresión interactiva en el comando <code>zap-to-char</code> es esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p\ncZap to char: &#34;</span><span class="p">)</span>
</code></pre>
<p>La parte entre comillas, <code>&#34;p\ncZap to char: &#34;</code>, especifica dos cosas diferentes. Primero, y lo mas sencillo, es la <samp>p</samp>. Esta parte se separa de la siguiente parte por una línea nueva, <samp>\n</samp>. La <samp>p</samp> significa que el primer argumento de la función será pasando el valor de un ‘prefijo procesado’. El argumento prefijo se pasa escribiendo <kbd>C-u</kbd> y un número, o <kbd>M-</kbd> y un número. Si la función se llamada interactivamente sin un prefijo, se pasa 1 a este argumento.</p>
<p>La segunda parte de <code>&#34;p\ncZap to char: &#34;</code> es <samp>cZap to char:</samp>. En esta parte, la <samp>c</samp> minuscula indica que <code>interactive</code> espera un prompt y que el argumento será un caracter. El prompt va despues de <samp>c</samp> y es la cadena <samp>Zap to char: </samp> (con un espacio después de los dos puntos para verse bien).</p>
<p>Todo lo que esto hace es preparar los argumentos de <code>zap-to-char</code> para que sean del tipo correcto, y darle al usuario un prompt.</p>
<p>En un búfer de solo lectura, la función <code>zap-to-char</code> copia el texto al anillo de la muerte, pero no lo elimina. El área de eco muestra un mensaje diciendo que el búfer es de solo lectura. Ademas, el terminal puede emitir un pitido o parpadear.</p>
</div>
<h4 id="el-cuerpo-de-zap-to-char" >El cuerpo de <code>zap-to-char</code></h4>
<div class="hBody-4" >
<p>El cuerpo de la función <code>zap-to-char</code> contiene el código que mata (es decir, elimina) el texto en la región desde la posición actual del cursor hasta e incluyendo el carácter especificado.</p>
<p>La primera parte del código se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">char-table-p</span> <span class="nv">translation-table-for-input</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">char</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">aref</span> <span class="nv">translation-table-for-input</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">char</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">kill-region</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nb">progn</span>
                       <span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
                       <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
</code></pre>
<p><code>char-table-p</code> es una función que aun no hemos visto. Determina si su argumento es una tabla de caracteres. Si lo es, establece el caracter pasado a <code>zap-to-char</code> a uno de ellos, si ese carácter existe, o al carácter en sí. (Esto es importante para ciertos caracteres en lenguas no Europeas. La función <code>aref</code> extrae un elemento desde un arreglo. Esta funcion es específica para arreglos y no sera descrita en este documento. Vea la Seccion <a href="info:elisp#Arrays" >Arreglos</a> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.)</p>
<p><code>(point)</code> es la posición actual del cursor.</p>
<p>La siguiente parte del código es una expresión utilizando <code>progn</code>. El cuerpo del <code>progn</code> consiste en llamadas a <code>search-forward</code> y <code>point</code>.</p>
<p>Es fácil comprender cómo funciona <code>progn</code> después de aprender sobre <code>search-forward</code>, asi que veremos <code>search-forward</code> y luego <code>progn</code>.</p>
</div>
<h4 id="la-función-search-forward" >La función <code>search-forward</code></h4>
<div class="hBody-4" >
<p>La función <code>search-forward</code> se utiliza para localizar el caracter a borrar en <code>zap-to-char</code>. Si la búsqueda es exitosa, <code>search-forward</code> deja el punto inmediatamente después del último carácter en la cadena objetivo. (En <code>zap-to-char</code>, la cadena objetivo tiene solo un carácter longitud. <code>zap-to-char</code> usa la función <code>char-to-string</code> para asegurar que el computador trata este carácter como una cadena). Si la búsqueda es hacia atrás, <code>search-forward</code> deja el punto justo antes del primer carácter en el objetivo. Ademas, <code>search-forward</code> devuelve <code>t</code> para verdadero. (Por lo tanto, desplazar el punto es un ‘efecto secundario’.)</p>
<p>En <code>zap-to-char</code>, la función <code>search-forward</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">search-forward</span> <span class="p">(</span><span class="nf">char-to-string</span> <span class="nv">char</span><span class="p">)</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nv">arg</span><span class="p">)</span>
</code></pre>
<p>La función <code>search-forward</code> utiliza cuatro argumentos:</p>
<ol class="num" >
<li>
<p>El primer argumento es el objetivo, que esta buscando. Debe ser una cadena, como <q>z</q>.</p>
<p>Sucede que el argumento pasado a <code>zap-to-char</code> es un solo caracter. Debido a la forma en la que se construyen los computadores, el intérprete Lisp puede tratar un solo caracter de forma distinta a una cadena de caracteres. Dentro del computador, un solo caracter tiene un formato electrónico diferente a una cadena de un caracteres. (Un solo caracter con frecuencia puede grabarse en el computador utilizardo exactamente un byte; pero una cadena puede ser mas larga, y el equipo debe estar listo para ello.) Ya que la función <code>search-forward</code> busca una cadena, el caracter que recive la función <code>zap-to-char</code> como argumento debe convertirse dentro del computador de un formato a otro; de lo contrario, la función <code>search-forward</code> fallará. Se utiliza la función <code>char-to-string</code> para realizar esta conversión.</p>
</li>
<li>
<p>El segundo argumento limita la búsqueda; se especifica como una posición en el búfer. En este caso, la búsqueda puede ir al final del búfer, por lo que no se establece ningun limite y el segundo argumento es <code>nil</code>.</p>
</li>
<li>
<p>El tercer argumento le dice a la función lo que debe hacer si la búsqueda falla––puede señalar un error (e imprimir un mensaje) o puede devolver <code>nil</code>. Un <code>nil</code> como el tercer argumento hace que la función señåle un error cuando la búsqueda falla.</p>
</li>
<li>
<p>El cuarto argumento de <code>search-forward</code> es el numero de repeticion––cuántas ocurrencias de la cadena hay que buscar. Este argumento es opcional y si la función se llamada sin contador de repeticion, este argumento pasa el valor 1. Si este argumento es negativo, la búsqueda va hacia atrás.</p>
</li>
</ol>
<p>En formato plantilla, una expresión <code>search-forward</code> tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">search-forward</span> <span class="s">&#34;cadena-a-buscar&#34;</span>
                <span class="nv">limite-de-busqueda</span>
                <span class="nv">que-hacer-si-la-busqueda-falla</span>
                <span class="nv">contador-de-repeticion</span><span class="p">)</span>
</code></pre>
<p>A continuacion veremos <code>progn</code>.</p>
</div>
<h4 id="la-forma-especial-progn" >La forma especial <code>progn</code></h4>
<div class="hBody-4" >
<p><code>progn</code> es una forma especial que hace que cada uno de sus argumentos sea evaluado en secuencia y luego devuelve el valor del último. Las expresiones anteriores solo se evaluan por los efectos secundarios que realizan. Los valores que producen son descartados.</p>
<p>La plantilla de una expresión <code>progn</code> es muy simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">progn</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>En <code>zap-to-char</code>, la expresión <code>progn</code> tiene que hacer dos cosas: poner el punto exactamente en la posición correcta; y devolver la posición del punto para que <code>kill-region</code> sepa handa donde cortar.</p>
<p>El primer argumento de <code>progn</code> es <code>search-forward</code>. Cuando <code>search-forward</code> encuentra la cadena, la función deja el punto inmediatamente después del último caracter en la cadena objetivo. (En este caso la cadena objetivo tiene solo un carácter de longitud.) Si la búsqueda es hacia atrás, <code>search-forward</code> deja el punto justo antes del primer carácter objetivo. El movimiento del punto es un efecto secundario.</p>
<p>El segundo y último argumento de <code>progn</code> es la expresión <code>(point)</code>. Esta expresión devuelve el valor del punto, que en este caso será la ubicacion a la que se ha movido por <code>search-forward</code>. (En el codigo, una línea le indica a la función que debe ir un carácter atras, si va hacia adelante, se comentó en 1999; yo no recuerdo si esta caracteriscita o funcion incorrecta alguna vez fue parte del codigo distribuido.) El valor de <code>point</code> es devuelto por la expresión <code>progn</code> y se pasa a <code>kill-region</code> como el segundo argumento de <code>kill-region</code> .</p>
</div>
<h4 id="resumiendo-zap-to-char" >Resumiendo <code>zap-to-char</code></h4>
<div class="hBody-4" >
<p>Ahora que hemos visto cómo funcionan <code>search-forward</code> y <code>progn</code>, podemos ver cómo la función <code>zap-to-como</code> trabaja como un todo.</p>
<p>El primer argumento de <code>kill-region</code> es la posición del cursor cuando se da el comando <code>zap-to-char</code>––el valor de punto en ese momento. Dentro de <code>progn</code>, la funcion de búsqueda mueve el punto justo después del caracter a borrar y <code>point</code> devuelvan el valor esa ubicacion. La función <code>kill-region</code> reune estos dos valores de punto, el primero como el inicio de la región y el segundo como el final de la región, y elimina la región.</p>
<p>La forma especial <code>progn</code> es necesaria porque el comando <code>kill-region</code> toma dos argumentos; y fallaría si las expresiones <code>search-forward</code> y <code>point</code> se escribieran en secuencia como dos argumentos adicionales. La expresión <code>progn</code> es solo un argumento para <code>kill-region</code> y devuelve el valor que <code>kill-region</code> necesita para su segundo argumento.</p>
</div>
<h3 id="kill-region" ><code>kill-region</code></h3>
<div class="hBody-3" >
<p>La función <code>zap-to-char</code> utiliza la función <code>kill-region</code>. Esta función corta texto de una región y copia ese texto al anillo de la muerte, desde el que puede recuperarse.</p>
<p>La versión en Emacs 22 de esta funcion utiliza <code>condition-case</code> y <code>copy-region-as-kill</code>, ambas seran explicadas. <code>condition-case</code> es una forma especial importante.</p>
<p>En esencia, la función <code>kill-region</code> llama a <code>condition-case</code>, que toma tres argumentos. En esta función, el primer argumento no hace nada. El segundo argumento contiene el código que hace el trabajo cuando todo va bien. El tercer argumento contiene el código que se llama en caso de error.</p>
<p>Revisaremos el código de <code>condition-case</code> en un momento. Primero, veamos la definición de <code>kill-region</code>, con comentarios añadidos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-region</span> <span class="p">(</span><span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Kill (\&#34;corta\&#34;) el texto entre el punto y la marca.
</span><span class="s">Esto elimina el texto del buffer y lo guarda en el anillo de la muerte.
</span><span class="s">El comando \\[yank] puede recuperarlo desde alli. … &#34;</span>

  <span class="c1">;; • Puesto que el orden importa, primero pasa el punto.</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span><span class="p">)))</span>
  <span class="c1">;; • Y dinos si no podemos cortar el texto.</span>
  <span class="c1">;; ‘A menos que’ sea un ‘if’ sin parte then.</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
    <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;La marca no esta definida, asi que no hay ninguna region&#34;</span><span class="p">))</span>
  <span class="c1">;; • ‘condition-case’ toma tres argumentos.</span>
  <span class="c1">;;    Si el primer argumento es nil, como aqui,</span>
  <span class="c1">;;    la informacion del error no se almacena</span>
  <span class="c1">;;    para ser utilizado por otra funcion.</span>
  <span class="p">(</span><span class="nb">condition-case</span> <span class="no">nil</span>

      <span class="c1">;; • El segundo argumento de ‘condition-case’ le dice al</span>
      <span class="c1">;;    interprete Lisp que hacer cuando todo va bien.</span>

      <span class="c1">;;    Empieza con una funcion ‘let’ que extrae la cadena y</span>
      <span class="c1">;;    comprueba si existe. Si es asi (eso es lo que comprueba</span>
      <span class="c1">;;    ‘when’), esta llama a una funcion ‘if’ que determina</span>
      <span class="c1">;;    si el comando anterior fue otra llamada a ‘kill-region’;</span>
      <span class="c1">;;    si lo fue, el nuevo texto se añade al texto anterior; si</span>
      <span class="c1">;;    no, se llama a una funcion diferente, ‘kill-new’.</span>

      <span class="c1">;;    La funcion ‘kill-append’ concatena la cadena nueva y antigua.</span>
      <span class="c1">;;    La funcion ‘kill-new’ inserta el texto dentro de un nuevo</span>
      <span class="c1">;;    elemento en el anillo de la muerte.</span>

      <span class="c1">;;    ‘when’ es un ‘if’ sin una parte else. El segundo ‘when’</span>
      <span class="c1">;;    comprueba de nuevo si la cadena actual existe; Ademas,</span>
      <span class="c1">;;    comprueba si el comando anterior fue otra llamada a</span>
      <span class="c1">;;    ‘kill-region’. Si una u otra condicion es verdadera,</span>
      <span class="c1">;;    entonces establece que el comando actual sea ‘kill-region’.</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nf">string</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span> <span class="no">t</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nf">string</span>                    <span class="c1">;STRING es nil si BEG = END</span>
          <span class="c1">;; agrega esa cadena al anillo de la muerte, de uno forma u otra.</span>
          <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
              <span class="c1">;;    − ‘yank-handler’ es un argumento opcional de</span>
              <span class="c1">;;    ‘kill-region’ que indica a las funciones ‘kill-append’</span>
              <span class="c1">;;    y ‘kill-new’ como tratar las propiedades añadidas al</span>
              <span class="c1">;;    texto, como ‘negrita’ o ‘cursiva’.</span>
              <span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">kill-new</span> <span class="nf">string</span> <span class="no">nil</span> <span class="nv">yank-handler</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">or</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;kill-region</span><span class="p">))</span>
        <span class="no">nil</span><span class="p">)</span>

    <span class="c1">;;  • El tercer argumento de ‘condition-case’ le dice al interprete</span>
    <span class="c1">;;    que hacer con un error.</span>
    <span class="c1">;;    El tercer argumento tiene una parte de condiciones y una parte cuerpo.</span>
    <span class="c1">;;    Si se cumplen las condiciones (en este caso,</span>
    <span class="c1">;;             si el texto o el buffer son de solo lectura)</span>
    <span class="c1">;;    entonces se ejecuta el cuerpo.</span>
    <span class="c1">;;    La primer parte del tercer argumento es la siguiente:</span>
    <span class="p">((</span><span class="nv">buffer-read-only</span> <span class="nv">text-read-only</span><span class="p">)</span> <span class="c1">;; la parte if</span>
     <span class="c1">;; …  la parte then</span>
     <span class="p">(</span><span class="nv">copy-region-as-kill</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
     <span class="c1">;;    A continuacion, tambien como parte de la parte then, establece</span>
     <span class="c1">;;    this-command, por lo que se establece en un error</span>
     <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
     <span class="c1">;;    Finalmente, en la pante then, envia un mensaje si puede copiar</span>
     <span class="c1">;;    el texto en el anillo de la muerte sin señalar un error, pero</span>
     <span class="c1">;;    no lo hace si no puede.</span>
     <span class="p">(</span><span class="nb">if</span> <span class="nv">kill-read-only-ok</span>
         <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Read only text copied to kill ring&#34;</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">barf-if-buffer-read-only</span><span class="p">)</span>
       <span class="c1">;; Si el buffer no es de solo lectura, el texto lo es.</span>
       <span class="p">(</span><span class="ne">signal</span> <span class="ss">&#39;text-read-only</span> <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))))</span>
</code></pre>
</div>
<h4 id="condition-case" ><code>condition-case</code></h4>
<div class="hBody-4" >
<p>Como se ha visto antes (ver la Seccion <a href="#generar-un-mensaje-de-error" >Generar un Mensaje de Error</a>), cuando el intérprete de Emacs Lisp tiene problemas evaluando una expresión, te proporciona ayuda; en la jerga, esto se llama “Señalar un error”. Normalmente, el computador detiene el programa y te muestra un mensaje.</p>
<p>Sin embargo, algunos programas emprenden acciones complicadas. No deberian simplemente detenerse en un error. En la función <code>kill-region</code>, el error mas probable es que intente cortar texto que es de solo lectura y no puede ser eliminado. Así que la función <code>kill-region</code> contiene código para manejar esta circunstancia. Este código, que forma el cuerpo de la función <code>kill-region</code>, se encuentra dentro de una forma especial <code>condition-case</code>.</p>
<p>La plantilla para <code>condition-case</code> tiene este aspecto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">condition-case</span>
  <span class="nv">var</span>
  <span class="nv">cuerpo</span>
  <span class="nv">gestor-de-errores</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>El segundo argumento, <code>cuerpo</code> es sencillo. La forma especial <code>condition-case</code> hace que el intérprete Lisp evalúe el código en <code>cuerpo</code>. Si no ocurre ningún error, la forma especial devuelve el valor del código y produce efectos secundarios, si los hubiera.</p>
<p>En resumen, la parte <code>cuerpo</code> de una expresión <code>condition-case</code> determina qué deberia suceder cuando todo funciona correctamente.</p>
<p>Sin embargo, si se produce un error, entre sus otras acciones, la función genera la señal de error que define uno o más nombres de condicion de error.</p>
<p>El gestor de errores es el tercer argumento de <code>condition-case</code>. Un gestor de errores tiene dos partes, un <code>nombre-de-condicion</code> y un <code>cuerpo</code>. Si la parte <code>nombre-de-condicion</code> de un gestor de errores coincide con un nombre de condicion generado por un error, se ejecuta la parte del <code>cuerpo</code> del gestor de errores.</p>
<p>Como es de esperar, la parte <code>nombre-de-condicion</code> de un gestor de errores puede ser un unico nombre de condicion o una lista de nombres de condición.</p>
<p>Ademas, una expresión <code>condition-case</code> completa puede contener más de un gestor de errores. Cuando se produce un error, se ejecuta el primer gestor aplicable.</p>
<p>Por ultimo, el primer argumento de la expresión <code>condition-case</code>, el argumento <code>var</code>, en ocaciones se vincula a una variable que contiene información sobre el error. Sin embargo, si este argumento es <code>nil</code>, como es el caso en <code>kill-region</code>, esa información se descarta.</p>
<p>En resumen, en la función <code>kill-region</code>, el código <code>condition-case</code> funciona de la siguiente manera:</p>
<div class="example-block" >
<pre class="example" >Si no hay errores, ejecuta solo este codigo
    pero, si hay errores, ejecuta este otro codigo.
</pre>
</div>
</div>
<h4 id="macro-lisp" >Macro Lisp</h4>
<div class="hBody-4" >
<p>La parte de la expresión <code>condition-case</code> que se evalúa en la expectativa de que todo va bien si tiene un <code>when</code>. El código utiliza <code>when</code> para determinar si la variable <code>string</code> apunta a texto que existe.</p>
<p>Una expresión <code>when</code> simplemente es una conveniencia para los programadores. Es un <code>if</code> sin la posibilidad de una cláusula else. En tu mente, puedes reemplazar <code>when</code> con <code>if</code> y entender lo que pasa. Eso es lo que hace el intérprete Lisp.</p>
<p>Técnicamente hablando, <code>when</code> es una macro Lisp. Una <dfn>macro</dfn> Lisp te permite definir nuevas construcciones de control y otras caracteristicas del lenguaje. Le indica al intérprete cómo calcular otra expresión Lisp que a su vez calcula el valor. En este caso, la ‘otra expresión’ es una expresión <code>if</code>.</p>
<p>La definición de la función <code>kill-region</code> también tiene una macro <code>unless</code>; es lo contario de <code>when</code>. La macro <code>unless</code> es un <code>if</code> sin una cláusula <code>then</code>.</p>
<p>Para optener más informacion sobre las macros Lisp, consulta la Seccion <a href="#info:elisp#Macros" >Macros</a> en <em>El Manual de Referencia de Emacs Lisp</em>. El lenguaje de programación C también proporciona macros. Estos son diferentes, pero también útiles.</p>
<p>Respecto a la macro <code>when</code>, en la expresión <code>condition-case</code>, cuando la cadena tiene contenido, se ejecuta otra expresión condicional. Esto es un <code>if</code> tanto con parte <code>then</code> como con una parte <code>else</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">kill-new</span> <span class="nf">string</span> <span class="no">nil</span> <span class="nv">yank-handler</span><span class="p">))</span>
</code></pre>
<p>La parte <code>then</code> se evalúa si el comando anterior era otra llamada a <code>kill-region</code>; si no, se evalúa la parte <code>else</code>.</p>
<p><code>yank-handler</code> es un argumento opcional de <code>kill-region</code> que indica a las funciones <code>kill-append</code> y <code>kill-new</code> como tratar con propiedades agregadas al texto, como ‘negrilla’ o ‘cursiva’.</p>
<p><code>last-command</code> es una variable que viene con Emacs y que no hemos visto antes. Normalmente, siempre que se ejecuta una función, Emacs establece el valor de <code>last-command</code> al comando anterior.</p>
<p>En este segmento de la definición, la expresión <code>if</code> comprueba si el comando anterior fue <code>kill-region</code>. Si lo fuera,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">kill-append</span> <span class="nf">string</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">)</span> <span class="nv">yank-handler</span><span class="p">)</span>
</code></pre>
<p>concatena una copia del texto recien cortado al texto cortado previamente en el anillo de la muerte.</p>
</div>
<h3 id="copy-region-as-kill" ><code>copy-region-as-kill</code></h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> copia una región de texto de un búfer y (via <code>kill-append</code> o <code>kill-new</code>) lo guarda en el <code>kill-ring</code>.</p>
<p>Si llamas a <code>copy-region-as-kill</code> inmediatamente después de un comando <code>kill-region</code>, Emacs agregara el texto recien copiado al texto copiado previamente. Esto significa que traes el texto, lo obtienes todo, tanto de esta operacion como de la anterior. Por otra parte, si algún otro comando precede a <code>copy-region-as-kill</code>, la función copia el texto dentro de una entrada separada en el anillo de la muerte.</p>
<p>Aquí está el texto completo de la función <code>copy-region-as-kill</code> de la versión 22:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-region-as-kill</span> <span class="p">(</span><span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Guarda la region como si fuese cortada, pero no la corta.
</span><span class="s">En el modo Transient Mark, desactiva la marca.
</span><span class="s">Si ‘interprogram-cut-function’ es no-nil, tambien guarda el texto de una
</span><span class="s">ventana del sistema corta y pega.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">kill-append</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">kill-new</span> <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">transient-mark-mode</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">deactivate-mark</span> <span class="no">t</span><span class="p">))</span>
  <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>Como de costumbre, esta función puede dividirse en las partes que la componen:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-region-as-kill</span> <span class="p">(</span><span class="nv">lista-de-argumentos</span><span class="p">)</span>
  <span class="s">&#34;documentacion…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="nv">cuerpo</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Los argumentos son <code>beg</code> y <code>end</code> y la función es interactiva con <code>&#34;r&#34;</code>, por lo que los dos argumentos deben referirse al inicio y al final de la región. Si has estado leyendo este documento desde el principio, entender estas partes de una función es casi una rutina.</p>
<p>En la documentación, los comentarios de ‘Transient Mark’ y <code>interprogram-cut-function</code> explican ciertos efectos secundarios.</p>
<p>Después de asignar una marca, un búfer siempre contiene una región. Si lo deseas puedes utilizar el modo Transient Mark para resaltar temporalmente la región. (Nadie quiere resaltar la región todo el tiempo, por lo que el modo Trasient Mark lo resalta solo en los momentos apropiados. Muchas personas desactivan el modo Transient Mark, por lo que la región nunca se resalta.)</p>
<p>Ademas, un sistema de ventanas permite copiar, cortar y pegar entre diferentes programas. En el sistema de ventanas X, por ejemplo, la función <code>interprogram-cut-function</code> es <code>x-select-text</code>, que funciona con el sistema de ventanas equivalente al anillo de la muerte de Emacs.</p>
<p>El cuerpo de la función <code>copy-region-as-kill</code> inicia con una cláusula <code>if</code>. Lo que esta cláusula hace es distinguir entre dos situaciones diferentes: si este comando se ejecuta o no inmediatamente después de un comando <code>kill-region</code> anterior. En el primer caso, la nueva región se concatena al texto copiado previamente. De lo contrario, se inserta al inicio del anillo de la muerte como una pedazo separado del texto anterior.</p>
<p>Las dos ultimas líneas de la función impiden que la región se ilumine si el modo Transient Mark está activo.</p>
<p>El cuerpo de <code>copy-region-as-kill</code> merece ser discutido en detalle.</p>
</div>
<h4 id="el-cuerpo-de-copy-region-as-kill" >El cuerpo de <code>copy-region-as-kill</code></h4>
<div class="hBody-4" >
<p><code>copy-region-as-kill</code> funciona de un modo parecido a la función <code>kill-region</code>. Ambas están escritas de manera que dos o más muertes en una fila combinan su texto en una sola entrada. Si sacas el texto del anillo de la muerte, se optiene todo en una sola pieza. Ademas, las muertes que matan hacia adelante desde la posición actual del cursor se añaden al final del texto copiado previamente y los comandos que cortan el texto hacia atrás lo añaden al principio del texto copiado previamente. De esta manera, las palabras del texto permanecen en el orden correcto.</p>
<p>Al igual que <code>kill-region</code>, la función <code>copy-region-as-kill</code> hace uso de la variable <code>last-command</code> que mantiene el registro del comando Emacs anterior.</p>
<p>Normalmente, siempre que se ejecuta una función, Emacs asigna el valor de <code>this-command</code> a la función que se ejecuta (que en este caso sería <code>copy-region-as-kill</code>). Al mismo tiempo, Emacs asigna el valor de <code>last-command</code> al valor anterior de <code>this-command</code>.</p>
<p>En la primer parte del cuerpo de la función <code>copy-region-as-kill</code>, una expresión <code>if</code> determina si el valor de <code>last-command</code> es <code>kill-region</code>. Si es así, se evalua la parte then de la expresión <code>if</code>; utiliza la función <code>kill-append</code> para concatenar el texto copiado en esta llamada a la función con el texto ya en el primer elemento (el <code>car</code> del anillo de la muerte. Por otro lado, si el valor de <code>last-command</code> no es <code>kill-region</code>, entonces la función <code>copy-region-as-kill</code> asigna un nuevo elemento al anillo de la muerte usando la función <code>kill-new</code>.</p>
<p>La expresión <code>if</code> se lee da la siguiente manera; se utiliza <code>eq</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;kill-region</span><span class="p">)</span>
    <span class="c1">;; parte then</span>
    <span class="p">(</span><span class="nv">kill-append</span>  <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">end</span> <span class="nv">beg</span><span class="p">))</span>
  <span class="c1">;; parte else</span>
  <span class="p">(</span><span class="nv">kill-new</span>  <span class="p">(</span><span class="nv">filter-buffer-substring</span> <span class="nv">beg</span> <span class="nv">end</span><span class="p">)))</span>
</code></pre>
<p>(La función <code>filter-buffer-substring</code> devuelve una subcadena filtrada del búfer, si existe. Opcionalmente––los argumentos no están aquí, por lo que tampoco se hace––la función puede borrar el texto inicial o devolver el texto sin sus propiedades; esta función es un reemplazo para la antigua función <code>buffer-substring</code>, que vino antes de implementar las propiedades de texto.)</p>
<p>La función <code>eq</code> prueba si su primer argumento es el mismo objeto Lisp que su segundo argumento. La función <code>eq</code> es similar a la función <code>equal</code> que se utiliza para probar la igualdad, pero difiere en que determina si dos representaciones son realmente el mismo objeto dentro de la computadora, pero con nombres diferentes. <code>equal</code> determina si la estructura y el contenido de dos expresiones son iguales.</p>
<p>Si el comando anterior fue <code>kill-region</code>, entonces el intérprete Emacs Lisp llama a la función <code>kill-append</code></p>
</div>
<h5 id="la-función-kill-append" >La función <code>kill-append</code></h5>
<div class="hBody-5" >
<p>La función <code>kill-new</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-append</span> <span class="p">(</span><span class="nf">string</span> <span class="nv">before-p</span> <span class="kp">&amp;optional</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="s">&#34;Inserta STRING al fin del ultimo corte en el anillo de la muerte.
</span><span class="s">Si BEFORE-P no es nil, anexa STRING al corte.
</span><span class="s">… &#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">cur</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">kill-new</span> <span class="p">(</span><span class="nb">if</span> <span class="nv">before-p</span> <span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span> <span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nf">=</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">cur</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">equal</span> <span class="nv">yank-handler</span>
                         <span class="p">(</span><span class="nf">get-text-property</span> <span class="mi">0</span> <span class="ss">&#39;yank-handler</span> <span class="nv">cur</span><span class="p">)))</span>
              <span class="nv">yank-handler</span><span class="p">)))</span>
</code></pre>
<p>La función <code>kill-append</code> es bastante sencilla. Utiliza la función <code>kill-new</code>, que discutiremos con más detalle en un momento.</p>
<p>(También, la función proporciona un argumento opcional llamado <code>yank-handler</code>; cuando se invoca, este argumento le dice a la función cómo tratar con la propiedades añadidas al texto, como ‘negrita’ o ‘cursiva’.)</p>
<p>Tiene una función <code>let*</code> para asignar el valor del primer elemento del anillo de la muerte a <code>cur</code>. (No se por qué la función no utiliza <code>let</code> en su lugar; solo un valor se asigna en la expresión. ¿Tal vez este es un bug que no produce problemas?</p>
<p>Considera el condicional que es uno de los dos argumentos de <code>kill-new</code>. Utiliza <code>concat</code> para concatenar el nuevo texto al <code>car</code> del anillo de la muerte. Si agrega el texto antes o despues depende del resultado de la expresión <code>if</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">before-p</span>                            <span class="c1">; parte if</span>
    <span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span>                 <span class="c1">; parte then</span>
  <span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>                  <span class="c1">; parte else</span>
</code></pre>
<p>Si la región cortada está antes de la región que se cortó en el último comando, entonces debería ser puesta antes que el material guardado en el corte anterior; y, a la inversa, si el texto que se corto esta despues del que acaba de cortar, debe añadirse después del texto anterior. La expresión <code>if</code> depende del predicado <code>before-p</code> para decidir si el texto recien guardado debe colocarse antes o después del texto anterior.</p>
<p>El símbolo <code>before-p</code> es el nombre de uno de los argumentos para <code>kill-append</code>. Cuando se evalúa la función <code>kill-append</code>, se asocia al valor devuelto evaluando el argumento actual. En este caso, esta es la expresión <code>(&lt; end beg)</code>. Esta expresión no determina directamente si el texto cortado en este comando se localiza antes o después del texto cortado del último comando; lo que hace es determinar si el valor de la variable <code>end</code> es menor que el valor de la variable <code>beg</code>. Si es así, significa que problamemente el usuario se dirige al principio del búfer. También, el resultado de evaluar la expresión del predicado. <code>(&lt; end beg)</code>, será verdadero y el texto se concatena antes del texto anterior. Por otro lado, si el valor de la variable <code>end</code> es mayor que el valor del la variable <code>beg</code>, el texto se agregara después del texto anterior.</p>
<p>Cuando se prepara el texto recien guardado, la cadena con el nuevo texto se concatena antes que el texto anterior:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="nf">string</span> <span class="nv">cur</span><span class="p">)</span>
</code></pre>
<p>Pero si el texto será añadido, será concatenado después del viejo texto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">concat</span> <span class="nv">cur</span> <span class="nf">string</span><span class="p">))</span>
</code></pre>
<p>Para comprender cómo funciona esto, primero se necesita revisar la función <code>concat</code>. La función <code>concat</code> enlaza o une dos cadenas de texto. El resultado es una cadena. Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;abc&#34;</span> <span class="s">&#34;def&#34;</span><span class="p">)</span>
</span><span class="out" >&#34;abcdef&#34;

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;nuevo &#34;</span>
        <span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;primer elemento&#34;</span> <span class="s">&#34;segundo elemento&#34;</span><span class="p">)))</span>
</span><span class="out" >&#34;nuevo primer elemento&#34;

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">car</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;primer elemento&#34;</span> <span class="s">&#34;segundo elemento&#34;</span><span class="p">))</span> <span class="s">&#34; modificado&#34;</span><span class="p">)</span>
</span><span class="out" >&#34;primer elemento modificado&#34;
</span></code></pre>
<p>Ahora podemos dar sentido a <code>kill-append</code>: modifica el contenido del anillo de la muerte. El anillo de la muerte es una lista, en la que cada elemento es un texto guardado. La función <code>kill-append</code> usa la función <code>kill-new</code> que a su vez utiliza la función <code>setcar</code>.</p>
</div>
<h5 id="la-función-kill-new" >La función <code>kill-new</code></h5>
<div class="hBody-5" >
<p>La función <code>kill-new</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">kill-new</span> <span class="p">(</span><span class="nf">string</span> <span class="kp">&amp;optional</span> <span class="nv">replace</span> <span class="nv">yank-handler</span><span class="p">)</span>
  <span class="s">&#34;Hace que STRING sea el último corte en el anillo de la muerte.
</span><span class="s">Asigna ‘kill-ring-yank-pointer’ para apuntar a el.
</span><span class="s">
</span><span class="s">Si ‘interprogram-cut-function’ es no nulo, aplícalo a STRING.
</span><span class="s">El segundo argumento opcional REPLACE no-nulo significa que STRING
</span><span class="s"> reemplazará el frente del kill ring, en lugar de agregarse a la lista.
</span><span class="s">…&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nf">string</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">if</span> <span class="nv">yank-handler</span>
          <span class="p">(</span><span class="nf">put-text-property</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">length</span> <span class="nf">string</span><span class="p">)</span>
                             <span class="ss">&#39;yank-handler</span> <span class="nv">yank-handler</span> <span class="nf">string</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">if</span> <span class="nv">yank-handler</span>
        <span class="p">(</span><span class="ne">signal</span> <span class="ss">&#39;args-out-of-range</span>
                <span class="p">(</span><span class="nf">list</span> <span class="nf">string</span> <span class="s">&#34;yank-handler specified for empty string&#34;</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;menu-bar-update-yank-menu</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">menu-bar-update-yank-menu</span> <span class="nf">string</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="nv">kill-ring</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">setcar</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">push</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">kill-ring-max</span><span class="p">)</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="no">nil</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">interprogram-cut-function</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="nv">interprogram-cut-function</span> <span class="nf">string</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">replace</span><span class="p">))))</span>
</code></pre>
<p>(Observa que la función no es interactiva.)</p>
<p>Como de costumbre, podemos ver esta función en partes.</p>
<p>La definición de la función tiene un argumento opcional <code>yank-handler</code>, que cuando se invoca le dice a la función cómo manejar las propiedades añadidas al texto, tales como ‘negrilla’ o ‘cursiva’. Nos Saltaremos eso.</p>
<p>La primer línea de la documentación tiene sentido:</p>
<div class="example-block" >
<pre class="example" >Hace que STRING sea el último corte en el anillo de la muerte.
</pre>
</div>
<p>Vamos a saltarnos el resto de la documentación por el momento.</p>
<p>También, vamos a saltar la expresión <code>if</code> inicial y las líneas de código en <code>menu-bar-update-yank-menu</code>. Les explicaremos mas tarde.</p>
<p>Las líneas críticas son estas:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="nv">kill-ring</span><span class="p">)</span>
      <span class="c1">;; entonces</span>
      <span class="p">(</span><span class="nf">setcar</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
    <span class="c1">;; de otra forma</span>
  <span class="p">(</span><span class="nb">push</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring</span> <span class="p">(</span><span class="nf">cons</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
        <span class="c1">;; evita desbordar el anillo de la muerte</span>
        <span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">kill-ring-max</span><span class="p">)</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="no">nil</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">interprogram-cut-function</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="nv">interprogram-cut-function</span> <span class="nf">string</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">replace</span><span class="p">))))</span>
</code></pre>
<p>El test condicional es <code>(and replace kill-ring)</code>. Esto será verdadero cuando se cumplan dos condiciones: el anillo de la muerte tiene algo en el, y la variable <code>replace</code> es verdadera.</p>
<p>Cuando la función <code>kill-append</code> establece <code>replace</code> como verdadero y cuando el anillo de la muerte tiene al menos un elemento en el, se ejecuta la expresión <code>setcar</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">setcar</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
</code></pre>
<p>La función <code>setcar</code> realmente cambia el primer elemento de la lista <code>kill-ring</code> al valor de <code>string</code>. Eso reemplaza el primer elemento.</p>
<p>Por otro lado, si el anillo de la muerte está vacío, o <code>replace</code> es falso, se ejecuta la parte else de la condición:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">push</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">)</span>
</code></pre>
<p><code>push</code> pone su primer argumento dentro del segundo. Es similar a la mas antigua</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring</span> <span class="p">(</span><span class="nf">cons</span> <span class="nf">string</span> <span class="nv">kill-ring</span><span class="p">))</span>
</code></pre>
<p>o la mas reciente</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">add-to-list</span> <span class="nv">kill-ring</span> <span class="nf">string</span><span class="p">)</span>
</code></pre>
<p>Cuando es falso, la expresión primero construye una nueva versión del anillo de la muerte, añadiendo <code>string</code> al anillo como un nuevo elemento (que es lo que hace <code>push</code>). Entonces ejecuta una segunda clausula <code>if</code>. Este segundo <code>if</code> impide que el anillo de la muerte se haga demaciado largo.</p>
<p>Veamos estas dos expresiones en orden.</p>
<p>La línea <code>push</code> de la parte else asigna el nuevo valor del anillo de la muerte a los resultados de agregar la cadena que esta siendo cortada al viejo anillo de la muerte.</p>
<p>Podemos ver cómo funciona esto con un ejemplo.</p>
<p>Primero,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-de-ejemplo</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;aqui hay una clausula&#34;</span> <span class="s">&#34;otra clausula&#34;</span><span class="p">))</span>
</code></pre>
<p>Después de evaluar esta expresión con <kbd>C-x C-e</kbd>, se puede evaluar <code>lista-de-ejemplo</code> y ver que devuelve:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">lista-de-ejemplo</span>
</span><span class="out" >(&#34;aquí hay una claúsula&#34; &#34;otra claúsula&#34;)
</span></code></pre>
<p>Ahora, podemos agregar un nuevo elemento a esta lista evaluando la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">push</span> <span class="s">&#34;una tercera cláusula&#34;</span> <span class="nv">lista-de-ejemplo</span><span class="p">)</span>
</code></pre>
<p>Cuando evaluamos <code>lista-de-ejemplo</code>, encontramos que su valor es:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="nv">lista-de-ejemplo</span>
</span><span class="out" >(&#34;una tercera claúsula&#34; &#34;aquí hay una claúsula&#34; &#34;otra claúsula&#34;)
</span></code></pre>
<p>Asi pues, la tercer claúsula se añade a la lista con <code>push</code>.</p>
<p>Ahora la segunda parte de la claúsula <code>if</code>. Esta expresión evita que el anillo de la muerte crezca demasiado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">kill-ring-max</span><span class="p">)</span> <span class="nv">kill-ring</span><span class="p">)</span> <span class="no">nil</span><span class="p">))</span>
</code></pre>
<p>El código verifica si la longitud del anillo de la muerte es mayor al tamaño máximo permitido. Este es el valor de <code>kill-ring-max</code> (que es 60, por defecto). Si el tamaño del anillo de la muerte es demasiado largo, entonces este código establece el último elemento del anillo de la muerte a <code>nil</code>. Hace esto usando dos funciones, <code>nthcdr</code> y <code>setcdr</code>.</p>
<p>Vimos <code>setcdr</code> anteriormente (ver Seccion <a href="#setcdr" ><code>setcdr</code></a>). Esto asigna el <code>cdr</code> de una lista, asi como <code>setcar</code> asigna el <code>car</code> de una lista. En este caso, sin embargo, <code>setcdr</code> no estará configurando el <code>cdr</code> del anillo de la muerte completo; se usa la función <code>nthcdr</code> para asignar el <code>cdr</code> del último elemento del anillo de la muerte––esto significa que desde el <code>cdr</code> del siguiente al último elemento del anillo de la muerte, se asignará el último elemento del anillo de la muerte.</p>
<p>La función <code>nthcdr</code> funciona tomando repetidamente el <code>cdr</code> de una lista––toma el <code>cdr</code> del <code>cdr</code> del <code>cdr</code> …. hace esto <span class="math" >N</span> veces y devuelve los resultados. (Vea la Seccion <a href="#nthcdr" ><code>nthcdr</code></a>.)</p>
<p>De este modo, si teniamos una lista de cuatro elementos que supuestamente debia tener tres elementos de longitud, podriamos asignar el <code>cdr</code> del elemento siguiente al último a <code>nil</code>, y asi acortar la lista. (Si se asigna el último elemento en algún otro valor distinto a <code>nil</code>, que se podría hacer, entonces no se habría acortado la lista. Véase Sección <a href="#setcdr" ><code>setcdr</code></a>.)</p>
<p>Puedes ver el acortamiento evaluando las tres siguientes expresiones. Primero asigna el valor de <code>arboles</code> a <code>(arce roble pino abedul)</code> luego asigna el <code>cdr</code> de su segundo <code>cdr</code> y entonces descubre el valor de <code>arboles</code>.</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">setq</span> <span class="nv">arboles</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">arce</span> <span class="nv">roble</span> <span class="nv">pino</span> <span class="nv">abedul</span><span class="p">))</span>
</span><span class="out" >(arce roble pino abedul)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">setcdr</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">2</span> <span class="nv">arboles</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
</span><span class="out" >nil

</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">arboles</span>
</span><span class="out" >(arce roble pino)
</span></code></pre>
<p>(El valor devuelto por la expresión <code>setcdr</code> es <code>nil</code>, ya que en esto se establece el <code>cdr</code>.)</p>
<p>Repitiendo, en <code>kill-new</code>, la función <code>nthcdr</code> toma el <code>cdr</code> un número de veces, que es uno menos que el tamaño máximo permitido del anillo de la muerte y <code>setcdr</code> asigna el <code>cdr</code> de este elemento (que será el resto de los elementos en el anillo de la muerte) en <code>nil</code>. Esto evita el anillo de la muerte crezca demaciado largo.</p>
<p>La penultima expresión en la función <code>kill-new</code> es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
</code></pre>
<p><code>kill-ring-yank-pointer</code> es una variable global que se establece para ser el <code>kill-ring</code>.</p>
<p>Apesar de llamar a <code>kill-ring-yank-pointer</code> un <samp>puntero</samp>, es una variable al igual que el anillo de la muerte. Sin embargo, el nombre ha sido elegido para ayudar a los humanos a entender cómo se usa la variable.</p>
<p>Ahora, volviendo a una expresión anterior en el cuerpo de la función:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;menu-bar-update-yank-menu</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">menu-bar-update-yank-menu</span> <span class="nf">string</span> <span class="p">(</span><span class="nb">and</span> <span class="nv">replace</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring</span><span class="p">))))</span>
</code></pre>
<p>Empieza con una expresión <code>if</code></p>
<p>En este caso, la expresión prueba primero si <code>menu-bar-update-yank-menu</code> existe como una función, y si es así, se llama. La función <code>fboundp</code> devuelve verdadero si el símbolo que se prueba tiene una definición de función que ‘no es nula’. Si el símbolo de la definición de función fuera nulo, recibiríamos un mensaje de error, como lo hicimos cuando se crearon errores intencionadamente (ver Seccion <a href="#generar-un-mensaje-de-error" >Generar un mensaje de error</a>).</p>
<p>La parte-entonces contiene una expresión cuyo primer elemento es la función <code>and</code>.</p>
<p>La forma especial <code>and</code> evalúa cada uno de sus argumentos hasta que uno de los argumentos devuelve un valor o <code>nil</code>, en cuyo caso la expresión <code>and</code> devuelve <code>nil</code>; sin embargo, si ninguno de los argumentos devuelve una valor <code>nil</code>, se devuelve el resultado de la evaluación del último argumento. (Dado que tal valor no es <code>nil</code>, en Emacs Lisp se considera verdadero.) En otras palabras, una expresión <code>and</code> devuelve un valor cierto solo si todos sus argumentos son verdaderos. (Vea la Seccion <a href="#Repaso:-Algunas-Funciones-Más-Complejas" >Revisar el segundo búfer relacionado</a>.)</p>
<p>La expresión determina si el segundo argumento <code>menu-bar-update-yank-menu</code> es verdadero o no.</p>
<p><code>menu-bar-update-yank-menu</code> es una de la funciones que permite utilizar el menu ‘Seleccionar y Pegar’ en el elemento Editar de la barra de menu; usando un ratón, pueden ver las distintas piezas de texto que se han guardado y se seleccionar una pieza para pegar.</p>
<p>La última expresión en la función <code>kill-new</code> añade la nueva cadena recien copiada a cualquier facilidad existente para copiar y pegar texto entre diferentes programas que se ejecutan en un sistema de ventanas. En el Sistema de Ventanas X, por ejemplo, la función <code>x-select-text</code> toma la cadena y la almacena en la memoria manejada por X. Puede pegar la cadena en otro programa, como Xterm.</p>
<p>La expresión se ve asi:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">if</span> <span class="nv">interprogram-cut-function</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="nv">interprogram-cut-function</span> <span class="nf">string</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">replace</span><span class="p">))))</span>
</code></pre>
<p>Si <code>interprogram-cut-function</code> existe, entonces Emacs ejecuta <code>funcall</code>, que a su vez llama a su primer argumento como una función y le pasa los argumentos restantes. (Incidentalmente, hasta donde puedo ver, esta expresión <code>if</code> podría reemplazarse por una expresión <code>and</code> similar a la de la primer parte de la función.)</p>
<p>No vamos a discutir mas sobre sistemas de ventanas y otros programas, sino simplemente indicar que este es un mecanismo que permite a GNU Emacs trabajar bien y fácilmente con otros programas.</p>
<p>Este código para colocar texto en el anillo de la muerte, concatenandolo con un elemento existente o como un nuevo, nos brinda la habilidad para traer texto que ha sido cortado del búfer––los comandos de corte (<em>yank</em>). Sin embargo, antes de discutir los comandos de corte, es mejor aprender cómo se implementan las listas en un ordenador. Esto pondra de manifiesto misterios como el uso del término ‘puntero’. Pero antes de eso, nos desviaremos a C.</p>
</div>
<h3 id="disgresión-dentro-de-c" >Disgresión dentro de C</h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> (ver Seccion <a href="#copy-region-as-kill" ><code>copy-region-as-kill</code></a>) usa la función <code>filter-buffer-substring</code>, que a su vez utiliza la función <code>delete-and-extract-region</code>. Eso elimina el contenido de una región y no se puede volverlos a recuperar.</p>
<p>A diferencia del otro código discutido aquí, la función <code>delete-and-extract-region</code> no está escrita en Emacs Lisp; está escrita en C y es una de las primitivas del sistema GNU Emacs. Puesto que es muy simple, voy a desviarme brevemente de Lisp y describirla aquí.</p>
<p>Al igual que muchas de las otras primitivas Emacs, <code>delete-and-extract-region</code> se escribe como una instancia de una macro C, una macro es una plantilla de codigo. La macro completa se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="n">DEFUN</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;delete-and-extract-region&#34;</span><span class="p">,</span> <span class="n">Fdelete_and_extract_region</span><span class="p">,</span>
       <span class="n">Sdelete_and_extract_region</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
       <span class="nl">doc</span><span class="p">:</span> <span class="cm">/* Borra el texto entre START y END y lo devuelve.  */</span><span class="p">)</span>
       <span class="p">(</span><span class="n">Lisp_Object</span> <span class="n">start</span><span class="p">,</span> <span class="n">Lisp_Object</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">validate_region</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">empty_unibyte_string</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">del_range_1</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
<p>Sin entrar en los detalles del proceso de escritura de la macro, permitame señalar que esta macro comienza con la palabra <code>DEFUN</code>. La palabra <code>DEFUN</code> fué elegida ya que el código tiene el mismo propósito que <code>defun</code> en Lisp. (La macro C <code>DEFUN</code> se define en en <span class="file" >emacs/src/lisp.h</span>.)</p>
<p>La palabra <code>DEFUN</code> tiene siete partes dentro de los paréntesis:</p>
<ul>
<li>
<p>La primera parte es el nombre dado a la función en Lisp, <code>delete-and-extract-region</code>.</p>
</li>
<li>
<p>La segunda parte es el nombre de la función en C, <code>Fdelete_and_extract_region</code>. Por convención, comienza con <samp>F</samp>. Puesto que C no usa guiones en los nombres, en su lugar se utilizan guiones bajos.</p>
</li>
<li>
<p>La tercera parte es el nombre para la estructura constante C que registra información en esta función para uso interno. Es el nombre de la función en C pero empieza con una <samp>S</samp> en vez de una <samp>F</samp>.</p>
</li>
<li>
<p>Las partes cuarta y quinta especifican el número mínimo y máximo de argumentos que la función puede tener. Esta función requiere exactamente 2 argumentos.</p>
</li>
<li>
<p>La sexta parte es casi como el argumento que sigue a la declaración <code>interactive</code> en una función escrita en Lisp: una letra seguida, tal vez, por un prompt. La única diferencia con Lisp es que si la macro se llama sin argumentos. Entonces se escribe un <code>0</code> (que es una ‘cadena nula’), como en esta macro.</p>
<p>Si fueras a especificar argumentos, se colocarian entre comillas. La macro C para <code>goto-char</code> incluye <code>\&#34;NGoto char \&#34;</code> en esta posición se indica que la función espera un prefijo en bruto, en este caso, una localización numérica en un búfer, y proporciona un prompt.</p>
</li>
<li>
<p>La séptima parte es una cadena de documentación, como la de una función escrita en Emacs Lisp. Se escribe como un comentario C. (Cuando se escribe Emacs, el programa <code class="command" >lib-src/make-docfile</code> extrae estos comentarios y los usa para crear la documentación “real”.)</p>
</li>
</ul>
<p>En una macro C, los parámetros formales vienen a continuacion, con una declaracion de que tipo de objeto son, seguido por lo que podría llamarse el ‘cuerpo’ de la macro. Para <code>delete-and-extract-region</code> el ‘cuerpo’ se compone de las cuatro líneas siguientes:</p>
<pre class="code" ><code class="chroma" ><span class="n">validate_region</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">==</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">build_string</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;&#34;</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">del_range_1</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
<p>La función <code>validate_region</code> comprueba si los valores pasados como el principio y fin de la región son del tipo apropiado y estan dentro del rango. Si las posiciones de inicio principio y fin son las mismas, entonces devuelve una cadena vacía.</p>
<p>La función <code>del_range_1</code> borra el texto. Es una función compleja que no examinaremos. Actualiza el búfer y hace otras cosas. Sin embargo, vale la pena mirar los dos argumentos pasados a <code>del_range</code>. Estos son <code>XINT (start)</code> y <code>XINT (end)</code>.</p>
<p>Por lo que respecta al lenguaje C, <code>start</code> y <code>end</code> son dos enteros que marcan el principio y el fin de la región a eliminar<span class="note" ><sup><a href="#10" >10</a></sup></span>.</p>
<p>En las primeras versiones de Emacs, estos dos números tenian 32 bits de longitud, pero el código está lentamente siendo generalizado para manejar otras longitudes. Tres de los bits disponibles son usados para especificar el tipo de información; los bits restantes se utilizan como ‘contenido’.</p>
<p><samp>XINT</samp> es una macro C que extrae los números relevantes desde una colección larga de bits; los otros tres bits se descartan.</p>
<p>El comando en <code>delete-and-extract-region</code> se ve asi:</p>
<pre class="code" ><code class="chroma" ><span class="n">del_range_1</span> <span class="p">(</span><span class="n">XINT</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">XINT</span> <span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre>
<p>Borra la región entre la posición inicial, <code>start</code>, y la posición final, <code>end</code>.</p>
<p>Desde el punto de vista de la persona que escribe Lisp, Emacs es muy simple; pero oculta en el fondo mucha complejidad para hacer que funcione.</p>
</div>
<h3 id="inicializando-una-variable-con-defvar" >Inicializando una variable con <code>defvar</code></h3>
<div class="hBody-3" >
<p>La función <code>copy-region-as-kill</code> esta escrita en Emacs Lisp. Dos funciones dentro de ella, <code>kill-append</code> y <code>kill-new</code>, copian una región en un búfer y la guardan en una variable llamada el <code>kill-ring</code>. Esta sección describe cómo se crea e inicializa la variable <code>kill-ring</code> usando la forma especial <code>defvar</code>.</p>
<p>(De nuevo se señala que el término <code>kill-ring</code> es un mal nombre. El texto que se corta del búfer puede ser devuelto; no es un anillo de cadaveres, sino un anillo de texto resucitable.)</p>
<p>En Emacs Lisp, una variable como <code>kill-ring</code> se crea y da un valor inicial usando la forma especial <code>defvar</code>. El nombre proviene de “definir variable”.</p>
<p>La forma especial <code>defvar</code> es similar a <code>setq</code> en la que se establece el valor de una variable. Se diferencia de <code>setq</code> en dos formas: primero solo establece el valor de la variable si la variable no tiene ya un valor. Si la variable ya tiene un valor, <code>defvar</code> no sobreescribe el valor existente. Segundo, <code>defvar</code> tiene una cadena de documentación.</p>
<p>(Otra forma especial, <code>defcustom</code>, está diseñada para variables que la gente personaliza. Tiene más funcionalidades que <code>defvar</code>. (Véase Sección <a href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>.)</p>
<p>Se puede ver el valor actual de una variable, cualquier variable, usando la función <code>describe-variable</code>, que normalmente se invoca escribiendo <kbd>C-h v</kbd>. Si presionas <kbd>C-h v</kbd> y luego escribes <code>kill-ring</code> (seguido por <kbd>RET</kbd>), veras lo que hay actualmente en tu anillo de la muerte––¡esto puede ser bastante grande! Por el contrario, si no has estado haciendo nada en esta sesión en Emacs, excepto leer este documento, es posible no tener nada en el. También, se verá la documentación para <code>kill-ring</code>:</p>
<div class="example-block" >
<pre class="example" >Documentación:
Lista de secuencias de texto muerto (guardado).
Ya que el anillo de la muerte se supone que interactua bien con
el copia-y-pega que ofrecen los sistemas de ventanas, el uso de
esta variable debería interactuar bien con las funciones
‘interprogram-cut-function’ y ‘interprogram-paste-function’.
Las funciones ‘kill-new’, ‘kill-append’, y ‘current-kill’ deben
implementar esta interacción; es posible que desee utilizarlas
en lugar de manipular el anillo de la muerte directamente.
</pre>
</div>
<p>El anillo de la muerte es definido por un <code>defvar</code> del siguiente modo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">kill-ring</span> <span class="no">nil</span>
  <span class="s">&#34;Lista de secuencia de textos cortados.
</span><span class="s">…&#34;</span><span class="p">)</span>
</code></pre>
<p>En esta definición de variable, a la variable se le da un valor inicial de <code>nil</code>, lo que tiene sentido, ya que si no has guardado nada, no quieres nada de vuelta si das un comando <code>yank</code>. La cadena de documentación se escribe igual que la cadena de documentación de un <code>defun</code>. Al igual que con la cadena de documentacion del defun, la primera linea de la documentación deberia ser una frase completa, ya que algunos comandos, como <code>apropos</code>, imprimen solo la primer línea de documentación. Las líneas sucesivas no deben indentarse; de lo contrario, se veran extrañas cuando se use <kbd>C-h v</kbd> (<code>describe-variable</code>).</p>
</div>
<h4 id="defvar-y-un-asterisco" ><code>defvar</code> y un asterisco</h4>
<div class="hBody-4" >
<p>En el pasado, Emacs usaba la forma especial <code>defvar</code> tanto para variables internas que se esperaba que un usuario cambiara como para las que no se esperaban cambios de parte del usuario. Aunque todavía se puede usar <code>defvar</code> para variables personalizadas, por favor, usa <code>defcustom</code> en su lugar, ya que esa forma especial proporciona una ruta a los comando de personalización. (Vea la Seccion <a href="#especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></a>.)</p>
<p>Cuando se especifica una variable utilizando la forma especial <code>defvar</code>, se podría distinguir una variable que un usuario podría querer cambiar de otros escribiendo, <samp>*</samp>, en la primera columna de su cadena de documentación. Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">shell-command-default-error-buffer</span> <span class="no">nil</span>
  <span class="s">&#34;*Nombre de buffer para ‘shell-command’ … salida de error.
</span><span class="s">… &#34;</span><span class="p">)</span>
</code></pre>
<p>Podrías (y todavía puedes) usar el comando <code>set-variable</code> para cambiar temporalmente el valor de <code>shell-command-default-error-buffer</code>. Sin embargo, las opciones configuradas usando <code>set-variable</code> solo se establecen por la duración de tu sesión actual. Los nuevos valores no se guardan entre sesiones. Cada vez que Emacs inicia, lee el valor original, a menos que cambie el valor dentro de su fichero <span class="file" >.emacs</span>, ya sea configurándolo manualmente o utilizando <code>customize</code>. Vea la Seccion <a href="#tu-fichero-.emacs" >Tu Fichero <span class="file" >.emacs</span></a>.</p>
<p>Para mí, el mayor uso del comando <code>set-variable</code> es sugerir variables que se podría querer establecer en mi fichero <span class="file" >.emacs</span>. Ahora hay más de 700 variables, demasiadas para recordarlas fácilmente. Afortunadamente, se puede presionar <kbd>TAB</kbd> después de llamar al comando <code>M-x set-variable</code> para ver la lista de variables. (Vea la Seccion <a href="info:emacs#Examining-and-Setting-Variables" >Examinando y Configurando Variables</a> en <em>El Manual de GNU Emacs</em>.)</p>
</div>
<h3 id="repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí hay un breve resumen de algunas funciones introducidas recientemente.</p>
<dl>
<dt><code>car</code>, <code>cdr</code></dt>
<dd>
<p><code>car</code> devuelve el primer elemento de una lista; <code>cdr</code> devuelve el segundo y los siguientes elementos de una lista.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
</span><span class="out" >1
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
</span><span class="out" >(2 3 4 5 6 7)
</span></code></pre>
</dd>
<dt><code>cons</code></dt>
<dd>
<p><code>cons</code> construye una lista enlazando su primer argumento a su segundo argumento.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">cons</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="out" >(1 2 3 4)
</span></code></pre>
</dd>
<dt><code>funcall</code></dt>
<dd>
<p><code>funcall</code> evalúa su primer argumento como una función. Pasa los argumentos restantes a su primer argumento.</p>
</dd>
<dt><code>nthcdr</code></dt>
<dd>
<p>Devuelve el resultado de tomar <code>cdr</code> ‘n’ veces en una lista. El <span class="math" >n^{th}</span> <code>cdr</code>. El ‘resto del resto’, por asi decirlo.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">))</span>
</span><span class="out" >(4 5 6 7)
</span></code></pre>
</dd>
<dt><code>setcar</code>, <code>setcdr</code></dt>
<dd>
<p><code>setcar</code> cambia el primer elemento de una lista; <code>setcdr</code> cambia el segundo y los siguientes elementos de una lista.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">setq</span> <span class="nv">triple</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span><span class="out" >
</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">setcar</span> <span class="nv">triple</span> <span class="ss">&#39;37</span><span class="p">)</span>
</span><span class="out" >
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">triple</span>
</span><span class="out" >(37 2 3)

</span><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nf">setcdr</span> <span class="nv">triple</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;foo&#34;</span> <span class="s">&#34;bar&#34;</span><span class="p">))</span>
</span><span class="out" >
</span><span class="in" ><span class="prompt" >&gt; </span><span class="nv">triple</span>
</span><span class="out" >(37 &#34;foo&#34; &#34;bar&#34;)
</span></code></pre>
</dd>
<dt><code>progn</code></dt>
<dd>
<p>Evalúa cada argumento en secuencia y luego devuelve el valor del último.</p>
<p>Por ejemplo:</p>
<pre class="srci" ><code class="elisp" ><span class="in" ><span class="prompt" >&gt; </span><span class="p">(</span><span class="nb">progn</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</span><span class="out" >4
</span></code></pre>
</dd>
<dt><code>save-restriction</code></dt>
<dd>
<p>Graba cualquier reduccion (<em>narrowing</em>) que esté en efecto en el búfer actual, si lo hay, y restablece esa reduccion despues de evaluar los argumentos.</p>
</dd>
<dt><code>search-forward</code></dt>
<dd>
<p>Busca una cadena y, si se encuentra, mueve el punto. De manera similar, para una expresión regular utiliza <code>re-search-forward</code>. (Véase Sección <a href="#búsqueda-de-expresiones-regulares" >Búsqueda de Expresiones Regulares</a>, para obtener una explicación de los patrones y busquedas de expresiones regulares.)</p>
<p><code>search-forward</code> y <code>re-search-forward</code> toman cuatro argumentos:</p>
<ol class="num" >
<li>
<p>La cadena o expresión regular a buscar.</p>
</li>
<li>
<p>Opcionalmente, el límite de la búsqueda.</p>
</li>
<li>
<p>Opcionalmente, que haces si la búsqueda falla, devuelve <code>nil</code> o un mensaje de error.</p>
</li>
<li>
<p>Opcionalmente, cuántas veces repetir la búsqueda; si es negativa, la búsqueda va hacia atrás.</p>
</li>
</ol>
</dd>
<dt><code>kill-region</code>, <code>delete-and-extract-region</code>, <code>copy-region-as-kill</code></dt>
<dd>
<p><code>kill-region</code> corta el texto entre el punto y la marca del búfer y almacena ese texto en el anillo de la muerte, para que puedas recuperarlo &#34;tirando&#34; de el.</p>
<p><code>copy-region-as-kill</code> copia el texto entre punto y marca dentro del anillo de la muerte. La función no corta ni elimina el texto del búfer.</p>
</dd>
</dl>
<p><code>delete-and-extract-region</code> elimina el texto entre el punto y la marca del búfer. No puede recuperarse. (Este no es un comando interactivo.)</p>
</div>
<h3 id="ejercicios-de-busqueda" >Ejercicios de Busqueda</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función interactiva que busque una cadena de texto. Si la búsqueda encuentra la cadena, deja el punto después de ella y muestra un mensaje que diga “¡Encontrado!”. (No uses <code>search-forward</code> para el nombre de esta función; si se haces, se sobreescribirá la versión existente de <code>search-forward</code> que viene con Emacs. En su lugar utiliza un nombre como, por ejemplo, <code>test-search</code>.</p>
</li>
<li>
<p>Escribe una función que imprima el tercer elemento del anillo de la muerte en el área de eco, si lo hay; si el anillo de la muerte no contiene un tercer elemento, imprime un mensaje apropiado.</p>
</li>
</ul>
</div>
<h2 id="cómo-se-implementan-las-listas" >Cómo se implementan las listas</h2>
<div class="hBody-2" >
<p>En Lisp, los átomos se graban de manera simple, si la implementación no es sencilla en la práctica, no es, nada sencilla en la teoría. El átomo <samp>rosa</samp>, por ejemplo, se graba como las cuatro letras contiguas <samp>r</samp>, <samp>o</samp>, <samp>s</samp>, <samp>a</samp>. Una lista, por otro lado, se guarda de manera diferente. El mecanismo es igualmente simple, pero toma un momento para tener usada la idea. Una lista se guarda usando una serie de pares de punteros. En las series, el primer puntero en cada par de puntos a un átomo o a otra lista, y el segundo puntero en cada par al siguiente par, o al símbolo <code>nil</code>, que marca el fin de la lista.</p>
<p>Un puntero por sí mismo es poco simple a la dirección electrónica de la que está apuntada. Aquí, una lista se guarda como una serie de direcciones electrónicas.</p>
<p>Por ejemplo, la lista <code>(rosa violeta tulipan)</code> tiene tres elementos, <samp>rosa</samp>, <samp>violeta</samp>, y <samp>tulipan</samp>. En el ordenador, la dirección electrónica de <samp>rosa</samp> se graba en un segmento de memoria del ordenador a través de la dirección que da la dirección electrónica de donde el átomo <samp>violeta</samp> está localizado; y esta dirección (la que cuenta donde <samp>violeta</samp> está se localiza) se guarda con una dirección que cuenta donde la dirección para el átomo <samp>tulipan</samp> se localiza.</p>
<p>Esto parece más complicado de lo que es y es más fácil visto en un diagrama:</p>
<div class="art-block" >
<pre class="art" >    ___ ___      ___ ___      ___ ___
   |___|___|--&gt; |___|___|--&gt; |___|___|--&gt; nil
     |            |            |
     |            |            |
     ---&gt; rosa    ---&gt; violeta ---&gt; tulipan
</pre>
</div>
<p>En el diagrama, cada caja representa una palabra de memoria del ordenador que maneja un objeto Lisp, normalmente en la forma de una dirección de memoria. Las cajas, por ej. las direcciones, están en pares. Cada flecha apunta a lo que la dirección es la dirección de, si un átomo u otro par de direcciones. La primera caja es la dirección electrónica de <samp>rosa</samp> y la flecha apunta a <samp>rosa</samp>; la segunda caja es la dirección del siguiente par de cajas, la primera parte de la que es la dirección de <samp>violeta</samp> y la segunda parte es la dirección del siguiente par. La última caja apunta al símbolo <code>nil</code>, que marca el fin de la lista.</p>
<p>Cuando una variable es configurado a una lista con una función tal como <code>setq</code>, almacena la dirección de la primera caja en la variable. De este modo, la evaluación de la expresión es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">ramo</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">rosa</span> <span class="nv">violeta</span> <span class="nv">tulipan</span><span class="p">))</span>
</code></pre>
<p>crea una situación como esta:</p>
<div class="art-block" >
<pre class="art" >ramo
     |
     |     ___ ___      ___ ___      ___ ___
      --&gt; |___|___|--&gt; |___|___|--&gt; |___|___|--&gt; nil
            |            |            |
            |            |            |
             --&gt; rosa     --&gt; violeta   --&gt; tulipan
</pre>
</div>
<p>En este ejemplo, el símbolo <code>ramo</code> maneja la dirección del primer par de cajas.</p>
<p>Esta misma lista puede ser ilustrada en un modo diferente de anotación de cajas como esta:</p>
<div class="art-block" >
<pre class="art" >ramo
 |
 |    --------------       ----------------       --------------------
 |   | car   | cdr  |     | car     | cdr  |     | car         | cdr  |
  --&gt;| rosa  |   o-------&gt;| violeta |   o-------&gt;| tulipan  | nil  |
     |       |      |     |         |      |     |             |      |
      --------------       ----------------       --------------------
</pre>
</div>
<p>(Los símbolos consisten de más pares de direcciones, pero la estructura de un símbolo es hecha de direcciones. De manera profunda, el símbolo <code>ramo</code> consiste de un grupo de cajas-de-direcciones, una que es la dirección de la palabra impresa <samp>ramo</samp>, una segunda de la que es la dirección de una definición de función adjunta al símbolo, si cualquiera, un tercero del que es la dirección del primer par de cajas-de-direccion para la lista <code>(rosa violeta tulipan)</code>, y así. Aquí se está mostrando que la tercera caja de dirección del símbolo apunta al primer par de cajas-de-direccion para la lista.)</p>
<p>Si un símbolo se asigna al <code>cdr</code> de una lista, la lista en sí no cambia; el símbolo simplemente tiene una dirección abajo de la lista. (En la jerga, <code>car</code> y <code>cdr</code> son ‘no destructivos’.) De este modo, se evalúa la siguiente expresión</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">flores</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">ramo</span><span class="p">))</span>
</code></pre>
<p>produce esto:</p>
<div class="art-block" >
<pre class="art" >ramo        flores
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --&gt; |   |   |  --&gt; |   |   |    |   |   |
       |___|___|----&gt; |___|___|--&gt; |___|___|--&gt; nil
         |              |            |
         |              |            |
          --&gt; rosa       --&gt; violeta  --&gt; tulipan
</pre>
</div>
<p>El valor de <code>flores</code> es <code>(violeta tulipan)</code>, esto es decir que el símbolo <code>flores</code> maneja la dirección del par address-boxes el primero que maneja la dirección de <code>violeta</code>, y el segundo que maneja la dirección de <code>tulipan</code>.</p>
<p>Un par de cajas-de-direcciones se llama una <dfn>cons cell</dfn> o <dfn>par de puntos</dfn>. Vea la Seccion &#34;la Célula Cons y los Tipos Lista&#34; en <em>El Manual de Referencia de Emacs Lisp</em>, y <q>Notación de Pares de Puntos</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información acerca de células cons y pares de puntos.</p>
<p>La función <code>cons</code> añade un nuevo par de direcciones al frente de una serie de direcciones como son mostradas debajo. Por ejemplo, evaluando la expresión</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">ramo</span> <span class="p">(</span><span class="nf">cons</span> <span class="ss">&#39;lila</span> <span class="nv">ramo</span><span class="p">))</span>
</code></pre>
<p>produce:</p>
<div class="art-block" >
<pre class="art" >ramo                       flores
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --&gt; |   |   |      |   |   |  --&gt; |   |   |     |   |   |
       |___|___|----&gt; |___|___|----&gt; |___|___|----&gt;|___|___|--&gt; nil
         |              |              |             |
         |              |              |             |
          --&gt; lila      --&gt; rosa       --&gt; violeta    --&gt; tulipan
</pre>
</div>
<p>Sin embargo, esto no cambia el valor del símbolo <code>flores</code>, así puedes ver evaluando lo siguiente,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">eq</span> <span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">ramo</span><span class="p">))</span> <span class="nv">flores</span><span class="p">)</span>
</code></pre>
<p>que devuelve <code>t</code> para verdad.</p>
<p>Hasta que se resetea, <code>flores</code> todavía tiene el valor de <code>(violeta tulipan)</code>; que es, eso tiene la dirección de la celula cons cuya primera dirección es <code>violeta</code>. También, esto no altera cualquier célula prexistente cons; ellas está todavía allí.</p>
<p>De este modo, en Lisp, tiene el <code>cdr</code> de una lista, se obtiene la dirección del siguiente cons en las serie; para tener el <code>car</code> de una lista, se obtiene la dirección del primer elemento de la lista; para <code>cons</code> un nuevo elemento en una lista, se añade una nueva célula cons al frente de la lista. ¡Esto es todo lo que hay así! ¡La estructura subyacente de Lisp es brillantemente simple!</p>
<p>¿Y qué hace la última dirección en una serie de células cons se refieren? Eso es la dirección de la lista vacía, de <code>nil</code>.</p>
<p>En resumen, cuando una variable Lisp es asignada a un valor, eso provee con la dirección de la lista a la que la variable se refiere.</p>
</div>
<h3 id="símbolos-como-una-caja-con-cajones" >Símbolos como una caja con cajones</h3>
<div class="hBody-3" >
<p>En una sección temprana, se sugería que se podría imaginar un símbolo siendo una caja con cajones. La definición de función se pone en un cajón, el valor en otro, y así. Lo que se pone en el cajón maneja el valor que puede cambiarse sin afectar a los contenidos del cajón manejando la definición de función, y viceversa.</p>
<p>Actualmente, lo que está puesto en cada cajón es la dirección del valor o definición de función. Eso es como si se encontrara un viejo cajón en el ático, y en uno de sus cajones se encontrara un mapa dándote direcciones a donde está el tesoro escondido.</p>
<p>(Además de su nombre, la definición del símbolo, y un valor de la variable, un símbolo tiene un ‘cajón’ para una <dfn>lista de propiedades</dfn> que puede ser usada para grabar otra información. Las listas de propiedades no se discuten aquí; ver <a href="Listas-de-Propiedades,-,-Listas-de-Propiedades,-elisp,-El-Manual-de-Referencia-de-Emacs-Lisp" >Listas de Propiedades, , Listas de Propiedades, elisp, El Manual de Referencia de Emacs Lisp</a>.)</p>
<p>Aquí hay una representación visionaria:</p>
<div class="art-block" >
<pre class="art" >            Caja de Cajones            Contenidos de Cajones

            __   o0O0o   __
          /                 \
         ---------------------
        |    direcciones al   |            [mapeo a]
        | nombre del simbolo  |            ramo
        |                     |
        +---------------------+
        |  direcciones a la   |
        |   definición del    |            [nunca]
        |    simbolo          |
        +---------------------+
        |    direcciones al   |            [mapeo a]
        |   valor de variable |            (rosa violeta tulipan)
        |                     |
        +---------------------+
        |    direcciones a la |
        |lista de propiedades |            [no descrito aquí]
        |                     |
        +---------------------+
        |/                   \|
</pre>
</div>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Asignar <code>flores</code> a <code>violeta</code> y <code>tulipan</code>. Asigna dos flores más en esta lista y asigna esta nueva lista a <code>mas-flores</code>. Asigna el <code>car</code> de <code>flores</code> a un pez. ¿Qué lista contiene ahora <code>mas-flores</code>?</p>
</div>
<h2 id="pegando-texto" >Pegando texto</h2>
<div class="hBody-2" >
<p>Siempre y cuando se corta texto fuera de un búfer con un comando `kill’ en GNU Emacs, se puede traer con un comando ‘pegar’. El texto cortado del búfer es puesto en el anillo de la muerte y en los comandos pegar, se insertan los contenidos apropiados del kill ring detrás de un búfer (no necesariamente el búfer original).</p>
<p>Un simple comando <kbd>C-y</kbd> (<code>yank</code>) inserta el primer ítem desde el anillo de la muerte dentro del actual búfer. Si el comando <kbd>C-y</kbd> es seguido inmediatamente para <kbd>M-y</kbd>, el primer elemento se reemplaza por el segundo elemento. Los sucesivos comandos <kbd>M-y</kbd> reemplazan el segundo elemento con el tercer, cuarto, o quinto elemento, y así. Cuando se llega al último elemento en el anillo de la muerte, se reemplaza por el primer elemento y el ciclo se repite. (De este modo, el kill ring se llama un ‘anillo’ en vez de solo una ‘lista’. Sin embargo, la estructura de de datos actual que maneja el texto es una lista. Vea la Seccion <a href="Qué-hace-el-anillo-de-la-muerte,-,-Manejando-el-anillo-de-la-muerte" >Qué hace el anillo de la muerte, , Manejando el anillo de la muerte</a>, para los detalles de cómo la lista es manejada como un anillo.)</p>
</div>
<h3 id="resumen-del-anillo-de-la-muerte" >Resumen del anillo de la muerte</h3>
<div class="hBody-3" >
<p>El anillo de la muerte es una lista de cadenas textuales. Esto es lo que se ve:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;algún texto&#34;</span> <span class="s">&#34;una pieza diferente pieza de texto&#34;</span>
<span class="s">&#34;todavía más texto&#34;</span><span class="p">)</span>
</code></pre>
<p>Si estos fueran los contenidos de mi anillo de la muerte y yo presionara <kbd>C-y</kbd>, la cadena de caracteres diciendo <samp>algún texto</samp> sería insertado en este búfer donde mi cursor está localizado.</p>
<p>El comando <code>yank</code> <em>pegar</em> es también usado para duplicar texto copiándolo. El texto copiado no es cortado desde el búfer, pero una copia de eso se pone en el anillo de la muerte y se inserta pegándolo.</p>
<p>Tres funciones se usan para atraer texto desde el anillo de la muerte <em>kill ring</em>: <code>yank</code> (<em>pegar</em>), que normalmente se asocian a <kbd>C-y</kbd>; <code>yank-pop</code>, que normalmente se asocia a <kbd>M-y</kbd>; y <code>rotate-yank-pointer</code>, que se usa por las otras dos funciones.</p>
<p>Estas funciones se refieren al kill ring <em>anillo de la muerte</em> a través de una variable llamada el <code>kill-ring-yank-pointer</code>. En vez de eso, la inserción del código para ambos son las funciones <code>yank</code> y <code>yank-pop</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">kill-ring-yank-pointer</span><span class="p">))</span>
</code></pre>
<p>(Bien, no más. En GNU Emacs 22, la función se ha reemplazado por <code>insert-for-yank</code> que llama a <code>insert-for-yank-1</code> repetitivamente para cada segmento <code>yank-handler</code>. En vez de eso, <code>insert-for-yank-1</code> destituye las propiedades de texto desde el texto insertado de acuerdo a <code>yank-excluded-properties</code>. De otro modo, eso es como <code>insert</code>. Nosotros lo pegamos con un <code>insert</code> plano puesto que sea fácil de comprender.)</p>
<p>Para empezar a comprender cómo <code>yank</code> y <code>yank-pop</code> funcionan, primero es necesario mirar en la variable <code>kill-ring-yank-pointer</code>.</p>
</div>
<h3 id="la-variable-kill-ring-yank-pointer" >La variable <code>kill-ring-yank-pointer</code></h3>
<div class="hBody-3" >
<p><code>kill-ring-yank-pointer</code> es una variable, solo como <code>kill-ring</code> es una variable. Eso apunta a alguna cosa siendo asignada al valor de lo que apunta, como cualquier otra variable Lisp.</p>
<p>De este modo, si el valor del kill ring es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;algún texto&#34;</span> <span class="s">&#34;una pieza diferente pieza de texto&#34;</span>
<span class="s">&#34;todavía más texto&#34;</span><span class="p">)</span>
</code></pre>
<p>y el <code>kill-ring-yank-pointer</code> apunta a la segunda cláusula, el valor de <code>kill-ring-yank-pointer</code> es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;una pieza diferente de texto&#34;</span> <span class="s">&#34;todavía más texto&#34;</span><span class="p">)</span>
</code></pre>
<p>Como se explica en el capítulo previo (Vea la Seccion <a href="Cómo-se-implementan-las-listas" >Cómo se implementan las listas</a>), el ordenador no guarda dos copias diferentes del texto siendo apuntado por ambos el <code>kill-ring</code> (el <em>anillo de la muerte</em>) y el <code>kill-ring-yank-pointer</code> (el <em>puntero de pegar el anillo de la muerte</em>). Las palabras “una pieza diferente de texto” y “todavía más texto” no están duplicadas. En vez de eso, las dos variables Lisp apuntan a las mismas piezas de texto. Aquí hay un diagrama:</p>
<div class="art-block" >
<pre class="art" >kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---&gt; |   |   |  --&gt; |   |   |    |   |   |
          |___|___|----&gt; |___|___|--&gt; |___|___|--&gt; nil
            |              |            |
            |              |            |
            |              |             --&gt; &#34;todavía más texto&#34;
            |              |
            |               --&gt; &#34;una pieza diferente de texto&#34;
            |
             --&gt; &#34;algo de texto&#34;
</pre>
</div>
<p>Tanto la variable <code>kill-ring</code> y la variable <code>kill-ring-yank-pointer</code> son punteros. Pero el kill ring <em>anillo de la muerte</em> en sí es normalmente descrito como si fuera actualmente de lo que está compuesto. El <code>kill-ring</code> se refiere a lo que es la lista en vez de lo que apunta a la lista. Conversando, el <code>kill-ring-yank-pointer</code> se refiere a como se apunta a una lista.</p>
<p>Estas dos maneras hablar acerca de la misma cosa suena confuso al principio pero tiene sentido para reflexionar. El kill ring <em>anillo de la muerte</em> es generalmente pensado como la estructura completa de datos que manejan la información de lo que se ha cortado reciéntemente de los búfers de Emacs. El <code>kill-ring-yank-pointer</code> en la otra mano, sirve para indicar --- que es, para ‘apuntar a’ --- esta parte del anillo de la muerte del que el primer elemento (el <code>car</code>) será insertado.</p>
</div>
<h3 id="ejercicios-con-yank-y-nthcdr" >Ejercicios con <code>yank</code> y <code>nthcdr</code></h3>
<div class="hBody-3" >
<ul>
<li>
<p>Usando <kbd>C-h v</kbd> (<code>describe-variable</code>), mira en el valor de tu kill ring <em>anillo de la muerte</em>. Añade varios ítems a tu anillo de la muerte; mira en su valor de nuevo. Usando <kbd>M-y</kbd> (<code>yank-pop</code>, mueve todo el camino alrededor del kill ring <em>anillo de la muerte</em>. ¿Cuántos ítems estaban en tu kill ring <em>anillo de la muerte</em>? Encuentra el valor de <code>kill-ring-max</code>. ¿Estaba tu anillo de la muerte completo, o podrías haber guardado más bloques de texto dentro?</p>
</li>
<li>
<p>Usando <code>nthcrd</code> y <code>car</code>, construye una serie de expresiones para devolver, el primer, segundo, tercer y cuarto elemento de una lista.</p>
</li>
</ul>
</div>
<h2 id="bucles-y-recursión" >Bucles y recursión</h2>
<div class="hBody-2" >
<p>Emacs Lisp tiene dos caminos primarios para causar una expresión, o una serie de expresiones, para ser evaluado repetidamente: uno usa un bucle <code>while</code>, y el otro usa <dfn>recursión</dfn>.</p>
<p>La repetición puede ser valorable. Por ejemplo, para mover hacia delante cuatro frases, tu solo necesitas escribir un programa que moverá hacia delante una frase y entonces repite el proceso cuatro veces. Ya que un ordenador no está aburrido o cansado, tal acción repetitiva no tiene los efectos de borrado por equivocación o exceso que pueden tener los humanos.</p>
<p>La gente mayoritariamente escribe funciones de Emacs Lisp usando bucles <code>while</code>; pero se puede usar recursión, que provee un poderoso camino mental para resolver problemas<span class="note" ><sup><a href="#10" >10</a></sup></span>.</p>
</div>
<h3 id="while" ><code>while</code></h3>
<div class="hBody-3" >
<p>La forma especial <code>while</code> chequea si el valor devuelto para evaluar el primer argumento es verdadero o falso. Esto es parecido a lo que el intérprete Lisp hace con un <code>if</code>; el intérprete hace lo siguiente, sin embargo, es diferente.</p>
<p>En una expresión <code>while</code>, si el valor devuelto por evaluar el primer argumento es falso, el intérprete Lisp descarta el resto de la expresión (el <dfn>cuerpo</dfn> de la expresión) y no la evalúa. Sin embargo, si el valor es cierto, el intérprete Lisp evalúa el cuerpo de la expresión y entonces de nuevo chequea si el primer argumento para <code>while</code> es cierto o falso. Si el valor devuelto de evaluar el primer argumento es cierto de nuevo, el intérprete Lisp evalúa el cuerpo de la expresión.</p>
<p>La plantilla para una expresión <code>while</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">@V{test-verdadero-o-falso}</span>
  <span class="nv">@V{cuerpo}</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>En el momento en el que el true-or-false-test de la expresión <code>while</code> devuelve un valor cierto cuando eso se evalúa, el cuerpo es repetidamente evaluado. Este proceso se llama bucle puesto que el intérprete Lisp repite la misma cosa una y otra vez, como un avión haciendo un loop. Cuando el resultado de evaluar el true-or-false-test es falso, el intérprete Lisp no evalúa el resto de la expresión <code>while</code> y ‘existe el bucle’.</p>
<p>Claramente, si el valor devuelto evaluando el primer argumento para <code>while</code> es siempre cierto, el cuerpo siguiente será evaluado una y otra vez … y … para siempre. Recíprocamente, si el valor devuelto nunca es cierto, las expresiones en el cuerpo nunca serán evaluadas. La fortaleza de escribir un bucle <code>while</code> consiste de elegir un mecanismo tal que el true-or-false-test devuelva cierto solo el número de veces que requieren las subsiguientes expresiones para ser evaluadas, y entonces tener el test devuelto a falso.</p>
<p>El valor devuelto evaluando <code>while</code> es el valor del true-or-false-test. Una consecuencia interesante de esto es que un bucle <code>while</code> que evalúa sin errores devolverá <code>nil</code> o falso sin dignidad de si eso ha girado 1 o 100 veces o ninguna. ¿Una expresión <code>while</code> que se evalúa de manera exitosa nunca devuelve un valor cierto! Lo que esto significa es que <code>while</code> es siempre evaluado por sus efectos laterales, que es decir, las consecuencias de evaluar las expresiones con el cuerpo del bucle <code>while</code>. Esto tiene sentido. Eso no es el mero acto del bucle que es deseado, pero las consecuencias de lo que ocurre cuando las expresiones en el bucle son repetidamente evaluadas.</p>
</div>
<h4 id="un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</h4>
<div class="hBody-4" >
<p>Un camino común para controlar un bucle <code>while</code> es chequear si una lista tiene cualquier elemento. Si eso se hace, el bucle se repite; pero si no, la repetición se finaliza. Puesto que esto es una técnica importante, se creará un breve ejemplo para ilustrarlo.</p>
<p>Un camino simple para chequear si una lista tiene elementos es evaluar la lista: si eso no tiene elementos, si es una lista vacía y devuelve la lista vacía, <code>()</code>, que es un sinónimo para <code>nil</code> o falso. Por otro lado, una lista con elementos devolverá estos elementos cuando eso se evalúa. Puesto que Emacs Lisp considera como cierto cualquier valor que no es <code>nil</code>, una lista que devuelve elementos chequeará cierto en un bucle <code>while</code>.</p>
<p>Por ejemplo, se puede asignar la variable <code>empty-list</code> a <code>nil</code> para evaluar la siguiente expresión <code>setq</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">lista-vacia</span> <span class="p">())</span>
</code></pre>
<p>Después de evaluar la expresión <code>setq</code>, se puede evaluar la variable <code>lista-vacia</code> es el camino normal, posicionando el cursor después del símbolo y escribiendo <kbd>C-x C-e</kbd>; <code>nil</code> aparecerá en tu área de eco:</p>
<pre class="code" ><code class="chroma" ><span class="nv">lista-vacia</span>
</code></pre>
<p>Por otro lado, si se asigna una variable para ser una lista con elementos, la lista aparecerá cuando se evalúe la variable, como se puede ver evaluando las siguientes dos expresiones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="nv">animales</span>
</code></pre>
<p>De este modo, para un bucle <code>while</code> que chequea si hay cualquier ítem en la lista <code>animales</code>, la primera parte del bucle será escrito así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">animales</span>
       <span class="err">…</span>
</code></pre>
<p>Cuando el <code>while</code> chequea su primer argumento, la variable <code>animales</code> se evalúa. Eso devuelve una lista. Mientras la lista tiene elementos, el <code>while</code> considera los resultados del test para ser verdadero; pero cuando la lista es vacía, eso considera los resultados del test para ser falso.</p>
<p>Para prevenir que el bucle <code>while</code> se ejecute siempre, se necesita proporcionar algún mecanismo. Una técnica usada con frecuencia es tener una de las subsiguientes formas en la expresión <code>while</code> que asigna el valor de la lista para ser el <code>cdr</code> de la lista. Cada vez que la función <code>cdr</code> se evalúa, se va reduciendo, hasta que finalmente solo queda la lista vacía. En este punto, el test del bucle <code>while</code> devolverá falso, y los argumentos para el <code>while</code> no se evaluarán.</p>
<p>Por ejemplo, la lista de animales asociada a la variable <code>animals</code> se puede asignar a ser el <code>cdr</code> de la lista original con la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animals</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">animals</span><span class="p">))</span>
</code></pre>
<p>Si se han evaluado las expresiones previas y entonces se evalúa esta expresión, se verá <code>(jirafa leon tigre)</code> que aparecerá en el área echo. Si se evalúa la expresión de nuevo, <code>(leon tigre)</code> aparecerá en el área de eco. Si se evalúa de nuevo, <code>(tigre)</code> y todavía de nuevo aparecerá la lista vacía y se mostrará como <code>nil</code>.</p>
<p>Una plantilla para un bucle <code>while</code> usa la función <code>cdr</code> repetidamente para causar el true-or-false-test finalmente para chequear la veracidad y se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">@V{test-whether-list-is-empty}</span>
  <span class="nv">@V{body}</span><span class="err">…</span>
  <span class="nv">@V{set-list-to-cdr-of-list}</span><span class="p">)</span>
</code></pre>
<p>Este chequeo y uso de <code>cdr</code> puede ser puesto junto a una función que va a través de una lista e imprime cada elemento de la lista en una línea de sí misma.</p>
</div>
<h4 id="un-ejemplo:-imprimir-elementos-de-la-lista" >Un ejemplo: <code>imprimir-elementos-de-la-lista</code></h4>
<div class="hBody-4" >
<p>La función <code>imprimir-elementos-de-la-lista</code> ilustra un bucle <code>while</code> con una lista.</p>
<p>La función requiere varias líneas por su salida. Si estás leyendo esto en una instancia reciente de GNU Emacs, se puede evaluar la siguiente expresión dentro de Info, de normal.</p>
<p>Si se está usando una versión antigua de Emacs, es necesario copiar las expresiones necesarias para el búfer <span class="file" >*scratch*</span> y evaluarlas allí. Esto es porque el área de eco tenía solo una línea en las versiones antiguas.</p>
<p>Se pueden copiar las expresiones marcando el principio de la región con <kbd>C-<kbd>SPC</kbd></kbd> (<code>set-mark-command</code>), moviendo el cursor al fin de la región y entonces copiando la región usando <kbd>M-w</kbd> (<code>kill-ring-save</code>, que llama a <code>copy-region-as-kill</code> y entonces provee realimentación visual). En el búfer <span class="file" >*scratch*</span>, se pueden copiar las expresiones escribiendo <kbd>C-y</kbd> (<code>yank</code>).</p>
<p>Después de haber copiado las expresiones al búfer <span class="file" >*scratch*</span>, se evalúa cada expresión en orden. Asegúrese de evaluar la última expresión, <code>(imprimir-elementos-de-la-lista animales)</code>, escribiendo <kbd>C-u C-x C-e</kbd>, que es, dando un argumento para <code>eval-last-sexp</code>. Esto causará el resultado de la evaluación para ser impreso en el búfer <span class="file" >*scratch*</span> en vez de siendo impreso en el área de eco. (De otro modo se verá alguna cosa como esto en tu área de eco: <code>^Jgacela^J^Jjirafa^J^Jleon^J^Jtigre^Jnulo</code>, en cada <samp>^J</samp> se estructura una ‘nueva línea’.)</p>
<p>En una instancia de GNU Emacs reciente, se pueden evaluar estas expresiones directamente en el búfer Info, y el área de eco crecerá para mostrar los resultados.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">imprimir-elementos-de-la-lista</span> <span class="p">(</span><span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Imprime cada elemento de LIST en una línea.&#34;</span>
  <span class="p">(</span><span class="nb">while</span> <span class="nf">list</span>
    <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">list</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nf">list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">list</span><span class="p">))))</span>

<span class="p">(</span><span class="nv">imprimir-elementos-de-la-lista</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>Cuando se evalúan las tres expresiones en secuencia, se verá esto:</p>
<div class="example-block" >
<pre class="example" >gacela

jirafa

leon

tigre
nil
</pre>
</div>
<p>Cada elemento de la lista se imprime en una línea en sí (que es lo que la función <code>print</code> hace) y entonces el valor devuelto por la función se imprime. Desde que la última expresión en la función es el bucle <code>while</code>, y desde que el bucle <code>while</code> siempre devuelve <code>nil</code>, un <code>nil</code> se imprime después del último elemento de la lista.</p>
</div>
<h4 id="un-bucle-con-un-contaje-incremental" >Un bucle con un contaje incremental</h4>
<div class="hBody-4" >
<p>Un bucle no es útil a menos que pare cuando debe. Bajo el control de un bucle con una lista, un camino común de parar un bucle es escribir el primer argumento como un test que devuelve falso cuando el número correcto de repeticiones es completo. Esto significa que el bucle debe tener un contador––una expresión que cuenta cuántas veces el bucle se repite a sí mismo.</p>
<p>El test para un bucle con un contador de incremento puede ser una expresión tal como <code>(&lt; contador numero-deseado)</code> que devuelve <code>t</code> para verdad si el valor de <code>contador</code> es menor que el <code>numero-deseado</code> de repeticiones y <code>nil</code> para falso si el valor de <code>contador</code> es igual a o es mayor que el <code>numero-deseado</code>. La expresión que incrementa el contador puede ser un simple <code>setq</code> tal como <code>(setq contador (1+ contador))</code>, donde <code>1+</code> es una función construida en Emacs Lisp que añade 1 a su argumento. (La expresión <code>(1+ contador)</code> tiene el mismo resultado que <code>(+ contador 1)</code>, que es fácil de leer para un humano.)</p>
<p>La plantilla para un bucle <code>while</code> controlado por un contador que se incrementa se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="nv">@V{asignar-contador-al-valor-inicial}</span>
<span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">contador</span> <span class="nv">numero-deseado</span><span class="p">)</span>         <span class="c1">; true-or-false-test</span>
  <span class="nv">@V{body}</span><span class="err">…</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">contador</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">contador</span><span class="p">)))</span>              <span class="c1">; incremento</span>
</code></pre>
<p>Note que se necesita asignar el valor inicial de <code>contador</code>; normalmente asignado a 1.</p>
</div>
<h5 id="ejemplo-con-contador-incremental" >Ejemplo con contador incremental</h5>
<div class="hBody-5" >
<p>Supón que estás jugando en la playa y decides crear un triángulo de asteriscos, poniendo un asterisco en la primera fila, dos en la segunda fila, tres en la tercera fila y así:</p>
<div class="example-block" >
<pre class="example" >               *
              * *
             * * *
            * * * *
</pre>
</div>
<p>(Hace 2500 años, Pitágoras y otras desarrollaron los principios de la teoría de números considerando preguntas como esta.)</p>
<p>Supón que quieres saber cuántos asteriscos necesitarás crear para un triángulo con 7 filas</p>
<p>Claramente, lo que necesitas hacer es añadir los números de 1 a 7. Hay dos caminos para hacer esto; se puede comenzar con los números más pequeños, uno, y añadir la lista en secuencia, 1, 2, 3, 4 y así; o empieza con el número más largo y añade la lista bajando: 7, 6, 5, 4 y así. Porque ambos mecanismos ilustran caminos comunes de escribir el bucle <code>while</code>, crearemos dos ejemplos, uno contando hacia arriba y el otro contando hacia abajo. En este primer ejemplo, empezaremos con 1 y añadimos 2, 3, 4 y así.</p>
<p>Si se quiere sumar toda una lista de números, el camino más fácil para hacer eso es sumar todos los números a la vez. Sin embargo, si no se sabe cuántos números tendrá la lista, o si se requiere estar preparado para una lista muy larga, entonces se necesita diseñar la adición, esto es, repetir un proceso simple muchas veces en vez de hacer un proceso más complejo.</p>
<p>Por ejemplo, en vez de añadir todos los asteriscos a la vez, lo que se puede hacer es añadir el número de asteriscos en la primera fila, 1, para el número en la segunda fila, 2, y entonces añadir el total de estas dos filas a la tercera fila, 3. Entonces se puede añadir el número en la cuarta fila, 4, al total de las primeras tres filas; y así.</p>
<p>La característica crítica del proceso es que cada acción repetitiva sea simple. En este caso, en cada paso nosotros añadimos solo dos números, el número de asteriscos en la fila y el total ya encontrado. Este proceso de añadir dos números es repetido de nuevo y de nuevo hasta la última fila que ha sido añadida al total de todas las filas precedentes. En un bucle más complejo la acción repetitiva podría no ser tan simple, pero será tan simple como hacer todo a la vez.</p>
</div>
<h5 id="las-partes-de-la-definición-de-función" >Las partes de la definición de función</h5>
<div class="hBody-5" >
<p>El análisis precedente nos da los bonos de nuestra definición de función: primero, necesitaremos una variable que podemos llamar <code>total</code> que será el número total de asteriscos. Esto será el valor devuelto por la función.</p>
<p>Segundo, sabemos que la función requerirá un argumento: este argumento será el número de filas en el triángulo. Eso puede llamarse <code>number-of-rows</code>.</p>
<p>Finalmente, se necesita una variable para usarse como contador. Se podría llamar a esta variable <code>counter</code>, pero un nombre mejor es <code>row-number</code>. Debido a que lo que el contador hace en esta función es contar filas, y un programa debería escribirse para ser comprendido en la medida de lo posible.</p>
<p>Cuando el intérprete Lisp primero empieza evaluando las expresiones de la función, el valor de <code>total</code> estaría asignado a cero, ya que no hemos añadido cualquier cosa a eso. Entonces la función añadiría el número de asteriscos en la primera fila al total, y entonces añade el número de asteriscos en la segunda al total, y entonces añade el número de asteriscos a la tercera fila al total, y así, hasta que no hay más filas a la izquierda para añadir.</p>
<p>Ambos <code>total</code> y <code>row-number</code> se usan solo dentro de la función, así ellos pueden ser declarados como variables locales con <code>let</code> y valores iniciales dados. Claramente, el valor inicial para total sería 0. El valor inicial de <code>row-number</code> sería 1, desde que se comienza con la primera fila. Esto significa que la frase <code>let</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" >  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">row-number</span> <span class="mi">1</span><span class="p">))</span>
    <span class="nv">@V{body}</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Después de que las variables internas se declaran y se asignan a sus valores iniciales se podría empezar el bucle <code>while</code>. La expresión que sirve como el test devolvería un valor de <code>t</code> para la verdad tan grande como el <code>row-number</code> que es menor o igual al <code>number-of-rows</code>. (La expresión devuelve cierto solo si el número de fila es menor que el número de filas en el triángulo, la última fila nunca será añadida al total; aquí el número de fila tiene que ser menor o igual el número de filas.))</p>
<p>Lisp provee la función <code>&lt;=</code> que devuelve cierto si el valor de su primer argumento es menor o igual al valor de su segundo argumento y falso de otro modo. Así la expresión que el <code>while</code> evaluará como si su test se vería como esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">row-number</span> <span class="nv">number-of-rows</span><span class="p">)</span>
</code></pre>
<p>El número de asteriscos puede encontrarse repetidamente añadiendo el número de asteriscos en una fila al total ya encontrado. Puesto que el número de asteriscos en la fila es igual al número de la fila, el total puede encontrarse añadiendo el número de filas al total. (Claramente, en una situación más compleja, el número de asteriscos en la fila podría ser relacionada al número de la fila en un camino más complicado; si este fuera el caso, el número de fila sería reemplazado por la expresión apropiada.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">row-number</span><span class="p">))</span>
</code></pre>
<p>Lo que esto hace es asignar el nuevo valor de <code>total</code> a ser igual a la suma de añadiendo el número de asteriscos en la fila al total previo.</p>
<p>Después de configurar el valor de <code>total</code>, las condiciones deben ser establecidas para la siguiente repetición del bucle, si hay alguna. Esto se hace incrementando el valor de la variable <code>row-number</code>, que sirve como un contador. Después que la variable <code>row-number</code> ha sido incrementada, el true-or-false-test al principio del bucle <code>while</code> chequea si su valor es todavía menor o igual al valor del <code>number-of-rows</code> y si eso es, añade el nuevo valor de la variable <code>row-number</code> al <code>total</code> de la repetición del bucle.</p>
<p>La función construida en Emacs Lisp <code>1+</code> añade 1 a un número, así la variable <code>row-number</code> puede ser incrementado con esta expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">row-number</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">row-number</span><span class="p">))</span>
</code></pre>
</div>
<h5 id="poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</h5>
<div class="hBody-5" >
<p>Nosotros hemos creado las partes para la definición de la función; ahora necesitamos ponerlas juntas.</p>
<p>Primero, los contenidos de la expresión <code>while</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">row-number</span> <span class="nv">number-of-rows</span><span class="p">)</span>   <span class="c1">; true-or-false-test</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">row-number</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">row-number</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">row-number</span><span class="p">)))</span>    <span class="c1">; incremento</span>
</code></pre>
<p>Tener la expresión <code>let</code> de varlist, se acerca a completar el cuerpo de la definición de función. Sin embargo, eso requiere un elemento final, la necesidad para la que es alguna cosa pequeña.</p>
<p>El toque final es emplazar la variable <code>total</code> en una línea por sí misma después de la expresión <code>while</code>. De otro modo, el valor devuelto por la función completa es el valor de la última expresión que es evaluada en el cuerpo del <code>let</code>, y este es el valor devuelto por el <code>while</code> que es siempre <code>nil</code>.</p>
<p>Esto puede no ser evidente a primera vista. Eso casi se ve como si la expresión de incremento es la última expresión de la función completa. Pero esta expresión es parte del cuerpo del <code>while</code>; eso es el último elemento de la lista que empieza con el símbolo <code>while</code>. Más allá, el bucle <code>while</code> completo es una lista con el cuerpo del <code>let</code>.</p>
<p>En línea (<em>outline</em>), la función se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">@V{name-of-function}</span> <span class="p">(</span><span class="nv">@V{argument-list}</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">@V{varlist}</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nv">@V{true-or-false-test}</span><span class="p">)</span>
      <span class="nv">@V{body-of-while}</span><span class="err">…</span> <span class="p">)</span>
    <span class="err">…</span> <span class="p">))</span>                    <span class="c1">; Necesita la expresión final aquí.</span>
</code></pre>
<p>El resultado de evaluar el <code>let</code> es que lo que está yendo para devolver el <code>defun</code> desde el <code>let</code> que no está embebido con cualquier lista que contiene, excepto para la <code>defun</code> como un todo. Sin embargo, si el <code>while</code> es el último elemento de la expresión <code>let</code>, la función siempre devolverá <code>nil</code>. ¡Esto no es lo que quiero! En vez de eso, lo que queremos es el valor de la variable <code>total</code>. Eso devuelve simplemente emplazando el símbolo como el último elemento de la lista empezando con <code>let</code>. Eso se evalúa después de los elementos precedentes de la lista evaluada, que significa que eso se evaluó después de haber sido asignado el valor correcto para el total.</p>
<p>Eso puede ser fácil de ver imprimiendo la lista empezando con <code>let</code> todo en una línea. Este formato hace evidente que las expresiones varlist y <code>while</code> son el segundo el tercer elementos de la lista empezando con <code>let</code>, y el <code>total</code> es el último elemento:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">@V{varlist}</span><span class="p">)</span> <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nv">@V{true-or-false-test}</span><span class="p">)</span>
<span class="nv">@V{body-of-while}</span><span class="err">…</span> <span class="p">)</span> <span class="nv">total</span><span class="p">)</span>
</code></pre>
<p>Poniendo cualquier cosa junta, la definición de función <code>triangle</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle</span> <span class="p">(</span><span class="nv">number-of-rows</span><span class="p">)</span>    <span class="c1">; Versión con</span>
                                    <span class="c1">;  contador de incremento.</span>
  <span class="s">&#34;Añade el número de asteriscos en un triángulo.
</span><span class="s">La primera fila tiene un asterisco, la segunda fila dos asteriscos,
</span><span class="s">la tercera fila tres asteriscos, y así.
</span><span class="s">El argumento es NUMBER-OF-ROWS.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">row-number</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;=</span> <span class="nv">row-number</span> <span class="nv">number-of-rows</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">row-number</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">row-number</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">row-number</span><span class="p">)))</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>Después de haber instalado <code>triangle</code> para evaluar la función, se puede probar. Aquí hay dos ejemplos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle</span> <span class="mi">4</span><span class="p">)</span>

<span class="p">(</span><span class="nv">triangle</span> <span class="mi">7</span><span class="p">)</span>
</code></pre>
<p>La suma del primero de cuatro números es 10 y la suma de los primeros siete números es 28.</p>
</div>
<h4 id="bucle-que-se-decrementa" >Bucle que se decrementa</h4>
<div class="hBody-4" >
<p>Otro camino común para escribir un bucle <code>while</code> es escribir el test así que determina si un contador es mayor que cero. Así tan largo es el contador mayor que cero, el bucle se repite. Pero cuando el contador es igual o menor que cero, el bucle se para. Para este trabajo, el contador tiene que empezar mayor que cero y entonces se hace más pequeño y pequeño por una forma que es evaluada repetidamente.</p>
<p>El test será una expresión tal como <code>(&gt; counter 0)</code> que devuelve <code>t</code> <em>cierto</em> si el valor de <code>counter</code> es mayor que cero, y <code>nil</code> <em>falso</em> si el valor de <code>counter</code> es igual a o menor que cero. La expresión hace que el número menor y menor puede ser un simple <code>setq</code> tal como <code>(setq counter (1- counter)</code>, donde <code>1-</code> es una función construida en Emacs Lisp que sustrae 1 de su argumento.</p>
<p>La plantilla para decrementar el bucle <code>while</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">counter</span> <span class="mi">0</span><span class="p">)</span>                    <span class="c1">; test-verdadero-o-falso</span>
  <span class="nv">@V{body}</span><span class="err">…</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">counter</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">counter</span><span class="p">)))</span>          <span class="c1">; decremento</span>
</code></pre>
</div>
<h5 id="ejemplo-con-el-contador-que-se-decrementa" >Ejemplo con el contador que se decrementa</h5>
<div class="hBody-5" >
<p>Para ilustrar un bucle con un contador de decremento, reescribirá la función <code>triangle</code> así como el contador se decrementa a cero.</p>
<p>Esto es lo inverso de la versión temprana de la función. En este caso, para encontrar cuántos asteriscos son necesarios para crear un triángulo con 3 filas, añade el número de asteriscos en la tercera fila, 3, para el número en la fila precedente, 2, y entonces añade el total de estas dos filas a la fila que lo precede, 1.</p>
<p>Más allá, para encontrar el número de asteriscos en un triángulo con 7 filas, añade el número de asteriscos en la fila siete, 7, al número en la fila precedente, que es 6, y entonces añade el total de estas dos filas a la fila esta que lo precede, que es 5, y así. Como en el ejemplo previo, cada adición solo involucra la adición de dos números, el total de las filas ya se añadió y el número de asteriscos en la fila que está siendo añadida al total. Este proceso de añadir dos números se repite de nuevo y de nuevo hasta que no haya más asteriscos que añadir.</p>
<p>Sabemos con cuántos asteriscos empezar: el número de asteriscos en la última fila es igual al número de filas. Si el triángulo tiene siete filas, el número de asteriscos en la última fila es 7. Más allá, sabemos cuántos asteriscos están en la fila precedente: eso es uno menos que el número en la fila.</p>
</div>
<h5 id="las-partes-de-la-definición-de-función" >Las partes de la definición de función</h5>
<div class="hBody-5" >
<p>Empezamos con tres variables: el número total de filas en el triángulo; el número de asteriscos en una fila; y el número total de asteriscos, que es lo que queremos calcular. Estas variables pueden llamarse <code>number-of-rows</code>, <code>number-of-pebbles-in-row</code>, y <code>total</code>, respectivamente.</p>
<p>Ambos <code>total</code> y <code>number-of-pebbles-in-row</code> se usan solo dentro de la función y se declaran con <code>let</code>. El valor inicial de <code>total</code> sería cero. Sin embargo, el valor inicial de <code>number-of-pebbles-in-row</code> sería igual al número de filas en el triángulo, desde la adición empezará con la fila más larga.</p>
<p>Esto significa que el principio de la expresión <code>let</code> se verá así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">number-of-pebbles-in-row</span> <span class="nv">number-of-rows</span><span class="p">))</span>
  <span class="nv">@V{body}</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>El número total de asteriscos puede encontrarse repetidamente añadiendo el número de asteriscos en una fila para el total ya encontrado, que, se evalúa repetidamente en la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number-of-pebbles-in-row</span><span class="p">))</span>
</code></pre>
<p>Después el <code>number-of-pebbles-in-row</code> se añade al <code>total</code>, el <code>number-of-pebbles-in-row</code> sería decrementado por uno, desde que la siguiente vez el bucle repite, la fila precedente será añadida al total.</p>
<p>El número de asteriscos en una fila precedente es uno menos que el número de asteriscos en una fila, así la función Emacs Lisp construida <code>1-</code> puede usarse para computar el número de asteriscos de la fila precedente. Esto puede ser hecho con la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-pebbles-in-row</span>
      <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-pebbles-in-row</span><span class="p">))</span>
</code></pre>
<p>Finalmente, sabemos que el bucle <code>while</code> pararía creando repetidas adiciones cuando no hay asteriscos en una fila. Así el test para el bucle <code>while</code> es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-pebbles-in-row</span> <span class="mi">0</span><span class="p">)</span>
</code></pre>
</div>
<h5 id="poniendo-la-definición-de-la-función-junta" >Poniendo la definición de la función junta</h5>
<div class="hBody-5" >
<p>Se pueden poner estas expresiones juntas para crear una definición de función que funcione. Sin embargo, al examinarlas, encontraremos que una de la variables locales ¡es innecesaria!</p>
<p>La definición de función se ve como esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Primero la versión substractiva.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle</span> <span class="p">(</span><span class="nv">number-of-rows</span><span class="p">)</span>
  <span class="s">&#34;Añade el número de asteriscos en un triángulo.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">number-of-pebbles-in-row</span> <span class="nv">number-of-rows</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-pebbles-in-row</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number-of-pebbles-in-row</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-pebbles-in-row</span>
            <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-pebbles-in-row</span><span class="p">)))</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>Como se dijo, esta función funciona.</p>
<p>Sin embargo, no se necesita <code>number-of-pebbles-in-row</code>.</p>
<p>Cuando la función <code>triangle</code> se evalúa, el símbolo <code>number-of-rows</code> será asociado al número, dando un valor inicial. Este número puede ser cambiado en el cuerpo de la función si hubiera una variable local, sin miedo de que tal cambio se efectuará el valor de la variable fuera de la función. Esto es una característica muy útil de Lisp; eso significa que la variable <code>number-of-rows</code> puede ser usada en cualquier lugar en la función donde <code>number-of-pebbles-in-row</code> se usa.</p>
<p>Aquí hay una segunda versión de la función escrita un poco más limpiamente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>                <span class="c1">; Segunda versión.</span>
  <span class="s">&#34;Devuelve la suma de números 1 a través de NUMBER inclusive.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number</span><span class="p">)))</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>En breve, un bucle <code>while</code> apropiadamente escrito consistirá de tres partes:</p>
<ol class="num" >
<li>
<p>Un test que devuelva falso después de que el bucle ha repetido por sí mismo el número de veces correcto.</p>
</li>
<li>
<p>Una expresión de la evaluación de que devolverá el valor deseado después de ser repetidamente evaluado.</p>
</li>
<li>
<p>Una expresión para cambiar el valor pasado al true-or-false-test así el test devuelve falso después de que el bucle se ha repetido por sí mismo el número de veces correcto.</p>
</li>
</ol>
</div>
<h3 id="ahorra-tiempo:-dolist-y-dotimes" >Ahorra tiempo: <code>dolist</code> y <code>dotimes</code></h3>
<div class="hBody-3" >
<p>Además de <code>while</code>, tanto <code>dolist</code> como <code>dotimes</code> proveen un bucle. Algunas veces estos son rápidos para escribir el bucle equivalente <code>while</code>. Ambos son macros Lisp. (Vea la Seccion <q>Macros</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p><code>dolist</code> funciona como un bucle <code>while</code> con ‘<code>cdr</code>s que bajan la lista’: <code>dolist</code> automáticamente ordena la lista cada vez que la lista hace bucles––toma la <code>cdr</code> de la lista––y asocia el <code>car</code> de cada versión ordenada de la lista al primero de sus argumentos.</p>
<p><code>dotimes</code> repite el bucle un número específico de veces: tu especificas el número.</p>
</div>
<h4 id="la-macro-dolist" >La macro <code>dolist</code></h4>
<div class="hBody-4" >
<p>Supón, por ejemplo, que quieres invertir una lista, así que “primero”, “segundo”, “tercero” llega a ser “tercero”, “segundo”, “primero”.</p>
<p>En la práctica, usarías la función <code>reverse</code>, como esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nf">reverse</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>Aquí se ve cómo se podría invertir la lista usando un bucle <code>while</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">reverse-list-with-while</span> <span class="p">(</span><span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Usando while, invierte el orden de LIST.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">value</span><span class="p">)</span>  <span class="c1">; asegura que la lista comienza vacía</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nf">list</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">value</span> <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">list</span><span class="p">)</span> <span class="nv">value</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nf">list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">list</span><span class="p">)))</span>
    <span class="nv">value</span><span class="p">))</span>

<span class="p">(</span><span class="nv">reverse-list-with-while</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>Y aquí se ve cómo podría usarse la macro <code>dolist</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">reverse-list-with-dolist</span> <span class="p">(</span><span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Usando dolist, reverse, la orden de la LISTA.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">value</span><span class="p">)</span>  <span class="c1">; asegura que la lista empieza vacía</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">element</span> <span class="nf">list</span> <span class="nv">value</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">value</span> <span class="p">(</span><span class="nf">cons</span> <span class="nv">element</span> <span class="nv">value</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">reverse-list-with-dolist</span> <span class="nv">animals</span><span class="p">)</span>
</code></pre>
<p>En Info, se puede localizar su cursor después de cerrar paréntesis de cada expresión y escribir <kbd>C-x C-e</kbd>; en cada caso, se vería</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">tigre</span> <span class="nv">leon</span> <span class="nv">jirafa</span> <span class="nv">gacela</span><span class="p">)</span>
</code></pre>
<p>en el área de eco.</p>
<p>Para este ejemplo, la función <code>reverse</code> existente es obviamente la mejor. El bucle <code>while</code> es solo como nuestro primer ejemplo (vease Seccion <a href="Un-bucle-while-y-una-lista" >Un bucle <code>while</code> y una lista</a>). El <code>while</code> primero chequea si la lista tiene elementos; si es así, eso construye una nueva lista añadiendo el primer elemento de la lista a la lista existente (que en la primera iteración del bucle es <code>nil</code>). Puesto que el segundo elemento está asignado en frente del segundo elemento, la lista es inversa.</p>
<p>En la expresión que usa el bucle <code>while</code>, la expresión <code>(setq list (cdr list))</code> ordena la lista, así el bucle <code>while</code> finalmente para. Además, se proporciona la expresión <code>cons</code> con un nuevo primer elemento creando una nueva lista y se ordena en cada repetición del bucle.</p>
<p>La expresión <code>dolist</code> hace lo mismo que la expresión <code>while</code>, excepto que la macro <code>dolist</code> hace algo del trabajo que se tiene que hacer cuando se escribe una expresión <code>while</code>.</p>
<p>Al igual que el bucle <code>while</code>, tenemos el bucle <code>dolist</code>. Lo que es diferente es que automáticamente ordena la lista cada vez que se repite––eso es ‘recorrer los <code>cdr</code>s de la lista’ en sí––y eso automáticamente asocia el <code>car</code> de cada versión ordenada de la lista al primero de sus argumentos.</p>
<p>En el ejemplo, el <code>car</code> de cada versión ordenada de la lista se refiere a usar el símbolo <samp>element</samp>, la lista en sí se llama <samp>list</samp>, y el valor devuelto se llama <samp>value</samp>. El resto de la expresión <code>dolist</code> es el cuerpo.</p>
<p>La expresión <code>dolist</code> asocia el <code>car</code> de cada versión ordenada de la lista al <code>element</code> y entonces evalúa el cuerpo de la expresión y repite el bucle. El resultado es devuelto en <code>value</code>.</p>
</div>
<h4 id="la-macro-dotimes" >La macro <code>dotimes</code></h4>
<div class="hBody-4" >
<p>La macro <code>dotimes</code> es similar a <code>dolist</code>, excepto que el bucle se repite un número específico de veces.</p>
<p>El primer argumento <code>dotimes</code> se asigna a los números 0, 1, 2 y así vuelve al bucle, y el valor del tercer argumento se devuelve. Se necesita proveer el valor del segundo argumento, que es cuántas veces la macro hace el bucle.</p>
<p>Por ejemplo, lo siguiente asocia los números de 0 en adelante, pero no incluyendo, el número 3 al primer argumento, número, y entonces construye una lista de los tres números. (El primer número es 0, el segundo número es 1, y el tercer número es 2; esto crea un total de tres números en todo, empezando con cero como el primer número.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">value</span><span class="p">)</span>      <span class="c1">; de otro modo un valor es una variable vacía</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">number</span> <span class="mi">3</span> <span class="nv">value</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">value</span> <span class="p">(</span><span class="nf">cons</span> <span class="nv">number</span> <span class="nv">value</span><span class="p">))))</span>

<span class="err">⇒</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
</code></pre>
<p><code>dotimes</code> devuelve <code>value</code>, así el camino para usar <code>dotimes</code> es para operar en alguna expresión el número de veces number y entonces devolver el resultado, como una lista o un átomo.</p>
<p>Aquí hay un ejemplo de una <code>defun</code> que usa <code>dotimes</code> para añadir el número de asteriscos en un triángulo.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-using-dotimes</span> <span class="p">(</span><span class="nv">number-of-rows</span><span class="p">)</span>
  <span class="s">&#34;Usando dotimes, añade el número de asteriscos en un triángulo.&#34;</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1">; de otro modo un total es una variable vacía</span>
  <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">number</span> <span class="nv">number-of-rows</span> <span class="nv">total</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">number</span><span class="p">))))))</span>

<span class="p">(</span><span class="nv">triangle-using-dotimes</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="recursión" >Recursión</h3>
<div class="hBody-3" >
<p>Una función recursiva contiene código que hace que el intérprete Lisp llame a un programa que ejecute el código en sí, pero con argumentos ligeramente diferentes. El código ejecuta exactamente lo mismo porque eso tiene el mismo nombre. Sin embargo, incluso aunque el programa tenga el mismo nombre, no es la misma entidad. Eso es diferente. En la jerga, se dice es una ‘instancia’ diferente.</p>
<p>Finalmente, si el programa se escribe correctamente, los ‘argumentos ligeramente diferentes’ llegan a ser suficientemente diferentes puesto que los primeros argumentos de la instancia final se pararán.</p>
</div>
<h4 id="construyendo-robots:-extendiendo-la-metáfora" >Construyendo robots: Extendiendo la metáfora</h4>
<div class="hBody-4" >
<p>Algunas veces es útil pensar en un programa en ejecución como un robot que hace un trabajo. Haciendo su trabajo, una función recursiva llama a un segundo robot para que le ayude. El segundo robot es idéntico al primero en cada paso, excepto que el segundo robot ayuda al primero y se han pasado diferentes argumentos en vez del primero.</p>
<p>En una función recursiva, el segundo robot puede llamar a un tercero; y el tercero puede llamar a un cuarto, y así. Cada una de estos es una entidad diferente; pero todos son clones.</p>
<p>Desde que cada robot tiene instrucciones ligeramente diferentes --- los argumentos diferirán desde un robot al siguiente––el último robot conocería cuando pare.</p>
<p>Permite expandir la metáfora en el que un programa de ordenador es un robot.</p>
<p>Una definición de función provee impresiones para un robot. Cuando se instala una definición de función, que es, cuando se evalúa una forma especial <code>defun</code>, se instala el equipamiento para construir robots. Eso es como si tu estuvieras en una fábrica, configurando una línea de ensamblaje. Los robots con el mismo nombre son construidos de acuerdo a las mismas impresiones. Así ellos tienen, como estaban, el mismo ‘número de modelo’, pero un diferente ‘número de serie’.</p>
<p>Nosotros con frecuencia decimos que una función recursiva ‘se llama así misma’. Esto significa que las instrucciones en una función recursiva causa que el intérprete de Lisp ejecute una función diferente que tiene el mismo nombre y hace el mismo trabajo que el primero, pero con diferentes argumentos.</p>
<p>Es importante que los argumentos difieran desde una instancia a la siguiente; de otro modo, el proceso nunca parará.</p>
</div>
<h4 id="las-partes-de-una-definición-recursiva" >Las partes de una definición recursiva</h4>
<div class="hBody-4" >
<p>Una función recursiva típicamente contiene una expresión condicional que tiene tres partes:</p>
<ol class="num" >
<li>
<p>Un true-or-false-test que determina si la función se llama de nuevo, aquí se llama el <dfn>do-again-test</dfn>.</p>
</li>
<li>
<p>El nombre de la función. Cuando este nombre se llama, es una nueva instancia de la función––un nuevo robot, así––se crea y se dice qué hacer.</p>
</li>
<li>
<p>Una expresión que devuelve un valor diferente cada vez que la función se llama, aquí llamada la <dfn>next-step-expression</dfn>. Consecuentemente, el argumento (o argumentos) pasados a la nueva instancia de la función serán diferentes puesto que se pasa a la instancia previa. Esto causa la expresión condicional, que el <dfn>do-again-test</dfn>, devuelva falso después del número correcto de repeticiones.</p>
</li>
</ol>
<p>Las funciones recursivas pueden ser más simples que cualquier otro tipo de funciones. De manera profunda, cuando la gente empieza a usarlas, con frecuencia se miran así misteriosamente de manera tan simple como incompresible. Como montar en bicicleta, leer una función recursiva es duro al principio, pero después es simple.</p>
<p>Hay varios patrones recursivos diferentes. Un patrón muy simple se parece a:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">@V{name-of-recursive-function}</span> <span class="p">(</span><span class="nv">@V{argument-list}</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">@V{do-again-test}</span>
    <span class="nv">@V{body}</span><span class="err">…</span>
    <span class="p">(</span><span class="nv">@V{name-of-recursive-function}</span>
         <span class="nv">@V{next-step-expression}</span><span class="p">)))</span>
</code></pre>
<p>Cada vez que una función recursiva es evaluada, una nueva instancia se crea y se dice qué hacer. Los argumentos le dicen a la instancia qué hacer.</p>
<p>Un argumento se empareja al valor de la next-step-expresion. Cada instancia se ejecuta con un valor diferente de la next-step-expression.</p>
<p>El valor en la next-step-expression es usado en la do-again-test.</p>
<p>El valor devuelto por la next-step-expression es pasada a las nuevas instancias de la función, que lo evalúa (o alguna transformación de eso) para determinar si continuar o parar. El next-step-expression está diseñado así que el do-again-test devuelve falso cuando la función no se repetiría mucho.</p>
<p>El do-again-test es algunas veces llamado la <dfn>condición de parar</dfn>, puesto que sirve para parar las repeticiones cuando se devuelve falso.</p>
</div>
<h4 id="recursión-con-una-lista" >Recursión con una lista</h4>
<div class="hBody-4" >
<p>El ejemplo de un bucle <code>while</code> que imprimió los elementos de una lista de números puede ser escrito recursivamente. Aquí está el código, incluyendo una expresión para asignar el valor de la variable <code>animales</code> a una lista.</p>
<p>Si está leyendo esto en el Info de Emacs, se puede evaluar esta expresión directamente en Info. De otro modo, se debe copiar el ejemplo al búfer <span class="file" >*scratch*</span> y evalúa cada expresión aquí. Usa <kbd>C-u C-x C-e</kbd> para evaluar la expresión <code>(print-elements-recursively animals)</code> así que los resultado se imprimen en el búfer; de otro modo el intérprete Lisp intentará presionar los resultados dentro de una línea del área de eco.</p>
<p>También, posiciona tu cursor inmediatamente después del último paréntesis que cierra la función <code>print-elements-recursively</code>, antes del comentario. De otro modo, el intérprete Lisp intentará evaluar el comentario.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-elements-recursively</span> <span class="p">(</span><span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Imprime cada elemento de la LISTA de la línea en
</span><span class="s">  sí. Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nf">list</span>                            <span class="c1">; do-again-test</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">list</span><span class="p">))</span>              <span class="c1">; body</span>
        <span class="p">(</span><span class="nv">print-elements-recursively</span>     <span class="c1">; recursive call</span>
         <span class="p">(</span><span class="nf">cdr</span> <span class="nf">list</span><span class="p">))))</span>                  <span class="c1">; next-step-expression</span>

<span class="p">(</span><span class="nv">print-elements-recursively</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>La función <code>print-elements-recursively</code> primero chequea si hay cualquier contenido en la lista; si lo hay, la función imprime el primer elemento de la lista, el <code>car</code> de la lista. Entonces la función se ‘invoca en sí’, pero da a sí mismo como su argumento, no la lista completa, pero el segundo y subsiguientes elementos de la lista, el <code>cdr</code> de la lista.</p>
<p>Pon otro camino, si la lista no está vacía, la función invoca otra instancia de código que es similar al código inicial, pero es un hilo diferente de ejecución, con diferentes argumentos a la primera instancia.</p>
<p>Veamos una manera más, si la lista no está vacía, el primer robot ensambla un segundo robot que cuenta qué hacer; el segundo robot es un individuo diferente desde el principio, pero es el mismo modelo.</p>
<p>Cuando la segunda evaluación ocurre, la expresión <code>when</code> se evalúa y si es verdad, se imprime el primer elemento de la lista que recibe como su argumento (que es el segundo elemento de la lista original). Entonces la función ‘llamarse a sí mismo’ con la <code>cdr</code> del <code>cdr</code> de la lista original.</p>
<p>Note que aunque nosotros decimos que la función ‘se llama a sí misma’, lo que significa es que el intérprete Lisp ensambla e instruye una nueva instancia del programa. La nueva instancia es un clon del primero, pero es un individuo separado.</p>
<p>Cada vez que la función ‘se invoca a sí misma’, se invoca a sí misma en una versión de la lista original. Eso crea una nueva instancia que funciona como una lista ordenada.</p>
<p>Finalmente, la función se invoca a sí misma en una lista vacía. Eso crea una nueva instancia cuyo argumento es <code>nil</code>. La expresión condicional chequea el valor de <code>lista</code>. Desde el valor de <code>lista</code> a <code>nil</code>, la expresión <code>when</code> devuelve falso así la then-part no está evaluada. La función es como un todo que entonces devuelve <code>nil</code>.</p>
<p>Cuando se evalúa la expresión <code>(print-elements-recursively animals)</code> en el búfer <span class="file" >*scratch*</span>, se verá este resultado:</p>
<div class="example-block" >
<pre class="example" >gacela

jirafa

leon

tigre
nil
</pre>
</div>
</div>
<h4 id="recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</h4>
<div class="hBody-4" >
<p>La función <code>triangle</code> describe en una sección previa si puede ser escrita recursivamente. Se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-recursively</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Return the sum of the numbers 1 through NUMBER inclusive.
</span><span class="s">Uses recursion.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">number</span> <span class="mi">1</span><span class="p">)</span>                    <span class="c1">; do-again-test</span>
      <span class="mi">1</span>                               <span class="c1">; then-part</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span>                         <span class="c1">; else-part</span>
       <span class="p">(</span><span class="nv">triangle-recursively</span>          <span class="c1">; recursive call</span>
        <span class="p">(</span><span class="nf">1-</span> <span class="nv">number</span><span class="p">)))))</span>               <span class="c1">; next-step-expression</span>

<span class="p">(</span><span class="nv">triangle-recursively</span> <span class="mi">7</span><span class="p">)</span>
</code></pre>
<p>Se puede instalar esta función evaluando y entonces se intenta evaluar <code>(triangle-recursively 7)</code>. (Recuerda poner tu cursor inmediatamente después de los últimos paréntesis de la definición de la función, antes del comentario.) La función se evalúa a 28.</p>
<p>Para comprender cómo funciona la función, hay que considerar qué ocurre en varios casos cuando la función se le pasa 1, 2, 3, o 4 como el valor a su argumento.</p>
<p>Primero, veamos qué ocurre si el valor del argumento es 1.</p>
<p>La función tiene una expresión <code>if</code> después de la cadena de documentación. Esto chequea si el valor de <code>number</code> es igual a 1; si es así, Emacs evalúa la then-part de la expresión <code>if</code>, que devuelve el número 1 como el valor de la función. (Un triángulo con una fila tiene un asterisco dentro.)</p>
<p>Supón, sin embargo, que el valor del argumento es 2. En este caso, Emacs evalúa la parte else de la expresión <code>if</code>.</p>
<p>La parte else consiste de una adición, la llamada recursiva para <code>triangle-recursively</code> y una acción de decremento; y se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">triangle-recursively</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number</span><span class="p">)))</span>
</code></pre>
<p>Cuando Emacs evalúa esta expresión, la expresión interna es evaluada primero; entonces las otras partes en secuencia. Aquí están los pasos en detalle:</p>
<dl>
<dt>Paso 1 Evalúa la expresión interna.</dt>
<dd>
<p>La expresión interna es <code>(1- number)</code> así Emacs decrementa el valor de <code>number</code> desde 2 a 1.</p>
</dd>
</dl>
<ul>
<li>
<p>Paso 2 Evalúa la función <code>triangle-recursively</code>.</p>
<p>El intérprete Lisp crea una instancia individual de <code>triangle-recursively</code>. Eso no importa que esta función está contenida con sí misma. Emacs pasa el resultado Paso 1 como el argumento usado por esta instancia de la función <code>triangle-recursively</code></p>
<p>En este caso, Emacs evalúa <code>triangle-recursively</code> con un argumento de 1. Esto significa que esta evaluación de <code>triangle-recursively</code> devuelve 1.</p>
</li>
</ul>
<dl>
<dt>Paso 3 Evalúa el valor de <code>number</code>.</dt>
<dd>
<p>La variable <code>number</code> es el segundo elemento de la lista que empieza con <code>+</code>; su valor es 2.</p>
</dd>
<dt>Paso 4 Evalúa la expresión <code>+</code>.</dt>
<dd>
<p>La expresión <code>+</code> recibe dos argumentos, el primero desde la evaluación de <code>number</code> (Paso 3) y el segundo desde la evaluación de <code>triangle-recursively</code> (Paso 2).</p>
<p>El resultado de la adición es la suma de 2 + 1, y el número 3 es devuelto, que es correcto. Un triángulo con dos filas tiene tres asteriscos ahí.</p>
</dd>
</dl>
</div>
<h5 id="un-argumento-de-3-o-4" >Un argumento de 3 o 4</h5>
<div class="hBody-5" >
<p>Supón que <code>triangle-recursively</code> es llamado con un argumento de 3.</p>
<dl>
<dt>Paso 1 Evalúa la do-again-test.</dt>
<dd>
<p>La expresión <code>if</code> se evalúa primero. Esto es el test do-again y devuelve falso, así la parte else de la expresión <code>if</code> es evaluada. (Note que en este ejemplo, el do-again-test causa la función para llamarse a sí misma cuando eso se chequea como falso, no cuando eso se chequea como verdadero.)</p>
</dd>
<dt>Paso 2 Evalúa la expresión propia de la parte else.</dt>
<dd>
<p>La expresión propia de la parte que es evaluada, decrementa 3 a 2. Esta la next-step-expression.</p>
</dd>
<dt>Paso 3 Evalúa la función <code>triangle-recursively</code>.</dt>
<dd>
<p>El número 2 es pasado a la función <code>triangle-recursively</code>.</p>
<p>Nosotros ya sabemos qué ocurre cuando Emacs evalúa <code>triangle-recursively</code> con un argumento de 2. Después de ir a través de la secuencia de acciones descritas temprano, eso devuelve un valor de 3. Así que es lo que ocurrirá aquí.</p>
</dd>
<dt>Paso 4 Evalúa la adición.</dt>
<dd>
<p>3 será pasado como un argumento para la adición y será añadido al número con el que la función se llamó, que es 3.</p>
</dd>
</dl>
<p>El valor devuelto por la función como un todo será 6.</p>
<p>Ahora que sabemos qué ocurrirá cuando <code>triangle-recursively</code> llama con un argumento 3, es evidente lo que ocurrirá si se llama con el argumento 4:</p>
<div class="tab" >
<p>En la llamada recursiva, la evaluación de</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-recursively</span> <span class="p">(</span><span class="nf">1-</span> <span class="mi">4</span><span class="p">))</span>
</code></pre>
<p>devuelve el valor de evaluar</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-recursively</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>que es 6 este valor será añadido a 4 por la adición en la tercera línea.</p>
</div>
<p>El valor devuelto por la función como un todo será 10.</p>
<p>Cada vez que <code>triangle-recursively</code> se evalúa, se interpreta una versión de sí misma––una instancia diferente en sí––con un pequeño argumento, hasta que el argumento es suficientemente pequeño así que no se evalúa en sí.</p>
<p>Note que este particular diseño para una función recursiva requiere que las operaciones sean diferidas.</p>
<p>Antes de que <code>(triangle-recursively 7)</code> pueda calcular su respuesta, debe llamarse a <code>(triangle-recursively 6)</code>; y antes a <code>(triangle-recursively 5)</code>; y así. Esto es decir, que el cálculo de <code>(triangle-recursively 7)</code> a crear debe ser diferido hasta que <code>(triangle-recursively 6)</code> haga su cálculo; y <code>(triangle-recursively 5)</code> lo complete; y así.</p>
<p>Si cada una de estas instancias de <code>triangle-recursively</code> son pensadas como diferentes robots, el primer robot debe esperar por el segundo para completar su trabajo, que debe esperar hasta los terceros completos, y así.</p>
<p>Hay un camino alrededor de este tipo de espera, que se discutirá en <a href="Recursión-sin-diferir" >Recursión sin diferir</a>.</p>
</div>
<h4 id="ejemplo-de-recursión-usando-cond" >Ejemplo de recursión usando <code>cond</code></h4>
<div class="hBody-4" >
<p>La versión de <code>triangle-recursively</code> antes descrita se escribió con la forma especial <code>if</code>. Eso puede también ser escrita usando otra forma especial llamada <code>cond</code>. El nombre de la forma especial <code>cond</code> es una abreviación de la palabra <samp>conditional</samp>.</p>
<p>Aunque la forma especial <code>cond</code> no se usa con frecuencia en las fuentes de Emacs como <code>if</code>, se usa con suficiente frecuencia para justificarse explicando.</p>
<p>La plantilla para una expresión <code>cond</code> se parece a:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">cond</span>
 <span class="nv">@V{body}</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>donde el body es una serie de listas.</p>
<p>Escrito de manera más completa, la plantilla se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">cond</span>
 <span class="p">(</span><span class="nv">@V{first-true-or-false-test}</span> <span class="nv">@V{first-consequent}</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">@V{second-true-or-false-test}</span> <span class="nv">@V{second-consequent}</span><span class="p">)</span>
 <span class="p">(</span><span class="nv">@V{third-true-or-false-test}</span> <span class="nv">@V{third-consequent}</span><span class="p">)</span>
  <span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Cuando el intérprete Lisp evalúa la expresión <code>cond</code>, evalúa el primer elemento (el <code>car</code> o true-or-false-test) de la primera expresión en una serie de expresiones con el cuerpo del <code>cond</code>.</p>
<p>Si el true-or-false-test devuelve <code>nil</code> el resto de esta expresión, el consecuente, se descarta y el true-or-false-test de la siguiente expresión se evalúa. Cuando una expresión encuentra un true-or-false-test cuyo valor no es <code>nil</code>, el consecuente de esta expresión se evalúa. El consecuente puede ser una o más expresiones. Si el consecuente consiste de más de una expresión, las expresiones son evaluadas en secuencia y el valor del último se devuelve. Si la expresión no tiene un consecuente, se devuelve el valor del true-or-false-test.</p>
<p>Si ninguno del test true-or-false-tests es cierto, la expresión <code>cond</code> devuelve <code>nil</code>.</p>
<p>Escrito usando <code>cond</code>, la función <code>triangle</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-using-cond</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nf">&lt;=</span> <span class="nv">number</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">=</span> <span class="nv">number</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nf">&gt;</span> <span class="nv">number</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">triangle-using-cond</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number</span><span class="p">))))))</span>
</code></pre>
<p>En este ejemplo, el <code>cond</code> devuelve 0 si el número es menor o igual a 0, eso devuelve 1 si el número es 1 y eso evalúa <code>(+ number (triangle-using-cond (1- number)))</code> si el número es más grandes que 1.</p>
</div>
<h4 id="patrones-recursivos" >Patrones recursivos</h4>
<div class="hBody-4" >
<p>Aquí hay tres patrones recursivos. Cada uno involucra una lista. La recursión no se necesita para involucrar listas, pero Lisp se diseña para listas y esto provee un sentido de sus capacidades primarias.</p>
</div>
<h5 id="patrón-recursivo:-every" >Patrón recursivo: <em>every</em></h5>
<div class="hBody-5" >
<p>En el patrón recursivo <code>every</code>, se desarrolla una acción por cada elemento de una lista.</p>
<p>El patrón básico es:</p>
<ul>
<li>
<p>Si una lista es vacía, devuelve <code>nil</code>.</p>
</li>
<li>
<p>Si no, se va al principio de la lista (el <code>car</code> de la lista) actuando</p>
<ul>
<li>
<p>a través de una llamada recursiva por la función en el resto (el <code>cdr</code>) de la lista,</p>
</li>
<li>
<p>y, opcionalmente, se combina el elemento sobre el que actúa, usando <code>cons</code>, con los resultados de actuar en el resto.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí está el ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">square-each</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;El cuadrado de cada LISTA DE NUMEROS, recursivamente.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">numbers-list</span><span class="p">)</span>                <span class="c1">; test-hazlo-de-nuevo</span>
      <span class="no">nil</span>
    <span class="p">(</span><span class="nf">cons</span>
     <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">numbers-list</span><span class="p">)</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">numbers-list</span><span class="p">))</span>
     <span class="p">(</span><span class="nv">square-each</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">numbers-list</span><span class="p">)))))</span> <span class="c1">; expresion-siguiente-paso</span>

<span class="p">(</span><span class="nv">square-each</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
    <span class="err">⇒</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span> <span class="mi">9</span><span class="p">)</span>
</code></pre>
<p>Si <code>numbers-list</code> está vacío, no hay que hacer nada. Pero si tiene contenido, se construye una lista combinando el cuadrado del primer número en la lista con el resultado de la llamada recursiva.</p>
<p>(El ejemplo sigue el patrón exactamente: se devuelve <code>nil</code> si la lista de números es vacía. En la práctica, se escribiría el condicional, así se ejecuta la acción cuando la lista de números no es vacía.)</p>
<p>La función <code>print-elements-recursively</code> (Vease Sección <a href="Recursión-con-una-Lista" >Recursión con una Lista</a>) es otro ejemplo de un patrón <code>every</code>, excepto en este caso, en vez de traer los resultados juntos usando <code>cons</code>, se imprime cada elemento de salida.</p>
<p>La función <code>print-elements-recursively</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">animales</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">gacela</span> <span class="nv">jirafa</span> <span class="nv">leon</span> <span class="nv">tigre</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-elements-recursively</span> <span class="p">(</span><span class="nf">list</span><span class="p">)</span>
  <span class="s">&#34;Imprime cada elemento de la LISTA de la línea en
</span><span class="s">  sí. Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">when</span> <span class="nf">list</span>                            <span class="c1">; do-again-test</span>
        <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">car</span> <span class="nf">list</span><span class="p">))</span>              <span class="c1">; body</span>
        <span class="p">(</span><span class="nv">print-elements-recursively</span>     <span class="c1">; recursive call</span>
         <span class="p">(</span><span class="nf">cdr</span> <span class="nf">list</span><span class="p">))))</span>                  <span class="c1">; next-step-expression</span>

<span class="p">(</span><span class="nv">print-elements-recursively</span> <span class="nv">animales</span><span class="p">)</span>
</code></pre>
<p>El patrón para <code>print-elements-recursively</code> es:</p>
<ul>
<li>
<p>Cuando la lista está vacía, no hacer nada.</p>
</li>
<li>
<p>Pero cuando la lista tiene al menos un elemento,</p>
<ul>
<li>
<p>actúa al principio de la lista (el <code>car</code> de la lista),</p>
</li>
<li>
<p>y crea una llamada recursiva en el resto (el <code>cdr</code> de la lista).</p>
</li>
</ul>
</li>
</ul>
</div>
<h5 id="patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></h5>
<div class="hBody-5" >
<p>Otro patrón recursivo es llamado el patrón <code>accumulate</code>. En el patrón recursivo <code>accumulate</code>, se realiza una acción en cada elemento de una lista y el resultado de esta acción se acumula con los resultados de desarrollar la acción en otros elementos.</p>
<p>Esto es como ‘cada’ patrón usando <code>cons</code>, excepto que este <code>cons</code> no se esté usando, pero que algún otro combine.</p>
<p>El patrón es:</p>
<ul>
<li>
<p>Si una lista está vacía, devuelve cero o alguna otra constante.</p>
</li>
<li>
<p>Lo demás, actúa al principio de la lista (el <code>car</code> de la lista),</p>
<ul>
<li>
<p>y combinar este elemento que actúa, usando <code>+</code> o alguna otra función de combinación, con</p>
</li>
<li>
<p>una llamada recursiva por la función en el resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí hay un ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">add-elements</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;Añade los elementos de NUMBERS-LIST juntos.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="nv">numbers-list</span><span class="p">)</span>
      <span class="mi">0</span>
    <span class="p">(</span><span class="nf">+</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">numbers-list</span><span class="p">)</span> <span class="p">(</span><span class="nv">add-elements</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">numbers-list</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">add-elements</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
    <span class="err">⇒</span> <span class="mi">10</span>
</code></pre>
<p>Vea la Seccion <a href="Creando-una-lista-de-ficheros" >Creando una lista de ficheros</a>, para un ejemplo del patrón acumulado.</p>
</div>
<h5 id="patrón-recursivo:-keep" >Patrón recursivo: <em>keep</em></h5>
<div class="hBody-5" >
<p>Un tercer patrón es llamado el patrón <code>keep</code>. En el patrón recursivo <code>keep</code>, se chequea cada elemento de una lista; se actúa en el elemento y los resultados se guardan solo si el elemento encuentra un criterio.</p>
<p>De nuevo, esto se parece al patrón ‘every’, excepto que el elemento se descarta a menos que se encuentre un criterio.</p>
<p>El patrón tiene tres partes:</p>
<ul>
<li>
<p>Si una lista es vacía, devuelve <code>nil</code>.</p>
</li>
<li>
<p>Lo demás, si el principio de la lista (el <code>car</code> de la lista) pasa un test</p>
<ul>
<li>
<p>actua en este elemento y lo combina, usando <code>cons</code> con</p>
</li>
<li>
<p>una llamada recursiva por la función en el resto (el <code>cdr</code> de la lista.</p>
</li>
</ul>
</li>
<li>
<p>De otro modo, si el principio de la lista (el <code>car</code> de la lista) falla el test</p>
<ul>
<li>
<p>para en este elemento,</p>
</li>
<li>
<p>y, recursivamente llama la función al resto (el <code>cdr</code>) de la lista.</p>
</li>
</ul>
</li>
</ul>
<p>Aquí hay un ejemplo que usa <code>cond</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">manten-tres-letras</span> <span class="p">(</span><span class="nv">lista-palabras</span><span class="p">)</span>
  <span class="s">&#34;Guarda 3 palabras en WORD-LIST.&#34;</span>
  <span class="p">(</span><span class="nb">cond</span>
   <span class="c1">;; Primero do-again-test: stop-condition</span>
   <span class="p">((</span><span class="nv">not</span> <span class="nv">lista-palabras</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>

   <span class="c1">;; Segundo do-again-test: cuando actuar</span>
   <span class="p">((</span><span class="nf">eq</span> <span class="mi">3</span> <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">symbol-name</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-palabras</span><span class="p">))))</span>
    <span class="c1">;; combina el elemento que actúa con la llamada recursiva en la</span>
    <span class="c1">;; lista ordenada</span>
    <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">lista-palabras</span><span class="p">)</span> <span class="p">(</span><span class="nv">manten-tres-letras</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-palabras</span><span class="p">))))</span>

   <span class="c1">;; Tercero do-again-test: cuando se descarte el elemento;</span>
   <span class="c1">;; llama recursivamente a la lista ordenada con la next-step expression</span>
   <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">manten-tres-letras</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">lista-palabras</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">manten-tres-letras</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">uno</span> <span class="nv">dos</span> <span class="nv">tres</span> <span class="nv">cuatro</span> <span class="nv">cinco</span> <span class="nv">seis</span><span class="p">))</span>
    <span class="err">⇒</span> <span class="p">(</span><span class="nv">uno</span> <span class="nv">dos</span><span class="p">)</span>
</code></pre>
<p>Eso va sin decir que no se necesita usar <code>nil</code> como si el test para cuando para; y se puede, de acuerdo, combinar estos patrones.</p>
</div>
<h4 id="recursión-sin-diferir" >Recursión sin diferir</h4>
<div class="hBody-4" >
<p>Permita considerar de nuevo qué ocurre con la función <code>triangle-recursively</code>. Nosotros encontraremos que los cálculos difieran hasta que todo pueda ser hecho.</p>
<p>Aquí está la definición de función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-recursively</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma de los números 1 a través de NUMBER inclusive
</span><span class="s">Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">number</span> <span class="mi">1</span><span class="p">)</span>                    <span class="c1">; do-again-test</span>
      <span class="mi">1</span>                               <span class="c1">; then-part</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span>                         <span class="c1">; else-part</span>
       <span class="p">(</span><span class="nv">triangle-recursively</span>          <span class="c1">; recursive call</span>
        <span class="p">(</span><span class="nf">1-</span> <span class="nv">number</span><span class="p">)))))</span>               <span class="c1">; next-step-expression</span>
</code></pre>
<p>¿Qué ocurre cuando se llama a esta función con un argumento de 7?</p>
<p>La primera instancia de la función <code>triangle-recursively</code> añade el número 7 al valor devuelto por una segunda instancia de <code>triangle-recursively</code>, una instancia que ha pasado un argumento de 6. Así, el primer cálculo es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="p">(</span><span class="nv">triangle-recursively</span> <span class="mi">6</span><span class="p">))</span>
</code></pre>
<p>La primera instancia de <code>triangle-recursively</code> --- se puede querer pensar como un pequeño robot––no puede completar su trabajo. Eso debe manejar el cálculo para <code>(triangle-recursively 6)</code> a una segunda instancia del programa, a un segundo robot. Este segundo individuo es completamente diferente desde el primero; eso es, en la jerga, una ‘diferente instanciación’. O, poner otro camino, eso es un diferente robot. Eso es el mismo modelo como el primero; eso calcula números de triángulo recursivamente; pero eso tiene un número de serie diferente.</p>
<p>¿Y qué hace <code>(triangle-recursively 6)</code> devuelve? Eso devuelve el número 6 añadido al valor devuelto para evaluar <code>triangle-recursively</code> con un argumento de 5. Usando la metáfora del robot, eso cuestiona todavía otro robot para ayudarle.</p>
<p>Ahora el total es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="mi">6</span> <span class="p">(</span><span class="nv">triangle-recursively</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>¿Y qué ocurre después?</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="p">(</span><span class="nv">triangle-recursively</span> <span class="mi">4</span><span class="p">))</span>
</code></pre>
<p>Cada vez que <code>triangle-recursively</code> es llamado, excepto por la última vez, eso crea otra instancia del programa––otro robot --- y pregunta para crear un cálculo.</p>
<p>Finalmente, la adición completa es de la siguiente manera:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">+</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>Este diseño para la función difiere el cálculo del primer paso hasta el segundo puede ser hecho, y difiere esto hasta que el tercero puede ser hecho, y así. Cada defermento significa el ordenador debe recordar que está siendo esperado dentro. Esto no es un problema cuando hay solo unos pocos pasos, como en este ejemplo. Pero eso puede ser un problema cuando hay más pasos.</p>
</div>
<h4 id="no-hay-solución-pospuesta" >No hay solución pospuesta</h4>
<div class="hBody-4" >
<p>La solución al problema de operaciones pospuestas es para escribir en una manera que no posponga operaciones<span class="note" ><sup><a href="#11" >11</a></sup></span>. Esto requiere escribir a un patrón diferente, con frecuencia uno que involucra escribiendo dos definiciones de función, una función de ‘inicialización’ y una función ‘ayuda’.</p>
<p>La función ‘inicializacion’ configura el trabajo; la función ‘ayudante’ hace el trabajo.</p>
<p>Aquí hay dos definiciones para añadir números. Son así de simple, aunque se encuentre duro de comprender.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-initialization</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma de los números 1 a través de NUMBER inclusive.
</span><span class="s">Este es el componente de ‘inicialización’ de una función dúo que
</span><span class="s">usa recursión&#34;</span>
  <span class="p">(</span><span class="nv">triangle-recursive-helper</span> <span class="mi">0</span> <span class="mi">0</span> <span class="nv">number</span><span class="p">))</span>
</code></pre>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-recursive-helper</span> <span class="p">(</span><span class="nv">sum</span> <span class="nv">counter</span> <span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve SUM, usando COUNTER, a través de NUMBER inclusive.
</span><span class="s">Este es el componente ‘helper’ de unas dos funciones
</span><span class="s">que usan recursión.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">counter</span> <span class="nv">number</span><span class="p">)</span>
      <span class="nv">sum</span>
    <span class="p">(</span><span class="nv">triangle-recursive-helper</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">sum</span> <span class="nv">counter</span><span class="p">)</span>  <span class="c1">; suma</span>
                               <span class="p">(</span><span class="nf">1+</span> <span class="nv">counter</span><span class="p">)</span>     <span class="c1">; contador</span>
                               <span class="nv">number</span><span class="p">)))</span>        <span class="c1">; número</span>
</code></pre>
<p>Instalar ambas definiciones de función por evaluarlo, entonces llama a <code>triangle-initialization</code> con 2 filas:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-initialization</span> <span class="mi">2</span><span class="p">)</span>
    <span class="err">⇒</span> <span class="mi">3</span>
</code></pre>
<p>La función ‘inicialización’ llama la primera instancia de la función ‘ayudante’ con tres argumentos: cero, cero, y un número que es el número de filas en el triángulo.</p>
<p>Los primeros dos argumentos pasaron a la función ‘ayuda’ son valores de inicialización. Estos valores son cambiados cuando <code>triangle-recursive-helper</code> invocan nuevas instancias.<span class="note" ><sup><a href="#12" >12</a></sup></span></p>
<p>Permítase ver que ocurre cuando tenemos un triángulo que tiene una fila. (¡Este triángulo tendrá un asterisco dentro!)</p>
<p><code>triangle-initialization</code> llamará su ayudante con los argumentos <code>0 0 1</code>. Esta función ejecutará el test condicional si <code>(&gt; counter number)</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&gt;</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>y encuentra que el resultado es falso, así invocará la else-part de la claúsula <code>if</code>:</p>
<pre class="code" ><code class="chroma" >    <span class="p">(</span><span class="nv">triangle-recursive-helper</span>
     <span class="p">(</span><span class="nf">+</span> <span class="nv">sum</span> <span class="nv">counter</span><span class="p">)</span>  <span class="c1">; @e{sum más counter} ⇒ @e{sum}</span>
     <span class="p">(</span><span class="nf">1+</span> <span class="nv">counter</span><span class="p">)</span>     <span class="c1">; @e{incrementa counter} ⇒ @e{counter}</span>
     <span class="nv">number</span><span class="p">)</span>          <span class="c1">; number parece lo mismo</span>
</code></pre>
<p>que computará primero:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-recursive-helper</span> <span class="p">(</span><span class="nf">+</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">; sum</span>
                           <span class="p">(</span><span class="nf">1+</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">; counter</span>
                           <span class="mi">1</span><span class="p">)</span>       <span class="c1">; number</span>
<span class="nv">que</span> <span class="nv">es:</span>

<span class="p">(</span><span class="nv">triangle-recursive-helper</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>De nuevo, <code>(&gt; counter number)</code> será falso, así de nuevo, el intérprete Lisp evaluará <code>triangle-recursive-helper</code>, creando una nueva instancia con nuevos argumentos.</p>
<p>Esta nueva instancia será;</p>
<pre class="code" ><code class="chroma" >    <span class="p">(</span><span class="nv">triangle-recursive-helper</span>
     <span class="p">(</span><span class="nf">+</span> <span class="nv">sum</span> <span class="nv">counter</span><span class="p">)</span>  <span class="c1">; @e{suma más contador} ⇒ @e{sum}</span>
     <span class="p">(</span><span class="nf">1+</span> <span class="nv">counter</span><span class="p">)</span>     <span class="c1">; @e{incrementar contador} ⇒ @e{contador}</span>
     <span class="nv">number</span><span class="p">)</span>          <span class="c1">; número empieza lo mismo</span>

<span class="nv">que</span> <span class="nv">es:</span>

<span class="p">(</span><span class="nv">triangle-recursive-helper</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>En este caso, el test <code>(&gt; counter number)</code> ¡será cierto!  Así la instancia devolverá el valor de la suma, que será 1, como se espera.</p>
<p>Ahora, permite pasar <code>triangle-initialization</code> un argumento de 2, para encontrar cuántos asterisco hay en un triángulo con dos filas.</p>
<p>Esta función llama <code>(triangle-recursive-helper 0 0 2)</code>.</p>
<p>En fases, las instancias llamadas serán:</p>
<div class="example-block" >
<pre class="example" >                          @e{suma contador número}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)
</pre>
</div>
<p>Cuando la última instancia se llama, el <code>(&gt; counter number)</code> se chequea si será cierto, así la instancia devolverá el valor de <code>sum</code>, que será 3.</p>
<p>Este tipo de patrón ayuda cuando estás escribiendo funciones que puede usar recursos en un ordenador.</p>
</div>
<h3 id="ejercicio-de-bucles" >Ejercicio de bucles</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función similar a <code>triangle</code> en el que cada fila tiene un valor que es la raíz del número de la fila. Usa un bucle <code>while</code>.</p>
</li>
<li>
<p>Escribe una función similar para <code>triangle</code> que multiplique en vez de añadir los valores.</p>
</li>
<li>
<p>Reescribe estas dos funciones recursivamente. Reescribe estas funciones usando <code>cond</code>.</p>
</li>
<li>
<p>Escribe una función para el modo Texinfo que crea una entrada índice al principio de un párrafo para cada <samp>@dfn</samp> con el párrafo. (En un fichero Texinfo, <samp>@dfn</samp> marca una definición. El libro es escrito en Texinfo.)</p>
<p>Muchas de las funciones necesitarán ser descritas en dos de los capítulos, <a href="#corte-y-almacenamiento-de-texto" >Corte y Almacenamiento de Texto</a> y <a href="Pegando-texto" >Pegando texto</a>. Si usas <code>forward-paragraph</code> para poner la entrada índice al principio del párrafo, tendrá que usar <kbd>C-h f</kbd> (<code>describe-function</code>) para encontrar cómo conseguir que el comando vaya hacia atrás.</p>
</li>
</ul>
<p>Para más información, ver “Indicando Definiciones, Comandos, etc.” en <em>Texinfo</em> el <em>Formato de Documentación de GNU</em>.</p>
</div>
<h2 id="búsqueda-de-expresiones-regulares" >Búsqueda de expresiones regulares</h2>
<div class="hBody-2" >
<p>Las búsquedas expresiones regulares son usadas extensivamente en GNU Emacs. Las dos funciones <code>forward-sentence</code> y <code>forward-paragraph</code>, ilustran estas búsquedas bien. Usan expresiones regulares para encontrar donde mover el punto. La frase ‘expresión regular’ es con frecuencia escrita como ‘regexp’.</p>
<p>Las búsquedas de expresiones regulares son descritas en Seccion <q>Búsqueda de Expresión Regular</q> en <em>El Manual de GNU Emacs</em>, tan bien como en Seccion <q>Expresiones Regulares</q> <em>El Manual de Referencia de GNU Emacs Lisp</em>. Escribiendo este capítulo, estoy presuponiendo que tiene al menos una familiaridad con esto. El mayor punto para recordar es que las expresiones regulares te permiten buscar patrones tan bien como para cadenas literales de caracteres. Por ejemplo, el código en <code>forward-sentence</code> busca para el patrón de posibles caracteres que podrían marcar el fin de una frase, y mueve el punto al otro lado.</p>
<p>Antes de mirar en el código la función <code>forward-sentence</code>, es valorable considerar que el patrón que marca el fin de una frase debe estar. El patrón se discute en la siguiente sección; siguiendo que es una descripción de la expresión regular de búsqueda, <code>re-search-forward</code>. La función <code>forward-sentence</code> es descrito en la sección siguiente. Finalmente, la función <code>forward-paragraph</code> es descrito en la última sección de este capítulo. <code>forward-paragraph</code> es una función compleja que introduce varias funcionalidades.</p>
</div>
<h3 id="la-expresión-regular-para-sentence-end" >La expresión regular para <code>sentence-end</code></h3>
<div class="hBody-3" >
<p>El símbolo <code>sentence-end</code> se asocia al patrón que marca el fin de una frase. ¿Cuál sería esta expresión regular?</p>
<p>Claramente, una frase puede ser finalizada por un periodo, una marca de inicio de interrogación, o una marca de exclamación. Puesto que viene del inglés, solo las claúsulas que finalizan con uno de estos tres caracteres deberían ser consideradas al fin de una frase. Esto significa que el patrón incluiría el conjunto de caracteres:</p>
<div class="example-block" >
<pre class="example" >[.?!]
</pre>
</div>
<p>Sin embargo, no queremos que <code>forward-sentence</code> salte a un periodo, una marca de pregunta, o una marca de exclamación, porque tal carácter podría ser usado en el medio de una frase. Un periodo, por ejemplo, se usa después de abreviaciones. Así, otra información es necesaria.</p>
<p>De acuerdo a la convención, escribe dos espacios después de cada frase, pero solo un espacio después de un periodo, una marca de pregunta, o una marca de exclamación seguida por dos espacios es un buen indicador de un fin de frase. Sin embargo, en un fichero, los dos espacios pueden ser un tabulador o el fin de una línea. Esto significa que la expresión regular incluiría estos tres ítems como alternativas.</p>
<p>Este grupo de alternativas se parece a esto:</p>
<div class="example-block" >
<pre class="example" >\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
</pre>
</div>
<p>Aquí, <samp>$</samp> indica el fin de la línea, y yo he apuntado donde el tab y dos espacios están insertados en la expresión. Ambos están insertados poniendo los caracteres actuales dentro de la expresión.</p>
<p>Dos barras invertidas, <samp>\\</samp>, se requiere antes de los paréntesis y barras verticales: la primera barra invertida cita la siguiente barra invertida en Emacs; y el segundo indica que el siguiente caracter, el paréntesis o la barra vertical, es especial.</p>
<p>También, una frase puede ser seguida por uno o más retornos de carro, como este:</p>
<div class="example-block" >
<pre class="example" >[
]*
</pre>
</div>
<p>Como en los tabuladores y espacios, un retorno de carro se inserta dentro de una expresión regular insertándolo literalmente. El asterisco indica que el <kbd>RET</kbd> se repite cero o más veces.</p>
<p>Pero una frase no consiste solo en un periodo, una marca de pregunta o una marca de exclamación seguida por espacios apropiados: una marca de cerrar comillas o cerrar un paréntesis de algún tipo puede preceder el espacio. En realidad más de una marca o paréntesis pueden preceder el espacio. Estas requieren una expresión que se parezca a:</p>
<div class="example-block" >
<pre class="example" >[]\&#34;&#39;)@}]*
</pre>
</div>
<p>En esta expresión, el primer <samp>]</samp> es el primer caracter en la expresión; el segundo caracter es <samp>&#34;</samp>, que está precedido por un <samp>\</samp> para contar Emacs el <samp>&#34;</samp> <em>no</em> es especial. Los últimos tres caracteres son <samp>&#39;</samp>, <samp>)</samp>, y <samp>}</samp>.</p>
<p>Todo esto sugiere que el patrón de la expresión regular para asociar el fin de una frase sería; y, profundamente, si se evalúa <code>sentence-end</code> y encuentra que se devuelve el valor siguiente:</p>
<div class="example-block" >
<pre class="example" >sentence-end
     ⇒ &#34;[.?!][]\&#34;&#39;)@}]*\\($\\|     \\|  \\)[
]*&#34;
</pre>
</div>
<p>(Bien, no en GNU Emacs 22; porque es un esfuerzo crear el proceso simple y manejar más símbolos y lenguajes. Cuando el valor de <code>sentence-end</code> es <code>nil</code>, entonces usa el valor definido por la función <code>sentence-end</code> es <code>nil</code>, entonces usa el valor definido por la función <code>sentence-end</code>. (Aquí se usa la diferencia entre un valor y una función en Emacs Lisp.) La función devuelve un valor construido desde las variables <code>sentence-end-base</code>, <code>sentence-end-double-space</code>, <code>sentence-end-without-period</code>, y <code>sentence-end-without-space</code>. La variable crítica es <code>sentence-end-base</code>; su valor global es similar a uno descrito debajo pero también contiene marcas de cita adicionales. Estas tienen diferentes grados de curvas. La variable <code>sentence-end-without-period</code>, cuando es verdad, dice a Emacs que una frase puede finalizar sin un periodo tal como texto en Thai.)</p>
</div>
<h3 id="la-función-re-search-forward" >La función <code>re-search-forward</code></h3>
<div class="hBody-3" >
<p>La función <code>re-search-forward</code> es similar a la función <code>search-forward</code>. (Vea la Seccion <a href="La-Función-search-forward" >La Función <code>search-forward</code></a>.)</p>
<p><code>re-search-forward</code> busca una expresión regular. Si la búsqueda es exitosa, deja el punto inmediatamente después del último caracter en el objetivo. Si la búsqueda es hacia atrás, deja el punto antes del primer caracter en el objetivo. Se puede contar <code>re-search-forward</code> para devolver <code>t</code> a cierto. (Moviendo el punto es por ello un ‘efecto lateral’.)</p>
<p>Como <code>search-forward</code>, la función <code>re-search-forward</code> toma cuatro argumentos:</p>
<ol class="num" >
<li>
<p>El primer argumento es la expresión regular que la función busca. La expresión regular será una cadena entre comillas.</p>
</li>
<li>
<p>El segundo argumento opcional limita cómo la función busca; es un emparejamiento, que se especifica como una posición en el búfer.</p>
</li>
<li>
<p>El tercer argumento opcional especifica cómo la función responde al fallo: <code>nil</code> como tercer argumento que causa la función para señalar un error (e imprime un mensaje) cuando la búsqueda falla; cualquier otro valor causa devolver <code>nil</code> si la búsqueda falla y <code>t</code> si la búsqueda tiene éxito.</p>
</li>
<li>
<p>El cuarto argumento opcional es el contaje repetido. Un contaje negativo repetido causa <code>re-search-forward</code> para buscar hacia atrás.</p>
</li>
</ol>
<p>La plantilla para <code>re-search-forward</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;@V{regular-expression}&#34;</span>
                <span class="nv">@V{limit-of-search}</span>
                <span class="nv">@V{what-to-do-if-search-fails}</span>
                <span class="nv">@V{repeat-count}</span><span class="p">)</span>
</code></pre>
<p>El segundo, tercer, y cuarto argumentos son opcionales. Sin embargo, si se quiere pasar un valor a uno o ambos de los últimos dos argumentos, se debe también pasar un valor a todos los argumentos precedentes. De otro modo, el intérprete Lisp errará a qué argumento estás pasando el valor.</p>
<p>En la función <code>forward-sentence</code>, la expresión regular será el valor de la variable <code>sentence-end</code>. En forma simple, esto es:</p>
<div class="example-block" >
<pre class="example" >&#34;[.?!][]\&#34;&#39;)@}]*\\($\\|  \\|  \\)[
]*&#34;
</pre>
</div>
<p>El límite de la búsqueda será el fin del párrafo (desde una frase no puede ir bajo un párrafo). Si la búsqueda falla, la función devuelve <code>nil</code>, y el contaje repite será provisto por el argumento para la función <code>forward-sentence</code>.</p>
</div>
<h3 id="la-función-forward-sentence" >La función <code>forward-sentence</code></h3>
<div class="hBody-3" >
<p>El comando mueve el cursor hacia adelante una frase es una ilustración honesta de cómo usar búsquedas de expresiones regulares en Emacs Lisp. En realidad, la función parece más larga y más complicada de lo que es; esto es porque la función está diseñada para ir hacia atrás tan bien como hacia adelante; y, opcionalmente, a través de una frase. La función está normalmente asociada al comando <kbd>M-e</kbd>.</p>
<p>Aquí está la código para <code>forward-sentence</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">forward-sentence</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;Ve al siguiente ‘sentence-end’. Con el argumento, repite.
</span><span class="s">Con el argumento negativo, mueve atrás repetidamente a ‘sentence-beginning’.
</span><span class="s">La variable ‘sentence-end’ es una expresión regular que empareja el
</span><span class="s">fin de frases. También, cada párrafo asociado termina las frases
</span><span class="s">bien.
</span><span class="s">  (interactive &#34;</span><span class="nv">p</span><span class="s">&#34;)
</span><span class="s">  (or arg (setq arg 1))
</span><span class="s">  (let ((opoint (point))
</span><span class="s">        (sentence-end (sentence-end)))
</span><span class="s">    (while (&lt; arg 0)
</span><span class="s">      (let ((pos (point))
</span><span class="s">            (par-beg (save-excursion (start-of-paragraph-text) (point))))
</span><span class="s">       (if (and (re-search-backward sentence-end par-beg t)
</span><span class="s">                (or (&lt; (match-end 0) pos)
</span><span class="s">                    (re-search-backward sentence-end par-beg t)))
</span><span class="s">           (goto-char (match-end 0))
</span><span class="s">         (goto-char par-beg)))
</span><span class="s">      (setq arg (1+ arg)))
</span><span class="s">    (while (&gt; arg 0)
</span><span class="s">      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
</span><span class="s">       (if (re-search-forward sentence-end par-end t)
</span><span class="s">           (skip-chars-backward &#34;</span> <span class="nv">\t\n</span><span class="s">&#34;)
</span><span class="s">         (goto-char par-end)))
</span><span class="s">      (setq arg (1- arg)))
</span><span class="s">    (constrain-to-field nil opoint t)))
</span><span class="s"></span></code></pre>
<p>La función se ve larga a primera vista y es mejor mirar primero el esqueleto, y entonces su músculo. El camino para ver el esqueleto es mirar en las expresiones que empiezan las columnas más a la izquierda:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">forward-sentence</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">opoint</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span> <span class="p">(</span><span class="nv">sentence-end</span> <span class="p">(</span><span class="nv">sentence-end</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">pos</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">par-beg</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">start-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
       <span class="nv">@V{rest-of-body-of-while-loop-when-going-backwards}</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">par-end</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
       <span class="nv">@V{rest-of-body-of-while-loop-when-going-forwards}</span>
    <span class="nv">@V{handle-forms-and-equivalent}</span>
</code></pre>
<p>¡Esto parece bastante simple! La definición de la función consiste de documentación una expresión <code>interactive</code>, una expresión <code>or</code>, una expresión <code>let</code>, y bucles <code>while</code>.</p>
<p>Permite mirar cada una de estas partes.</p>
<p>Notamos que la documentación es profunda y comprensible.</p>
<p>La función tiene una declaración <code>interactive &#34;p&#34;</code>. Esto signifca que el argumento prefijo, si cualquiera es pasado a la función como su argumento. (Esto será un número.) Si la función no pasa un argumento (eso es opcional) entonces el argumento <code>arg</code> será asociado a 1.</p>
<p>Cuando <code>forward-sentence</code> se llama no interactivamente sin un argumento, <code>arg</code> está asignado <code>nil</code>. La expresión <code>or</code> maneja esto. Lo que hace es dejar el valor de <code>arg</code> como eso es, pero solo si <code>arg</code> está asignado a un valor; o eso asigna el valor de <code>arg</code> a 1, en el caso de <code>arg</code> está asignado a <code>nil</code>.</p>
<p>Lo siguiente es un <code>let</code>. Que especifica los valores de dos variables locales <code>point</code> y <code>sentence-end</code>. El valor local de punto, desde antes de la búsqueda, es usada en la función <code>constrain-to-field</code> que maneja formularios y equivalentes. La variable <code>sentence-end</code> está asignada por la función <code>sentence-end</code>.</p>
</div>
<h4 id="los-bucles-while" >Los bucles <code>while</code></h4>
<div class="hBody-4" >
<p>Sigue dos bucles <code>while</code>. El primer <code>while</code> tiene un true-or-false-test que chequea cierto si el argumento prefijo para <code>forward-sentence</code> es un número negativo. Esto es para volver hacia atrás. El cuerpo de este bucle es similar al cuerpo de la segunda cláusula <code>while</code>, pero eso no es exactamente el mismo. Se obviará este bucle <code>while</code> y concentra en el segundo bucle <code>while</code>.</p>
<p>El segundo bucle <code>while</code> está moviendo el punto hacia adelante. Su esqueleto se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span>            <span class="c1">; true-or-false-test</span>
  <span class="p">(</span><span class="nb">let</span> <span class="nv">@V{varlist}</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">@V{true-or-false-test}</span><span class="p">)</span>
        <span class="nv">@V{then-part}</span>
      <span class="nv">@V{else-part}</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">))))</span>     <span class="c1">; @c{while} @e{loop decrementer}</span>
</code></pre>
<p>El bucle <code>while</code> es el tipo de decremento. (Vea la Seccion <a href="Los-bucles-while" >Los bucles <code>while</code></a>.) Eso tiene un true-or-false-test que chequea cierto tan largo con el contador (en este caso, la variable <code>arg</code>) es mayor que cero; y eso tiene un decremento que elimina 1 desde el valor del contador cada vez que el bucle se repite.</p>
<p>Si ningún argumento prefijo es dado para <code>forward-sentece</code>, que es el camino más común es usado, este bucle <code>while</code> ejecutará una vez, desde que el valor de <code>arg</code> será 1.</p>
<p>El cuerpo del cuerpo <code>while</code> consite de una expresión <code>let</code>, que crea y asocia una variable local, y tiene, su cuerpo, una expresión <code>if</code>.</p>
<p>El cuerpo del bucle <code>while</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">par-end</span>
       <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sentence-end</span> <span class="nv">par-end</span> <span class="no">t</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">skip-chars-backward</span> <span class="s">&#34; \t\n&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">par-end</span><span class="p">)))</span>
</code></pre>
<p>La expresión <code>let</code> crea y asocia la variable local <code>par-end</code>. Como se ve, esta variable local está diseñada para proporcionar una asociación o límite para la búsqueda de la expresión regular. Si la búsqueda falla para encontrar una frase apropiada finalizando en el párrafo, eso se parará logrando el fin del párrafo.</p>
<p>Pero primero, permítenos examinar cómo <code>par-end</code> se asocia a la variable del fin del párrafo. Lo que ocurre es que el <code>let</code> asigna el valor de <code>par-end</code> al valor devuelto cuando el intérprete evalúa la expresión.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-paragraph-text</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
</code></pre>
<p>En esta expresión, <code>(end-of-paragraph-text)</code> mueve el punto al fin del párrafo, <code>(point)</code> devuelve el valor del punto, y entonces <code>save-excursion</code> restaura el punto a su posición original. De este modo, el <code>let</code> asocia <code>par-end</code> al valor devuelto por la expresión <code>save-excursion</code>, que es la posición del fin del párrafo.  (La función <code>end-of-paragraph-text</code> usa <code>forward-paragraph</code>, que se discutirá pronto.)</p>
<p>Emacs evalúa el cuerpo del <code>let</code>, que es una expresión <code>if</code> que se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sentence-end</span> <span class="nv">par-end</span> <span class="no">t</span><span class="p">)</span> <span class="c1">; if-part</span>
    <span class="p">(</span><span class="nf">skip-chars-backward</span> <span class="s">&#34; \t\n&#34;</span><span class="p">)</span>              <span class="c1">; then-part</span>
  <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">par-end</span><span class="p">)))</span>                        <span class="c1">; else-part</span>
</code></pre>
<p>El test <code>if</code> si su primer argumento es cierto y si así, evalúa su parte then; de otro modo, el intérprete Emacs Lisp evalúa la parte else. El true-or-false-test de la expresión <code>if</code> es la búsqueda de la expresión regular.</p>
<p>Puede estar mal tener que mirar como el ‘trabajo real’ de la función <code>forward-sentence</code> es vista aquí, pero esto es un camino común de este tipo de operación traida en Lisp.</p>
</div>
<h4 id="la-búsqueda-de-expresiones-regulares" >La búsqueda de expresiones regulares</h4>
<div class="hBody-4" >
<p>La función <code>re-search-forward</code> busca el fin de la frase, que es, para el patrón definido por la expresión regular <code>sentence-end</code>. Si el patrón es encontrado––si el fin de la frase se encuentra––entonces la función <code>re-search-forward</code> hace dos cosas:</p>
<ol class="num" >
<li>
<p>La función <code>re-search-forward</code> trae un efecto secundario, que es mover el punto al final de la ocurrencia encontrada.</p>
</li>
<li>
<p>La función <code>re-search-forward</code> devuelve un valor de verdad. Esto es el valor recibido por el <code>if</code>, y significa que la búsqueda fué exitosa.</p>
</li>
</ol>
<p>El efecto secundario, el movimiento del punto se completa antes de la función <code>if</code> y es manejado por el valor devuelto por la exitosa conclusión de la búsqueda.</p>
<p>Cuando la función <code>if</code> recibe el valor de verdad desde una llamada exitosa a <code>re-search-forward</code>, el <code>if</code> evalúa la parte then que es la expresión <code>(skip-chars-backward &#34;\t\n&#34;)</code>. Esta expresión se mueve atrás a través de espacios en blanco, los tabuladores o retornos de carro hasta un caracter impreso es encontrado y entonces deja el punto correcto después del caracter impreso cerrado de la frase, que es normalmente un periodo.</p>
<p>Por otro lado, si la función <code>re-search-forward</code> falla para encontrar un patrón marcando el fin de la frase, la función devuelve falso. Lo falso causa el <code>if</code> para evaluar su tercer argumento, que es <code>(goto-char par-end)</code>: eso mueve el punto al final del párrafo.</p>
<p>(Y si el texto está en una forma o equivalente, y apunta a que no puede moverse completamente entonces la función <code>constrain-to-field</code> empieza a funcionar.)</p>
<p>Las búsquedas de expresiones regulares son excepcionalmente útiles y el patrón ilustrado por <code>re-search-forward</code>, en el que la búsqueda es el test de una expresión <code>if</code>, es manejable. Se verá o escribirá código incorporando este patrón con frecuencia.</p>
</div>
<h3 id="forward-paragraph:-una-mina-de-oro-de-funciones" ><code>forward-paragraph</code>: una mina de oro de funciones</h3>
<div class="hBody-3" >
<p>La función <code>forward-paragraph</code> mueve el punto al fin del párrafo. Eso está normalmente asociado a <kbd>M-}</kbd> y hace uso de un número de funciones que son importantes en sí, incluyendo <code>let*</code>, <code>match-beginning</code>, y <code>looking-at</code>.</p>
<p>La definición de función para <code>forward-paragraph</code> es considerablemente mayor que la definición de función para <code>forward-sentence</code> porque eso funciona como un párrafo, cada línea puede empezar con un prefijo de relleno <em>fill prefix</em>.</p>
<p>Un prefijo de relleno <em>fill prefix</em> consiste en una cadena de caracteres que se repite al principio de cada línea. Por ejemplo, en código Lisp, es una convención para empezar cada línea de un comentario de párrafo largo con <samp>;;; </samp>. En modo Texto, cuatro espacios en blanco crean otro prefijo de relleno <em>fill prefix</em> común, creando un párrafo indentado. (Véase Sección <q>Fill Prefix</q> en <em>The GNU Emacs Manual</em> para más información acerca de prefijos de relleno <em>fill prefix</em>.)</p>
<p>La existencia de un prefijo de relleno significa que además de ser capaz de encontrar el fin de un párrafo cuyas líneas empiezan más a la izquierda, la función <code>forward-paragraph</code> debe ser capaz de encontrar el fin de un párrafo cuando todas o muchas de las líneas en el búfer empiezan con el prefijo de relleno <em>fill prefix</em>.</p>
<p>Más allá, es algunas veces práctico ignorar un prefijo de relleno <em>fill prefix</em> que existe, especialmente cuando las líneas en blanco separen párrafos. Esto es una complicación añadida.</p>
<p>En vez de imprimir toda la función <code>forward-paragraph</code>, nosotros solo imprimiremos partes de la misma. ¡Lee sin preparación, la función puede estar para desanimar!</p>
<p>En esquema, la función se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">forward-paragraph</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let*</span>
      <span class="nv">@V{varlist}</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">bobp</span><span class="p">)))</span>     <span class="c1">; backward-moving-code</span>
      <span class="err">…</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>     <span class="c1">; forward-moving-code</span>
      <span class="err">…</span>
</code></pre>
<p>Las primeras partes de la función son rutinas: la función lista argumentos que consisten de un argumento opcional. La documentación sigue.</p>
<p>La letra minúscula <samp>p</samp> en la declaración <code>interactive</code> significa que el argumento prefijo se procesa, si se pasa a la función. Eso será un número, y es el contaje repetido de cuántos párrafos se moverá. La expresión <code>or</code> en la siguiente línea maneja el caso común cuando no hay argumentos que se pasan a la función, esto ocurre si la función se llama desde otro código en vez de interactivamente. Este caso se describe pronto. (Vea la Seccion <a href="La-función-forward-sentence" >La función <code>forward-sentence</code></a>.) Ahora se logra el fin de la parte familiar de esta función.</p>
</div>
<h4 id="la-expresión-let*" >La expresión <code>let*</code></h4>
<div class="hBody-4" >
<p>La siguiente línea de la función <code>forward-paragraph</code> empieza una expresión <code>let*</code>. Esto es tan diferente como <code>let</code>. El símbolo es <code>let*</code> no <code>let</code>.</p>
<p>La forma especial <code>let*</code> es como <code>let</code> excepto que Emacs asigna cada variable en secuencia, una después de otra, y las variables en la última parte de la varlist hacen uso de los valores para los que Emacs asignó variable al principio la varlist.</p>
<p>(Seccion <a href="La-definición-de-append-to-buffer" >La definición de <code>append-to-buffer</code></a>.)</p>
<p>En la expresión <code>let*</code> en esta función, Emacs asigna un total de siete variables: <code>opoint</code>, <code>fill-prefix-regexp</code>, <code>parstart</code>, <code>parsep</code>, <code>sp-parstart</code>, <code>start</code>, y <code>found-start</code>.</p>
<p>La variable <code>parsep</code> aparece dos veces, primero, para borrar instancias de <samp>^</samp>, y segundo, para manejar prefijos rellenos.</p>
<p>La variable <code>opoint</code> es solo el valor de <code>point</code>. Como se puede adivinar, eso se usa en una expresión <code>constrain-to-field</code>, solo como en <code>forward-sentence</code>.</p>
<p>La variable <code>fill-prefix-regexp</code> se asigna al valor devuelto para evaluar la siguiente lista:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="nv">fill-prefix</span>
     <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">equal</span> <span class="nv">fill-prefix</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
     <span class="p">(</span><span class="nv">not</span> <span class="nv">paragraph-ignore-fill-prefix</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">regexp-quote</span> <span class="nv">fill-prefix</span><span class="p">))</span>
</code></pre>
<p>Esta es una expresión cuyo primer elemento es la forma especial <code>and</code>.</p>
<p>Como se aprendió antes la (Vease Sección <a href="Función-kill-new,-,-La-función-kill-new" >Función kill-new, , La función <code>kill-new</code></a>), la forma especial <code>and</code> evalúa cada uno de sus argumentos hasta uno de los argumentos y devuelve un valor de <code>nil</code> en el que el caso de la expresión <code>and</code> devuelve <code>nil</code>; sin embargo, si ninguno de los argumentos devuelve un valor de <code>nil</code>, el valor resultante de evaluar el último argumento es devuelto. (Puesto que tal valor no es <code>nil</code>, eso es considerado verdad en Lisp.) En otras palabras, una expresión <code>and</code> devuelve un valor de verdad solo si todos sus argumentos son verdad.</p>
<p>En este caso, la variable <code>fill-prefix-regexp</code> está asociado a un valor no <code>nil</code> solo si el las siguientes cuatro expresiones producen un valor true (por ej., un no <code>nil</code>) cuando son evaluados; de otro modo, <code>fill-prefix-regexp</code> está asociado a <code>nil</code>.</p>
<dl>
<dt><code>fill-prefix</code></dt>
<dd>
<p>Cuando esta variable se evalúa, el valor del prefijo de relleno <em>fill prefix</em>, si cualquiera, está devuelto. Si no hay prefijo relleno, la variable devuelve <code>nil</code>.</p>
</dd>
<dt>(not (equal fill-prefix &#34;&#34;)</dt>
<dd>
<p>Esta expresión chequea si un prefijo lleno es una cadena vacía, que es, una cadena sin caracteres en eso. Una cadena vacía no es útil un prefijo relleno <em>fill prefix</em>.</p>
</dd>
<dt>(not paragraph-ignore-fill-prefix)</dt>
<dd>
<p>Esta expresión devuelve <code>nil</code> si la variable <code>paragraph-ignore-fill-prefix</code> ha sido cambiado siendo asignado un valor de verdad tal como <code>t</code>.</p>
</dd>
<dt>(regexp-quote fill-prefix)</dt>
<dd>
<p>Este es el último argumento para la forma especial <code>and</code>. Si todos los argumentos de <code>and</code> son verdaderos, el valor resultante de evaluar esta expresión será devuelto por la expresión <code>and</code> y asociado a la variable <code>fill-prefix-regexp</code>,</p>
</dd>
</dl>
<p>El resultado de evaluar esta expresión <code>and</code> con éxito es que <code>fill-prefix-regexp</code> se asociará al valor de <code>fill-prefix</code> como fué modificado por la función <code>regexp-quote</code>. Lo que <code>regexp-quote</code> hace es leer una cadena y devolver la expresión regular que asociará exactamente la cadena y nada más. Esto significa que <code>fill-prefix-regexp</code> será asignada a un valor que asociará el prefijo si el prefijo existe. De otro modo, la variable será asignada a <code>nil</code>.</p>
<p>Las dos variables locales siguientes en la expresión <code>let*</code> están diseñadas para eliminar instancias de <samp>^</samp> desde <code>parstart</code> y <code>parsep</code>, las variables locales indican que el párrafo empieza como separador de párrafo. La siguiente expresión asigna <code>parsep</code> de nuevo. Esto es manejar prefijos rellenos.</p>
<p>Esta es la configuración que requiere la llamada de la definición <code>let*</code> en vez de <code>let</code>. El true-or-false-test para el <code>if</code> depende de si la variable <code>fill-prefix-regexp</code> evalúa a <code>nil</code> o algún otro valor.</p>
<p>Si <code>fill-prefix-regexp</code> no tiene un valor, Emacs evalúa la parte else de la expresión <code>if</code> y asocia <code>parsep</code> a su valor local. (<code>parsep</code> es una expresión regular que asocia lo que los párrafos separan.)</p>
<p>Pero si <code>fill-prefix-regexp</code> tiene un valor, Emacs evalúa la parte then de la expresión <code>if</code> y asocia <code>parsep</code> a una expresión regular que incluye el <code>fill-prefix-regexp</code> como parte del patrón.</p>
<p>Específicamente, <code>parsep</code> está asignado al valor original del párrafo que separa la expresión regular concatenada con una expresión alternativa que consiste del <code>fill-prefix-regexp</code> seguido por espacios en blanco opcionales para el fin de la línea. El espacio en blanco está definido por <code>&#34;[ \t]*$&#34;</code>.) El <samp>\\|</samp> define esta porción del regexp como una alternativa a <code>parsep</code>.</p>
<p>De acuerdo a un comentario en el código, la siguiente variable local, <code>sp-parstart</code>, se usa para buscar, y entonces los dos finales, <code>start</code> y <code>found-start</code>, se asignan a <code>nil</code>.</p>
<p>Ahora tenemos dentro el cuerpo del <code>let*</code>. La primera parte del cuerpo del <code>let*</code> trata con el caso cuando la función es dada a un argumento negativo y consiguientemente moviéndose hacia atrás. Nosotros saldremos de esta sección yendo hacia atrás.</p>
</div>
<h4 id="el-bucle-while-hacia-adelante" >El bucle <code>while</code> hacia adelante</h4>
<div class="hBody-4" >
<p>La segunda parte del cuerpo del <code>let*</code> trata con el proceso hacia adelante. Eso es un bucle <code>while</code> que se repite si el valor de <code>arg</code> es mayor que cero. En el uso más común de la función el valor del argumento es 1, así el cuerpo del bucle <code>while</code> se evalúa exactamente una vez, y el cursor se mueve hacia adelante un párrafo.</p>
<p>Esta parte maneja tres situaciones: cuando el punto está entre párrafos, cuando hay un prefijo de relleno y cuando no hay prefijo de relleno <em>fill prefix</em>.</p>
<p>El bucle <code>while</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; yendo hacia adelante y no al fin del búfer</span>
<span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">arg</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>

  <span class="c1">;; entre párrafos</span>
  <span class="c1">;; Mueve hacia adelante a través de líneas de</span>
  <span class="c1">;; separación...</span>
  <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
              <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c1">;;  @e{Esto decremento el bucle}</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">)))</span>
  <span class="c1">;; ... y una línea más</span>
  <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">)</span>

  <span class="p">(</span><span class="nb">if</span> <span class="nv">fill-prefix-regexp</span>
      <span class="c1">;; Hay un prefijo lleno; que sobreescribe parstart;</span>
      <span class="c1">;; vamos adelante línea por línea</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">))</span>
                  <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
                  <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">))</span>
                  <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">fill-prefix-regexp</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1">;; No hay prefijo;</span>
    <span class="c1">;; vamos hacia adelante caracter por caracter</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sp-parstart</span> <span class="no">nil</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
                       <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parstart</span><span class="p">))</span>
                    <span class="p">(</span><span class="nb">and</span> <span class="nv">use-hard-newlines</span>
                         <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">get-text-property</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">start</span><span class="p">)</span> <span class="ss">&#39;hard</span><span class="p">)))))</span>
      <span class="p">(</span><span class="nf">forward-char</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1">;; y si no hay prefijo y si no estamos al final</span>
    <span class="c1">;; ir a lo que fué encontrado en la búsqueda de expresiones regulares</span>
    <span class="c1">;; para sp-parstart</span>
    <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">))))</span>
</code></pre>
<p>Se puede ver que esto es un contador de decremento <code>while</code>, usando la expresión <code>(setq arg (1- arg))</code> como lo que se decrementa. Esta expresión no está lejos desde el <code>while</code>, pero está oculta en otra macro Lisp, una macro <code>unless</code>. A menos que estemos al final del búfer––esto es lo que la función <code>eobp</code> determina; eso es una abreviación de <samp>Fin del Buffer P</samp> --- nosotros decrementamos el valor de <code>arg</code> por uno.</p>
<p>(Si estamos al fin del búfer, no podemos ir más hacia adelante y el siguiente bucle de la expresión <code>while</code> chequeará falso desde que el test es un <code>and</code> con <code>(not (eobp))</code>. La función <code>not</code> significa exactamente como se esperaba; eso es otro nombre de <code>null</code>, una función que devuelve cierto cuando su argumento es falso.)</p>
<p>De manera interesante, el bucle cuenta que no se decrementa hasta que deje el espacio entre párrafos, a menos que vuelva al fin del búfer o pare viendo el valor local del separador del párrafo.</p>
<p>El segundo <code>while</code> también tiene una expresión <code>(move-to-left-margin)</code>. La función es autoexplicativa. Eso está dentro de una expresión <code>progn</code> y no el último elemento de su cuerpo, así es solo invocado para su efecto secundario, que es mover el punto al margen izquierdo de la línea actual.</p>
<p>La función <code>looking-at</code> es también auto-explicativa; eso devuelve cierto si el texto después del punto asocia la expresión regular dada como su argumento.</p>
<p>El resto del cuerpo del bucle se ve compleja al principio, pero tiene sentido cuando se comprende.</p>
<p>Primero considera que ocurre si hay un prefijo de relleno <em>fill prefix</em>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">fill-prefix-regexp</span>
    <span class="c1">;; Hay un prefijo lleno; que sobreescribe parstart;</span>
    <span class="c1">;; vamos adelante línea por línea</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
                <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">fill-prefix-regexp</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">forward-line</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<p>Esta expresión mueve el punto hacia adelante línea por línea tan lejos como que las cuatro condiciones son ciertas:</p>
<ol class="num" >
<li>
<p>Punto no está al final del búfer.</p>
</li>
<li>
<p>Podemos mover al margen izquierdo del texto y no estar al fin del búfer.</p>
</li>
<li>
<p>El siguiente punto no separa párrafos.</p>
</li>
<li>
<p>El patrón que sigue el punto es la expresión regular prefija rellena.</p>
</li>
</ol>
<p>La última condición puede ser un puzzle, hasta que se recuerde qué punto fué movido al principio de la línea temprana en la función <code>forward-paragraph</code>. Esto significa que si el texto tiene el prefijo relleno, la función <code>looking-at</code> se verá.</p>
<p>Considera qué ocurre cuando no hay un prefijo lleno.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="nv">sp-parstart</span> <span class="no">nil</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
                   <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eobp</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">progn</span> <span class="p">(</span><span class="nv">move-to-left-margin</span><span class="p">)</span>
                   <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parsep</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">looking-at</span> <span class="nv">parstart</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">and</span> <span class="nv">use-hard-newlines</span>
                     <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">get-text-property</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">start</span><span class="p">)</span> <span class="ss">&#39;hard</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">forward-char</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<p>El bucle <code>while</code> nos tiene buscando hacia adelante para <code>sp-parstart</code>, que es la combinación de posibles espacios en blanco con un valor local del comienzo de un párrafo o de un párrafo separador. (Las últimas dos son con una expresión empezando con <code>(?:)</code> así que no están referenciadas por la función <code>match-beginning</code>.)</p>
<p>Las dos expresiones,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">start</span> <span class="p">(</span><span class="nf">match-beginning</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
</code></pre>
<p>significa ir al comienzo del siguiente texto localizado por la expresión regular.</p>
<p>La expresión <code>(match-beginning 0)</code> es nueva. Eso devuelve un número especificando la posición del comienzo del texto fuese asociado a la última búsqueda.</p>
<p>La función <code>match-beginning</code> es usado aquí porque una característica de una búsqueda hacia adelante: una búsqueda hacia adelante, sin dignidad si eso es una búsqueda plana o una expresión regular, mueve el punto al fin del texto que es encontrado. En este caso, una búsqueda exitosa mueve el punto al fin del patrón para <code>sp-parstart</code>.</p>
<p>Sin embargo, se quiere poner el punto al fin del actual párrafo, no en algún lugar más. En vez de eso, desde que la búsqueda posiblemente incluye el separador del párrafo, el punto puede finalizar al principio de lo siguiente a menos que se use una expresión que incluya <code>match-beginning</code>.</p>
<p>Cuando un argumento de 0, <code>match-beginning</code> devuelve la posición que es el comienzo del texto asociado por la búsqueda más reciente. En este caso, la búsqueda más reciente parece <code>sp-parstart</code>. La expresión <code>(match-beginning 0)</code> devuelve la posición del comienzo de este patrón, en vez de la posición final de este patrón.</p>
<p>(Incidentalmente, cuando se pasa un número positivo como un argumento, la función <code>match-beginning</code> devuelve la localización de punto en el que la expresión con paréntesis en la última búsqueda a menos que la expresión con paréntesis empiece con <code>\(?:</code>. No sé porque <code>\(?:</code> aparece aquí desde que el argumento es 0.)</p>
<p>La última expresión cuando no hay prefijos es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">point-max</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">))))</span>
</code></pre>
<p>Esto dice que si no hay prefijo lleno y no estamos al punto final que se movería al principio de lo que fué encontrado por la búsqueda de la expresión regular para <code>sp-parstart</code>.</p>
<p>La definición completa para la función <code>forward-paragraph</code> no solo incluye código para avanzar, también código para retroceder.</p>
<p>Si está leyendo esto dentro de GNU Emacs y quieres ver la función completa, se puede escribir <kbd>C-h f</kbd> (<code>describe-function</code>) y el nombre de la función. Esto da la documentación de función y el nombre de la librería conteniendo las fuentes de la función. Posiciona el punto a través del nombre de la librería y presionar la tecla RET; será tomado directamente a las fuentes. (¡Asegúrate de instalar las fuentes! ¡Sin eso, estarás como una persona que intenta conducir un coche con los ojos cerrados!)</p>
</div>
<h3 id="crea-tu-propio-fichero-tags" >Crea tu propio fichero <span class="file" >TAGS</span></h3>
<div class="hBody-3" >
<p>Bajo <kbd>C-h f</kbd> (<code>describe-function</code>), otro camino para ver la fuente de una función es escribir <kbd>M-.</kbd> (<code>find-tag</code>) y el nombre de la función se asigna para eso. Esto es un buen hábito para obtenerlo. El comando <kbd>M-.</kbd> (<code>find-tag</code>) toma directamente a las fuentes de una función, variable, o nodo. La función depende de tablas de etiquetas para saber donde ir.</p>
<p>Si la función <code>find-tag</code> pregunta primero por el nombre de una tabla <span class="file" >TAGS</span>, dado el nombre de un fichero <span class="file" >TAGS</span> tal como <span class="file" >/usr/local/src/emacs/src/TAGS</span>. (La ruta exacta a tu fichero <span class="file" >TAGS</span> depende de cómo tu copia de Emacs fué instalada. Yo te cuento la localización que provee tanto mi C y mis fuentes de Emacs Lisp.)</p>
<p>Se puede también crear tu propio fichero <span class="file" >TAGS</span> para los directorios que faltan.</p>
<p>Con frecuencia se necesita construir e instalar etiquetas de tablas por uno mismo. Esas no son construidas automáticamente. Una tabla de etiquetas llama a un fichero <span class="file" >TAGS</span>; el nombre es letras mayúsculas.</p>
<p>Se puede crear un fichero <span class="file" >TAGS</span> llamando el programa <code>etags</code> que viene como parte de la distribución Emacs. Normalmente, <code>etags</code> está compilado e instalado cuando Emacs se construye. (<code>etags</code> no es una función Lisp o una parte de Emacs; eso es un programa C.)</p>
<p>Para crear el fichero <span class="file" >TAGS</span>, primero cambia el directorio en el que se quiere crear el fichero. En Emacs se puede hacer esto con el comando <kbd>M-x cd</kbd>, o visitando un fichero en el directorio, o listando el directorio <code>etags *.el</code> como el comando a ejecutar</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags *.el RET
</pre>
</div>
<p>crear un fichero de <span class="file" >TAGS</span> para Emacs Lisp.</p>
<p>Por ejemplo, si se tiene un gran número de ficheros en el directorio <span class="file" >~/emacs</span>, como se hace––Yo tengo 137 <span class="file" >.el</span> dentro, de que se carguen 12––se puede crear un fichero <span class="file" >TAGS</span> para los ficheros Emacs Lisp en este directorio.</p>
<p>El programa <code>etags</code> toma en toda la consola usual ‘comodines’. Por ejemplo, si tienes dos directorios para el que quieres un fichero <span class="file" >TAGS</span> simple, escribe <code>etags *.el ../elisp/*.el</code>, donde <span class="file" >../elisp/</span> es el segundo directorio:</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags *.el ../elisp/*.el RET
</pre>
</div>
<p>Tipo</p>
<div class="example-block" >
<pre class="example" >M-x compile RET etags --help RET
</pre>
</div>
<p>para ver una lista de las opciones aceptadas por <code>etags</code> tan bien como una lista de lenguajes soportados.</p>
<p>El programa <code>etags</code> maneja más de 20 lenguajes, incluyendo Emacs Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java, LaTeX, Pascal, Perl, Postscript, Python, TeX, Texinfo, makefiles, y la mayoría de ensambladores. El programa no cambia para especificar el lenguaje; eso reconoce el lenguaje como una entrada de fichero de acuerdo a su nombre de fichero y contenidos.</p>
<p><span class="file" >etags</span> es muy útil cuando se escribe código por tí mismo y quiere referirse a funciones que ya se han escrito. Ahora ejecuta <code>etags</code> de nuevo en intervalos como se escriben nuevas funciones, así llegan a ser parte del fichero <span class="file" >TAGS</span>.</p>
<p>Si piensa que un fichero <span class="file" >TAGS</span> apropiado que ya existe para lo que quieres, pero no conoces donde está, se puede usar el programa <code>locate</code> para intentar encontrarlo.</p>
<p>Escribe <kbd>M-x locate <kbd>RET</kbd> TAGS <kbd>RET</kbd></kbd> y Emacs listará para ti las rutas nombres completas de todos tus ficheros <span class="file" >TAGS</span>. En mi sistema, este comando lista 34 fichero <span class="file" >TAGS</span>. Por otro lado, un sistema ‘vanilla plano’ que recientemente no contenía fichero <span class="file" >TAGS</span>.</p>
<p>Si la tabla de etiquetas que se quiere ha sido creada, se puede usar el comando <code>M-x visit-tags-table</code> para especificarlo. De otro modo, se necesitará la tabla de etiquetas por tí mismo y entonces usar <code>M-x visit-tags-table</code>.</p>
</div>
<h4 id="construyendo-etiquetas-en-las-fuentes-emacs" >Construyendo Etiquetas en las fuentes Emacs</h4>
<div class="hBody-4" >
<p>Las fuentes GNU Emacs vienen con un <span class="file" >Makefile</span> que contiene un comando sofisticado <code>etags</code> que crea, recoge, y asocia tablas de etiquetas de todas las fuentes de Emacs y pone la información dentro de un fichero <span class="file" >TAGS</span> en el directorio <span class="file" >src/</span>. (El directorio <span class="file" >src/</span> está debajo del alto nivel de tu directorio Emacs.)</p>
<p>Para construir este fichero <span class="file" >TAGS</span>, se puede ir al alto nivel de directorio de fuentes Emacs y ejecutar el comando de compilar <code>make tags</code>:</p>
<div class="example-block" >
<pre class="example" >M-x compile RET make tags RET
</pre>
</div>
<p>(El comando <code>make tags</code> trabaja bien con las fuentes de GNU Emacs, tan bien como con otros paquetes fuentes.)</p>
<p>Para más información, mira <q>Tablas de Etiquetas</q> en <em>El Manual GNU Emacs</em>.</p>
</div>
<h3 id="repaso" >Repaso</h3>
<div class="hBody-3" >
<p>Aquí hay un breve resumen de algunas funciones introducidas recientemente.</p>
<dl>
<dt><code>while</code></dt>
<dd>
<p>Repetidamente evalúa el cuerpo de la expresión tan larga como el primer elemento del cuerpo chequea cierto. Entonces devuelve <code>nil</code>. (La expresión es evaluado solo por sus efectos laterales.)</p>
<p>Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">foo</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">foo</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;foo is %d.\n&#34;</span> <span class="nv">foo</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">foo</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">foo</span><span class="p">))))</span>

     <span class="err">⇒</span>      <span class="nv">foo</span> <span class="nv">is</span> <span class="mi">2.</span>
             <span class="nv">foo</span> <span class="nv">is</span> <span class="mi">1.</span>
             <span class="no">nil</span>
</code></pre>
<p>(La función <code>insert</code> inserta sus argumentos en el punto; la función <code>format</code> devuelve una cadena formateada desde sus argumentos el camino <code>message</code> formatea sus argumentos; <code>\n</code> produce una nueva línea.)</p>
</dd>
<dt><code>re-search-forward</code></dt>
<dd>
<p>Busca un patrón, y si el patrón se encuentra, mueve el punto al resto solo después de eso.</p>
<p>Toma cuatro argumentos, como <code>search-forward</code>:</p>
<ol class="num" >
<li>
<p>Una expresión regular que especifica el patrón para buscarlo. (¡Recuerda por marcas de comillas alrededor de este argumento!)</p>
</li>
<li>
<p>Opcionalmente, el límite de la búsqueda.</p>
</li>
<li>
<p>Opcionalmente, que haces si la búsqueda falla, devuelve <code>nil</code> o un mensaje de error.</p>
</li>
<li>
<p>Opcionalmente, cuántas veces se puede repetir la búsqueda; si es negativa, la búsqueda va hacia atrás.</p>
</li>
</ol>
</dd>
<dt>let*</dt>
<dd>
<p>Asocia algunas variables localmente a valores particulares, y entonces evalúa los argumentos que permanencen, devolviendo el valor del último. Mientras se asocian las variables locales, se usan los valores locales de variables asociadas pronto, si acaso.</p>
<p>Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">foo</span> <span class="mi">7</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">bar</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">3</span> <span class="nv">foo</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;</span><span class="ss">`bar&#39;</span><span class="s"> is %d.&#34;</span> <span class="nv">bar</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="o">`</span><span class="nv">bar</span><span class="o">&#39;</span> <span class="nv">is</span> <span class="mi">21.</span>
</code></pre>
</dd>
<dt><code>match-beginning</code></dt>
<dd>
<p>Devuelve la posición del principio del texto encontrado por la última búsqueda de la expresión regular.</p>
</dd>
<dt><code>looking-at</code></dt>
<dd>
<p>Devuelve <code>t</code> para verdadero si el texto después del punto se asocia al argumento, que debería ser una expresión.</p>
</dd>
<dt><code>eobp</code></dt>
<dd>
<p>Devuelve <code>t</code> para cierto si el punto está en el fin de la parte accesible de un búfer. El fin de la parte accesible es el fin del búfer no está encogido; eso es el fin de la parte encogida si el búfer está encogido.</p>
</dd>
</dl>
</div>
<h3 id="ejercicios-con-re-search-forward" >Ejercicios con <code>re-search-forward</code></h3>
<div class="hBody-3" >
<ul>
<li>
<p>Escribe una función para buscar para una expresión que detecte dos o más líneas blancas en secuencia.</p>
</li>
<li>
<p>Escribe una función para buscar palabras duplicadas, tales como ‘el el’. Vea la Seccion <q>Sintaxis para Expresiones Regulares</q> en <em>El Manual de GNU Emacs</em>, para información de cómo escribir un regexp (una expresión regular) para asociar una cadena que se compone de dos mitades idénticas. Se puede disponer de varios regexps; algunos son mejores que otros. La función que se usa es descrito en un apéndice, a lo largo de varios regexps. Vea la Seccion <a href="the-the,-,-Función-de-Palabras-Duplicadas-the-the" >the-the, , Función de Palabras Duplicadas <code>the-the</code></a>.</p>
</li>
</ul>
</div>
<h2 id="contando:-repetición-y-regexps" >Contando: repetición y regexps</h2>
<div class="hBody-2" >
<p>La repetición y búsqueda de expresiones regulares son herramientas poderosas que con frecuencia se usan cuando se escribe código en Emacs Lisp. Este capítulo ilustra el uso de búsqueda de expresiones regulares a través de la construcción de comandos de contaje de palabras usando bucles <code>while</code> y recursión.</p>
<p>La distribución de Emacs estándar contiene una función para contar el número de líneas en una región.</p>
<p>Hay cierto tipo de pregunta escrita para contar palabras. De este modo, si se escribe un ensayo, puede limitarse a 800 palabras; si se escribe una novela, te puedes disciplinar a ti mismo a escribir 1000 palabras al día. Parece raro, pero durante mucho tiempo, a Emacs le faltó un comando para contar palabras. Quizás la gente usaba Emacs mayoritariamente para codificar o documentar cosas que no requieren contar palabras, o quizás se restringían al sistema operativo el comando de contar palabras, <code>wc</code>. De manera alternativa, la gente puede seguir la convención de las editoriales y computaban un contaje de palabras dividiendo el número de caracteres en un documento por cinco.</p>
<p>Hay mucho caminos para implementar un comando para contar palabras. Aquí hay algunos ejemplos, que pueden desear compararse con el comando de Emacs estándar, <code>count-words-region</code>.</p>
</div>
<h3 id="la-función-count-words-example" >La función <code>count-words-example</code></h3>
<div class="hBody-3" >
<p>Un comando de contar palabras podría contar palabras en una línea, párrafo, región, o búfer. ¿Qué comando funcionaría? Se podría diseñar el comando para contar el número de palabras en un búfer completo. Sin embargo, la tradición Emacs anima a la flexibilidad––se puede querer contar palabras solo en una sección, en vez de en todo un búfer. Así, tiene más sentido diseñar el comando para contar el número de palabras en una región. Una vez tienes un comando <code>count-words-region</code>, se puede, si desea, contar palabras en un búfer completo marcándolo con <kbd>C-x h</kbd> (<code>mark-whole-buffer</code>).</p>
<p>Claramente, contar palabras es un acto repetitivo: empezando desde el principio de la región, se cuenta la primera palabra, entonces la segunda palabra, entonces la tercera palabra, y así, hasta que logres el fin de la región. Esto significa que contar palabras se ajusta idealmente a recursión o a un bucle <code>while</code>.</p>
<p>Primero, implementaremos el comando de contar palabras con un bucle <code>while</code>, entonces con la recursión. El comando, de acuerdo, será interactivo.</p>
<p>La plantilla para una definición de función interactiva es, como siempre:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">@V{name-of-function}</span> <span class="p">(</span><span class="nv">@V{argument-list}</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nv">@V{interactive-expression}</span><span class="err">…</span><span class="p">)</span>
  <span class="nv">@V{body}</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Lo que necesitamos hacer es rellenar los slots.</p>
<p>El nombre de la función sería auto-explicativo y similar al nombre del <code>count-lines-region</code> existente. Esto hace que el nombre sea fácil de recordar. <code>count-words-region</code> es una buena elección. Puesto que el nombre se usa ahora para el comando de Emacs estándar para contar palabras, nosotros nombraremos nuestra implementación como <code>count-words-example</code>.</p>
<p>La función cuenta palabras con una región. Esto significa que el argumento lista debe contener símbolos que son asociados a las dos posiciones, el principio y fin de la región. Estas dos posiciones puede ser llamadas <samp>beginning</samp> y <samp>end</samp> respectivamente. La primera línea de la documentación sería una frase simple, desde que esto es todo lo que está impreso como documentación por un comando tal como <code>apropos</code>. La expresión interactiva será de la forma <samp>(interactive &#34;r&#34;)</samp>, puesto que causará que Emacs pase al principio y fin de la región a la lista de argumentos de función. Todo esto es rutina.</p>
<p>El cuerpo de la función necesita ser escrita para hacer tres tareas: primero, configurar condiciones bajo las que el bucle <code>while</code> pueda contar palabras, segundo, ejecutar el bucle <code>while</code>, y tercero, enviar un mensaje al usuario.</p>
<p>Cuando un usuario llama a <code>count-words-example</code>, apunta a que puede estar al principio o fin de la región. Sin embargo, el proceso de conteo debe empezar al principio de la región. Esto significa que querremos poner el punto que hay si eso no está allí. Ejecutando <code>(goto-char beginning)</code> asegura esto. De acuerdo, querremos devolver el punto a su posición esperada cuando la función finalice su trabajo. Por esta razón, el cuerpo debe ser encerrado en una expresión <code>save-excursion</code>.</p>
<p>La parte central del cuerpo de la función consiste en un bucle <code>while</code> en el que una expresión salta el punto hacia delante palabra por palabra, y otra expresión cuenta estos saltos. Si el test-verdadero-o-falso del bucle <code>while</code> es verdadero, el punto saltaría hacia adelante, y si es falso el punto estaría al fin de la región.</p>
<p>Nosotros podríamos usar <code>(forward-word 1)</code> como la expresión para mover el punto hacia adelante palabra por palabra, pero eso es fácil de ver que Emacs identifica como una ‘palabra’ si se usa una búsqueda de expresión regular.</p>
<p>Una expresión regular busca lo que encuentra el patrón que se está buscando deja el punto después del último carácter emparejado. Esto significa que una sucesión de palabras exitosas busquen que moverá el punto adelante palabra por palabra.</p>
<p>Como materia práctica, se quiere que la expresión regular se busque para saltar a través de un espacio en blanco y puntúe entre palabras tan bien a través de las palabras en sí. Una expresión regexp que rechaza para saltar a través de espacios en blanco entre palabras ¡nunca saltaría más de una palabra!. Esto significa que el regexp incluiría el espacio en blanco y la puntuación sigue a una palabra cualquiera, como la palabra en sí. (Una palabra puede finalizar un búfer y no tiene cualquier espacio en blanco o puntuación, así esta parte del regexp debe ser opcional.)</p>
<p>De este modo, queremos para el regexp es un patrón definiendo una o más palabras de caracteres que constituyen caracteres seguidos, opcionalmente, por uno o más caracteres que no son palabras constituyentes. La expresión regular para esto es:</p>
<div class="example-block" >
<pre class="example" >\w+\W*
</pre>
</div>
<p>La tabla de sintaxis del búfer determina qué caracteres son y no son palabras constituyentes. Para más información acerca de sintaxis, Vease Sección <q>Tablas de Sintaxis</q> <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
<p>La expresión se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span><span class="p">)</span>
</code></pre>
<p>(Note que las barras invertidas que preceden el <samp>w</samp> y <samp>W</samp>. Una barra invertida tiene significado especial al intérprete Emacs Lisp. Eso indica que el caracter siguiente es interpretado de manera diferente que la normal. Por ejemplo, los dos caracteres, <samp>\n</samp>, son una <samp>nueva línea</samp>, en vez de una barra invertida seguida por <samp>\n</samp>. Dos barras invertidas en una fila para una ‘barra invertida no especial’, así Emacs Lisp interpreta el fin de mirar una barra invertida simple seguida por una letra. Así descubre la letra que es especial.)</p>
<p>Se necesita un contador para contar cuántas palabras hay; esta variables debe primero ser asignado a 0 y entonces incrementados cada vez que Emacs va alrededor del bucle <code>while</code>. La expresión de incremento es simple:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">count</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">count</span><span class="p">))</span>
</code></pre>
<p>Finalmente, se quiere contar al usuario cuántas palabras hay en la región. La función <code>message</code> presenta este tipo de información al usuario. El mensaje tiene que ser fraseado de manera que se lea apropiadamente sin cuidado de cuantas palabras hay en la región: no se quiere decir que “hay una palabra en la región”. El conflicto entre singular y plural no es gramatical. Se puede resolver este problema usando una expresión condicional que evalúa diferentes mensajes dependiendo en el número de palabras en la región. Hay tres posibilidades: no palabras en la región, una palabra en la región, y más de una palabra. Esto significa que la forma especial <code>cond</code> es apropiada.</p>
<p>Todo esto lidera a la siguiente definición de función:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; ¡La Primera versión; tiene errores!</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-region</span> <span class="p">(</span><span class="nv">beginning</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Imprime el número de palabras en la región.
</span><span class="s">Las palabras están definidas al menos una palabra
</span><span class="s">constituida de caracteres seguido por al menos un
</span><span class="s">caracter que no constituye palabra. La tabla de
</span><span class="s">sintaxis del búfer determina qué caracteres hay.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palaras en la región ... &#34;</span><span class="p">)</span>

<span class="c1">;;; 1. Configurar condiciones apropiadas.</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">beginning</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">count</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;;; @e{2. Ejecutar el} @e{bucle} while.</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">end</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">count</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">count</span><span class="p">)))</span>

<span class="c1">;;; 3. Enviar un mensaje al usuario.</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">count</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región no tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">count</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">count</span><span class="p">))))))</span>
</code></pre>
<p>Como se escribe, la función funciona, pero no en todas las circunstancias.</p>
</div>
<h4 id="el-error-de-espacio-en-blanco-en-count-words-example" >El error de espacio en blanco en <code>count-words-example</code></h4>
<div class="hBody-4" >
<p>El comando <code>count-words-example</code> descrito en la sección precedente tiene dos errores, o incluso, un error con dos manifestaciones. Primero, si se marca una región conteniendo solo espacio en blanco en el medio de algún texto el comando ¡<code>count-words-example</code> cuenta que la región contiene una palabra!. Segundo, si se marca una región conteniendo solo espacios en blanco al final del búfer o la porción accesible de un búfer encogido, el comando muestra un mensaje de error que se parece a esto:</p>
<div class="example-block" >
<pre class="example" >Búsqueda fallida: &#34;\\w+\\W*&#34;
</pre>
</div>
<p>Si está leyendo esto en Info en GNU Emacs, se puede testear para estos errores por sí mismo.</p>
<p>Primero, evalúa la función de la manera usual para instalarlo.</p>
<p>Si se desea, se puede también instalar este atajo para ser evaluado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-c=&#34;</span> <span class="ss">&#39;count-words-example</span><span class="p">)</span>
</code></pre>
<p>Para conducir el primer test, asigna marca y punto al principio y fin de la siguiente línea y entonces escribe <kbd>C-c =</kbd> (o <kbd>M-x count-words-example</kbd> si no se ha asignado <kbd>C-c =</kbd>):</p>
<div class="example-block" >
<pre class="example" >    uno   dos  tres
</pre>
</div>
<p>Emacs te contará, correctamente, que la región tiene tres palabras.</p>
<p>Repite el test, pero marca el lugar al principio de la línea y emplaza el punto justo <em>antes</em> de la palabra <samp>uno</samp>. De nuevo escribe el comando <kbd>C-c =</kbd> (o <kbd>M-x count-words-example</kbd>). Emacs cuenta que la región no tiene palabras, puesto que eso está compuesto solo por espacios en blanco al principio de la línea. ¡Pero en vez de que Emacs cuente que la región tiene una palabra!</p>
<p>Para el tercer test, copia la línea de ejemplo al fin del búfer <span class="file" >*scratch*</span> y entonces escribe varios espacios al fin de la línea. Posiciona la marca correcta después de la palabra <samp>tres</samp> y apunta al fin de la línea. (El fin de la línea será el fin del búfer.) Escribe <kbd>C-c =</kbd> (o <kbd>M-x count-words-example</kbd>) como se hizo antes. De nuevo, Emacs te contaría que la región no tiene palabras, puesto que eso está compuesto solo de los espacios en blanco al fin de la línea. En vez de eso, Emacs muestra un mensaje de error diciendo <samp>Búsqueda fallida</samp>.</p>
<p>Los dos errores queman el mismo problema.</p>
<p>Considere la primera manifestación del error, en el que el comando te cuenta que el espacio en blanco al principio de la línea contiene una palabra. Lo que ocurre es esto: El comando <code>M-x count-words-example</code> mueve el punto al principio de la región. El test <code>while</code> si el valor del punto es más pequeño de lo que el valor de <code>end</code>, que es. Por consiguiente, en la expresión regular se busca y encuentra la primera palabra. Eso deja el punto después de la palabra. <code>count</code> que se establece a uno. El bucle <code>while</code> repite; pero esta vez el valor del punto es más largo que el valor de <code>end</code>, el bucle sale; y la función muestra un mensaje diciendo el número de palabras en la región es uno. En breve, la expresión regular busca y encuentra la palabra incluso aunque eso esté fuera de la región marcada.</p>
<p>En la segunda manifestación del error, la región es un espacio en blanco al fin del búfer. Emacs dice <samp>Búsqueda fallida</samp>. Lo que ocurre es que true-or-false-test en el bucle <code>while</code> chequea verdad, así la expresión de búsqueda es ejecutada. Pero desde que no hay más palabras en el buffer, la búsqueda falla.</p>
<p>En ambas manifestaciones del error, la búsqueda extiende o intenta extenderse fuera de la región.</p>
<p>La solución es limitar la búsqueda a la región––esto es una acción simple y limpia, pero como tu puedes tener que llegar a esperar, eso no es tan simple como se podría pensar.</p>
<p>Como se ha visto, la función <code>re-search-forward</code> toma un patrón de búsqueda como su primer argumento. Pero además de este primer, argumento obligatorio, se aceptan tres argumentos opcionales. El segundo argumento opcional asocia la búsqueda. El tercer argumento opcional, si <code>t</code>, causa la función a devolver <code>nil</code> en vez de la señal un error si la búsqueda falla. El cuarto argumento opcional es un contador repetido. (En Emacs, se puede ver una documentación de la función escribiendo <kbd>C-h f</kbd>, el nombre de la función, y entonces <kbd>RET</kbd>.)</p>
<p>En la definición <code>count-words-example</code>, el valor del fin de la región es tomada por la variable <code>end</code> que es pasada como un argumento para la función. De este modo, se puede añadir <code>end</code> como un argumento para la búsqueda de la expresión de búsqueda:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">fin</span><span class="p">)</span>
</code></pre>
<p>Sin embargo, si se crea solo este cambio a la definición <code>count-words-example</code> y entonces se chequea la nueva versión de la definición en una extensión de espacio en blanco, se recibirá un mensaje de error diciendo <samp>Búsqueda fallida</samp>.</p>
<p>Lo que ocurre es esto: la búsqueda se limita a la región, y falla como se espera porque no hay caracteres de palabras constituyentes en la región. Puesto que eso falla, se recibe un mensaje de error. Pero no queremos recibir un mensaje de error en este caso; se quiere recibir el mensaje que &#34;La región no tiene palabras&#34;.</p>
<p>La solución a este problema es proveer <code>re-search-forward</code> con un tercer argumento de <code>t</code>, que causa la función para devolver <code>nil</code> en vez la señalar un error si la búsqueda falla.</p>
<p>Sin embargo, si se crea este cambio y se intenta, se verá el mensaje “Contando palabras en la región ...” y … se guardará viendo qué mensaje …, hasta que se escribe <kbd>C-g</kbd> (<code>keyboard-quit</code>).</p>
<p>Aquí está lo que ocurre: la búsqueda está limitada a la región, como antes, y eso falla porque no hay caracteres no constituyentes de palabras en la región, como se espera. Por tanto, la expresión <code>re-search-forward</code> devuelve <code>nil</code>. Eso no hace nada más. En particular, no mueve el punto, que hace como un efecto secundario si se encuentra la búsqueda objetiva. Después la expresión <code>re-search-forward</code> devuelve <code>nil</code>, la siguiente expresión en el bucle <code>while</code> está evaluado. Esta expresión incrementa el contador. Entonces el bucle repite. El test true-or-false-test chequea cierto porque el valor del punto es todavía menor que el valor final, desde que la expresión <code>re-search-forward</code> no movería el punto. … y el ciclo repite …</p>
<p>La definición <code>count-words-example</code> requiere todavía de otra modificación para causar el true-or-false-test del bucle <code>while</code> para chequear falso si la búsqueda falla. Pon otro camino, hay dos condiciones que deben ser satisfechas en el true-or-false-test antes que el contador de palabras variable se incremente: el punto debe todavía estar con la región y la expresión de búsqueda debe haber encontrado una palabra para contar.</p>
<p>Por ambas la primera condición y la segunda condición deben ser ciertas juntas, las dos expresiones, la región chequea y la expresión de búsqueda, puede estar unido con una forma especial <code>and</code> y embebido en el bucle <code>while</code> como el true-or-false-test, como esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">end</span><span class="p">)</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">end</span> <span class="no">t</span><span class="p">))</span>
</code></pre>
<p>(Para información acerca de <code>and</code>, ver <q>La función <code>kill-new</code></q>.)</p>
<p>La expresión <code>re-search-forward</code> devuelve <code>t</code> si la búsqueda es exitosa y como efecto secundario se mueve el punto. Consiguientemente, como las palabras se encuentran, el punto es movido a través de la región. Cuando la búsqueda de la expresión falla para encontrar otra palabra, o cuando el punto logra el fin de la región, el test true-or-false-test es falso, el bucle <code>while</code> existe, y la función <code>count-words-example</code> muestra uno u otro de sus mensajes.</p>
<p>Después de incorporar estos cambios finales, el <code>count-words-example</code> funciona sin errores (¡o al menos, sin los errores que yo haya encontrado!. Aquí está lo que parece:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; @e{Versión final:} @c{while}</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">beginning</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Imprime número de palabras en la región.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palabras en la región ... &#34;</span><span class="p">)</span>

<span class="c1">;;; 1. Configura condiciones apropiadas.</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">count</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">beginning</span><span class="p">)</span>

<span class="c1">;;; @e{2. Ejecuta el} @e{bucle} while</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">end</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nv">end</span> <span class="no">t</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">count</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">count</span><span class="p">)))</span>

<span class="c1">;;; 3. Enviar un mensaje al usuario.</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">count</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región no tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">count</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">count</span><span class="p">))))))</span>
</code></pre>
</div>
<h3 id="cuenta-palabras-recursivamente" >Cuenta palabras recursivamente</h3>
<div class="hBody-3" >
<p>Se puede escribir la función para contar palabras tanto de manera recursiva como con un bucle <code>while</code>. Permita ver cómo se hace.</p>
<p>Primero, se necesita reconocer que la función <code>count-words-example</code> tiene tres trabajos: eso configura las condiciones apropiadas para contar lo que ocurre; eso cuenta las palabras en la región; y envía un mensaje al usuario contando cuántas palabras hay.</p>
<p>Si se escribe una función recursiva simple para hacer cualquier cosa se recibirá un mensaje para cada llamada recursiva. Si la región contiene 13 palabras, se recibirán trece mensajes, uno correcto después del otro. ¡No queremos esto!. En vez de eso, se deben escribir dos funciones para hacer el trabajo, una (la función recursiva) será usada dentro de la otra. Una función configurará las condiciones y muestra el mensaje; la otra devolverá el contador de palabras.</p>
<p>Permítase comenzar con la función que causa el mensaje que se muestra. Se puede continuar por llamarse <code>count-words-example</code>.</p>
<p>Esta es la función que el usuario llama. Será interactiva. En realidad, será similar a nuestras versiones previas de esta función, excepto que llamará <code>recursive-count-words</code> para determinar cuántas palabras hay en la región.</p>
<p>Se puede construir una plantilla legible para esta función, basada en versiones previas:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Versión Recursiva; usa la búsqueda de la expresión regular</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">beginning</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nv">@V{interactive-expression}</span><span class="err">…</span><span class="p">)</span>

<span class="c1">;;; 1. Configura condiciones apropiadas.</span>
  <span class="p">(</span><span class="nv">@V{explanatory</span> <span class="nv">message}</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">@V{set-up</span> <span class="nv">functions}</span><span class="err">…</span>

<span class="c1">;;; 2. Contar las palabras.</span>
    <span class="nv">@V{recursive</span> <span class="nv">call}</span>

<span class="c1">;;; 3. Envía un mensaje al usuario.</span>
    <span class="nv">@V{message</span> <span class="nv">providing</span> <span class="nv">word</span> <span class="nv">count}</span><span class="p">))</span>
</code></pre>
<p>La definición parece sencilla, excepto que como el contador devuelve la llamada recursiva que debe ser pasada al mensaje mostrando el contaje de palabras. Un pequeño pensamiento sugiere que esto puede ser hecho haciendo uso de una expresión <code>let</code> al número de palabras en la región, como se devuelve por la llamada recursiva; y entonces la expresión <code>cond</code>, que usa la asociación, puede mostrar el valor al usuario.</p>
<p>Con frecuencia, uno piensa que se puede asociar una expresión <code>let</code> como algo secundario al trabajo ‘primario’ de una función. Pero en este caso, se podría considerar el trabajo ‘primario’ de la función, contando palabras, esto es hecho con la expresión <code>let</code>.</p>
<p>Usando <code>let</code>, la definición de función se parece a:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">beginning</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Imprime el número de palabras en la región.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;r&#34;</span><span class="p">)</span>

<span class="c1">;;; 1. Configura condiciones apropiadas.</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Contando palabras en la región ... &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">beginning</span><span class="p">)</span>

<span class="c1">;;; 2. Contar las palabras.</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">count</span> <span class="p">(</span><span class="nv">recursive-count-words</span> <span class="nv">end</span><span class="p">)))</span>

<span class="c1">;;; 3. Enviar un mensaje al usuario.</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">zerop</span> <span class="nv">count</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región no tiene palabras.&#34;</span><span class="p">))</span>
            <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">count</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene 1 palabra.&#34;</span><span class="p">))</span>
            <span class="p">(</span><span class="no">t</span>
             <span class="p">(</span><span class="nf">message</span>
              <span class="s">&#34;La región tiene %d palabras.&#34;</span> <span class="nv">count</span><span class="p">))))))</span>
</code></pre>
<p>Lo siguiente, que se necesita es escribir la función de contaje recursivo.</p>
<p>Una función recursiva tiene al menos tres partes: el ‘do-again-test’, la ‘next-step-expression’, y la llamada recursiva.</p>
<p>El do-again-test determina si la función será o no llamada de nuevo. Puesto que estamos contando palabras en una región y puede causar que una función se mueva el punto hacia delante por cada palabra, el do-again-test puede chequear si el punto está todavía con la región. El do-again-test encontraría el valor del punto y determina si el punto está antes, en, o después del valor del fin de la región. Se puede usar la función <code>point</code> para localizar el punto. Claramente, se debe pasar el valor del fin de la región a la función de contaje recursivo como un argumento.</p>
<p>Además, el do-again-test también chequea si la búsqueda encuentra una palabra. Si no, la función no se llamaría de nuevo.</p>
<p>La next-step-expression cambia un valor así que cuando la función recursiva se supone que debe parar de llamarse así misma, se para. Más precisamente, los cambios de next-step-expression cambia un valor así en el momento adecuado, el do-again-test para la función recursiva de la llamada en sí de nuevo. En este caso, la next-step-expression puede ser la expresión que mueve el punto hacia adelante, palabra por palabra.</p>
<p>La tercera parte de una función recursiva es la llamada recursiva.</p>
<p>En algún lugar, también, se necesita una parte que hace el ‘trabajo’ de la función, una parte que es el contaje. ¡Una parte vital!</p>
<p>Pero ya, tenemos un guión de la función recursiva de contaje:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">recursive-count-words</span> <span class="p">(</span><span class="nf">region-end</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
   <span class="nv">@V{do-again-test}</span>
   <span class="nv">@V{next-step-expression}</span>
   <span class="nv">@V{recursive</span> <span class="nv">call}</span><span class="p">)</span>
</code></pre>
<p>Ahora se necesita rellenar los slots. Permite comenzar con el caso más simple primero: si se apunta debajo del fin de la región, no puede haber palabras en la región, así la función devuelve cero. De otro modo, si la búsqueda falla no hay palabras para contar, así la función devolvería cero.</p>
<p>Por otro lado, si se apunta con la región y la búsqueda tiene éxito, la función se llamaría de nuevo.</p>
<p>De este modo, do-again-test se vería así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nf">region-end</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nf">region-end</span> <span class="no">t</span><span class="p">))</span>
</code></pre>
<p>Note que la expresión de búsqueda es parte del do-again-test --- la función devuelve <code>t</code> si su búsqueda tiene éxito y <code>nil</code> si falla. (Vea la Seccion <a href="Error-de-espacio-en-blanco,-,-El-Error-de-Espacio-en-Blanco-en-count-words-example" >Error de espacio en blanco, , El Error de Espacio en Blanco en <code>count-words-example</code></a>), para una explicación de cómo <code>re-search-forward</code> funciona.)</p>
<p>El do-again-test es el test true-or-false de una cláusula <code>if</code>. Claramente si el do-again-test tiene éxito, la then-part de la cláusula <code>if</code> llamaría a la función; pero si eso falla, la else-part devolvería cero desde que el punto está fuera de la región o la búsqueda falló porque no había palabras a encontrar.</p>
<p>Pero antes de considerar la llamada recursiva, se necesita considerar la next-step-expression. ¿Qué es eso? De manera interesante, eso es la parte de la búsqueda del do-again-test.</p>
<p>Además para devolver <code>t</code> o <code>nil</code> para el do-again-test, <code>re-search-forward</code> mueve el punto hacia adelante como un efecto secundario de una búsqueda exitosa. Esta es la acción que cambia el valor de punto así que la función recursiva para de llamarse a sí misma cuando el punto complete su movimiento a través de la región. Por consiguiente, la expresión <code>re-search-forward</code> es la next-step-expression.</p>
<p>En esquema, entonces, el cuerpo de la función <code>recursive-count-words</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="nv">@V{do-again-test-and-next-step-combined}</span>
    <span class="c1">;; then</span>
    <span class="nv">@V{recursive-call-returning-count}</span>
  <span class="c1">;; else</span>
  <span class="nv">@V{return-zero}</span><span class="p">)</span>
</code></pre>
<p>¿Cómo incorporar el mecanismo que cuenta?</p>
<p>Si no estás acostumbrado a escribir funciones recursivas, una pregunta como esta puede ser un problema. Pero eso puede y sería enfocado sistemáticamente.</p>
<p>Se sabe que el mecanismo de contaje sería asociado en algún lugar con la llamada recursiva. En vez de eso, desde que la next-step-expression mueve el punto hacia adelante por una palabra, y desde que una llamada recursiva es hecha para cada palabra, el mecanismo de contaje debe ser una expresión que añade uno al valor devuelto por una llamada para <code>recursive-count-words</code></p>
<p>Considera varias casos:</p>
<ul>
<li>
<p>Si hay dos palabras en la región, la función devolverá un valor resultante de añadir uno al valor devuelto al contar la primera palabra, más el número devuelto al contar las palabras que permanecen en la región, que en este caso es una.</p>
</li>
<li>
<p>Si hay una palabra en la región, la función devolvería un valor resultante de añadir uno al valor devuelto cuando eso cuenta esta palabra más el número devuelto cuando eso cuenta las palabras que permanecen en la región, que en este caso es cero.</p>
</li>
<li>
<p>Si no hay palabras en la región, la función devolvería cero.</p>
</li>
</ul>
<p>Desde el esquema se puede ver que la parte else del <code>if</code> devuelve cero para el caso en el que no hay palabras. Esto significa que la parte then del <code>if</code> debe devolver un valor resultante de añadir uno al valor devuelto desde el contaje de las palabras que permanecen.</p>
<p>La expresión se parece a esto, donde <code>1+</code> es una función que añade uno a su argumento.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">recursive-count-words</span> <span class="nf">region-end</span><span class="p">))</span>
</code></pre>
<p>La función completa <code>recursive-count-words</code> entonces se parecerá e esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">recursive-count-words</span> <span class="p">(</span><span class="nf">region-end</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>

<span class="c1">;;; 1. do-again-test</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nf">region-end</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nf">region-end</span> <span class="no">t</span><span class="p">))</span>

<span class="c1">;;; 2. then-part: la llamada recursiva</span>
      <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">recursive-count-words</span> <span class="nf">region-end</span><span class="p">))</span>

<span class="c1">;;; 3. else-part</span>
    <span class="mi">0</span><span class="p">))</span>
</code></pre>
<p>Permíteme examinar cómo esto funciona:</p>
<p>Si no hay palabras en la región, la parte else de la expresión <code>if</code> es evaluada y, por tanto, la función devuelve cero.</p>
<p>Si hay una palabra en la región, el valor del punto es menor que el valor de <code>region-end</code> y la búsqueda tiene éxito. En este caso, el true-or-false-test de la expresión <code>if</code> chequea cierto, y la then-part de la expresión <code>if</code> es evaluada. La expresión de contaje se evalúa. Esta expresión devuelve un valor (que será el valor devuelto por la función completa) que es la suma de uno añadida al valor devuelto por una llamada recursiva.</p>
<p>Mientras tanto, la next-step-expression ha causado el punto para saltar a través de la primera (y en este caso única) palabra en la región. Esto significa que cuando <code>(recursive-count-words region-end)</code> está evaluada una segunda vez, como un resultado de la llamada recursiva, el valor del punto será igual o mayor que el valor de la región final. Así esta vez, <code>recursive-count-words</code> devolverá cero. El cero será añadido a uno, y la evaluación original de <code>recursive-count-words</code> devolverá uno más cero (uno) que es la cantidad correcta.</p>
<p>Claramente, si hay dos palabras en la región, la primera llamada a <code>recursive-count-words</code> devuelve uno que se añade al valor devuelto por el siguiente <code>recursive-count-words</code> en una región donde está la palabra que permanece––que es, eso añadir uno a uno, produciendo dos, que es la cantidad correcta.</p>
<p>Similarmente, si hay tres palabras en la región, la primera llamada <code>recursive-count-words</code> devuelve uno añadido al valor devuelto llamado <code>recursive-count-words</code> en una región conteniendo las dos palabras que faltan––y así.</p>
<p>Con documentación completa las dos funciones se parecen a esto:</p>
<p>La función recursiva:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">recursive-count-words</span> <span class="p">(</span><span class="nf">region-end</span><span class="p">)</span>
  <span class="s">&#34;Número de palabras entre punto y REGION-END.&#34;</span>

<span class="c1">;;; 1. do-again-test</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nf">region-end</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;\\w+\\W*&#34;</span> <span class="nf">region-end</span> <span class="no">t</span><span class="p">))</span>

<span class="c1">;;; 2. then-part: la llamada recursiva</span>
      <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nv">recursive-count-words</span> <span class="nf">region-end</span><span class="p">))</span>

<span class="c1">;;; 3. else-part</span>
    <span class="mi">0</span><span class="p">))</span>
</code></pre>
<p>El envoltorio:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Recursiva</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-example</span> <span class="p">(</span><span class="nv">beginning</span> <span class="nv">end</span><span class="p">)</span>
  <span class="s">&#34;Imprime el número de palabras en la región.
</span><span class="s">
</span><span class="s">Las palabras son definidas como al menos una palabra constituyente
</span><span class="s">seguida por al menos un caracter que es una palabra constituyente. La
</span><span class="s">tabla de sintaxis del buffer determina qué caracter hay.
</span><span class="s">  (interactive &#34;</span><span class="nv">r</span><span class="s">&#34;)
</span><span class="s">  (message &#34;</span><span class="nv">Contando</span> <span class="nv">palabras</span> <span class="nv">en</span> <span class="nv">la</span> <span class="nv">región</span> <span class="o">...</span> <span class="s">&#34;)
</span><span class="s">  (save-excursion
</span><span class="s">    (goto-char beginning)
</span><span class="s">    (let ((count (recursive-count-words end)))
</span><span class="s">      (cond ((zerop count)
</span><span class="s">             (message
</span><span class="s">              &#34;</span><span class="nv">La</span> <span class="nv">región</span> <span class="nv">no</span> <span class="nv">tiene</span> <span class="nv">palabras.</span><span class="s">&#34;))
</span><span class="s">            ((= 1 count)
</span><span class="s">             (message &#34;</span><span class="nv">La</span> <span class="nv">región</span> <span class="nv">tiene</span> <span class="mi">1</span> <span class="nv">palabra.</span><span class="s">&#34;))
</span><span class="s">            (t
</span><span class="s">             (message
</span><span class="s">              &#34;</span><span class="nv">La</span> <span class="nv">región</span> <span class="nv">tiene</span> <span class="nv">%d</span> <span class="nv">palabras.</span><span class="s">&#34; count))))))
</span><span class="s"></span></code></pre>
</div>
<h3 id="ejercicio:-contando-puntuación" >Ejercicio: contando puntuación</h3>
<div class="hBody-3" >
<p>Usando un bucle <code>while</code>, escriba una función para contar el número de marcas de puntuación en una región––periodo, coma, punto y coma, dos puntos, exclamación, marca y marca de pregunta. Haga lo mismo usando recursión.</p>
</div>
<h2 id="contando-palabras-en-una-defun" >Contando palabras en una <code>defun</code></h2>
<div class="hBody-2" >
<p>El siguiente proyecto es contar el número de palabras en una definición de función. Claramente, esto se puede hacer usando alguna variante de <code>count-words-example</code>. Vea la Seccion <a href="Contando-palabras,-,-Contando-palabras:-repetición-y-regexps" >Contando palabras, , Contando palabras: repetición y regexps</a>. Si se está ahora yendo a contar las palabras en una definición, es suficientemente fácil marcar la definición con el comando <kbd>C-M-h</kbd> (<code>mark-defun</code>), y entonces se llama a <code>count-words-example</code>.</p>
<p>Sin embargo, soy más ambicioso: Yo quiero contar las palabras y símbolos en cada definición en las fuentes de Emacs y entonces imprimir un grafo que muestre cuántas funciones hay de cada tamaño: cuántas contienen de 40 a 49 palabras o símbolos, cuántas contienen de 50 a 59 palabras o símbolos, y así. Yo he sido con frecuencia curioso de cómo es una función típica, y esto se contará.</p>
<p>Descrito en una frase, el proyecto desanima; pero dividido dentro de numerosos pequeños pasos, cada uno de los que podemos tomar en un momento, el proyecto llegar ser menos atemorizante. Permítenos considerar qué pasos deben ser:</p>
<ul>
<li>
<p>Primero, escribe una función para contar las palabras en una definición. Esto incluye el problema de manejar símbolos tan bien como palabras.</p>
</li>
<li>
<p>Segundo, escribe una función para listar los números de palabras en cada función en un fichero. Esta función puede usar la función <code>count-words-in-defun</code>.</p>
</li>
<li>
<p>Tercero, escribe una función para listar los números de palabras en cada función en cada uno de varios ficheros. Esto encola automáticamente encontrando varios ficheros, cambiándolos, y contando las palabras en las definiciones con ellos.</p>
</li>
<li>
<p>Cuarto, escribe una función para convertir la lista de números que nosotros creamos en tres pasos para un formulario que se ajustará para imprimir un grafo.</p>
</li>
<li>
<p>Quinto, escribe una función para imprimir los resultados como un grafo.</p>
</li>
</ul>
<p>¡Esto es un proyecto! Pero si tomamos cada paso lentamente, eso no será difícil.</p>
</div>
<h3 id="¿qué-contar?" >¿Qué contar?</h3>
<div class="hBody-3" >
<p>Cuando nosotros primero empezamos pensando acerca del contaje de palabras en una definición de función, la primera pregunta es (o podría ser) ¿qué se va a contar?  Cuando se habla de ‘palabras’ con repecto a una definición de función Lisp, estamos actualmente hablando, en parte, de ‘símbolos’. Por ejemplo, la siguiente función <code>multiply-by-seven</code> contiene los cinco símbolos <code>defun</code>, <code>multipy-by-seven</code>, <code>number</code>, <code>*</code>, y <code>7</code>. Además, en la cadena de documentación, contiene cuatro palabras <samp>Multiplicar</samp>, <samp>NUMBER</samp>, <samp>por</samp>, y <samp>siete</samp>. El símbolo <samp>número</samp> es repetido, así la definición contiene un total de diez palabras y símbolos.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiply-by-seven</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Multiplicar NUMBER por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">number</span><span class="p">))</span>
</code></pre>
<p>Sin embargo, si se marca la definición <code>multiply-by-seven</code> con <kbd>C-M-h</kbd> (<code>mark-defun</code>), y entonces se llama a <code>count-words-example</code> dentro, se encontrará que <code>count-words-example</code> ¡reclama la definición tiene once palabras, no diez! ¡Alguna cosa está mal!</p>
<p>El problema es doble: <code>count-words-example</code> no cuenta el <samp>*</samp> como una palabra, y eso cuenta el símbolo simple, <code>multiply-by-seven</code>, conteniendo tres palabras. Las conexiones son tratadas como si fueran espacios entre palabras en vez de conectores entre palabras <samp>multiply-by-seven</samp> se cuenta como si fuese escrito <samp>multiply-by-seven</samp>.</p>
<p>La causa de esta confusión es la expresión regular que busca la definición <code>count-words-example</code> que mueve el punto hacia delante palabra por palabra. En la versión canónica de <code>count-words-example</code>, el regexp es:</p>
<div class="example-block" >
<pre class="example" >&#34;\\w+\\W*&#34;
</pre>
</div>
<p>Esta expresión regular es un patrón definiendo una o más palabras constituyendo caracteres posiblemente seguidos por uno o más caracteres que no son palabras constituyentes. Esto significa que los ‘caracteres que constituyen palabras’ nos traen la cuestión de la sintaxis, que es el valor de una sección en sí.</p>
</div>
<h3 id="¿qué-constituye-una-palabra-o-símbolo?" >¿Qué constituye una palabra o símbolo?</h3>
<div class="hBody-3" >
<p>Emacs trata diferentes caracteres perteneciendo a diferentes <dfn>categorías de sintaxis</dfn>. Por ejemplo, la expresión regular, <samp>\\w+</samp>, es un patrón especificando uno o más caracteres de <em>palabras constituyentes</em>. Los caracteres de palabras constituyentes son miembros de una categoría de sintaxis. Otras categoría de sintaxis incluye la clase de caracteres de puntuación, tales como el espacio en blanco o el caracter de tabulación. (Para más información, ver Seccion <q>La Tabla de Sintaxis</q> en <em>El Manual GNU Emacs</em>, y Seccion <q>Tablas de Sintaxis</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p>Las tablas de sintaxis especifican qué caracteres pertenecen a qué categorías. Normalmente un guión no está especificado como un ‘caracter constituido por una palabra’. En vez de eso, se especificó como estando en la ‘clase de caracteres que son parte de los nombres de símbolos, pero no las palabras.’  Esto significa que la función <code>count-words-example</code> se trata del mismo modo que trata un espacio en blanco entre palabras, que es el por qué <code>count-words-example</code> cuenta <samp>multiply-by-seven</samp> como tres palabras.</p>
<p>Hay dos caminos para causar que Emacs cuente <samp>multiply-by-seven</samp> como un símbolo: modificar la tabla de sintaxis o modificar la expresión regular.</p>
<p>Se podría redefinir un guión (<em>hyphen</em>) como un caracter que constituye una palabra modificando la tabla de sintaxis que Emacs guarda por cada modo. Esta acción serviría nuestro propósito, excepto que una conexión es meramente el caracter más común con símbolos que no son típicamente un caracter de palabra constituyente; hay otros, también.</p>
<p>Alternativamente, se puede redefinir la expresión regular <em>regexp</em> usada en la definición <code>count-words</code> así como incluir símbolos. Este procedimiento tiene el mérito de la claridad, pero la tarea es un pequeño truco.</p>
<p>La primera parte es suficientemente simple: el patrón debe asignarse “al menos un carácter que es una palabra o símbolo constituyente”. De este modo:</p>
<div class="example-block" >
<pre class="example" >&#34;\\(\\w\\|\\s_\\)+&#34;
</pre>
</div>
<p>El <samp>\\(</samp> es la primera parte del constructo que agrupa esto que incluye el <samp>\\w</samp> y el <samp>\\s_</samp> como alternativas, separadas por los <samp>\\|</samp>. El <samp>\\w</samp> asocia cualquier caracter de palabra constituyente y el <samp>\\s_</samp> asocia cualquier caracter que es parte de un nombre de símbolo pero no una palabra de caracteres constituyente. El <samp>+</samp> sigue al grupo que indica que la palabra o símbolo constituyan caracteres que deben ser asociados al menos por uno.</p>
<p>Sin embargo, la segunda parte de regexp es más difícil de diseñar. Lo que queremos es seguir la primera parte con “opcionalmente uno o más caracteres que no constituyen una palabra o símbolo”. Primero, se pensaba que se podría definir esto con lo siguiente:</p>
<div class="example-block" >
<pre class="example" >&#34;\\(\\W\\|\\S_\\)*&#34;
</pre>
</div>
<p>Las mayúsculas <samp>W</samp> y <samp>S</samp> asocian caracteres que <em>no</em> son constituyente de palabra o símbolo. Desafortunadamente, esta expresión asocia cualquier caracter que sea o no una palabra constituyente no un símbolo constituyente. ¡Esto asocia cualquier caracter!</p>
<p>Entonces se notificó que cada palabra o símbolo en mi región test fué seguida por algún espacio (espacio en blanco, tabulador, o nueva línea). Así yo intenté emplazar un patrón para asociar uno o más espacios en blanco después del patrón para una o más palabras o símbolos constituyentes. Esto falló, también. Palabras y símbolos son con frecuencia separados por espacios en blanco, pero en el código actual los paréntesis pueden seguir símbolos y puntuación puede seguir las palabras. Así finalmente, se diseño un patrón en el que la palabra o símbolo constituyente es seguido opcionalmente por caracteres que no son espacios en blanco y entonces son seguidos opcionalmente por espacios en blanco.</p>
<p>Aquí está la expresión regular completa:</p>
<div class="example-block" >
<pre class="example" >&#34;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&#34;
</pre>
</div>
</div>
<h3 id="la-función-count-words-in-defun" >La función <code>count-words-in-defun</code></h3>
<div class="hBody-3" >
<p>Se ha visto que hay varios caminos para escribir una función <code>count-word-region</code>. Para escribir un <code>count-words-in-defun</code>, se necesita solamente adaptar una de estas versiones.</p>
<p>La versión que usa un bucle <code>while</code> es fácil de comprender, así estoy yendo a adaptar esto. Porque <code>count-words-in-defun</code> será parte de un programa más complejo, eso no necesita ser interactivo y no necesita mostrar un mensaje pero solo devuelve el contaje. Estas consideraciones simplifican la definición un poco.</p>
<p>Por otro lado, <code>count-words-in-defun</code> será usado con un buffer que contiene definiciones de función. Consiguientemente, es razonable preguntar que la función determina si se llamó cuando el punto está con una definición de función, y eso es, para devolver el contaje para esta definición. Esto añade complejidad a la definición, pero nos guarda desde la necesidad de pasar argumentos a la función.</p>
<p>Estas consideraciones nos llevan a preparar la siguiente plantilla:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-in-defun</span> <span class="p">()</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nv">@V{set</span> <span class="nv">up}</span><span class="err">…</span>
     <span class="p">(</span><span class="nv">@V{while</span> <span class="nv">loop}</span><span class="err">…</span><span class="p">)</span>
   <span class="nv">@V{return</span> <span class="nv">count}</span><span class="p">)</span>
</code></pre>
<p>Así, el trabajo es rellenar los slots.</p>
<p>Primero, la configuración.</p>
<p>Estamos presuponiendo que esta función será llamada con un búfer conteniendo definiciones de función. Apunta si será con una definición de función o no. Para que <code>count-words-in-defun</code> funcione, el punto debe moverse al principio de la definición, un contador debe empezar a cero, y el bucle contando debe parar cuando el punto logre el fin de la definición.</p>
<p>La función <code>beginning-of-defun</code> busca atrás para un delimitador de apertura tal como <samp>(</samp> al principio de una línea, y mueve el punto a esta posición, o sino al límite de la búsqueda. En la práctica, esto significa que <code>beginning-of-defun</code> mueve el punto al principio de un cierre o definición de función precedente, o sino al principio del buffer.</p>
<p>El bucle <code>while</code> requiere un contador para guardar la traza de las palabras o símbolos siendo contados. Una expresión <code>let</code> puede ser usado para crear una variable local para este propósito, y lo asocia a un valor inicial de cero.</p>
<p>La función <code>end-of-defun</code> funciona como <code>beginning-of-defun</code> excepto que mueve el punto al fin de la definición. <code>end-of-defun</code> puede ser usado como parte de una expresión que determina la posición del fin de la definición.</p>
<p>La configuración para <code>count-words-in-defun</code> toma forma rápidamente: primero movemos el punto al principio de la definición, entonces se crea una variable local para manejar el conteo, y finalmente, se graba la posición del fin de la definición así el bucle <code>while</code> conocerá cuando parar el bucle.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">beginning-of-defun</span><span class="p">)</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">end</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-defun</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
</code></pre>
<p>El código es simple. La única ligera complicación es probablemente ir al <code>end</code>: eso está asociado a la posición del fin de la definición por una expresión <code>save-excursion</code> que devuelve el valor del punto después de <code>end-of-defun</code> temporalmente se mueve al fin de la definición.</p>
<p>La segunda parte del <code>count-words-in-defun</code>, después de la configuración, es el bucle <code>while</code>.</p>
<p>El bucle debe contener una expresión que mueva el punto hacia adelante palabra por palabra y símbolo por símbolo, y otra expresión que cuente los saltos. El test-verdadero-o-falso para el bucle <code>while</code> chequearía verdadero tan largo como el punto debería saltar hacia adelante, y falso si apunta al fin de la definición. Ya se ha redefinido la expresión regular para esto, así el bucle es sencillo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">end</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">re-search-forward</span>
             <span class="s">&#34;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&#34;</span> <span class="nv">end</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">count</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">count</span><span class="p">)))</span>
</code></pre>
<p>La tercera parte de la definición devuelve el contaje de palabras y símbolos. Esta parte es la última expresión con el cuerpo de la expresión <code>let</code>, y puede ser, muy la variable local <code>count</code>, que cuando se evalúa devuelve el contaje.</p>
<p>Puesto junto, la definición <code>count-words-in-defun</code> se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-in-defun</span> <span class="p">()</span>
  <span class="s">&#34;Devuelve el número de palabras y símbolos en una defun.&#34;</span>
  <span class="p">(</span><span class="nv">beginning-of-defun</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">end</span> <span class="p">(</span><span class="nb">save-excursion</span> <span class="p">(</span><span class="nv">end-of-defun</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">while</span>
        <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="nv">end</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">re-search-forward</span>
              <span class="s">&#34;\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*&#34;</span>
              <span class="nv">end</span> <span class="no">t</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">count</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">count</span><span class="p">)))</span>
    <span class="nv">count</span><span class="p">))</span>
</code></pre>
<p>¿Cómo se chequea esto? La función no es interactiva, pero es fácil poner un envoltorio alrededor de la función para hacerla interactiva; se puede usar casi el mismo código como la versión recursiva de <code>count-words-example</code>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Interactiva.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">count-words-defun</span> <span class="p">()</span>
  <span class="s">&#34;Número de palabras y símbolos en una definición
</span><span class="s">  de función.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span>
   <span class="s">&#34;Contando palabras y símbolos en la definición de función ... &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">count</span> <span class="p">(</span><span class="nv">count-words-in-defun</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">cond</span>
     <span class="p">((</span><span class="nv">zerop</span> <span class="nv">count</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span>
       <span class="s">&#34;La definición NO tiene palabras o símbolos.&#34;</span><span class="p">))</span>
     <span class="p">((</span><span class="nf">=</span> <span class="mi">1</span> <span class="nv">count</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span>
       <span class="s">&#34;La definición tiene 1 palabra o símbolo.&#34;</span><span class="p">))</span>
     <span class="p">(</span><span class="no">t</span>
      <span class="p">(</span><span class="nf">message</span>
       <span class="s">&#34;La definición tiene %d palabras o símbolos.&#34;</span> <span class="nv">count</span><span class="p">)))))</span>
</code></pre>
<p>Permite reutilizar <kbd>C-c =</kbd> como un atajo conveniente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-c=&#34;</span> <span class="ss">&#39;count-words-defun</span><span class="p">)</span>
</code></pre>
<p>Ahora se puede intentar <code>count-words-defun</code>: instala ambas funciones <code>count-words-in-defun</code> y <code>count-words-defun</code>, y asigna el atajo, y entonces emplaza el cursor con la siguiente definición:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">multiply-by-seven</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Multiplicar NUMBER por siete.&#34;</span>
  <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">number</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">10</span>
</code></pre>
<p>¡Éxito! La definición tiene 10 palabras y símbolos.</p>
<p>El siguiente problema es contar los números de palabras y símbolos en varias definiciones con un fichero simple.</p>
</div>
<h3 id="contar-varias-defuns-en-un-fichero" >Contar varias <code>defuns</code> en un fichero</h3>
<div class="hBody-3" >
<p>Un fichero tal como <span class="file" >simple.el</span> puede tener un centenar o más definiciones de función dentro. Nuestro objetivo es recoger estadísticas en muchos ficheros, pero en un primer paso, nuestro objetivo inmediato es recoger estadísticas en un fichero.</p>
<p>La información será una serie de números, cada número siendo el tamaño de una definición de función. Se pueden almacenar los números en una lista.</p>
<p>Se sabe que se querrá incorporar la información considerando un fichero con información acerca de muchos otros ficheros; esto significa que la función para contar el tamaño de contaje con un fichero solo necesita devolver la lista de tamaños. Eso no necesita y no mostraría mensajes.</p>
<p>Los comando de contar palabras contienen una expresión para saltar el punto hacia adelante palabra por palabra y otra expresión para contar los saltos. La función devuelve los tamaños de definiciones que pueden ser diseñadas para trabajar del mismo modo, con una expresión para saltar el punto hacia la definición por definición y otra expresión para construir el tamaño de la lista.</p>
<p>Esta frase del problema hace elemental escribir la definición de función. Claramente, empezaremos el conteo al principio del fichero, así el primer comando será <code>(goto-char (point-min))</code>. Lo siguiente, es empezar el bucle <code>while</code>; y este true-or-false del bucle puede ser una búsqueda de expresión regular para la siguiente definición de función --- así en el momento que la búsqueda tiene éxito, el punto se mueve hacia adelante y entonces el cuerpo del bucle es evaluado. El cuerpo necesita una expresión que construye la lista de tamaños. <code>cons</code>, la lista de construcción del comando, puede ser usado para crear la lista. Esto es casi todo lo que hay.</p>
<p>Aquí está este fragmento de código que se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
<span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;^(defun&#34;</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lengths-list</span>
        <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">count-words-in-defun</span><span class="p">)</span> <span class="nv">lengths-list</span><span class="p">)))</span>
</code></pre>
<p>Dejamos fuera el mecanismo para encontrar el fichero que contiene las definiciones de función.</p>
<p>En ejemplos previos, nosotros habíamos usado esto, el fichero Info, o cambiamos atrás y adelante a algún otro búfer, tal como el búfer <span class="file" >*scratch*</span>.</p>
<p>Encontrar un fichero es un nuevo proceso que no tenemos todavía discutido.</p>
</div>
<h3 id="encontrar-un-fichero" >Encontrar un fichero</h3>
<div class="hBody-3" >
<p>Para encontrar un fichero en Emacs, se usa el comando <kbd>C-x C-f</kbd> (<code>find-file</code>). Este comando es casi, pero no bastante correcto para el problema de tamaños.</p>
<p>Permita mirar el fuente para <code>find-file</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">find-file</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="s">&#34;Edita el fichero FILENAME.
</span><span class="s">Cambia a un búfer visitando el fichero FILENAME,
</span><span class="s">creando uno si no existe ya.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;FFind file: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nv">find-file-noselect</span> <span class="nv">filename</span><span class="p">)))</span>
</code></pre>
<p>(La versión más reciente de la definición de función <code>find-file</code> permite comodines especiales para visitar múltiples ficheros; que hacen la definición más compleja y no se discutirá aquí, ya que no es relevante. Se pueden ver sus fuentes usando <kbd>M-.</kbd> (<code>find-tag</code>) o <kbd>C-h f</kbd> (<code>describe-function</code>).)</p>
<p>La definición que se está mostrando posee una documentación corta, pero completa y una especificación interactiva que muestra un nombre de fichero cuando se usa el comando interactivamente. El cuerpo de la definición contiene dos funciones, <code>find-file-noselect</code> y <code>switch-to-buffer</code>.</p>
<p>De acuerdo a su documentación como muestra por <kbd>C-h f</kbd> (el comando <code>describe-function</code>), la función <code>find-file-noselect</code> lee el fichero nombrado dentro de un búfer y devuelve el búfer. (Su versión más reciente incluye un argumento comodín, también, así como otro para leer un fichero literalmente y otro que suprime mensajes de aviso. Estos argumentos opcionales son irrelevantes.)</p>
<p>Sin embargo, la función <code>find-file-noselect</code> no selecciona el búfer en el que se pone el fichero. Emacs no cambia su atención (o la tuya si estás usando <code>find-file-noselect</code>) al búfer seleccionado. Esto es lo que <code>switch-to-buffer</code> hace: eso cambia el búfer al que se dirige la atención de Emacs; y eso cambia el búfer mostrado en la ventana al nuevo búfer. Se ha discutido el búfer cambiando a otro lugar. (Vea la Seccion <a href="Cambiando-búfers" >Cambiando búfers</a>.)</p>
<p>En este proyecto de histograma, no se necesita mostrar cada fichero en la pantalla como el programa determina el tamaño de cada definición con eso. En vez de emplear <code>switch-to-buffer</code>, se puede trabajar con <code>set-buffer</code>, que redirige la atención del programa de ordenador para un búfer diferente pero no lo muestra en pantalla. Así en vez llamar a <code>find-file</code> para hacer el trabajo, debe escribir nuestra expresión.</p>
<p>La tarea es fácil: usar <code>find-file-noselect</code> y <code>set-buffer</code>.</p>
</div>
<h3 id="lengths-list-file-en-detalle" ><code>lengths-list-file</code> en detalle</h3>
<div class="hBody-3" >
<p>El núcleo de la función <code>lengths-list-file</code> es un bucle <code>while</code> conteniendo una función para mover el punto hacia delante ‘función a función’ y una función para contar el número de palabras y símbolos en cada función. Este núcleo debe ser rodeado por funciones que hacen otras tareas varias, incluyendo encontrar el fichero, y asegurando que el punto empieza al principio del fichero. La definición de la función se parece a:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">lengths-list-file</span> <span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de tamaños de definiciones con FILE.
</span><span class="s">La lista devuelta es una lista de números.
</span><span class="s">Cada número es el número de palabras o
</span><span class="s">símbolos en una definición.&#34;</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Trabajando en </span><span class="ss">`%s&#39;</span><span class="s"> ... &#34;</span> <span class="nv">filename</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">save-excursion</span>
    <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">buffer</span> <span class="p">(</span><span class="nv">find-file-noselect</span> <span class="nv">filename</span><span class="p">))</span>
          <span class="p">(</span><span class="nv">lengths-list</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">set-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">buffer-read-only</span> <span class="no">t</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">widen</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nf">point-min</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">re-search-forward</span> <span class="s">&#34;^(defun&#34;</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">lengths-list</span>
              <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">count-words-in-defun</span><span class="p">)</span> <span class="nv">lengths-list</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">kill-buffer</span> <span class="nv">buffer</span><span class="p">)</span>
      <span class="nv">lengths-list</span><span class="p">)))</span>
</code></pre>
<p>La función pasa un argumento, el nombre del fichero en el que se trabajará. Eso tiene cuatro líneas de documentación, pero sin especificación interactiva. Para evitar la preocupación de si se ha estropeado el programa o no, la primera línea del cuerpo es un mensaje de aviso.</p>
<p>La siguiente línea contiene un <code>save-excursion</code> que devuelve a Emacs la atención al actual búfer cuando la función se completa. Esto es útil en caso de embeber esta función en otra función que presume que el punto restaura el búfer original.</p>
<p>En la varlist de la expresión <code>let</code>, Emacs encuentra el fichero y ajusta la variable local <code>buffer</code> al búfer conteniendo el fichero. Al mismo tiempo, Emacs crea <code>lengths-list</code> como una variable local.</p>
<p>Lo siguiente, Emacs cambia su atención al búfer.</p>
<p>En la siguiente línea, Emacs crea el búfer de solo lectura. Idealmente, esta línea no es necesaria. Ninguna de las funciones para contar palabras y símbolos en una definición de función cambiaría el búfer. Debajo, el búfer no está yendo para ser guardado, incluso si eso fuese cambiado. Esta línea es enteramente la consecuencia grata, quizás excesiva precaución. La razón para la precaución es que esta función y esta se llama a trabajar en las fuentes para Emacs y eso es un inconveniente si están inadvertidamente modificadas. Eso va sin decir que no se realizó una necesidad para esta línea hasta que un experimento fué cambiado hacia un lado y empezó a modificar mis ficheros de fuentes Emacs …</p>
<p>Lo siguiente llama a alargar el búfer si eso está encogido. Esta función es normalmente innecesaria––Emacs crea un búfer fresco si ninguno ya existe; pero si un búfer está visitando el fichero que ya existe que Emacs devuelve uno. En este caso, el búfer puede ser encogido y debe ser amplio. Si se quiere ser completamente ‘amigo del usuario’, se pondría en orden para guardar la restricción y la localización del punto, pero no.</p>
<p>La expresión <code>(goto-char (point-min))</code> mueve el punto al principio del búfer.</p>
<p>Entonces llega un bucle <code>while</code> en el que se devuelve el ‘trabajo’ de la función. En el bucle, Emacs determina el tamaño de cada definición y construye una lista de tamaños conteniendo la información.</p>
<p>Emacs corta el búfer después de trabajar a través de eso. Esto es guardar espacio dentro de Emacs. Mi versión de GNU Emacs 19 contenía 300 ficheros fuente de interés; GNU Emacs 22 contiene a través de un millar de ficheros fuente. Otra función aplicará <code>lengths-list-file</code> a cada uno de los ficheros.</p>
<p>Finalmente, la última expresión con la expresión <code>let</code> es la variable <code>lengths-list</code>; su valor es devuelto como el valor de la función completa.</p>
<p>Se puede probar esta función instalándolo en el modo usual. Entonces posiciona tu cursor después de la siguiente expresión y escribe <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>).</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">lengths-list-file</span>
 <span class="s">&#34;/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el&#34;</span><span class="p">)</span>
</code></pre>
<p>(Se puede necesitar cambiar la ruta del fichero; el único aquí es para GNU Emacs versión 22.1.1. Para cambiar la expresión, cópialo al búfer <span class="file" >*scratch*</span> y edítalo.</p>
<p>(También, para ver el tamaño completo de la lista, en vez de una versión truncada se puede tener que evaluar lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">custom-set-variables</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">eval-expression-print-length</span> <span class="no">nil</span><span class="p">))</span>
</code></pre>
<p>(Vea la Seccion <a href="Especificar-Variables-usando-defcustom" >Especificar Variables usando <code>defcustom</code></a>. Entonces evalúa la expresión <code>lengths-list-file</code>.)</p>
<p>La lista de tamaños para <span class="file" >debug.el</span> toma menos de un segundo para producirse esto en GNU Emacs 22:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">83</span> <span class="mi">113</span> <span class="mi">105</span> <span class="mi">144</span> <span class="mi">289</span> <span class="mi">22</span> <span class="mi">30</span> <span class="mi">97</span> <span class="mi">48</span> <span class="mi">89</span> <span class="mi">25</span> <span class="mi">52</span> <span class="mi">52</span> <span class="mi">88</span> <span class="mi">28</span> <span class="mi">29</span> <span class="mi">77</span> <span class="mi">49</span> <span class="mi">43</span> <span class="mi">290</span> <span class="mi">232</span> <span class="mi">587</span><span class="p">)</span>
</code></pre>
<p>(Usando mi vieja máquina, la versión 19 lista tamaños para <span class="file" >debug.el</span> que en siete segundos para producen esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">75</span> <span class="mi">41</span> <span class="mi">80</span> <span class="mi">62</span> <span class="mi">20</span> <span class="mi">45</span> <span class="mi">44</span> <span class="mi">68</span> <span class="mi">45</span> <span class="mi">12</span> <span class="mi">34</span> <span class="mi">235</span><span class="p">)</span>
</code></pre>
<p>(La versión nueva de <span class="file" >debug.el</span> contiene más defuns que la temprana; y mi nueva máquina es más rápida que la vieja.</p>
<p>Nótese que el tamaño de la última definición en el fichero es el primero en la lista.</p>
</div>
<h3 id="contar-palabras-en-defuns-en-diferentes-ficheros" >Contar palabras en <code>defuns</code> en diferentes ficheros</h3>
<div class="hBody-3" >
<p>En la sección previa, se creaba una función que devuelve una lista de los tamaños de cada definición en un fichero. Ahora, se quiere definir una función para devolver una lista maestra de los tamaños de las definiciones en una lista de ficheros.</p>
<p>Trabajar en cada elemento de una lista de ficheros es un acto repetitivo, así se puede usar un bucle <code>while</code> o recursión.</p>
<p>El diseño usando un bucle <code>while</code> es rutina. El argumento que se pasaba a la función es una lista de ficheros. Como se vió pronto (Vease Sección <a href="Ejemplo-de-bucle" >Ejemplo de bucle</a>), se puede escribir un bucle <code>while</code> de un modo que el cuerpo del bucle es evaluado si tal lista contiene elementos, pero sale del bucle si la lista está vacía. Para que este diseño funcione, el cuerpo del bucle debe contener una expresión que ordene la lista cada vez que el cuerpo es evaluado, de modo que finalmente la lista esté vacía. La técnica normal es asignar el valor de la lista para el valor del <code>cdr</code> de la lista cada vez que el cuerpo es evaluado.</p>
<p>La plantilla se ve así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">@V{test-whether-list-is-empty}</span>
  <span class="nv">@V{body}</span><span class="err">…</span>
  <span class="nv">@V{set-list-to-cdr-of-list}</span><span class="p">)</span>
</code></pre>
<p>También, recuérdanos que un bucle <code>while</code> devuelve <code>nil</code> (el resultado de evaluar el true-or-false-test), no el resultado de cualquier evaluación con su cuerpo. (Las evaluaciones con el cuerpo del bucle son hechas para sus efectos laterales.) Sin embargo, la expresión que asigna la lista de tamaños es parte del cuerpo––y que es el valor que queremos devuelto por la función como un todo. Para hacer esto cerramos el bucle <code>while</code> con una expresión <code>let</code>, y pone en orden que el último elemento de la expresión <code>let</code> contiene el valor de lista de tamaños. (Vea la Seccion <a href="Ejemplo-de-Incremento,-,-El-Ejemplo-del-Bucle-con-un-Contador-de-Incremento" >Ejemplo de Incremento, , El Ejemplo del Bucle con un Contador de Incremento</a>.)</p>
<p>Estas consideraciones lideran directamente a la función en sí:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; @e{Usar bucle @c{while}.}</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">lengths-list-many-files</span> <span class="p">(</span><span class="nv">list-of-files</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de tamaños de funciones en LIST-OF-FILES.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">lengths-list</span><span class="p">)</span>

<span class="c1">;;; true-or-false-test</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">list-of-files</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">lengths-list</span>
            <span class="p">(</span><span class="nf">append</span>
             <span class="nv">lengths-list</span>

<span class="c1">;;; Genera una lista de tamaños.</span>
             <span class="p">(</span><span class="nv">lengths-list-file</span>
              <span class="p">(</span><span class="nf">expand-file-name</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">list-of-files</span><span class="p">)))))</span>

<span class="c1">;;; Crea una lista ordenada de ficheros.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">list-of-files</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">list-of-files</span><span class="p">)))</span>

<span class="c1">;;; Devuelve la lista final de valores de tamaños.</span>
    <span class="nv">lengths-list</span><span class="p">))</span>
</code></pre>
<p><code>expand-file-name</code> es una función construida que convierte un nombre de fichero al absoluto, forma de nombre de ruta. La función emplea el nombre del directorio en el que la función se llama.</p>
<p>De este modo, si <code>expand-file-name</code> es llamado en <code>debug.el</code> cuando Emacs está visitando el directorio <span class="file" >/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/</span></p>
<div class="example-block" >
<pre class="example" >debug.el
</pre>
</div>
<p>llega a ser</p>
<div class="example-block" >
<pre class="example" >/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
</pre>
</div>
<p>El único nuevo elemento de esta definición de función es la todavía no estudiada función <code>append</code>, que merece una corta sección en sí.</p>
</div>
<h4 id="la-función-append" >La función <code>append</code></h4>
<div class="hBody-4" >
<p>La función <code>append</code> adjunta una lista a otra. De este modo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">append</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
</code></pre>
<p>produce la lista</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">)</span>
</code></pre>
<p>Esto es exactamente cómo queremos adjuntar dos listas de tamaños producidas por <code>lengths-list-file</code> a cualquier otra. Los resultados contrastan con <code>cons</code>,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">cons</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span>
</code></pre>
<p>que construye una nueva lista en el que el primer argumento para <code>cons</code> llega a ser el primer elemento de la nueva lista:</p>
<pre class="code" ><code class="chroma" ><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="recursivamente-cuenta-palabras-en-diferentes-ficheros" >Recursivamente cuenta palabras en diferentes ficheros</h3>
<div class="hBody-3" >
<p>Bajo un bucle <code>while</code>, se puede trabajar cada lista de ficheros con recursión. Una versión recursiva de <code>lengths-list-many-files</code> es corta y simple.</p>
<p>La función recursiva tiene las partes normales: el ‘do-again-test’, la ‘next-step-expression’, y la llamada recursiva. El ‘do-again-test’ determina si la función se llamaría, que hará si la <code>list-of-files</code> contiene los elementos que permanecen; la ‘next-step-expression’ resetea el <code>list-of-files</code> al <code>cdr</code> en sí, así finalmente la lista será vacía; y la llamada recursiva llama en sí a la lista ordenada. ¡La función completa está ordenada por esta descripción!</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">recursive-lengths-list-many-files</span> <span class="p">(</span><span class="nv">list-of-files</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de tamaños de cada defun en LIST-OF-FILES.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="nv">list-of-files</span>                     <span class="c1">; do-again-test</span>
      <span class="p">(</span><span class="nf">append</span>
       <span class="p">(</span><span class="nv">lengths-list-file</span>
        <span class="p">(</span><span class="nf">expand-file-name</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">list-of-files</span><span class="p">)))</span>
       <span class="p">(</span><span class="nv">recursive-lengths-list-many-files</span>
        <span class="p">(</span><span class="nf">cdr</span> <span class="nv">list-of-files</span><span class="p">)))))</span>
</code></pre>
<p>En una frase, la función devuelve de tamaños de la lista para la el primero de la <code>list-of-files</code> al resultado de llamarse así mismo al resto de <code>list-of-files</code>.</p>
<p>Aquí hay un test <code>recursive-lengths-list-many-files</code>, a lo largo de los resultados de ejecutar <code>lengths-list-file</code> en cada uno de los ficheros individualmente.</p>
<p>Instala <code>recursive-lengths-list-many-files</code> y <code>lengths-list-file</code>, si es necesario, y entonces evalúa las siguientes expresiones. Se puede necesitar cambiar las rutas de ficheros; aquí se trabaja cuando este fichero Info y las fuentes de Emacs están localizadas en sus lugares personales. Para cambiar las expresiones, cópialas al búfer <span class="file" >*scratch*</span>, edítalos y entonces evalúalos.</p>
<p>Los resultados son mostrados después del <samp>⇒</samp>. (Estos resultados son para ficheros de Emacs versión 22.1.1; ficheros desde otras versiones de Emacs puede producir diferentes resultados.)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">cd</span> <span class="s">&#34;/usr/local/share/emacs/22.1.1/&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">lengths-list-file</span> <span class="s">&#34;./lisp/macros.el&#34;</span><span class="p">)</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="mi">283</span> <span class="mi">263</span> <span class="mi">480</span> <span class="mi">90</span><span class="p">)</span>

<span class="p">(</span><span class="nv">lengths-list-file</span> <span class="s">&#34;./lisp/mail/mailalias.el&#34;</span><span class="p">)</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="mi">38</span> <span class="mi">32</span> <span class="mi">29</span> <span class="mi">95</span> <span class="mi">178</span> <span class="mi">180</span> <span class="mi">321</span> <span class="mi">218</span> <span class="mi">324</span><span class="p">)</span>

<span class="p">(</span><span class="nv">lengths-list-file</span> <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">)</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="mi">85</span> <span class="mi">181</span><span class="p">)</span>

  <span class="p">(</span><span class="nv">recursive-lengths-list-many-files</span>
   <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;./lisp/macros.el&#34;</span>
     <span class="s">&#34;./lisp/mail/mailalias.el&#34;</span>
     <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">))</span>
       <span class="err">⇒</span> <span class="p">(</span><span class="mi">283</span> <span class="mi">263</span> <span class="mi">480</span> <span class="mi">90</span> <span class="mi">38</span> <span class="mi">32</span> <span class="mi">29</span> <span class="mi">95</span> <span class="mi">178</span> <span class="mi">180</span> <span class="mi">321</span> <span class="mi">218</span> <span class="mi">324</span> <span class="mi">85</span> <span class="mi">181</span><span class="p">)</span>
</code></pre>
<p>La función <code>recursive-lengths-list-many-files</code> produce la salida que queremos.</p>
<p>El siguiente paso es preparar el dato en la lista para mostrarlo en un grafo.</p>
</div>
<h3 id="preparar-los-datos-para-mostrarlos-en-un-grafo" >Preparar los datos para mostrarlos en un grafo</h3>
<div class="hBody-3" >
<p>La función <code>recursive-lengths-list-many-files</code> devuelve una lista de números. Cada número graba el tamaño de una definición de función. Lo que se necesita hacer ahora es transformar estos datos dentro de una lista de números ajustado para generar un grafo. La nueva lista contará cuántas definiciones de funciones contienen menos de 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuántas contienen entre 20 y 29 palabras y símbolos, y así.</p>
<p>En breve, se necesita ir a través el tamaño de la lista producida por la función <code>recursive-lengths-list-many-files</code> y contar el número de defuns con cada rango de tamaños, y produce una lista de esto de números.</p>
<p>Basado en lo que hemos hecho antes, se prevee que no sería difícil escribir una función que ‘<code>cdr</code>s’ bajo la lista de tamaños, parece que cada elemento, determina que rango de tamaños está dentro, e incrementa un contador para este rango.</p>
<p>Sin embargo, antes de empezar a escribir tal función, nosotros consideraríamos las ventajas de ordenar los tamaños de la lista primero, así los números son ordenados desde el más pequeño al más largo. Primero, ordenando se hará fácil contar los números en cada rango, desde dos números adyacentes será el mismo rango del tamaño en rangos adyacentes. Segundo, inspeccionando una lista ordenada, se puede descubrir el número mayor y menor, y esto significa determinar el rango de tamaño mayor y menor que necesitará.</p>
</div>
<h4 id="ordenando-listas" >Ordenando listas</h4>
<div class="hBody-4" >
<p>Emacs contiene una función para listas ordenadas, llamadas (como se podría adivinar) <code>sort</code>. La función <code>sort</code> toma dos argumentos, la lista es ordenada, y un predicado que determina si la primera de dos elementos de lista es “menor” que la segunda.</p>
<p>Como se vió antes (Vease Sección <q>Usando el Tipo Incorrecto de Objeto como un Argumento</q>), un predicado es una función que determina si alguna propiedad es verdadera o falsa. La función <code>sort</code> reordenará una lista de acuerdo a lo que la propiedad del predicado usa; esto significa que <code>sort</code> puede ser usado para ordenar listas no numéricas por un criterio no numérico --- eso puede, por ejemplo, alfabetizar una lista.</p>
<p>La función <code>&lt;</code> se usa cuando se ordena una lista numérica. Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">sort</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">8</span> <span class="mi">21</span> <span class="mi">17</span> <span class="mi">33</span> <span class="mi">7</span> <span class="mi">21</span> <span class="mi">7</span><span class="p">)</span> <span class="ss">&#39;&lt;</span><span class="p">)</span>
</code></pre>
<p>produce esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">4</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">17</span> <span class="mi">21</span> <span class="mi">21</span> <span class="mi">33</span><span class="p">)</span>
</code></pre>
<p>(Note que en este ejemplo, ambos argumentos se citan así que los símbolos no se evalúan antes de ser pasados por <code>sort</code> como argumentos.)</p>
<p>Ordenando la lista devuelta por la función <code>recursive-lengths-list-many-files</code> es honesta; eso usa la función <code>&lt;</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">sort</span>
 <span class="p">(</span><span class="nv">recursive-lengths-list-many-files</span>
  <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;./lisp/macros.el&#34;</span>
    <span class="s">&#34;./lisp/mailalias.el&#34;</span>
    <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">))</span>
 <span class="ss">&#39;&lt;</span><span class="p">)</span>
</code></pre>
<p>que produce:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">29</span> <span class="mi">32</span> <span class="mi">38</span> <span class="mi">85</span> <span class="mi">90</span> <span class="mi">95</span> <span class="mi">178</span> <span class="mi">180</span> <span class="mi">181</span> <span class="mi">218</span> <span class="mi">263</span> <span class="mi">283</span> <span class="mi">321</span> <span class="mi">324</span> <span class="mi">480</span><span class="p">)</span>
</code></pre>
<p>(Note que en este ejemplo, el primer argumento para <code>sort</code> no está citado, desde que la expresión debe ser evaluado así como producir la lista que es pasada para <code>sort</code>.)</p>
</div>
<h4 id="creando-una-lista-de-ficheros" >Creando una lista de ficheros</h4>
<div class="hBody-4" >
<p>La función <code>recursive-lengths-list-many-files</code> requiere una lista de fichero como argumento. Para nuestros ejemplos de test, se construyeron tal como una lista a mano; pero el directorio fuente de Emacs Lisp es demasiado grande para hacer esto. Así, se escribirá una función para hacer el trabajo. En esta función, se usa tanto un bucle <code>while</code> como una llamada recursiva.</p>
<p>En viejas versiones de GNU Emacs no hizo falta tener que escribir esta función, puesto que todos los ficheros <samp>.el</samp> en un directorio. En vez de eso, se puede ser capaz de usar la función <code>directory-files</code>, que lista los nombres de fichero que hay en un directorio simple.</p>
<p>Sin embargo, las versiones reciente Emacs emplazan ficheros de Emacs Lisp en subdirectorios del directorio de alto nivel <span class="file" >lisp</span>. Esto facilita la navegación. Por ejemplo, todos los ficheros de correo relacionados que están en el subdirectorio llamado <span class="file" >mail</span>. Pero al mismo tiempo, esta facilidad fuerza a crear un fichero listando la función que desciende dentro de los subdirectorios.</p>
<p>Se puede crear esta función, llamada <code>files-en-below-directory</code>, usando funciones familiares tales como <code>car</code>, <code>nthcdr</code>, y <code>substring</code> en conjunción con una función existente llamada <code>directory-files-and-attributes</code>. Esta última función no solo listas de ficheros en un directorio, incluyendo los nombres de subdirectorios, pero también sus atributos.</p>
<p>Para empezar nuestro objetivo: crear una función que nos permita alimentas ficheros a <code>recursive-lengths-list-many-files</code> como una lista que se parece a esto (pero con más elementos):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;./lisp/macros.el&#34;</span>
 <span class="s">&#34;./lisp/mail/rmail.el&#34;</span>
 <span class="s">&#34;./lisp/makesum.el&#34;</span><span class="p">)</span>
</code></pre>
<p>La función <code>directory-files-and-attributes</code> devuelve una lista de listas. Cada una de las listas con la lista principal consiste de 13 elementos. El primer elemento es una cadena que contiene el nombre del fichero––que, en GNU/Linux, puede ser un ‘directorio fichero’, que dice, un fichero con los atributos especiales de un directorio. El segundo elemento de la lista es <code>t</code> para un directorio, es una cadena para el enlace simbólico (la cadena es el nombre enlazado), o <code>nil</code>.</p>
<p>Por ejemplo, el primer fichero <samp>.el</samp> en el directorio es <span class="file" >abbrev.el</span>. Su nombre es <span class="file" >/usr/local/share/emacs/22.1.1/lisp/abbrev.el</span> y no es un directorio o un enlace simbólico.</p>
<p>Esto es cómo <code>directory-files-and-attributes</code> lista este fichero y sus atributos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;abbrev.el&#34;</span>
<span class="no">nil</span>
<span class="mi">1</span>
<span class="mi">1000</span>
<span class="mi">100</span>
<span class="p">(</span><span class="mi">20615</span> <span class="mi">27034</span> <span class="mi">579989</span> <span class="mi">697000</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17905</span> <span class="mi">55681</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">20615</span> <span class="mi">26327</span> <span class="mi">734791</span> <span class="mi">805000</span><span class="p">)</span>
<span class="mi">13188</span>
<span class="s">&#34;-rw-r--r--&#34;</span>
<span class="no">nil</span>
<span class="mi">2971624</span>
<span class="mi">773</span><span class="p">)</span>
</code></pre>
<p>Por otro lado, <span class="file" >mail/</span> es un directorio con el directorio <span class="file" >lisp/</span>. El principio del listado se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;mail&#34;</span>
<span class="no">t</span>
<span class="err">…</span>
<span class="p">)</span>
</code></pre>
<p>(Para aprender acerca de los diferentes atributos, mira en la documentación de <code>file-attributes</code>. Tenga en mente que la función <code>file-attributes</code> no lista el nombre del fichero, así su primer elemento es <code>directory-files-and-attributes</code> que es el segundo elemento.)</p>
<p>Se querrán nuestras nuevas funciones, <code>files-in-below-directory</code>, para listar los fichero <samp>.el</samp> en el directorio eso es contado para chequear, y en los directorios bajo este directorio.</p>
<p>Esto nos da una sugestión de como construir <code>files-in-below-directory</code>: con un directorio, la función añadir los nombres de ficheros <samp>.el</samp> a una lista; y si, con un directorio, la función viene con un subdirectorio, iría dentro de este subdirectorio y repite sus acciones.</p>
<p>Sin embargo, nosotros notaríamos que cada directorio contiene un nombre que se refiere a sí mismo, llamado <span class="file" >.</span>, (“dot”) y un nombre que se refiere a su directorio padre, llamado <span class="file" >..</span> (“doble punto”). (En <span class="file" >/</span>, el directorio raíz, <span class="file" >..</span> se refiere así mismo, desde que <span class="file" >/</span> no tiene padre.) Claramente, no que se quiere nuestra función <code>files-in-below-directory</code> para introducir estos directorio, desde que ellos siempre nos lideran, directamente o indirectamente, al directorio actual.</p>
<p>Consecuentemente, nuestra función <code>files-in-below-directory</code> debe hacer varias tareas:</p>
<ul>
<li>
<p>Chequee para ver si se está mirando en un nombre de fichero que finaliza en <samp>.el</samp> y si es así, se añade el nombre a una lista.</p>
</li>
<li>
<p>Chequee para ver si está mirando en un nombre de fichero que es el nombre de un directorio; y si es así,</p>
<ul>
<li>
<p>Chequee para ver si está mirando en <span class="file" >.</span> o <span class="file" >..</span>; y si es así sal.</p>
</li>
<li>
<p>O además, ve dentro de este directorio y repite el proceso.</p>
</li>
</ul>
</li>
</ul>
<p>Se permite escribir una definición de función para hacer estas tareas. Se usará un bucle <code>while</code> para mover de un nombre de fichero a otro con un directorio chequeando lo que necesita ser hecho; y se usa una llamada recursiva para repetir las acciones en cada subdirectorio. El patrón recursivo es ‘acumular’ (Vease Sección <a href="Patrón-recursivo:-accumulate" >Patrón recursivo: <em>accumulate</em></a>) usando <code>append</code> para combinar.</p>
<p>Aquí está la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">files-in-below-directory</span> <span class="p">(</span><span class="nv">directory</span><span class="p">)</span>
  <span class="s">&#34;Lista los ficheros .el en DIRECTORIO y en sus subdirectorios.&#34;</span>
  <span class="c1">;; Aunque la función será usada no interactivamente,</span>
  <span class="c1">;; será fácil chequear si lo hacemos interactivo.</span>
  <span class="c1">;; El directorio tendrá un nombre tal como</span>
  <span class="c1">;;  &#34;/usr/local/share/emacs/22.1.1/lisp/&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;DNombre del Directorio: &#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">el-files-list</span>
        <span class="p">(</span><span class="nv">current-directory-list</span>
         <span class="p">(</span><span class="nf">directory-files-and-attributes</span> <span class="nv">directory</span> <span class="no">t</span><span class="p">)))</span>
    <span class="c1">;; mientras estamos en el directorio actual</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">current-directory-list</span>
      <span class="p">(</span><span class="nb">cond</span>
       <span class="c1">;; chequee para ver si el nombre del fichero finaliza en ‘.el’</span>
       <span class="c1">;; y si es así, añade su nombre a una lista.</span>
       <span class="p">((</span><span class="nf">equal</span> <span class="s">&#34;.el&#34;</span> <span class="p">(</span><span class="nf">substring</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">current-directory-list</span><span class="p">))</span> <span class="mi">-3</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">el-files-list</span>
              <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">current-directory-list</span><span class="p">))</span> <span class="nv">el-files-list</span><span class="p">)))</span>
       <span class="c1">;; chequee si el nombre del fichero es un directorio</span>
       <span class="p">((</span><span class="nf">eq</span> <span class="no">t</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">cdr</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">current-directory-list</span><span class="p">))))</span>
        <span class="c1">;; decide si salir o hacer recursión</span>
        <span class="p">(</span><span class="nb">if</span>
            <span class="p">(</span><span class="nf">equal</span> <span class="s">&#34;.&#34;</span>
                   <span class="p">(</span><span class="nf">substring</span> <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">current-directory-list</span><span class="p">))</span> <span class="mi">-1</span><span class="p">))</span>
            <span class="c1">;; entonces no hagas nada puesto que el nombre del fichero es</span>
            <span class="c1">;; el actual directorio o padre, &#34;.&#34; o &#34;..&#34;</span>
            <span class="p">()</span>
          <span class="c1">;; else desciende dentro del directorio y repite el proceso</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">el-files-list</span>
                <span class="p">(</span><span class="nf">append</span>
                 <span class="p">(</span><span class="nv">files-in-below-directory</span>
                  <span class="p">(</span><span class="nf">car</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">current-directory-list</span><span class="p">)))</span>
                 <span class="nv">el-files-list</span><span class="p">)))))</span>
      <span class="c1">;; mueve al siguiente fichero en la lista; esto también</span>
      <span class="c1">;; ordena la lista así mientras el bucle</span>
      <span class="c1">;; eventualmente llega a un fin</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">current-directory-list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">current-directory-list</span><span class="p">)))</span>
    <span class="c1">;; devuelve los ficheros</span>
    <span class="nv">el-files-list</span><span class="p">))</span>
</code></pre>
<p>Las funciones <code>files-in-below-directory</code> <code>directory-files</code> toma un argumento, el nombre de un directorio.</p>
<p>De este modo, en mi sistema,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span>
 <span class="p">(</span><span class="nv">files-in-below-directory</span> <span class="s">&#34;/usr/local/share/emacs/22.1.1/lisp/&#34;</span><span class="p">))</span>
</code></pre>
<p>se cuenta que dentro y debajo de mi directorio de fuentes Lisp hay 1031 ficheros <samp>.el</samp></p>
<p><code>files-in-below-directory</code> devuelve una lista en orden alfabético inverso. Una expresión para ordenar la lista en orden que parece como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">sort</span>
 <span class="p">(</span><span class="nv">files-in-below-directory</span> <span class="s">&#34;/usr/local/share/emacs/22.1.1/lisp/&#34;</span><span class="p">)</span>
 <span class="ss">&#39;string-lessp</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="contando-definiciones-de-función" >Contando definiciones de función</h4>
<div class="hBody-4" >
<p>Nuestro objetivo inmediato es generar una lista que cuenta, cuantas definiciones de funciones contienen menos de 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuantas contienen entre 20 y 29 palabras y símbolos, y así.</p>
<p>Con una lista ordenada de números, es fácil: se cuentan cuantos elementos de la lista son más pequeños de 10, entonces, se devuelven los números contados, se cuenta cuantos son más pequeños de 20, entonces se devuelven los números contados, después se cuentan los que son más pequeños de 30, y así. Cada uno de los números, 10, 20, 30, 40, y como, es más grande que el tope de este rango. Se puede llamar a la lista de tales números, la lista <code>top-of-ranges</code>.</p>
<p>Si se desea, se podría generar esta lista automáticamente, pero es más simple escribir una lista manualmente. Aquí está:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">top-of-ranges</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span>  <span class="mi">20</span>  <span class="mi">30</span>  <span class="mi">40</span>  <span class="mi">50</span>
   <span class="mi">60</span>  <span class="mi">70</span>  <span class="mi">80</span>  <span class="mi">90</span> <span class="mi">100</span>
  <span class="mi">110</span> <span class="mi">120</span> <span class="mi">130</span> <span class="mi">140</span> <span class="mi">150</span>
  <span class="mi">160</span> <span class="mi">170</span> <span class="mi">180</span> <span class="mi">190</span> <span class="mi">200</span>
  <span class="mi">210</span> <span class="mi">220</span> <span class="mi">230</span> <span class="mi">240</span> <span class="mi">250</span>
  <span class="mi">260</span> <span class="mi">270</span> <span class="mi">280</span> <span class="mi">290</span> <span class="mi">300</span><span class="p">)</span>
 <span class="s">&#34;Listar especificando rangos para ‘defuns-per-range’.&#34;</span><span class="p">)</span>
</code></pre>
<p>Para cambiar los rangos, se edita esta lista.</p>
<p>Lo siguiente, que se necesita es escribir la función que crea la lista del número de definiciones con cada rango. Claramente, esta función debe tomar el <code>sorted-lengths</code> y las listas <code>top-of-ranges</code> listas como argumentos.</p>
<p>La función <code>defuns-per-range</code> debe hacer dos cosas una y otra vez: eso debe contar el número de definiciones con un rango específico por el actual valor top-of-range; y eso debe dividir al siguiente gran valor en la lista <code>top-of-ranges</code> después de contar el número de definiciones en el rango actual. Desde que cada una de estas acciones es repetitiva, se puede usar los bucles <code>while</code> para el trabajo. Un bucle cuenta el número de definiciones en el rango definido por el valor actual top-of-range, y el otro bucle selecciona cada uno de los valores top-of-range en turno.</p>
<p>Varias entradas de la lista <code>sorted-lengths</code> se cuentan para cada rango; esto significa que el bucle para la lista <code>sorted-lengths</code> será dentro del bucle para la lista <code>top-of-ranges</code>, como un pequeño adorno dentro de un gran adorno.</p>
<p>El bucle interno cuenta el número de definiciones con el rango. Eso es un simple contaje del tipo en el que se ha visto antes. (Vea la Seccion <a href="Un-bucle-con-un-contaje-incremental" >Un bucle con un contaje incremental</a>). El test true-or-false del bucle chequea si el valor desde la lista <code>sorted-lengths</code> es más pequeña que el actual valor de lo alto del rango. Si es así, la función incrementa el contador y se chequea el siguiente valor desde la lista <code>sorted-lengths</code>.</p>
<p>El bucle interno se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">@V{length-element-smaller-than-top-of-range}</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-within-range</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">number-within-range</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">sorted-lengths</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">sorted-lengths</span><span class="p">)))</span>
</code></pre>
<p>El bucle de fuera debe empezar con el valor más bajo de la lista <code>top-of-ranges</code>, y entonces se asigna a cada uno de los valores superiores exitosos a su vez. Esto puede ser hecho con un bucle como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">top-of-ranges</span>
  <span class="nv">@V{body-of-loop}</span><span class="err">…</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">top-of-ranges</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">top-of-ranges</span><span class="p">)))</span>
</code></pre>
<p>Se ponen juntos, los dos bucles como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">while</span> <span class="nv">top-of-ranges</span>

  <span class="c1">;; Contar el número de elementos con el actual rango.</span>
  <span class="p">(</span><span class="nb">while</span> <span class="nv">@V{length-element-smaller-than-top-of-range}</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-within-range</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">number-within-range</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">sorted-lengths</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">sorted-lengths</span><span class="p">)))</span>

  <span class="c1">;; Mover al siguiente rango.</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">top-of-ranges</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">top-of-ranges</span><span class="p">)))</span>
</code></pre>
<p>Además, en cada circuito del bucle exterior, Emacs grabaría el número de definiciones con este rango (el valor de <code>number-within-range</code>) en una lista. Se puede usar <code>cons</code> para este propósito. (Vea la Seccion <a href="cons" ><code>cons</code></a>.)</p>
<p>La función <code>cons</code> trabaja bien, excepto que la lista que se construye contendrá el número de definiciones para el alto rango y su principio el número de definiciones para el más bajo rango a su fin. Esto es porque <code>cons</code> adjunta nuevos elementos de la lista al principio de la lista, y desde los dos bucles que hacen cálculos a través de la lista de tamaños desde lo bajo finaliza primero, el <code>defuns-per-range-list</code> finalizará el primer número más largo. Pero lo que se quiere es imprimir nuestro grafo con pequeños valores primero y el más grande después. La solución es invertir el orden del <code>defuns-per-range-list</code>. Nosotros podemos hacer esto usando la función <code>nreverse</code>, que invierte el orden de una lista.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">nreverse</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</code></pre>
<p>produce:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</code></pre>
<p>Note que la función <code>nreverse</code> es “destructiva”––que es, cambiar la lista a la que se aplica; esto contrasta con las funciones <code>car</code> y <code>cdr</code>, que no son destructivas. En este caso, no se quiere que el original <code>defuns-per-range-list</code>, de manera que no hay materia que se destruya. (La función <code>reverse</code> provee un copia inversa de una lista, dejando la lista original como es.)</p>
<p>Pon todo junto, el <code>defuns-per-range</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">defuns-per-range</span> <span class="p">(</span><span class="nv">sorted-lengths</span> <span class="nv">top-of-ranges</span><span class="p">)</span>
  <span class="s">&#34;funciones de SORTED-LENGTHS en cada rango TOP-OF-RANGES.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">top-of-range</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">top-of-ranges</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">number-within-range</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nv">defuns-per-range-list</span><span class="p">)</span>

    <span class="c1">;; Bucle Exterior.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">top-of-ranges</span>

      <span class="c1">;; Bucle Interno.</span>
      <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nb">and</span>
              <span class="c1">;; Necesita el número para el test numérico.</span>
              <span class="p">(</span><span class="nf">car</span> <span class="nv">sorted-lengths</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">sorted-lengths</span><span class="p">)</span> <span class="nv">top-of-range</span><span class="p">))</span>

        <span class="c1">;; Contar número de definiciones con el rango actual.</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-within-range</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">number-within-range</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">sorted-lengths</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">sorted-lengths</span><span class="p">)))</span>

      <span class="c1">;; Sal del bucle interno pero permanece con el bucle externo.</span>

      <span class="p">(</span><span class="nb">setq</span> <span class="nv">defuns-per-range-list</span>
            <span class="p">(</span><span class="nf">cons</span> <span class="nv">number-within-range</span> <span class="nv">defuns-per-range-list</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-within-range</span> <span class="mi">0</span><span class="p">)</span>      <span class="c1">; Resetear el contaje a cero.</span>

      <span class="c1">;; Mover al siguiente rango.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">top-of-ranges</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">top-of-ranges</span><span class="p">))</span>
      <span class="c1">;; Especifica el siguiente mejor rango de valores.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">top-of-range</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">top-of-ranges</span><span class="p">)))</span>

    <span class="c1">;; Salir del bucle externo y contar el número de defuns más</span>
    <span class="c1">;; largas que</span>
    <span class="c1">;; el valor más largo del valor top-of-range.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">defuns-per-range-list</span>
          <span class="p">(</span><span class="nf">cons</span>
           <span class="p">(</span><span class="nf">length</span> <span class="nv">sorted-lengths</span><span class="p">)</span>
           <span class="nv">defuns-per-range-list</span><span class="p">))</span>

    <span class="c1">;; Devuelve una lista del número de definiciones con cada rango,</span>
    <span class="c1">;;  del más pequeño al más largo.</span>
    <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">defuns-per-range-list</span><span class="p">)))</span>
</code></pre>
<p>La función es simple excepto para una pequeña funcionalidad. El test verdadero-o-falso para el bucle interno se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">sorted-lengths</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">sorted-lengths</span><span class="p">)</span> <span class="nv">top-of-range</span><span class="p">))</span>
</code></pre>
<p>en vez de algo como esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">sorted-lengths</span><span class="p">)</span> <span class="nv">top-of-range</span><span class="p">)</span>
</code></pre>
<p>El propósito del test es determinar si el primer ítem en la lista <code>sorted-lengths</code> es menor que el valor de lo mejor del rango.</p>
<p>La versión simple del test trabaja bien a menos que la lista <code>sorted-lengths</code> tiene un valor <code>nil</code>. En este caso, la expresión <code>(car sorted-lengths)</code> devuelve <code>nil</code>. La función <code>&lt;</code> no se puede compara un número a <code>nil</code>, que es una lista vacía, así Emacs señala un error y para la función desde el intento de continuar la ejecución.</p>
<p>La lista <code>sorted-lengths</code> siempre llega a ser <code>nil</code> cuando el contador logra el fin de la lista. Esto significa que cualquier intento de usar la función <code>defuns-per-range</code> con la versión simple del test fallará.</p>
<p>Se resuelve el problema usando <code>(car sorted-lengths)</code> en conjunción con la expresión <code>and</code>. La expresión <code>(car sorted-lengths)</code> devuelve un valor no <code>nil</code> tan largo como la lista que tiene al menos un número con eso, pero devuelve <code>nil</code> si la lista está vacía. La expresión <code>and</code> primero evalúa el <code>(car sorted-lengths)</code>, y si eso es <code>nil</code>, devuelve falso <em>sin</em> evaluar la expresión <code>&lt;</code> y devuelve este valor como el valor de la expresión <code>and</code>.</p>
<p>Este camino, evita un error.  (Para información acerca de <code>and</code>, ver <a href="La-función-kill-new" >La función <code>kill-new</code></a></p>
<p>Aquí hay un pequeño test de la función <code>defuns-per-range</code>. Primero, evalúa la expresión que ajusta (una resumida) lista <code>top-of-ranges</code> a la lista de valores, entonces evalúa la expresión para ajustar la lista <code>sorted-lengths</code>, y entonces evalúa la función <code>defuns-per-range</code>.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; (La lista ordenada que usará después.)</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">top-of-ranges</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="mi">110</span> <span class="mi">120</span> <span class="mi">130</span> <span class="mi">140</span> <span class="mi">150</span>
   <span class="mi">160</span> <span class="mi">170</span> <span class="mi">180</span> <span class="mi">190</span> <span class="mi">200</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setq</span> <span class="nv">sorted-lengths</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="mi">85</span> <span class="mi">86</span> <span class="mi">110</span> <span class="mi">116</span> <span class="mi">122</span> <span class="mi">129</span> <span class="mi">154</span> <span class="mi">176</span> <span class="mi">179</span> <span class="mi">200</span> <span class="mi">265</span> <span class="mi">300</span> <span class="mi">300</span><span class="p">))</span>

<span class="p">(</span><span class="nv">defuns-per-range</span> <span class="nv">sorted-lengths</span> <span class="nv">top-of-ranges</span><span class="p">)</span>
</code></pre>
<p>La lista devuelta se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Dentro, hay dos elementos de la lista <code>sorted-lengths</code> menores de 110, dos elementos entre 110 y 119, dos elementos entre 120 y 129 y así. Hay cuatro elementos con un valor de 200 o superior.</p>
</div>
<h2 id="leyendo-un-grafo" >Leyendo un grafo</h2>
<div class="hBody-2" >
<p>Nuestro objetivo es construir un grafo mostrando los números de definiciones de función de varios tamaños en las fuentes de Emacs lisp.</p>
<p>Como una materia práctica, si se estuviese creando un grafo, probablemente usarías un programa tal como <code>gnuplot</code> para hacer el trabajo. (<code>gnuplot</code> está bien integrado dentro de GNU Emacs.) En este caso, sin embargo, creamos uno desde cero, y en el proceso lo reconstruimos nosotros mismos con algo de lo que se aprende antes y así poder aprender más.</p>
<p>En este capítulo, primero se escribe un grafo simple imprimiendo la función. Esta primera definición será un <dfn>prototipo</dfn>, una función escrita rápidamente nos permite reconocer este territorio de crear un grafo. Se descubren dragones, o resulta que son mitos. Después de olisquear el terreno, nos sentiremos más confidentes y mejoraremos la función para etiquetar las coordenadas automáticamente.</p>
<p>Puesto que Emacs está diseñado para ser flexible y trabajar con todo tipo de terminales, incluyendo los terminales de caracteres, el grafo necesitará ser hecho desde símbolos de ‘escritura’. Un asterisco hará; como nosotros mejoramos la función de impresión del grafo, se puede crear la elección del símbolo como una opción de usuario.</p>
<p>Se puede llamar a esta función <code>graph-body-print</code>; se tomará un <code>numbers-list</code> como su único argumento. En esta fase, no se etiquetará el grafo, pero se imprime su cuerpo.</p>
<p>La función <code>graph-body-print</code> inserta una columna vertical de asteriscos para cada elemento en la lista <code>numbers-list</code>. La altura de cada línea está determinada por el valor de este elemento de la <code>numbers-list</code>.</p>
<p>Insertar columnas es un acto repetitivo; que significa que esta función debe ser escrita con un bucle <code>while</code> o recursivamente.</p>
<p>Nuestro primer reto es descubrir como imprimir una columna de asteriscos. Normalmente, en Emacs, se imprimen caracteres dentro de una pantalla horizontalmente, línea a línea, escribiendo. Se tienen dos rutas que se pueden seguir: escribir nuestra función column-insertion o descubrir si una que exista en Emacs.</p>
<p>Para ver si hay uno en Emacs, se puede usar el comando <kbd>M-x apropos</kbd>. Este comando es como el comando <kbd>C-h a</kbd> (<code>command-apropos</code>), excepto que último encuentra solo estas funciones que son comandos. El comando <kbd>M-x apropos</kbd> lista todos los símbolos que se asocian a una expresión regular, incluyendo funciones que no son interactivas.</p>
<p>Lo que se quiere buscar es algún comando que imprima o inserte columnas. Muy probablemente, el nombre de la función contendrá la palabra ‘print’ o la palabra ‘insert’ o la palabra ‘column’. Por esta razón, podemos simplemente escribir <kbd>M-x apropos RET print \|insert\|column RET</kbd> y se ve el resultado. En mi sistema, este comando toma todavía algún tiempo, y entonces se produce una lista de 79 funciones y variables. Ahora no se tarda mucho y se produce una lista de 211 funciones y variables. Escaneando la lista, la única función que se ve como si se pudiera hacer el trabajo que es <code>insert-rectangle</code>.</p>
<p>En realidad, esta es la función que queremos; su documentación dice:</p>
<div class="example-block" >
<pre class="example" >insert-rectangle:
Insertar texto de RECTANGLE con la esquina izquierda a punto
La primera línea de RECTANGLE es insertada al punto
su segunda línea es insertada a un punto verticalmente
bajo el punto, etc.
El RECTANGLE debería ser una lista de cadenas.
Después de este comando, la marca está en la esquina izquierda
superior y el punto en la esquina derecha inferior.
</pre>
</div>
<p>Se puede ejecutar un test rápido, para asegurar que hace lo que se espera de eso.</p>
<p>Aquí está el resultado de emplazar el cursor después de la expresión <code>insert-rectangle</code> y escribiendo <kbd>C-u C-x C-e</kbd> (<code>eval-last-sexp</code>). La función inserta las cadenas <samp>&#34;primero&#34;</samp>, <samp>&#34;segundo&#34;</samp>, y <samp>&#34;tercero&#34;</samp> en el punto. También la función devuelve <code>nil</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">insert-rectangle</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;primero&#34;</span> <span class="s">&#34;segundo&#34;</span> <span class="s">&#34;tercer&#34;</span><span class="p">))</span><span class="nv">primero</span>
                                              <span class="nv">segundo</span>
                                              <span class="nv">terceronil</span>
</code></pre>
<p>De acuerdo, no se inserta el texto de la expresión <code>insert-rectangle</code> en sí dentro del búfer en el que se marca el grafo, pero se llamará la función de nuestro programa. Nosotros, sin embargo, tenemos que asegurar que el punto está en el búfer en el lugar donde la función <code>insert-rectangle</code> insertará la columna de cadenas.</p>
<p>Si se está leyendo esto en Info, se puede ver como este trabajo cambia a otro búfer, tal como el búfer <span class="file" >*scratch*</span>, emplazando el punto a algún lugar en el búfer, se escribe <kbd>M::</kbd>, después se escribe la expresión <code>insert-rectangle</code> dentro del minibúfer en la consola, y entonces se escribe <kbd>RET</kbd>. Esto causa que Emacs evalúe la expresión en el minibúfer, pero usa como el valor del punto la posición del punto en el búfer <span class="file" >*scratch*</span>. (<kbd>M::</kbd> es el atajo para <code>eval-expression</code>. <code>nil</code> tampoco aparece en el búfer <span class="file" >*scratch*</span> desde que la expresión se evalúa en el minibúfer.)</p>
<p>Se encuentra cuando hacer esto hasta el punto que finaliza al fin de la última línea insertada––es decir, esta función mueve el punto como un efecto secundario. Si se iba a repetir el comando, con el punto en esta posición, la siguiente inserción sería debajo y a la derecha de la inserción previa. ¡Nosotros no queremos esto!. Si se está yendo a crear un gráfico de barras, las columnas necesitan estar debajo unas de otras.</p>
<p>Así se descubre que cada ciclo del bucle <code>while</code> de column-inserting debe reposicionar el punto al lugar que queremos, y este lugar estará arriba, no abajo, de la columna. Más allá, se recuerda que cuando se imprime un grafo, no esperan todas las columnas para estar a la misma altura. Esto significa que el alto de cada columna puede estar a una altura diferente desde una previa. Nosotros simplemente reposicionamos el punto a la misma línea cada vez, pero movido cubriendo a la derecha––o quizás se puede …</p>
<p>Estamos planeando crear las columnas de la barra gráfica sin asteriscos. El número de asteriscos en la columna es el número específico por el elemento actual del <code>numbers-list</code>. Necesitamos construir una lista de asteriscos del tamaño derecho para cada llamada a <code>insert-rectangle</code>. Si esta lista consiste únicamente del número requerido de asteriscos, entonces tendremos la posición de punto el número correcto de líneas bajo la base del gráfico para imprimirse correctamente. Esto podría ser difícil.</p>
<p>Alternativamente, si podemos figurarnos algún camino para pasar <code>insert-rectangle</code> del mismo tamaño cada vez, entonces podemos posicionar el punto en la misma línea cada vez, pero se mueve a través de una columna a la derecha por cada nueva columna. Si hacemos esto, sin embargo, alguna de las entradas en la lista pasaba a <code>insert-rectangle</code> y deben ser espacios en blanco en vez de asteriscos. Por ejemplo, si la altura máxima del grafo es 5, pero la altura de la columna es 3, entonces <code>insert-rectangle</code> requiere un argumento que se parezca a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34; &#34;</span> <span class="s">&#34; &#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span><span class="p">)</span>
</code></pre>
<p>Esta última propuesta no es tan difícil, de hecho se puede determinar la altura de la columna. Hay dos caminos para nosotros especificar la altura de la columna: se puede arbitrariamente situar lo que será, lo que funcionaría bien para gráficas de esta altura; o podemos buscar a través de la lista de números y usar la altura máxima de la lista como la altura máxima del grafo. Si la última operación fuera difícil, entonces el procedimiento formal sería fácil, pero hay una función construida en Emacs para determinar el máximo de sus argumentos. Se puede usar esta función. La función se llamaba <code>max</code> y eso devuelve el mayor de sus argumentos, que deben ser números. De este modo, por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">max</span>  <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>devuelve 7. (Una función correspondiente llamada <code>min</code> devuelve lo más pequeño de todos sus argumentos.)</p>
<p>Sin embargo, no podemos simplemente llama a <code>max</code> en el <code>numbers-list</code>; la función <code>max</code> espera números como sus argumentos, no una lista de números. De este modo, la siguiente expresión,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">max</span>  <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
<p>produce el siguiente mensaje error;</p>
<div class="example-block" >
<pre class="example" >Mal tipo de argumento: number-or-marker-p, (3 4 6 5 7 3)
</pre>
</div>
<p>Se necesita una función que pasa una lista de argumentos a una función. Esta función es <code>apply</code>. Esta función ‘aplica’ su primer argumento (una función) para los argumentos que permanecen, el último puede ser una lista.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">7</span> <span class="mi">3</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">8</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>devuelve 8</p>
<p>(Incidentalmente, yo no sabría cómo aprender acerca de esta función sin un libro tal como este. Eso es posible descubrir otras funciones, como <code>search-forward</code> o <code>insert-rectangle</code>, adivinando una parte de sus nombres y entonces usando <code>apropos</code>. Incluso aunque su base metafórica es clara––‘apply’ su primer argumento al resto––dudo que un novicio vendría con esta palabra particular usando <code>apropos</code> u otra ayuda. De acuerdo, podría ser incorrecto; después de todo, la función fué primero llamada por alguien quien lo había inventado.</p>
<p>El segundo y subsiguientes argumentos para <code>apply</code> son opcionales, así se puede usar <code>apply</code> para llamar a una función y pasan los elementos de una lista, como este, que también devuelve 8:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="mi">8</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>Este camino tardío usará <code>apply</code>. La función <code>recursive-lengths-list-many-files</code> devuelve una lista de números que se puede aplicar a <code>max</code> (se podría también aplicar <em>(hacer apply)</em> a la lista de números ordenados; eso no importa si la lista está o no).</p>
<p>Aquí, la operación para encontrar el tamaño máximo del grafo es este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">max-graph-height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">numbers-list</span><span class="p">))</span>
</code></pre>
<p>Ahora se puede devolver la pregunta de como crear una lista de cadenas para una columna del grafo. Cuenta la máxima altura del grafo y el número de asteriscos que aparecerían en la columna, la función devolverá una lista de cadenas para el comando a insertar <code>insert-rectangle</code>.</p>
<p>Cada columna se realiza con asteriscos o espacios en blanco. Puesto que la función pasa el valor del alto de la columna y el número de asteriscos en el columna, el número de espacios en blanco puede ser encontrado sustrayendo el número de asteriscos desde lo alto de la columna. Dado el número de espacios en blanco y el número de asteriscos, dos bucles <code>while</code> puede ser usado para construir la lista:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Primera versión.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">column-of-graph</span> <span class="p">(</span><span class="nv">max-graph-height</span> <span class="nv">actual-height</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista de cadenas que una columna de un grafo.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">insert-list</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">number-of-top-blanks</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">max-graph-height</span> <span class="nv">actual-height</span><span class="p">)))</span>

    <span class="c1">;; Llenar asteriscos.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">actual-height</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">insert-list</span> <span class="p">(</span><span class="nf">cons</span> <span class="s">&#34;*&#34;</span> <span class="nv">insert-list</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">actual-height</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">actual-height</span><span class="p">)))</span>

    <span class="c1">;; Rellena espacios en blanco.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-top-blanks</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">insert-list</span> <span class="p">(</span><span class="nf">cons</span> <span class="s">&#34; &#34;</span> <span class="nv">insert-list</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-top-blanks</span>
            <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-top-blanks</span><span class="p">)))</span>

    <span class="c1">;; Devuelve la lista completa.</span>
    <span class="nv">insert-list</span><span class="p">))</span>
</code></pre>
<p>Si se instala esta función y entonces evalúa la siguiente expresión se verá que devuelve la lista como se desea:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">column-of-graph</span> <span class="mi">5</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>devuelve</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34; &#34;</span> <span class="s">&#34; &#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span> <span class="s">&#34;*&#34;</span><span class="p">)</span>
</code></pre>
<p>Como está escrito, <code>column-of-graph</code> contiene una grieta mayor: los símbolos usados para el espacio en blanco para las entradas marcadas en la columna son ‘codificadas duras’ como un espacio y un asterisco. Esto está bien para un prototipo, pero tu, u otro usuario, puede desear usar otros símbolos. Por ejemplo, chequeando la función grafo, tu quieres usar un periodo en vez del espacio, asegura el punto que está siendo reposicionando apropiadamente cada vez que la función <code>insert-rectangle</code> se llama; o se podría querer sustituir un signo <samp>+</samp> u otro símbolo para el asterisco. Se podría incluso querer hacer un graph-column que es más que un ancho de columna. El programa debería ser más flexible. El camino para hacer esto es reemplazar el espacio en blanco y el asterisco con dos variables que se puede llamar <code>graph-blank</code> y <code>graph-symbol</code> y define estas variables separadamente.</p>
<p>También la documentación no está escrita. Estas consideraciones nos llevan también a la segunda versión de la función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">graph-symbol</span> <span class="s">&#34;*&#34;</span>
  <span class="s">&#34;Cadena usada como símbolo en grafo, normalmente un asterisco.&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defvar</span> <span class="nv">graph-blank</span> <span class="s">&#34; &#34;</span>
  <span class="s">&#34;La cadena como un espacio en blanco en grafo, normalmente un
</span><span class="s">  espacio en blanco.
</span><span class="s">graph-blank debe ser el mismo número de columnas amplio como graph-symbol.&#34;</span><span class="p">)</span>
</code></pre>
<p>(Para una explicación de <code>defvar</code>, ver <a href="Inicializando-una-Variable-con-defvar" >Inicializando una Variable con <code>defvar</code></a>.)</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Segunda versión.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">column-of-graph</span> <span class="p">(</span><span class="nv">max-graph-height</span> <span class="nv">actual-height</span><span class="p">)</span>
  <span class="s">&#34;Devuelve cadenas MAX-GRAPH-HEIGHT; ACTUAL-HEIGHT son
</span><span class="s">  símbolos de grafos.
</span><span class="s">
</span><span class="s">Los graph-symbols son entradas contiguo al fin de la lista.
</span><span class="s">La lista será insertado como una columna de un grafo.
</span><span class="s">Las cadenas son tanto graph-blank o graph-symbol.
</span><span class="s">
</span><span class="s">  (let ((insert-list nil)
</span><span class="s">        (number-of-top-blanks
</span><span class="s">         (- max-graph-height actual-height)))
</span><span class="s">
</span><span class="s">    ;; @e{Rellenar en @c{graph-symbols}.}
</span><span class="s">    (while (&gt; actual-height 0)
</span><span class="s">      (setq insert-list (cons graph-symbol insert-list))
</span><span class="s">      (setq actual-height (1- actual-height)))
</span><span class="s">
</span><span class="s">    ;; @e{Rellenar en @c{graph-blanks}.}
</span><span class="s">    (while (&gt; number-of-top-blanks 0)
</span><span class="s">      (setq insert-list (cons graph-blank insert-list))
</span><span class="s">      (setq number-of-top-blanks
</span><span class="s">            (1- number-of-top-blanks)))
</span><span class="s">
</span><span class="s">    ;; Devuelve la lista completa.
</span><span class="s">    insert-list))
</span><span class="s"></span></code></pre>
<p>Si se desea, podríamos reescribir <code>column-of-graph</code> una tercera vez para proporcionar opcionalmente un gráfico de líneas, como gráfico de barras. Esto no sería duro de hacer. Un camino para pensar en un grafo de líneas es que no es más que un grafo de barras en el que la parte de cada barra que está debajo del alto es blanco. Para construir una columna para gráfico de líneas, la función primero construyen una lista de espacios en blanco que es una más ordenada que el valor, entonces usa <code>cons</code> para adjuntar un símbolo gráfico a la lista; entonces eso usa <code>cons</code> de nuevo para adjuntar el ‘alto de espacios en blanco’ a la lista.</p>
<p>Es fácil ver como escribir tal función, pero puesto que no se necesita eso, no se hará. Pero el trabajo podría ser hecho, y si eso se hiciera, se haría con <code>column-of-graph</code>. Incluso más importante, no se valora nada más que pocos cambios que tendrían que ser hechos de cualquier otra manera. La mejora, que se desea hacer, es simple.</p>
<p>Ahora, finalmente, volvemos a nuestra primera función de grafo impresa. Esto imprime el cuerpo de un grafo, no las etiquetas para los ejes horizontal y vertical, así se puede llamar este <code>graph-body-print</code>.</p>
</div>
<h3 id="la-función-graph-body-print" >La función <code>graph-body-print</code></h3>
<div class="hBody-3" >
<p>Después de nuestra preparación en la sección precedente, la función <code>graph-body-print</code> es simple. La función imprimirá la columna después de la columna de asteriscos y espacios en blanco, usando los elementos de la lista de números para especificar el número de asteriscos en cada columna. Esto es un acto repetitivo, que significa que se puede usar un bucle <code>while</code> que decrementa o una función recursiva para el trabajo. En esta sección, se escribirá la definición usando un bucle <code>while</code>.</p>
<p>La función <code>column-of-graph</code> requiere el alto del grafo como un argumento, así se asigna y guarda esto como una variable local.</p>
<p>Esto lidera a la siguiente plantilla para el bucle <code>while</code> versión de esta función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">graph-body-print</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span>  <span class="err">…</span>
         <span class="err">…</span><span class="p">))</span>

    <span class="p">(</span><span class="nb">while</span> <span class="nv">numbers-list</span>
      <span class="nv">@V{insert-columns-and-reposition-point}</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numbers-list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">numbers-list</span><span class="p">)))))</span>
</code></pre>
<p>Necesitamos rellenar los slots de la plantilla.</p>
<p>Claramente, se puede usar la expresión <code>(apply &#39;max numbers-list)</code> para determinar el alto del grafo.</p>
<p>El bucle <code>while</code> iterará a través de <code>numbers-list</code> un elemento a la vez. Como eso está ordenado por la expresión <code>(setq numbers-list (cdr numbers-list))</code>, el <code>car</code> de cada instancia de la lista es el valor del argumento para <code>column-of-graph</code>.</p>
<p>En cada ciclo del bucle <code>while</code>, la función <code>insert-rectangle</code> inserta la lista devuelta por <code>column-of-graph</code>. Desde que la función <code>insert-rectangle</code>, se necesita guardar la localización de punto al tiempo que el rectángulo se inserta, mueve atrás a esta posición después de que el rectángulo es insertado, y entonces se mueve horizontalmente al siguiente lugar desde el que <code>insert-rectangle</code> se llama.</p>
<p>Si las columnas se insertan en un carácter amplio, será si los espacios en blanco y asteriscos se usan, el comando de reposición es simple <code>(forward-char 1)</code>; sin embargo, el ancho de una columna puede ser más grande que uno. Esto significa que el comando de reposicionamiento sería escrito <code>(forward-char symbol-width)</code>. El mejor lugar para asociar la variable <code>symbol-width</code> al valor del width de la columna grafo está en la varlist de la expresión <code>let</code>.</p>
<p>Estas consideraciones lideran a la siguiente definición de función:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">graph-body-print</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;Imprime un gráfico de barras de la NUMBERS-LIST.
</span><span class="s">La numbers-list consiste en los valores del eje Y.&#34;</span>

  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">numbers-list</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">symbol-width</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">graph-blank</span><span class="p">))</span>
        <span class="nv">from-position</span><span class="p">)</span>

    <span class="p">(</span><span class="nb">while</span> <span class="nv">numbers-list</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">from-position</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">insert-rectangle</span>
       <span class="p">(</span><span class="nv">column-of-graph</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">numbers-list</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">from-position</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">symbol-width</span><span class="p">)</span>
      <span class="c1">;; Dibuja la columna del grafo por columna.</span>
      <span class="p">(</span><span class="nv">sit-for</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numbers-list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">numbers-list</span><span class="p">)))</span>
    <span class="c1">;; Emplaza el punto para etiquetas de ejes X.</span>
    <span class="p">(</span><span class="nf">forward-line</span> <span class="nv">height</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
<span class="p">))</span>
</code></pre>
<p>La expresión inesperada en esta función es la expresión <code>(sit-for 0)</code> en el bucle <code>while</code>. Esta expresión hace que el grafo imprima la operación más interesante para vigilar lo que sería de otro modo. La expresión causa que Emacs pare (sit-for 0) para un momento cero y entonces redibuje la pantalla. Puesto aquí, eso causa que Emacs redibuje la pantalla columna por columna. Sin eso, Emacs no redibujaría la pantalla hasta que la función exista.</p>
<p>Se puede chequear <code>graph-body-print</code> con una pequeña lista de números.</p>
<ol class="num" >
<li>
<p>Instala <code>graph-symbol</code>, <code>graph-blank</code>, <code>column-of-graph</code>, que están en <a href="Leyendo-un-grafo" >Leyendo un grafo</a>, and <code>graph-body-print</code>.</p>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">graph-body-print</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde quiere que el grafo empiece.</p>
</li>
<li>
<p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pega la expresión <code>graph-body-print</code> dentro del minibúfer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión <code>graph-body-print</code>.</p>
</li>
</ol>
<p>Emacs imprimirá un grafo como este:</p>
<div class="example-block" >
<pre class="example" >        *
    *   **
    *  ****
   *** ****
  ********* *
 ************
*************
</pre>
</div>
</div>
<h3 id="la-función-recursive-graph-body-print" >La función <code>recursive-graph-body-print</code></h3>
<div class="hBody-3" >
<p>La función <code>graph-body-print</code> puede también ser escrito recursivamente. La solución recursiva es dividida dentro de dos partes: una fuera ‘wrapper’ <em>envoltorio</em> que usa una expresión <code>let</code> para determinar los valores varias variables que solo necesitan ser encontradas una vez, tal como la máxima altura del grafo, y una función dentro que es llamada recursivamente para imprimir el grafo.</p>
<p>El ‘envoltorio’ no es complicado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">recursive-graph-body-print</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;Imprime un gráfico de barras del NUMBERS-LIST.
</span><span class="s">El numbers-list consiste en los valores del eje Y.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">numbers-list</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">symbol-width</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">graph-blank</span><span class="p">))</span>
        <span class="nv">from-position</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">recursive-graph-body-print-internal</span>
     <span class="nv">numbers-list</span>
     <span class="nv">height</span>
     <span class="nv">symbol-width</span><span class="p">)))</span>
</code></pre>
<p>La función recursiva es un poco más difícil. Eso tiene cuatro partes: el ‘do-again-test’, el código impreso, la llamada recursiva, y la ‘next-step-expression’. El ‘do-again-test’ es una expresión <code>when</code> determina si la <code>numbers-list</code> contiene cualquier elemento que permanece; si hace eso, la función imprime una columna del grafo usando el código impreso y se llama así mismo de nuevo. La función se llama así misma de nuevo de acuerdo al valor producido por la ‘next-step-expression’ que causa para llamar a actuar en una versión ordenada de la <code>numbers-list</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">recursive-graph-body-print-internal</span>
  <span class="p">(</span><span class="nv">numbers-list</span> <span class="nv">height</span> <span class="nv">symbol-width</span><span class="p">)</span>
  <span class="s">&#34;Imprime un gráfico de barras.
</span><span class="s">Usado con la función recursive-graph-body-print.&#34;</span>

  <span class="p">(</span><span class="nb">when</span> <span class="nv">numbers-list</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">from-position</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
        <span class="p">(</span><span class="nv">insert-rectangle</span>
         <span class="p">(</span><span class="nv">column-of-graph</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">numbers-list</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">from-position</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">symbol-width</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">sit-for</span> <span class="mi">0</span><span class="p">)</span>     <span class="c1">; Dibuja un gráfico columna por columna.</span>
        <span class="p">(</span><span class="nv">recursive-graph-body-print-internal</span>
         <span class="p">(</span><span class="nf">cdr</span> <span class="nv">numbers-list</span><span class="p">)</span> <span class="nv">height</span> <span class="nv">symbol-width</span><span class="p">)))</span>
</code></pre>
<p>Después de la siguiente instalación, esta expresión puede ser chequeada; aquí hay un ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">recursive-graph-body-print</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<p>Aquí está lo que <code>recursive-graph-body-print</code> produce:</p>
<div class="example-block" >
<pre class="example" >    *
   **   *
  ****  *
  **** ***
* *********
************
*************
</pre>
</div>
<p>Cada una de estas dos funciones, <code>graph-body-print</code> o <code>recursive-graph-body-print</code>, crea el cuerpo de un grafo.</p>
</div>
<h3 id="necesidad-para-ejes-impresos" >Necesidad para ejes impresos</h3>
<div class="hBody-3" >
<p>Un grafo necesita ejes impresos, así se puede orientar a tí mismo. Para un proyecto do-once, eso puede ser razonable dibujar los ejes a mano usando el modo de emacs Picture, pero un grafo dibuja la función que puede ser usada más de una vez.</p>
<p>Por esta razón, se han escrito mejoras a la función básica <code>print-graph-body</code> que automáticamente imprime etiquetas para los ejes horizontal y vertical. Puesto que la etiqueta de imprimir funciones no contiene mucho material nuevo, se ha emplazado su descripción en un apéndice Vea la Seccion <a href="Un-Grafo-con-Ejes-Etiquetados" >Un Grafo con Ejes Etiquetados</a>.</p>
</div>
<h3 id="ejercicio" >Ejercicio</h3>
<div class="hBody-3" >
<p>Escribe una versión de línea de grafo de la funciones de impresión del grafo.</p>
</div>
<h2 id="tu-fichero-.emacs" >Tu fichero <span class="file" >.emacs</span></h2>
<div class="hBody-2" >
<p>“No te tiene que gustar Emacs para lo que te gusta”––esto que parece una frase paradójica es el secreto de GNU Emacs. En realidad, Emacs es una herramienta genérica. La mayoría de la gente que usa Emacs, lo personaliza para ajustarlo a sus necesidades.</p>
<p>GNU Emacs está mayoritariamente escrito en Emacs Lisp; esto significa que escribiendo expresiones en Emacs Lisp se puede modificar o extender Emacs.</p>
<p>Hay quien aprecia la configuración por defecto de Emacs. Después de todo, Emacs empieza en modo C cuando se edita un fichero C, empieza en modo Fortran cuando se edita un fichero Fortran, y empieza en modo Fundamental cuando se edita un fichero no adornado. Esto tiene sentido, si no sabes quien está yendo a usar Emacs. ¿Quién sabe lo que una persona espera hacer con un fichero no adornado? El modo fundamental es el modo correcto por defecto para tal fichero, tal como el modo C es lo correcto para editar código C. (Suficientes lenguajes de programación tienen sintaxis que permiten compartir funcionalidades, tal como el modo C es ahora proporcionado por el modo CC, la ‘Colección C’.)</p>
<p>Pero cuando se conoce quien está yendo a usar Emacs––tu, tu mismo––entonces eso tiene sentido para personalizar Emacs.</p>
<p>Por ejemplo, yo raramente quiero el modo Fundamental cuando edito un fichero de otro modo no distinguido; yo quiero el modo Texto. Esto es por lo que yo personalizo Emacs: así eso se ajusta a mí.</p>
<p>Se puede personalizar y extender Emacs escribiendo o adaptando un fichero <span class="file" >~/.emacs</span>. Esto es un fichero de inicialización personal; sus contenidos, escritos en Emacs Lisp, cuentan a Emacs qué hacer.<span class="note" ><sup><a href="#13" >13</a></sup></span></p>
<p>Un fichero <span class="file" >~/.emacs</span> contiene código Emacs Lisp. Se puede escribir este código por uno mismo; o se puede usar la funcionalidad <code>customize</code> para escribir el código para ti. Se puede combinar tus propias expresiones y expresiones auto-escritas personalizadas en tu fichero <span class="file" >.emacs</span>.</p>
<p>(Yo prefiero por mí mismo escribir mis propias expresiones, excepto para estas, fuentes particularmente, que se encuentran fáciles de manipular usando el comando <code>customize</code>. Yo combino los dos métodos.)</p>
<p>La mayoría de este capítulo es acerca de escribir expresiones por uno mismo. Eso describe un fichero <span class="file" >.emacs</span> simple; para más información, mira <q>El Fichero de Inicio</q> en <em>El Manual GNU Emacs</em>, y la Seccion <q>El Fichero de Inicio</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
</div>
<h3 id="fichero-de-inicialización-site-wide" >Fichero de inicialización site-wide</h3>
<div class="hBody-3" >
<p>Además de tu fichero de inicialización personal, Emacs automáticamente carga varios ficheros de inicialización amplios, si existen. Tienen la misma forma que tu fichero <span class="file" >.emacs</span>, pero se cargan por cualquiera.</p>
<p>Dos ficheros de incialización, <span class="file" >site-load.el</span> y <span class="file" >site-init.el</span>, están cargados dentro de Emacs y volcados <em>dumped</em> sin una versión dumped de Emacs se creó, como es más común. (Las copias dumped de Emacs cargan más rápidamente. Sin embargo, puesto que un fichero se carga y compila, un cambio no llega a ser un cambio en Emacs a menos que se cargue por uno mismo o se recompile Emacs. Vea la Seccion <q>Construyendo Emacs</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, y el fichero <span class="file" >INSTALL</span>)</p>
<p>Los otros tres ficheros de inicialización se cargan automáticamente cada vez que se inicia Emacs, si existen. Son <span class="file" >site-start.el</span>, que se carga <em>antes</em> que tu fichero <span class="file" >.emacs</span>, y <span class="file" >default.el</span>, y el tipo de fichero terminal, que se cargan <em>después</em> de tu fichero <span class="file" >.emacs</span>.</p>
<p>Las configuraciones y definiciones en tu fichero <span class="file" >.emacs</span> sobreescribirán las configuraciones en conflicto y definiciones en un fichero <span class="file" >site-start.el</span>, si eso existe; pero las configuraciones y definiciones en un <span class="file" >default.el</span> o el tipo de fichero terminal sobreescribirá estos en tu fichero <span class="file" >.emacs</span>. (Se pueden prevenir interferencias desde un tipo de fichero terminal configurando <code>term-file-prefix</code> para <code>nil</code>. Vea la Seccion <a href="Una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></a>.)</p>
<p>El fichero <span class="file" >INSTALL</span> que viene en la distribución contiene descripciones de los fichero <span class="file" >site-init.el</span> y <span class="file" >site-load.el</span>.</p>
<p>Los ficheros <span class="file" >loadup.el</span>, <span class="file" >startup.el</span>, y <span class="file" >loaddefs.el</span> controlan la carga. Estos ficheros están en el directorio <span class="file" >lisp</span> de la distribución Emacs y tiene valor de uso.</p>
<p>El fichero <span class="file" >loaddefs.el</span> contiene buenas sugerencias como las que poner dentro de tu propio fichero <span class="file" >.emacs</span>, o dentro de un fichero de inicialización amplio.</p>
</div>
<h3 id="especificar-variables-usando-defcustom" >Especificar variables usando <code>defcustom</code></h3>
<div class="hBody-3" >
<p>Se pueden especificar variables usando <code>defcustom</code> así que la gente pueda usar la funcionalidad de Emacs <code>customize</code> para asignar sus valores. (No se puede usar <code>customize</code> para escribir definiciones de función; pero se pueden escribir <code>defuns</code> en tu fichero <span class="file" >.emacs</span>. En vez de eso, se puede escribir cualquier expresión Lisp en tu fichero <span class="file" >.emacs</span>).</p>
<p>La funcionalidad <code>customize</code> depende de la forma especial <code>defcustom</code>. Aunque se puede usar <code>defvar</code> o <code>setq</code> para las variables que los usuarios asignan, la forma especial <code>defcustom</code> está diseñada para el trabajo.</p>
<p>Se puede usar tu conocimiento de <code>defvar</code> para escribir los primeros tres argumentos para <code>defcustom</code>. El primer argumento para <code>defcustom</code> es el nombre de la variable. El segundo argumento es el valor inicial de la variable, cualquiera; y este valor es asignado solo si el valor no ha sido ya asignado. El tercer argumento es la documentación.</p>
<p>El cuarto y subsiguientes argumentos para <code>defcustom</code> especifican los tipos y opciones; estos no son funcionales en <code>defvar</code>. (Estos argumentos son opcionales.)</p>
<p>Cada uno de estos argumentos consiste de una palabra seguido de una palabra por un valor. Cada palabra clave empieza con los dos puntos <samp>:</samp>.</p>
<p>Por ejemplo, la variable de opciones personalizable <code>text-mode-hook</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defcustom</span> <span class="nv">text-mode-hook</span> <span class="no">nil</span>
  <span class="s">&#34;El hook normal se ejecuta cuando se introduce en modo texto y
</span><span class="s">  muchos modos relacionados.&#34;</span>
  <span class="nb">:type</span> <span class="ss">&#39;hook</span>
  <span class="nb">:options</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">turn-on-auto-fill</span> <span class="nv">flyspell-mode</span><span class="p">)</span>
  <span class="nb">:group</span> <span class="ss">&#39;data</span><span class="p">)</span>
</code></pre>
<p>El nombre de la variable es <code>text-mode-hook</code>; no tiene valor por defecto; y su cadena de documentación cuenta lo que hace.</p>
<p>La palabra clave <code>:type</code> le cuenta a Emacs el tipo de datos para los que <code>text-mode-hook</code> sería asignado y como muestra el valor en un búfer de Personalización.</p>
<p>La palabra clave <code>:options</code> especifica una lista sugerida de valores para la variable. Normalmente, <code>:options</code> se asocia a un gancho (<em>hook</em>. La lista es solo una sugerencia; esa no es exclusiva; una persona quien asigna la variable puede asignarse a otros valores; la lista mostrada siguiendo la palabra clave <code>:options</code> se pretende ofrecer elecciones convenientes a un usuario.</p>
<p>Finalmente, la palabra clave <code>:group</code> cuenta el comando de Personalización de Emacs en el que el grupo de la variable está localizado. Esto cuenta dónde encontralo.</p>
<p>La función <code>defcustom</code> reconoce más de una docena de palabras clave. Para más información, mire <q>Escribiendo las Definiciones de Personalización</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
<p>Considere <code>text-mode-hook</code> como un ejemplo.</p>
<p>Hay dos caminos para personalizar esta variable. Se puede usar el comando de personalización o escribir las expresiones apropiadas por uno mismo.</p>
<p>Usando el comando de personalización, se puede escribir:</p>
<div class="example-block" >
<pre class="example" >M-x customize
</pre>
</div>
<p>y encuentre que el grupo para editar ficheros de datos se llama ‘datos’. Introduzca este grupo. El Hook <em>Disparador</em> es el primer miembro. Se puede hacer click en sus opciones varias, tal como <code>turn-on-auto-fill</code>, para asignar los valores. Después de hacer click en el botón.</p>
<div class="example-block" >
<pre class="example" >Guárdalo para Futuras Sesiones
</pre>
</div>
<p>Emacs escribirá una expresión en tu fichero <span class="file" >.emacs</span>. Se parecerá a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">custom-set-variables</span>
  <span class="c1">;; custom-set-variables fué añadido por Custom.</span>
  <span class="c1">;; Si se edita a mano, tu podrías liarte,</span>
  <span class="c1">;; así que ten cuidado.</span>
  <span class="c1">;; Tu fichero init contendría solo esta instancia.</span>
  <span class="c1">;; Si hay más de uno, ellos no quieren trabajar.</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="nv">text-mode-hook</span> <span class="p">(</span><span class="nb">quote</span> <span class="p">(</span><span class="nv">turn-on-auto-fill</span> <span class="nv">text-mode-hook-identify</span><span class="p">))))</span>
</code></pre>
<p>(La función <code>text-mode-hook-identify</code> cuenta <code>toggle-text-mode-auto-fill</code> que buffers hay en modo Texto. Eso viene automáticamente)</p>
<p>La función <code>custom-set-variables</code> funciona de alguna manera diferente más de un <code>setq</code>. Mientras yo nunca he aprendido las diferencias, yo modifico las expresiones <code>custom-set-variable</code> en mi fichero <span class="file" >.emacs</span> a mano: yo creo los cambios en los que aparecen a mi para ser una manera razonable y no tener problemas. Otros prefieren usar el comando de Personalización y permitir a Emacs hacer el trabajo para ellos.</p>
<p>Otra función <code>custom-set-…</code> es <code>custom-set-faces</code>. Esta función asigna varios tipos de fuentes. A través del tiempo, yo he asignado un considerable número de tipos. Algo de tiempo, yo las reseteo usando <code>customize</code>; otras veces, simplemente edito la expresión <code>custom-set-faces</code> en mi fichero <span class="file" >.emacs</span> en sí.</p>
<p>El segundo modo de personalizar tu <code>text-mode-hook</code> es asignarte a tí mismo en tu fichero <span class="file" >.emacs</span> usando código que no tiene nada que hacer con las funciones <code>custom-set-…</code>.</p>
<p>Cuando se hace esto, y después usa <code>customize</code>, se verá un mensaje que dice:</p>
<div class="example-block" >
<pre class="example" >CHANGED fuera de Personalizar; operando dentro aquí
puede ser no confiable.
</pre>
</div>
<p>Este mensaje es solo un aviso. Si se puede cliquear en el botón a</p>
<div class="example-block" >
<pre class="example" >Guárdalo para Futuras Sesiones
</pre>
</div>
<p>Emacs escribirá una expresión <code>custom-set-…</code> cerca del fin de tu fichero <span class="file" >.emacs</span> que será evaluado después de que tu expresión sea escrita a mano. Por esta razón, se sobreescribirá tu expresión escrita a mano. Ningún daño será hecho. Cuando se haga esto, sin embargo, ten cuidado para recordar que expresión está activa; si olvidas, puedes confundirte por tí mismo.</p>
<p>Tan largo como se recuerda donde los valores son configurados, no habrá problemas. En cualquier eventos, los valores son siempre configurados en tu fichero de inicialización, que es normalmente llamado <span class="file" >.emacs</span>.</p>
<p>Yo mismo hago un <code>customize</code> para cualquier cosa. Mayoritariamente, escribo expresiones por mí mismo.</p>
<p>Incidentalmente, para ser una definición concerniente más completa: <code>defsubst</code> define una función inline. La sintaxis es solo como esta de <code>defun</code>. <code>defconst</code> define un símbolo como una constante. El intento es que ningún programa o usuario cambiarían un valor asignado por <code>defconst</code>. (Se puede cambiar; el valor asignado es una variable; pero por favor no lo haga.)</p>
</div>
<h3 id="empieza-por-un-fichero-.emacs" >Empieza por un fichero <span class="file" >.emacs</span></h3>
<div class="hBody-3" >
<p>Cuando se abre Emacs, se carga tu fichero <span class="file" >.emacs</span> a menos que se cuente que no se especifique <samp>-q</samp> en la línea de comandos. (El comando <code>emacs -q</code> tu da un Emacs plano, fuera.)</p>
<p>Un fichero <span class="file" >.emacs</span> contiene expresiones Lisp. Con frecuencia, no hay más expresiones para configura valores; algunas veces esas son definiciones de funciones.</p>
<p>Vea la Seccion <a href="info:emacs#Init-File" >El Fichero de Inicio</a> <span class="file" >~/.emacs</span> en <em>El Manual GNU Emacs</em>, para una corta descripción de fichero de inicialización.</p>
<p>Este capítulo cubre algo del mismo suelo, pero es un paseo entre extractos desde un completo, largamente usado fichero <span class="file" >.emacs</span>––por mí.</p>
<p>La primera parte del fichero consiste en comentario: me recuerdo a mí mismo. Por ahora, yo recuerdo estas cosas, pero cuando empecé, no.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;;; fichero .emacs de Bob</span>
<span class="c1">; Robert J. Chassell</span>
<span class="c1">; 26 de Septiembre de 1985</span>
</code></pre>
<p>¡Mira en esta fecha! Yo empecé este fichero hace mucho tiempo. Yo he estado añadiendo cosas desde siempre.</p>
<pre class="code" ><code class="chroma" ><span class="c1">; Cada sección en este fichero es introducido por una</span>
<span class="c1">; línea empezando con cuatro puntos y comas y cada</span>
<span class="c1">; entrada es introducida por una línea empezando con</span>
<span class="c1">; tres puntos y comas.</span>
</code></pre>
<p>Esto describe las convenciones usuales para comentarios en Emacs Lisp. Cada cosa en una línea que sigue un punto y coma es un comentario. Dos, tres, y cuatro puntos y coma son usados como subsección y marcas de sección. (Vea la Seccion <q>Comentarios</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más comentarios.)</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;;; La Tecla de Ayuda</span>
<span class="c1">; Control-h es la tecla de ayuda;</span>
<span class="c1">; después escribiendo control-h, escribe una letra a</span>
<span class="c1">; indica el asunto acerca del que quieres ayuda.</span>
<span class="c1">; Para una explicación de la facilidad de ayuda,</span>
<span class="c1">; escribe control-h dos veces en una fila.</span>
</code></pre>
<p>Solo recuerda: escribe <kbd>C-h</kbd> dos veces para ayudar.</p>
<pre class="code" ><code class="chroma" ><span class="c1">; Para informarse acerca de cualquier modo, escribe control-h m</span>
<span class="c1">; mientras esté en este modo. Por ejemplo, para encontrar</span>
<span class="c1">; acerca del modo correo, introduce el modo correo y entonces</span>
<span class="c1">; escribe control-h m.</span>
</code></pre>
<p>‘Modo ayuda’, como yo llamo a esto, es muy útil. Usualmente, se cuenta todo lo que se necesita saber.</p>
<p>De acuerdo, no se necesitan incluir comentarios y ficheros como estos <span class="file" >.emacs</span>. Yo los incluí en el mío porque se olvida el Modo ayuda o las convenciones para comentarios––pero era capaz de recordar ver aquí recordármelo a mí mismo.</p>
</div>
<h3 id="modo-texto-y-auto-relleno" >Modo texto y auto relleno</h3>
<div class="hBody-3" >
<p>Ahora regresa a la parte que ‘vuelve’ al modo Texto y modo Auto Relleno.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Modo texto modo Auto Fill</span>
<span class="c1">;; Las siguiente dos líneas puestas en Emacs dentro de</span>
<span class="c1">;; modo Texto y en el modo Auto Fill, son para escritores que</span>
<span class="c1">;; quieren empezar a escribir prosa en vez de código.</span>
<span class="p">(</span><span class="nb">setq-default</span> <span class="nv">major-mode</span> <span class="ss">&#39;text-mode</span><span class="p">)</span>
<span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;text-mode-hook</span> <span class="ss">&#39;turn-on-auto-fill</span><span class="p">)</span>
</code></pre>
<p>¡Aquí está la primera parte de este fichero <span class="file" >.emacs</span> que hace alguna cosa bajo recuerdo de un humano olvidado!</p>
<p>La primera de las dos líneas entre paréntesis cuentan a Emacs a cambiar al modo Texto que se encuentra un fichero, <em>a menos que</em> el fichero iría dentro de algún otro modo, tal como el modo C.</p>
<p>Cuando Emacs lee un fichero, eso parece la extensión al nombre del fichero. (La extensión es la parte que viene después de un <samp>.</samp>.) Si el fichero finaliza con una extensión <samp>.c</samp> o <samp>.h</samp> entonces Emacs cambia al modo C. También, Emacs parece al principio una línea no blanca del fichero; si la línea dice <samp>-*- C -*-</samp>, Emacs cambia al modo C. Emacs posee una lista de extensiones y especificaciones que usa automáticamente. Además, Emacs se ve cerca de la última página por buffer, “lista variables locales”.</p>
<p>Mira las secciones “Cómo los Modos Mayores son Elegidos” y “Variables Locales en Fichero” en <em>El Manual GNU Emacs</em>.</p>
<p>Ahora, regresa al fichero <span class="file" >.emacs</span>.</p>
<p>Aquí está la línea de nuevo; ¿cómo funciona?</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">major-mode</span> <span class="ss">&#39;text-mode</span><span class="p">)</span>
</code></pre>
<p>Esta línea es un resumen, pero completa la expresión Emacs Lisp.</p>
<p>Ya estamos familiarizados con <code>setq</code>. Eso asigna la siguiente variable, <code>major-mode</code>, al subsiguiente valor, que es <code>text-mode</code>. La marca de cita simple antes de <code>text-mode</code> cuenta a Emacs como tratar directamente con el símbolo, no con cualquier cosa que pudiera existir. Vea la Seccion <a href="Configurando-el-Valor-de-una-Variable" >Configurando el Valor de una Variable</a>, por un recuerdo de como <code>setq</code> funciona. El principal punto es que no hay diferencia entre el procedimiento que se usa para asignar un valor en su fichero <span class="file" >.emacs</span> y el procedimiento que se usa en cualquier lugar más en Emacs.</p>
<p>Aquí está la siguiente línea:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;text-mode-hook</span> <span class="ss">&#39;turn-on-auto-fill</span><span class="p">)</span>
</code></pre>
<p>En esta línea, el comando <code>add-hook</code> añade <code>turn-on-auto-fill</code> para la variable.</p>
<p>¡<code>turn-on-auto-fill</code> es el nombre de un programa, que se adivina!, cambia al modo Auto Fill.</p>
<p>Cada vez que Emacs cambia al modo texto, Emacs ejecuta el comando ‘hooked’ dentro de modo Texto. Así que cada vez que Emacs cambia al modo Texto, Emacs también cambia al modo de autoajuste.</p>
<p>En breve, la primera línea causa a Emacs a entrar en modo Texto cuando se edite un fichero, a menos que la extensión del nombre del fichero, una línea no en blanco, variables locales para contar a Emacs de otro modo.</p>
<p>El modo texto entre otras acciones, asigna la tabla de sintaxis para trabajar adecuadamente a escritores. En modo texto, Emacs considera un apóstrofe como parte de una palabra como una letra; pero Emacs no considera un período o un espacio como parte de una palabra. De este modo, <kbd>M-f</kbd> se mueve hacia tí a través de <samp>eso</samp>. Por otro lado, en modo C, <kbd>M-f</kbd> para solo después del <samp>t</samp> de <samp>eso</samp>.</p>
<p>La segunda línea causa que Emacs active el modo Auto Fill cuando cambia al modo Texto. En modo Auto Fill, Emacs automáticamente rompe una línea que es demasiado amplio y trae la parte excesivamente amplia de la línea de debajo a la siguiente línea. Emacs rompe líneas entre palabras con ellas.</p>
<p>Cuando el modo Auto Fill está desactivado, las líneas continúan a la derecha como se escriben. Dependiendo de como configuras el valor de <code>truncate-lines</code>, las palabras que se escribe si desaparecen al lado derecho de la pantalla, o lo demás son mostradas, en un modo feo e ilegible, como una línea de continuación en la pantalla.</p>
<p>Además, en esta parte de mi fichero <span class="file" >.emacs</span>, yo cuento a Emacs el ajuste de comandos para insertar dos espacios después de dos puntos:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">colon-double-space</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
</div>
<h3 id="alias-de-correo" >Alias de correo</h3>
<div class="hBody-3" >
<p>Aquí hay un <code>setq</code> que ‘activa’ el alias de correo, para más ocasiones.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Modo Correo</span>
<span class="c1">; Para entrar en el modo correo, escribe ‘C-x m’</span>
<span class="c1">; Para introducir RMAIL (para leer el correo),</span>
<span class="c1">; escribe ‘M-x rmail’</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">mail-aliases</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>Este comando <code>setq</code> asigna el valor de la variable <code>mail-aliases</code> al <code>t</code>. Desde que <code>t</code> significa cierto, la línea dice, en efecto, “Sí uso alias de correo.”</p>
<p>Los alias de correo son nombres cortos convenientes para largas direcciones de correo o para listas de direcciones de correo. El fichero donde guardar tus ‘aliases’ es <span class="file" >~/.mailrc</span>. Se escribe un alias como este:</p>
<div class="example-block" >
<pre class="example" >alias geo george@@foobar.wiz.edu
</pre>
</div>
<p>Cuando se escribe un mensaje a Jorge, la dirección a <samp>geo</samp>; el correo automáticamente expandirá <samp>geo</samp> a la dirección completa.</p>
</div>
<h3 id="indentar-modo-de-tabulaciones" >Indentar modo de tabulaciones</h3>
<div class="hBody-3" >
<p>Por defecto, Emacs inserta tabulaciones en lugar en múltiples espacios cuando se formatea una región. (Por ejemplo, se podrían indentar muchas líneas de texto todo a la vez con el comando <code>indent-region</code>.) Los tabuladores se ven bien en un terminal o con impresión ordinaria, pero ellos producen mala salida de indentación cuando se usa T<sub>E</sub>X o Texinfo puesto que T<sub>E</sub>X ignora tabuladores.</p>
<p>Lo siguiente desactiva el modo de Indentar Tabulaciones:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Prevenir Tabulaciones Extrañas</span>
<span class="p">(</span><span class="nb">setq-default</span> <span class="nv">indent-tabs-mode</span> <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>Note que esta línea usa <code>setq-default</code> en vez de el comando <code>setq</code> que hemos visto antes. El comando <code>setq-default</code> asigna valores solo en búfers que no tienen sus propios valores locales para la variable.</p>
<p>Ver secciones “Tabuladores versus Espacios” y “Variables Locales en Ficheros” en <em>El Manual de GNU Emacs</em>.</p>
</div>
<h3 id="atajos-de-teclado" >Atajos de teclado</h3>
<div class="hBody-3" >
<p>Ahora para algunos atajos personales:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Compara ventanas</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-cw&#34;</span> <span class="ss">&#39;compare-windows</span><span class="p">)</span>
</code></pre>
<p><code>compare-windows</code> es un comando excelente que compara el texto en tu ventana actual con texto de la siguiente ventana. Eso hace la comparación empezando al punto en cada ventana, moviendo a través del texto en cada ventana tan lejos como ellos asocian. Yo uso este comando todo el tiempo.</p>
<p>Esto también muestra como configurar una tecla globalmente, para todo los modos</p>
<p>El comando es <code>global-set-key</code>. Es seguido por el atajo. En un fichero <span class="file" >.emacs</span>, el atajo es escrito como se ve: <code>\C-c</code> que se asocia a ‘control-c’, que significa ‘presionar la tecla de control y la tecla <kbd>c</kbd> al mismo tiempo’. La <code>w</code> significa ‘presionar la tecla <kbd>w</kbd>’. El atajo es rodeado por dobles comillas. En la documentación, se escribiría esto como <kbd>C-c w</kbd>. (Si estuviera asociando una tecla <kbd>META</kbd>, tal como <kbd>M-c</kbd>, en vez de una tecla de <kbd>CTRL</kbd>, se escribiría <code>\M-c</code> en su fichero <span class="file" >.emacs</span>. Vea la Seccion <q>Reasociando Teclas en Su Fichero Init</q> en <em>El Manual de GNU Emacs</em>, para más detalles.)</p>
<p>El comando invocado por las teclas es <code>compare-windows</code>. Note que <code>compare-windows</code> es precedido por una comilla simple; de otro modo, Emacs primero intentaría evaluar el símbolo para determinar su valor.</p>
<p>Estas tres cosas, las marcas de dobles comillas, la barra invertida antes de la <samp>C</samp>, y la marca de comilla simple son partes necesarias de atajos de teclado que tiendo a olvidar. Afortunadamente, he llegado a recordar que miraría mi fichero <span class="file" >.emacs</span> existente, y lo adaptaría a lo que hay.</p>
<p>Como para el atajo en sí: <kbd>C-c w</kbd>, combina la tecla prefija, <kbd>C-c</kbd>, con un caracter simple, en este caso, <kbd>w</kbd>. Este conjunto de teclas, <kbd>C-c</kbd> seguido por un caracter simple, es estrictamente reservado para un uso propio individual. (Esto se llama teclas ‘propias’, puesto que estas son para su propio uso). Siempre sería capaz de crear tal atajo para el uso propio sin pisar fuerte en algún atajo más. Si siempre se escribe una extensión a Emacs, por favor, evite tomar cualquiera de estas teclas para uso público. Se cree que una tecla como <kbd>C-c C-w</kbd> en vez de eso. De otra manera, ejecutará sin sus ‘propias’ teclas.</p>
<p>Aquí hay otro atajo, con un comentario:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Atajo para ‘occur’</span>
<span class="c1">; Yo uso mucho occur, así permite asignarlo a una tecla:</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-co&#34;</span> <span class="ss">&#39;occur</span><span class="p">)</span>
</code></pre>
<p>El comando <code>occur</code> muestra todas las líneas en el buffer actual que contiene un emparejamiento para una expresión regular. Asociar las líneas que se muestran en un búfer llamado <span class="file" >*Occur*</span>. Este buffer sirve como un menu para saltar a ocurrencias.</p>
<p>Aquí se muestra como desasignar una tecla, así no funciona:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Desasociar ‘C-x f’</span>
<span class="p">(</span><span class="nv">global-unset-key</span> <span class="s">&#34;\C-xf&#34;</span><span class="p">)</span>
</code></pre>
<p>Hay una razón para esta no asociación: Yo encontré inadvertidamente escrito <kbd>C-x f</kbd> cuando significó escribir <kbd>C-x C-f</kbd>. En vez de encontrar un fichero, como se pretende, accidentalmente asigna el ancho para el fichero lleno, casi siempre a un tamaño que no quería. Puesto que duramente se reseteó mi ancho por defecto, yo simplemente disocié la tecla.</p>
<p>Lo siguiente reasocia una tecla existente:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Reasocia ‘C-x C-b’ al ‘buffer-menu’</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-x\C-b&#34;</span> <span class="ss">&#39;buffer-menu</span><span class="p">)</span>
</code></pre>
<p>Por defecto, <kbd>C-x C-b</kbd> ejecute el comando <code>list-buffers</code>. Este comando lista sus buffers en <em>otra</em> ventana. Desde que casi siempre se quiere hacer alguna cosa en esta ventana, se prefiere el comando <code>buffer-menu</code>, que no solo lista los buffers, pero mueve el punto dentro de esta ventana.</p>
</div>
<h3 id="mapas-de-teclado" >Mapas de teclado</h3>
<div class="hBody-3" >
<p>Emacs usa <dfn>keymaps</dfn> para grabar qué teclas llaman a qué comandos. Cuando se use <code>global-set-key</code> para asignar los atajos de teclados a un simple comando en todo <code>current-global-map</code>.</p>
<p>Modos específicos, tales como modo C o modo Texto, tiene sus propios mapas de teclado; mapas de teclado de modo específico sobreescribe el mapa global que es compartido por todos los buffers.</p>
<p>La función <code>global-set-key</code> asocia, o reasocia, el mapa de teclado global. Por ejemplo, las siguientes asociaciones la tecla <kbd>C-x C-b</kbd> a la función <code>buffer-menu</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-x\C-b&#34;</span> <span class="ss">&#39;buffer-menu</span><span class="p">)</span>
</code></pre>
<p>Mapas de teclado específico de modo son asociados usando la función <code>define-key</code>, que toma un mapa de teclado específico como un argumento, tan bien como la tecla y el comando. Por ejemplo, mi fichero <span class="file" >.emacs</span> contiene la siguiente expresión asociada al comando <code>texinfo-insert-@group</code> comando a <kbd>C-c C-c g</kbd>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">define-key</span> <span class="nv">texinfo-mode-map</span> <span class="s">&#34;\C-c\C-cg&#34;</span> <span class="ss">&#39;texinfo-insert-@@group</span><span class="p">)</span>
</code></pre>
<p>La función <code>texinfo-insert-@group</code> en sí es una pequeña extensión del modo Texinfo que inserta <samp>@group</samp> dentro de un fichero Texinfo. Se usa este comando todo el tiempo y se prefieren escribir los tres atajos <kbd>C-c C-c g</kbd> en vez de los seis atajos <kbd>@ g r o u p</kbd>. (<samp>@group</samp> y su asociación <samp>@end group</samp> son comandos que guarda todo el texto cerrado junto a una página; muchos ejemplos multi-línea en este libro están rodeados por <samp>@group … @end group</samp>.)</p>
<p>Aquí está la definición de función <code>texinfo-insert-@group</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">texinfo-insert-@@group</span> <span class="p">()</span>
  <span class="s">&#34;Inserta la cadena @@group en un búfer Texinfo.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">beginning-of-line</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;@@group\n&#34;</span><span class="p">))</span>
</code></pre>
<p>(De acuerdo, podría haber usado el modo Abbrev para dejar de escribir, en vez de escribir una función para insertar una palabra; pero prefiero atajos de teclado consitentes con otro modo Texinfo para atajos de teclado.)</p>
<p>Verá numerosas expresiones <code>define-key</code> en <span class="file" >loaddefs.el</span> tan bien como en varios modos de librerías, tal como <span class="file" >cc-mode.el</span> y <span class="file" >lisp-mode.el</span>.</p>
<p>Vea la Seccion <q>Personalizando Atajos de Teclado</q> en <em>El Manual GNU Emacs</em>, y <q>Mapas de Teclado</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más información acerca de mapas de teclado.</p>
</div>
<h3 id="cargando-ficheros" >Cargando ficheros</h3>
<div class="hBody-3" >
<p>Muchas personas en la comunidad de GNU Emacs han escrito extensiones a Emacs. Hace tiempo, que estas extensiones son con frecuencia incluidas en las nuevas entregas <em>releases</em>. Por ejemplo, los paquetes Calendario y Diario son ahora parte del estándar GNU Emacs, como es Calc.</p>
<p>Se puede usar un comando <code>load</code> para evaluar un fichero completo que significa instalar todas las funciones y variables en el fichero Emacs. Por ejemplo:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">load</span> <span class="s">&#34;~/emacs/slowsplit&#34;</span><span class="p">)</span>
</code></pre>
<p>Esto evalúa, es decir, carga, el fichero <span class="file" >slowsplit.el</span> o si eso existe, lo más rápido, el fichero compilado <span class="file" >slowsplit.elc</span> desde el subdirectorio <span class="file" >emacs</span> del directorio home. El fichero contiene la función <code>split-window-quietly</code>, que John Robinson escribió en 1989.</p>
<p>La función <code>split-window-quietly</code> divide una ventana con el mínimo de redisplay. Yo lo instalé en 1989 porque trabajó bien con los terminales de 1200 baudios que entonces estaba usando. Ahora, ocasionalmente vengo a través de una conexión lenta, pero continúa usando la función porque me gusta el camino que deja arriba del búfer en el bajo de las nuevas ventanas y arriba en la ventana superior.</p>
<p>Para reemplazar el atajo de teclado por defecto <code>split-window-vertically</code>, se debe también desasignar esta tecla y asociar las teclas a <code>split-window-quietly</code>, como este:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-unset-key</span> <span class="s">&#34;\C-x2&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-x2&#34;</span> <span class="ss">&#39;split-window-quietly</span><span class="p">)</span>
</code></pre>
<p>Si se cargan muchas extensiones, como yo hago, entonces en vez de especificar la posición exacta del fichero, como se muestra arriba, se puede especificar que directorio como parte del <code>load-path</code> de Emacs. Entonces, cuando Emacs carga un fichero, buscará que directorio tan bien como su lista por defecto de directorios. (La lista por defecto es especificada en <span class="file" >paths.h</span> cuando Emacs se construye.)</p>
<p>El comando siguiente añade tu directorio <span class="file" >~/emacs</span> a la ruta existente:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Ruta Emacs</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">load-path</span> <span class="p">(</span><span class="nf">cons</span> <span class="s">&#34;~/emacs&#34;</span> <span class="nv">load-path</span><span class="p">))</span>
</code></pre>
<p>Incidentalmente, <code>load-library</code> es un interfaz interactivo a la función <code>load</code>. La función se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">load-library</span> <span class="p">(</span><span class="nv">library</span><span class="p">)</span>
  <span class="s">&#34;Carga la librería llamada LIBRARY.
</span><span class="s">Esto es una interfaz a la función ‘load’.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span>
   <span class="p">(</span><span class="nf">list</span> <span class="p">(</span><span class="nf">completing-read</span> <span class="s">&#34;Carga la librería: &#34;</span>
                          <span class="p">(</span><span class="nv">apply-partially</span> <span class="ss">&#39;locate-file-completion-table</span>
                                           <span class="nv">load-path</span>
                                           <span class="p">(</span><span class="nf">get-load-suffixes</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nf">load</span> <span class="nv">library</span><span class="p">))</span>
</code></pre>
<p>El nombre de la función, <code>load-libray</code>, viene desde el uso de ‘library’ como un sinónimo para ‘file’. La fuente para el comando <code>load-library</code> está en la librería <span class="file" >files.el</span>.</p>
<p>Otro comando interactivo que hace un trabajo ligeramente diferente es <code>load-file</code>. Vea la Seccion <q>Librerías de Código Lisp para Emacs</q> en <em>El Manual GNU Emacs</em>, para información en la distinción entre <code>load-library</code> y este comando.</p>
</div>
<h3 id="autoloading" >Autoloading</h3>
<div class="hBody-3" >
<p>En vez de instalar una función cargando el fichero que lo contiene, o evaluando la definición de función, se puede hacer la función disponible pero actualmente no se instala hasta la primera vez llamada. Este proceso se llama <dfn>autocarga</dfn> (<em>autoloading</em>).</p>
<p>Cuando se ejecuta una función de autocarga, Emacs automáticamente evalúa el fichero que contiene la definición, y entonces llama a la función.</p>
<p>Emacs empieza rápido con funciones de autocarga, puesto que sus librerías no se cargan bien; pero si necesita esperar un momento cuando su primer uso tal como una función, mientras que el fichero que lo contiene se evalúa.</p>
<p>Raramente las funciones usadas son frecuentemente autocargadas. La librería <span class="file" >loaddefs.el</span> coniene cientos de funciones autocargadas, desde <code>bookmark-set</code> a <code>wordstar-mode</code>. Si se usa una función ‘rara’ frecuentemente, se debería cargar este fichero de función con una expresión de <code>load</code> en tu fichero <span class="file" >.emacs</span>.</p>
<p>En mi fichero <span class="file" >.emacs</span>, se cargan 14 librerías que contienen funciones que de otro modo serían autocargadas. (Actualmente, eso habría sido mejor para incluir estos ficheros en mi Emacs ‘volcado’, pero se olvida. Véase Sección <q>Construyendo Emacs</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, y el fichero <span class="file" >INSTALL</span> para más acerca de volcados.)</p>
<p>Se puede también querer incluir expresiones autocargadas en tu fichero <span class="file" >.emacs</span>. <code>autoload</code> es una función construida que toma cinco argumento, los tres finales de los que son opcionales. El primer argumento es el nombre de la función para ser autocargada. El segundo es el nombre del fichero para ser cargado. El tercer argumento es documentación para la función, y el cuarto cuenta si la función puede ser llamada interactivmente. El quinto argumento cuenta que tipo de objeto––<code>autoload</code> puede manejar un mapa de teclado o macro tan bien como una función (por defecto es una función).</p>
<p>Aquí hay un ejemplo típico:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">autoload</span> <span class="ss">&#39;html-helper-mode</span>
  <span class="s">&#34;html-helper-mode&#34;</span> <span class="s">&#34;Editar documentos HTML&#34;</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
<p>(<code>html-helper-mode</code> es una vieja alternativa a <code>html-mode</code>, que es una parte estándar de la distribución.)</p>
<p>Esta expresión autocarga la función <code>html-helper-mode</code>. Esto se toma desde el fichero <span class="file" >html-helper-mode-el</span> (o desde la versión compilada <span class="file" >html-helper-mode.elc</span>, si eso existe). El fichero debe ser localizado en un directorio específico por <code>load-path</code>. La documentación dice que esto es un modo para ayudar a editar documentos escritos en Lenguaje de Marcas de Hiper Texto. Se puede llamar este modo interactivamente escribiendo <kbd>M-x html-helper-mode</kbd>. (Se necesitan duplicar las funciones regulares de documentación en la expresión de autocarga porque la función regular no está todavía cargada, así su documentación no está disponible.)</p>
<p>Vea la Seccion <q>Autocarga</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.</p>
</div>
<h3 id="una-extensión-simple:-line-to-top-of-window" >Una extensión simple: <code>line-to-top-of-window</code></h3>
<div class="hBody-3" >
<p>Aquí hay una simple extensión a Emacs que mueve el punto de línea arriba de la ventana. Yo uso esto todo el tiempo, para hacer fácil de leer el texto.</p>
<p>Se puede poner el siguiente código dentro de un fichero separado y entonce cargarlo desde tu fichero <span class="file" >.emacs</span>, o se puede incluir con tu fichero <span class="file" >.emacs</span>.</p>
<p>Aquí está la definición</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Línea a lo alto de la ventana;</span>
<span class="c1">;;; reemplaza tres secuencias de atajos de teclado  C-u 0 C-l</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">line-to-top-of-window</span> <span class="p">()</span>
  <span class="s">&#34;Mueve la línea que apunta a lo alto de la ventana.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">recenter</span> <span class="mi">0</span><span class="p">))</span>
</code></pre>
<p>Ahora el atajo.</p>
<p>En estos días, las teclas de función así como los eventos del ratón y caracteres no <code>ascii</code> son escritos con corchetes, sin marcas de citas. (En Emacs versión 18 y anteriores, se tenía que escribir diferentes teclas de función asignadas por cada diferente creación del terminal.)</p>
<p>Se puede asociar <code>line-to-top-of-window</code> a la tecla de función <kbd>F6</kbd> así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">global-set-key</span> <span class="p">[</span><span class="nv">f6</span><span class="p">]</span> <span class="ss">&#39;line-to-top-of-window</span><span class="p">)</span>
</code></pre>
<p>Para más información, mira <q>Reasociando Teclas en tu fichero init</q> en <em>El Manual GNU Emacs</em>.</p>
<p>Si ejecutas dos versiones de GNU Emacs, tal como las versiones 22 y 23, y usas un fichero <span class="file" >.emacs</span>, se puede seleccionar qué código evalúa el siguiente condicional:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">cond</span>
 <span class="p">((</span><span class="nf">=</span> <span class="mi">22</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
  <span class="c1">;; evalúa la version 22</span>
  <span class="p">(</span> <span class="err">…</span> <span class="p">))</span>
 <span class="p">((</span><span class="nf">=</span> <span class="mi">23</span> <span class="nv">emacs-major-version</span><span class="p">)</span>
  <span class="c1">;; evalúa la version 23</span>
  <span class="p">(</span> <span class="err">…</span> <span class="p">)))</span>
</code></pre>
<p>Por ejemplo, en versiones más recientes se ocultan los cursores por defecto. Si se odia tal ocultación se escribe lo siguiente en mi fichero <span class="file" >.emacs</span><span class="note" ><sup><a href="#14" >14</a></sup></span>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">&gt;=</span> <span class="nv">emacs-major-version</span> <span class="mi">21</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">blink-cursor-mode</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1">;; Inserta la nueva línea cuando se presiona ‘C-n’ (next-line)</span>
  <span class="c1">;; al fin del búfer</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">next-line-add-newlines</span> <span class="no">t</span><span class="p">)</span>
  <span class="c1">;; Cambia la imagen viendo</span>
  <span class="p">(</span><span class="nv">auto-image-file-mode</span> <span class="no">t</span><span class="p">)</span>
  <span class="c1">;; Activa la barra de menu (esta barra tiene texto)</span>
  <span class="c1">;; (Usa un argumento numérico para activarlo)</span>
  <span class="p">(</span><span class="nv">menu-bar-mode</span> <span class="mi">1</span><span class="p">)</span>
   <span class="c1">;; Desactiva la barra de herramientas (esta barra tiene iconos)</span>
   <span class="c1">;; (Usa argumentos numéricos para activarlo)</span>
   <span class="p">(</span><span class="nv">tool-bar-mode</span> <span class="no">nil</span><span class="p">)</span>
  <span class="c1">;; Desactiva el modo tooltip para la tool bar</span>
  <span class="c1">;; (Este modo causa explicaciones de iconos al pop up)</span>
  <span class="c1">;; (Usa el argumento numérico para activarlo)</span>
  <span class="p">(</span><span class="nv">tooltip-mode</span> <span class="no">nil</span><span class="p">)</span>
  <span class="c1">;; Si los tooltips activados, crea consejos aparecen en el prompt</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">tooltip-delay</span> <span class="mf">0.1</span><span class="p">)</span>  <span class="c1">; por defecto es de 0.7 segundos</span>
   <span class="p">)</span>
</code></pre>
</div>
<h3 id="colores-x11" >Colores X11</h3>
<div class="hBody-3" >
<p>Se pueden especificar colores cuando se usa Emacs con el Sistema de Ventanas X del MIT.</p>
<p>Si disgustan los colores por defecto y especifica unos propios.</p>
<p>Aquí están las expresiones en un fichero <span class="file" >.emacs</span> que establecen los valores:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Asigna el color del cursor</span>
<span class="p">(</span><span class="nv">set-cursor-color</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>

<span class="c1">;; Asigna el color del ratón</span>
<span class="p">(</span><span class="nv">set-mouse-color</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>

<span class="c1">;; Asigna foreground y background</span>
<span class="p">(</span><span class="nv">set-foreground-color</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-background-color</span> <span class="s">&#34;darkblue&#34;</span><span class="p">)</span>

<span class="c1">;;; Asigna colores para isearch y drag</span>
<span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;highlight</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;highlight</span> <span class="s">&#34;blue&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;region</span> <span class="s">&#34;cyan&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;region</span> <span class="s">&#34;blue&#34;</span><span class="p">)</span>

<span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;secondary-selection</span> <span class="s">&#34;skyblue&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;secondary-selection</span> <span class="s">&#34;darkblue&#34;</span><span class="p">)</span>

<span class="c1">;; Asigna colores al calendario</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">calendar-load-hook</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span>
         <span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;diary-face</span>   <span class="s">&#34;skyblue&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">set-face-background</span> <span class="ss">&#39;holiday-face</span> <span class="s">&#34;slate blue&#34;</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">set-face-foreground</span> <span class="ss">&#39;holiday-face</span> <span class="s">&#34;white&#34;</span><span class="p">)))</span>
</code></pre>
<p>Las varias sombras de azul disparan mi ojo y me preveen de ver la ventana desplegada.</p>
<p>Alternativamente, se podrían haber configurado mis especificaciones en varios ficheros inicialización de X. Por ejemplo, se podría asignar el foreground, background, cursor y puntero (por ej., ratón) colores en mi fichero <span class="file" >~/.Xresources</span> como esto:</p>
<div class="example-block" >
<pre class="example" >Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
</pre>
</div>
<p>En cualquier evento que no es parte de Emacs, se asigna el color raíz de mi ventana X en mi fichero <span class="file" >~/.xinitrc</span>, como este<span class="note" ><sup><a href="#15" >15</a></sup></span></p>
<div class="example-block" >
<pre class="example" >xsetroot -solid Navy -fg white &amp;
</pre>
</div>
</div>
<h3 id="configuraciones-misceláneas-para-un-fichero-.emacs" >Configuraciones misceláneas para un fichero <span class="file" >.emacs</span></h3>
<div class="hBody-3" >
<p>Aquí hay unas pocas configuraciones misceláneas:</p>
<ul>
<li>
<p>Asigna la forma y color del ratón del cursor:</p>
<pre class="code" ><code class="chroma" ><span class="c1">; Formas de Cursor están definidas en</span>
<span class="c1">; ‘/usr/include/X11/cursorfont.h’;</span>
<span class="c1">; por ejemplo, el cursor ‘objetivo’ es número 128;</span>
<span class="c1">; el cursor ‘top_left_arrow’ es el número 132.</span>

<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">mpointer</span> <span class="p">(</span><span class="nf">x-get-resource</span> <span class="s">&#34;*mpointer&#34;</span>
                                <span class="s">&#34;*emacs*mpointer&#34;</span><span class="p">)))</span>
  <span class="c1">;; Si no se ha asignado tu puntero de ratón</span>
  <span class="c1">;; entonces asignalo, de otro modo, déjalo así:</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">mpointer</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">mpointer</span> <span class="s">&#34;132&#34;</span><span class="p">))</span> <span class="c1">; top_left_arrow</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">x-pointer-shape</span> <span class="p">(</span><span class="nv">string-to-int</span> <span class="nv">mpointer</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">set-mouse-color</span> <span class="s">&#34;white&#34;</span><span class="p">))</span>
</code></pre>
</li>
<li>
<p>O se pueden asignar los valores de una variedad de funcionalidades en una alist, como esta:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq-default</span>
 <span class="nv">default-frame-alist</span>
 <span class="o">&#39;</span><span class="p">((</span><span class="nv">cursor-color</span> <span class="o">.</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">mouse-color</span> <span class="o">.</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">foreground-color</span> <span class="o">.</span> <span class="s">&#34;white&#34;</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">background-color</span> <span class="o">.</span> <span class="s">&#34;DodgerBlue4&#34;</span><span class="p">)</span>
   <span class="c1">;; (cursor-type . bar)</span>
   <span class="p">(</span><span class="nv">cursor-type</span> <span class="o">.</span> <span class="nv">box</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">tool-bar-lines</span> <span class="o">.</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">menu-bar-lines</span> <span class="o">.</span> <span class="mi">1</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">width</span> <span class="o">.</span> <span class="mi">80</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">height</span> <span class="o">.</span> <span class="mi">58</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">font</span> <span class="o">.</span>
         <span class="s">&#34;-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1&#34;</span><span class="p">)</span>
   <span class="p">))</span>
</code></pre>
</li>
<li>
<p>Convierte <kbd><kbd>CTRL</kbd>-h</kbd> dentro <kbd>DEL</kbd> y <kbd>DEL</kbd> dentro de <kbd><kbd>CTRL</kbd>-h</kbd>.</p>
<p>(Algunos viejos teclados lo necesitan, aunque yo no he visto el problema recientemente.)</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Traducir ‘C-h’ a &lt;DEL&gt;.</span>
<span class="c1">; (keyboard-translate ?\C-h ?\C-?)</span>

<span class="c1">;; Traducir &lt;DEL&gt; a ‘C-h’.</span>
<span class="p">(</span><span class="nv">keyboard-translate</span> <span class="sc">?\C</span><span class="nv">-?</span> <span class="sc">?\C</span><span class="nv">-h</span><span class="p">)</span>
</code></pre>
</li>
<li>
<p>¡Desactiva un cursor oculto!</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">fboundp</span> <span class="ss">&#39;blink-cursor-mode</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">blink-cursor-mode</span> <span class="mi">-1</span><span class="p">))</span>
</code></pre>
<p>o empieza GNU Emacs con el comando <code>emacs -nbc</code>.</p>
</li>
<li>
<p>Cuando se usa ‘grep’</p>
<dl>
<dt><samp>-i</samp></dt>
<dd>
<p>Ignore distinciones de letras</p>
</dd>
<dt><samp>-n</samp></dt>
<dd>
<p>El prefijo de cada línea de la salida con el número de líneas</p>
</dd>
<dt><samp>-H</samp></dt>
<dd>
<p>Imprime el nombre de fichero para cada cadena encontrada.</p>
</dd>
<dt><samp>-e</samp></dt>
<dd>
<p>Protege patrones empezando con un caracter de guión, <samp>-</samp></p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">grep-command</span> <span class="s">&#34;grep -i -nH -e &#34;</span><span class="p">)</span>
</code></pre>
</dd>
</dl>
</li>
</ul>
<dl>
<dt>Encuentra un búfer existente, incluso si eso tiene un nombre diferente</dt>
<dd>
<p>Esto evita problemas con enlaces simbólicos.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">find-file-existing-other-name</span> <span class="no">t</span><span class="p">)</span>
</code></pre>
</dd>
</dl>
<ul>
<li>
<p>Configura tu entorno de lenguaje y el método de entrada por defecto</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">set-language-environment</span> <span class="s">&#34;latin-1&#34;</span><span class="p">)</span>
<span class="c1">;; Recuerda que se puede habilitar o deshabilitar el texto de lenguaje</span>
<span class="c1">;; multilingüe con el comando @c{toggle-input-method&#39;} (@k{C-\})</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">default-input-method</span> <span class="s">&#34;latin-1-prefix&#34;</span><span class="p">)</span>
</code></pre>
<p>Si se quiere escribir con el caracter Chino ‘GB’, asigna esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">set-language-environment</span> <span class="s">&#34;Chinese-GB&#34;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">default-input-method</span> <span class="s">&#34;chinese-tonepy&#34;</span><span class="p">)</span>
</code></pre>
</li>
</ul>
</div>
<h4 id="arreglando-atajos-de-teclados" >Arreglando Atajos de Teclados</h4>
<div class="hBody-4" >
<p>Algunos sistemas asocian teclas de maneras no agradables. Algunas veces, por ejemplo, la tecla <kbd>CTRL</kbd> en un modo perverso en vez de la lejanía a la izquierda de la fila.</p>
<p>Normalmente, cuando las personas arreglan estos atajos de teclado, no se cambia su fichero <span class="file" >~/.emacs</span>. En vez de eso, se asocian las teclas apropiadas en sus consolas con los comandos <code>loadkeys</code> o <code>install-keymap</code> en su script de inicio y entonces incluyen comandos <code>xmodmap</code> en su fichero <span class="file" >.xinitrc</span> o <span class="file" >.Xsession</span> para X Windows.</p>
<p>Para un script de inicio:</p>
<div class="example-block" >
<pre class="example" >loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

or

install-keymap emacs2
</pre>
</div>
<p>Para un fichero <span class="file" >.xinitrc</span> o un fichero <span class="file" >.Xsession</span> cuando la tecla <kbd>Caps Lock</kbd> es que tan lejos de la fila del home:</p>
<div class="example-block" >
<pre class="example" ># Asocia la tecla etiquetada ‘Caps Lock’ a ‘Control’
# (Tal como un interfaz de usuario roto sugiere que el teclado hecho
# piensa que los ordenadores son máquinas de escribir desde 1885.)

xmodmap -e &#34;clear Lock&#34;
xmodmap -e &#34;add Control = Caps_Lock&#34;
</pre>
</div>
<p>En un <span class="file" >.xinitrc</span> o <span class="file" >.Xsession</span>, para convertir una tecla <kbd>ALT</kbd> a una tecla <kbd>META</kbd>:</p>
<div class="example-block" >
<pre class="example" ># Algunos teclados mal diseñados tienen una tecla etiquetada ALT y no Meta
xmodmap -e &#34;keysym Alt_L = Meta_L Alt_L&#34;
</pre>
</div>
</div>
<h3 id="una-línea-modificada" >Una línea modificada</h3>
<div class="hBody-3" >
<p>Finalmente, una funcionalidad que realmente me gusta: un mode line modificado.</p>
<p>Cuando se trabaja a través de una red, se olvida que máquina se está usando. También, se tiende a perder la traza de donde se está, y a qué línea se apunta.</p>
<p>Así se resetea mi mode line para que se parezca a esto:</p>
<div class="example-block" >
<pre class="example" >::-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
</pre>
</div>
<p>Estoy visitando un fichero llamado <span class="file" >foo.texi</span>, en mi máquina <span class="file" >rattlesnake</span> en mi búfer <span class="file" >/home/bob</span>. Yo estoy en la línea 1, en modo Texinfo, y estoy arriba del búfer.</p>
<p>Mi fichero <span class="file" >.emacs</span> tiene una sección que se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; Asigna un Mode Line que nos cuente que máquina, que directorio,</span>
<span class="c1">;; y que línea estoy on, más la información de client.</span>
<span class="p">(</span><span class="nb">setq-default</span> <span class="nv">mode-line-format</span>
 <span class="p">(</span><span class="nb">quote</span>
  <span class="p">(</span><span class="o">#(</span><span class="s">&#34;-&#34;</span> <span class="mi">0</span> <span class="mi">1</span>
     <span class="p">(</span><span class="nv">help-echo</span>
      <span class="s">&#34;mouse-1: select window, mouse-2: delete others ...&#34;</span><span class="p">))</span>
   <span class="nv">mode-line-mule-info</span>
   <span class="nv">mode-line-modified</span>
   <span class="nv">mode-line-frame-identification</span>
   <span class="s">&#34;    &#34;</span>
   <span class="nv">mode-line-buffer-identification</span>
   <span class="s">&#34;    &#34;</span>
   <span class="p">(</span><span class="nb">:eval</span> <span class="p">(</span><span class="nf">substring</span>
           <span class="p">(</span><span class="nf">system-name</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">string-match</span> <span class="s">&#34;\\..+&#34;</span> <span class="p">(</span><span class="nf">system-name</span><span class="p">))))</span>
   <span class="s">&#34;:&#34;</span>
   <span class="nv">default-directory</span>
   <span class="o">#(</span><span class="s">&#34; &#34;</span> <span class="mi">0</span> <span class="mi">1</span>
     <span class="p">(</span><span class="nv">help-echo</span>
      <span class="s">&#34;mouse-1: select window, mouse-2: delete others ...&#34;</span><span class="p">))</span>
   <span class="p">(</span><span class="nv">line-number-mode</span> <span class="s">&#34; Line %l &#34;</span><span class="p">)</span>
   <span class="nv">global-mode-string</span>
   <span class="o">#(</span><span class="s">&#34;   %[(&#34;</span> <span class="mi">0</span> <span class="mi">6</span>
     <span class="p">(</span><span class="nv">help-echo</span>
      <span class="s">&#34;mouse-1: select window, mouse-2: delete others ...&#34;</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">:eval</span> <span class="p">(</span><span class="nv">mode-line-mode-name</span><span class="p">))</span>
   <span class="nv">mode-line-process</span>
   <span class="nv">minor-mode-alist</span>
   <span class="o">#(</span><span class="s">&#34;%n&#34;</span> <span class="mi">0</span> <span class="mi">2</span> <span class="p">(</span><span class="nv">help-echo</span> <span class="s">&#34;mouse-2: widen&#34;</span> <span class="nv">local-map</span> <span class="p">(</span><span class="nv">keymap</span> <span class="o">...</span><span class="p">)))</span>
   <span class="s">&#34;)%] &#34;</span>
   <span class="p">(</span><span class="mi">-3</span> <span class="o">.</span> <span class="s">&#34;%P&#34;</span><span class="p">)</span>
   <span class="c1">;;   &#34;-%-&#34;</span>
   <span class="p">)))</span>
</code></pre>
<p>Aquí, se redefine el mode line por defecto. La mayoría de las partes son desde el original; pero yo creo unos pocos cambios. Yo asigno el formato de mode line <em>default</em> así como permitir varios modos, tales como Info, para sobreescribirlo.</p>
<p>Muchos elementos en la lista son auto-explicativos: <code>mode-line-modified</code> es una variable que cuenta si el búfer ha sido modificado, <code>mode-name</code> cuenta el nombre del modo, y así. Sin embargo, el formato parece complicado porque las dos funcionalidades no han sido discutidas.</p>
<p>La nueva cadena de formato tiene una sintaxis especial:</p>
<pre class="code" ><code class="chroma" ><span class="o">#(</span><span class="s">&#34;-&#34;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="nv">help-echo</span> <span class="s">&#34;mouse-1: select window, ...&#34;</span><span class="p">))</span>
</code></pre>
<p>El <code>#(</code> empieza una lista. El primer elemento de la lista es la cadena en sí, solo un <samp>-</samp>. El segundo y tercer elemento especifica el rango a través del cuarto elemento aplicado. Un rango empieza <em>después</em> un carácter, así un cero significa el rango que empieza solo después del primer caracter; un 1 significa que el rango finaliza solo después del primer caracter. El tercer elemento es la propiedad para el rango. Eso consiste en una lista de propiedades, un nombre de propiedad, en este caso, <samp>help-echo</samp>, seguido por un valor, en este caso, una cadena. El segundo, tercer y cuarto elemento de este nuevo formato de cadena puede ser repetido.</p>
<p>Vea la Seccion <q>Propiedades de Texto</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, y ver <q>Formato Mode Line</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más información.</p>
<p><code>mode-line-buffer-identification</code> muestra el nombre del buffer. Eso es una lista empezando por <code>(#(&#34;%12b&#34; 0 4 …</code>. El <code>#(</code> empieza la lista.</p>
<p>El <samp>&#34;%12b&#34;</samp> muestra el nombre del actual búfer, usando la función <code>buffer-name</code> con la que estamos familiarizados; el ‘12’ especifica el número máximo de caracteres que serán mostrados. Cuando un nombre tiene pocos caracteres, el espacio en blanco se añade para rellenar este número. (Los nombres del búfer puede y con frecuencia serán más largos de 12 caracteres; esta longitud funciona bien en la típica ventana de 80 columnas de ancho.)</p>
<p><code>:eval</code> dice evaluar la siguiente forma y usa el resultado como una cadena para mostrarse. En este caso, la expresión muestra el primer componente del sistema completo. El fin del primer componente es un <samp>.</samp> (‘periodo’), así se usa la función <code>string-match</code> para contar el tamaño del primer componente. La subcadena desde el caracter cero a este tamaño del primer componente. La subcadena desde el caracter cero a este tamaño es el nombre de la máquina.</p>
<p>Esta es la expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">:eval</span> <span class="p">(</span><span class="nf">substring</span>
        <span class="p">(</span><span class="nf">system-name</span><span class="p">)</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">string-match</span> <span class="s">&#34;\\..+&#34;</span> <span class="p">(</span><span class="nf">system-name</span><span class="p">))))</span>
</code></pre>
<p><samp>%[</samp> y <samp>%]</samp> causa un par de corchetes que aparezcan por cada edición nivel de edición recursiva editando el nivel. <samp>%n</samp> dice ‘Encoger’ cuando esto puede hacerse. <samp>%P</samp> te cuenta el porcentaje del búfer que está debajo de la ventana, o ‘arriba’, ‘abajo’, o ‘todo’. (Una minúscula <samp>p</samp> cuenta el porcentaje bajo el alto de la ventana.) <samp>%-</samp> inserta suficientes guiones para rellenar la línea.</p>
<p>Recuerda, “No tiene que gustarte Emacs para que le gustes”––Emacs puede tener diferentes colores, diferentes comandos, y diferentes teclas que un Emacs por defecto.</p>
<p>Por otro lado, si se quiere traer un plano ‘fuera de la caja’ Emacs, sin personalización, escribe:</p>
<div class="example-block" >
<pre class="example" >emacs -q
</pre>
</div>
<p>Esto inicializará un Emacs que <em>no</em> cargue tu <span class="file" >~/.emacs</span> fichero de inicialización. Uno plano, el que trae Emacs por defecto. Nada más.</p>
</div>
<h2 id="depurando" >Depurando</h2>
<div class="hBody-2" >
<p>GNU Emacs tiene dos depuradores, <code>debug</code> y <code>edebug</code>. El primero es construido dentro de las tripas de Emacs y está siempre contigo; el segundo requiere que exista una función antes de que se pueda usar.</p>
<p>Ambos depuradores son descritos extensivamente en Seccion <q>Depurando</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>. En este capítulo, se explicará un breve ejemplo de esto.</p>
</div>
<h3 id="depurar" ><code>depurar</code></h3>
<div class="hBody-3" >
<p>Supón que se ha escrito una definición de función que se pretende devolver la suma de los números 1 a través de un número dado. (Esta es la función <code>triangle</code> discutida pronto. Vea la Seccion <a href="Ejemplo-de-Decremento,-,-Ejemplo-con-Contador-de-Decremento" >Ejemplo de Decremento, , Ejemplo con Contador de Decremento</a>, para una discusión.)</p>
<p>Sin embargo, tu definición de función tiene un error. Se ha malescrito <samp>1=</samp> por <samp>1-</samp>. Aquí está la definición rota:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-bugged</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve suma de números 1 a través de NUMBER inclusive.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)))</span>      <span class="c1">; Error aquí.</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>Si se está leyendo esto en Info, se puede evaluar esta definición en el modo normal. Se verá que <code>triangle-bugged</code> aparece en el área de eco.</p>
<p>Ahora evalúa la función <code>triangle-bugged</code> con un argumento de 4:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-bugged</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>En un GNU Emacs reciente, se creará e introducirá un búfer <span class="file" >*Backtrace*</span> que dice:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (&gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (&gt; number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>(Se ha reformateado este ejemplo ligeramente; el depurador no contiene muchas líneas. Así, se puede salir del depurador escribiendo <kbd>q</kbd> en el buffer <span class="file" >*Backtrace*</span>.)</p>
<p>En la práctica, debido a un error tan simple como este, la línea de ‘error Lisp’ explica lo que se necesita saber para corregir la definición. La función <code>1=</code> está ‘vacía’.</p>
<p>Sin embargo, si no se conoce con bastante certeza lo que está pasando, se puede leer la traza completa.</p>
<p>En este caso, se necesita ejecutar una versión reciente de GNU Emacs, que automáticamente empieza el depurador que pone en el búfer <span class="file" >*Backtrace*</span>; o además, se necesita para empezar el depurador manualmente como se describe debajo.</p>
<p>Lee el búfer <span class="file" >*Backtrace*</span> de abajo a arriba; eso cuenta lo que le hizo a Emacs tener un error. Emacs hace una llamada interactiva a <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>), que lleva a la evaluación de la expresión <code>triangle-bugged</code>. Cada línea de debajo cuenta lo que el intérprete Lisp evaluó.</p>
<p>La tercera línea desde lo alto del búfer es</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">))</span>
</code></pre>
<p>Emacs intentó evaluar esta expresión; para hacerlo así, se intentó evaluar la expresión interna para ser mostrada en la segunda línea desde arriba:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)</span>
</code></pre>
<p>Aquí es donde el error ocurre; como se dice en la línea de arriba:</p>
<div class="example-block" >
<pre class="example" >Debugger entered--Lisp error: (void-function 1=)
</pre>
</div>
<p>Se puede corregir el error, reevalúa la definición de función, y entonces se puede testear de nuevo.</p>
</div>
<h3 id="debug-on-entry" ><code>debug-on-entry</code></h3>
<div class="hBody-3" >
<p>Un GNU Emacs actual abre el depurador automáticamente cuando la función tiene un error.</p>
<p>Incidentalmente, se puede empezar el depurador manualmente para todas las versiones de Emacs; la ventaja es que el depurador se ejecuta incluso si no se tiene un error en su código. Algunas veces, ¡su código estará libre de errores!</p>
<p>Se puede introducir el depurador cuando se llama a la función llamando <code>debug-on-entry</code>.</p>
<p>Tipo:</p>
<div class="example-block" >
<pre class="example" >M-x debug-on-entry RET triangle-bugged RET
</pre>
</div>
<p>Ahora, evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-bugged</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>Todas las versiones de Emacs crearán un búfer <span class="file" >*Backtrace*</span> y cuenta tu que eso es el principio para evaluar la función <code>triangle-bugged</code>:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>En el búfer <span class="file" >*Backtrace*</span>, escribe <kbd>d</kbd>. Emacs evaluará la primera expresión en <code>triangle-bugged</code>; el búfer se parece a esto:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (&gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Ahora, escribe <kbd>d</kbd> de nuevo, ocho veces, lentamente. Cada vez que se escribe <kbd>d</kbd> Emacs evaluará otra expresión en la definición de función.</p>
<p>Eventualmente, el búfer se parece a esto:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (&gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
* (let ((total 0)) (while (&gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Finalmente, después se escribe <kbd>d</kbd> dos veces más, Emacs logrará el error y las dos líneas superiores del buffer <span class="file" >*Backtrace*</span> se ve así:</p>
<div class="example-block" >
<pre class="example" >---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
…
---------- Buffer: *Backtrace* ----------
</pre>
</div>
<p>Escribiendo <kbd>d</kbd>, sería capaz de pasear a través de la función.</p>
<p>Se puede salir de un buffer <span class="file" >*Backtrace*</span> escribiendo <kbd>q</kbd>; esto se sale de la traza, pero no cancela <code>debug-on-entry</code>.</p>
<p>Para cancelar el efecto de <code>debug-on-entry</code>, llama a <code>cancel-debug-on-entry</code> y el nombre de la función, como esto:</p>
<div class="example-block" >
<pre class="example" >M-x cancel-debug-on-entry RET triangle-bugged RET
</pre>
</div>
<p>(Si está leyendo esto en Info, cancela <code>debug-on-entry</code> ahora.)</p>
</div>
<h3 id="debug-on-quit-y-(debug)" ><code>debug-on-quit</code> y <code>(debug)</code></h3>
<div class="hBody-3" >
<p>Adición a la configuración <code>debug-on-error</code> o llamando <code>debug-on-entry</code>, hay otros dos caminos para empezar <code>debug</code>.</p>
<p>Se puede empezar <code>debug</code> siempre y cuando se escribe <kbd>C-g</kbd> (<code>keyboard-quit</code>) se configura la variable <code>debug-on-quit</code> para <code>t</code>. Esto es útil para depurar bucles infinitos.</p>
<p>O, se puede insertar un línea que dice <code>(debug)</code> dentro de tu código donde se quiere que el depurador empiece, así:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-bugged</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve suma de números 1 a través de NUMERO inclusive.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">total</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">total</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">total</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">debug</span><span class="p">)</span>                         <span class="c1">; Empieza el depurador.</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)))</span>      <span class="c1">; Error aquí.</span>
    <span class="nv">total</span><span class="p">))</span>
</code></pre>
<p>La función <code>debug</code> se describe en detalle en <q>El Depurador Lisp</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.</p>
</div>
<h3 id="el-depurador-de-nivel-de-fuentes-edebug" >El depurador de nivel de fuentes <code>edebug</code></h3>
<div class="hBody-3" >
<p>Edebug es un depurador a nivel de fuentes Edebug que normalmente muestra las fuentes del código que se está depurando, con una flecha a la izquierda que muestra que línea se está actualmente ejecutando.</p>
<p>Se puede pasear a través de la ejecución de una función, línea a línea, o ejecutarse rápidamente hasta lograr un <dfn>punto de ruptura</dfn> donde la ejecución pare.</p>
<p>Edebug se describe en Seccion <q>edebug</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
<p>Aquí hay una función con errores para <code>triangle-recursively</code>. Véase Sección <a href="Recursión-en-lugar-de-un-contador" >Recursión en lugar de un contador</a>, para una revisión de eso.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">triangle-recursively-bugged</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la suma of números 1 a través de NUMBER inclusive.
</span><span class="s">Usa recursión.&#34;</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">=</span> <span class="nv">number</span> <span class="mi">1</span><span class="p">)</span>
      <span class="mi">1</span>
    <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span>
       <span class="p">(</span><span class="nv">triangle-recursively-bugged</span>
        <span class="p">(</span><span class="nv">1=</span> <span class="nv">number</span><span class="p">)))))</span>               <span class="c1">; Error aquí.</span>
</code></pre>
<p>Normalmente, se instalaría esta definición posicionando su cursor después de la función cerrando paréntesis y escribiendo <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>) o lo demás posicionando tu cursor con la definición y escribiendo <kbd>C-M-x</kbd> (<code>eval-defun</code>). (Por defecto, el comando <code>eval-defun</code> funciona solo en modo Emacs Lisp o en el modo de interacción de Lisp.)</p>
<p>Sin embargo, para preparar esta definición de función para Edebug, se debe primero <dfn>instrumentar</dfn> el código usando un comando diferente. Se puede hacer esto posicionando el cursor dentro o después de la definición y escribiendo</p>
<div class="example-block" >
<pre class="example" >M-x edebug-defun RET
</pre>
</div>
<p>Esto causará que Emacs cargue Edebug automáticamente si eso no está ya cargado y, apropiadamente prepara la función.</p>
<p>Después de preparar la función, emplaza tu cursor después de la siguiente expresión y escribe <kbd>C-x C-e</kbd> (<code>eval-last-sexp</code>):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">triangle-recursively-bugged</span> <span class="mi">3</span><span class="p">)</span>
</code></pre>
<p>Se vuelve a las fuentes de <code>triangle-recursively-bugged</code> y el cursor se posiciona al principio del <code>if</code> de la línea de la función. También, se verá una flecha en la mano izquierda al lado de esta línea donde la función se está ejecutando. (En los siguientes ejemplos, se muestra la flecha con <samp>=&gt;</samp>; en un sistema de ventanas, se puede ver la flecha como un triángulo sólido en el ‘borde’ de la ventana.)</p>
<div class="example-block" >
<pre class="example" >=&gt;★(if (= number 1)
</pre>
</div>
<p>En el ejemplo, la posición del punto es mostrado con una estrella, <samp>★</samp> (en Info, eso es mostrado como <samp>-!-</samp>).</p>
<p>Si ahora se presiona <kbd>SPC</kbd>, el punto se moverá a la siguiente expresión para ejecutarse; la línea se parece a esto:</p>
<div class="example-block" >
<pre class="example" >=&gt;(if ★(= number 1)
</pre>
</div>
<p>Como se continua presionando <kbd>SPC</kbd>, el puntero se moverá desde la expresión a la expresión. Al mismo tiempo, siempre y cuando una expresión devuelva un valor, este valor será mostrado en el área de eco. Por ejemplo, después de mover el punto pasado <code>number</code>, se verá lo siguiente:</p>
<div class="example-block" >
<pre class="example" >Resultado: 3 (#o3, #x3, ?\C-c)
</pre>
</div>
<p>Esto significa el valor de <code>number</code> es 3, que son tres octales, tres hexadecimales, y <code>ascii</code> ‘control-c’ (la tercera letra del alfabeto, en caso de que se necesite conocer esta información).</p>
<p>Uno puede continuar moviéndose a través del código hasta que logre la línea con el error. Antes de la evaluación, esta línea se parece a esto:</p>
<div class="example-block" >
<pre class="example" >=&gt;        ★(1= number)))))               ; Error aquí.
</pre>
</div>
<p>Cuando se presiona <kbd>SPC</kbd> una vez de nuevo, se producirá un mensaje de error que dice:</p>
<div class="example-block" >
<pre class="example" >La definición de la función está vacío: 1=
</pre>
</div>
<p>Este es el error.</p>
<p>Presiona <kbd>q</kbd> para salir de Edebug.</p>
<p>Para eliminar la instrumentación desde una definición de función, simplemente se reevalúa con un comando que no lo instrumente. Por ejemplo, se podría posicionar su cursor después de la definición cerrando paréntesis y escribiendo <kbd>C-x C-e</kbd>.</p>
<p>Edebug hace un gran trato antes de entrar en una función. Se puede dirigir así mismo, parando solo en un error o en puntos específicos, se puede causar para mostrar los valores cambiantes de varias expresiones; se puede encontrar cuantas veces una función se llama, y más.</p>
<p>Edebug se describe en <q>edebug</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
</div>
<h3 id="ejercicios-de-depuración" >Ejercicios de depuración</h3>
<div class="hBody-3" >
<ul>
<li>
<p>Instale la función <code>count-words-example</code> y provoque que se introduzca el depurador construido cuando se llame. Ejecute el comando en una región conteniendo dos palabras. Se necesitará presionar <kbd>d</kbd> un número remarcable de veces. En el sistema, es un ‘hook’ llamado después que el comando se finaliza. (Para información sobre hooks, mira Seccion <q>Resumen del Comando Bucle</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
</li>
<li>
<p>Copie <code>count-words-example</code> dentro del búfer <span class="file" >*scratch*</span>, instrumente la función para Edebug, y navegue a través de su ejecución. La función no necesita tener un error, aunque se puede introducir uno si se desea. Si a la función le falta un error, el paseo se completa sin problemas.</p>
</li>
<li>
<p>Mientras se ejecuta Edebug, escriba <kbd>?</kbd> para ver una lista de todos los comandos Edebug. (El <code>global-edebug-prefix</code> normalmente es <kbd>C-x X</kbd>, por ej: <kbd>CTRL-x</kbd> seguido por una tecla mayúscula <kbd>X</kbd>; use este prefijo para comandos hechos fuera del búfer de depuración Edebug.)</p>
</li>
<li>
<p>En el búfer de depuración Edebug, usa el comando <kbd>p</kbd> (<code>edebug-bounce-point</code>) para ver si <code>count-words-example</code> está funcionando.</p>
</li>
<li>
<p>Mueve el punto a algún sitio debajo de la función y entonces escribe el comando <kbd>h</kbd> (<code>edebug-goto-here</code>) para saltar a esta localización.</p>
</li>
<li>
<p>Usa el comando <kbd>t</kbd> (<code>edebug-trace-mode</code>) para causar que Edebug pasee a través de la función en sí; usa una letra mayúscula <kbd>T</kbd> para <code>edebug-Trace-fast-mode</code>.</p>
</li>
<li>
<p>Asigna un punto de ruptura, entonces ejecuta Edebug en modo Traza hasta que se logre el punto de parada.</p>
</li>
</ul>
</div>
<h2 id="conclusión" >Conclusión</h2>
<div class="hBody-2" >
<p>Ahora se ha llegado al fin de esta Introducción. Se ha aprendido lo suficiente acerca de programación en Emacs Lisp para asignar valores, para escribir ficheros <span class="file" >.emacs</span> para tí mismo y tus amigos, y escribir personalizaciones simples y extensiones a Emacs.</p>
<p>Este es un lugar para parar. O, si se desea, se puede ir adelante, y aprender más por uno mismo.</p>
<p>Se han aprendido algunas bases de programación. Pero solo algunas. Todavía hay muchas cosas que son fáciles de usar que no se han tocado.</p>
<p>Otra idea para seguir es leer las fuentes de Emacs y en <em>El Manual de Referencia de GNU Emacs</em>.</p>
<p>Las fuentes de Emacs Lisp son una aventura. Cuando se leen las fuentes vienen a través de una función o expresión que nos es familiar, se necesita imaginar o encontrar qué se hace.</p>
<p>Ir al Manual de Referencia. Eso está a través del completo, limpio y fácil de leer descripción de Emacs Lisp. Está escrito no solo para expertos, pero sí para gente que conoce lo que usted conoce. (El <em>Manual de Referencia</em> viene con la distribución de GNU Emacs. Como esta introducción, viene como un fichero fuente Texinfo, así se puede leer on-line como un libro impreso.)</p>
<p>Ir a otra ayuda on-line que sea parte de GNU Emacs: la documentación on-line para todas las funciones y variables, y <code>find-tag</code>, el programa que va a las fuentes.</p>
<p>Aquí hay un ejemplo de cómo explorar las fuentes. Porque su nombre, <span class="file" >simple.el</span> es el fichero que se vió primero, hace tiempo. Como eso ocurre alguna de las funciones en <span class="file" >simple.el</span> son complicadas, o al menos parece complicado a primera vista. La función <code>open-line</code>, por ejemplo, parece complicada.</p>
<p>Se puede querer pasear a través de esta función lentamente, como nosotros hicimos la función <code>forward-sentence</code>. (Vea la Seccion <a href="La-función-forward-sentence" >La función <code>forward-sentence</code></a>.) O se puede querer salir de esta función y mirar en otra, tal como <code>split-line</code>. No se necesita leer todas las funciones. De acuerdo a <code>count-words-in-defun</code>, la función <code>split-line</code> contiene 102 palabras y símbolos.</p>
<p>Incluso aunque sean pocas, <code>split-line</code> contiene expresiones que no se han estudiado: <code>skip-chars-forward</code>, <code>indent-to</code>, <code>current-column</code> y <code>insert-and-inherit</code>.</p>
<p>Considera la función <code>skip-chars-forward</code>. (Eso es parte de la definición de función para <code>back-to-indentation</code>, que muestra la <a href="Repaso:-Cómo-escribir-definiciones-de-funciones" >Repaso</a>.)</p>
<p>En GNU Emacs, se puede encontrar más acerca de <code>skip-chars-forward</code> escribiendo <kbd>C-h f</kbd> (<code>describe-function</code>) y el nombre de la función. Esto te da la documentación de función.</p>
<p>Se puede ser capaz de adivinar que se hace por una función bien llamada tal como <code>indent-to</code>; o se puede buscar, también. Incidentalmente, la función <code>describe-function</code> en sí está en <span class="file" >help.el</span>; esta es una de estas largas, pero descifrables funciones. ¡Se puede buscar <code>describe-function</code> usando el comando <kbd>C-h f</kbd>!</p>
<p>En esta instancia, desde el código es Lisp, el búfer <span class="file" >*Help*</span> contiene el nombre de la librería conteniendo las fuentes de la función. Se puede poner el punto a través del nombre de la librería y presiona la tecla RET, que está en esta situación está asociado a <code>help-follow</code>, y se toma directamente de las fuentes, en el mismo camino que <kbd>M-.</kbd> (<code>find-tag</code>).</p>
<p>La definición para <code>describe-function</code> ilustra como personalizar las expresiones <code>interactive</code> sin usar los códigos de caracter estándar y eso muestra como crear un búfer temporal.</p>
<p>(La función <code>indent-to</code> es escrita en C en vez de Emacs Lisp; eso es una función ‘construida’. <code>help-follow</code> toma su fuente como <code>find-tag</code>, cuando se configura apropiadamente.)</p>
<p>Se puede mirar en las fuentes de la función usando <code>find-tag</code>, que está asociado a <kbd>M-.</kbd>. Finalmente, se puede encontrar que el Manual de Referencia tiene que decir visitando el manual en Info, y escribiendo <kbd>i</kbd> (<code>Info-index</code>) y el nombre de la función, o buscando la función en el índice a una copia impresa del manual.</p>
<p>Similarmente, se puede encontrar que significa por <code>insert-and-inherit</code>.</p>
<p>Otros ficheros fuente interesantes incluyen <span class="file" >paragraphs.el</span>, <span class="file" >loaddefs.el</span> y <span class="file" >loadup.el</span>. El fichero <span class="file" >paragraphs.el</span> incluye ordenar, funciones fácilmente comprendidas tan bien como las largas. El fichero <span class="file" >loaddefs.el</span> contiene muchos autoloads estándar y muchos mapas de teclado. Nunca se ha buscado en todo; solo en las partes. <span class="file" >loadup.el</span> es el fichero que carga las partes estándar de Emacs; eso cuenta un gran trato acerca de cómo Emacs está construido. (Vea la Seccion <q>Construyendo Emacs</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más acerca de construcción.)</p>
<p>Como dije, se han aprendido algunas cosas; sin embargo, y de manera muy importante, se han tocado fuertes aspectos de la programación; no se ha dicho nada acerca de como ordenar la información, excepto para usar la función predefinida <code>sort</code>; no se ha dicho nada acerca de cómo almacenar la información, excepto para usar variables y listas; no se ha dicho nada acerca de como escribir programas que escriben programas. Esto son asuntos para otro tipo diferente de libro, un diferente tipo de aprendizaje.</p>
<p>Lo que se ha hecho es aprender lo suficiente para hacer mucho trabajo práctico con GNU Emacs. Lo que se ha hecho es comenzar. Este es el fin del principio de una gran amistad.</p>
</div>
<h3 id="apéndice-a-la-función-the-the" >Apéndice A La función <code>the-the</code></h3>
<div class="hBody-3" >
<p>Algunas veces cuando se se escribe texto, se duplican palabras––como con “se se” cerca del principio de esta frase. Se encuentra que lo más frecuente, es duplicar “el”; aquí, se llama a la función para detectar las palabras duplicadas, <code>the-the</code>.</p>
<p>Como primer paso, se podrían usar las siguientes expresiones regulares para buscar duplicados:</p>
<div class="example-block" >
<pre class="example" >\\(\\w+[ \t\n]+\\)\\1
</pre>
</div>
<p>Este regexp asocia uno o más caracteres que constituyen palabras seguidas por uno o más espacios, tabuladores, o nuevas líneas. Sin embargo, eso no detecta palabras duplicadas en diferentes líneas, desde la finalización de la primera palabra, el fin de la línea, es diferente desde el fin de la segunda palabra, un espacio. (Para más información acerca de expresiones regulares, mira el Capitulo 12 <a href="Búsqueda-de-Expresiones-Regulares" >Búsqueda de Expresiones Regulares</a>, tan bien como la Seccion <q>Sintaxis de Expresiones Regulares</q> en <em>El Manual de GNU Emacs</em>, y la Seccion <q>Expresiones Regulares</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>.)</p>
<p>Se podrían intentar buscar caracteres duplicados pero no si el patrón detecta dobles tales como las dos ocurrencias de ‘th’ en ‘with the’.</p>
<p>Otro posible regexp busca caracteres constituyentes de palabras seguidos por caracteres de no palabras constituyentes, reduplicadas. Aquí, <samp>\\w+</samp> asocia a una o más caracteres de palabras constituyente y <samp>\\W*</samp> asocia cero o más caracteres que no constituyen palabras.</p>
<div class="example-block" >
<pre class="example" >\\(\\(\\w+\\)\\W*\\)\\1
</pre>
</div>
<p>De nuevo, no útil.</p>
<p>Aquí está el patrón que uso. No es perfecto, pero suficientemente bueno. <samp>\\b</samp> asocia la cadena vacía provista al principio o fin de una palabra; <samp>[^@ \n\t]+</samp> asocia una o más ocurrencias de qué caracteres que <em>no</em> son un @-signo, espacio, nueva línea, o tabulador.</p>
<div class="example-block" >
<pre class="example" >\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
</pre>
</div>
<p>Uno puede escribir expresiones más complicadas, pero esta expresión es suficientemente buena así.</p>
<p>Aquí está la función <code>the-the</code>, como se incluye en mi fichero <span class="file" >.emacs</span>, a lo largo de un atajo global manejable:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">the-the</span> <span class="p">()</span>
  <span class="s">&#34;Busca hacia adelante para una palabra duplicada.&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Buscando palabras duplicadas ...&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span><span class="p">)</span>
  <span class="c1">;; Este regexp no es perfecto</span>
  <span class="c1">;; pero es limpiamente bueno a pesar de todo:</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">re-search-forward</span>
       <span class="s">&#34;\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b&#34;</span> <span class="no">nil</span> <span class="ss">&#39;move</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Palabra encontrada duplicada.&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">message</span> <span class="s">&#34;Fin de búfer&#34;</span><span class="p">)))</span>

<span class="c1">;; Asocia ‘the-the’ a  C-c \</span>
<span class="p">(</span><span class="nv">global-set-key</span> <span class="s">&#34;\C-c\\&#34;</span> <span class="ss">&#39;the-the</span><span class="p">)</span>
</code></pre>
<p>Aquí está el test del texto:</p>
<div class="example-block" >
<pre class="example" >uno dos tres cuatro cinco
cinco seis siete
</pre>
</div>
<p>Se pueden sustituir las otras expresiones regulares mostradas debajo en la definición de función y se prueba cada una de ellas en esta lista.</p>
</div>
<h3 id="apéndice-b-manejando-el-anillo-de-la-muerte" >Apéndice B Manejando el anillo de la muerte</h3>
<div class="hBody-3" >
<p>El anillo de la muerte es una lista que es transformada dentro de un anillo que trabaja con la función <code>current-kill</code>. Los comandos <code>yank</code> y <code>yank-pop</code> usan la función <code>current-kill</code>.</p>
<p>Este apéndice describe la función <code>current-kill</code> y los comandos <code>yank</code> y <code>yank-pop</code>, pero primero, considere los trabajo del kill ring.</p>
<p>El anillo de la muerte tiene el tamaño máximo de sesenta elementos; hacer una explicación con este número máximo quedaría demasiado larga. En vez de eso, pensemos qué ocurre si se asígna a cuatro. Por favor, evalúe lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">old-kill-ring-max</span> <span class="nv">kill-ring-max</span><span class="p">)</span>
<span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-max</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Entonces, por favor, copie cada línea del siguiente ejemplo indentado dentro del anillo de la muerte. Se puede cortar cada línea con <kbd>C-k</kbd> o marcarla y copiarla con <kbd>M-w</kbd>.</p>
<p>(En un búfer de solo lectura, tal como el búfer <span class="file" >*info*</span>, el comando kill, <kbd>C-k</kbd> (<code>kill-line</code>), no eliminará el texto, solamente lo mueve al anillo de la muerte. Sin embargo, el ordenador puede avisar con un beep. Alternativamente, para silenciar, se puede copiar la región de cada línea con el comando <kbd>M-w</kbd> (<code>kill-ring-save</code>). Se debe marcar cada línea de este comando para tener éxito, pero no importa si al final se posiciona en el punto o la marca).</p>
<p>Por favor, invoque las llamadas en orden, de modo que los cinco elementos rellenen el anillo de la muerte.</p>
<div class="example-block" >
<pre class="example" >primero algo de texto
segunda pieza de texto
tercera línea
cuarta línea de texto
quinto bit de texto
</pre>
</div>
<p>Entonces encuentra el valor de <code>kill-ring</code> evaluando</p>
<div class="example-block" >
<pre class="example" >kill-ring
</pre>
</div>
<p>Eso es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="s">&#34;quinto bit de texto&#34;</span> <span class="s">&#34;cuarta línea de texto&#34;</span>
<span class="s">&#34;tercera línea&#34;</span> <span class="s">&#34;segunda pieza de texto&#34;</span><span class="p">)</span>
</code></pre>
<p>El primer elemento, <samp>primero algo de texto</samp>, fué borrado.</p>
<p>Para devolver el viejo valor para el tamaño del kill ring, evalúe:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-max</span> <span class="nv">old-kill-ring-max</span><span class="p">)</span>
</code></pre>
</div>
<h4 id="la-función-current-kill" >La función <code>current-kill</code></h4>
<div class="hBody-4" >
<p>La función <code>current-kill</code> cambia el elemento en el anillo de la muerte <em>kill ring</em> para el que el <code>kill-ring-yank-pointer</code> apunta. (También, la función <code>kill-new</code> asigna <code>kill-ring-yank-pointer</code> para apuntar al último elemento del anillo de la muerte. La función <code>kill-new</code> se usa directamente o indirectamente por <code>kill-append</code>, <code>copy-region-as-kill</code>, <code>kill-ring-save</code>, <code>kill-line</code>, y <code>kill-region</code>.)</p>
<p>La función <code>current-kill</code> es usada por <code>yank</code> y por <code>yank-pop</code>. Aquí está el código para <code>current-kill</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">current-kill</span> <span class="p">(</span><span class="nv">n</span> <span class="kp">&amp;optional</span> <span class="nv">do-not-move</span><span class="p">)</span>
<span class="s">&#34;Rota el punto de pegue por N lugares, y entonces devuelve lo cortado.
</span><span class="s">Si N es cero, ‘interprogram-paste-function’ se asigna, y si se llama
</span><span class="s">devuelve una cadena, entonces esta cadena se añade al frente del
</span><span class="s">anillo de la muerte y devuelve el último corte.
</span><span class="s">Si el argumento opcional DO-NOT-MOVE es no nulo, entonces no muevas el
</span><span class="s">punto de pegue; solo devuelve el Nth corte hacia adelante.
</span><span class="s">   (let ((interprogram-paste (and (= n 0)
</span><span class="s">                                  interprogram-paste-function
</span><span class="s">                                  (funcall interprogram-paste-function)))))
</span><span class="s">    (if interprogram-paste
</span><span class="s">        (progn
</span><span class="s">          ;; Deshabilita el programa de la función de corte cuando se
</span><span class="s">          ;; añade el nuevo texto al anillo de la muerte,
</span><span class="s">          ;; así Emacs no intenta poseer la selección
</span><span class="s">          ;; con idéntico texto.
</span><span class="s">          (let ((interprogram-cut-function nil))
</span><span class="s">            (kill-new interprogram-paste))
</span><span class="s">          interprogram-paste)
</span><span class="s">      (or kill-ring (error &#34;</span><span class="nv">Kill</span> <span class="nv">ring</span> <span class="nv">is</span> <span class="nv">empty</span><span class="s">&#34;))
</span><span class="s">      (let ((ARGth-kill-element
</span><span class="s">             (nthcdr (mod (- n (length kill-ring-yank-pointer))
</span><span class="s">                          (length kill-ring))
</span><span class="s">                     kill-ring)))
</span><span class="s">        (or do-not-move
</span><span class="s">            (setq kill-ring-yank-pointer ARGth-kill-element))
</span><span class="s">        (car ARGth-kill-element)))))
</span><span class="s"></span></code></pre>
<p>Recuerde también que la función <code>kill-new</code> asigna <code>kill-ring-yank-pointer</code> al último elemento del anillo de la muerte <em>kill ring</em>, que significa que todas las funciones lo llaman y asigna el valor de manera indirecta: <code>kill-append</code>, <code>copy-region-as-kill</code>, <code>kill-ring-save</code>, <code>kill-line</code> y <code>kill-region</code>.</p>
<p>Aquí está la línea en <code>kill-new</code>, que se explica en la <a href="La-función-kill-new" >La función <code>kill-new</code></a>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">kill-ring</span><span class="p">)</span>
</code></pre>
<p>La función <code>current-kill</code> parece compleja, pero usual, eso puede ser comprendido tomándolo aparte pieza por pieza. Primero míralo en la forma esquelética:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">current-kill</span> <span class="p">(</span><span class="nv">n</span> <span class="kp">&amp;optional</span> <span class="nv">do-not-move</span><span class="p">)</span>
  <span class="s">&#34;Rota el punto a pegar por N lugares, y entonces devuelve el texto cortado.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="nv">@V{varlist}</span>
    <span class="nv">@V{body}</span><span class="err">…</span><span class="p">)</span>
</code></pre>
<p>Esta función tiene dos argumentos, uno es opcional. Hay una cadena de documentación. <em>No</em> es una función interactiva.</p>
<p>El cuerpo de la definición de función es una expresión <code>let</code>, que por sí misma tiene tanto un cuerpo como una varlist.</p>
<p>La expresión <code>let</code> declara una variable que será solo usable con las asociaciones de esta función. Esta variable se llama <code>interprogram-paste</code> y se copia a otro programa. No se copia con esta instancia de GNU Emacs. La mayoría de los sistemas de ventanas proveen una facilidad para pegar el interprograma. Tristemente, esta facilidad normalmente provee solo el último elemento. La mayoría de los sistemas de ventanas no han adoptado un anillo de muchas posibilidades, incluso aunque Emacs haya provisto esto durante décadas.</p>
<p>La expresión <code>if</code> tiene dos partes, una si existe <code>interprogram-paste</code> y otra si no.</p>
<p>Permítenos considerar el ‘si no’ o la parte else de la función <code>current-kill</code>. (La parte then usa la función <code>kill-new</code>, que ya hemos descrito. Vea la Seccion <a href="La-función-kill-new." >La función <code>kill-new</code>.</a>)</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">or</span> <span class="nv">kill-ring</span> <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;El Kill ring está vacío&#34;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">ARGth-kill-element</span>
       <span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring-yank-pointer</span><span class="p">))</span>
                    <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">))</span>
               <span class="nv">kill-ring</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">or</span> <span class="nv">do-not-move</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="nv">ARGth-kill-element</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">car</span> <span class="nv">ARGth-kill-element</span><span class="p">))</span>
</code></pre>
<p>El código primero chequea si el kill ring <em>anillo de la muerte</em> tiene contenido; de otro modo señala un error.</p>
<p>Note que la expresión <code>or</code> es muy similar para testear el tamaño con un <code>if</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">))</span>          <span class="c1">; parte-si</span>
    <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;Anillo de la muerte vacío&#34;</span><span class="p">))</span>       <span class="c1">; parte-entonces</span>
  <span class="c1">;; No hay parte-resto</span>
</code></pre>
<p>Si no hay nada en el kill ring <em>anillo de la muerte</em>, su tamaño debe ser cero y un mensaje de error se envía al usuario: <samp>El kill ring está vacío</samp>. La función <code>current-kill</code> usa una expresión <code>or</code> que es simple. Pero una expresión <code>if</code> recuerda lo que lleva.</p>
<p>Esta expresión <code>if</code> usa la función <code>zerop</code> que devuelve cierto si el valor que se chequea es cero. Cuando <code>zerop</code> chequea cierto, la parte then del <code>if</code> se evalúa. La parte then es una lista empezando con la función <code>error</code>, que es una función que es similar a la función <code>message</code> (Vease Sección <a href="message,-,-La-Función-message" >message, , La Función <code>message</code></a>) que imprime un mensaje de una línea en el área de eco. Sin embargo, además de imprimir un mensaje, <code>error</code> también evalúa la función que está embebida. Esto significa que el resto de la función no será evaluada si el tamaño del anillo de la muerte es cero.</p>
<p>Entonces la función <code>current-kill</code> selecciona el elemento a devolver. La selección depende del número de lugares que <code>current-kill</code> rota y donde <code>kill-ring-yank-pointer</code> apunta.</p>
<p>Lo siguiente, si el argumento <code>do-not-move</code> opcional es verdadero o el actual valor de <code>kill-ring-yank-pointer</code> se establece al punto de la lista. Finalmente, otra expresión devuelve el primer elemento de la lista incluso si el argumento <code>do-not-move</code> es verdadero.</p>
<p>En mi opinión, es ligeramente erróneo, al menos para humanos, usar el término ‘error’ como el nombre de la función <code>error</code>. Un término mejor sería ‘cancelar’. Estrictamente hablando, de acuerdo, no se puede apuntar, mucho menos rotar un puntero a una lista que no tiene tamaño, así desde el punto de vista del ordenador, la palabra ‘error’ es correcta. Pero un humano espera intentar algo, si solo si se encuentra el anillo de la muerte esté lleno o vacío. Esto es un acto de exploración.</p>
<p>Desde el punto de vista humano, el acto de exploración y descubrimiento no es necesariamente un error, y por esta razón no sería etiquetado como tal, incluso las vocales de un ordenador. Como tal, el código en Emacs implica que un humano que está actuando virtuosamente, explorando su entorno, está teniendo un error. Esto está mal. Incluso aunque el ordenador tome los mismos pasos como cuando hay ‘error’, un término tal como ‘cancelar’ tendría una clara connotación.</p>
<p>Entre otras acciones, la else-part de la expresión <code>if</code> asigna el valor de <code>kill-ring-yank-pointer</code> a <code>ARGth-kill-element</code> cuando el kill ring <em>anillo de la muerte</em> tiene alguna cosa dentro y el valor de <code>do-not-move</code> es <code>nil</code>.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="nv">n</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring-yank-pointer</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">length</span> <span class="nv">kill-ring</span><span class="p">))</span>
        <span class="nv">kill-ring</span><span class="p">)))</span>
</code></pre>
<p>Esto necesita algún examen. A menos que no se suponga mover el puntero, la función <code>current-kill</code> cambia donde <code>kill-ring-yank-pointer</code> apunta. Esto es lo que la expresión <code>(setq kill-ring-yank-pointer ARGth-kill-element)</code> hace. También, claramente, <code>ARGth-kill-element</code> está siendo asignado para ser igual a algún <code>cdr</code> del anillo de la muerte, usando la función <code>nthcdr</code> que está descrita en una sección temprana. (Vea la Seccion <a href="copy-region-as-kill" >copy-region-as-kill</a>.)  ¿Cómo se hace?</p>
<p>Como se ha visto antes (Vease Sección <a href="nthcdr" >nthcdr</a>), la función <code>nthcdr</code> funciona repetidamente tomando el <code>cdr</code> de una lista––eso toma el <code>cdr</code>, del <code>cdr</code>, del <code>cdr</code>, …</p>
<p>Las siguientes dos expresiones producen el mismo resultado:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">kill-ring</span><span class="p">))</span>

<span class="p">(</span><span class="nb">setq</span> <span class="nv">kill-ring-yank-pointer</span> <span class="p">(</span><span class="nf">nthcdr</span> <span class="mi">1</span> <span class="nv">kill-ring</span><span class="p">))</span>
</code></pre>
<p>Sin embargo, la expresión <code>nthcdr</code> es más complicada. Usa la función <code>mod</code> para determinar que <code>cdr</code> para seleccionar.</p>
<p>(Se recordará buscar funciones propias primero, en vez de esto, tendremos que ir dentro del <code>mod</code>.)</p>
<p>La función <code>mod</code> devuelve el valor de su primer argumento módulo el segundo; que es decir, eso devuelve el resto después de dividir el primer argumento por el segundo. El valor devuelto tiene el mismo signo que el segundo argumento.</p>
<p>De este modo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mod</span> <span class="mi">12</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">0</span>  <span class="c1">;; porque no hay resto</span>
<span class="p">(</span><span class="nf">mod</span> <span class="mi">13</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">1</span>
</code></pre>
<p>En este caso, el primer argumento es con frecuencia pequeño que el segundo. Que está bien.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mod</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">0</span>
<span class="p">(</span><span class="nf">mod</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>
  <span class="err">⇒</span> <span class="mi">1</span>
</code></pre>
<p>Se puede adivinar lo que la función <code>-</code> hace. Eso es como <code>+</code> pero sustrae en vez de añadir; la función <code>-</code> sustrae su segundo argumento desde el primero. También, ya se sabe que la función <code>length</code> hace (Vease Sección <a href="#descubrir-la-longitud-de-una-lista:-length" >Descubrir la longitud de una lista: <code>length</code></a>). Eso devuelve el tamaño de una lista.</p>
<p>Y <code>n</code> es el nombre del argumento requerido a la función <code>current-kill</code>.</p>
<p>Así cuando el primer argumento a <code>nthcdr</code> es cero, la expresión <code>nthcdr</code> devuelve la lista entera, como se puede ver evaluando lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; kill-ring-yank-pointer @e{and} kill-ring @e{tener un tamaño de cuatro}</span>
<span class="c1">;; @e{and} (mod (- 0 4) 4) ⇒ 0</span>
<span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;cuarta línea de texto&#34;</span>
          <span class="s">&#34;tercera línea&#34;</span>
          <span class="s">&#34;segunda pieza de texto&#34;</span>
          <span class="s">&#34;primero algo de texto&#34;</span><span class="p">))</span>
</code></pre>
<p>Cuando el primer argumento a la función <code>current-kill</code> es uno, la expresión <code>nthcdr</code> devuelve la lista sin su primer elemento.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">nthcdr</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="nf">-</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;cuarta línea de texto&#34;</span>
          <span class="s">&#34;tercera línea&#34;</span>
          <span class="s">&#34;segunda pieza de texto&#34;</span>
          <span class="s">&#34;primero algo de texto&#34;</span><span class="p">))</span>
</code></pre>
<p>Incidentalmente, tanto <code>kill-ring</code> y <code>kill-ring-yank-pointer</code> son <dfn>variables globales</dfn>. Esto significa que cualquier expresión en Emacs Lisp puede acceder a ellas. Ellas no son como las variables locales asignadas por <code>let</code> o como los símbolos en una lista de argumentos. Las variables locales pueden solo ser accedidas con el <code>let</code> que los define o la función que los especifica en una lista de argumentos (y con expresiones llamadas por ellos).</p>
</div>
<h4 id="pegar" ><code>pegar</code></h4>
<div class="hBody-4" >
<p>Después de aprender acerca de <code>current-kill</code>, el código para la función <code>yank</code> es casi fácil.</p>
<p>La función <code>yank</code> no usa la variable <code>kill-ring-yank-pointer</code> directamente. Eso llama a <code>insert-for-yank</code> que llama a <code>current-kill</code> que asigna la variable <code>kill-ring-yank-pointer</code>.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">yank</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;Reinserta (\&#34;pega\&#34;) el último logro del texto cortado.
</span><span class="s">Más precisamente, reinserta el texto cortado más recientemente.
</span><span class="s">Pon el punto al final, y asigna la marca al principio.
</span><span class="s">Solo con \\[universal-argument] como argumento, lo mismo pero pon el
</span><span class="s">punto al principio (y la marca al final). Con el argumento N, reinserta
</span><span class="s">el N más recientemente cortado.
</span><span class="s">Cuando este comando inserta texto cortado dentro del búfer, eso
</span><span class="s">honra a ‘yank-excluded-properties’ y ‘yank-handler’ como se describe
</span><span class="s">la cadena de documentación para ‘insert-for-yank-1’, que se ve.
</span><span class="s">Ver también el comando \\[yank-pop].&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*P&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">yank-window-start</span> <span class="p">(</span><span class="nf">window-start</span><span class="p">))</span>
  <span class="c1">;; Si no tenemos todo el camino a través, crea last-command que</span>
  <span class="c1">;; indique esto para el siguiente comando.</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="no">t</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">push-mark</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
  <span class="p">(</span><span class="nv">insert-for-yank</span> <span class="p">(</span><span class="nv">current-kill</span> <span class="p">(</span><span class="nb">cond</span>
                                  <span class="p">((</span><span class="nf">listp</span> <span class="nv">arg</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                                  <span class="p">((</span><span class="nf">eq</span> <span class="nv">arg</span> <span class="ss">&#39;-</span><span class="p">)</span> <span class="mi">-2</span><span class="p">)</span>
                                  <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">arg</span><span class="p">)))))</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">consp</span> <span class="nv">arg</span><span class="p">)</span>
      <span class="c1">;; Esto es como like exchange-point-and-mark,</span>
      <span class="c1">;;     pero no activa la marca.</span>
      <span class="c1">;; Es limpio evitar la activación, incluso aunque el comando</span>
      <span class="c1">;; loop would desactivaría la marca porque se</span>
      <span class="c1">;; insertara el texto.</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">)</span>
                   <span class="p">(</span><span class="nf">set-marker</span> <span class="p">(</span><span class="nf">mark-marker</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)))))</span>
  <span class="c1">;; Si tenemos todo el camino, haz que this-command lo indique.</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">this-command</span> <span class="no">t</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;yank</span><span class="p">))</span>
  <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>La expresión clave es <code>insert-for-yank</code>, que inserta la cadena devuelta por <code>current-kill</code>, pero elimina algo de propiedades de texto desde eso.</p>
<p>Sin embargo, antes de tener esta expresión, la función asigna el valor de <code>yank-window-start</code> a la posición devuelta por la expresión <code>(window-start)</code>, la posición que muestra lo que actualmente empieza. La función <code>yank</code> también asigna <code>this-command</code> y empuja la marca.</p>
<p>Después de pegar el elemento apropiado, si el argumento opcional es un <code>cons</code> en vez de un número o nada, se pone el punto al principio del texto pegado y se marca al final.</p>
<p>(La función <code>prog1</code> es como <code>progn</code> pero devuelve el valor de su primer argumento en vez del valor de su último argumento. Su primer argumento fuerza devolver la marca del búfer como un entero. Se puede ver la documentación para estas funciones emplazando el punto a través de ellas en este búfer y entonces escribiendo <kbd>C-h f</kbd> (<code>describe-function</code>) seguido por un <kbd>RET</kbd>; por defecto es la función.)</p>
<p>La última parte de la función cuenta que hacer cuando eso sucede.</p>
</div>
<h4 id="yank-pop" ><code>yank-pop</code></h4>
<div class="hBody-4" >
<p>Después de comprender <code>yank</code> y <code>current-kill</code>, se conoce como enfocar la función <code>yank-pop</code>. Dejando fuera la documentación para guardar el espacio, se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">yank-pop</span> <span class="p">(</span><span class="kp">&amp;optional</span> <span class="nv">arg</span><span class="p">)</span>
  <span class="s">&#34;…&#34;</span>
  <span class="p">(</span><span class="nb">interactive</span> <span class="s">&#34;*p&#34;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">not</span> <span class="p">(</span><span class="nf">eq</span> <span class="nv">last-command</span> <span class="ss">&#39;yank</span><span class="p">))</span>
      <span class="p">(</span><span class="ne">error</span> <span class="s">&#34;El comando previo no fué un corte&#34;</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setq</span> <span class="nv">this-command</span> <span class="ss">&#39;yank</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">unless</span> <span class="nv">arg</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">arg</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">inhibit-read-only</span> <span class="no">t</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">before</span> <span class="p">(</span><span class="nf">&lt;</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">if</span> <span class="nv">before</span>
        <span class="p">(</span><span class="nf">funcall</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">yank-undo-function</span> <span class="ss">&#39;delete-region</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">funcall</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">yank-undo-function</span> <span class="ss">&#39;delete-region</span><span class="p">)</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">yank-undo-function</span> <span class="no">nil</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">set-marker</span> <span class="p">(</span><span class="nf">mark-marker</span><span class="p">)</span> <span class="p">(</span><span class="nf">point</span><span class="p">)</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">insert-for-yank</span> <span class="p">(</span><span class="nv">current-kill</span> <span class="nv">arg</span><span class="p">))</span>
    <span class="c1">;; Asigna la ventana a volver donde estaba el comando yank,</span>
    <span class="c1">;; si es posible</span>
    <span class="p">(</span><span class="nf">set-window-start</span> <span class="p">(</span><span class="nf">selected-window</span><span class="p">)</span> <span class="nv">yank-window-start</span> <span class="no">t</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">if</span> <span class="nv">before</span>
        <span class="c1">;; Esto es como exchange-point-and-mark,</span>
        <span class="c1">;; pero no activa la marca.</span>
        <span class="c1">;; Es limpio evitar la activación, incluso aunque el comando</span>
        <span class="c1">;; desactivase la marca porque se insertara el texto.</span>
        <span class="p">(</span><span class="nf">goto-char</span> <span class="p">(</span><span class="nb">prog1</span> <span class="p">(</span><span class="nv">mark</span> <span class="no">t</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">set-marker</span> <span class="p">(</span><span class="nf">mark-marker</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nf">point</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nf">current-buffer</span><span class="p">))))))</span>
  <span class="no">nil</span><span class="p">)</span>
</code></pre>
<p>La función es interactive con una pequeña <samp>p</samp> así el argumento prefijo es procesado y pasado a la función. El comando puede solo ser usado después del yank previo; de otro modo un mensaje de error se envía. Este chequeo usa la variable <code>last-command</code> que se asigna por <code>yank</code> y discutida de algún modo. (Vea la Seccion <a href="copy-region-as-kill" >copy-region-as-kill</a>.)</p>
<p>La cláusula <code>let</code> asigna la variable <code>before</code> a cierto o falso dependiendo de si el punto está antes o después de la marca y entonce la región entre punto y marca se borra. Esta es la región que fué insertada por el yank previo y eso es este texto que será reemplazado.</p>
<p><code>funcall</code> llama a su primer argumento como una función, pasando los argumentos que permanecen. El primer argumento es el que la expresión <code>or</code> devuelve. Los dos argumentos que permanecen son las posiciones de punto y marca asignadas por el comando <code>yank</code> precedente.</p>
<p>Hay más, pero esta es la parte más dura.</p>
</div>
<h4 id="el-fichero-ring.el" >El fichero <span class="file" >ring.el</span></h4>
<div class="hBody-4" >
<p>De manera interesante, GNU Emacs posee un fichero llamado <span class="file" >ring.el</span> que provee muchas de las funcionalidades que ahora se discuten. Pero las funciones tales como <code>kill-ring-yank-pointer</code> no usan esta librería, posiblemente porque fueron escritas pronto.</p>
</div>
<h3 id="apéndice-c-un-grafo-con-ejes-etiquetados" >Apéndice C <span id="Un-grafo-con-ejes-etiquetados" >Un grafo con ejes etiquetados</span></h3>
<div class="hBody-3" >
<p>Los ejes impresos ayudan a comprender un grafo. Para crear escalas. En un capítulo anterior (Vease Sección <a href="Leyendo-un-grafo,-,-Leyendo-un-grafo" >Leyendo un grafo, , Leyendo un grafo</a>), se escribió el código para imprimir el cuerpo de un grafo. Aquí se escribe el código para imprimir y etiquetar ejes horizontales y verticales, a lo largo del cuerpo en sí.</p>
<p>Puesto que las inserciones rellenan un búfer a la derecha y debajo del punto, el nuevo grafo imprime la función que primero imprimiría el eje vertical Y, después el cuerpo del grafo, y finalmente el eje horizontal X. Esta secuencia nos da los contenidos de la función:</p>
<ol class="num" >
<li>
<p>Configura código.</p>
</li>
<li>
<p>Imprime el eje Y.</p>
</li>
<li>
<p>Imprime el cuerpo del grafo.</p>
</li>
<li>
<p>Imprime el eje X.</p>
</li>
</ol>
<p>Aquí hay un ejemplo de como se ve un grafo finalizado:</p>
<div class="example-block" >
<pre class="example" >0 -
             *
             *  *
             *  **
             *  ***
5 -      *   *******
       * *** *******
       *************
     ***************
1 - ****************
    |   |    |    |
    1   5   10   15
</pre>
</div>
<p>En este grafo, en ambos ejes vertical y horizontal se etiquetan con números. Sin embargo, en algunos grafos, el eje horizontal es tiempo y estaría mejor etiquetarlo con meses, así:</p>
<div class="example-block" >
<pre class="example" >5 -      *
       * ** *
       *******
     ********** **
1 - **************
    |    ^      |
  Enero Junio Enero
</pre>
</div>
<p>Dentro, con un pequeño pensamiento, se puede fácilmente venir con una variedad de esquemas de etiquetado verticales y horizontales. Nuestra tarea podría llegar a ser complicada. Pero las complicaciones generan confusión. En vez de permitir esto, es mejor elegir un simple esquema de etiquetado para nuestro primer esfuerzo, y modificarlo o reemplazarlo después.</p>
<p>Estas consideraciones sugieren el siguiente outline para la función <code>print-graph</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span>  <span class="err">…</span>
        <span class="err">…</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-Y-axis</span> <span class="nv">height</span> <span class="err">…</span> <span class="p">)</span>
    <span class="p">(</span><span class="nv">graph-body-print</span> <span class="nv">numbers-list</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">print-X-axis</span> <span class="err">…</span> <span class="p">)))</span>
</code></pre>
<p>Nosotros podemos trabajar en cada parte de la definición de función <code>print-graph</code>.</p>
</div>
<h4 id="la-varlist-print-graph" >La varlist <code>print-graph</code></h4>
<div class="hBody-4" >
<p>Para escribir la función <code>print-graph</code>, la primera tarea es escribir la varlist en la expresión <code>let</code>. (Nosotros dejaremos por ahora cualquier pensamiento acerca de hacer la función interactive o acerca de los contenidos de su cadena de documentación.)</p>
<p>La varlist asignaría varios valores. Claramente, la etiqueta superior del eje vertical debe ser al menos la altura del grafo, que significa que debe obtener esta información aquí. Note que la función <code>print-graph-body</code> también requiere esta información. No hay razón para calcular la altura del grafo en dos lugares diferentes, así cambiaría <code>print-graph-body</code> desde el camino que definimos pronto para tomar ventaja del cálculo.</p>
<p>De manera similar, tanto la función para imprimir la etiqueta del eje X y la función <code>print-graph-body</code> se necesita aprender el valor del ancho de cada símbolo. Se puede desarrollar el cálculo aquí y cambiar la definición para <code>print-graph-body</code> desde el camino que se definió en el capítulo previo.</p>
<p>El tamaño de la etiqueta para el eje horizontal debe ser al menos tan largo como el grafo. Sin embargo, esta información es usada solo en la función que imprime el eje horizontal, así no necesita calcularse aquí.</p>
<p>Estos pensamientos nos llevan directamente a la siguiente forma para la varlist en el <code>let</code> para <code>print-graph</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">numbers-list</span><span class="p">))</span> <span class="c1">; Primera versión.</span>
      <span class="p">(</span><span class="nv">symbol-width</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">graph-blank</span><span class="p">)))</span>
</code></pre>
<p>Como se verá, esta expresión no es bastante correcta.</p>
</div>
<h4 id="la-función-print-y-axis" >La función <code>print-Y-axis</code></h4>
<div class="hBody-4" >
<p>El trabajo de la función <code>print-Y-axis</code> es imprimir una etiqueta para el eje vertical que se parece a esto:</p>
<div class="example-block" >
<pre class="example" >    10 -




     5 -



     1 -
</pre>
</div>
<p>La función se pasaría a lo alto del grafo, y así construyen e insertan los números y marcas apropiados.</p>
<p>Es suficientemente fácil ver en la figura que la etiqueta del eje Y pero se puede decir en palabras, y entonces escribir una definición de función para hacer el trabajo es otra materia. No es bastante verdad decir que se quiere un número y un tic cada cinco líneas: solo hay tres líneas entre el <samp>1</samp> y el <samp>5</samp> (líneas 2, 3 y 4), pero cuatro líneas entre el <samp>5</samp> y el <samp>10</samp> (líneas 6, 7, 8 y 9). Es mejor decir que se quiere un número y un tic en la quinta línea desde abajo a cada línea que es un múltiplo de cinco.</p>
<p>La siguiente cuestión es a que altura se etiquetaría. Supón que la máxima altura de la columna mayor del grafo es siete. La etiqueta superior en el eje Y sería <samp>5 -</samp>, ¿y el grafo se pegaría debajo de la etiqueta?, ¿o la etiqueta superior sería <samp>7 -</samp>, y marcar la vertical del grafo? ¿o sería la etiqueta superior <code>10 -</code>, que es múltiplo de cinco, y es superior al valor más alto del grafo?</p>
<p>La última forma es preferida. La mayoría de los grafos son rectángulos cuyos lados son un número integral de pasos a lo largo––5, 10, 15, y así para un paso a distancia de cinco. Pero tan pronto se decide usar un paso alto para el eje vertical, se descubre que la expresión simple en la varlist para la altura de la computación es errónea. La expresión es <code>(apply &#39;max numbers-list)</code>. Esto devuelve la altura precisa, no la altura máxima más de lo que es necesario para redondear el múltiplo de cinco. Una expresión más compleja es requerida.</p>
<p>Como es normal en casos como este, un problema complejo llega a ser simple si está dividido en varios problemas pequeños.</p>
<p>Primero, considere el caso cuando el valor superior del grafo es un múltiplo integral de cinco––cuando eso es 5, 10, 15, o algún múltiplo de cinco. Se puede usar este valor como la altura del eje Y.</p>
<p>Un camino simple y limpio para determinar si un número es múltiplo de cinco se divide por cinco y mira si la división devuelve resto. Si no hay resto, el número es un múltiplo de cinco. De este modo, siete dividido tiene un resto de dos, y siete no es un entero múltiplo de cinco. Dicho de otra manera, recordando la escuela, cinco entre siete es uno y me llevo dos. Sin embargo, diez entre dos, no tiene resto: diez es un múltiplo entero de cinco.</p>
</div>
<h5 id="viaje-lateral:-calcula-un-resto" >Viaje lateral: Calcula un resto</h5>
<div class="hBody-5" >
<p>En Lisp, la función para calcular un resto es <code>%</code>. La función devuelve el resto de su primer argumento dividido por su segundo argumento. Como ocurre, <code>%</code> es una función en Emacs Lisp que no se puede implementar usando <code>apropos</code>: no se puede encontrar nada si se escribe <kbd>M-x apropos <kbd>RET</kbd> resto <kbd>RET</kbd></kbd>. El único camino para aprender la existencia de <code>%</code> es leer acerca de eso en un libro tal como este o en las fuentes de Emacs Lisp.</p>
<p>Se puede probar la función <code>%</code> evaluando las siguientes dos expresiones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">%</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">)</span>

<span class="p">(</span><span class="nf">%</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>La primera expresión devuelve 2 y la segunda expresión devuelve 0.</p>
<p>Para chequear si el valor devuelto es cero o algún otro número, se puede usar la función <code>zerop</code>. Esta función devuelve <code>t</code> si su argumento debe ser un número, es cero.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="mi">7</span> <span class="mi">5</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">nil</span>

<span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="mi">10</span> <span class="mi">5</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="no">t</span>
</code></pre>
<p>De este modo, la siguiente expresión devolverá <code>t</code> si la altura del grafo es divisible por cinco:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="mi">5</span><span class="p">))</span>
</code></pre>
<p>(El valor de <code>height</code>, de acuerdo, puede ser encontrado desde <code>(apply &#39;max numbers-list)</code>.)</p>
<p>Por otro lado, si el valor de <code>height</code> no es un múltiplo de cinco, nosotros queremos resetear el valor al siguiente múltiplo de cinco. Esta es la aritmética sencilla usando funciones con las que ya se está familiarizado. Primero, se divide el valor de <code>height</code> por cinco para determinar cuantas veces cinco va dentro del número. De este modo, cinco va dentro doce veces. Si se añade uno a este cociente y se multiplica por cinco, obtendremos el valor del siguiente múltiplo de cinco que es más largo que el mayor. Cinco va dentro de doce dos veces. Añade uno a dos, y multiplica por cinco; el resultado es quince, que es el siguiente múltiplo de cinco que es mayor de doce. La expresión Lisp para esto es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">height</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>Por ejemplo, si se evalúa lo siguiente, el resultado es 15:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="mi">12</span> <span class="mi">5</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
<p>Todo a través de esta discusión, se ha estado usando ‘cinco’ como el valor para las etiquetas espaciadas en el eje Y; pero se puede querer usar algún otro valor. Generalmente, reemplazaría ‘cinco’ con una variable a la que poder asignar un valor. El mejor nombre que puedo pensar para esta variable es <code>Y-axis-label-spacing</code>.</p>
<p>Usando este término, y una expresión <code>if</code>, se produce lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
    <span class="nv">height</span>
  <span class="c1">;; else</span>
  <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
     <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
</code></pre>
<p>Esta expresión devuelve el valor de <code>height</code> en sí si la altura es incluso un múltiplo del valor del <code>Y-axis-label-spacing</code> o lo demás computa y devuelve un valor de <code>height</code> que es igual al siguiente múltiplo mayor del valor del <code>Y-axis-label-spacing</code>.</p>
<p>Se puede ahora incluir esta expresión en la expresión <code>let</code> de la función <code>print-graph</code> (después de la primera configuración del valor de <code>Y-axis-label-spacing</code>):</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">Y-axis-label-spacing</span> <span class="mi">5</span>
  <span class="s">&#34;Número de líneas desde una etiqueta del eje Y al siguiente.&#34;</span><span class="p">)</span>

<span class="err">…</span>
<span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">height</span> <span class="p">(</span><span class="nf">apply</span> <span class="ss">&#39;max</span> <span class="nv">numbers-list</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">height-of-top-line</span>
        <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
            <span class="nv">height</span>
          <span class="c1">;; else</span>
          <span class="p">(</span><span class="nf">*</span> <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
             <span class="nv">Y-axis-label-spacing</span><span class="p">)))</span>
       <span class="p">(</span><span class="nv">symbol-width</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">graph-blank</span><span class="p">))))</span>
<span class="err">…</span>
</code></pre>
<p>(Note que el uso de la función <code>let*</code>: el valor inicial de la altura es calculada una vez por la expresión <code>(apply &#39;max numbers-list)</code> y entonces el valor resultado de <code>height</code> es usado para computar su valor final. Vea la Seccion <a href="La-expresión-let*" >La expresión <code>let*</code></a>, para más acerca de <code>let*</code>.)</p>
</div>
<h5 id="construye-un-elemento-del-eje-y" >Construye un elemento del eje Y</h5>
<div class="hBody-5" >
<p>Cuando se imprime el eje vertical, se quieren insertar cadenas tales como <samp>5 -</samp> y <samp>10 - </samp> cada cinco líneas. Más allá, se quieren los números agitados para alinear, así pocos números deben ser acuñados con espacios de guía. Si alguna de las cadenas usan dos dígitos, las cadenas con un simple dígito deben incluir una guía en blanco antes del número.</p>
<p>Para figurarse el tamaño del número, se usa la función <code>length</code>. Pero la función <code>length</code> funciona solo con una cadena, no con un número. Así el número tiene que ser convertido desde un número a una cadena. Esto se hace con la función <code>number-to-string</code>. Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="mi">35</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">2</span>

<span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="mi">100</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="mi">3</span>
</code></pre>
<p>(<code>number-to-string</code> se llama <code>int-to-string</code>; se verá este nombre alternativo en varias fuentes.)</p>
<p>Además, en cada etiqueta, cada número es seguido por una cadena tal como <samp> - </samp>, que llamará al marcador <code>Y-axis-tic</code>. Esta variable está definida con <code>defvar</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">Y-axis-tic</span> <span class="s">&#34; - &#34;</span>
   <span class="s">&#34;La Cadena que sigue el número en una etiqueta del eje Y.&#34;</span><span class="p">)</span>
</code></pre>
<p>El tamaño de la etiqueta Y es la suma del tamaño del eje Y y el tamaño del número del alto del grafo.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">height</span><span class="p">)</span> <span class="nv">Y-axis-tic</span><span class="p">)))</span>
</code></pre>
<p>Este valor será calculado por la función <code>print-graph</code> en su varlist como <code>full-Y-label-width</code> y se pasa dentro. (Note que no se pensaba en incluir esto en el varlist cuando se propuso.)</p>
<p>Para crear un eje vertical completo, una marca de tic es concatenada con un número; y los dos juntos pueden ser precedidos por uno o más espacios dependiendo de cómo de largo es el número. La etiqueta consiste de tres partes: los espacios que se lideran (opcional), el número, y la marca tic. La función se pasa al valor del número para la fila específica, y el valor del ancho de la línea de arriba, que es calculada (solo una vez) por <code>print-graph</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">Y-axis-element</span> <span class="p">(</span><span class="nv">number</span> <span class="nv">full-Y-label-width</span><span class="p">)</span>
  <span class="s">&#34;Construye una etiqueta NUMERADA
</span><span class="s">Un elemento numerado se parece a esto ‘ 5 - ’,
</span><span class="s">y está tan acuñado como se necesita así todo se
</span><span class="s">alinea con el elemento para el número mayor.&#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">leading-spaces</span>
         <span class="p">(</span><span class="nf">-</span> <span class="nv">full-Y-label-width</span>
            <span class="p">(</span><span class="nf">length</span>
             <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)</span>
                     <span class="nv">Y-axis-tic</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">concat</span>
     <span class="p">(</span><span class="nf">make-string</span> <span class="nv">leading-spaces</span> <span class="sc">? </span><span class="p">)</span>
     <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)</span>
     <span class="nv">Y-axis-tic</span><span class="p">)))</span>
</code></pre>
<p>La función <code>Y-axis-element</code> concatena junto los espacios que se lideran si cualquiera; el número, como una cadena; y la marca tic.</p>
<p>Para imaginarnos cuantos espacios guía la etiqueta necesita, la función sustrae el tamaño de la etiqueta––el tamaño del número más el tamaño de la marca tic––desde el ancho de la etiqueta deseada.</p>
<p>Los espacios en blanco se insertan usando la función <code>make-string</code>. Esta función tiene dos argumentos: lo primero cuenta como de larga será a cadena y el segundo es un símbolo para el caracter a insertar, en un formato espcial. El formato es una marca de pregunta seguida por un espacio en blanco, como este, <samp>?</samp>. Vea la Seccion <q>Tipo de Caracter</q> en <em>El Manual de Referencia Emacs Lisp</em>, para una descripción de la sintaxis para caracteres. (De acuerdo, se podría querer reemplazar el espacio en blanco por algún otro caracter …. Tu sabes qué hacer.)</p>
<p>La función <code>number-to-string</code> es usada en la expresión de concatenación, para convertir el número a una cadena que es concatenada con los espacios que se lideran y la marca de tic.</p>
</div>
<h5 id="crea-un-eje-de-la-columna-y" >Crea un eje de la columna Y</h5>
<div class="hBody-5" >
<p>Las funciones precedentes proporcionan todas las herramientas necesarias para construir una función que genera una lista de cadenas enumeradas y en blanco para inserta como la etiqueta para el eje vertical:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">Y-axis-column</span> <span class="p">(</span><span class="nv">height</span> <span class="nv">width-of-label</span><span class="p">)</span>
  <span class="s">&#34;Construye la lista de ejes Y etiquetadas y cadenas en blanco.
</span><span class="s">Para height @e{la altura} de la línea de debajo y width-of-label.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">Y-axis</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">height</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
          <span class="c1">;; Insertar etiqueta.</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
                <span class="p">(</span><span class="nf">cons</span>
                 <span class="p">(</span><span class="nv">Y-axis-element</span> <span class="nv">height</span> <span class="nv">width-of-label</span><span class="p">)</span>
                 <span class="nv">Y-axis</span><span class="p">))</span>
        <span class="c1">;; Else, insertar blancos.</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
              <span class="p">(</span><span class="nf">cons</span>
               <span class="p">(</span><span class="nf">make-string</span> <span class="nv">width-of-label</span> <span class="sc">? </span><span class="p">)</span>
               <span class="nv">Y-axis</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">height</span><span class="p">)))</span>
    <span class="c1">;; Insertar la línea base.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
          <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">Y-axis-element</span> <span class="mi">1</span> <span class="nv">width-of-label</span><span class="p">)</span> <span class="nv">Y-axis</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">Y-axis</span><span class="p">)))</span>
</code></pre>
<p>En esta función, nosotros empezamos con el valor de <code>height</code> y repetitivamente sustrae uno desde su valor. Después de cada sustración, se chequea para ver si el valor es una integral múltiple del <code>Y-axis-label-spacing</code>. Si eso es, se construye una etiqueta numerada usando la función <code>Y-axis-element</code>; si no, se construye una etiqueta blanca usando la función <code>make-string</code>. La línea base consiste del número uno seguido por una marca tic.</p>
</div>
<h5 id="la-versión-no-demasiado-final-de-print-y-axis" >La versión no demasiado final de <code>print-Y-axis</code></h5>
<div class="hBody-5" >
<p>La lista construida por la función <code>Y-axis-column</code> está pasada a la función <code>print-Y-axis</code>, que inserta la lista como una columna.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-Y-axis</span> <span class="p">(</span><span class="nv">height</span> <span class="nv">full-Y-label-width</span><span class="p">)</span>
  <span class="s">&#34;Inserta el eje Y usando HEIGHT y FULL-Y-LABEL-WIDTH.
</span><span class="s">La altura debe ser la máxima altura del grafo.
</span><span class="s">El ancho completo es el ancho del mayor elemento de la
</span><span class="s">etiqueta&#34;</span>
<span class="c1">;; El valor del alto y full-Y-label-width</span>
<span class="c1">;; son pasadas por ‘print-graph’.</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">start</span> <span class="p">(</span><span class="nf">point</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">insert-rectangle</span>
     <span class="p">(</span><span class="nv">Y-axis-column</span> <span class="nv">height</span> <span class="nv">full-Y-label-width</span><span class="p">))</span>
    <span class="c1">;; Posiciona el punto listo para inserta el grafo.</span>
    <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">start</span><span class="p">)</span>
    <span class="c1">;; @e{Mueve el punto hacia adelante por valor de} full-Y-label-width</span>
    <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">full-Y-label-width</span><span class="p">)))</span>
</code></pre>
<p>El <code>print-Y-axis</code> usa la función <code>insert-rectangle</code> para inserta el eje Y creado por la función <code>Y-axis-column</code>. Además, eso emplaza el punto en la posición correcta para imprimir el cuerpo del grafo.</p>
<p>Se puede chequear <code>print-Y-axis</code>:</p>
<ul>
<li>
<p>Instalar</p>
<div class="example-block" >
<pre class="example" >Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
</pre>
</div>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-Y-axis</span> <span class="mi">12</span> <span class="mi">5</span><span class="p">)</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li>
<p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pega la expresión <code>graph-body-print</code> dentro del minibúfer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá etiquetas verticalmente, el primero siendo <samp>10 - </samp>. (La función <code>print-graph</code> pasará el valor de <code>height-of-top-line</code>, que en este caso finalizará en 15, por esto lo que se obtiene podría aparecer como un error.)</p>
</div>
<h4 id="la-función-print-x-axis" >La función <code>print-X-axis</code></h4>
<div class="hBody-4" >
<p>Las etiquetas del eje X son como las etiquetas del eje Y, excepto que los ticks son un línea debajo de los números. Las etiquetas se parece como esto:</p>
<div class="example-block" >
<pre class="example" >|   |    |    |
1   5   10   15
</pre>
</div>
<p>El primer tic está bajo la primera columna del grafo y está precedido por varios espacios en blanco. Estos espacios proporcionan la habitación en filas de debajo para las etiquetas del eje Y. El segundo, tercer, cuarto, y subsiguientes ticks son todos espaciados igualmente, de acuerdo al valor de <code>X-axis-label-spacing</code>.</p>
<p>La segunda fila del eje X consiste de números, precedidos por varios espacios en blanco y también separado de acuerdo al valor de la variable <code>X-axis-label-spacing</code>.</p>
<p>El valor de la variable <code>X-axis-label-spacing</code> sería medido en unidades de <code>symbol-width</code>, puesto que se puede querer cambiar el ancho de los símbolos que estás usando para imprimir el cuerpo del grafo sin cambiar los caminos del grafo que está etiquetado.</p>
<p>La función <code>print-X-axis</code> está construida más o menos del mismo modo como que la función <code>print-Y-axis</code> excepto que tiene dos líneas: la línea de marcas tic y los números. Nosotros escribiremos una función separado a imprimir cada línea y entonces combinarlo con la función <code>print-X-axis</code>.</p>
<p>Esto es un proceso de tres pasos:</p>
<ol class="num" >
<li>
<p>Escribe una función para imprimir el eje X marca tic, <code>print-X-axis-tic-line</code>.</p>
</li>
<li>
<p>Escribe una función imprime los números X, <code>print-X-axis-numbered-line</code>.</p>
</li>
<li>
<p>Escribe una función para imprimir ambas líneas, la función <code>print-X-axis</code>, usando <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>.</p>
</li>
</ol>
</div>
<h5 id="eje-x-marca-tic" >Eje X marca tic</h5>
<div class="hBody-5" >
<p>La primera función imprimiría las marcas de tic del eje X. Se deben especificar las marcas en sí y su espacio:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">X-axis-label-spacing</span>
  <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nf">boundp</span> <span class="ss">&#39;graph-blank</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">*</span> <span class="mi">5</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">graph-blank</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
  <span class="s">&#34;Números de unidades desde un eje X al siguiente.&#34;</span><span class="p">)</span>
</code></pre>
<p>(Note que el valor de <code>graph-blank</code> est&#39;a asignado por otro <code>defvar</code>. El predicado <code>boundp</code> chequea si ya ha sido asignado; <code>boundp</code> devuelve <code>nil</code> si no lo tiene. Si <code>graph-blank</code> fuera disociado y no usara esta construcción condicional, en un GNU Emacs reciente, se introduciría el depurador y mirará un mensaje de error diciendo <samp>Debugger entered--Lisp error: (void-variable graph-blank)</samp></p>
<p>Aquí está el <code>defvar</code> para <code>X-axis-tic-symbol</code>:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defvar</span> <span class="nv">X-axis-tic-symbol</span> <span class="s">&#34;|&#34;</span>
  <span class="s">&#34;Cadena para insertar para apuntar a una columna en el eje X.&#34;</span><span class="p">)</span>
</code></pre>
<p>El objetivo es crear una línea que se parece a esto:</p>
<div class="example-block" >
<pre class="example" >|   |    |    |
</pre>
</div>
<p>El primer tic es indentado así que está bajo la primera columna, que es indentado para proveer espacio para las etiquetas del eje Y.</p>
<p>Un elemento tic consiste en espacios en blanco que se extienden desde un tic al siguiente más un símbolo tic. El número de espacios en blanco se determinan por el ancho del símbolo tic y el <code>X-axis-label-spacing</code>.</p>
<p>El código se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; X-axis-tic-element</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">concat</span>
 <span class="p">(</span><span class="nf">make-string</span>
  <span class="c1">;; Crea una cadena de blancos.</span>
  <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">length</span> <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
  <span class="sc">? </span><span class="p">)</span>
 <span class="c1">;; Concatena blancos con símbolos.</span>
 <span class="nv">X-axis-tic-symbol</span><span class="p">)</span>
<span class="err">…</span>
</code></pre>
<p>Lo siguiente, determina cuantos espacios en blanco son necesarios para indentar la primera marca tic a la primera del grafo. Esto usa el valor de <code>full-Y-label-width</code> pasaba por la función <code>print-graph</code>.</p>
<p>El código para crear <code>X-axis-leading-spaces</code> se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; X-axis-leading-spaces</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">make-string</span> <span class="nv">full-Y-label-width</span> <span class="sc">? </span><span class="p">)</span>
<span class="err">…</span>
</code></pre>
<p>También necesita determinar el tamaño del eje horizontal, que es el tamaño de la lista de números, y el número de ticks en el eje horizontal:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;; X-length</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">length</span> <span class="nv">numbers-list</span><span class="p">)</span>

<span class="c1">;; tic-width</span>
<span class="err">…</span>
<span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>

<span class="c1">;; number-of-X-ticks</span>
<span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="p">(</span><span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">))))</span>
</code></pre>
<p>Todo esto lidera directamente a la función para imprimir el eje X:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis-tic-line</span>
  <span class="p">(</span><span class="nv">number-of-X-tics</span> <span class="nv">X-axis-leading-spaces</span> <span class="nv">X-axis-tic-element</span><span class="p">)</span>
  <span class="s">&#34;Imprime ticks para el eje X.&#34;</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-tic-symbol</span><span class="p">)</span>  <span class="c1">; En la primera columna.</span>
    <span class="c1">;; Inserta el segundo tic en el lugar adecuado.</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">concat</span>
             <span class="p">(</span><span class="nf">make-string</span>
              <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
                  <span class="c1">;; Inserta el espacio en blanco al segundo símbolo tic.</span>
                  <span class="p">(</span><span class="nf">*</span> <span class="mi">2</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">X-axis-tic-symbol</span><span class="p">)))</span>
              <span class="sc">? </span><span class="p">)</span>
             <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
    <span class="c1">;; Inserta los ticks que permanecen.</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-X-tics</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-tic-element</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-X-tics</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-X-tics</span><span class="p">))))</span>
</code></pre>
<p>La línea de números es igualmente simple:</p>
<p>Primero, creamos un elemento numerado con espacios en blanco antes de cada número:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">X-axis-element</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span>
  <span class="s">&#34;Construye un elemento del eje X numerado.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">leading-spaces</span>
         <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
             <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">concat</span> <span class="p">(</span><span class="nf">make-string</span> <span class="nv">leading-spaces</span> <span class="sc">? </span><span class="p">)</span>
            <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">))))</span>
</code></pre>
<p>Lo siguiente, se crea la función para imprimir la línea numerada, empezando con el número “1” para la primera columna:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis-numbered-line</span>
  <span class="p">(</span><span class="nv">number-of-X-tics</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
  <span class="s">&#34;Imprime la líneas de números del eje X&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;1&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">concat</span>
             <span class="p">(</span><span class="nf">make-string</span>
              <span class="c1">;; Inserta espacios en blanco al siguiente número.</span>
              <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
              <span class="sc">? </span><span class="p">)</span>
             <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">number</span><span class="p">)))</span>
    <span class="c1">;; Insertar números.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-X-tics</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nv">X-axis-element</span> <span class="nv">number</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-X-tics</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-X-tics</span><span class="p">)))))</span>
</code></pre>
<p>Finalmente, se necesita escribir lo que <code>print-X-axis</code> que usa <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>.</p>
<p>La función debe determinar los valores locales de las variables usadas por <code>print-X-axis-tic-line</code> y <code>print-X-axis-numbered-line</code>, y entonces eso debe llamarlas. También, debe imprimir el retorno de carro que separe las dos líneas.</p>
<p>La función consiste de una varlist que especifica cinco variables locales, y llama cada una de las dos líneas imprimiendo funciones:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;Imprime el eje X etique al tamaño de NUMBERS-LIST.&#34;</span>
  <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">leading-spaces</span>
          <span class="p">(</span><span class="nf">make-string</span> <span class="nv">full-Y-label-width</span> <span class="sc">? </span><span class="p">))</span>
       <span class="c1">;; symbol-width @e{se provee por} graph-body-print</span>
       <span class="p">(</span><span class="nv">tic-width</span> <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">X-length</span> <span class="p">(</span><span class="nf">length</span> <span class="nv">numbers-list</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">X-tic</span>
        <span class="p">(</span><span class="nf">concat</span>
         <span class="p">(</span><span class="nf">make-string</span>
          <span class="c1">;; Crea una cadena de espacios en blanco.</span>
          <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">length</span> <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
          <span class="sc">? </span><span class="p">)</span>
         <span class="c1">;; Concatena espacio en blanco con símbolos</span>
         <span class="nv">tic.</span>
         <span class="nv">X-axis-tic-symbol</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">tic-number</span>
        <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">/</span> <span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">1+</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">X-length</span> <span class="nv">tic-width</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nv">print-X-axis-tic-line</span> <span class="nv">tic-number</span> <span class="nv">leading-spaces</span> <span class="nv">X-tic</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">print-X-axis-numbered-line</span> <span class="nv">tic-number</span> <span class="nv">leading-spaces</span><span class="p">)))</span>
</code></pre>
<p>Se puede testear <code>print-X-axis</code>:</p>
<ul>
<li>
<p>Instale <code>X-axis-tic-symbol</code>, <code>X-axis-label-spacing</code>, <code>print-X-axis-tic-line</code>, tanto como <code>X-axis-element</code>, <code>print-X-axis-numbered-line</code>, y <code>print-X-axis</code>.</p>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">progn</span>
 <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">full-Y-label-width</span> <span class="mi">5</span><span class="p">)</span>
       <span class="p">(</span><span class="nv">symbol-width</span> <span class="mi">1</span><span class="p">))</span>
   <span class="p">(</span><span class="nv">print-X-axis</span>
    <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span><span class="p">))))</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li>
<p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pegue la expresión de test dentro del minibuffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá el eje horizontal así</p>
<div class="example-block" >
<pre class="example" >|   |    |    |    |
1   5   10   15   20
</pre>
</div>
</div>
<h3 id="imprimiendo-el-grafo-completo" >Imprimiendo el grafo completo</h3>
<div class="hBody-3" >
<p>Ahora estamos listos para imprimir el grafo completo.</p>
<p>La función para imprimir el grafo con las etiquetas apropiadas sigue el esquema que creamos antes (Vease Sección <a href="Un-Grafo-con-Ejes-Etiquetados" >Un Grafo con Ejes Etiquetados</a>), pero con adiciones.</p>
<p>Aquí está el esquema:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span> <span class="p">(</span><span class="nv">numbers-list</span><span class="p">)</span>
  <span class="s">&#34;@V{documentation}…&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">height</span>  <span class="err">…</span>
        <span class="err">…</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">print-Y-axis</span> <span class="nv">height</span> <span class="err">…</span> <span class="p">)</span>
    <span class="p">(</span><span class="nv">graph-body-print</span> <span class="nv">numbers-list</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">print-X-axis</span> <span class="err">…</span> <span class="p">)))</span>
</code></pre>
<p>La versión final es diferente desde que se planea en dos caminos: primero, contiene los valores adicionales calculadas una vez que en la varlist; segundo, eso trae una opción para específicar las etiquetas se incrementa la fila. Esta última funcionalidad cambia a ser esencial; de otro modo, un grafo puede tener más filas que ajustarse en una muestra o en una hoja de papel.</p>
<p>Esta nueva funcionalidad requiere un cambio a la función <code>Y-axis-column</code>, para añadir <code>vertical-step</code> para eso. Esta función es parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Final.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">Y-axis-column</span>
  <span class="p">(</span><span class="nv">height</span> <span class="nv">width-of-label</span> <span class="kp">&amp;optional</span> <span class="nv">vertical-step</span><span class="p">)</span>
  <span class="s">&#34;Construye una lista de etiquetas para el eje Y.
</span><span class="s">HEIGHT es la máxima altura del grafo.
</span><span class="s">WIDTH-OF-LABEL es el máximo ancho de la etiqueta.
</span><span class="s">VERTICAL-STEP, una opción, es un entero positivo
</span><span class="s">que especifica cuanto una etiqueta de eje Y incrementa
</span><span class="s">cada línea. Por ejemplo, un paso de 5
</span><span class="s">significa que cada línea es cinco unidades
</span><span class="s">del grafo.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">Y-axis</span>
        <span class="p">(</span><span class="nv">number-per-line</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">vertical-step</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">height</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">if</span> <span class="p">(</span><span class="nv">zerop</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">height</span> <span class="nv">Y-axis-label-spacing</span><span class="p">))</span>
          <span class="c1">;; Inserta etiqueta.</span>
          <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
                <span class="p">(</span><span class="nf">cons</span>
                 <span class="p">(</span><span class="nv">Y-axis-element</span>
                  <span class="p">(</span><span class="nf">*</span> <span class="nv">height</span> <span class="nv">number-per-line</span><span class="p">)</span>
                  <span class="nv">width-of-label</span><span class="p">)</span>
                 <span class="nv">Y-axis</span><span class="p">))</span>
        <span class="c1">;; Else, inserta espacios en blanco.</span>
        <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span>
              <span class="p">(</span><span class="nf">cons</span>
               <span class="p">(</span><span class="nf">make-string</span> <span class="nv">width-of-label</span> <span class="sc">? </span><span class="p">)</span>
               <span class="nv">Y-axis</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">height</span><span class="p">)))</span>
    <span class="c1">;; Inserta línea base.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">Y-axis</span> <span class="p">(</span><span class="nf">cons</span> <span class="p">(</span><span class="nv">Y-axis-element</span>
                        <span class="p">(</span><span class="nb">or</span> <span class="nv">vertical-step</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="nv">width-of-label</span><span class="p">)</span>
                       <span class="nv">Y-axis</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">Y-axis</span><span class="p">)))</span>
</code></pre>
<p>Los valores para la máxima altura del grafo y el ancho de un símbolo se computan por <code>print-graph</code> es su expresión <code>let</code>; así <code>graph-body-print</code> debe ser cambiado para aceptarlos.</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Final.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">graph-body-print</span> <span class="p">(</span><span class="nv">numbers-list</span> <span class="nv">height</span> <span class="nv">symbol-width</span><span class="p">)</span>
  <span class="s">&#34;Imprime una gráfica de barras del NUMBERS-LIST.
</span><span class="s">El numbers-list consiste en los valores del eje Y.
</span><span class="s">HEIGHT es la máxisma altura del grafo.
</span><span class="s">SYMBOL-WIDTH es el número de cada columna.&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">(</span><span class="nv">from-position</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">while</span> <span class="nv">numbers-list</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">from-position</span> <span class="p">(</span><span class="nf">point</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">insert-rectangle</span>
       <span class="p">(</span><span class="nv">column-of-graph</span> <span class="nv">height</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">numbers-list</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">goto-char</span> <span class="nv">from-position</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">forward-char</span> <span class="nv">symbol-width</span><span class="p">)</span>
      <span class="c1">;; Dibuja el grafo columna por columna.</span>
      <span class="p">(</span><span class="nv">sit-for</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">numbers-list</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">numbers-list</span><span class="p">)))</span>
    <span class="c1">;; Posiciona el punto para las etiquetas del eje X.</span>
    <span class="p">(</span><span class="nf">forward-line</span> <span class="nv">height</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="s">&#34;\n&#34;</span><span class="p">)))</span>
</code></pre>
<p>Finalmente, el código para la función <code>print-graph</code>:</p>
<pre class="code" ><code class="chroma" ><span class="c1">;;; Versión Final.</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span>
  <span class="p">(</span><span class="nv">numbers-list</span> <span class="kp">&amp;optional</span> <span class="nv">vertical-step</span><span class="p">)</span>
  <span class="s">&#34;El gráfico de barras etiquetadas del NUMBERS-LIST.
</span><span class="s">El numbers-list consiste en los valores de eje Y.
</span><span class="s">
</span><span class="s">Opcionalmente, VERTICAL-STEP, un entero positivo, especifica cuanto el
</span><span class="s">eje Y incrementa cada línea. Por ejemplo, un paso de 5
</span><span class="s">significa que cada fila es de cinco unidades.
</span><span class="s">  (let* ((symbol-width (length graph-blank))
</span><span class="s">         ;; @c{height} @e{en ambos es el número más largo}
</span><span class="s">         ;; y el número con la mayoría de los digitos.
</span><span class="s">         (height (apply &#39;max numbers-list))
</span><span class="s">         (height-of-top-line
</span><span class="s">          (if (zerop (% height Y-axis-label-spacing))
</span><span class="s">              height
</span><span class="s">            ;; else
</span><span class="s">            (* (1+ (/ height Y-axis-label-spacing))
</span><span class="s">               Y-axis-label-spacing)))
</span><span class="s">         (vertical-step (or vertical-step 1))
</span><span class="s">         (full-Y-label-width
</span><span class="s">          (length
</span><span class="s">           (concat
</span><span class="s">            (number-to-string
</span><span class="s">             (* height-of-top-line vertical-step))
</span><span class="s">            Y-axis-tic))))
</span><span class="s">
</span><span class="s">    (print-Y-axis
</span><span class="s">     height-of-top-line full-Y-label-width vertical-step)
</span><span class="s">    (graph-body-print
</span><span class="s">     numbers-list height-of-top-line symbol-width)
</span><span class="s">    (print-X-axis numbers-list)))
</span><span class="s"></span></code></pre>
</div>
<h5 id="testeando-print-graph" >Testeando <code>print-graph</code></h5>
<div class="hBody-5" >
<p>Se puede chequear la función <code>print-graph</code> con una lista ordenada de números:</p>
<ul>
<li>
<p>Instala las versiones finales de <code>Y-axis-column</code>, <code>graph-body-print</code>, y <code>print-graph</code> (además del resto del código.)</p>
</li>
<li>
<p>Copia la siguiente expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-graph</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
</li>
<li>
<p>Cambia al búfer <span class="file" >*scratch*</span> y emplaza el cursor donde se quiere el eje etiquetado para empezar.</p>
</li>
<li>
<p>Escribe <kbd>M::</kbd> (<code>eval-expression</code>).</p>
</li>
<li>
<p>Pegue la expresión de test dentro del minibuffer con <kbd>C-y</kbd> (<code>yank</code>).</p>
</li>
<li>
<p>Presiona <kbd>RET</kbd> para evaluar la expresión</p>
</li>
</ul>
<p>Emacs imprimirá un grafo que se parece a:</p>
<div class="example-block" >
<pre class="example" >10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
</pre>
</div>
<p>Por otro lado, si se pasa a <code>print-graph</code> un <code>vertical-step</code> valor de 2, evaluando esta expresión:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-graph</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>El grafo se parece a esto:</p>
<div class="example-block" >
<pre class="example" >20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
</pre>
</div>
<p>(Una pregunta: ¿es el ‘2’ debajo del eje vertical un error o una funcionalidad? Si se piensa que es un error, y sería un ‘1’, (o incluso un ‘0’), se pueden modificar las fuentes.)</p>
</div>
<h5 id="creando-gráficas-de-números-de-palabras-y-símbolos" >Creando gráficas de números de palabras y símbolos</h5>
<div class="hBody-5" >
<p>Ahora para el gráfico para el que todo este código fué escrito: un gráfico que muestra cuantas definiciones de función contienen unas pocas 10 palabras y símbolos, cuantas contienen entre 10 y 19 palabras y símbolos, cuantos contienen entre 20 y 29 palabras y símbolos, y así.</p>
<p>Esto es un proceso de múltiples pasos. Primero asegúrate que has cargado todo el requisito del código.</p>
<p>Eso es una buena idea para eliminar el valor de <code>top-of-ranges</code> en caso de que has asignado a algún valor diferente. Se puede evaluar lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">top-of-ranges</span>
 <span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span>  <span class="mi">20</span>  <span class="mi">30</span>  <span class="mi">40</span>  <span class="mi">50</span>
   <span class="mi">60</span>  <span class="mi">70</span>  <span class="mi">80</span>  <span class="mi">90</span> <span class="mi">100</span>
  <span class="mi">110</span> <span class="mi">120</span> <span class="mi">130</span> <span class="mi">140</span> <span class="mi">150</span>
  <span class="mi">160</span> <span class="mi">170</span> <span class="mi">180</span> <span class="mi">190</span> <span class="mi">200</span>
  <span class="mi">210</span> <span class="mi">220</span> <span class="mi">230</span> <span class="mi">240</span> <span class="mi">250</span>
  <span class="mi">260</span> <span class="mi">270</span> <span class="mi">280</span> <span class="mi">290</span> <span class="mi">300</span><span class="p">)</span>
</code></pre>
<p>Lo siguiente crea una lista del número de palabras y símbolos en cada rango.</p>
<p>Evalúa lo siguiente:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">list-for-graph</span>
       <span class="p">(</span><span class="nv">defuns-per-range</span>
         <span class="p">(</span><span class="nf">sort</span>
          <span class="p">(</span><span class="nv">recursive-lengths-list-many-files</span>
           <span class="p">(</span><span class="nf">directory-files</span> <span class="s">&#34;/usr/local/emacs/lisp&#34;</span>
                            <span class="no">t</span> <span class="s">&#34;.+el$&#34;</span><span class="p">))</span>
          <span class="ss">&#39;&lt;</span><span class="p">)</span>
         <span class="nv">top-of-ranges</span><span class="p">))</span>
</code></pre>
<p>En mi vieja máquina, esto lleva como una hora. Se parece a 303 ficheros Lisp en mi copia de Emacs version 19.23. Después de toda esta computación, el <code>list-for-graph</code> tenía este valor:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">537</span> <span class="mi">1027</span> <span class="mi">955</span> <span class="mi">785</span> <span class="mi">594</span> <span class="mi">483</span> <span class="mi">349</span> <span class="mi">292</span> <span class="mi">224</span> <span class="mi">199</span> <span class="mi">166</span> <span class="mi">120</span> <span class="mi">116</span> <span class="mi">99</span>
<span class="mi">90</span> <span class="mi">80</span> <span class="mi">67</span> <span class="mi">48</span> <span class="mi">52</span> <span class="mi">45</span> <span class="mi">41</span> <span class="mi">33</span> <span class="mi">28</span> <span class="mi">26</span> <span class="mi">25</span> <span class="mi">20</span> <span class="mi">12</span> <span class="mi">28</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">220</span><span class="p">)</span>
</code></pre>
<p>Esto significa que mi copia de Emacs tiene 537 definiciones de funciones con poco menos de 10 palabras o símbolos en sí, 1027 definiciones de función con 10 a 19 palabras o símbolos dentro, 955 definiciones de función con 20 a 29 palabras o símbolos dentro, y así.</p>
<p>Claramente, solo buscando esta lista se puede ver que la mayoría de definiciones de función contienen de diez a treinta palabras y símbolos.</p>
<p>Ahora para imprimir. Nosotros <em>no</em> queremos imprimir un grafo que es de 1030 líneas de alto …. En vez de eso, imprimiría un grafo que es mejor que venticinco líneas de alto. Un grafo cuya altura puede ser mostrada en casi cualquier monitor, y fácilmente impreso en una hoja de papel.</p>
<p>Esto significa que cada valor en <code>list-for-graph</code> debe ser reducido a un quinceavo de su valor presente.</p>
<p>Aquí hay una corta función para hacer esto, usando dos funciones que no se han visto todavía, <code>mapcar</code> y <code>lambda</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">one-fiftieth</span> <span class="p">(</span><span class="nv">full-range</span><span class="p">)</span>
  <span class="s">&#34;Devuelve la lista, con el cincuenteavo de cada elemento.&#34;</span>
 <span class="p">(</span><span class="nf">mapcar</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span> <span class="nv">full-range</span><span class="p">))</span>
</code></pre>
</div>
<h5 id="una-expresión-lambda:-anonimicidad-útil" >Una expresión <code>lambda</code>: Anonimicidad útil</h5>
<div class="hBody-5" >
<p><code>lambda</code> es el símbolo para una función anónima, una función sin un nombre. Cada vez que se use una función anónima, se necesita incluir su cuerpo completo.</p>
<p>De este modo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span>
</code></pre>
<p>es una definición de función que dice ‘devuelve el valor resultante de dividir cualquier cosa que es pasada como <code>arg</code> por 50’.</p>
<p>Pronto, por ejemplo, se tenía una función <code>multiply-by-seven</code>; se multiplica su argumento por 7. Esta función es similar, excepto que divide su argumento por 50; y, no tiene nombre. El equivalente anónimo de <code>multiply-by-seven</code> es:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">number</span><span class="p">)</span> <span class="p">(</span><span class="nf">*</span> <span class="mi">7</span> <span class="nv">number</span><span class="p">))</span>
</code></pre>
<p>(Vea la Seccion <a href="La-forma-especial-defun" >La forma especial <code>defun</code></a>.)</p>
<p>Si queremos multiplicar 3 por 7, podemos escribir:</p>
<div class="art-block" >
<pre class="art" >(multiply-by-seven 3)
 \_______________/ ^
         |         |
      función  argumento
</pre>
</div>
<p>Esta expresión devuelve 21.</p>
<p>De manera similar, se puede escribir:</p>
<div class="art-block" >
<pre class="art" >((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      función anónima     argumento
</pre>
</div>
<p>Si queremos dividir 100 por 50, se puede escribir:</p>
<div class="art-block" >
<pre class="art" >((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
     función anónima   argumento
</pre>
</div>
<p>Esta expresión devuelve 2. El 100 es pasado para la función, que divide este número por 50.</p>
<p>Vea la Seccion <q>Expresiones Lambda</q> en <em>El Manual de Referencia GNU Emacs Lisp</em>, para más acerca de <code>lambda</code>. Lisp y expresiones Lambda se derivan del Cálculo Lambda.</p>
</div>
<h4 id="la-función-mapcar" >La función <code>mapcar</code></h4>
<div class="hBody-4" >
<p><code>mapcar</code> es una función que llama a su primer argumento con cada elemento de su segundo argumento. El segundo argumento debe ser una secuencia.</p>
<p>La parte <samp>map</samp> del nombre viene de la frase matemática, ‘mapeando a través de un dominio’, significa hace apply a una función a cada uno de los elementos en un dominio. La frase matemática está basada en la metáfora de un superviviente paseando, un paso en un momento, a través de un área él está mapeando. Y <samp>car</samp>, de acuerdo, viene desde la noción Lisp del primero de una lista.</p>
<p>Por ejemplo,</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mapcar</span> <span class="ss">&#39;1+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">))</span>
     <span class="err">⇒</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span><span class="p">)</span>
</code></pre>
<p>La función <code>1+</code> añade uno a su argumento, es ejecutada en <em>each</em> de la lista, y una nueva lista es devuelta.</p>
<p>En contraste con esto <code>apply</code>, se aplica su primer argumento a todo lo que permanece. (Vea la Seccion <a href="Leyendo-un-grafo" >Leyendo un grafo</a>, para una explicación de <code>apply</code>.)</p>
<p>En la definición de <code>one-fiftieth</code>, el primer argumento es la función anónima:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span>
</code></pre>
<p>y el segundo argumento es <code>full-range</code>, que será asociado para <code>list-for-graph</code>.</p>
<p>La expresión completa se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nf">mapcar</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">arg</span><span class="p">)</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">arg</span> <span class="mi">50</span><span class="p">))</span> <span class="nv">full-range</span><span class="p">))</span>
</code></pre>
<p>Vea la Seccion <q>Mapeando Funciones</q> en <em>El Manual de Referencia de GNU Emacs Lisp</em>, para más acerca de <code>mapcar</code>.</p>
<p>Usando la función <code>one-fiftieth</code>, se puede generar una lista en el que cada elemento es un cincuenteavo del tamaño del correspondiente elemento en <code>list-for-graph</code>.</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">setq</span> <span class="nv">fiftieth-list-for-graph</span>
      <span class="p">(</span><span class="nv">one-fiftieth</span> <span class="nv">list-for-graph</span><span class="p">))</span>
</code></pre>
<p>La lista resultante se parece a esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">19</span> <span class="mi">15</span> <span class="mi">11</span> <span class="mi">9</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">4</span><span class="p">)</span>
</code></pre>
<p>Así, ¡ya estamos casi listos para imprimir!  (También se notifica la pérdida de información: muchos de los rangos superiores son 0, esto significa que menos de 50 funciones tenían muchas palabras o símbolos––pero no necesariamente significando que niguna tenía muchas palabras o símbolos.)</p>
</div>
<h5 id="otro-error-…-más-insidioso" >Otro error … más insidioso</h5>
<div class="hBody-5" >
<p>¡Se dijo ‘casi listo para imprimir’! De acuerdo, hay un error en la función <code>print-graph</code> …. Esta tiene una opción <code>vertical-step</code>, pero no una opción <code>horizontal-step</code>. La escala <code>top-of-range</code> va desde 10 a 300 por decenas. Pero la función <code>print-graph</code> imprimirá solo uno por uno.</p>
<p>Esto es un ejemplo clásico de lo que algunos consideramos el tipo más insidioso de error, el error de omisión. Este no es el tipo de error que se puede encontrar estudiando el código, para eso no es el código; es una funcionalidad omitida. Tus mejores acciones son probar tu programa pronto y con frecuencia; e intentar poner en orden, tanto como se pueda, escribir código que sea fácil de comprender y fácil de cambiar. Intenta ser consciente, siempre y cuando se pueda, esto es siempre que tengas que escribir, <em>será</em> reescrito, si no pronto, eventualmente. Un máximo duro de seguir.</p>
<p>Esta es la función <code>print-X-axis-numbered-line</code> que necesita el trabajo; y entonces el <code>print-X-axis</code> y la función <code>print-graph</code> necesita ser adaptada. No se necesita mucho para ser hecho; hay uno simpático: los números podrían alinearse con marcas de tic. Esto toma un pequeño pensamiento.</p>
<p>Aquí está el <code>print-X-axis-numbered-line</code> corregido:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis-numbered-line</span>
  <span class="p">(</span><span class="nv">number-of-X-tics</span> <span class="nv">X-axis-leading-spaces</span>
   <span class="kp">&amp;optional</span> <span class="nv">horizontal-step</span><span class="p">)</span>
  <span class="s">&#34;Imprime la líneas de números X-axis&#34;</span>
  <span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">horizontal-step</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">horizontal-step</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="nv">X-axis-leading-spaces</span><span class="p">)</span>
    <span class="c1">;; Elimina espacios extra de guía.</span>
    <span class="p">(</span><span class="nf">delete-char</span>
     <span class="p">(</span><span class="nf">-</span> <span class="p">(</span><span class="nf">1-</span>
         <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">horizontal-step</span><span class="p">)))))</span>
    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">concat</span>
             <span class="p">(</span><span class="nf">make-string</span>
              <span class="c1">;; Inserta espacio en blanco.</span>
              <span class="p">(</span><span class="nf">-</span>  <span class="p">(</span><span class="nf">*</span> <span class="nv">symbol-width</span>
                     <span class="nv">X-axis-label-spacing</span><span class="p">)</span>
                  <span class="p">(</span><span class="nf">1-</span>
                   <span class="p">(</span><span class="nf">length</span>
                    <span class="p">(</span><span class="nf">number-to-string</span> <span class="nv">horizontal-step</span><span class="p">)))</span>
                  <span class="mi">2</span><span class="p">)</span>
              <span class="sc">? </span><span class="p">)</span>
             <span class="p">(</span><span class="nf">number-to-string</span>
              <span class="p">(</span><span class="nf">*</span> <span class="nv">number</span> <span class="nv">horizontal-step</span><span class="p">))))</span>
    <span class="c1">;; Insertar los números que permanecen.</span>
    <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">while</span> <span class="p">(</span><span class="nf">&gt;</span> <span class="nv">number-of-X-tics</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nv">X-axis-element</span>
               <span class="p">(</span><span class="nf">*</span> <span class="nv">number</span> <span class="nv">horizontal-step</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">number</span> <span class="nv">X-axis-label-spacing</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setq</span> <span class="nv">number-of-X-tics</span> <span class="p">(</span><span class="nf">1-</span> <span class="nv">number-of-X-tics</span><span class="p">)))))</span>
</code></pre>
<p>Si se está leyendo esto en Info, se pueden ver las nuevas versiones <code>print-X-axis</code> y <code>print-graph</code> y los evaluarlas. Si se está leyendo esto en un libro impreso, se pueden ver las líneas cambiadas aquí (el texto completo es mucho para imprimir).</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nb">defun</span> <span class="nv">print-X-axis</span> <span class="p">(</span><span class="nv">numbers-list</span> <span class="nv">horizontal-step</span><span class="p">)</span>
  <span class="err">…</span>
    <span class="p">(</span><span class="nv">print-X-axis-numbered-line</span>
     <span class="nv">tic-number</span> <span class="nv">leading-spaces</span> <span class="nv">horizontal-step</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-graph</span>
  <span class="p">(</span><span class="nv">numbers-list</span>
   <span class="kp">&amp;optional</span> <span class="nv">vertical-step</span> <span class="nv">horizontal-step</span><span class="p">)</span>
  <span class="err">…</span>
    <span class="p">(</span><span class="nv">print-X-axis</span> <span class="nv">numbers-list</span> <span class="nv">horizontal-step</span><span class="p">))</span>
</code></pre>
</div>
<h5 id="el-gráfico-impreso" >El gráfico impreso</h5>
<div class="hBody-5" >
<p>Cuando esté hecho e instalado, se puede llamar al comando <code>print-graph</code> como esto:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">print-graph</span> <span class="nv">fiftieth-list-for-graph</span> <span class="mi">50</span> <span class="mi">10</span><span class="p">)</span>
</code></pre>
<p>Aquí está el gráfico:</p>
<div class="example-block" >
<pre class="example" >1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
</pre>
</div>
<p>El grupo largo de funciones contienen de 10 a 19 palabras y símbolos.</p>
</div>
<h3 id="apéndice-d-software-libre-y-manuales-libres-por-richard-m.-stallman" >Apéndice D Software Libre y Manuales Libres (<b>por Richard M. Stallman</b>)</h3>
<div class="hBody-3" >
<p>La mayor deficiencia en sistemas operativos libres no está en el software––es la falta de buenos manuales libres que se puedan incluir en estos sistemas. Muchos de nuestros programas más importantes no vienen con manuales completos. La documentación es una parte esencial de cualquier paquete de software; cuando un paquete de software libre no viene con un manual libre, es una brecha mayor. Nosotros tenemos muchas brechas hoy.</p>
<p>Érase una vez, hace muchos años, se piensa que aprendería Perl. Se tiene una copia de un manual libre, pero se encontró difícil de leer. Cuando pregunto a los usuarios de Perl acerca de alternativas, me contaron que serían mejor los manuales introductorios––pero estos no eran libres.</p>
<p>¿Por qué era esto? Los autores de los buenos manuales los habían escrito para O&#39;Reilly Associates, que los publicaron con términos restrictivos––no copiando, no modificando, los ficheros fuentes están disponibles––que los excluyen desde la comunidad de software libre.</p>
<p>No era la primera vez que esto ocurría, y (para nuestra comunidad es una gran pérdida) eso está lejos desde el último. Las editoriales de manuales privativos han logrado que muchos autores restrinjan sus manuales desde entonces. Muchas veces se ha oido que un usuario de GNU hábil me cuente que un manual que está escribiendo, con el que él espera ayudar al proyecto GNU––y entonces tenía mis esperanzas frustradas, como se ha procedió a explicar que él tenía que haber firmado un contrato con una editorial que restringiría eso, así que no puede usarlo.</p>
<p>Debido a que escribir buen inglés es una habilidad rara entre programadores, se pueden perder manuales por este motivo.</p>
<p>La documentación, como el software, es una cuestión de libertad, no de precio. El problema con estos manuales no eran que O&#39;Reilly Associates impusiera un precio por las copias impresas––que en sí estaban bien. La Free Software Foundation <em>Fundación por el Software Libre</em> <a href="http://shop.fsf.org,-vende-copias-impresas" >http://shop.fsf.org, vende copias impresas</a> de <a href="http://www.gnu.org/doc/doc.html,-manuales-libres-de-GNU" >http://www.gnu.org/doc/doc.html, manuales libres de GNU</a>, también. Pero los manuales de GNU están disponibles en forma de código fuente, mientras que estos manuales están disponibles solo en papel. Los manuales de GNU vienen con permiso para copiar y modificar; los manuales de Perl no. Estas restricciones son un problema.</p>
<p>El criterio para un manual libre es parecido al del software libre: es una cuestión de dar a todos los usuarios ciertas libertades. La redistribución (incluyendo redistribución comercial) debe ser permitida, así el manual puede acompañar cada copia del programa, en líne o en papel. El permiso para modificar es crucial también.</p>
<p>Como regla general, no se cree que sea esencial para la gente tener permisos para modificar todas las partes de artículos y libro. Las cuestiones para escritos no son necesariamente las mismas como estas para el software. Por ejemplo, no se sabe si se está obligado a dar permisos para modificar artículos como este, que describen nuestras acciones y nuestras vistas.</p>
<p>Pero hay una razón particular de por qué la libertad de modificar es crucial para la documentación de software libre. Cuando las personas ejercita su derecho a modificar el software, y añadir o cambiar sus funcionalidades, si son consciente ellos cambiarán el manual también––así se puede proveer documentación usable y cuidada con el programa modificado. Un manual que prohibe a los programadores ser consciente y finalizar el trabajo, o más precisamente requiere escribir un nuevo manual desde cero si ellos cambian el programa, no se ajusta a las necesidades de nuestra comunidad.</p>
<p>Mientras una serie de prohibiciones en la modificación es inaceptable, algunos tipos de límites en el método de modificar no tiene tanto problema. Por ejemplo, los requisitos para preservar la noticia de autores del copyright, los términos de distribución, o la lista de autores, estén ok. Eso es también no da problemas para requerir versiones modificadas para incluir notificar que fueron modificadas, incluso tienen secciones enteras que puede no ser eliminadas o cambiadas, tan largo como estas secciones tratan con asuntos no técnicos. (Algunos manuales de GNU los tienen).</p>
<p>Estos tipos de restricciones no son un problema porque, como materia práctica, no para al programador consciente desde la adaptación del manual para ajustar el programa modificado. En otras palabras, no se bloquea la comunidad del software libre haciendo el uso completo del manual.</p>
<p>Sin embargo, debe ser posible modificar todo el contenido técnico del manual, y entonces se distribuye el resultado en todos los medios usuales, a través de todos los canales usuales; de otro modo, las restricciones bloquean la comunidad, el manual no es libre, y así no se necesita otro manual.</p>
<p>Desafortunadamente, con frecuencia es duro encontrar a alguien a escribir otro manual cuando un manual privativo. El obstáculo es que muchos usuario piensan que un manual privativo es suficientemente bueno––así ellos no ven la necesidad de escribir un manual libre. Ellos no ven que el sistema operativo tiene un gazapo que necesita se rellenado.</p>
<p>¿Por qué los usuarios piensan que los manuales privativos son suficientemente buenos? Algunos no han considerado la cuestión. Espero que este artículo hará alguna cosa para cambiar esto.</p>
<p>Otros usuarios considera manuales privativos aceptables para la misma razón así muchas personas software privativo aceptable: ellos judgan en términos puramente prácticos, no usando la liberta como un criterio. Estas personas son tituladas a sus opiniones, pero desde que estas opciones crezcan desde valores que no incluyen libertad, ellas no están guiadas por esto quienes valoran la libertad.</p>
<p>Por favor, populariza esta cuestión. Se continúa a perder manuales para publicación privativa. Si se populariza que los manuales privativos no son suficientes, quizás la siguiente persona que quiere ayudar a GNU escribiendo documentación realizará, antes de que sea demasiado tarde, lo que él debe que todo sea libre.</p>
<p>Se puede también animar editoriales comerciales a vender manuales libres o con copyleft en vez de uno privativo. Un camino que se puede ayudar esto chequea los términos de la distribución de un manual antes de que se compre, y preferimos manuales copyleft a los no copyleft.</p>
<p>Note: La Fundación para el Software Libre mantiene una página en su sitio Web que liste libros libres disponibles desde otras editoriales: <a href="http://www.gnu.org/doc/other-free-books.html" >http://www.gnu.org/doc/other-free-books.html</a></p>
</div>
<h2 id="appendix-e-gnu-free-documentation-license" >Appendix E GNU Free Documentation License</h2>
<div class="hBody-2" >
<div class="center" >
<p>Version 1.3, 3 November 2008</p>
</div>
<p>Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</p>
<p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>
</div>
<h3 id="0.-preamble" >0. PREAMBLE</h3>
<div class="hBody-3" >
<p>The purpose of this License is to make a manual, textbook, or other functional and useful document &#34;free&#34; in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</p>
<p>This License is a kind of &#34;copyleft&#34;, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software.</p>
<p>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.</p>
</div>
<h3 id="1.-applicability-and-definitions" >1. APPLICABILITY AND DEFINITIONS</h3>
<div class="hBody-3" >
<p>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The &#34;Document&#34;, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as &#34;you&#34;. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</p>
<p>A &#34;Modified Version&#34; of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</p>
<p>A &#34;Secondary Section&#34; is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document&#39;s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject.  (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.)  The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</p>
<p>The &#34;Invariant Sections&#34; are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none.</p>
<p>The &#34;Cover Texts&#34; are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</p>
<p>A &#34;Transparent&#34; copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not &#34;Transparent&#34; is called &#34;Opaque&#34;.</p>
<p>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.</p>
<p>The &#34;Title Page&#34; means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, &#34;Title Page&#34; means the text near the most prominent appearance of the work&#39;s title, preceding the beginning of the body of the text.</p>
<p>The &#34;publisher&#34; means any person or entity that distributes copies of the Document to the public.</p>
<p>A section &#34;Entitled XYZ&#34; means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language.  (Here XYZ stands for a specific section name mentioned below, such as &#34;Acknowledgements&#34;, &#34;Dedications&#34;, &#34;Endorsements&#34;, or &#34;History&#34;.)  To &#34;Preserve the Title&#34; of such a section when you modify the Document means that it remains a section &#34;Entitled XYZ&#34; according to this definition.</p>
<p>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</p>
</div>
<h3 id="2.-verbatim-copying" >2. VERBATIM COPYING</h3>
<div class="hBody-3" >
<p>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3.</p>
<p>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</p>
</div>
<h3 id="3.-copying-in-quantity" >3. COPYING IN QUANTITY</h3>
<div class="hBody-3" >
<p>If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document&#39;s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</p>
<p>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</p>
<p>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</p>
<p>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</p>
</div>
<h3 id="4.-modifications" >4. MODIFICATIONS</h3>
<div class="hBody-3" >
<p>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:</p>
<ol class="alpha" >
<li>
<p>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.</p>
</li>
<li>
<p>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.</p>
</li>
<li>
<p>State on the Title page the name of the publisher of the Modified Version, as the publisher.</p>
</li>
<li>
<p>Preserve all the copyright notices of the Document.</p>
</li>
<li>
<p>Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.</p>
</li>
<li>
<p>Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.</p>
</li>
<li>
<p>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document&#39;s license notice.</p>
</li>
<li>
<p>Include an unaltered copy of this License.</p>
</li>
<li>
<p>Preserve the section Entitled &#34;History&#34;, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled &#34;History&#34; in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.</p>
</li>
<li>
<p>Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the &#34;History&#34; section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.</p>
</li>
<li>
<p>For any section Entitled &#34;Acknowledgements&#34; or &#34;Dedications&#34;, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.</p>
</li>
<li>
<p>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.</p>
</li>
<li>
<p>Delete any section Entitled &#34;Endorsements&#34;. Such a section may not be included in the Modified Version.</p>
</li>
<li>
<p>Do not retitle any existing section to be Entitled &#34;Endorsements&#34; or to conflict in title with any Invariant Section.</p>
</li>
<li>
<p>Preserve any Warranty Disclaimers.</p>
</li>
</ol>
<p>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version&#39;s license notice. These titles must be distinct from any other section titles.</p>
<p>You may add a section Entitled &#34;Endorsements&#34;, provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</p>
<p>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</p>
</div>
<h3 id="5.-combining-documents" >5. COMBINING DOCUMENTS</h3>
<div class="hBody-3" >
<p>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</p>
<p>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</p>
<p>In the combination, you must combine any sections Entitled &#34;History&#34; in the various original documents, forming one section Entitled &#34;History&#34;; likewise combine any sections Entitled &#34;Acknowledgements&#34;, and any sections Entitled &#34;Dedications&#34;. You must delete all sections Entitled &#34;Endorsements&#34;.</p>
</div>
<h3 id="6.-collections-of-documents" >6. COLLECTIONS OF DOCUMENTS</h3>
<div class="hBody-3" >
<p>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</p>
<p>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</p>
</div>
<h3 id="7.-aggregation-with-independent-works" >7. AGGREGATION WITH INDEPENDENT WORKS</h3>
<div class="hBody-3" >
<p>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an &#34;aggregate&#34; if the copyright resulting from the compilation is not used to limit the legal rights of the compilation&#39;s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.</p>
<p>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document&#39;s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.</p>
</div>
<h3 id="8.-translation" >8. TRANSLATION</h3>
<div class="hBody-3" >
<p>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</p>
<p>If a section in the Document is Entitled &#34;Acknowledgements&#34;, &#34;Dedications&#34;, or &#34;History&#34;, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.</p>
</div>
<h3 id="9.-termination" >9. TERMINATION</h3>
<div class="hBody-3" >
<p>You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.</p>
<p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p>
<p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p>
<p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.</p>
</div>
<h3 id="10.-future-revisions-of-this-license" >10. FUTURE REVISIONS OF THIS LICENSE</h3>
<div class="hBody-3" >
<p>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/.</p>
<p>Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License &#34;or any later version&#34; applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy&#39;s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.</p>
</div>
<h3 id="11.-relicensing" >11. RELICENSING</h3>
<div class="hBody-3" >
<p>&#34;Massive Multiauthor Collaboration Site&#34; (or &#34;MMC Site&#34;) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A &#34;Massive Multiauthor Collaboration&#34; (or &#34;MMC&#34;) contained in the site means any set of copyrightable works thus published on the MMC site.</p>
<p>&#34;CC-BY-SA&#34; means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.</p>
<p>&#34;Incorporate&#34; means to publish or republish a Document, in whole or in part, as part of another Document.</p>
<p>An MMC is &#34;eligible for relicensing&#34; if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.</p>
<p>The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.</p>
</div>
<h2 id="addendum:-how-to-use-this-license-for-your-documents" >ADDENDUM: How to use this License for your documents</h2>
<div class="hBody-2" >
<p>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</p>
<div class="pre-block" >
<pre class="pre" >Copyright (c)  YEAR  YOUR NAME.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled &#34;GNU
Free Documentation License&#34;.
</pre>
</div>
<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the &#34;with...Texts.&#34; line with this:</p>
<div class="pre-block" >
<pre class="pre" >with the Invariant Sections being LIST THEIR TITLES, with the
Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
</pre>
</div>
<p>If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.</p>
<p>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</p>
</div>
<h3 id="acerca-del-autor" >Acerca del Autor</h3>
<div class="hBody-3" >
<p>Robert J. Chassell ha trabajado con GNU Emacs desde 1985. Él escribe, edita y enseña Emacs y Emacs Lisp, y habla alrededor del mundo acerca de la libertad del software. Chassell es Director fundador y Tesorero de la Fundación por el Software Libre (FSF). Él se graduó la Universidad de Cambridge, en Inglaterra. Él tiene un interés contínuo en historia económica y social y vuela su propio aeroplano</p>
</div>
<h2 id="footnotes" >footnotes</h2>
<div class="hBody-2" >
<div class="about" >
<div class="about-dt" ><span class="defnote" id="1" >1</span></div>
<div class="about-dd" >
<p>El apóstrofo o comilla es una abreviación para la función <code>quote</code>; no es necesario pensar en las funciones ahora; las funciones se definen en la Seccion <a href="Generar-un-mensaje-de-error" >Generar un mensaje de error</a>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="2" >2</span></div>
<div class="about-dd" >
<p>Es curioso seguir el camino por el que la palabra ‘argumento’ llego a tener dos significados distintos, uno en matemáticas y otro en el inglés cotidiano. De acuerdo al <em>Oxford English Dictionary</em>, la palabra deriva del Latín para <samp>dejar claro, probar</samp>; por lo tanto, paso a significar, por un hilo de derivación, ‘la evidencia ofrecida como prueba’, es decir ‘la informacion que se ofrece’, que conduce a su significado en Lisp. Pero en el otro hilo de la derivación, paso a significar ‘afirmar de una manera contra la cual otros pueden hacer afirmaciones contrarias’, lo que llevó al significado de la palabra como disputa. (Tenga en cuenta que la palabra Inglésa tiene dos definiciones distintas al mismo tiempo. En contraste, en Emacs Lisp, un símbolo no puede tener dos definiciones de funcion diferentes al mismo tiempo.)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="3" >3</span></div>
<div class="about-dd" >
<p><code>(quote hola)</code> es una expansión de la abreviatura <code>&#39;hola</code>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="4" >4</span></div>
<div class="about-dd" >
<p>En realidad, puede utilizar <code>%s</code> para imprimir un número. No es específico. <code>%d</code> solo imprime la parte de un número a la izquierda del punto decimal, excluyendo cualquier cosa que no sea un número.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="5" >5</span></div>
<div class="about-dd" >
<p>En realidad, por defecto, si el búfer desde el que acabas de cambiar es visible por tí en otra ventana, <code>other-buffer</code> elegirá el búfer más reciente que no puedas ver; esta es una sutileza que a menudo olvido.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="6" >6</span></div>
<div class="about-dd" >
<p>O mejor dicho, para evitar escribir, probablemente solo necesites pulsar <kbd>RET</kbd> si <span class="file" >*scratch*</span> es el buffer por defecto, de ser diferente, solo escribe parte del nombre, por ejemplo <code>*sc</code>, luego presiona la tecla <kbd>TAB</kbd> para hacer que se expanda el nombre completo, y finalmente pulsa <kbd>RET</kbd>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="7" >7</span></div>
<div class="about-dd" >
<p>Recuerda, esta expresión te desplaza al buffer diferente más reciente que no puedas ver. Si realmente quieres ir al ultimo búfer seleccionado, incluso si es visible, es necesario evaluar la siguiente expresión más compleja:</p>
<pre class="code" ><code class="chroma" ><span class="p">(</span><span class="nv">switch-to-buffer</span> <span class="p">(</span><span class="nf">other-buffer</span> <span class="p">(</span><span class="nf">current-buffer</span><span class="p">)</span> <span class="no">t</span><span class="p">))</span>
</code></pre>
<p>En este caso, el primer argumento de <code>other-buffer</code> le dice a que búfer saltar––el actual––y el segundo argumento <code>other-buffer</code> le indica que esta BIEN cambiar a un búfer visible. La utilidad de <code>switch-to-buffer</code> es llevarte a una ventana invisible ya que probablemente usarias <kbd>C-x o</kbd> (<code>other-window</code>) para ir a otro búfer visible.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="8" >8</span></div>
<div class="about-dd" >
<p>Segun Jared Diamond en <em>Guns, Germs, and Steel</em>, “… las cebras se vuelven increiblemente peligrosas a medida que envejecen” pero la afirmacion aquí es que no llegan a ser feroces como un tigre. (1997, W. W. Norton and Co., ISBN 0-393-03894-2, pagina 171)</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="9" >9</span></div>
<div class="about-dd" >
<p>Actualmente, se puede <code>cons</code> un elemento para un átomo para producir a para punteado. Los pares punteados no se discuten aquí; ver Seccion &#34;Notación de Para Punteado&#34; en <em>El Manual de Referencia de GNU Emacs Lisp</em>.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="10" >10</span></div>
<div class="about-dd" >
<p>Más precisamente, y requiriendo conocimiento más experto para entender, los dos enteros son del tipo ‘Lisp_Object’, que también puede ser una unión C en lugar de un tipo entero.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="11" >11</span></div>
<div class="about-dd" >
<p>Se pueden escribir funciones recursivas para ser frugal o basura mental o recursos de ordenador; como eso ocurre, los métodos que la gente encuentra fáciles––son frugales de ‘recursos mentales’––algunas veces usan recursos de ordenador considerables. Emacs fué diseñado para ejecutarse en máquinas que ahora se consideran limitadas y sus configuraciones por defecto son conservadoras. Se puede querer incrementar los valores de <code>max-specdl-size</code> y <code>max-lisp-eval-depth</code>. En mi fichero <span class="file" >.emacs</span>, yo los asigno a 15 o 30 veces su valor por defecto.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="12" >12</span></div>
<div class="about-dd" >
<p>La frase <dfn>cola recursiva</dfn> es usado para describir tal proceso, uno que usa ‘espacio constante’.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="13" >13</span></div>
<div class="about-dd" >
<p>La jerga es medianamente confusa: <code>triangle-recursive-helper</code> usa un proceso que es iterativo en un procedimiento que es recursivo. El proceso se llama iterativo porque el ordenador necesita solo grabar los tres valores, <code>suma</code>, <code>contador</code>, y <code>número</code>: el procedimiento es recursivo porque la función ‘llama a sí mismo’. Por otro lado, ambos el proceso y el procedimiento usado por <code>triangle-recursively</code> son llamados recursivos. La palabra ‘recursivo’ tiene diferentes significados en los dos contextos.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="14" >14</span></div>
<div class="about-dd" >
<p>Tu puedes también añadir <span class="file" >.el</span> para <span class="file" >~/.emacs</span> y llama a un fichero <span class="file" >~/.emacs</span>. En el pasado, fué prohibido escribir los atajos de teclado extra que el nombre <span class="file" >~/.emacs.el</span> requiere, pero ahora puedes. El nuevo formato es consistente con las conveniciones de nombre del fichero Emacs Lisp; el viejo formato guarda la escritura.</p>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="15" >15</span></div>
<div class="about-dd" >
<p>Cuando se empiezan las instancias de Emacs que no cargan mi fichero <span class="file" >.emacs</span> o cualquier fichero, también se puede deshabilitar la ocultación:</p>
<div class="example-block" >
<pre class="example" >emacs -q --no-site-file -eval
&#39;(blink-cursor-mode nil)&#39; @exdent O ahora, usando un conjunto más
sofisticado de opciones, emacs -Q - D
</pre>
</div>
</div>
</div>
<div class="about" >
<div class="about-dt" ><span class="defnote" id="16" >16</span></div>
<div class="about-dd" >
<p>también se ejecutan gestores de ventanas más modernos, tales como Enlightenment, Gnome, o KDE; en estos casos, con frecuencia se especifica una imagen en vez de un color plano.</p>
</div>
</div>
</div>
</body>
</html>
